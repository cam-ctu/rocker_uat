
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:39:51.303] plan(): Setting new future strategy stack:
[17:39:51.304] List of future strategies:
[17:39:51.304] 1. sequential:
[17:39:51.304]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.304]    - tweaked: FALSE
[17:39:51.304]    - call: future::plan("sequential")
[17:39:51.315] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:39:51.384] plan(): Setting new future strategy stack:
[17:39:51.384] List of future strategies:
[17:39:51.384] 1. sequential:
[17:39:51.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.384]    - tweaked: FALSE
[17:39:51.384]    - call: plan(strategy)
[17:39:51.395] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.396] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.396] Searching for globals...
[17:39:51.403] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.404] Searching for globals ... DONE
[17:39:51.404] Resolving globals: TRUE
[17:39:51.404] Resolving any globals that are futures ...
[17:39:51.404] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.404] Resolving any globals that are futures ... DONE
[17:39:51.405] Resolving futures part of globals (recursively) ...
[17:39:51.405] resolve() on list ...
[17:39:51.405]  recursive: 99
[17:39:51.406]  length: 1
[17:39:51.406]  elements: ‘x’
[17:39:51.406]  length: 0 (resolved future 1)
[17:39:51.406] resolve() on list ... DONE
[17:39:51.406] - globals: [1] ‘x’
[17:39:51.406] Resolving futures part of globals (recursively) ... DONE
[17:39:51.407] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.407] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.407] - globals: [1] ‘x’
[17:39:51.407] 
[17:39:51.407] getGlobalsAndPackages() ... DONE
[17:39:51.408] run() for ‘Future’ ...
[17:39:51.408] - state: ‘created’
[17:39:51.408] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.409] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.409]   - Field: ‘label’
[17:39:51.409]   - Field: ‘local’
[17:39:51.409]   - Field: ‘owner’
[17:39:51.409]   - Field: ‘envir’
[17:39:51.409]   - Field: ‘packages’
[17:39:51.409]   - Field: ‘gc’
[17:39:51.409]   - Field: ‘conditions’
[17:39:51.409]   - Field: ‘expr’
[17:39:51.409]   - Field: ‘uuid’
[17:39:51.410]   - Field: ‘seed’
[17:39:51.410]   - Field: ‘version’
[17:39:51.410]   - Field: ‘result’
[17:39:51.410]   - Field: ‘asynchronous’
[17:39:51.410]   - Field: ‘calls’
[17:39:51.410]   - Field: ‘globals’
[17:39:51.410]   - Field: ‘stdout’
[17:39:51.410]   - Field: ‘earlySignal’
[17:39:51.410]   - Field: ‘lazy’
[17:39:51.410]   - Field: ‘state’
[17:39:51.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.410] - Launch lazy future ...
[17:39:51.411] Packages needed by the future expression (n = 0): <none>
[17:39:51.411] Packages needed by future strategies (n = 0): <none>
[17:39:51.412] {
[17:39:51.412]     {
[17:39:51.412]         {
[17:39:51.412]             ...future.startTime <- base::Sys.time()
[17:39:51.412]             {
[17:39:51.412]                 {
[17:39:51.412]                   {
[17:39:51.412]                     base::local({
[17:39:51.412]                       has_future <- base::requireNamespace("future", 
[17:39:51.412]                         quietly = TRUE)
[17:39:51.412]                       if (has_future) {
[17:39:51.412]                         ns <- base::getNamespace("future")
[17:39:51.412]                         version <- ns[[".package"]][["version"]]
[17:39:51.412]                         if (is.null(version)) 
[17:39:51.412]                           version <- utils::packageVersion("future")
[17:39:51.412]                       }
[17:39:51.412]                       else {
[17:39:51.412]                         version <- NULL
[17:39:51.412]                       }
[17:39:51.412]                       if (!has_future || version < "1.8.0") {
[17:39:51.412]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.412]                           "", base::R.version$version.string), 
[17:39:51.412]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.412]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.412]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.412]                             "release", "version")], collapse = " "), 
[17:39:51.412]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.412]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.412]                           info)
[17:39:51.412]                         info <- base::paste(info, collapse = "; ")
[17:39:51.412]                         if (!has_future) {
[17:39:51.412]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.412]                             info)
[17:39:51.412]                         }
[17:39:51.412]                         else {
[17:39:51.412]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.412]                             info, version)
[17:39:51.412]                         }
[17:39:51.412]                         base::stop(msg)
[17:39:51.412]                       }
[17:39:51.412]                     })
[17:39:51.412]                   }
[17:39:51.412]                   ...future.strategy.old <- future::plan("list")
[17:39:51.412]                   options(future.plan = NULL)
[17:39:51.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.412]                 }
[17:39:51.412]                 ...future.workdir <- getwd()
[17:39:51.412]             }
[17:39:51.412]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.412]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.412]         }
[17:39:51.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.412]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.412]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.412]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.412]             base::names(...future.oldOptions))
[17:39:51.412]     }
[17:39:51.412]     if (FALSE) {
[17:39:51.412]     }
[17:39:51.412]     else {
[17:39:51.412]         if (TRUE) {
[17:39:51.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.412]                 open = "w")
[17:39:51.412]         }
[17:39:51.412]         else {
[17:39:51.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.412]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.412]         }
[17:39:51.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.412]             base::sink(type = "output", split = FALSE)
[17:39:51.412]             base::close(...future.stdout)
[17:39:51.412]         }, add = TRUE)
[17:39:51.412]     }
[17:39:51.412]     ...future.frame <- base::sys.nframe()
[17:39:51.412]     ...future.conditions <- base::list()
[17:39:51.412]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.412]     if (FALSE) {
[17:39:51.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.412]     }
[17:39:51.412]     ...future.result <- base::tryCatch({
[17:39:51.412]         base::withCallingHandlers({
[17:39:51.412]             ...future.value <- base::withVisible(base::local({
[17:39:51.412]                 x$a <- 1
[17:39:51.412]                 x
[17:39:51.412]             }))
[17:39:51.412]             future::FutureResult(value = ...future.value$value, 
[17:39:51.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.412]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.412]                     ...future.globalenv.names))
[17:39:51.412]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.412]         }, condition = base::local({
[17:39:51.412]             c <- base::c
[17:39:51.412]             inherits <- base::inherits
[17:39:51.412]             invokeRestart <- base::invokeRestart
[17:39:51.412]             length <- base::length
[17:39:51.412]             list <- base::list
[17:39:51.412]             seq.int <- base::seq.int
[17:39:51.412]             signalCondition <- base::signalCondition
[17:39:51.412]             sys.calls <- base::sys.calls
[17:39:51.412]             `[[` <- base::`[[`
[17:39:51.412]             `+` <- base::`+`
[17:39:51.412]             `<<-` <- base::`<<-`
[17:39:51.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.412]                   3L)]
[17:39:51.412]             }
[17:39:51.412]             function(cond) {
[17:39:51.412]                 is_error <- inherits(cond, "error")
[17:39:51.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.412]                   NULL)
[17:39:51.412]                 if (is_error) {
[17:39:51.412]                   sessionInformation <- function() {
[17:39:51.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.412]                       search = base::search(), system = base::Sys.info())
[17:39:51.412]                   }
[17:39:51.412]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.412]                     cond$call), session = sessionInformation(), 
[17:39:51.412]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.412]                   signalCondition(cond)
[17:39:51.412]                 }
[17:39:51.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.412]                 "immediateCondition"))) {
[17:39:51.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.412]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.412]                   if (TRUE && !signal) {
[17:39:51.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.412]                     {
[17:39:51.412]                       inherits <- base::inherits
[17:39:51.412]                       invokeRestart <- base::invokeRestart
[17:39:51.412]                       is.null <- base::is.null
[17:39:51.412]                       muffled <- FALSE
[17:39:51.412]                       if (inherits(cond, "message")) {
[17:39:51.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.412]                         if (muffled) 
[17:39:51.412]                           invokeRestart("muffleMessage")
[17:39:51.412]                       }
[17:39:51.412]                       else if (inherits(cond, "warning")) {
[17:39:51.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.412]                         if (muffled) 
[17:39:51.412]                           invokeRestart("muffleWarning")
[17:39:51.412]                       }
[17:39:51.412]                       else if (inherits(cond, "condition")) {
[17:39:51.412]                         if (!is.null(pattern)) {
[17:39:51.412]                           computeRestarts <- base::computeRestarts
[17:39:51.412]                           grepl <- base::grepl
[17:39:51.412]                           restarts <- computeRestarts(cond)
[17:39:51.412]                           for (restart in restarts) {
[17:39:51.412]                             name <- restart$name
[17:39:51.412]                             if (is.null(name)) 
[17:39:51.412]                               next
[17:39:51.412]                             if (!grepl(pattern, name)) 
[17:39:51.412]                               next
[17:39:51.412]                             invokeRestart(restart)
[17:39:51.412]                             muffled <- TRUE
[17:39:51.412]                             break
[17:39:51.412]                           }
[17:39:51.412]                         }
[17:39:51.412]                       }
[17:39:51.412]                       invisible(muffled)
[17:39:51.412]                     }
[17:39:51.412]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.412]                   }
[17:39:51.412]                 }
[17:39:51.412]                 else {
[17:39:51.412]                   if (TRUE) {
[17:39:51.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.412]                     {
[17:39:51.412]                       inherits <- base::inherits
[17:39:51.412]                       invokeRestart <- base::invokeRestart
[17:39:51.412]                       is.null <- base::is.null
[17:39:51.412]                       muffled <- FALSE
[17:39:51.412]                       if (inherits(cond, "message")) {
[17:39:51.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.412]                         if (muffled) 
[17:39:51.412]                           invokeRestart("muffleMessage")
[17:39:51.412]                       }
[17:39:51.412]                       else if (inherits(cond, "warning")) {
[17:39:51.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.412]                         if (muffled) 
[17:39:51.412]                           invokeRestart("muffleWarning")
[17:39:51.412]                       }
[17:39:51.412]                       else if (inherits(cond, "condition")) {
[17:39:51.412]                         if (!is.null(pattern)) {
[17:39:51.412]                           computeRestarts <- base::computeRestarts
[17:39:51.412]                           grepl <- base::grepl
[17:39:51.412]                           restarts <- computeRestarts(cond)
[17:39:51.412]                           for (restart in restarts) {
[17:39:51.412]                             name <- restart$name
[17:39:51.412]                             if (is.null(name)) 
[17:39:51.412]                               next
[17:39:51.412]                             if (!grepl(pattern, name)) 
[17:39:51.412]                               next
[17:39:51.412]                             invokeRestart(restart)
[17:39:51.412]                             muffled <- TRUE
[17:39:51.412]                             break
[17:39:51.412]                           }
[17:39:51.412]                         }
[17:39:51.412]                       }
[17:39:51.412]                       invisible(muffled)
[17:39:51.412]                     }
[17:39:51.412]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.412]                   }
[17:39:51.412]                 }
[17:39:51.412]             }
[17:39:51.412]         }))
[17:39:51.412]     }, error = function(ex) {
[17:39:51.412]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.412]                 ...future.rng), started = ...future.startTime, 
[17:39:51.412]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.412]             version = "1.8"), class = "FutureResult")
[17:39:51.412]     }, finally = {
[17:39:51.412]         if (!identical(...future.workdir, getwd())) 
[17:39:51.412]             setwd(...future.workdir)
[17:39:51.412]         {
[17:39:51.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.412]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.412]             }
[17:39:51.412]             base::options(...future.oldOptions)
[17:39:51.412]             if (.Platform$OS.type == "windows") {
[17:39:51.412]                 old_names <- names(...future.oldEnvVars)
[17:39:51.412]                 envs <- base::Sys.getenv()
[17:39:51.412]                 names <- names(envs)
[17:39:51.412]                 common <- intersect(names, old_names)
[17:39:51.412]                 added <- setdiff(names, old_names)
[17:39:51.412]                 removed <- setdiff(old_names, names)
[17:39:51.412]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.412]                   envs[common]]
[17:39:51.412]                 NAMES <- toupper(changed)
[17:39:51.412]                 args <- list()
[17:39:51.412]                 for (kk in seq_along(NAMES)) {
[17:39:51.412]                   name <- changed[[kk]]
[17:39:51.412]                   NAME <- NAMES[[kk]]
[17:39:51.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.412]                     next
[17:39:51.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.412]                 }
[17:39:51.412]                 NAMES <- toupper(added)
[17:39:51.412]                 for (kk in seq_along(NAMES)) {
[17:39:51.412]                   name <- added[[kk]]
[17:39:51.412]                   NAME <- NAMES[[kk]]
[17:39:51.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.412]                     next
[17:39:51.412]                   args[[name]] <- ""
[17:39:51.412]                 }
[17:39:51.412]                 NAMES <- toupper(removed)
[17:39:51.412]                 for (kk in seq_along(NAMES)) {
[17:39:51.412]                   name <- removed[[kk]]
[17:39:51.412]                   NAME <- NAMES[[kk]]
[17:39:51.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.412]                     next
[17:39:51.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.412]                 }
[17:39:51.412]                 if (length(args) > 0) 
[17:39:51.412]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.412]             }
[17:39:51.412]             else {
[17:39:51.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.412]             }
[17:39:51.412]             {
[17:39:51.412]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.412]                   0L) {
[17:39:51.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.412]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.412]                   base::options(opts)
[17:39:51.412]                 }
[17:39:51.412]                 {
[17:39:51.412]                   {
[17:39:51.412]                     NULL
[17:39:51.412]                     RNGkind("Mersenne-Twister")
[17:39:51.412]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.412]                       inherits = FALSE)
[17:39:51.412]                   }
[17:39:51.412]                   options(future.plan = NULL)
[17:39:51.412]                   if (is.na(NA_character_)) 
[17:39:51.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.412]                     .init = FALSE)
[17:39:51.412]                 }
[17:39:51.412]             }
[17:39:51.412]         }
[17:39:51.412]     })
[17:39:51.412]     if (TRUE) {
[17:39:51.412]         base::sink(type = "output", split = FALSE)
[17:39:51.412]         if (TRUE) {
[17:39:51.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.412]         }
[17:39:51.412]         else {
[17:39:51.412]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.412]         }
[17:39:51.412]         base::close(...future.stdout)
[17:39:51.412]         ...future.stdout <- NULL
[17:39:51.412]     }
[17:39:51.412]     ...future.result$conditions <- ...future.conditions
[17:39:51.412]     ...future.result$finished <- base::Sys.time()
[17:39:51.412]     ...future.result
[17:39:51.412] }
[17:39:51.414] assign_globals() ...
[17:39:51.414] List of 1
[17:39:51.414]  $ x: list()
[17:39:51.414]  - attr(*, "where")=List of 1
[17:39:51.414]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.414]  - attr(*, "resolved")= logi TRUE
[17:39:51.414]  - attr(*, "total_size")= num 0
[17:39:51.414]  - attr(*, "already-done")= logi TRUE
[17:39:51.416] - copied ‘x’ to environment
[17:39:51.416] assign_globals() ... done
[17:39:51.417] plan(): Setting new future strategy stack:
[17:39:51.417] List of future strategies:
[17:39:51.417] 1. sequential:
[17:39:51.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.417]    - tweaked: FALSE
[17:39:51.417]    - call: NULL
[17:39:51.417] plan(): nbrOfWorkers() = 1
[17:39:51.418] plan(): Setting new future strategy stack:
[17:39:51.418] List of future strategies:
[17:39:51.418] 1. sequential:
[17:39:51.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.418]    - tweaked: FALSE
[17:39:51.418]    - call: plan(strategy)
[17:39:51.421] plan(): nbrOfWorkers() = 1
[17:39:51.421] SequentialFuture started (and completed)
[17:39:51.421] - Launch lazy future ... done
[17:39:51.421] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.422] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.422] Searching for globals...
[17:39:51.424] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.424] Searching for globals ... DONE
[17:39:51.424] Resolving globals: TRUE
[17:39:51.424] Resolving any globals that are futures ...
[17:39:51.424] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.424] Resolving any globals that are futures ... DONE
[17:39:51.425] Resolving futures part of globals (recursively) ...
[17:39:51.425] resolve() on list ...
[17:39:51.425]  recursive: 99
[17:39:51.425]  length: 1
[17:39:51.425]  elements: ‘x’
[17:39:51.425]  length: 0 (resolved future 1)
[17:39:51.425] resolve() on list ... DONE
[17:39:51.425] - globals: [1] ‘x’
[17:39:51.425] Resolving futures part of globals (recursively) ... DONE
[17:39:51.426] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.426] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.426] - globals: [1] ‘x’
[17:39:51.426] 
[17:39:51.426] getGlobalsAndPackages() ... DONE
[17:39:51.426] run() for ‘Future’ ...
[17:39:51.426] - state: ‘created’
[17:39:51.427] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.427] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.427]   - Field: ‘label’
[17:39:51.427]   - Field: ‘local’
[17:39:51.427]   - Field: ‘owner’
[17:39:51.427]   - Field: ‘envir’
[17:39:51.427]   - Field: ‘packages’
[17:39:51.427]   - Field: ‘gc’
[17:39:51.428]   - Field: ‘conditions’
[17:39:51.428]   - Field: ‘expr’
[17:39:51.428]   - Field: ‘uuid’
[17:39:51.428]   - Field: ‘seed’
[17:39:51.428]   - Field: ‘version’
[17:39:51.428]   - Field: ‘result’
[17:39:51.428]   - Field: ‘asynchronous’
[17:39:51.428]   - Field: ‘calls’
[17:39:51.428]   - Field: ‘globals’
[17:39:51.428]   - Field: ‘stdout’
[17:39:51.428]   - Field: ‘earlySignal’
[17:39:51.429]   - Field: ‘lazy’
[17:39:51.429]   - Field: ‘state’
[17:39:51.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.429] - Launch lazy future ...
[17:39:51.429] Packages needed by the future expression (n = 0): <none>
[17:39:51.429] Packages needed by future strategies (n = 0): <none>
[17:39:51.429] {
[17:39:51.429]     {
[17:39:51.429]         {
[17:39:51.429]             ...future.startTime <- base::Sys.time()
[17:39:51.429]             {
[17:39:51.429]                 {
[17:39:51.429]                   {
[17:39:51.429]                     base::local({
[17:39:51.429]                       has_future <- base::requireNamespace("future", 
[17:39:51.429]                         quietly = TRUE)
[17:39:51.429]                       if (has_future) {
[17:39:51.429]                         ns <- base::getNamespace("future")
[17:39:51.429]                         version <- ns[[".package"]][["version"]]
[17:39:51.429]                         if (is.null(version)) 
[17:39:51.429]                           version <- utils::packageVersion("future")
[17:39:51.429]                       }
[17:39:51.429]                       else {
[17:39:51.429]                         version <- NULL
[17:39:51.429]                       }
[17:39:51.429]                       if (!has_future || version < "1.8.0") {
[17:39:51.429]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.429]                           "", base::R.version$version.string), 
[17:39:51.429]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.429]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.429]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.429]                             "release", "version")], collapse = " "), 
[17:39:51.429]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.429]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.429]                           info)
[17:39:51.429]                         info <- base::paste(info, collapse = "; ")
[17:39:51.429]                         if (!has_future) {
[17:39:51.429]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.429]                             info)
[17:39:51.429]                         }
[17:39:51.429]                         else {
[17:39:51.429]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.429]                             info, version)
[17:39:51.429]                         }
[17:39:51.429]                         base::stop(msg)
[17:39:51.429]                       }
[17:39:51.429]                     })
[17:39:51.429]                   }
[17:39:51.429]                   ...future.strategy.old <- future::plan("list")
[17:39:51.429]                   options(future.plan = NULL)
[17:39:51.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.429]                 }
[17:39:51.429]                 ...future.workdir <- getwd()
[17:39:51.429]             }
[17:39:51.429]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.429]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.429]         }
[17:39:51.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.429]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.429]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.429]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.429]             base::names(...future.oldOptions))
[17:39:51.429]     }
[17:39:51.429]     if (FALSE) {
[17:39:51.429]     }
[17:39:51.429]     else {
[17:39:51.429]         if (TRUE) {
[17:39:51.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.429]                 open = "w")
[17:39:51.429]         }
[17:39:51.429]         else {
[17:39:51.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.429]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.429]         }
[17:39:51.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.429]             base::sink(type = "output", split = FALSE)
[17:39:51.429]             base::close(...future.stdout)
[17:39:51.429]         }, add = TRUE)
[17:39:51.429]     }
[17:39:51.429]     ...future.frame <- base::sys.nframe()
[17:39:51.429]     ...future.conditions <- base::list()
[17:39:51.429]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.429]     if (FALSE) {
[17:39:51.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.429]     }
[17:39:51.429]     ...future.result <- base::tryCatch({
[17:39:51.429]         base::withCallingHandlers({
[17:39:51.429]             ...future.value <- base::withVisible(base::local({
[17:39:51.429]                 x$a <- 1
[17:39:51.429]                 x
[17:39:51.429]             }))
[17:39:51.429]             future::FutureResult(value = ...future.value$value, 
[17:39:51.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.429]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.429]                     ...future.globalenv.names))
[17:39:51.429]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.429]         }, condition = base::local({
[17:39:51.429]             c <- base::c
[17:39:51.429]             inherits <- base::inherits
[17:39:51.429]             invokeRestart <- base::invokeRestart
[17:39:51.429]             length <- base::length
[17:39:51.429]             list <- base::list
[17:39:51.429]             seq.int <- base::seq.int
[17:39:51.429]             signalCondition <- base::signalCondition
[17:39:51.429]             sys.calls <- base::sys.calls
[17:39:51.429]             `[[` <- base::`[[`
[17:39:51.429]             `+` <- base::`+`
[17:39:51.429]             `<<-` <- base::`<<-`
[17:39:51.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.429]                   3L)]
[17:39:51.429]             }
[17:39:51.429]             function(cond) {
[17:39:51.429]                 is_error <- inherits(cond, "error")
[17:39:51.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.429]                   NULL)
[17:39:51.429]                 if (is_error) {
[17:39:51.429]                   sessionInformation <- function() {
[17:39:51.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.429]                       search = base::search(), system = base::Sys.info())
[17:39:51.429]                   }
[17:39:51.429]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.429]                     cond$call), session = sessionInformation(), 
[17:39:51.429]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.429]                   signalCondition(cond)
[17:39:51.429]                 }
[17:39:51.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.429]                 "immediateCondition"))) {
[17:39:51.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.429]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.429]                   if (TRUE && !signal) {
[17:39:51.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.429]                     {
[17:39:51.429]                       inherits <- base::inherits
[17:39:51.429]                       invokeRestart <- base::invokeRestart
[17:39:51.429]                       is.null <- base::is.null
[17:39:51.429]                       muffled <- FALSE
[17:39:51.429]                       if (inherits(cond, "message")) {
[17:39:51.429]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.429]                         if (muffled) 
[17:39:51.429]                           invokeRestart("muffleMessage")
[17:39:51.429]                       }
[17:39:51.429]                       else if (inherits(cond, "warning")) {
[17:39:51.429]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.429]                         if (muffled) 
[17:39:51.429]                           invokeRestart("muffleWarning")
[17:39:51.429]                       }
[17:39:51.429]                       else if (inherits(cond, "condition")) {
[17:39:51.429]                         if (!is.null(pattern)) {
[17:39:51.429]                           computeRestarts <- base::computeRestarts
[17:39:51.429]                           grepl <- base::grepl
[17:39:51.429]                           restarts <- computeRestarts(cond)
[17:39:51.429]                           for (restart in restarts) {
[17:39:51.429]                             name <- restart$name
[17:39:51.429]                             if (is.null(name)) 
[17:39:51.429]                               next
[17:39:51.429]                             if (!grepl(pattern, name)) 
[17:39:51.429]                               next
[17:39:51.429]                             invokeRestart(restart)
[17:39:51.429]                             muffled <- TRUE
[17:39:51.429]                             break
[17:39:51.429]                           }
[17:39:51.429]                         }
[17:39:51.429]                       }
[17:39:51.429]                       invisible(muffled)
[17:39:51.429]                     }
[17:39:51.429]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.429]                   }
[17:39:51.429]                 }
[17:39:51.429]                 else {
[17:39:51.429]                   if (TRUE) {
[17:39:51.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.429]                     {
[17:39:51.429]                       inherits <- base::inherits
[17:39:51.429]                       invokeRestart <- base::invokeRestart
[17:39:51.429]                       is.null <- base::is.null
[17:39:51.429]                       muffled <- FALSE
[17:39:51.429]                       if (inherits(cond, "message")) {
[17:39:51.429]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.429]                         if (muffled) 
[17:39:51.429]                           invokeRestart("muffleMessage")
[17:39:51.429]                       }
[17:39:51.429]                       else if (inherits(cond, "warning")) {
[17:39:51.429]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.429]                         if (muffled) 
[17:39:51.429]                           invokeRestart("muffleWarning")
[17:39:51.429]                       }
[17:39:51.429]                       else if (inherits(cond, "condition")) {
[17:39:51.429]                         if (!is.null(pattern)) {
[17:39:51.429]                           computeRestarts <- base::computeRestarts
[17:39:51.429]                           grepl <- base::grepl
[17:39:51.429]                           restarts <- computeRestarts(cond)
[17:39:51.429]                           for (restart in restarts) {
[17:39:51.429]                             name <- restart$name
[17:39:51.429]                             if (is.null(name)) 
[17:39:51.429]                               next
[17:39:51.429]                             if (!grepl(pattern, name)) 
[17:39:51.429]                               next
[17:39:51.429]                             invokeRestart(restart)
[17:39:51.429]                             muffled <- TRUE
[17:39:51.429]                             break
[17:39:51.429]                           }
[17:39:51.429]                         }
[17:39:51.429]                       }
[17:39:51.429]                       invisible(muffled)
[17:39:51.429]                     }
[17:39:51.429]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.429]                   }
[17:39:51.429]                 }
[17:39:51.429]             }
[17:39:51.429]         }))
[17:39:51.429]     }, error = function(ex) {
[17:39:51.429]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.429]                 ...future.rng), started = ...future.startTime, 
[17:39:51.429]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.429]             version = "1.8"), class = "FutureResult")
[17:39:51.429]     }, finally = {
[17:39:51.429]         if (!identical(...future.workdir, getwd())) 
[17:39:51.429]             setwd(...future.workdir)
[17:39:51.429]         {
[17:39:51.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.429]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.429]             }
[17:39:51.429]             base::options(...future.oldOptions)
[17:39:51.429]             if (.Platform$OS.type == "windows") {
[17:39:51.429]                 old_names <- names(...future.oldEnvVars)
[17:39:51.429]                 envs <- base::Sys.getenv()
[17:39:51.429]                 names <- names(envs)
[17:39:51.429]                 common <- intersect(names, old_names)
[17:39:51.429]                 added <- setdiff(names, old_names)
[17:39:51.429]                 removed <- setdiff(old_names, names)
[17:39:51.429]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.429]                   envs[common]]
[17:39:51.429]                 NAMES <- toupper(changed)
[17:39:51.429]                 args <- list()
[17:39:51.429]                 for (kk in seq_along(NAMES)) {
[17:39:51.429]                   name <- changed[[kk]]
[17:39:51.429]                   NAME <- NAMES[[kk]]
[17:39:51.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.429]                     next
[17:39:51.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.429]                 }
[17:39:51.429]                 NAMES <- toupper(added)
[17:39:51.429]                 for (kk in seq_along(NAMES)) {
[17:39:51.429]                   name <- added[[kk]]
[17:39:51.429]                   NAME <- NAMES[[kk]]
[17:39:51.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.429]                     next
[17:39:51.429]                   args[[name]] <- ""
[17:39:51.429]                 }
[17:39:51.429]                 NAMES <- toupper(removed)
[17:39:51.429]                 for (kk in seq_along(NAMES)) {
[17:39:51.429]                   name <- removed[[kk]]
[17:39:51.429]                   NAME <- NAMES[[kk]]
[17:39:51.429]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.429]                     next
[17:39:51.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.429]                 }
[17:39:51.429]                 if (length(args) > 0) 
[17:39:51.429]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.429]             }
[17:39:51.429]             else {
[17:39:51.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.429]             }
[17:39:51.429]             {
[17:39:51.429]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.429]                   0L) {
[17:39:51.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.429]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.429]                   base::options(opts)
[17:39:51.429]                 }
[17:39:51.429]                 {
[17:39:51.429]                   {
[17:39:51.429]                     NULL
[17:39:51.429]                     RNGkind("Mersenne-Twister")
[17:39:51.429]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.429]                       inherits = FALSE)
[17:39:51.429]                   }
[17:39:51.429]                   options(future.plan = NULL)
[17:39:51.429]                   if (is.na(NA_character_)) 
[17:39:51.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.429]                     .init = FALSE)
[17:39:51.429]                 }
[17:39:51.429]             }
[17:39:51.429]         }
[17:39:51.429]     })
[17:39:51.429]     if (TRUE) {
[17:39:51.429]         base::sink(type = "output", split = FALSE)
[17:39:51.429]         if (TRUE) {
[17:39:51.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.429]         }
[17:39:51.429]         else {
[17:39:51.429]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.429]         }
[17:39:51.429]         base::close(...future.stdout)
[17:39:51.429]         ...future.stdout <- NULL
[17:39:51.429]     }
[17:39:51.429]     ...future.result$conditions <- ...future.conditions
[17:39:51.429]     ...future.result$finished <- base::Sys.time()
[17:39:51.429]     ...future.result
[17:39:51.429] }
[17:39:51.431] assign_globals() ...
[17:39:51.431] List of 1
[17:39:51.431]  $ x: list()
[17:39:51.431]  - attr(*, "where")=List of 1
[17:39:51.431]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.431]  - attr(*, "resolved")= logi TRUE
[17:39:51.431]  - attr(*, "total_size")= num 0
[17:39:51.431]  - attr(*, "already-done")= logi TRUE
[17:39:51.433] - copied ‘x’ to environment
[17:39:51.433] assign_globals() ... done
[17:39:51.434] plan(): Setting new future strategy stack:
[17:39:51.434] List of future strategies:
[17:39:51.434] 1. sequential:
[17:39:51.434]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.434]    - tweaked: FALSE
[17:39:51.434]    - call: NULL
[17:39:51.434] plan(): nbrOfWorkers() = 1
[17:39:51.435] plan(): Setting new future strategy stack:
[17:39:51.435] List of future strategies:
[17:39:51.435] 1. sequential:
[17:39:51.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.435]    - tweaked: FALSE
[17:39:51.435]    - call: plan(strategy)
[17:39:51.435] plan(): nbrOfWorkers() = 1
[17:39:51.436] SequentialFuture started (and completed)
[17:39:51.436] - Launch lazy future ... done
[17:39:51.436] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.437] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.437] Searching for globals...
[17:39:51.439] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.439] Searching for globals ... DONE
[17:39:51.439] Resolving globals: TRUE
[17:39:51.439] Resolving any globals that are futures ...
[17:39:51.439] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.439] Resolving any globals that are futures ... DONE
[17:39:51.440] Resolving futures part of globals (recursively) ...
[17:39:51.440] resolve() on list ...
[17:39:51.440]  recursive: 99
[17:39:51.440]  length: 1
[17:39:51.440]  elements: ‘x’
[17:39:51.440]  length: 0 (resolved future 1)
[17:39:51.440] resolve() on list ... DONE
[17:39:51.440] - globals: [1] ‘x’
[17:39:51.441] Resolving futures part of globals (recursively) ... DONE
[17:39:51.441] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.441] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.441] - globals: [1] ‘x’
[17:39:51.441] 
[17:39:51.441] getGlobalsAndPackages() ... DONE
[17:39:51.441] run() for ‘Future’ ...
[17:39:51.442] - state: ‘created’
[17:39:51.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.442] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.442]   - Field: ‘label’
[17:39:51.442]   - Field: ‘local’
[17:39:51.442]   - Field: ‘owner’
[17:39:51.442]   - Field: ‘envir’
[17:39:51.443]   - Field: ‘packages’
[17:39:51.443]   - Field: ‘gc’
[17:39:51.443]   - Field: ‘conditions’
[17:39:51.443]   - Field: ‘expr’
[17:39:51.443]   - Field: ‘uuid’
[17:39:51.443]   - Field: ‘seed’
[17:39:51.443]   - Field: ‘version’
[17:39:51.443]   - Field: ‘result’
[17:39:51.443]   - Field: ‘asynchronous’
[17:39:51.443]   - Field: ‘calls’
[17:39:51.443]   - Field: ‘globals’
[17:39:51.443]   - Field: ‘stdout’
[17:39:51.444]   - Field: ‘earlySignal’
[17:39:51.444]   - Field: ‘lazy’
[17:39:51.444]   - Field: ‘state’
[17:39:51.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.444] - Launch lazy future ...
[17:39:51.444] Packages needed by the future expression (n = 0): <none>
[17:39:51.444] Packages needed by future strategies (n = 0): <none>
[17:39:51.445] {
[17:39:51.445]     {
[17:39:51.445]         {
[17:39:51.445]             ...future.startTime <- base::Sys.time()
[17:39:51.445]             {
[17:39:51.445]                 {
[17:39:51.445]                   {
[17:39:51.445]                     base::local({
[17:39:51.445]                       has_future <- base::requireNamespace("future", 
[17:39:51.445]                         quietly = TRUE)
[17:39:51.445]                       if (has_future) {
[17:39:51.445]                         ns <- base::getNamespace("future")
[17:39:51.445]                         version <- ns[[".package"]][["version"]]
[17:39:51.445]                         if (is.null(version)) 
[17:39:51.445]                           version <- utils::packageVersion("future")
[17:39:51.445]                       }
[17:39:51.445]                       else {
[17:39:51.445]                         version <- NULL
[17:39:51.445]                       }
[17:39:51.445]                       if (!has_future || version < "1.8.0") {
[17:39:51.445]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.445]                           "", base::R.version$version.string), 
[17:39:51.445]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.445]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.445]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.445]                             "release", "version")], collapse = " "), 
[17:39:51.445]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.445]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.445]                           info)
[17:39:51.445]                         info <- base::paste(info, collapse = "; ")
[17:39:51.445]                         if (!has_future) {
[17:39:51.445]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.445]                             info)
[17:39:51.445]                         }
[17:39:51.445]                         else {
[17:39:51.445]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.445]                             info, version)
[17:39:51.445]                         }
[17:39:51.445]                         base::stop(msg)
[17:39:51.445]                       }
[17:39:51.445]                     })
[17:39:51.445]                   }
[17:39:51.445]                   ...future.strategy.old <- future::plan("list")
[17:39:51.445]                   options(future.plan = NULL)
[17:39:51.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.445]                 }
[17:39:51.445]                 ...future.workdir <- getwd()
[17:39:51.445]             }
[17:39:51.445]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.445]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.445]         }
[17:39:51.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.445]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.445]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.445]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.445]             base::names(...future.oldOptions))
[17:39:51.445]     }
[17:39:51.445]     if (FALSE) {
[17:39:51.445]     }
[17:39:51.445]     else {
[17:39:51.445]         if (TRUE) {
[17:39:51.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.445]                 open = "w")
[17:39:51.445]         }
[17:39:51.445]         else {
[17:39:51.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.445]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.445]         }
[17:39:51.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.445]             base::sink(type = "output", split = FALSE)
[17:39:51.445]             base::close(...future.stdout)
[17:39:51.445]         }, add = TRUE)
[17:39:51.445]     }
[17:39:51.445]     ...future.frame <- base::sys.nframe()
[17:39:51.445]     ...future.conditions <- base::list()
[17:39:51.445]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.445]     if (FALSE) {
[17:39:51.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.445]     }
[17:39:51.445]     ...future.result <- base::tryCatch({
[17:39:51.445]         base::withCallingHandlers({
[17:39:51.445]             ...future.value <- base::withVisible(base::local({
[17:39:51.445]                 x$a <- 1
[17:39:51.445]                 x
[17:39:51.445]             }))
[17:39:51.445]             future::FutureResult(value = ...future.value$value, 
[17:39:51.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.445]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.445]                     ...future.globalenv.names))
[17:39:51.445]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.445]         }, condition = base::local({
[17:39:51.445]             c <- base::c
[17:39:51.445]             inherits <- base::inherits
[17:39:51.445]             invokeRestart <- base::invokeRestart
[17:39:51.445]             length <- base::length
[17:39:51.445]             list <- base::list
[17:39:51.445]             seq.int <- base::seq.int
[17:39:51.445]             signalCondition <- base::signalCondition
[17:39:51.445]             sys.calls <- base::sys.calls
[17:39:51.445]             `[[` <- base::`[[`
[17:39:51.445]             `+` <- base::`+`
[17:39:51.445]             `<<-` <- base::`<<-`
[17:39:51.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.445]                   3L)]
[17:39:51.445]             }
[17:39:51.445]             function(cond) {
[17:39:51.445]                 is_error <- inherits(cond, "error")
[17:39:51.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.445]                   NULL)
[17:39:51.445]                 if (is_error) {
[17:39:51.445]                   sessionInformation <- function() {
[17:39:51.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.445]                       search = base::search(), system = base::Sys.info())
[17:39:51.445]                   }
[17:39:51.445]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.445]                     cond$call), session = sessionInformation(), 
[17:39:51.445]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.445]                   signalCondition(cond)
[17:39:51.445]                 }
[17:39:51.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.445]                 "immediateCondition"))) {
[17:39:51.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.445]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.445]                   if (TRUE && !signal) {
[17:39:51.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.445]                     {
[17:39:51.445]                       inherits <- base::inherits
[17:39:51.445]                       invokeRestart <- base::invokeRestart
[17:39:51.445]                       is.null <- base::is.null
[17:39:51.445]                       muffled <- FALSE
[17:39:51.445]                       if (inherits(cond, "message")) {
[17:39:51.445]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.445]                         if (muffled) 
[17:39:51.445]                           invokeRestart("muffleMessage")
[17:39:51.445]                       }
[17:39:51.445]                       else if (inherits(cond, "warning")) {
[17:39:51.445]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.445]                         if (muffled) 
[17:39:51.445]                           invokeRestart("muffleWarning")
[17:39:51.445]                       }
[17:39:51.445]                       else if (inherits(cond, "condition")) {
[17:39:51.445]                         if (!is.null(pattern)) {
[17:39:51.445]                           computeRestarts <- base::computeRestarts
[17:39:51.445]                           grepl <- base::grepl
[17:39:51.445]                           restarts <- computeRestarts(cond)
[17:39:51.445]                           for (restart in restarts) {
[17:39:51.445]                             name <- restart$name
[17:39:51.445]                             if (is.null(name)) 
[17:39:51.445]                               next
[17:39:51.445]                             if (!grepl(pattern, name)) 
[17:39:51.445]                               next
[17:39:51.445]                             invokeRestart(restart)
[17:39:51.445]                             muffled <- TRUE
[17:39:51.445]                             break
[17:39:51.445]                           }
[17:39:51.445]                         }
[17:39:51.445]                       }
[17:39:51.445]                       invisible(muffled)
[17:39:51.445]                     }
[17:39:51.445]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.445]                   }
[17:39:51.445]                 }
[17:39:51.445]                 else {
[17:39:51.445]                   if (TRUE) {
[17:39:51.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.445]                     {
[17:39:51.445]                       inherits <- base::inherits
[17:39:51.445]                       invokeRestart <- base::invokeRestart
[17:39:51.445]                       is.null <- base::is.null
[17:39:51.445]                       muffled <- FALSE
[17:39:51.445]                       if (inherits(cond, "message")) {
[17:39:51.445]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.445]                         if (muffled) 
[17:39:51.445]                           invokeRestart("muffleMessage")
[17:39:51.445]                       }
[17:39:51.445]                       else if (inherits(cond, "warning")) {
[17:39:51.445]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.445]                         if (muffled) 
[17:39:51.445]                           invokeRestart("muffleWarning")
[17:39:51.445]                       }
[17:39:51.445]                       else if (inherits(cond, "condition")) {
[17:39:51.445]                         if (!is.null(pattern)) {
[17:39:51.445]                           computeRestarts <- base::computeRestarts
[17:39:51.445]                           grepl <- base::grepl
[17:39:51.445]                           restarts <- computeRestarts(cond)
[17:39:51.445]                           for (restart in restarts) {
[17:39:51.445]                             name <- restart$name
[17:39:51.445]                             if (is.null(name)) 
[17:39:51.445]                               next
[17:39:51.445]                             if (!grepl(pattern, name)) 
[17:39:51.445]                               next
[17:39:51.445]                             invokeRestart(restart)
[17:39:51.445]                             muffled <- TRUE
[17:39:51.445]                             break
[17:39:51.445]                           }
[17:39:51.445]                         }
[17:39:51.445]                       }
[17:39:51.445]                       invisible(muffled)
[17:39:51.445]                     }
[17:39:51.445]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.445]                   }
[17:39:51.445]                 }
[17:39:51.445]             }
[17:39:51.445]         }))
[17:39:51.445]     }, error = function(ex) {
[17:39:51.445]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.445]                 ...future.rng), started = ...future.startTime, 
[17:39:51.445]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.445]             version = "1.8"), class = "FutureResult")
[17:39:51.445]     }, finally = {
[17:39:51.445]         if (!identical(...future.workdir, getwd())) 
[17:39:51.445]             setwd(...future.workdir)
[17:39:51.445]         {
[17:39:51.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.445]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.445]             }
[17:39:51.445]             base::options(...future.oldOptions)
[17:39:51.445]             if (.Platform$OS.type == "windows") {
[17:39:51.445]                 old_names <- names(...future.oldEnvVars)
[17:39:51.445]                 envs <- base::Sys.getenv()
[17:39:51.445]                 names <- names(envs)
[17:39:51.445]                 common <- intersect(names, old_names)
[17:39:51.445]                 added <- setdiff(names, old_names)
[17:39:51.445]                 removed <- setdiff(old_names, names)
[17:39:51.445]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.445]                   envs[common]]
[17:39:51.445]                 NAMES <- toupper(changed)
[17:39:51.445]                 args <- list()
[17:39:51.445]                 for (kk in seq_along(NAMES)) {
[17:39:51.445]                   name <- changed[[kk]]
[17:39:51.445]                   NAME <- NAMES[[kk]]
[17:39:51.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.445]                     next
[17:39:51.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.445]                 }
[17:39:51.445]                 NAMES <- toupper(added)
[17:39:51.445]                 for (kk in seq_along(NAMES)) {
[17:39:51.445]                   name <- added[[kk]]
[17:39:51.445]                   NAME <- NAMES[[kk]]
[17:39:51.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.445]                     next
[17:39:51.445]                   args[[name]] <- ""
[17:39:51.445]                 }
[17:39:51.445]                 NAMES <- toupper(removed)
[17:39:51.445]                 for (kk in seq_along(NAMES)) {
[17:39:51.445]                   name <- removed[[kk]]
[17:39:51.445]                   NAME <- NAMES[[kk]]
[17:39:51.445]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.445]                     next
[17:39:51.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.445]                 }
[17:39:51.445]                 if (length(args) > 0) 
[17:39:51.445]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.445]             }
[17:39:51.445]             else {
[17:39:51.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.445]             }
[17:39:51.445]             {
[17:39:51.445]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.445]                   0L) {
[17:39:51.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.445]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.445]                   base::options(opts)
[17:39:51.445]                 }
[17:39:51.445]                 {
[17:39:51.445]                   {
[17:39:51.445]                     NULL
[17:39:51.445]                     RNGkind("Mersenne-Twister")
[17:39:51.445]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.445]                       inherits = FALSE)
[17:39:51.445]                   }
[17:39:51.445]                   options(future.plan = NULL)
[17:39:51.445]                   if (is.na(NA_character_)) 
[17:39:51.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.445]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.445]                     .init = FALSE)
[17:39:51.445]                 }
[17:39:51.445]             }
[17:39:51.445]         }
[17:39:51.445]     })
[17:39:51.445]     if (TRUE) {
[17:39:51.445]         base::sink(type = "output", split = FALSE)
[17:39:51.445]         if (TRUE) {
[17:39:51.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.445]         }
[17:39:51.445]         else {
[17:39:51.445]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.445]         }
[17:39:51.445]         base::close(...future.stdout)
[17:39:51.445]         ...future.stdout <- NULL
[17:39:51.445]     }
[17:39:51.445]     ...future.result$conditions <- ...future.conditions
[17:39:51.445]     ...future.result$finished <- base::Sys.time()
[17:39:51.445]     ...future.result
[17:39:51.445] }
[17:39:51.446] assign_globals() ...
[17:39:51.446] List of 1
[17:39:51.446]  $ x: list()
[17:39:51.446]  - attr(*, "where")=List of 1
[17:39:51.446]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.446]  - attr(*, "resolved")= logi TRUE
[17:39:51.446]  - attr(*, "total_size")= num 0
[17:39:51.446]  - attr(*, "already-done")= logi TRUE
[17:39:51.450] - copied ‘x’ to environment
[17:39:51.450] assign_globals() ... done
[17:39:51.450] plan(): Setting new future strategy stack:
[17:39:51.450] List of future strategies:
[17:39:51.450] 1. sequential:
[17:39:51.450]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.450]    - tweaked: FALSE
[17:39:51.450]    - call: NULL
[17:39:51.451] plan(): nbrOfWorkers() = 1
[17:39:51.451] plan(): Setting new future strategy stack:
[17:39:51.451] List of future strategies:
[17:39:51.451] 1. sequential:
[17:39:51.451]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.451]    - tweaked: FALSE
[17:39:51.451]    - call: plan(strategy)
[17:39:51.452] plan(): nbrOfWorkers() = 1
[17:39:51.452] SequentialFuture started (and completed)
[17:39:51.452] - Launch lazy future ... done
[17:39:51.452] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.453] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.453] Searching for globals...
[17:39:51.455] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.455] Searching for globals ... DONE
[17:39:51.455] Resolving globals: TRUE
[17:39:51.455] Resolving any globals that are futures ...
[17:39:51.455] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.455] Resolving any globals that are futures ... DONE
[17:39:51.455] Resolving futures part of globals (recursively) ...
[17:39:51.456] resolve() on list ...
[17:39:51.456]  recursive: 99
[17:39:51.456]  length: 1
[17:39:51.456]  elements: ‘x’
[17:39:51.456]  length: 0 (resolved future 1)
[17:39:51.456] resolve() on list ... DONE
[17:39:51.456] - globals: [1] ‘x’
[17:39:51.456] Resolving futures part of globals (recursively) ... DONE
[17:39:51.456] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.457] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.457] - globals: [1] ‘x’
[17:39:51.457] 
[17:39:51.457] getGlobalsAndPackages() ... DONE
[17:39:51.457] run() for ‘Future’ ...
[17:39:51.457] - state: ‘created’
[17:39:51.458] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.458] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.458]   - Field: ‘label’
[17:39:51.458]   - Field: ‘local’
[17:39:51.458]   - Field: ‘owner’
[17:39:51.458]   - Field: ‘envir’
[17:39:51.458]   - Field: ‘packages’
[17:39:51.458]   - Field: ‘gc’
[17:39:51.458]   - Field: ‘conditions’
[17:39:51.459]   - Field: ‘expr’
[17:39:51.459]   - Field: ‘uuid’
[17:39:51.459]   - Field: ‘seed’
[17:39:51.459]   - Field: ‘version’
[17:39:51.459]   - Field: ‘result’
[17:39:51.459]   - Field: ‘asynchronous’
[17:39:51.459]   - Field: ‘calls’
[17:39:51.459]   - Field: ‘globals’
[17:39:51.459]   - Field: ‘stdout’
[17:39:51.459]   - Field: ‘earlySignal’
[17:39:51.459]   - Field: ‘lazy’
[17:39:51.459]   - Field: ‘state’
[17:39:51.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.460] - Launch lazy future ...
[17:39:51.460] Packages needed by the future expression (n = 0): <none>
[17:39:51.460] Packages needed by future strategies (n = 0): <none>
[17:39:51.460] {
[17:39:51.460]     {
[17:39:51.460]         {
[17:39:51.460]             ...future.startTime <- base::Sys.time()
[17:39:51.460]             {
[17:39:51.460]                 {
[17:39:51.460]                   {
[17:39:51.460]                     base::local({
[17:39:51.460]                       has_future <- base::requireNamespace("future", 
[17:39:51.460]                         quietly = TRUE)
[17:39:51.460]                       if (has_future) {
[17:39:51.460]                         ns <- base::getNamespace("future")
[17:39:51.460]                         version <- ns[[".package"]][["version"]]
[17:39:51.460]                         if (is.null(version)) 
[17:39:51.460]                           version <- utils::packageVersion("future")
[17:39:51.460]                       }
[17:39:51.460]                       else {
[17:39:51.460]                         version <- NULL
[17:39:51.460]                       }
[17:39:51.460]                       if (!has_future || version < "1.8.0") {
[17:39:51.460]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.460]                           "", base::R.version$version.string), 
[17:39:51.460]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.460]                             "release", "version")], collapse = " "), 
[17:39:51.460]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.460]                           info)
[17:39:51.460]                         info <- base::paste(info, collapse = "; ")
[17:39:51.460]                         if (!has_future) {
[17:39:51.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.460]                             info)
[17:39:51.460]                         }
[17:39:51.460]                         else {
[17:39:51.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.460]                             info, version)
[17:39:51.460]                         }
[17:39:51.460]                         base::stop(msg)
[17:39:51.460]                       }
[17:39:51.460]                     })
[17:39:51.460]                   }
[17:39:51.460]                   ...future.strategy.old <- future::plan("list")
[17:39:51.460]                   options(future.plan = NULL)
[17:39:51.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.460]                 }
[17:39:51.460]                 ...future.workdir <- getwd()
[17:39:51.460]             }
[17:39:51.460]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.460]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.460]         }
[17:39:51.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.460]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.460]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.460]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.460]             base::names(...future.oldOptions))
[17:39:51.460]     }
[17:39:51.460]     if (FALSE) {
[17:39:51.460]     }
[17:39:51.460]     else {
[17:39:51.460]         if (TRUE) {
[17:39:51.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.460]                 open = "w")
[17:39:51.460]         }
[17:39:51.460]         else {
[17:39:51.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.460]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.460]         }
[17:39:51.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.460]             base::sink(type = "output", split = FALSE)
[17:39:51.460]             base::close(...future.stdout)
[17:39:51.460]         }, add = TRUE)
[17:39:51.460]     }
[17:39:51.460]     ...future.frame <- base::sys.nframe()
[17:39:51.460]     ...future.conditions <- base::list()
[17:39:51.460]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.460]     if (FALSE) {
[17:39:51.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.460]     }
[17:39:51.460]     ...future.result <- base::tryCatch({
[17:39:51.460]         base::withCallingHandlers({
[17:39:51.460]             ...future.value <- base::withVisible(base::local({
[17:39:51.460]                 x$a <- 1
[17:39:51.460]                 x
[17:39:51.460]             }))
[17:39:51.460]             future::FutureResult(value = ...future.value$value, 
[17:39:51.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.460]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.460]                     ...future.globalenv.names))
[17:39:51.460]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.460]         }, condition = base::local({
[17:39:51.460]             c <- base::c
[17:39:51.460]             inherits <- base::inherits
[17:39:51.460]             invokeRestart <- base::invokeRestart
[17:39:51.460]             length <- base::length
[17:39:51.460]             list <- base::list
[17:39:51.460]             seq.int <- base::seq.int
[17:39:51.460]             signalCondition <- base::signalCondition
[17:39:51.460]             sys.calls <- base::sys.calls
[17:39:51.460]             `[[` <- base::`[[`
[17:39:51.460]             `+` <- base::`+`
[17:39:51.460]             `<<-` <- base::`<<-`
[17:39:51.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.460]                   3L)]
[17:39:51.460]             }
[17:39:51.460]             function(cond) {
[17:39:51.460]                 is_error <- inherits(cond, "error")
[17:39:51.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.460]                   NULL)
[17:39:51.460]                 if (is_error) {
[17:39:51.460]                   sessionInformation <- function() {
[17:39:51.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.460]                       search = base::search(), system = base::Sys.info())
[17:39:51.460]                   }
[17:39:51.460]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.460]                     cond$call), session = sessionInformation(), 
[17:39:51.460]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.460]                   signalCondition(cond)
[17:39:51.460]                 }
[17:39:51.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.460]                 "immediateCondition"))) {
[17:39:51.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.460]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.460]                   if (TRUE && !signal) {
[17:39:51.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.460]                     {
[17:39:51.460]                       inherits <- base::inherits
[17:39:51.460]                       invokeRestart <- base::invokeRestart
[17:39:51.460]                       is.null <- base::is.null
[17:39:51.460]                       muffled <- FALSE
[17:39:51.460]                       if (inherits(cond, "message")) {
[17:39:51.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.460]                         if (muffled) 
[17:39:51.460]                           invokeRestart("muffleMessage")
[17:39:51.460]                       }
[17:39:51.460]                       else if (inherits(cond, "warning")) {
[17:39:51.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.460]                         if (muffled) 
[17:39:51.460]                           invokeRestart("muffleWarning")
[17:39:51.460]                       }
[17:39:51.460]                       else if (inherits(cond, "condition")) {
[17:39:51.460]                         if (!is.null(pattern)) {
[17:39:51.460]                           computeRestarts <- base::computeRestarts
[17:39:51.460]                           grepl <- base::grepl
[17:39:51.460]                           restarts <- computeRestarts(cond)
[17:39:51.460]                           for (restart in restarts) {
[17:39:51.460]                             name <- restart$name
[17:39:51.460]                             if (is.null(name)) 
[17:39:51.460]                               next
[17:39:51.460]                             if (!grepl(pattern, name)) 
[17:39:51.460]                               next
[17:39:51.460]                             invokeRestart(restart)
[17:39:51.460]                             muffled <- TRUE
[17:39:51.460]                             break
[17:39:51.460]                           }
[17:39:51.460]                         }
[17:39:51.460]                       }
[17:39:51.460]                       invisible(muffled)
[17:39:51.460]                     }
[17:39:51.460]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.460]                   }
[17:39:51.460]                 }
[17:39:51.460]                 else {
[17:39:51.460]                   if (TRUE) {
[17:39:51.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.460]                     {
[17:39:51.460]                       inherits <- base::inherits
[17:39:51.460]                       invokeRestart <- base::invokeRestart
[17:39:51.460]                       is.null <- base::is.null
[17:39:51.460]                       muffled <- FALSE
[17:39:51.460]                       if (inherits(cond, "message")) {
[17:39:51.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.460]                         if (muffled) 
[17:39:51.460]                           invokeRestart("muffleMessage")
[17:39:51.460]                       }
[17:39:51.460]                       else if (inherits(cond, "warning")) {
[17:39:51.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.460]                         if (muffled) 
[17:39:51.460]                           invokeRestart("muffleWarning")
[17:39:51.460]                       }
[17:39:51.460]                       else if (inherits(cond, "condition")) {
[17:39:51.460]                         if (!is.null(pattern)) {
[17:39:51.460]                           computeRestarts <- base::computeRestarts
[17:39:51.460]                           grepl <- base::grepl
[17:39:51.460]                           restarts <- computeRestarts(cond)
[17:39:51.460]                           for (restart in restarts) {
[17:39:51.460]                             name <- restart$name
[17:39:51.460]                             if (is.null(name)) 
[17:39:51.460]                               next
[17:39:51.460]                             if (!grepl(pattern, name)) 
[17:39:51.460]                               next
[17:39:51.460]                             invokeRestart(restart)
[17:39:51.460]                             muffled <- TRUE
[17:39:51.460]                             break
[17:39:51.460]                           }
[17:39:51.460]                         }
[17:39:51.460]                       }
[17:39:51.460]                       invisible(muffled)
[17:39:51.460]                     }
[17:39:51.460]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.460]                   }
[17:39:51.460]                 }
[17:39:51.460]             }
[17:39:51.460]         }))
[17:39:51.460]     }, error = function(ex) {
[17:39:51.460]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.460]                 ...future.rng), started = ...future.startTime, 
[17:39:51.460]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.460]             version = "1.8"), class = "FutureResult")
[17:39:51.460]     }, finally = {
[17:39:51.460]         if (!identical(...future.workdir, getwd())) 
[17:39:51.460]             setwd(...future.workdir)
[17:39:51.460]         {
[17:39:51.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.460]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.460]             }
[17:39:51.460]             base::options(...future.oldOptions)
[17:39:51.460]             if (.Platform$OS.type == "windows") {
[17:39:51.460]                 old_names <- names(...future.oldEnvVars)
[17:39:51.460]                 envs <- base::Sys.getenv()
[17:39:51.460]                 names <- names(envs)
[17:39:51.460]                 common <- intersect(names, old_names)
[17:39:51.460]                 added <- setdiff(names, old_names)
[17:39:51.460]                 removed <- setdiff(old_names, names)
[17:39:51.460]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.460]                   envs[common]]
[17:39:51.460]                 NAMES <- toupper(changed)
[17:39:51.460]                 args <- list()
[17:39:51.460]                 for (kk in seq_along(NAMES)) {
[17:39:51.460]                   name <- changed[[kk]]
[17:39:51.460]                   NAME <- NAMES[[kk]]
[17:39:51.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.460]                     next
[17:39:51.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.460]                 }
[17:39:51.460]                 NAMES <- toupper(added)
[17:39:51.460]                 for (kk in seq_along(NAMES)) {
[17:39:51.460]                   name <- added[[kk]]
[17:39:51.460]                   NAME <- NAMES[[kk]]
[17:39:51.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.460]                     next
[17:39:51.460]                   args[[name]] <- ""
[17:39:51.460]                 }
[17:39:51.460]                 NAMES <- toupper(removed)
[17:39:51.460]                 for (kk in seq_along(NAMES)) {
[17:39:51.460]                   name <- removed[[kk]]
[17:39:51.460]                   NAME <- NAMES[[kk]]
[17:39:51.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.460]                     next
[17:39:51.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.460]                 }
[17:39:51.460]                 if (length(args) > 0) 
[17:39:51.460]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.460]             }
[17:39:51.460]             else {
[17:39:51.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.460]             }
[17:39:51.460]             {
[17:39:51.460]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.460]                   0L) {
[17:39:51.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.460]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.460]                   base::options(opts)
[17:39:51.460]                 }
[17:39:51.460]                 {
[17:39:51.460]                   {
[17:39:51.460]                     NULL
[17:39:51.460]                     RNGkind("Mersenne-Twister")
[17:39:51.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.460]                       inherits = FALSE)
[17:39:51.460]                   }
[17:39:51.460]                   options(future.plan = NULL)
[17:39:51.460]                   if (is.na(NA_character_)) 
[17:39:51.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.460]                     .init = FALSE)
[17:39:51.460]                 }
[17:39:51.460]             }
[17:39:51.460]         }
[17:39:51.460]     })
[17:39:51.460]     if (TRUE) {
[17:39:51.460]         base::sink(type = "output", split = FALSE)
[17:39:51.460]         if (TRUE) {
[17:39:51.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.460]         }
[17:39:51.460]         else {
[17:39:51.460]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.460]         }
[17:39:51.460]         base::close(...future.stdout)
[17:39:51.460]         ...future.stdout <- NULL
[17:39:51.460]     }
[17:39:51.460]     ...future.result$conditions <- ...future.conditions
[17:39:51.460]     ...future.result$finished <- base::Sys.time()
[17:39:51.460]     ...future.result
[17:39:51.460] }
[17:39:51.462] assign_globals() ...
[17:39:51.462] List of 1
[17:39:51.462]  $ x: list()
[17:39:51.462]  - attr(*, "where")=List of 1
[17:39:51.462]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.462]  - attr(*, "resolved")= logi TRUE
[17:39:51.462]  - attr(*, "total_size")= num 0
[17:39:51.462]  - attr(*, "already-done")= logi TRUE
[17:39:51.464] - copied ‘x’ to environment
[17:39:51.464] assign_globals() ... done
[17:39:51.464] plan(): Setting new future strategy stack:
[17:39:51.465] List of future strategies:
[17:39:51.465] 1. sequential:
[17:39:51.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.465]    - tweaked: FALSE
[17:39:51.465]    - call: NULL
[17:39:51.465] plan(): nbrOfWorkers() = 1
[17:39:51.466] plan(): Setting new future strategy stack:
[17:39:51.466] List of future strategies:
[17:39:51.466] 1. sequential:
[17:39:51.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.466]    - tweaked: FALSE
[17:39:51.466]    - call: plan(strategy)
[17:39:51.466] plan(): nbrOfWorkers() = 1
[17:39:51.466] SequentialFuture started (and completed)
[17:39:51.466] - Launch lazy future ... done
[17:39:51.466] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.467] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.467] Searching for globals...
[17:39:51.469] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:39:51.469] Searching for globals ... DONE
[17:39:51.470] Resolving globals: TRUE
[17:39:51.470] Resolving any globals that are futures ...
[17:39:51.470] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:39:51.470] Resolving any globals that are futures ... DONE
[17:39:51.470] 
[17:39:51.470] 
[17:39:51.470] getGlobalsAndPackages() ... DONE
[17:39:51.471] run() for ‘Future’ ...
[17:39:51.471] - state: ‘created’
[17:39:51.471] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.471] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.471]   - Field: ‘label’
[17:39:51.471]   - Field: ‘local’
[17:39:51.471]   - Field: ‘owner’
[17:39:51.471]   - Field: ‘envir’
[17:39:51.472]   - Field: ‘packages’
[17:39:51.472]   - Field: ‘gc’
[17:39:51.472]   - Field: ‘conditions’
[17:39:51.472]   - Field: ‘expr’
[17:39:51.472]   - Field: ‘uuid’
[17:39:51.472]   - Field: ‘seed’
[17:39:51.472]   - Field: ‘version’
[17:39:51.472]   - Field: ‘result’
[17:39:51.472]   - Field: ‘asynchronous’
[17:39:51.472]   - Field: ‘calls’
[17:39:51.472]   - Field: ‘globals’
[17:39:51.473]   - Field: ‘stdout’
[17:39:51.473]   - Field: ‘earlySignal’
[17:39:51.473]   - Field: ‘lazy’
[17:39:51.473]   - Field: ‘state’
[17:39:51.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.473] - Launch lazy future ...
[17:39:51.473] Packages needed by the future expression (n = 0): <none>
[17:39:51.473] Packages needed by future strategies (n = 0): <none>
[17:39:51.474] {
[17:39:51.474]     {
[17:39:51.474]         {
[17:39:51.474]             ...future.startTime <- base::Sys.time()
[17:39:51.474]             {
[17:39:51.474]                 {
[17:39:51.474]                   {
[17:39:51.474]                     base::local({
[17:39:51.474]                       has_future <- base::requireNamespace("future", 
[17:39:51.474]                         quietly = TRUE)
[17:39:51.474]                       if (has_future) {
[17:39:51.474]                         ns <- base::getNamespace("future")
[17:39:51.474]                         version <- ns[[".package"]][["version"]]
[17:39:51.474]                         if (is.null(version)) 
[17:39:51.474]                           version <- utils::packageVersion("future")
[17:39:51.474]                       }
[17:39:51.474]                       else {
[17:39:51.474]                         version <- NULL
[17:39:51.474]                       }
[17:39:51.474]                       if (!has_future || version < "1.8.0") {
[17:39:51.474]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.474]                           "", base::R.version$version.string), 
[17:39:51.474]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.474]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.474]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.474]                             "release", "version")], collapse = " "), 
[17:39:51.474]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.474]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.474]                           info)
[17:39:51.474]                         info <- base::paste(info, collapse = "; ")
[17:39:51.474]                         if (!has_future) {
[17:39:51.474]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.474]                             info)
[17:39:51.474]                         }
[17:39:51.474]                         else {
[17:39:51.474]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.474]                             info, version)
[17:39:51.474]                         }
[17:39:51.474]                         base::stop(msg)
[17:39:51.474]                       }
[17:39:51.474]                     })
[17:39:51.474]                   }
[17:39:51.474]                   ...future.strategy.old <- future::plan("list")
[17:39:51.474]                   options(future.plan = NULL)
[17:39:51.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.474]                 }
[17:39:51.474]                 ...future.workdir <- getwd()
[17:39:51.474]             }
[17:39:51.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.474]         }
[17:39:51.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.474]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.474]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.474]             base::names(...future.oldOptions))
[17:39:51.474]     }
[17:39:51.474]     if (FALSE) {
[17:39:51.474]     }
[17:39:51.474]     else {
[17:39:51.474]         if (TRUE) {
[17:39:51.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.474]                 open = "w")
[17:39:51.474]         }
[17:39:51.474]         else {
[17:39:51.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.474]         }
[17:39:51.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.474]             base::sink(type = "output", split = FALSE)
[17:39:51.474]             base::close(...future.stdout)
[17:39:51.474]         }, add = TRUE)
[17:39:51.474]     }
[17:39:51.474]     ...future.frame <- base::sys.nframe()
[17:39:51.474]     ...future.conditions <- base::list()
[17:39:51.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.474]     if (FALSE) {
[17:39:51.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.474]     }
[17:39:51.474]     ...future.result <- base::tryCatch({
[17:39:51.474]         base::withCallingHandlers({
[17:39:51.474]             ...future.value <- base::withVisible(base::local({
[17:39:51.474]                 x <- list(b = 2)
[17:39:51.474]                 x$a <- 1
[17:39:51.474]                 x
[17:39:51.474]             }))
[17:39:51.474]             future::FutureResult(value = ...future.value$value, 
[17:39:51.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.474]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.474]                     ...future.globalenv.names))
[17:39:51.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.474]         }, condition = base::local({
[17:39:51.474]             c <- base::c
[17:39:51.474]             inherits <- base::inherits
[17:39:51.474]             invokeRestart <- base::invokeRestart
[17:39:51.474]             length <- base::length
[17:39:51.474]             list <- base::list
[17:39:51.474]             seq.int <- base::seq.int
[17:39:51.474]             signalCondition <- base::signalCondition
[17:39:51.474]             sys.calls <- base::sys.calls
[17:39:51.474]             `[[` <- base::`[[`
[17:39:51.474]             `+` <- base::`+`
[17:39:51.474]             `<<-` <- base::`<<-`
[17:39:51.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.474]                   3L)]
[17:39:51.474]             }
[17:39:51.474]             function(cond) {
[17:39:51.474]                 is_error <- inherits(cond, "error")
[17:39:51.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.474]                   NULL)
[17:39:51.474]                 if (is_error) {
[17:39:51.474]                   sessionInformation <- function() {
[17:39:51.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.474]                       search = base::search(), system = base::Sys.info())
[17:39:51.474]                   }
[17:39:51.474]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.474]                     cond$call), session = sessionInformation(), 
[17:39:51.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.474]                   signalCondition(cond)
[17:39:51.474]                 }
[17:39:51.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.474]                 "immediateCondition"))) {
[17:39:51.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.474]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.474]                   if (TRUE && !signal) {
[17:39:51.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.474]                     {
[17:39:51.474]                       inherits <- base::inherits
[17:39:51.474]                       invokeRestart <- base::invokeRestart
[17:39:51.474]                       is.null <- base::is.null
[17:39:51.474]                       muffled <- FALSE
[17:39:51.474]                       if (inherits(cond, "message")) {
[17:39:51.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.474]                         if (muffled) 
[17:39:51.474]                           invokeRestart("muffleMessage")
[17:39:51.474]                       }
[17:39:51.474]                       else if (inherits(cond, "warning")) {
[17:39:51.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.474]                         if (muffled) 
[17:39:51.474]                           invokeRestart("muffleWarning")
[17:39:51.474]                       }
[17:39:51.474]                       else if (inherits(cond, "condition")) {
[17:39:51.474]                         if (!is.null(pattern)) {
[17:39:51.474]                           computeRestarts <- base::computeRestarts
[17:39:51.474]                           grepl <- base::grepl
[17:39:51.474]                           restarts <- computeRestarts(cond)
[17:39:51.474]                           for (restart in restarts) {
[17:39:51.474]                             name <- restart$name
[17:39:51.474]                             if (is.null(name)) 
[17:39:51.474]                               next
[17:39:51.474]                             if (!grepl(pattern, name)) 
[17:39:51.474]                               next
[17:39:51.474]                             invokeRestart(restart)
[17:39:51.474]                             muffled <- TRUE
[17:39:51.474]                             break
[17:39:51.474]                           }
[17:39:51.474]                         }
[17:39:51.474]                       }
[17:39:51.474]                       invisible(muffled)
[17:39:51.474]                     }
[17:39:51.474]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.474]                   }
[17:39:51.474]                 }
[17:39:51.474]                 else {
[17:39:51.474]                   if (TRUE) {
[17:39:51.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.474]                     {
[17:39:51.474]                       inherits <- base::inherits
[17:39:51.474]                       invokeRestart <- base::invokeRestart
[17:39:51.474]                       is.null <- base::is.null
[17:39:51.474]                       muffled <- FALSE
[17:39:51.474]                       if (inherits(cond, "message")) {
[17:39:51.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.474]                         if (muffled) 
[17:39:51.474]                           invokeRestart("muffleMessage")
[17:39:51.474]                       }
[17:39:51.474]                       else if (inherits(cond, "warning")) {
[17:39:51.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.474]                         if (muffled) 
[17:39:51.474]                           invokeRestart("muffleWarning")
[17:39:51.474]                       }
[17:39:51.474]                       else if (inherits(cond, "condition")) {
[17:39:51.474]                         if (!is.null(pattern)) {
[17:39:51.474]                           computeRestarts <- base::computeRestarts
[17:39:51.474]                           grepl <- base::grepl
[17:39:51.474]                           restarts <- computeRestarts(cond)
[17:39:51.474]                           for (restart in restarts) {
[17:39:51.474]                             name <- restart$name
[17:39:51.474]                             if (is.null(name)) 
[17:39:51.474]                               next
[17:39:51.474]                             if (!grepl(pattern, name)) 
[17:39:51.474]                               next
[17:39:51.474]                             invokeRestart(restart)
[17:39:51.474]                             muffled <- TRUE
[17:39:51.474]                             break
[17:39:51.474]                           }
[17:39:51.474]                         }
[17:39:51.474]                       }
[17:39:51.474]                       invisible(muffled)
[17:39:51.474]                     }
[17:39:51.474]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.474]                   }
[17:39:51.474]                 }
[17:39:51.474]             }
[17:39:51.474]         }))
[17:39:51.474]     }, error = function(ex) {
[17:39:51.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.474]                 ...future.rng), started = ...future.startTime, 
[17:39:51.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.474]             version = "1.8"), class = "FutureResult")
[17:39:51.474]     }, finally = {
[17:39:51.474]         if (!identical(...future.workdir, getwd())) 
[17:39:51.474]             setwd(...future.workdir)
[17:39:51.474]         {
[17:39:51.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.474]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.474]             }
[17:39:51.474]             base::options(...future.oldOptions)
[17:39:51.474]             if (.Platform$OS.type == "windows") {
[17:39:51.474]                 old_names <- names(...future.oldEnvVars)
[17:39:51.474]                 envs <- base::Sys.getenv()
[17:39:51.474]                 names <- names(envs)
[17:39:51.474]                 common <- intersect(names, old_names)
[17:39:51.474]                 added <- setdiff(names, old_names)
[17:39:51.474]                 removed <- setdiff(old_names, names)
[17:39:51.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.474]                   envs[common]]
[17:39:51.474]                 NAMES <- toupper(changed)
[17:39:51.474]                 args <- list()
[17:39:51.474]                 for (kk in seq_along(NAMES)) {
[17:39:51.474]                   name <- changed[[kk]]
[17:39:51.474]                   NAME <- NAMES[[kk]]
[17:39:51.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.474]                     next
[17:39:51.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.474]                 }
[17:39:51.474]                 NAMES <- toupper(added)
[17:39:51.474]                 for (kk in seq_along(NAMES)) {
[17:39:51.474]                   name <- added[[kk]]
[17:39:51.474]                   NAME <- NAMES[[kk]]
[17:39:51.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.474]                     next
[17:39:51.474]                   args[[name]] <- ""
[17:39:51.474]                 }
[17:39:51.474]                 NAMES <- toupper(removed)
[17:39:51.474]                 for (kk in seq_along(NAMES)) {
[17:39:51.474]                   name <- removed[[kk]]
[17:39:51.474]                   NAME <- NAMES[[kk]]
[17:39:51.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.474]                     next
[17:39:51.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.474]                 }
[17:39:51.474]                 if (length(args) > 0) 
[17:39:51.474]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.474]             }
[17:39:51.474]             else {
[17:39:51.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.474]             }
[17:39:51.474]             {
[17:39:51.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.474]                   0L) {
[17:39:51.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.474]                   base::options(opts)
[17:39:51.474]                 }
[17:39:51.474]                 {
[17:39:51.474]                   {
[17:39:51.474]                     NULL
[17:39:51.474]                     RNGkind("Mersenne-Twister")
[17:39:51.474]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.474]                       inherits = FALSE)
[17:39:51.474]                   }
[17:39:51.474]                   options(future.plan = NULL)
[17:39:51.474]                   if (is.na(NA_character_)) 
[17:39:51.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.474]                     .init = FALSE)
[17:39:51.474]                 }
[17:39:51.474]             }
[17:39:51.474]         }
[17:39:51.474]     })
[17:39:51.474]     if (TRUE) {
[17:39:51.474]         base::sink(type = "output", split = FALSE)
[17:39:51.474]         if (TRUE) {
[17:39:51.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.474]         }
[17:39:51.474]         else {
[17:39:51.474]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.474]         }
[17:39:51.474]         base::close(...future.stdout)
[17:39:51.474]         ...future.stdout <- NULL
[17:39:51.474]     }
[17:39:51.474]     ...future.result$conditions <- ...future.conditions
[17:39:51.474]     ...future.result$finished <- base::Sys.time()
[17:39:51.474]     ...future.result
[17:39:51.474] }
[17:39:51.475] plan(): Setting new future strategy stack:
[17:39:51.475] List of future strategies:
[17:39:51.475] 1. sequential:
[17:39:51.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.475]    - tweaked: FALSE
[17:39:51.475]    - call: NULL
[17:39:51.477] plan(): nbrOfWorkers() = 1
[17:39:51.478] plan(): Setting new future strategy stack:
[17:39:51.478] List of future strategies:
[17:39:51.478] 1. sequential:
[17:39:51.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.478]    - tweaked: FALSE
[17:39:51.478]    - call: plan(strategy)
[17:39:51.478] plan(): nbrOfWorkers() = 1
[17:39:51.478] SequentialFuture started (and completed)
[17:39:51.478] - Launch lazy future ... done
[17:39:51.479] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.479] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.479] Searching for globals...
[17:39:51.481] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.481] Searching for globals ... DONE
[17:39:51.481] Resolving globals: TRUE
[17:39:51.481] Resolving any globals that are futures ...
[17:39:51.481] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.481] Resolving any globals that are futures ... DONE
[17:39:51.482] Resolving futures part of globals (recursively) ...
[17:39:51.482] resolve() on list ...
[17:39:51.482]  recursive: 99
[17:39:51.482]  length: 1
[17:39:51.482]  elements: ‘x’
[17:39:51.482]  length: 0 (resolved future 1)
[17:39:51.482] resolve() on list ... DONE
[17:39:51.482] - globals: [1] ‘x’
[17:39:51.483] Resolving futures part of globals (recursively) ... DONE
[17:39:51.483] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.483] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.483] - globals: [1] ‘x’
[17:39:51.483] 
[17:39:51.483] getGlobalsAndPackages() ... DONE
[17:39:51.483] run() for ‘Future’ ...
[17:39:51.484] - state: ‘created’
[17:39:51.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.484] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.484]   - Field: ‘label’
[17:39:51.484]   - Field: ‘local’
[17:39:51.484]   - Field: ‘owner’
[17:39:51.484]   - Field: ‘envir’
[17:39:51.484]   - Field: ‘packages’
[17:39:51.485]   - Field: ‘gc’
[17:39:51.485]   - Field: ‘conditions’
[17:39:51.485]   - Field: ‘expr’
[17:39:51.485]   - Field: ‘uuid’
[17:39:51.485]   - Field: ‘seed’
[17:39:51.485]   - Field: ‘version’
[17:39:51.485]   - Field: ‘result’
[17:39:51.485]   - Field: ‘asynchronous’
[17:39:51.485]   - Field: ‘calls’
[17:39:51.485]   - Field: ‘globals’
[17:39:51.485]   - Field: ‘stdout’
[17:39:51.485]   - Field: ‘earlySignal’
[17:39:51.486]   - Field: ‘lazy’
[17:39:51.486]   - Field: ‘state’
[17:39:51.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.486] - Launch lazy future ...
[17:39:51.486] Packages needed by the future expression (n = 0): <none>
[17:39:51.486] Packages needed by future strategies (n = 0): <none>
[17:39:51.486] {
[17:39:51.486]     {
[17:39:51.486]         {
[17:39:51.486]             ...future.startTime <- base::Sys.time()
[17:39:51.486]             {
[17:39:51.486]                 {
[17:39:51.486]                   {
[17:39:51.486]                     base::local({
[17:39:51.486]                       has_future <- base::requireNamespace("future", 
[17:39:51.486]                         quietly = TRUE)
[17:39:51.486]                       if (has_future) {
[17:39:51.486]                         ns <- base::getNamespace("future")
[17:39:51.486]                         version <- ns[[".package"]][["version"]]
[17:39:51.486]                         if (is.null(version)) 
[17:39:51.486]                           version <- utils::packageVersion("future")
[17:39:51.486]                       }
[17:39:51.486]                       else {
[17:39:51.486]                         version <- NULL
[17:39:51.486]                       }
[17:39:51.486]                       if (!has_future || version < "1.8.0") {
[17:39:51.486]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.486]                           "", base::R.version$version.string), 
[17:39:51.486]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.486]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.486]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.486]                             "release", "version")], collapse = " "), 
[17:39:51.486]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.486]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.486]                           info)
[17:39:51.486]                         info <- base::paste(info, collapse = "; ")
[17:39:51.486]                         if (!has_future) {
[17:39:51.486]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.486]                             info)
[17:39:51.486]                         }
[17:39:51.486]                         else {
[17:39:51.486]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.486]                             info, version)
[17:39:51.486]                         }
[17:39:51.486]                         base::stop(msg)
[17:39:51.486]                       }
[17:39:51.486]                     })
[17:39:51.486]                   }
[17:39:51.486]                   ...future.strategy.old <- future::plan("list")
[17:39:51.486]                   options(future.plan = NULL)
[17:39:51.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.486]                 }
[17:39:51.486]                 ...future.workdir <- getwd()
[17:39:51.486]             }
[17:39:51.486]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.486]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.486]         }
[17:39:51.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.486]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.486]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.486]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.486]             base::names(...future.oldOptions))
[17:39:51.486]     }
[17:39:51.486]     if (FALSE) {
[17:39:51.486]     }
[17:39:51.486]     else {
[17:39:51.486]         if (TRUE) {
[17:39:51.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.486]                 open = "w")
[17:39:51.486]         }
[17:39:51.486]         else {
[17:39:51.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.486]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.486]         }
[17:39:51.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.486]             base::sink(type = "output", split = FALSE)
[17:39:51.486]             base::close(...future.stdout)
[17:39:51.486]         }, add = TRUE)
[17:39:51.486]     }
[17:39:51.486]     ...future.frame <- base::sys.nframe()
[17:39:51.486]     ...future.conditions <- base::list()
[17:39:51.486]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.486]     if (FALSE) {
[17:39:51.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.486]     }
[17:39:51.486]     ...future.result <- base::tryCatch({
[17:39:51.486]         base::withCallingHandlers({
[17:39:51.486]             ...future.value <- base::withVisible(base::local({
[17:39:51.486]                 x[["a"]] <- 1
[17:39:51.486]                 x
[17:39:51.486]             }))
[17:39:51.486]             future::FutureResult(value = ...future.value$value, 
[17:39:51.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.486]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.486]                     ...future.globalenv.names))
[17:39:51.486]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.486]         }, condition = base::local({
[17:39:51.486]             c <- base::c
[17:39:51.486]             inherits <- base::inherits
[17:39:51.486]             invokeRestart <- base::invokeRestart
[17:39:51.486]             length <- base::length
[17:39:51.486]             list <- base::list
[17:39:51.486]             seq.int <- base::seq.int
[17:39:51.486]             signalCondition <- base::signalCondition
[17:39:51.486]             sys.calls <- base::sys.calls
[17:39:51.486]             `[[` <- base::`[[`
[17:39:51.486]             `+` <- base::`+`
[17:39:51.486]             `<<-` <- base::`<<-`
[17:39:51.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.486]                   3L)]
[17:39:51.486]             }
[17:39:51.486]             function(cond) {
[17:39:51.486]                 is_error <- inherits(cond, "error")
[17:39:51.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.486]                   NULL)
[17:39:51.486]                 if (is_error) {
[17:39:51.486]                   sessionInformation <- function() {
[17:39:51.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.486]                       search = base::search(), system = base::Sys.info())
[17:39:51.486]                   }
[17:39:51.486]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.486]                     cond$call), session = sessionInformation(), 
[17:39:51.486]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.486]                   signalCondition(cond)
[17:39:51.486]                 }
[17:39:51.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.486]                 "immediateCondition"))) {
[17:39:51.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.486]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.486]                   if (TRUE && !signal) {
[17:39:51.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.486]                     {
[17:39:51.486]                       inherits <- base::inherits
[17:39:51.486]                       invokeRestart <- base::invokeRestart
[17:39:51.486]                       is.null <- base::is.null
[17:39:51.486]                       muffled <- FALSE
[17:39:51.486]                       if (inherits(cond, "message")) {
[17:39:51.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.486]                         if (muffled) 
[17:39:51.486]                           invokeRestart("muffleMessage")
[17:39:51.486]                       }
[17:39:51.486]                       else if (inherits(cond, "warning")) {
[17:39:51.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.486]                         if (muffled) 
[17:39:51.486]                           invokeRestart("muffleWarning")
[17:39:51.486]                       }
[17:39:51.486]                       else if (inherits(cond, "condition")) {
[17:39:51.486]                         if (!is.null(pattern)) {
[17:39:51.486]                           computeRestarts <- base::computeRestarts
[17:39:51.486]                           grepl <- base::grepl
[17:39:51.486]                           restarts <- computeRestarts(cond)
[17:39:51.486]                           for (restart in restarts) {
[17:39:51.486]                             name <- restart$name
[17:39:51.486]                             if (is.null(name)) 
[17:39:51.486]                               next
[17:39:51.486]                             if (!grepl(pattern, name)) 
[17:39:51.486]                               next
[17:39:51.486]                             invokeRestart(restart)
[17:39:51.486]                             muffled <- TRUE
[17:39:51.486]                             break
[17:39:51.486]                           }
[17:39:51.486]                         }
[17:39:51.486]                       }
[17:39:51.486]                       invisible(muffled)
[17:39:51.486]                     }
[17:39:51.486]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.486]                   }
[17:39:51.486]                 }
[17:39:51.486]                 else {
[17:39:51.486]                   if (TRUE) {
[17:39:51.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.486]                     {
[17:39:51.486]                       inherits <- base::inherits
[17:39:51.486]                       invokeRestart <- base::invokeRestart
[17:39:51.486]                       is.null <- base::is.null
[17:39:51.486]                       muffled <- FALSE
[17:39:51.486]                       if (inherits(cond, "message")) {
[17:39:51.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.486]                         if (muffled) 
[17:39:51.486]                           invokeRestart("muffleMessage")
[17:39:51.486]                       }
[17:39:51.486]                       else if (inherits(cond, "warning")) {
[17:39:51.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.486]                         if (muffled) 
[17:39:51.486]                           invokeRestart("muffleWarning")
[17:39:51.486]                       }
[17:39:51.486]                       else if (inherits(cond, "condition")) {
[17:39:51.486]                         if (!is.null(pattern)) {
[17:39:51.486]                           computeRestarts <- base::computeRestarts
[17:39:51.486]                           grepl <- base::grepl
[17:39:51.486]                           restarts <- computeRestarts(cond)
[17:39:51.486]                           for (restart in restarts) {
[17:39:51.486]                             name <- restart$name
[17:39:51.486]                             if (is.null(name)) 
[17:39:51.486]                               next
[17:39:51.486]                             if (!grepl(pattern, name)) 
[17:39:51.486]                               next
[17:39:51.486]                             invokeRestart(restart)
[17:39:51.486]                             muffled <- TRUE
[17:39:51.486]                             break
[17:39:51.486]                           }
[17:39:51.486]                         }
[17:39:51.486]                       }
[17:39:51.486]                       invisible(muffled)
[17:39:51.486]                     }
[17:39:51.486]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.486]                   }
[17:39:51.486]                 }
[17:39:51.486]             }
[17:39:51.486]         }))
[17:39:51.486]     }, error = function(ex) {
[17:39:51.486]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.486]                 ...future.rng), started = ...future.startTime, 
[17:39:51.486]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.486]             version = "1.8"), class = "FutureResult")
[17:39:51.486]     }, finally = {
[17:39:51.486]         if (!identical(...future.workdir, getwd())) 
[17:39:51.486]             setwd(...future.workdir)
[17:39:51.486]         {
[17:39:51.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.486]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.486]             }
[17:39:51.486]             base::options(...future.oldOptions)
[17:39:51.486]             if (.Platform$OS.type == "windows") {
[17:39:51.486]                 old_names <- names(...future.oldEnvVars)
[17:39:51.486]                 envs <- base::Sys.getenv()
[17:39:51.486]                 names <- names(envs)
[17:39:51.486]                 common <- intersect(names, old_names)
[17:39:51.486]                 added <- setdiff(names, old_names)
[17:39:51.486]                 removed <- setdiff(old_names, names)
[17:39:51.486]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.486]                   envs[common]]
[17:39:51.486]                 NAMES <- toupper(changed)
[17:39:51.486]                 args <- list()
[17:39:51.486]                 for (kk in seq_along(NAMES)) {
[17:39:51.486]                   name <- changed[[kk]]
[17:39:51.486]                   NAME <- NAMES[[kk]]
[17:39:51.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.486]                     next
[17:39:51.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.486]                 }
[17:39:51.486]                 NAMES <- toupper(added)
[17:39:51.486]                 for (kk in seq_along(NAMES)) {
[17:39:51.486]                   name <- added[[kk]]
[17:39:51.486]                   NAME <- NAMES[[kk]]
[17:39:51.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.486]                     next
[17:39:51.486]                   args[[name]] <- ""
[17:39:51.486]                 }
[17:39:51.486]                 NAMES <- toupper(removed)
[17:39:51.486]                 for (kk in seq_along(NAMES)) {
[17:39:51.486]                   name <- removed[[kk]]
[17:39:51.486]                   NAME <- NAMES[[kk]]
[17:39:51.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.486]                     next
[17:39:51.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.486]                 }
[17:39:51.486]                 if (length(args) > 0) 
[17:39:51.486]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.486]             }
[17:39:51.486]             else {
[17:39:51.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.486]             }
[17:39:51.486]             {
[17:39:51.486]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.486]                   0L) {
[17:39:51.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.486]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.486]                   base::options(opts)
[17:39:51.486]                 }
[17:39:51.486]                 {
[17:39:51.486]                   {
[17:39:51.486]                     NULL
[17:39:51.486]                     RNGkind("Mersenne-Twister")
[17:39:51.486]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.486]                       inherits = FALSE)
[17:39:51.486]                   }
[17:39:51.486]                   options(future.plan = NULL)
[17:39:51.486]                   if (is.na(NA_character_)) 
[17:39:51.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.486]                     .init = FALSE)
[17:39:51.486]                 }
[17:39:51.486]             }
[17:39:51.486]         }
[17:39:51.486]     })
[17:39:51.486]     if (TRUE) {
[17:39:51.486]         base::sink(type = "output", split = FALSE)
[17:39:51.486]         if (TRUE) {
[17:39:51.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.486]         }
[17:39:51.486]         else {
[17:39:51.486]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.486]         }
[17:39:51.486]         base::close(...future.stdout)
[17:39:51.486]         ...future.stdout <- NULL
[17:39:51.486]     }
[17:39:51.486]     ...future.result$conditions <- ...future.conditions
[17:39:51.486]     ...future.result$finished <- base::Sys.time()
[17:39:51.486]     ...future.result
[17:39:51.486] }
[17:39:51.488] assign_globals() ...
[17:39:51.488] List of 1
[17:39:51.488]  $ x: list()
[17:39:51.488]  - attr(*, "where")=List of 1
[17:39:51.488]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.488]  - attr(*, "resolved")= logi TRUE
[17:39:51.488]  - attr(*, "total_size")= num 0
[17:39:51.488]  - attr(*, "already-done")= logi TRUE
[17:39:51.490] - copied ‘x’ to environment
[17:39:51.490] assign_globals() ... done
[17:39:51.491] plan(): Setting new future strategy stack:
[17:39:51.491] List of future strategies:
[17:39:51.491] 1. sequential:
[17:39:51.491]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.491]    - tweaked: FALSE
[17:39:51.491]    - call: NULL
[17:39:51.491] plan(): nbrOfWorkers() = 1
[17:39:51.492] plan(): Setting new future strategy stack:
[17:39:51.492] List of future strategies:
[17:39:51.492] 1. sequential:
[17:39:51.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.492]    - tweaked: FALSE
[17:39:51.492]    - call: plan(strategy)
[17:39:51.492] plan(): nbrOfWorkers() = 1
[17:39:51.492] SequentialFuture started (and completed)
[17:39:51.492] - Launch lazy future ... done
[17:39:51.493] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.493] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.493] Searching for globals...
[17:39:51.495] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.495] Searching for globals ... DONE
[17:39:51.495] Resolving globals: TRUE
[17:39:51.495] Resolving any globals that are futures ...
[17:39:51.495] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.495] Resolving any globals that are futures ... DONE
[17:39:51.495] Resolving futures part of globals (recursively) ...
[17:39:51.496] resolve() on list ...
[17:39:51.496]  recursive: 99
[17:39:51.496]  length: 1
[17:39:51.496]  elements: ‘x’
[17:39:51.496]  length: 0 (resolved future 1)
[17:39:51.496] resolve() on list ... DONE
[17:39:51.496] - globals: [1] ‘x’
[17:39:51.496] Resolving futures part of globals (recursively) ... DONE
[17:39:51.496] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.497] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.497] - globals: [1] ‘x’
[17:39:51.497] 
[17:39:51.497] getGlobalsAndPackages() ... DONE
[17:39:51.497] run() for ‘Future’ ...
[17:39:51.497] - state: ‘created’
[17:39:51.498] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.498] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.498]   - Field: ‘label’
[17:39:51.498]   - Field: ‘local’
[17:39:51.498]   - Field: ‘owner’
[17:39:51.498]   - Field: ‘envir’
[17:39:51.498]   - Field: ‘packages’
[17:39:51.498]   - Field: ‘gc’
[17:39:51.498]   - Field: ‘conditions’
[17:39:51.499]   - Field: ‘expr’
[17:39:51.499]   - Field: ‘uuid’
[17:39:51.499]   - Field: ‘seed’
[17:39:51.499]   - Field: ‘version’
[17:39:51.499]   - Field: ‘result’
[17:39:51.499]   - Field: ‘asynchronous’
[17:39:51.499]   - Field: ‘calls’
[17:39:51.499]   - Field: ‘globals’
[17:39:51.499]   - Field: ‘stdout’
[17:39:51.499]   - Field: ‘earlySignal’
[17:39:51.499]   - Field: ‘lazy’
[17:39:51.499]   - Field: ‘state’
[17:39:51.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.500] - Launch lazy future ...
[17:39:51.500] Packages needed by the future expression (n = 0): <none>
[17:39:51.500] Packages needed by future strategies (n = 0): <none>
[17:39:51.500] {
[17:39:51.500]     {
[17:39:51.500]         {
[17:39:51.500]             ...future.startTime <- base::Sys.time()
[17:39:51.500]             {
[17:39:51.500]                 {
[17:39:51.500]                   {
[17:39:51.500]                     base::local({
[17:39:51.500]                       has_future <- base::requireNamespace("future", 
[17:39:51.500]                         quietly = TRUE)
[17:39:51.500]                       if (has_future) {
[17:39:51.500]                         ns <- base::getNamespace("future")
[17:39:51.500]                         version <- ns[[".package"]][["version"]]
[17:39:51.500]                         if (is.null(version)) 
[17:39:51.500]                           version <- utils::packageVersion("future")
[17:39:51.500]                       }
[17:39:51.500]                       else {
[17:39:51.500]                         version <- NULL
[17:39:51.500]                       }
[17:39:51.500]                       if (!has_future || version < "1.8.0") {
[17:39:51.500]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.500]                           "", base::R.version$version.string), 
[17:39:51.500]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.500]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.500]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.500]                             "release", "version")], collapse = " "), 
[17:39:51.500]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.500]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.500]                           info)
[17:39:51.500]                         info <- base::paste(info, collapse = "; ")
[17:39:51.500]                         if (!has_future) {
[17:39:51.500]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.500]                             info)
[17:39:51.500]                         }
[17:39:51.500]                         else {
[17:39:51.500]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.500]                             info, version)
[17:39:51.500]                         }
[17:39:51.500]                         base::stop(msg)
[17:39:51.500]                       }
[17:39:51.500]                     })
[17:39:51.500]                   }
[17:39:51.500]                   ...future.strategy.old <- future::plan("list")
[17:39:51.500]                   options(future.plan = NULL)
[17:39:51.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.500]                 }
[17:39:51.500]                 ...future.workdir <- getwd()
[17:39:51.500]             }
[17:39:51.500]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.500]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.500]         }
[17:39:51.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.500]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.500]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.500]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.500]             base::names(...future.oldOptions))
[17:39:51.500]     }
[17:39:51.500]     if (FALSE) {
[17:39:51.500]     }
[17:39:51.500]     else {
[17:39:51.500]         if (TRUE) {
[17:39:51.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.500]                 open = "w")
[17:39:51.500]         }
[17:39:51.500]         else {
[17:39:51.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.500]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.500]         }
[17:39:51.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.500]             base::sink(type = "output", split = FALSE)
[17:39:51.500]             base::close(...future.stdout)
[17:39:51.500]         }, add = TRUE)
[17:39:51.500]     }
[17:39:51.500]     ...future.frame <- base::sys.nframe()
[17:39:51.500]     ...future.conditions <- base::list()
[17:39:51.500]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.500]     if (FALSE) {
[17:39:51.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.500]     }
[17:39:51.500]     ...future.result <- base::tryCatch({
[17:39:51.500]         base::withCallingHandlers({
[17:39:51.500]             ...future.value <- base::withVisible(base::local({
[17:39:51.500]                 x[["a"]] <- 1
[17:39:51.500]                 x
[17:39:51.500]             }))
[17:39:51.500]             future::FutureResult(value = ...future.value$value, 
[17:39:51.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.500]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.500]                     ...future.globalenv.names))
[17:39:51.500]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.500]         }, condition = base::local({
[17:39:51.500]             c <- base::c
[17:39:51.500]             inherits <- base::inherits
[17:39:51.500]             invokeRestart <- base::invokeRestart
[17:39:51.500]             length <- base::length
[17:39:51.500]             list <- base::list
[17:39:51.500]             seq.int <- base::seq.int
[17:39:51.500]             signalCondition <- base::signalCondition
[17:39:51.500]             sys.calls <- base::sys.calls
[17:39:51.500]             `[[` <- base::`[[`
[17:39:51.500]             `+` <- base::`+`
[17:39:51.500]             `<<-` <- base::`<<-`
[17:39:51.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.500]                   3L)]
[17:39:51.500]             }
[17:39:51.500]             function(cond) {
[17:39:51.500]                 is_error <- inherits(cond, "error")
[17:39:51.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.500]                   NULL)
[17:39:51.500]                 if (is_error) {
[17:39:51.500]                   sessionInformation <- function() {
[17:39:51.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.500]                       search = base::search(), system = base::Sys.info())
[17:39:51.500]                   }
[17:39:51.500]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.500]                     cond$call), session = sessionInformation(), 
[17:39:51.500]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.500]                   signalCondition(cond)
[17:39:51.500]                 }
[17:39:51.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.500]                 "immediateCondition"))) {
[17:39:51.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.500]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.500]                   if (TRUE && !signal) {
[17:39:51.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.500]                     {
[17:39:51.500]                       inherits <- base::inherits
[17:39:51.500]                       invokeRestart <- base::invokeRestart
[17:39:51.500]                       is.null <- base::is.null
[17:39:51.500]                       muffled <- FALSE
[17:39:51.500]                       if (inherits(cond, "message")) {
[17:39:51.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.500]                         if (muffled) 
[17:39:51.500]                           invokeRestart("muffleMessage")
[17:39:51.500]                       }
[17:39:51.500]                       else if (inherits(cond, "warning")) {
[17:39:51.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.500]                         if (muffled) 
[17:39:51.500]                           invokeRestart("muffleWarning")
[17:39:51.500]                       }
[17:39:51.500]                       else if (inherits(cond, "condition")) {
[17:39:51.500]                         if (!is.null(pattern)) {
[17:39:51.500]                           computeRestarts <- base::computeRestarts
[17:39:51.500]                           grepl <- base::grepl
[17:39:51.500]                           restarts <- computeRestarts(cond)
[17:39:51.500]                           for (restart in restarts) {
[17:39:51.500]                             name <- restart$name
[17:39:51.500]                             if (is.null(name)) 
[17:39:51.500]                               next
[17:39:51.500]                             if (!grepl(pattern, name)) 
[17:39:51.500]                               next
[17:39:51.500]                             invokeRestart(restart)
[17:39:51.500]                             muffled <- TRUE
[17:39:51.500]                             break
[17:39:51.500]                           }
[17:39:51.500]                         }
[17:39:51.500]                       }
[17:39:51.500]                       invisible(muffled)
[17:39:51.500]                     }
[17:39:51.500]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.500]                   }
[17:39:51.500]                 }
[17:39:51.500]                 else {
[17:39:51.500]                   if (TRUE) {
[17:39:51.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.500]                     {
[17:39:51.500]                       inherits <- base::inherits
[17:39:51.500]                       invokeRestart <- base::invokeRestart
[17:39:51.500]                       is.null <- base::is.null
[17:39:51.500]                       muffled <- FALSE
[17:39:51.500]                       if (inherits(cond, "message")) {
[17:39:51.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.500]                         if (muffled) 
[17:39:51.500]                           invokeRestart("muffleMessage")
[17:39:51.500]                       }
[17:39:51.500]                       else if (inherits(cond, "warning")) {
[17:39:51.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.500]                         if (muffled) 
[17:39:51.500]                           invokeRestart("muffleWarning")
[17:39:51.500]                       }
[17:39:51.500]                       else if (inherits(cond, "condition")) {
[17:39:51.500]                         if (!is.null(pattern)) {
[17:39:51.500]                           computeRestarts <- base::computeRestarts
[17:39:51.500]                           grepl <- base::grepl
[17:39:51.500]                           restarts <- computeRestarts(cond)
[17:39:51.500]                           for (restart in restarts) {
[17:39:51.500]                             name <- restart$name
[17:39:51.500]                             if (is.null(name)) 
[17:39:51.500]                               next
[17:39:51.500]                             if (!grepl(pattern, name)) 
[17:39:51.500]                               next
[17:39:51.500]                             invokeRestart(restart)
[17:39:51.500]                             muffled <- TRUE
[17:39:51.500]                             break
[17:39:51.500]                           }
[17:39:51.500]                         }
[17:39:51.500]                       }
[17:39:51.500]                       invisible(muffled)
[17:39:51.500]                     }
[17:39:51.500]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.500]                   }
[17:39:51.500]                 }
[17:39:51.500]             }
[17:39:51.500]         }))
[17:39:51.500]     }, error = function(ex) {
[17:39:51.500]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.500]                 ...future.rng), started = ...future.startTime, 
[17:39:51.500]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.500]             version = "1.8"), class = "FutureResult")
[17:39:51.500]     }, finally = {
[17:39:51.500]         if (!identical(...future.workdir, getwd())) 
[17:39:51.500]             setwd(...future.workdir)
[17:39:51.500]         {
[17:39:51.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.500]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.500]             }
[17:39:51.500]             base::options(...future.oldOptions)
[17:39:51.500]             if (.Platform$OS.type == "windows") {
[17:39:51.500]                 old_names <- names(...future.oldEnvVars)
[17:39:51.500]                 envs <- base::Sys.getenv()
[17:39:51.500]                 names <- names(envs)
[17:39:51.500]                 common <- intersect(names, old_names)
[17:39:51.500]                 added <- setdiff(names, old_names)
[17:39:51.500]                 removed <- setdiff(old_names, names)
[17:39:51.500]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.500]                   envs[common]]
[17:39:51.500]                 NAMES <- toupper(changed)
[17:39:51.500]                 args <- list()
[17:39:51.500]                 for (kk in seq_along(NAMES)) {
[17:39:51.500]                   name <- changed[[kk]]
[17:39:51.500]                   NAME <- NAMES[[kk]]
[17:39:51.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.500]                     next
[17:39:51.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.500]                 }
[17:39:51.500]                 NAMES <- toupper(added)
[17:39:51.500]                 for (kk in seq_along(NAMES)) {
[17:39:51.500]                   name <- added[[kk]]
[17:39:51.500]                   NAME <- NAMES[[kk]]
[17:39:51.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.500]                     next
[17:39:51.500]                   args[[name]] <- ""
[17:39:51.500]                 }
[17:39:51.500]                 NAMES <- toupper(removed)
[17:39:51.500]                 for (kk in seq_along(NAMES)) {
[17:39:51.500]                   name <- removed[[kk]]
[17:39:51.500]                   NAME <- NAMES[[kk]]
[17:39:51.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.500]                     next
[17:39:51.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.500]                 }
[17:39:51.500]                 if (length(args) > 0) 
[17:39:51.500]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.500]             }
[17:39:51.500]             else {
[17:39:51.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.500]             }
[17:39:51.500]             {
[17:39:51.500]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.500]                   0L) {
[17:39:51.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.500]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.500]                   base::options(opts)
[17:39:51.500]                 }
[17:39:51.500]                 {
[17:39:51.500]                   {
[17:39:51.500]                     NULL
[17:39:51.500]                     RNGkind("Mersenne-Twister")
[17:39:51.500]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.500]                       inherits = FALSE)
[17:39:51.500]                   }
[17:39:51.500]                   options(future.plan = NULL)
[17:39:51.500]                   if (is.na(NA_character_)) 
[17:39:51.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.500]                     .init = FALSE)
[17:39:51.500]                 }
[17:39:51.500]             }
[17:39:51.500]         }
[17:39:51.500]     })
[17:39:51.500]     if (TRUE) {
[17:39:51.500]         base::sink(type = "output", split = FALSE)
[17:39:51.500]         if (TRUE) {
[17:39:51.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.500]         }
[17:39:51.500]         else {
[17:39:51.500]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.500]         }
[17:39:51.500]         base::close(...future.stdout)
[17:39:51.500]         ...future.stdout <- NULL
[17:39:51.500]     }
[17:39:51.500]     ...future.result$conditions <- ...future.conditions
[17:39:51.500]     ...future.result$finished <- base::Sys.time()
[17:39:51.500]     ...future.result
[17:39:51.500] }
[17:39:51.502] assign_globals() ...
[17:39:51.502] List of 1
[17:39:51.502]  $ x: list()
[17:39:51.502]  - attr(*, "where")=List of 1
[17:39:51.502]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.502]  - attr(*, "resolved")= logi TRUE
[17:39:51.502]  - attr(*, "total_size")= num 0
[17:39:51.502]  - attr(*, "already-done")= logi TRUE
[17:39:51.505] - copied ‘x’ to environment
[17:39:51.505] assign_globals() ... done
[17:39:51.506] plan(): Setting new future strategy stack:
[17:39:51.506] List of future strategies:
[17:39:51.506] 1. sequential:
[17:39:51.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.506]    - tweaked: FALSE
[17:39:51.506]    - call: NULL
[17:39:51.506] plan(): nbrOfWorkers() = 1
[17:39:51.507] plan(): Setting new future strategy stack:
[17:39:51.507] List of future strategies:
[17:39:51.507] 1. sequential:
[17:39:51.507]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.507]    - tweaked: FALSE
[17:39:51.507]    - call: plan(strategy)
[17:39:51.507] plan(): nbrOfWorkers() = 1
[17:39:51.507] SequentialFuture started (and completed)
[17:39:51.507] - Launch lazy future ... done
[17:39:51.508] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.508] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.508] Searching for globals...
[17:39:51.510] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.510] Searching for globals ... DONE
[17:39:51.510] Resolving globals: TRUE
[17:39:51.510] Resolving any globals that are futures ...
[17:39:51.510] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.510] Resolving any globals that are futures ... DONE
[17:39:51.511] Resolving futures part of globals (recursively) ...
[17:39:51.511] resolve() on list ...
[17:39:51.511]  recursive: 99
[17:39:51.511]  length: 1
[17:39:51.511]  elements: ‘x’
[17:39:51.511]  length: 0 (resolved future 1)
[17:39:51.511] resolve() on list ... DONE
[17:39:51.511] - globals: [1] ‘x’
[17:39:51.511] Resolving futures part of globals (recursively) ... DONE
[17:39:51.512] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.512] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.512] - globals: [1] ‘x’
[17:39:51.512] 
[17:39:51.512] getGlobalsAndPackages() ... DONE
[17:39:51.512] run() for ‘Future’ ...
[17:39:51.512] - state: ‘created’
[17:39:51.513] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.513]   - Field: ‘label’
[17:39:51.513]   - Field: ‘local’
[17:39:51.513]   - Field: ‘owner’
[17:39:51.513]   - Field: ‘envir’
[17:39:51.513]   - Field: ‘packages’
[17:39:51.514]   - Field: ‘gc’
[17:39:51.514]   - Field: ‘conditions’
[17:39:51.514]   - Field: ‘expr’
[17:39:51.514]   - Field: ‘uuid’
[17:39:51.514]   - Field: ‘seed’
[17:39:51.514]   - Field: ‘version’
[17:39:51.514]   - Field: ‘result’
[17:39:51.514]   - Field: ‘asynchronous’
[17:39:51.514]   - Field: ‘calls’
[17:39:51.514]   - Field: ‘globals’
[17:39:51.514]   - Field: ‘stdout’
[17:39:51.514]   - Field: ‘earlySignal’
[17:39:51.514]   - Field: ‘lazy’
[17:39:51.515]   - Field: ‘state’
[17:39:51.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.515] - Launch lazy future ...
[17:39:51.515] Packages needed by the future expression (n = 0): <none>
[17:39:51.515] Packages needed by future strategies (n = 0): <none>
[17:39:51.515] {
[17:39:51.515]     {
[17:39:51.515]         {
[17:39:51.515]             ...future.startTime <- base::Sys.time()
[17:39:51.515]             {
[17:39:51.515]                 {
[17:39:51.515]                   {
[17:39:51.515]                     base::local({
[17:39:51.515]                       has_future <- base::requireNamespace("future", 
[17:39:51.515]                         quietly = TRUE)
[17:39:51.515]                       if (has_future) {
[17:39:51.515]                         ns <- base::getNamespace("future")
[17:39:51.515]                         version <- ns[[".package"]][["version"]]
[17:39:51.515]                         if (is.null(version)) 
[17:39:51.515]                           version <- utils::packageVersion("future")
[17:39:51.515]                       }
[17:39:51.515]                       else {
[17:39:51.515]                         version <- NULL
[17:39:51.515]                       }
[17:39:51.515]                       if (!has_future || version < "1.8.0") {
[17:39:51.515]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.515]                           "", base::R.version$version.string), 
[17:39:51.515]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.515]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.515]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.515]                             "release", "version")], collapse = " "), 
[17:39:51.515]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.515]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.515]                           info)
[17:39:51.515]                         info <- base::paste(info, collapse = "; ")
[17:39:51.515]                         if (!has_future) {
[17:39:51.515]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.515]                             info)
[17:39:51.515]                         }
[17:39:51.515]                         else {
[17:39:51.515]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.515]                             info, version)
[17:39:51.515]                         }
[17:39:51.515]                         base::stop(msg)
[17:39:51.515]                       }
[17:39:51.515]                     })
[17:39:51.515]                   }
[17:39:51.515]                   ...future.strategy.old <- future::plan("list")
[17:39:51.515]                   options(future.plan = NULL)
[17:39:51.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.515]                 }
[17:39:51.515]                 ...future.workdir <- getwd()
[17:39:51.515]             }
[17:39:51.515]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.515]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.515]         }
[17:39:51.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.515]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.515]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.515]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.515]             base::names(...future.oldOptions))
[17:39:51.515]     }
[17:39:51.515]     if (FALSE) {
[17:39:51.515]     }
[17:39:51.515]     else {
[17:39:51.515]         if (TRUE) {
[17:39:51.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.515]                 open = "w")
[17:39:51.515]         }
[17:39:51.515]         else {
[17:39:51.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.515]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.515]         }
[17:39:51.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.515]             base::sink(type = "output", split = FALSE)
[17:39:51.515]             base::close(...future.stdout)
[17:39:51.515]         }, add = TRUE)
[17:39:51.515]     }
[17:39:51.515]     ...future.frame <- base::sys.nframe()
[17:39:51.515]     ...future.conditions <- base::list()
[17:39:51.515]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.515]     if (FALSE) {
[17:39:51.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.515]     }
[17:39:51.515]     ...future.result <- base::tryCatch({
[17:39:51.515]         base::withCallingHandlers({
[17:39:51.515]             ...future.value <- base::withVisible(base::local({
[17:39:51.515]                 x[["a"]] <- 1
[17:39:51.515]                 x
[17:39:51.515]             }))
[17:39:51.515]             future::FutureResult(value = ...future.value$value, 
[17:39:51.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.515]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.515]                     ...future.globalenv.names))
[17:39:51.515]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.515]         }, condition = base::local({
[17:39:51.515]             c <- base::c
[17:39:51.515]             inherits <- base::inherits
[17:39:51.515]             invokeRestart <- base::invokeRestart
[17:39:51.515]             length <- base::length
[17:39:51.515]             list <- base::list
[17:39:51.515]             seq.int <- base::seq.int
[17:39:51.515]             signalCondition <- base::signalCondition
[17:39:51.515]             sys.calls <- base::sys.calls
[17:39:51.515]             `[[` <- base::`[[`
[17:39:51.515]             `+` <- base::`+`
[17:39:51.515]             `<<-` <- base::`<<-`
[17:39:51.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.515]                   3L)]
[17:39:51.515]             }
[17:39:51.515]             function(cond) {
[17:39:51.515]                 is_error <- inherits(cond, "error")
[17:39:51.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.515]                   NULL)
[17:39:51.515]                 if (is_error) {
[17:39:51.515]                   sessionInformation <- function() {
[17:39:51.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.515]                       search = base::search(), system = base::Sys.info())
[17:39:51.515]                   }
[17:39:51.515]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.515]                     cond$call), session = sessionInformation(), 
[17:39:51.515]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.515]                   signalCondition(cond)
[17:39:51.515]                 }
[17:39:51.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.515]                 "immediateCondition"))) {
[17:39:51.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.515]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.515]                   if (TRUE && !signal) {
[17:39:51.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.515]                     {
[17:39:51.515]                       inherits <- base::inherits
[17:39:51.515]                       invokeRestart <- base::invokeRestart
[17:39:51.515]                       is.null <- base::is.null
[17:39:51.515]                       muffled <- FALSE
[17:39:51.515]                       if (inherits(cond, "message")) {
[17:39:51.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.515]                         if (muffled) 
[17:39:51.515]                           invokeRestart("muffleMessage")
[17:39:51.515]                       }
[17:39:51.515]                       else if (inherits(cond, "warning")) {
[17:39:51.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.515]                         if (muffled) 
[17:39:51.515]                           invokeRestart("muffleWarning")
[17:39:51.515]                       }
[17:39:51.515]                       else if (inherits(cond, "condition")) {
[17:39:51.515]                         if (!is.null(pattern)) {
[17:39:51.515]                           computeRestarts <- base::computeRestarts
[17:39:51.515]                           grepl <- base::grepl
[17:39:51.515]                           restarts <- computeRestarts(cond)
[17:39:51.515]                           for (restart in restarts) {
[17:39:51.515]                             name <- restart$name
[17:39:51.515]                             if (is.null(name)) 
[17:39:51.515]                               next
[17:39:51.515]                             if (!grepl(pattern, name)) 
[17:39:51.515]                               next
[17:39:51.515]                             invokeRestart(restart)
[17:39:51.515]                             muffled <- TRUE
[17:39:51.515]                             break
[17:39:51.515]                           }
[17:39:51.515]                         }
[17:39:51.515]                       }
[17:39:51.515]                       invisible(muffled)
[17:39:51.515]                     }
[17:39:51.515]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.515]                   }
[17:39:51.515]                 }
[17:39:51.515]                 else {
[17:39:51.515]                   if (TRUE) {
[17:39:51.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.515]                     {
[17:39:51.515]                       inherits <- base::inherits
[17:39:51.515]                       invokeRestart <- base::invokeRestart
[17:39:51.515]                       is.null <- base::is.null
[17:39:51.515]                       muffled <- FALSE
[17:39:51.515]                       if (inherits(cond, "message")) {
[17:39:51.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.515]                         if (muffled) 
[17:39:51.515]                           invokeRestart("muffleMessage")
[17:39:51.515]                       }
[17:39:51.515]                       else if (inherits(cond, "warning")) {
[17:39:51.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.515]                         if (muffled) 
[17:39:51.515]                           invokeRestart("muffleWarning")
[17:39:51.515]                       }
[17:39:51.515]                       else if (inherits(cond, "condition")) {
[17:39:51.515]                         if (!is.null(pattern)) {
[17:39:51.515]                           computeRestarts <- base::computeRestarts
[17:39:51.515]                           grepl <- base::grepl
[17:39:51.515]                           restarts <- computeRestarts(cond)
[17:39:51.515]                           for (restart in restarts) {
[17:39:51.515]                             name <- restart$name
[17:39:51.515]                             if (is.null(name)) 
[17:39:51.515]                               next
[17:39:51.515]                             if (!grepl(pattern, name)) 
[17:39:51.515]                               next
[17:39:51.515]                             invokeRestart(restart)
[17:39:51.515]                             muffled <- TRUE
[17:39:51.515]                             break
[17:39:51.515]                           }
[17:39:51.515]                         }
[17:39:51.515]                       }
[17:39:51.515]                       invisible(muffled)
[17:39:51.515]                     }
[17:39:51.515]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.515]                   }
[17:39:51.515]                 }
[17:39:51.515]             }
[17:39:51.515]         }))
[17:39:51.515]     }, error = function(ex) {
[17:39:51.515]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.515]                 ...future.rng), started = ...future.startTime, 
[17:39:51.515]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.515]             version = "1.8"), class = "FutureResult")
[17:39:51.515]     }, finally = {
[17:39:51.515]         if (!identical(...future.workdir, getwd())) 
[17:39:51.515]             setwd(...future.workdir)
[17:39:51.515]         {
[17:39:51.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.515]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.515]             }
[17:39:51.515]             base::options(...future.oldOptions)
[17:39:51.515]             if (.Platform$OS.type == "windows") {
[17:39:51.515]                 old_names <- names(...future.oldEnvVars)
[17:39:51.515]                 envs <- base::Sys.getenv()
[17:39:51.515]                 names <- names(envs)
[17:39:51.515]                 common <- intersect(names, old_names)
[17:39:51.515]                 added <- setdiff(names, old_names)
[17:39:51.515]                 removed <- setdiff(old_names, names)
[17:39:51.515]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.515]                   envs[common]]
[17:39:51.515]                 NAMES <- toupper(changed)
[17:39:51.515]                 args <- list()
[17:39:51.515]                 for (kk in seq_along(NAMES)) {
[17:39:51.515]                   name <- changed[[kk]]
[17:39:51.515]                   NAME <- NAMES[[kk]]
[17:39:51.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.515]                     next
[17:39:51.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.515]                 }
[17:39:51.515]                 NAMES <- toupper(added)
[17:39:51.515]                 for (kk in seq_along(NAMES)) {
[17:39:51.515]                   name <- added[[kk]]
[17:39:51.515]                   NAME <- NAMES[[kk]]
[17:39:51.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.515]                     next
[17:39:51.515]                   args[[name]] <- ""
[17:39:51.515]                 }
[17:39:51.515]                 NAMES <- toupper(removed)
[17:39:51.515]                 for (kk in seq_along(NAMES)) {
[17:39:51.515]                   name <- removed[[kk]]
[17:39:51.515]                   NAME <- NAMES[[kk]]
[17:39:51.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.515]                     next
[17:39:51.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.515]                 }
[17:39:51.515]                 if (length(args) > 0) 
[17:39:51.515]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.515]             }
[17:39:51.515]             else {
[17:39:51.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.515]             }
[17:39:51.515]             {
[17:39:51.515]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.515]                   0L) {
[17:39:51.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.515]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.515]                   base::options(opts)
[17:39:51.515]                 }
[17:39:51.515]                 {
[17:39:51.515]                   {
[17:39:51.515]                     NULL
[17:39:51.515]                     RNGkind("Mersenne-Twister")
[17:39:51.515]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.515]                       inherits = FALSE)
[17:39:51.515]                   }
[17:39:51.515]                   options(future.plan = NULL)
[17:39:51.515]                   if (is.na(NA_character_)) 
[17:39:51.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.515]                     .init = FALSE)
[17:39:51.515]                 }
[17:39:51.515]             }
[17:39:51.515]         }
[17:39:51.515]     })
[17:39:51.515]     if (TRUE) {
[17:39:51.515]         base::sink(type = "output", split = FALSE)
[17:39:51.515]         if (TRUE) {
[17:39:51.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.515]         }
[17:39:51.515]         else {
[17:39:51.515]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.515]         }
[17:39:51.515]         base::close(...future.stdout)
[17:39:51.515]         ...future.stdout <- NULL
[17:39:51.515]     }
[17:39:51.515]     ...future.result$conditions <- ...future.conditions
[17:39:51.515]     ...future.result$finished <- base::Sys.time()
[17:39:51.515]     ...future.result
[17:39:51.515] }
[17:39:51.517] assign_globals() ...
[17:39:51.517] List of 1
[17:39:51.517]  $ x: list()
[17:39:51.517]  - attr(*, "where")=List of 1
[17:39:51.517]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.517]  - attr(*, "resolved")= logi TRUE
[17:39:51.517]  - attr(*, "total_size")= num 0
[17:39:51.517]  - attr(*, "already-done")= logi TRUE
[17:39:51.519] - copied ‘x’ to environment
[17:39:51.519] assign_globals() ... done
[17:39:51.519] plan(): Setting new future strategy stack:
[17:39:51.519] List of future strategies:
[17:39:51.519] 1. sequential:
[17:39:51.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.519]    - tweaked: FALSE
[17:39:51.519]    - call: NULL
[17:39:51.520] plan(): nbrOfWorkers() = 1
[17:39:51.521] plan(): Setting new future strategy stack:
[17:39:51.521] List of future strategies:
[17:39:51.521] 1. sequential:
[17:39:51.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.521]    - tweaked: FALSE
[17:39:51.521]    - call: plan(strategy)
[17:39:51.521] plan(): nbrOfWorkers() = 1
[17:39:51.521] SequentialFuture started (and completed)
[17:39:51.521] - Launch lazy future ... done
[17:39:51.521] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.522] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.522] Searching for globals...
[17:39:51.524] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.524] Searching for globals ... DONE
[17:39:51.524] Resolving globals: TRUE
[17:39:51.524] Resolving any globals that are futures ...
[17:39:51.524] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.524] Resolving any globals that are futures ... DONE
[17:39:51.525] Resolving futures part of globals (recursively) ...
[17:39:51.525] resolve() on list ...
[17:39:51.525]  recursive: 99
[17:39:51.525]  length: 1
[17:39:51.525]  elements: ‘x’
[17:39:51.525]  length: 0 (resolved future 1)
[17:39:51.525] resolve() on list ... DONE
[17:39:51.525] - globals: [1] ‘x’
[17:39:51.525] Resolving futures part of globals (recursively) ... DONE
[17:39:51.526] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.526] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.526] - globals: [1] ‘x’
[17:39:51.526] 
[17:39:51.526] getGlobalsAndPackages() ... DONE
[17:39:51.526] run() for ‘Future’ ...
[17:39:51.526] - state: ‘created’
[17:39:51.527] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.527] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.527]   - Field: ‘label’
[17:39:51.527]   - Field: ‘local’
[17:39:51.527]   - Field: ‘owner’
[17:39:51.527]   - Field: ‘envir’
[17:39:51.527]   - Field: ‘packages’
[17:39:51.527]   - Field: ‘gc’
[17:39:51.527]   - Field: ‘conditions’
[17:39:51.528]   - Field: ‘expr’
[17:39:51.528]   - Field: ‘uuid’
[17:39:51.529]   - Field: ‘seed’
[17:39:51.529]   - Field: ‘version’
[17:39:51.529]   - Field: ‘result’
[17:39:51.529]   - Field: ‘asynchronous’
[17:39:51.529]   - Field: ‘calls’
[17:39:51.529]   - Field: ‘globals’
[17:39:51.529]   - Field: ‘stdout’
[17:39:51.529]   - Field: ‘earlySignal’
[17:39:51.529]   - Field: ‘lazy’
[17:39:51.530]   - Field: ‘state’
[17:39:51.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.530] - Launch lazy future ...
[17:39:51.530] Packages needed by the future expression (n = 0): <none>
[17:39:51.530] Packages needed by future strategies (n = 0): <none>
[17:39:51.530] {
[17:39:51.530]     {
[17:39:51.530]         {
[17:39:51.530]             ...future.startTime <- base::Sys.time()
[17:39:51.530]             {
[17:39:51.530]                 {
[17:39:51.530]                   {
[17:39:51.530]                     base::local({
[17:39:51.530]                       has_future <- base::requireNamespace("future", 
[17:39:51.530]                         quietly = TRUE)
[17:39:51.530]                       if (has_future) {
[17:39:51.530]                         ns <- base::getNamespace("future")
[17:39:51.530]                         version <- ns[[".package"]][["version"]]
[17:39:51.530]                         if (is.null(version)) 
[17:39:51.530]                           version <- utils::packageVersion("future")
[17:39:51.530]                       }
[17:39:51.530]                       else {
[17:39:51.530]                         version <- NULL
[17:39:51.530]                       }
[17:39:51.530]                       if (!has_future || version < "1.8.0") {
[17:39:51.530]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.530]                           "", base::R.version$version.string), 
[17:39:51.530]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.530]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.530]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.530]                             "release", "version")], collapse = " "), 
[17:39:51.530]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.530]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.530]                           info)
[17:39:51.530]                         info <- base::paste(info, collapse = "; ")
[17:39:51.530]                         if (!has_future) {
[17:39:51.530]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.530]                             info)
[17:39:51.530]                         }
[17:39:51.530]                         else {
[17:39:51.530]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.530]                             info, version)
[17:39:51.530]                         }
[17:39:51.530]                         base::stop(msg)
[17:39:51.530]                       }
[17:39:51.530]                     })
[17:39:51.530]                   }
[17:39:51.530]                   ...future.strategy.old <- future::plan("list")
[17:39:51.530]                   options(future.plan = NULL)
[17:39:51.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.530]                 }
[17:39:51.530]                 ...future.workdir <- getwd()
[17:39:51.530]             }
[17:39:51.530]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.530]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.530]         }
[17:39:51.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.530]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.530]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.530]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.530]             base::names(...future.oldOptions))
[17:39:51.530]     }
[17:39:51.530]     if (FALSE) {
[17:39:51.530]     }
[17:39:51.530]     else {
[17:39:51.530]         if (TRUE) {
[17:39:51.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.530]                 open = "w")
[17:39:51.530]         }
[17:39:51.530]         else {
[17:39:51.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.530]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.530]         }
[17:39:51.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.530]             base::sink(type = "output", split = FALSE)
[17:39:51.530]             base::close(...future.stdout)
[17:39:51.530]         }, add = TRUE)
[17:39:51.530]     }
[17:39:51.530]     ...future.frame <- base::sys.nframe()
[17:39:51.530]     ...future.conditions <- base::list()
[17:39:51.530]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.530]     if (FALSE) {
[17:39:51.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.530]     }
[17:39:51.530]     ...future.result <- base::tryCatch({
[17:39:51.530]         base::withCallingHandlers({
[17:39:51.530]             ...future.value <- base::withVisible(base::local({
[17:39:51.530]                 x["a"] <- list(1)
[17:39:51.530]                 x
[17:39:51.530]             }))
[17:39:51.530]             future::FutureResult(value = ...future.value$value, 
[17:39:51.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.530]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.530]                     ...future.globalenv.names))
[17:39:51.530]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.530]         }, condition = base::local({
[17:39:51.530]             c <- base::c
[17:39:51.530]             inherits <- base::inherits
[17:39:51.530]             invokeRestart <- base::invokeRestart
[17:39:51.530]             length <- base::length
[17:39:51.530]             list <- base::list
[17:39:51.530]             seq.int <- base::seq.int
[17:39:51.530]             signalCondition <- base::signalCondition
[17:39:51.530]             sys.calls <- base::sys.calls
[17:39:51.530]             `[[` <- base::`[[`
[17:39:51.530]             `+` <- base::`+`
[17:39:51.530]             `<<-` <- base::`<<-`
[17:39:51.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.530]                   3L)]
[17:39:51.530]             }
[17:39:51.530]             function(cond) {
[17:39:51.530]                 is_error <- inherits(cond, "error")
[17:39:51.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.530]                   NULL)
[17:39:51.530]                 if (is_error) {
[17:39:51.530]                   sessionInformation <- function() {
[17:39:51.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.530]                       search = base::search(), system = base::Sys.info())
[17:39:51.530]                   }
[17:39:51.530]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.530]                     cond$call), session = sessionInformation(), 
[17:39:51.530]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.530]                   signalCondition(cond)
[17:39:51.530]                 }
[17:39:51.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.530]                 "immediateCondition"))) {
[17:39:51.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.530]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.530]                   if (TRUE && !signal) {
[17:39:51.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.530]                     {
[17:39:51.530]                       inherits <- base::inherits
[17:39:51.530]                       invokeRestart <- base::invokeRestart
[17:39:51.530]                       is.null <- base::is.null
[17:39:51.530]                       muffled <- FALSE
[17:39:51.530]                       if (inherits(cond, "message")) {
[17:39:51.530]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.530]                         if (muffled) 
[17:39:51.530]                           invokeRestart("muffleMessage")
[17:39:51.530]                       }
[17:39:51.530]                       else if (inherits(cond, "warning")) {
[17:39:51.530]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.530]                         if (muffled) 
[17:39:51.530]                           invokeRestart("muffleWarning")
[17:39:51.530]                       }
[17:39:51.530]                       else if (inherits(cond, "condition")) {
[17:39:51.530]                         if (!is.null(pattern)) {
[17:39:51.530]                           computeRestarts <- base::computeRestarts
[17:39:51.530]                           grepl <- base::grepl
[17:39:51.530]                           restarts <- computeRestarts(cond)
[17:39:51.530]                           for (restart in restarts) {
[17:39:51.530]                             name <- restart$name
[17:39:51.530]                             if (is.null(name)) 
[17:39:51.530]                               next
[17:39:51.530]                             if (!grepl(pattern, name)) 
[17:39:51.530]                               next
[17:39:51.530]                             invokeRestart(restart)
[17:39:51.530]                             muffled <- TRUE
[17:39:51.530]                             break
[17:39:51.530]                           }
[17:39:51.530]                         }
[17:39:51.530]                       }
[17:39:51.530]                       invisible(muffled)
[17:39:51.530]                     }
[17:39:51.530]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.530]                   }
[17:39:51.530]                 }
[17:39:51.530]                 else {
[17:39:51.530]                   if (TRUE) {
[17:39:51.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.530]                     {
[17:39:51.530]                       inherits <- base::inherits
[17:39:51.530]                       invokeRestart <- base::invokeRestart
[17:39:51.530]                       is.null <- base::is.null
[17:39:51.530]                       muffled <- FALSE
[17:39:51.530]                       if (inherits(cond, "message")) {
[17:39:51.530]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.530]                         if (muffled) 
[17:39:51.530]                           invokeRestart("muffleMessage")
[17:39:51.530]                       }
[17:39:51.530]                       else if (inherits(cond, "warning")) {
[17:39:51.530]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.530]                         if (muffled) 
[17:39:51.530]                           invokeRestart("muffleWarning")
[17:39:51.530]                       }
[17:39:51.530]                       else if (inherits(cond, "condition")) {
[17:39:51.530]                         if (!is.null(pattern)) {
[17:39:51.530]                           computeRestarts <- base::computeRestarts
[17:39:51.530]                           grepl <- base::grepl
[17:39:51.530]                           restarts <- computeRestarts(cond)
[17:39:51.530]                           for (restart in restarts) {
[17:39:51.530]                             name <- restart$name
[17:39:51.530]                             if (is.null(name)) 
[17:39:51.530]                               next
[17:39:51.530]                             if (!grepl(pattern, name)) 
[17:39:51.530]                               next
[17:39:51.530]                             invokeRestart(restart)
[17:39:51.530]                             muffled <- TRUE
[17:39:51.530]                             break
[17:39:51.530]                           }
[17:39:51.530]                         }
[17:39:51.530]                       }
[17:39:51.530]                       invisible(muffled)
[17:39:51.530]                     }
[17:39:51.530]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.530]                   }
[17:39:51.530]                 }
[17:39:51.530]             }
[17:39:51.530]         }))
[17:39:51.530]     }, error = function(ex) {
[17:39:51.530]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.530]                 ...future.rng), started = ...future.startTime, 
[17:39:51.530]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.530]             version = "1.8"), class = "FutureResult")
[17:39:51.530]     }, finally = {
[17:39:51.530]         if (!identical(...future.workdir, getwd())) 
[17:39:51.530]             setwd(...future.workdir)
[17:39:51.530]         {
[17:39:51.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.530]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.530]             }
[17:39:51.530]             base::options(...future.oldOptions)
[17:39:51.530]             if (.Platform$OS.type == "windows") {
[17:39:51.530]                 old_names <- names(...future.oldEnvVars)
[17:39:51.530]                 envs <- base::Sys.getenv()
[17:39:51.530]                 names <- names(envs)
[17:39:51.530]                 common <- intersect(names, old_names)
[17:39:51.530]                 added <- setdiff(names, old_names)
[17:39:51.530]                 removed <- setdiff(old_names, names)
[17:39:51.530]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.530]                   envs[common]]
[17:39:51.530]                 NAMES <- toupper(changed)
[17:39:51.530]                 args <- list()
[17:39:51.530]                 for (kk in seq_along(NAMES)) {
[17:39:51.530]                   name <- changed[[kk]]
[17:39:51.530]                   NAME <- NAMES[[kk]]
[17:39:51.530]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.530]                     next
[17:39:51.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.530]                 }
[17:39:51.530]                 NAMES <- toupper(added)
[17:39:51.530]                 for (kk in seq_along(NAMES)) {
[17:39:51.530]                   name <- added[[kk]]
[17:39:51.530]                   NAME <- NAMES[[kk]]
[17:39:51.530]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.530]                     next
[17:39:51.530]                   args[[name]] <- ""
[17:39:51.530]                 }
[17:39:51.530]                 NAMES <- toupper(removed)
[17:39:51.530]                 for (kk in seq_along(NAMES)) {
[17:39:51.530]                   name <- removed[[kk]]
[17:39:51.530]                   NAME <- NAMES[[kk]]
[17:39:51.530]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.530]                     next
[17:39:51.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.530]                 }
[17:39:51.530]                 if (length(args) > 0) 
[17:39:51.530]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.530]             }
[17:39:51.530]             else {
[17:39:51.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.530]             }
[17:39:51.530]             {
[17:39:51.530]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.530]                   0L) {
[17:39:51.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.530]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.530]                   base::options(opts)
[17:39:51.530]                 }
[17:39:51.530]                 {
[17:39:51.530]                   {
[17:39:51.530]                     NULL
[17:39:51.530]                     RNGkind("Mersenne-Twister")
[17:39:51.530]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.530]                       inherits = FALSE)
[17:39:51.530]                   }
[17:39:51.530]                   options(future.plan = NULL)
[17:39:51.530]                   if (is.na(NA_character_)) 
[17:39:51.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.530]                     .init = FALSE)
[17:39:51.530]                 }
[17:39:51.530]             }
[17:39:51.530]         }
[17:39:51.530]     })
[17:39:51.530]     if (TRUE) {
[17:39:51.530]         base::sink(type = "output", split = FALSE)
[17:39:51.530]         if (TRUE) {
[17:39:51.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.530]         }
[17:39:51.530]         else {
[17:39:51.530]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.530]         }
[17:39:51.530]         base::close(...future.stdout)
[17:39:51.530]         ...future.stdout <- NULL
[17:39:51.530]     }
[17:39:51.530]     ...future.result$conditions <- ...future.conditions
[17:39:51.530]     ...future.result$finished <- base::Sys.time()
[17:39:51.530]     ...future.result
[17:39:51.530] }
[17:39:51.532] assign_globals() ...
[17:39:51.532] List of 1
[17:39:51.532]  $ x: list()
[17:39:51.532]  - attr(*, "where")=List of 1
[17:39:51.532]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.532]  - attr(*, "resolved")= logi TRUE
[17:39:51.532]  - attr(*, "total_size")= num 0
[17:39:51.532]  - attr(*, "already-done")= logi TRUE
[17:39:51.534] - copied ‘x’ to environment
[17:39:51.534] assign_globals() ... done
[17:39:51.535] plan(): Setting new future strategy stack:
[17:39:51.535] List of future strategies:
[17:39:51.535] 1. sequential:
[17:39:51.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.535]    - tweaked: FALSE
[17:39:51.535]    - call: NULL
[17:39:51.535] plan(): nbrOfWorkers() = 1
[17:39:51.536] plan(): Setting new future strategy stack:
[17:39:51.536] List of future strategies:
[17:39:51.536] 1. sequential:
[17:39:51.536]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.536]    - tweaked: FALSE
[17:39:51.536]    - call: plan(strategy)
[17:39:51.536] plan(): nbrOfWorkers() = 1
[17:39:51.536] SequentialFuture started (and completed)
[17:39:51.537] - Launch lazy future ... done
[17:39:51.537] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.537] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.537] Searching for globals...
[17:39:51.539] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.539] Searching for globals ... DONE
[17:39:51.539] Resolving globals: TRUE
[17:39:51.539] Resolving any globals that are futures ...
[17:39:51.539] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.540] Resolving any globals that are futures ... DONE
[17:39:51.540] Resolving futures part of globals (recursively) ...
[17:39:51.540] resolve() on list ...
[17:39:51.540]  recursive: 99
[17:39:51.540]  length: 1
[17:39:51.540]  elements: ‘x’
[17:39:51.540]  length: 0 (resolved future 1)
[17:39:51.541] resolve() on list ... DONE
[17:39:51.541] - globals: [1] ‘x’
[17:39:51.541] Resolving futures part of globals (recursively) ... DONE
[17:39:51.541] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.541] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.541] - globals: [1] ‘x’
[17:39:51.541] 
[17:39:51.541] getGlobalsAndPackages() ... DONE
[17:39:51.542] run() for ‘Future’ ...
[17:39:51.542] - state: ‘created’
[17:39:51.542] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.542] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.542] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.542]   - Field: ‘label’
[17:39:51.542]   - Field: ‘local’
[17:39:51.542]   - Field: ‘owner’
[17:39:51.543]   - Field: ‘envir’
[17:39:51.543]   - Field: ‘packages’
[17:39:51.543]   - Field: ‘gc’
[17:39:51.543]   - Field: ‘conditions’
[17:39:51.543]   - Field: ‘expr’
[17:39:51.543]   - Field: ‘uuid’
[17:39:51.543]   - Field: ‘seed’
[17:39:51.543]   - Field: ‘version’
[17:39:51.543]   - Field: ‘result’
[17:39:51.543]   - Field: ‘asynchronous’
[17:39:51.543]   - Field: ‘calls’
[17:39:51.543]   - Field: ‘globals’
[17:39:51.544]   - Field: ‘stdout’
[17:39:51.544]   - Field: ‘earlySignal’
[17:39:51.544]   - Field: ‘lazy’
[17:39:51.544]   - Field: ‘state’
[17:39:51.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.544] - Launch lazy future ...
[17:39:51.544] Packages needed by the future expression (n = 0): <none>
[17:39:51.544] Packages needed by future strategies (n = 0): <none>
[17:39:51.545] {
[17:39:51.545]     {
[17:39:51.545]         {
[17:39:51.545]             ...future.startTime <- base::Sys.time()
[17:39:51.545]             {
[17:39:51.545]                 {
[17:39:51.545]                   {
[17:39:51.545]                     base::local({
[17:39:51.545]                       has_future <- base::requireNamespace("future", 
[17:39:51.545]                         quietly = TRUE)
[17:39:51.545]                       if (has_future) {
[17:39:51.545]                         ns <- base::getNamespace("future")
[17:39:51.545]                         version <- ns[[".package"]][["version"]]
[17:39:51.545]                         if (is.null(version)) 
[17:39:51.545]                           version <- utils::packageVersion("future")
[17:39:51.545]                       }
[17:39:51.545]                       else {
[17:39:51.545]                         version <- NULL
[17:39:51.545]                       }
[17:39:51.545]                       if (!has_future || version < "1.8.0") {
[17:39:51.545]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.545]                           "", base::R.version$version.string), 
[17:39:51.545]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.545]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.545]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.545]                             "release", "version")], collapse = " "), 
[17:39:51.545]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.545]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.545]                           info)
[17:39:51.545]                         info <- base::paste(info, collapse = "; ")
[17:39:51.545]                         if (!has_future) {
[17:39:51.545]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.545]                             info)
[17:39:51.545]                         }
[17:39:51.545]                         else {
[17:39:51.545]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.545]                             info, version)
[17:39:51.545]                         }
[17:39:51.545]                         base::stop(msg)
[17:39:51.545]                       }
[17:39:51.545]                     })
[17:39:51.545]                   }
[17:39:51.545]                   ...future.strategy.old <- future::plan("list")
[17:39:51.545]                   options(future.plan = NULL)
[17:39:51.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.545]                 }
[17:39:51.545]                 ...future.workdir <- getwd()
[17:39:51.545]             }
[17:39:51.545]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.545]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.545]         }
[17:39:51.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.545]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.545]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.545]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.545]             base::names(...future.oldOptions))
[17:39:51.545]     }
[17:39:51.545]     if (FALSE) {
[17:39:51.545]     }
[17:39:51.545]     else {
[17:39:51.545]         if (TRUE) {
[17:39:51.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.545]                 open = "w")
[17:39:51.545]         }
[17:39:51.545]         else {
[17:39:51.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.545]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.545]         }
[17:39:51.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.545]             base::sink(type = "output", split = FALSE)
[17:39:51.545]             base::close(...future.stdout)
[17:39:51.545]         }, add = TRUE)
[17:39:51.545]     }
[17:39:51.545]     ...future.frame <- base::sys.nframe()
[17:39:51.545]     ...future.conditions <- base::list()
[17:39:51.545]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.545]     if (FALSE) {
[17:39:51.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.545]     }
[17:39:51.545]     ...future.result <- base::tryCatch({
[17:39:51.545]         base::withCallingHandlers({
[17:39:51.545]             ...future.value <- base::withVisible(base::local({
[17:39:51.545]                 x["a"] <- list(1)
[17:39:51.545]                 x
[17:39:51.545]             }))
[17:39:51.545]             future::FutureResult(value = ...future.value$value, 
[17:39:51.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.545]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.545]                     ...future.globalenv.names))
[17:39:51.545]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.545]         }, condition = base::local({
[17:39:51.545]             c <- base::c
[17:39:51.545]             inherits <- base::inherits
[17:39:51.545]             invokeRestart <- base::invokeRestart
[17:39:51.545]             length <- base::length
[17:39:51.545]             list <- base::list
[17:39:51.545]             seq.int <- base::seq.int
[17:39:51.545]             signalCondition <- base::signalCondition
[17:39:51.545]             sys.calls <- base::sys.calls
[17:39:51.545]             `[[` <- base::`[[`
[17:39:51.545]             `+` <- base::`+`
[17:39:51.545]             `<<-` <- base::`<<-`
[17:39:51.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.545]                   3L)]
[17:39:51.545]             }
[17:39:51.545]             function(cond) {
[17:39:51.545]                 is_error <- inherits(cond, "error")
[17:39:51.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.545]                   NULL)
[17:39:51.545]                 if (is_error) {
[17:39:51.545]                   sessionInformation <- function() {
[17:39:51.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.545]                       search = base::search(), system = base::Sys.info())
[17:39:51.545]                   }
[17:39:51.545]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.545]                     cond$call), session = sessionInformation(), 
[17:39:51.545]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.545]                   signalCondition(cond)
[17:39:51.545]                 }
[17:39:51.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.545]                 "immediateCondition"))) {
[17:39:51.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.545]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.545]                   if (TRUE && !signal) {
[17:39:51.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.545]                     {
[17:39:51.545]                       inherits <- base::inherits
[17:39:51.545]                       invokeRestart <- base::invokeRestart
[17:39:51.545]                       is.null <- base::is.null
[17:39:51.545]                       muffled <- FALSE
[17:39:51.545]                       if (inherits(cond, "message")) {
[17:39:51.545]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.545]                         if (muffled) 
[17:39:51.545]                           invokeRestart("muffleMessage")
[17:39:51.545]                       }
[17:39:51.545]                       else if (inherits(cond, "warning")) {
[17:39:51.545]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.545]                         if (muffled) 
[17:39:51.545]                           invokeRestart("muffleWarning")
[17:39:51.545]                       }
[17:39:51.545]                       else if (inherits(cond, "condition")) {
[17:39:51.545]                         if (!is.null(pattern)) {
[17:39:51.545]                           computeRestarts <- base::computeRestarts
[17:39:51.545]                           grepl <- base::grepl
[17:39:51.545]                           restarts <- computeRestarts(cond)
[17:39:51.545]                           for (restart in restarts) {
[17:39:51.545]                             name <- restart$name
[17:39:51.545]                             if (is.null(name)) 
[17:39:51.545]                               next
[17:39:51.545]                             if (!grepl(pattern, name)) 
[17:39:51.545]                               next
[17:39:51.545]                             invokeRestart(restart)
[17:39:51.545]                             muffled <- TRUE
[17:39:51.545]                             break
[17:39:51.545]                           }
[17:39:51.545]                         }
[17:39:51.545]                       }
[17:39:51.545]                       invisible(muffled)
[17:39:51.545]                     }
[17:39:51.545]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.545]                   }
[17:39:51.545]                 }
[17:39:51.545]                 else {
[17:39:51.545]                   if (TRUE) {
[17:39:51.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.545]                     {
[17:39:51.545]                       inherits <- base::inherits
[17:39:51.545]                       invokeRestart <- base::invokeRestart
[17:39:51.545]                       is.null <- base::is.null
[17:39:51.545]                       muffled <- FALSE
[17:39:51.545]                       if (inherits(cond, "message")) {
[17:39:51.545]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.545]                         if (muffled) 
[17:39:51.545]                           invokeRestart("muffleMessage")
[17:39:51.545]                       }
[17:39:51.545]                       else if (inherits(cond, "warning")) {
[17:39:51.545]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.545]                         if (muffled) 
[17:39:51.545]                           invokeRestart("muffleWarning")
[17:39:51.545]                       }
[17:39:51.545]                       else if (inherits(cond, "condition")) {
[17:39:51.545]                         if (!is.null(pattern)) {
[17:39:51.545]                           computeRestarts <- base::computeRestarts
[17:39:51.545]                           grepl <- base::grepl
[17:39:51.545]                           restarts <- computeRestarts(cond)
[17:39:51.545]                           for (restart in restarts) {
[17:39:51.545]                             name <- restart$name
[17:39:51.545]                             if (is.null(name)) 
[17:39:51.545]                               next
[17:39:51.545]                             if (!grepl(pattern, name)) 
[17:39:51.545]                               next
[17:39:51.545]                             invokeRestart(restart)
[17:39:51.545]                             muffled <- TRUE
[17:39:51.545]                             break
[17:39:51.545]                           }
[17:39:51.545]                         }
[17:39:51.545]                       }
[17:39:51.545]                       invisible(muffled)
[17:39:51.545]                     }
[17:39:51.545]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.545]                   }
[17:39:51.545]                 }
[17:39:51.545]             }
[17:39:51.545]         }))
[17:39:51.545]     }, error = function(ex) {
[17:39:51.545]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.545]                 ...future.rng), started = ...future.startTime, 
[17:39:51.545]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.545]             version = "1.8"), class = "FutureResult")
[17:39:51.545]     }, finally = {
[17:39:51.545]         if (!identical(...future.workdir, getwd())) 
[17:39:51.545]             setwd(...future.workdir)
[17:39:51.545]         {
[17:39:51.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.545]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.545]             }
[17:39:51.545]             base::options(...future.oldOptions)
[17:39:51.545]             if (.Platform$OS.type == "windows") {
[17:39:51.545]                 old_names <- names(...future.oldEnvVars)
[17:39:51.545]                 envs <- base::Sys.getenv()
[17:39:51.545]                 names <- names(envs)
[17:39:51.545]                 common <- intersect(names, old_names)
[17:39:51.545]                 added <- setdiff(names, old_names)
[17:39:51.545]                 removed <- setdiff(old_names, names)
[17:39:51.545]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.545]                   envs[common]]
[17:39:51.545]                 NAMES <- toupper(changed)
[17:39:51.545]                 args <- list()
[17:39:51.545]                 for (kk in seq_along(NAMES)) {
[17:39:51.545]                   name <- changed[[kk]]
[17:39:51.545]                   NAME <- NAMES[[kk]]
[17:39:51.545]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.545]                     next
[17:39:51.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.545]                 }
[17:39:51.545]                 NAMES <- toupper(added)
[17:39:51.545]                 for (kk in seq_along(NAMES)) {
[17:39:51.545]                   name <- added[[kk]]
[17:39:51.545]                   NAME <- NAMES[[kk]]
[17:39:51.545]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.545]                     next
[17:39:51.545]                   args[[name]] <- ""
[17:39:51.545]                 }
[17:39:51.545]                 NAMES <- toupper(removed)
[17:39:51.545]                 for (kk in seq_along(NAMES)) {
[17:39:51.545]                   name <- removed[[kk]]
[17:39:51.545]                   NAME <- NAMES[[kk]]
[17:39:51.545]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.545]                     next
[17:39:51.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.545]                 }
[17:39:51.545]                 if (length(args) > 0) 
[17:39:51.545]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.545]             }
[17:39:51.545]             else {
[17:39:51.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.545]             }
[17:39:51.545]             {
[17:39:51.545]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.545]                   0L) {
[17:39:51.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.545]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.545]                   base::options(opts)
[17:39:51.545]                 }
[17:39:51.545]                 {
[17:39:51.545]                   {
[17:39:51.545]                     NULL
[17:39:51.545]                     RNGkind("Mersenne-Twister")
[17:39:51.545]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.545]                       inherits = FALSE)
[17:39:51.545]                   }
[17:39:51.545]                   options(future.plan = NULL)
[17:39:51.545]                   if (is.na(NA_character_)) 
[17:39:51.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.545]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.545]                     .init = FALSE)
[17:39:51.545]                 }
[17:39:51.545]             }
[17:39:51.545]         }
[17:39:51.545]     })
[17:39:51.545]     if (TRUE) {
[17:39:51.545]         base::sink(type = "output", split = FALSE)
[17:39:51.545]         if (TRUE) {
[17:39:51.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.545]         }
[17:39:51.545]         else {
[17:39:51.545]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.545]         }
[17:39:51.545]         base::close(...future.stdout)
[17:39:51.545]         ...future.stdout <- NULL
[17:39:51.545]     }
[17:39:51.545]     ...future.result$conditions <- ...future.conditions
[17:39:51.545]     ...future.result$finished <- base::Sys.time()
[17:39:51.545]     ...future.result
[17:39:51.545] }
[17:39:51.546] assign_globals() ...
[17:39:51.546] List of 1
[17:39:51.546]  $ x: list()
[17:39:51.546]  - attr(*, "where")=List of 1
[17:39:51.546]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.546]  - attr(*, "resolved")= logi TRUE
[17:39:51.546]  - attr(*, "total_size")= num 0
[17:39:51.546]  - attr(*, "already-done")= logi TRUE
[17:39:51.548] - copied ‘x’ to environment
[17:39:51.548] assign_globals() ... done
[17:39:51.549] plan(): Setting new future strategy stack:
[17:39:51.549] List of future strategies:
[17:39:51.549] 1. sequential:
[17:39:51.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.549]    - tweaked: FALSE
[17:39:51.549]    - call: NULL
[17:39:51.549] plan(): nbrOfWorkers() = 1
[17:39:51.550] plan(): Setting new future strategy stack:
[17:39:51.550] List of future strategies:
[17:39:51.550] 1. sequential:
[17:39:51.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.550]    - tweaked: FALSE
[17:39:51.550]    - call: plan(strategy)
[17:39:51.550] plan(): nbrOfWorkers() = 1
[17:39:51.550] SequentialFuture started (and completed)
[17:39:51.551] - Launch lazy future ... done
[17:39:51.551] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.551] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.551] Searching for globals...
[17:39:51.553] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.553] Searching for globals ... DONE
[17:39:51.553] Resolving globals: TRUE
[17:39:51.553] Resolving any globals that are futures ...
[17:39:51.553] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.554] Resolving any globals that are futures ... DONE
[17:39:51.554] Resolving futures part of globals (recursively) ...
[17:39:51.555] resolve() on list ...
[17:39:51.555]  recursive: 99
[17:39:51.555]  length: 1
[17:39:51.555]  elements: ‘x’
[17:39:51.556]  length: 0 (resolved future 1)
[17:39:51.556] resolve() on list ... DONE
[17:39:51.556] - globals: [1] ‘x’
[17:39:51.556] Resolving futures part of globals (recursively) ... DONE
[17:39:51.556] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.556] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.556] - globals: [1] ‘x’
[17:39:51.557] 
[17:39:51.557] getGlobalsAndPackages() ... DONE
[17:39:51.557] run() for ‘Future’ ...
[17:39:51.557] - state: ‘created’
[17:39:51.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.557] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.557]   - Field: ‘label’
[17:39:51.558]   - Field: ‘local’
[17:39:51.558]   - Field: ‘owner’
[17:39:51.558]   - Field: ‘envir’
[17:39:51.558]   - Field: ‘packages’
[17:39:51.558]   - Field: ‘gc’
[17:39:51.558]   - Field: ‘conditions’
[17:39:51.558]   - Field: ‘expr’
[17:39:51.558]   - Field: ‘uuid’
[17:39:51.558]   - Field: ‘seed’
[17:39:51.558]   - Field: ‘version’
[17:39:51.558]   - Field: ‘result’
[17:39:51.559]   - Field: ‘asynchronous’
[17:39:51.559]   - Field: ‘calls’
[17:39:51.559]   - Field: ‘globals’
[17:39:51.559]   - Field: ‘stdout’
[17:39:51.559]   - Field: ‘earlySignal’
[17:39:51.559]   - Field: ‘lazy’
[17:39:51.559]   - Field: ‘state’
[17:39:51.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.559] - Launch lazy future ...
[17:39:51.559] Packages needed by the future expression (n = 0): <none>
[17:39:51.559] Packages needed by future strategies (n = 0): <none>
[17:39:51.560] {
[17:39:51.560]     {
[17:39:51.560]         {
[17:39:51.560]             ...future.startTime <- base::Sys.time()
[17:39:51.560]             {
[17:39:51.560]                 {
[17:39:51.560]                   {
[17:39:51.560]                     base::local({
[17:39:51.560]                       has_future <- base::requireNamespace("future", 
[17:39:51.560]                         quietly = TRUE)
[17:39:51.560]                       if (has_future) {
[17:39:51.560]                         ns <- base::getNamespace("future")
[17:39:51.560]                         version <- ns[[".package"]][["version"]]
[17:39:51.560]                         if (is.null(version)) 
[17:39:51.560]                           version <- utils::packageVersion("future")
[17:39:51.560]                       }
[17:39:51.560]                       else {
[17:39:51.560]                         version <- NULL
[17:39:51.560]                       }
[17:39:51.560]                       if (!has_future || version < "1.8.0") {
[17:39:51.560]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.560]                           "", base::R.version$version.string), 
[17:39:51.560]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.560]                             "release", "version")], collapse = " "), 
[17:39:51.560]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.560]                           info)
[17:39:51.560]                         info <- base::paste(info, collapse = "; ")
[17:39:51.560]                         if (!has_future) {
[17:39:51.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.560]                             info)
[17:39:51.560]                         }
[17:39:51.560]                         else {
[17:39:51.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.560]                             info, version)
[17:39:51.560]                         }
[17:39:51.560]                         base::stop(msg)
[17:39:51.560]                       }
[17:39:51.560]                     })
[17:39:51.560]                   }
[17:39:51.560]                   ...future.strategy.old <- future::plan("list")
[17:39:51.560]                   options(future.plan = NULL)
[17:39:51.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.560]                 }
[17:39:51.560]                 ...future.workdir <- getwd()
[17:39:51.560]             }
[17:39:51.560]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.560]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.560]         }
[17:39:51.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.560]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.560]             base::names(...future.oldOptions))
[17:39:51.560]     }
[17:39:51.560]     if (FALSE) {
[17:39:51.560]     }
[17:39:51.560]     else {
[17:39:51.560]         if (TRUE) {
[17:39:51.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.560]                 open = "w")
[17:39:51.560]         }
[17:39:51.560]         else {
[17:39:51.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.560]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.560]         }
[17:39:51.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.560]             base::sink(type = "output", split = FALSE)
[17:39:51.560]             base::close(...future.stdout)
[17:39:51.560]         }, add = TRUE)
[17:39:51.560]     }
[17:39:51.560]     ...future.frame <- base::sys.nframe()
[17:39:51.560]     ...future.conditions <- base::list()
[17:39:51.560]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.560]     if (FALSE) {
[17:39:51.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.560]     }
[17:39:51.560]     ...future.result <- base::tryCatch({
[17:39:51.560]         base::withCallingHandlers({
[17:39:51.560]             ...future.value <- base::withVisible(base::local({
[17:39:51.560]                 x["a"] <- list(1)
[17:39:51.560]                 x
[17:39:51.560]             }))
[17:39:51.560]             future::FutureResult(value = ...future.value$value, 
[17:39:51.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.560]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.560]                     ...future.globalenv.names))
[17:39:51.560]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.560]         }, condition = base::local({
[17:39:51.560]             c <- base::c
[17:39:51.560]             inherits <- base::inherits
[17:39:51.560]             invokeRestart <- base::invokeRestart
[17:39:51.560]             length <- base::length
[17:39:51.560]             list <- base::list
[17:39:51.560]             seq.int <- base::seq.int
[17:39:51.560]             signalCondition <- base::signalCondition
[17:39:51.560]             sys.calls <- base::sys.calls
[17:39:51.560]             `[[` <- base::`[[`
[17:39:51.560]             `+` <- base::`+`
[17:39:51.560]             `<<-` <- base::`<<-`
[17:39:51.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.560]                   3L)]
[17:39:51.560]             }
[17:39:51.560]             function(cond) {
[17:39:51.560]                 is_error <- inherits(cond, "error")
[17:39:51.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.560]                   NULL)
[17:39:51.560]                 if (is_error) {
[17:39:51.560]                   sessionInformation <- function() {
[17:39:51.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.560]                       search = base::search(), system = base::Sys.info())
[17:39:51.560]                   }
[17:39:51.560]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.560]                     cond$call), session = sessionInformation(), 
[17:39:51.560]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.560]                   signalCondition(cond)
[17:39:51.560]                 }
[17:39:51.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.560]                 "immediateCondition"))) {
[17:39:51.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.560]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.560]                   if (TRUE && !signal) {
[17:39:51.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.560]                     {
[17:39:51.560]                       inherits <- base::inherits
[17:39:51.560]                       invokeRestart <- base::invokeRestart
[17:39:51.560]                       is.null <- base::is.null
[17:39:51.560]                       muffled <- FALSE
[17:39:51.560]                       if (inherits(cond, "message")) {
[17:39:51.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.560]                         if (muffled) 
[17:39:51.560]                           invokeRestart("muffleMessage")
[17:39:51.560]                       }
[17:39:51.560]                       else if (inherits(cond, "warning")) {
[17:39:51.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.560]                         if (muffled) 
[17:39:51.560]                           invokeRestart("muffleWarning")
[17:39:51.560]                       }
[17:39:51.560]                       else if (inherits(cond, "condition")) {
[17:39:51.560]                         if (!is.null(pattern)) {
[17:39:51.560]                           computeRestarts <- base::computeRestarts
[17:39:51.560]                           grepl <- base::grepl
[17:39:51.560]                           restarts <- computeRestarts(cond)
[17:39:51.560]                           for (restart in restarts) {
[17:39:51.560]                             name <- restart$name
[17:39:51.560]                             if (is.null(name)) 
[17:39:51.560]                               next
[17:39:51.560]                             if (!grepl(pattern, name)) 
[17:39:51.560]                               next
[17:39:51.560]                             invokeRestart(restart)
[17:39:51.560]                             muffled <- TRUE
[17:39:51.560]                             break
[17:39:51.560]                           }
[17:39:51.560]                         }
[17:39:51.560]                       }
[17:39:51.560]                       invisible(muffled)
[17:39:51.560]                     }
[17:39:51.560]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.560]                   }
[17:39:51.560]                 }
[17:39:51.560]                 else {
[17:39:51.560]                   if (TRUE) {
[17:39:51.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.560]                     {
[17:39:51.560]                       inherits <- base::inherits
[17:39:51.560]                       invokeRestart <- base::invokeRestart
[17:39:51.560]                       is.null <- base::is.null
[17:39:51.560]                       muffled <- FALSE
[17:39:51.560]                       if (inherits(cond, "message")) {
[17:39:51.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.560]                         if (muffled) 
[17:39:51.560]                           invokeRestart("muffleMessage")
[17:39:51.560]                       }
[17:39:51.560]                       else if (inherits(cond, "warning")) {
[17:39:51.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.560]                         if (muffled) 
[17:39:51.560]                           invokeRestart("muffleWarning")
[17:39:51.560]                       }
[17:39:51.560]                       else if (inherits(cond, "condition")) {
[17:39:51.560]                         if (!is.null(pattern)) {
[17:39:51.560]                           computeRestarts <- base::computeRestarts
[17:39:51.560]                           grepl <- base::grepl
[17:39:51.560]                           restarts <- computeRestarts(cond)
[17:39:51.560]                           for (restart in restarts) {
[17:39:51.560]                             name <- restart$name
[17:39:51.560]                             if (is.null(name)) 
[17:39:51.560]                               next
[17:39:51.560]                             if (!grepl(pattern, name)) 
[17:39:51.560]                               next
[17:39:51.560]                             invokeRestart(restart)
[17:39:51.560]                             muffled <- TRUE
[17:39:51.560]                             break
[17:39:51.560]                           }
[17:39:51.560]                         }
[17:39:51.560]                       }
[17:39:51.560]                       invisible(muffled)
[17:39:51.560]                     }
[17:39:51.560]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.560]                   }
[17:39:51.560]                 }
[17:39:51.560]             }
[17:39:51.560]         }))
[17:39:51.560]     }, error = function(ex) {
[17:39:51.560]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.560]                 ...future.rng), started = ...future.startTime, 
[17:39:51.560]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.560]             version = "1.8"), class = "FutureResult")
[17:39:51.560]     }, finally = {
[17:39:51.560]         if (!identical(...future.workdir, getwd())) 
[17:39:51.560]             setwd(...future.workdir)
[17:39:51.560]         {
[17:39:51.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.560]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.560]             }
[17:39:51.560]             base::options(...future.oldOptions)
[17:39:51.560]             if (.Platform$OS.type == "windows") {
[17:39:51.560]                 old_names <- names(...future.oldEnvVars)
[17:39:51.560]                 envs <- base::Sys.getenv()
[17:39:51.560]                 names <- names(envs)
[17:39:51.560]                 common <- intersect(names, old_names)
[17:39:51.560]                 added <- setdiff(names, old_names)
[17:39:51.560]                 removed <- setdiff(old_names, names)
[17:39:51.560]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.560]                   envs[common]]
[17:39:51.560]                 NAMES <- toupper(changed)
[17:39:51.560]                 args <- list()
[17:39:51.560]                 for (kk in seq_along(NAMES)) {
[17:39:51.560]                   name <- changed[[kk]]
[17:39:51.560]                   NAME <- NAMES[[kk]]
[17:39:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.560]                     next
[17:39:51.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.560]                 }
[17:39:51.560]                 NAMES <- toupper(added)
[17:39:51.560]                 for (kk in seq_along(NAMES)) {
[17:39:51.560]                   name <- added[[kk]]
[17:39:51.560]                   NAME <- NAMES[[kk]]
[17:39:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.560]                     next
[17:39:51.560]                   args[[name]] <- ""
[17:39:51.560]                 }
[17:39:51.560]                 NAMES <- toupper(removed)
[17:39:51.560]                 for (kk in seq_along(NAMES)) {
[17:39:51.560]                   name <- removed[[kk]]
[17:39:51.560]                   NAME <- NAMES[[kk]]
[17:39:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.560]                     next
[17:39:51.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.560]                 }
[17:39:51.560]                 if (length(args) > 0) 
[17:39:51.560]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.560]             }
[17:39:51.560]             else {
[17:39:51.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.560]             }
[17:39:51.560]             {
[17:39:51.560]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.560]                   0L) {
[17:39:51.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.560]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.560]                   base::options(opts)
[17:39:51.560]                 }
[17:39:51.560]                 {
[17:39:51.560]                   {
[17:39:51.560]                     NULL
[17:39:51.560]                     RNGkind("Mersenne-Twister")
[17:39:51.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.560]                       inherits = FALSE)
[17:39:51.560]                   }
[17:39:51.560]                   options(future.plan = NULL)
[17:39:51.560]                   if (is.na(NA_character_)) 
[17:39:51.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.560]                     .init = FALSE)
[17:39:51.560]                 }
[17:39:51.560]             }
[17:39:51.560]         }
[17:39:51.560]     })
[17:39:51.560]     if (TRUE) {
[17:39:51.560]         base::sink(type = "output", split = FALSE)
[17:39:51.560]         if (TRUE) {
[17:39:51.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.560]         }
[17:39:51.560]         else {
[17:39:51.560]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.560]         }
[17:39:51.560]         base::close(...future.stdout)
[17:39:51.560]         ...future.stdout <- NULL
[17:39:51.560]     }
[17:39:51.560]     ...future.result$conditions <- ...future.conditions
[17:39:51.560]     ...future.result$finished <- base::Sys.time()
[17:39:51.560]     ...future.result
[17:39:51.560] }
[17:39:51.561] assign_globals() ...
[17:39:51.561] List of 1
[17:39:51.561]  $ x: list()
[17:39:51.561]  - attr(*, "where")=List of 1
[17:39:51.561]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.561]  - attr(*, "resolved")= logi TRUE
[17:39:51.561]  - attr(*, "total_size")= num 0
[17:39:51.561]  - attr(*, "already-done")= logi TRUE
[17:39:51.564] - copied ‘x’ to environment
[17:39:51.564] assign_globals() ... done
[17:39:51.564] plan(): Setting new future strategy stack:
[17:39:51.564] List of future strategies:
[17:39:51.564] 1. sequential:
[17:39:51.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.564]    - tweaked: FALSE
[17:39:51.564]    - call: NULL
[17:39:51.564] plan(): nbrOfWorkers() = 1
[17:39:51.565] plan(): Setting new future strategy stack:
[17:39:51.565] List of future strategies:
[17:39:51.565] 1. sequential:
[17:39:51.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.565]    - tweaked: FALSE
[17:39:51.565]    - call: plan(strategy)
[17:39:51.566] plan(): nbrOfWorkers() = 1
[17:39:51.566] SequentialFuture started (and completed)
[17:39:51.566] - Launch lazy future ... done
[17:39:51.566] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.566] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.567] Searching for globals...
[17:39:51.568] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:39:51.569] Searching for globals ... DONE
[17:39:51.569] Resolving globals: TRUE
[17:39:51.569] Resolving any globals that are futures ...
[17:39:51.569] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:39:51.569] Resolving any globals that are futures ... DONE
[17:39:51.569] Resolving futures part of globals (recursively) ...
[17:39:51.569] resolve() on list ...
[17:39:51.570]  recursive: 99
[17:39:51.570]  length: 2
[17:39:51.570]  elements: ‘x’, ‘name’
[17:39:51.570]  length: 1 (resolved future 1)
[17:39:51.570]  length: 0 (resolved future 2)
[17:39:51.570] resolve() on list ... DONE
[17:39:51.570] - globals: [2] ‘x’, ‘name’
[17:39:51.570] Resolving futures part of globals (recursively) ... DONE
[17:39:51.570] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:51.571] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:39:51.571] - globals: [2] ‘x’, ‘name’
[17:39:51.571] 
[17:39:51.571] getGlobalsAndPackages() ... DONE
[17:39:51.571] run() for ‘Future’ ...
[17:39:51.571] - state: ‘created’
[17:39:51.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:51.572] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:51.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:51.572]   - Field: ‘label’
[17:39:51.572]   - Field: ‘local’
[17:39:51.572]   - Field: ‘owner’
[17:39:51.572]   - Field: ‘envir’
[17:39:51.572]   - Field: ‘packages’
[17:39:51.572]   - Field: ‘gc’
[17:39:51.572]   - Field: ‘conditions’
[17:39:51.572]   - Field: ‘expr’
[17:39:51.573]   - Field: ‘uuid’
[17:39:51.573]   - Field: ‘seed’
[17:39:51.573]   - Field: ‘version’
[17:39:51.573]   - Field: ‘result’
[17:39:51.573]   - Field: ‘asynchronous’
[17:39:51.573]   - Field: ‘calls’
[17:39:51.573]   - Field: ‘globals’
[17:39:51.573]   - Field: ‘stdout’
[17:39:51.573]   - Field: ‘earlySignal’
[17:39:51.573]   - Field: ‘lazy’
[17:39:51.573]   - Field: ‘state’
[17:39:51.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:51.574] - Launch lazy future ...
[17:39:51.574] Packages needed by the future expression (n = 0): <none>
[17:39:51.574] Packages needed by future strategies (n = 0): <none>
[17:39:51.574] {
[17:39:51.574]     {
[17:39:51.574]         {
[17:39:51.574]             ...future.startTime <- base::Sys.time()
[17:39:51.574]             {
[17:39:51.574]                 {
[17:39:51.574]                   {
[17:39:51.574]                     base::local({
[17:39:51.574]                       has_future <- base::requireNamespace("future", 
[17:39:51.574]                         quietly = TRUE)
[17:39:51.574]                       if (has_future) {
[17:39:51.574]                         ns <- base::getNamespace("future")
[17:39:51.574]                         version <- ns[[".package"]][["version"]]
[17:39:51.574]                         if (is.null(version)) 
[17:39:51.574]                           version <- utils::packageVersion("future")
[17:39:51.574]                       }
[17:39:51.574]                       else {
[17:39:51.574]                         version <- NULL
[17:39:51.574]                       }
[17:39:51.574]                       if (!has_future || version < "1.8.0") {
[17:39:51.574]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.574]                           "", base::R.version$version.string), 
[17:39:51.574]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:51.574]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.574]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.574]                             "release", "version")], collapse = " "), 
[17:39:51.574]                           hostname = base::Sys.info()[["nodename"]])
[17:39:51.574]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.574]                           info)
[17:39:51.574]                         info <- base::paste(info, collapse = "; ")
[17:39:51.574]                         if (!has_future) {
[17:39:51.574]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.574]                             info)
[17:39:51.574]                         }
[17:39:51.574]                         else {
[17:39:51.574]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.574]                             info, version)
[17:39:51.574]                         }
[17:39:51.574]                         base::stop(msg)
[17:39:51.574]                       }
[17:39:51.574]                     })
[17:39:51.574]                   }
[17:39:51.574]                   ...future.strategy.old <- future::plan("list")
[17:39:51.574]                   options(future.plan = NULL)
[17:39:51.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.574]                 }
[17:39:51.574]                 ...future.workdir <- getwd()
[17:39:51.574]             }
[17:39:51.574]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.574]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.574]         }
[17:39:51.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.574]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.574]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.574]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.574]             base::names(...future.oldOptions))
[17:39:51.574]     }
[17:39:51.574]     if (FALSE) {
[17:39:51.574]     }
[17:39:51.574]     else {
[17:39:51.574]         if (TRUE) {
[17:39:51.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.574]                 open = "w")
[17:39:51.574]         }
[17:39:51.574]         else {
[17:39:51.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.574]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.574]         }
[17:39:51.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.574]             base::sink(type = "output", split = FALSE)
[17:39:51.574]             base::close(...future.stdout)
[17:39:51.574]         }, add = TRUE)
[17:39:51.574]     }
[17:39:51.574]     ...future.frame <- base::sys.nframe()
[17:39:51.574]     ...future.conditions <- base::list()
[17:39:51.574]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.574]     if (FALSE) {
[17:39:51.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.574]     }
[17:39:51.574]     ...future.result <- base::tryCatch({
[17:39:51.574]         base::withCallingHandlers({
[17:39:51.574]             ...future.value <- base::withVisible(base::local({
[17:39:51.574]                 x[name] <- list(1)
[17:39:51.574]                 x
[17:39:51.574]             }))
[17:39:51.574]             future::FutureResult(value = ...future.value$value, 
[17:39:51.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.574]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.574]                     ...future.globalenv.names))
[17:39:51.574]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.574]         }, condition = base::local({
[17:39:51.574]             c <- base::c
[17:39:51.574]             inherits <- base::inherits
[17:39:51.574]             invokeRestart <- base::invokeRestart
[17:39:51.574]             length <- base::length
[17:39:51.574]             list <- base::list
[17:39:51.574]             seq.int <- base::seq.int
[17:39:51.574]             signalCondition <- base::signalCondition
[17:39:51.574]             sys.calls <- base::sys.calls
[17:39:51.574]             `[[` <- base::`[[`
[17:39:51.574]             `+` <- base::`+`
[17:39:51.574]             `<<-` <- base::`<<-`
[17:39:51.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.574]                   3L)]
[17:39:51.574]             }
[17:39:51.574]             function(cond) {
[17:39:51.574]                 is_error <- inherits(cond, "error")
[17:39:51.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.574]                   NULL)
[17:39:51.574]                 if (is_error) {
[17:39:51.574]                   sessionInformation <- function() {
[17:39:51.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.574]                       search = base::search(), system = base::Sys.info())
[17:39:51.574]                   }
[17:39:51.574]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.574]                     cond$call), session = sessionInformation(), 
[17:39:51.574]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.574]                   signalCondition(cond)
[17:39:51.574]                 }
[17:39:51.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.574]                 "immediateCondition"))) {
[17:39:51.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.574]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.574]                   if (TRUE && !signal) {
[17:39:51.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.574]                     {
[17:39:51.574]                       inherits <- base::inherits
[17:39:51.574]                       invokeRestart <- base::invokeRestart
[17:39:51.574]                       is.null <- base::is.null
[17:39:51.574]                       muffled <- FALSE
[17:39:51.574]                       if (inherits(cond, "message")) {
[17:39:51.574]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.574]                         if (muffled) 
[17:39:51.574]                           invokeRestart("muffleMessage")
[17:39:51.574]                       }
[17:39:51.574]                       else if (inherits(cond, "warning")) {
[17:39:51.574]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.574]                         if (muffled) 
[17:39:51.574]                           invokeRestart("muffleWarning")
[17:39:51.574]                       }
[17:39:51.574]                       else if (inherits(cond, "condition")) {
[17:39:51.574]                         if (!is.null(pattern)) {
[17:39:51.574]                           computeRestarts <- base::computeRestarts
[17:39:51.574]                           grepl <- base::grepl
[17:39:51.574]                           restarts <- computeRestarts(cond)
[17:39:51.574]                           for (restart in restarts) {
[17:39:51.574]                             name <- restart$name
[17:39:51.574]                             if (is.null(name)) 
[17:39:51.574]                               next
[17:39:51.574]                             if (!grepl(pattern, name)) 
[17:39:51.574]                               next
[17:39:51.574]                             invokeRestart(restart)
[17:39:51.574]                             muffled <- TRUE
[17:39:51.574]                             break
[17:39:51.574]                           }
[17:39:51.574]                         }
[17:39:51.574]                       }
[17:39:51.574]                       invisible(muffled)
[17:39:51.574]                     }
[17:39:51.574]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.574]                   }
[17:39:51.574]                 }
[17:39:51.574]                 else {
[17:39:51.574]                   if (TRUE) {
[17:39:51.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.574]                     {
[17:39:51.574]                       inherits <- base::inherits
[17:39:51.574]                       invokeRestart <- base::invokeRestart
[17:39:51.574]                       is.null <- base::is.null
[17:39:51.574]                       muffled <- FALSE
[17:39:51.574]                       if (inherits(cond, "message")) {
[17:39:51.574]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.574]                         if (muffled) 
[17:39:51.574]                           invokeRestart("muffleMessage")
[17:39:51.574]                       }
[17:39:51.574]                       else if (inherits(cond, "warning")) {
[17:39:51.574]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.574]                         if (muffled) 
[17:39:51.574]                           invokeRestart("muffleWarning")
[17:39:51.574]                       }
[17:39:51.574]                       else if (inherits(cond, "condition")) {
[17:39:51.574]                         if (!is.null(pattern)) {
[17:39:51.574]                           computeRestarts <- base::computeRestarts
[17:39:51.574]                           grepl <- base::grepl
[17:39:51.574]                           restarts <- computeRestarts(cond)
[17:39:51.574]                           for (restart in restarts) {
[17:39:51.574]                             name <- restart$name
[17:39:51.574]                             if (is.null(name)) 
[17:39:51.574]                               next
[17:39:51.574]                             if (!grepl(pattern, name)) 
[17:39:51.574]                               next
[17:39:51.574]                             invokeRestart(restart)
[17:39:51.574]                             muffled <- TRUE
[17:39:51.574]                             break
[17:39:51.574]                           }
[17:39:51.574]                         }
[17:39:51.574]                       }
[17:39:51.574]                       invisible(muffled)
[17:39:51.574]                     }
[17:39:51.574]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.574]                   }
[17:39:51.574]                 }
[17:39:51.574]             }
[17:39:51.574]         }))
[17:39:51.574]     }, error = function(ex) {
[17:39:51.574]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.574]                 ...future.rng), started = ...future.startTime, 
[17:39:51.574]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.574]             version = "1.8"), class = "FutureResult")
[17:39:51.574]     }, finally = {
[17:39:51.574]         if (!identical(...future.workdir, getwd())) 
[17:39:51.574]             setwd(...future.workdir)
[17:39:51.574]         {
[17:39:51.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.574]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.574]             }
[17:39:51.574]             base::options(...future.oldOptions)
[17:39:51.574]             if (.Platform$OS.type == "windows") {
[17:39:51.574]                 old_names <- names(...future.oldEnvVars)
[17:39:51.574]                 envs <- base::Sys.getenv()
[17:39:51.574]                 names <- names(envs)
[17:39:51.574]                 common <- intersect(names, old_names)
[17:39:51.574]                 added <- setdiff(names, old_names)
[17:39:51.574]                 removed <- setdiff(old_names, names)
[17:39:51.574]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.574]                   envs[common]]
[17:39:51.574]                 NAMES <- toupper(changed)
[17:39:51.574]                 args <- list()
[17:39:51.574]                 for (kk in seq_along(NAMES)) {
[17:39:51.574]                   name <- changed[[kk]]
[17:39:51.574]                   NAME <- NAMES[[kk]]
[17:39:51.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.574]                     next
[17:39:51.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.574]                 }
[17:39:51.574]                 NAMES <- toupper(added)
[17:39:51.574]                 for (kk in seq_along(NAMES)) {
[17:39:51.574]                   name <- added[[kk]]
[17:39:51.574]                   NAME <- NAMES[[kk]]
[17:39:51.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.574]                     next
[17:39:51.574]                   args[[name]] <- ""
[17:39:51.574]                 }
[17:39:51.574]                 NAMES <- toupper(removed)
[17:39:51.574]                 for (kk in seq_along(NAMES)) {
[17:39:51.574]                   name <- removed[[kk]]
[17:39:51.574]                   NAME <- NAMES[[kk]]
[17:39:51.574]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.574]                     next
[17:39:51.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.574]                 }
[17:39:51.574]                 if (length(args) > 0) 
[17:39:51.574]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.574]             }
[17:39:51.574]             else {
[17:39:51.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.574]             }
[17:39:51.574]             {
[17:39:51.574]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.574]                   0L) {
[17:39:51.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.574]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.574]                   base::options(opts)
[17:39:51.574]                 }
[17:39:51.574]                 {
[17:39:51.574]                   {
[17:39:51.574]                     NULL
[17:39:51.574]                     RNGkind("Mersenne-Twister")
[17:39:51.574]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:51.574]                       inherits = FALSE)
[17:39:51.574]                   }
[17:39:51.574]                   options(future.plan = NULL)
[17:39:51.574]                   if (is.na(NA_character_)) 
[17:39:51.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.574]                     .init = FALSE)
[17:39:51.574]                 }
[17:39:51.574]             }
[17:39:51.574]         }
[17:39:51.574]     })
[17:39:51.574]     if (TRUE) {
[17:39:51.574]         base::sink(type = "output", split = FALSE)
[17:39:51.574]         if (TRUE) {
[17:39:51.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.574]         }
[17:39:51.574]         else {
[17:39:51.574]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.574]         }
[17:39:51.574]         base::close(...future.stdout)
[17:39:51.574]         ...future.stdout <- NULL
[17:39:51.574]     }
[17:39:51.574]     ...future.result$conditions <- ...future.conditions
[17:39:51.574]     ...future.result$finished <- base::Sys.time()
[17:39:51.574]     ...future.result
[17:39:51.574] }
[17:39:51.576] assign_globals() ...
[17:39:51.576] List of 2
[17:39:51.576]  $ x   : list()
[17:39:51.576]  $ name: chr "a"
[17:39:51.576]  - attr(*, "where")=List of 2
[17:39:51.576]   ..$ x   :<environment: R_EmptyEnv> 
[17:39:51.576]   ..$ name:<environment: R_EmptyEnv> 
[17:39:51.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.576]  - attr(*, "resolved")= logi TRUE
[17:39:51.576]  - attr(*, "total_size")= num 112
[17:39:51.576]  - attr(*, "already-done")= logi TRUE
[17:39:51.578] - copied ‘x’ to environment
[17:39:51.578] - copied ‘name’ to environment
[17:39:51.579] assign_globals() ... done
[17:39:51.579] plan(): Setting new future strategy stack:
[17:39:51.579] List of future strategies:
[17:39:51.579] 1. sequential:
[17:39:51.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.579]    - tweaked: FALSE
[17:39:51.579]    - call: NULL
[17:39:51.579] plan(): nbrOfWorkers() = 1
[17:39:51.580] plan(): Setting new future strategy stack:
[17:39:51.580] List of future strategies:
[17:39:51.580] 1. sequential:
[17:39:51.580]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.580]    - tweaked: FALSE
[17:39:51.580]    - call: plan(strategy)
[17:39:51.581] plan(): nbrOfWorkers() = 1
[17:39:51.582] SequentialFuture started (and completed)
[17:39:51.582] - Launch lazy future ... done
[17:39:51.582] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:39:51.590] plan(): Setting new future strategy stack:
[17:39:51.590] List of future strategies:
[17:39:51.590] 1. multicore:
[17:39:51.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.590]    - tweaked: FALSE
[17:39:51.590]    - call: plan(strategy)
[17:39:51.594] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.594] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.594] Searching for globals...
[17:39:51.596] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.596] Searching for globals ... DONE
[17:39:51.596] Resolving globals: TRUE
[17:39:51.596] Resolving any globals that are futures ...
[17:39:51.596] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.596] Resolving any globals that are futures ... DONE
[17:39:51.597] Resolving futures part of globals (recursively) ...
[17:39:51.597] resolve() on list ...
[17:39:51.597]  recursive: 99
[17:39:51.597]  length: 1
[17:39:51.597]  elements: ‘x’
[17:39:51.597]  length: 0 (resolved future 1)
[17:39:51.597] resolve() on list ... DONE
[17:39:51.597] - globals: [1] ‘x’
[17:39:51.598] Resolving futures part of globals (recursively) ... DONE
[17:39:51.598] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.598] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.598] - globals: [1] ‘x’
[17:39:51.598] 
[17:39:51.598] getGlobalsAndPackages() ... DONE
[17:39:51.599] run() for ‘Future’ ...
[17:39:51.599] - state: ‘created’
[17:39:51.599] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.602] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.602]   - Field: ‘label’
[17:39:51.602]   - Field: ‘local’
[17:39:51.603]   - Field: ‘owner’
[17:39:51.603]   - Field: ‘envir’
[17:39:51.603]   - Field: ‘workers’
[17:39:51.603]   - Field: ‘packages’
[17:39:51.603]   - Field: ‘gc’
[17:39:51.603]   - Field: ‘job’
[17:39:51.603]   - Field: ‘conditions’
[17:39:51.603]   - Field: ‘expr’
[17:39:51.603]   - Field: ‘uuid’
[17:39:51.603]   - Field: ‘seed’
[17:39:51.603]   - Field: ‘version’
[17:39:51.604]   - Field: ‘result’
[17:39:51.604]   - Field: ‘asynchronous’
[17:39:51.604]   - Field: ‘calls’
[17:39:51.604]   - Field: ‘globals’
[17:39:51.604]   - Field: ‘stdout’
[17:39:51.604]   - Field: ‘earlySignal’
[17:39:51.604]   - Field: ‘lazy’
[17:39:51.604]   - Field: ‘state’
[17:39:51.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.604] - Launch lazy future ...
[17:39:51.605] Packages needed by the future expression (n = 0): <none>
[17:39:51.605] Packages needed by future strategies (n = 0): <none>
[17:39:51.606] {
[17:39:51.606]     {
[17:39:51.606]         {
[17:39:51.606]             ...future.startTime <- base::Sys.time()
[17:39:51.606]             {
[17:39:51.606]                 {
[17:39:51.606]                   {
[17:39:51.606]                     {
[17:39:51.606]                       base::local({
[17:39:51.606]                         has_future <- base::requireNamespace("future", 
[17:39:51.606]                           quietly = TRUE)
[17:39:51.606]                         if (has_future) {
[17:39:51.606]                           ns <- base::getNamespace("future")
[17:39:51.606]                           version <- ns[[".package"]][["version"]]
[17:39:51.606]                           if (is.null(version)) 
[17:39:51.606]                             version <- utils::packageVersion("future")
[17:39:51.606]                         }
[17:39:51.606]                         else {
[17:39:51.606]                           version <- NULL
[17:39:51.606]                         }
[17:39:51.606]                         if (!has_future || version < "1.8.0") {
[17:39:51.606]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.606]                             "", base::R.version$version.string), 
[17:39:51.606]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.606]                               "release", "version")], collapse = " "), 
[17:39:51.606]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.606]                             info)
[17:39:51.606]                           info <- base::paste(info, collapse = "; ")
[17:39:51.606]                           if (!has_future) {
[17:39:51.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.606]                               info)
[17:39:51.606]                           }
[17:39:51.606]                           else {
[17:39:51.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.606]                               info, version)
[17:39:51.606]                           }
[17:39:51.606]                           base::stop(msg)
[17:39:51.606]                         }
[17:39:51.606]                       })
[17:39:51.606]                     }
[17:39:51.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.606]                     base::options(mc.cores = 1L)
[17:39:51.606]                   }
[17:39:51.606]                   ...future.strategy.old <- future::plan("list")
[17:39:51.606]                   options(future.plan = NULL)
[17:39:51.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.606]                 }
[17:39:51.606]                 ...future.workdir <- getwd()
[17:39:51.606]             }
[17:39:51.606]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.606]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.606]         }
[17:39:51.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.606]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.606]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.606]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.606]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.606]             base::names(...future.oldOptions))
[17:39:51.606]     }
[17:39:51.606]     if (FALSE) {
[17:39:51.606]     }
[17:39:51.606]     else {
[17:39:51.606]         if (TRUE) {
[17:39:51.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.606]                 open = "w")
[17:39:51.606]         }
[17:39:51.606]         else {
[17:39:51.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.606]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.606]         }
[17:39:51.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.606]             base::sink(type = "output", split = FALSE)
[17:39:51.606]             base::close(...future.stdout)
[17:39:51.606]         }, add = TRUE)
[17:39:51.606]     }
[17:39:51.606]     ...future.frame <- base::sys.nframe()
[17:39:51.606]     ...future.conditions <- base::list()
[17:39:51.606]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.606]     if (FALSE) {
[17:39:51.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.606]     }
[17:39:51.606]     ...future.result <- base::tryCatch({
[17:39:51.606]         base::withCallingHandlers({
[17:39:51.606]             ...future.value <- base::withVisible(base::local({
[17:39:51.606]                 withCallingHandlers({
[17:39:51.606]                   {
[17:39:51.606]                     x$a <- 1
[17:39:51.606]                     x
[17:39:51.606]                   }
[17:39:51.606]                 }, immediateCondition = function(cond) {
[17:39:51.606]                   save_rds <- function (object, pathname, ...) 
[17:39:51.606]                   {
[17:39:51.606]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.606]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.606]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.606]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.606]                         fi_tmp[["mtime"]])
[17:39:51.606]                     }
[17:39:51.606]                     tryCatch({
[17:39:51.606]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.606]                     }, error = function(ex) {
[17:39:51.606]                       msg <- conditionMessage(ex)
[17:39:51.606]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.606]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.606]                         fi_tmp[["mtime"]], msg)
[17:39:51.606]                       ex$message <- msg
[17:39:51.606]                       stop(ex)
[17:39:51.606]                     })
[17:39:51.606]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.606]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.606]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.606]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.606]                       fi <- file.info(pathname)
[17:39:51.606]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.606]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.606]                         fi[["size"]], fi[["mtime"]])
[17:39:51.606]                       stop(msg)
[17:39:51.606]                     }
[17:39:51.606]                     invisible(pathname)
[17:39:51.606]                   }
[17:39:51.606]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.606]                     rootPath = tempdir()) 
[17:39:51.606]                   {
[17:39:51.606]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.606]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.606]                       tmpdir = path, fileext = ".rds")
[17:39:51.606]                     save_rds(obj, file)
[17:39:51.606]                   }
[17:39:51.606]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.606]                   {
[17:39:51.606]                     inherits <- base::inherits
[17:39:51.606]                     invokeRestart <- base::invokeRestart
[17:39:51.606]                     is.null <- base::is.null
[17:39:51.606]                     muffled <- FALSE
[17:39:51.606]                     if (inherits(cond, "message")) {
[17:39:51.606]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.606]                       if (muffled) 
[17:39:51.606]                         invokeRestart("muffleMessage")
[17:39:51.606]                     }
[17:39:51.606]                     else if (inherits(cond, "warning")) {
[17:39:51.606]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.606]                       if (muffled) 
[17:39:51.606]                         invokeRestart("muffleWarning")
[17:39:51.606]                     }
[17:39:51.606]                     else if (inherits(cond, "condition")) {
[17:39:51.606]                       if (!is.null(pattern)) {
[17:39:51.606]                         computeRestarts <- base::computeRestarts
[17:39:51.606]                         grepl <- base::grepl
[17:39:51.606]                         restarts <- computeRestarts(cond)
[17:39:51.606]                         for (restart in restarts) {
[17:39:51.606]                           name <- restart$name
[17:39:51.606]                           if (is.null(name)) 
[17:39:51.606]                             next
[17:39:51.606]                           if (!grepl(pattern, name)) 
[17:39:51.606]                             next
[17:39:51.606]                           invokeRestart(restart)
[17:39:51.606]                           muffled <- TRUE
[17:39:51.606]                           break
[17:39:51.606]                         }
[17:39:51.606]                       }
[17:39:51.606]                     }
[17:39:51.606]                     invisible(muffled)
[17:39:51.606]                   }
[17:39:51.606]                   muffleCondition(cond)
[17:39:51.606]                 })
[17:39:51.606]             }))
[17:39:51.606]             future::FutureResult(value = ...future.value$value, 
[17:39:51.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.606]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.606]                     ...future.globalenv.names))
[17:39:51.606]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.606]         }, condition = base::local({
[17:39:51.606]             c <- base::c
[17:39:51.606]             inherits <- base::inherits
[17:39:51.606]             invokeRestart <- base::invokeRestart
[17:39:51.606]             length <- base::length
[17:39:51.606]             list <- base::list
[17:39:51.606]             seq.int <- base::seq.int
[17:39:51.606]             signalCondition <- base::signalCondition
[17:39:51.606]             sys.calls <- base::sys.calls
[17:39:51.606]             `[[` <- base::`[[`
[17:39:51.606]             `+` <- base::`+`
[17:39:51.606]             `<<-` <- base::`<<-`
[17:39:51.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.606]                   3L)]
[17:39:51.606]             }
[17:39:51.606]             function(cond) {
[17:39:51.606]                 is_error <- inherits(cond, "error")
[17:39:51.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.606]                   NULL)
[17:39:51.606]                 if (is_error) {
[17:39:51.606]                   sessionInformation <- function() {
[17:39:51.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.606]                       search = base::search(), system = base::Sys.info())
[17:39:51.606]                   }
[17:39:51.606]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.606]                     cond$call), session = sessionInformation(), 
[17:39:51.606]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.606]                   signalCondition(cond)
[17:39:51.606]                 }
[17:39:51.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.606]                 "immediateCondition"))) {
[17:39:51.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.606]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.606]                   if (TRUE && !signal) {
[17:39:51.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.606]                     {
[17:39:51.606]                       inherits <- base::inherits
[17:39:51.606]                       invokeRestart <- base::invokeRestart
[17:39:51.606]                       is.null <- base::is.null
[17:39:51.606]                       muffled <- FALSE
[17:39:51.606]                       if (inherits(cond, "message")) {
[17:39:51.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.606]                         if (muffled) 
[17:39:51.606]                           invokeRestart("muffleMessage")
[17:39:51.606]                       }
[17:39:51.606]                       else if (inherits(cond, "warning")) {
[17:39:51.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.606]                         if (muffled) 
[17:39:51.606]                           invokeRestart("muffleWarning")
[17:39:51.606]                       }
[17:39:51.606]                       else if (inherits(cond, "condition")) {
[17:39:51.606]                         if (!is.null(pattern)) {
[17:39:51.606]                           computeRestarts <- base::computeRestarts
[17:39:51.606]                           grepl <- base::grepl
[17:39:51.606]                           restarts <- computeRestarts(cond)
[17:39:51.606]                           for (restart in restarts) {
[17:39:51.606]                             name <- restart$name
[17:39:51.606]                             if (is.null(name)) 
[17:39:51.606]                               next
[17:39:51.606]                             if (!grepl(pattern, name)) 
[17:39:51.606]                               next
[17:39:51.606]                             invokeRestart(restart)
[17:39:51.606]                             muffled <- TRUE
[17:39:51.606]                             break
[17:39:51.606]                           }
[17:39:51.606]                         }
[17:39:51.606]                       }
[17:39:51.606]                       invisible(muffled)
[17:39:51.606]                     }
[17:39:51.606]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.606]                   }
[17:39:51.606]                 }
[17:39:51.606]                 else {
[17:39:51.606]                   if (TRUE) {
[17:39:51.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.606]                     {
[17:39:51.606]                       inherits <- base::inherits
[17:39:51.606]                       invokeRestart <- base::invokeRestart
[17:39:51.606]                       is.null <- base::is.null
[17:39:51.606]                       muffled <- FALSE
[17:39:51.606]                       if (inherits(cond, "message")) {
[17:39:51.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.606]                         if (muffled) 
[17:39:51.606]                           invokeRestart("muffleMessage")
[17:39:51.606]                       }
[17:39:51.606]                       else if (inherits(cond, "warning")) {
[17:39:51.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.606]                         if (muffled) 
[17:39:51.606]                           invokeRestart("muffleWarning")
[17:39:51.606]                       }
[17:39:51.606]                       else if (inherits(cond, "condition")) {
[17:39:51.606]                         if (!is.null(pattern)) {
[17:39:51.606]                           computeRestarts <- base::computeRestarts
[17:39:51.606]                           grepl <- base::grepl
[17:39:51.606]                           restarts <- computeRestarts(cond)
[17:39:51.606]                           for (restart in restarts) {
[17:39:51.606]                             name <- restart$name
[17:39:51.606]                             if (is.null(name)) 
[17:39:51.606]                               next
[17:39:51.606]                             if (!grepl(pattern, name)) 
[17:39:51.606]                               next
[17:39:51.606]                             invokeRestart(restart)
[17:39:51.606]                             muffled <- TRUE
[17:39:51.606]                             break
[17:39:51.606]                           }
[17:39:51.606]                         }
[17:39:51.606]                       }
[17:39:51.606]                       invisible(muffled)
[17:39:51.606]                     }
[17:39:51.606]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.606]                   }
[17:39:51.606]                 }
[17:39:51.606]             }
[17:39:51.606]         }))
[17:39:51.606]     }, error = function(ex) {
[17:39:51.606]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.606]                 ...future.rng), started = ...future.startTime, 
[17:39:51.606]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.606]             version = "1.8"), class = "FutureResult")
[17:39:51.606]     }, finally = {
[17:39:51.606]         if (!identical(...future.workdir, getwd())) 
[17:39:51.606]             setwd(...future.workdir)
[17:39:51.606]         {
[17:39:51.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.606]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.606]             }
[17:39:51.606]             base::options(...future.oldOptions)
[17:39:51.606]             if (.Platform$OS.type == "windows") {
[17:39:51.606]                 old_names <- names(...future.oldEnvVars)
[17:39:51.606]                 envs <- base::Sys.getenv()
[17:39:51.606]                 names <- names(envs)
[17:39:51.606]                 common <- intersect(names, old_names)
[17:39:51.606]                 added <- setdiff(names, old_names)
[17:39:51.606]                 removed <- setdiff(old_names, names)
[17:39:51.606]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.606]                   envs[common]]
[17:39:51.606]                 NAMES <- toupper(changed)
[17:39:51.606]                 args <- list()
[17:39:51.606]                 for (kk in seq_along(NAMES)) {
[17:39:51.606]                   name <- changed[[kk]]
[17:39:51.606]                   NAME <- NAMES[[kk]]
[17:39:51.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.606]                     next
[17:39:51.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.606]                 }
[17:39:51.606]                 NAMES <- toupper(added)
[17:39:51.606]                 for (kk in seq_along(NAMES)) {
[17:39:51.606]                   name <- added[[kk]]
[17:39:51.606]                   NAME <- NAMES[[kk]]
[17:39:51.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.606]                     next
[17:39:51.606]                   args[[name]] <- ""
[17:39:51.606]                 }
[17:39:51.606]                 NAMES <- toupper(removed)
[17:39:51.606]                 for (kk in seq_along(NAMES)) {
[17:39:51.606]                   name <- removed[[kk]]
[17:39:51.606]                   NAME <- NAMES[[kk]]
[17:39:51.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.606]                     next
[17:39:51.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.606]                 }
[17:39:51.606]                 if (length(args) > 0) 
[17:39:51.606]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.606]             }
[17:39:51.606]             else {
[17:39:51.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.606]             }
[17:39:51.606]             {
[17:39:51.606]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.606]                   0L) {
[17:39:51.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.606]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.606]                   base::options(opts)
[17:39:51.606]                 }
[17:39:51.606]                 {
[17:39:51.606]                   {
[17:39:51.606]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.606]                     NULL
[17:39:51.606]                   }
[17:39:51.606]                   options(future.plan = NULL)
[17:39:51.606]                   if (is.na(NA_character_)) 
[17:39:51.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.606]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.606]                     .init = FALSE)
[17:39:51.606]                 }
[17:39:51.606]             }
[17:39:51.606]         }
[17:39:51.606]     })
[17:39:51.606]     if (TRUE) {
[17:39:51.606]         base::sink(type = "output", split = FALSE)
[17:39:51.606]         if (TRUE) {
[17:39:51.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.606]         }
[17:39:51.606]         else {
[17:39:51.606]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.606]         }
[17:39:51.606]         base::close(...future.stdout)
[17:39:51.606]         ...future.stdout <- NULL
[17:39:51.606]     }
[17:39:51.606]     ...future.result$conditions <- ...future.conditions
[17:39:51.606]     ...future.result$finished <- base::Sys.time()
[17:39:51.606]     ...future.result
[17:39:51.606] }
[17:39:51.608] assign_globals() ...
[17:39:51.608] List of 1
[17:39:51.608]  $ x: list()
[17:39:51.608]  - attr(*, "where")=List of 1
[17:39:51.608]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.608]  - attr(*, "resolved")= logi TRUE
[17:39:51.608]  - attr(*, "total_size")= num 0
[17:39:51.608]  - attr(*, "already-done")= logi TRUE
[17:39:51.610] - copied ‘x’ to environment
[17:39:51.610] assign_globals() ... done
[17:39:51.610] requestCore(): workers = 2
[17:39:51.613] MulticoreFuture started
[17:39:51.614] - Launch lazy future ... done
[17:39:51.614] plan(): Setting new future strategy stack:
[17:39:51.614] run() for ‘MulticoreFuture’ ... done
[17:39:51.614] List of future strategies:
[17:39:51.614] 1. sequential:
[17:39:51.614]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.614]    - tweaked: FALSE
[17:39:51.614]    - call: NULL
[17:39:51.615] plan(): nbrOfWorkers() = 1
[17:39:51.615] result() for MulticoreFuture ...
[17:39:51.617] plan(): Setting new future strategy stack:
[17:39:51.617] List of future strategies:
[17:39:51.617] 1. multicore:
[17:39:51.617]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.617]    - tweaked: FALSE
[17:39:51.617]    - call: plan(strategy)
[17:39:51.626] plan(): nbrOfWorkers() = 2
[17:39:51.633] result() for MulticoreFuture ...
[17:39:51.633] result() for MulticoreFuture ... done
[17:39:51.633] result() for MulticoreFuture ... done
[17:39:51.633] result() for MulticoreFuture ...
[17:39:51.633] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.634] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.634] Searching for globals...
[17:39:51.637] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.637] Searching for globals ... DONE
[17:39:51.637] Resolving globals: TRUE
[17:39:51.637] Resolving any globals that are futures ...
[17:39:51.637] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.637] Resolving any globals that are futures ... DONE
[17:39:51.638] Resolving futures part of globals (recursively) ...
[17:39:51.638] resolve() on list ...
[17:39:51.638]  recursive: 99
[17:39:51.638]  length: 1
[17:39:51.638]  elements: ‘x’
[17:39:51.638]  length: 0 (resolved future 1)
[17:39:51.638] resolve() on list ... DONE
[17:39:51.639] - globals: [1] ‘x’
[17:39:51.639] Resolving futures part of globals (recursively) ... DONE
[17:39:51.639] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.639] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.639] - globals: [1] ‘x’
[17:39:51.639] 
[17:39:51.640] getGlobalsAndPackages() ... DONE
[17:39:51.640] run() for ‘Future’ ...
[17:39:51.640] - state: ‘created’
[17:39:51.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.644]   - Field: ‘label’
[17:39:51.644]   - Field: ‘local’
[17:39:51.644]   - Field: ‘owner’
[17:39:51.644]   - Field: ‘envir’
[17:39:51.645]   - Field: ‘workers’
[17:39:51.645]   - Field: ‘packages’
[17:39:51.645]   - Field: ‘gc’
[17:39:51.645]   - Field: ‘job’
[17:39:51.645]   - Field: ‘conditions’
[17:39:51.645]   - Field: ‘expr’
[17:39:51.645]   - Field: ‘uuid’
[17:39:51.645]   - Field: ‘seed’
[17:39:51.645]   - Field: ‘version’
[17:39:51.646]   - Field: ‘result’
[17:39:51.646]   - Field: ‘asynchronous’
[17:39:51.646]   - Field: ‘calls’
[17:39:51.646]   - Field: ‘globals’
[17:39:51.646]   - Field: ‘stdout’
[17:39:51.646]   - Field: ‘earlySignal’
[17:39:51.646]   - Field: ‘lazy’
[17:39:51.646]   - Field: ‘state’
[17:39:51.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.646] - Launch lazy future ...
[17:39:51.647] Packages needed by the future expression (n = 0): <none>
[17:39:51.647] Packages needed by future strategies (n = 0): <none>
[17:39:51.647] {
[17:39:51.647]     {
[17:39:51.647]         {
[17:39:51.647]             ...future.startTime <- base::Sys.time()
[17:39:51.647]             {
[17:39:51.647]                 {
[17:39:51.647]                   {
[17:39:51.647]                     {
[17:39:51.647]                       base::local({
[17:39:51.647]                         has_future <- base::requireNamespace("future", 
[17:39:51.647]                           quietly = TRUE)
[17:39:51.647]                         if (has_future) {
[17:39:51.647]                           ns <- base::getNamespace("future")
[17:39:51.647]                           version <- ns[[".package"]][["version"]]
[17:39:51.647]                           if (is.null(version)) 
[17:39:51.647]                             version <- utils::packageVersion("future")
[17:39:51.647]                         }
[17:39:51.647]                         else {
[17:39:51.647]                           version <- NULL
[17:39:51.647]                         }
[17:39:51.647]                         if (!has_future || version < "1.8.0") {
[17:39:51.647]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.647]                             "", base::R.version$version.string), 
[17:39:51.647]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.647]                               "release", "version")], collapse = " "), 
[17:39:51.647]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.647]                             info)
[17:39:51.647]                           info <- base::paste(info, collapse = "; ")
[17:39:51.647]                           if (!has_future) {
[17:39:51.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.647]                               info)
[17:39:51.647]                           }
[17:39:51.647]                           else {
[17:39:51.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.647]                               info, version)
[17:39:51.647]                           }
[17:39:51.647]                           base::stop(msg)
[17:39:51.647]                         }
[17:39:51.647]                       })
[17:39:51.647]                     }
[17:39:51.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.647]                     base::options(mc.cores = 1L)
[17:39:51.647]                   }
[17:39:51.647]                   ...future.strategy.old <- future::plan("list")
[17:39:51.647]                   options(future.plan = NULL)
[17:39:51.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.647]                 }
[17:39:51.647]                 ...future.workdir <- getwd()
[17:39:51.647]             }
[17:39:51.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.647]         }
[17:39:51.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.647]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.647]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.647]             base::names(...future.oldOptions))
[17:39:51.647]     }
[17:39:51.647]     if (FALSE) {
[17:39:51.647]     }
[17:39:51.647]     else {
[17:39:51.647]         if (TRUE) {
[17:39:51.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.647]                 open = "w")
[17:39:51.647]         }
[17:39:51.647]         else {
[17:39:51.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.647]         }
[17:39:51.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.647]             base::sink(type = "output", split = FALSE)
[17:39:51.647]             base::close(...future.stdout)
[17:39:51.647]         }, add = TRUE)
[17:39:51.647]     }
[17:39:51.647]     ...future.frame <- base::sys.nframe()
[17:39:51.647]     ...future.conditions <- base::list()
[17:39:51.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.647]     if (FALSE) {
[17:39:51.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.647]     }
[17:39:51.647]     ...future.result <- base::tryCatch({
[17:39:51.647]         base::withCallingHandlers({
[17:39:51.647]             ...future.value <- base::withVisible(base::local({
[17:39:51.647]                 withCallingHandlers({
[17:39:51.647]                   {
[17:39:51.647]                     x$a <- 1
[17:39:51.647]                     x
[17:39:51.647]                   }
[17:39:51.647]                 }, immediateCondition = function(cond) {
[17:39:51.647]                   save_rds <- function (object, pathname, ...) 
[17:39:51.647]                   {
[17:39:51.647]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.647]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.647]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.647]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.647]                         fi_tmp[["mtime"]])
[17:39:51.647]                     }
[17:39:51.647]                     tryCatch({
[17:39:51.647]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.647]                     }, error = function(ex) {
[17:39:51.647]                       msg <- conditionMessage(ex)
[17:39:51.647]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.647]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.647]                         fi_tmp[["mtime"]], msg)
[17:39:51.647]                       ex$message <- msg
[17:39:51.647]                       stop(ex)
[17:39:51.647]                     })
[17:39:51.647]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.647]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.647]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.647]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.647]                       fi <- file.info(pathname)
[17:39:51.647]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.647]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.647]                         fi[["size"]], fi[["mtime"]])
[17:39:51.647]                       stop(msg)
[17:39:51.647]                     }
[17:39:51.647]                     invisible(pathname)
[17:39:51.647]                   }
[17:39:51.647]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.647]                     rootPath = tempdir()) 
[17:39:51.647]                   {
[17:39:51.647]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.647]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.647]                       tmpdir = path, fileext = ".rds")
[17:39:51.647]                     save_rds(obj, file)
[17:39:51.647]                   }
[17:39:51.647]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.647]                   {
[17:39:51.647]                     inherits <- base::inherits
[17:39:51.647]                     invokeRestart <- base::invokeRestart
[17:39:51.647]                     is.null <- base::is.null
[17:39:51.647]                     muffled <- FALSE
[17:39:51.647]                     if (inherits(cond, "message")) {
[17:39:51.647]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.647]                       if (muffled) 
[17:39:51.647]                         invokeRestart("muffleMessage")
[17:39:51.647]                     }
[17:39:51.647]                     else if (inherits(cond, "warning")) {
[17:39:51.647]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.647]                       if (muffled) 
[17:39:51.647]                         invokeRestart("muffleWarning")
[17:39:51.647]                     }
[17:39:51.647]                     else if (inherits(cond, "condition")) {
[17:39:51.647]                       if (!is.null(pattern)) {
[17:39:51.647]                         computeRestarts <- base::computeRestarts
[17:39:51.647]                         grepl <- base::grepl
[17:39:51.647]                         restarts <- computeRestarts(cond)
[17:39:51.647]                         for (restart in restarts) {
[17:39:51.647]                           name <- restart$name
[17:39:51.647]                           if (is.null(name)) 
[17:39:51.647]                             next
[17:39:51.647]                           if (!grepl(pattern, name)) 
[17:39:51.647]                             next
[17:39:51.647]                           invokeRestart(restart)
[17:39:51.647]                           muffled <- TRUE
[17:39:51.647]                           break
[17:39:51.647]                         }
[17:39:51.647]                       }
[17:39:51.647]                     }
[17:39:51.647]                     invisible(muffled)
[17:39:51.647]                   }
[17:39:51.647]                   muffleCondition(cond)
[17:39:51.647]                 })
[17:39:51.647]             }))
[17:39:51.647]             future::FutureResult(value = ...future.value$value, 
[17:39:51.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.647]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.647]                     ...future.globalenv.names))
[17:39:51.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.647]         }, condition = base::local({
[17:39:51.647]             c <- base::c
[17:39:51.647]             inherits <- base::inherits
[17:39:51.647]             invokeRestart <- base::invokeRestart
[17:39:51.647]             length <- base::length
[17:39:51.647]             list <- base::list
[17:39:51.647]             seq.int <- base::seq.int
[17:39:51.647]             signalCondition <- base::signalCondition
[17:39:51.647]             sys.calls <- base::sys.calls
[17:39:51.647]             `[[` <- base::`[[`
[17:39:51.647]             `+` <- base::`+`
[17:39:51.647]             `<<-` <- base::`<<-`
[17:39:51.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.647]                   3L)]
[17:39:51.647]             }
[17:39:51.647]             function(cond) {
[17:39:51.647]                 is_error <- inherits(cond, "error")
[17:39:51.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.647]                   NULL)
[17:39:51.647]                 if (is_error) {
[17:39:51.647]                   sessionInformation <- function() {
[17:39:51.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.647]                       search = base::search(), system = base::Sys.info())
[17:39:51.647]                   }
[17:39:51.647]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.647]                     cond$call), session = sessionInformation(), 
[17:39:51.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.647]                   signalCondition(cond)
[17:39:51.647]                 }
[17:39:51.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.647]                 "immediateCondition"))) {
[17:39:51.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.647]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.647]                   if (TRUE && !signal) {
[17:39:51.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.647]                     {
[17:39:51.647]                       inherits <- base::inherits
[17:39:51.647]                       invokeRestart <- base::invokeRestart
[17:39:51.647]                       is.null <- base::is.null
[17:39:51.647]                       muffled <- FALSE
[17:39:51.647]                       if (inherits(cond, "message")) {
[17:39:51.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.647]                         if (muffled) 
[17:39:51.647]                           invokeRestart("muffleMessage")
[17:39:51.647]                       }
[17:39:51.647]                       else if (inherits(cond, "warning")) {
[17:39:51.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.647]                         if (muffled) 
[17:39:51.647]                           invokeRestart("muffleWarning")
[17:39:51.647]                       }
[17:39:51.647]                       else if (inherits(cond, "condition")) {
[17:39:51.647]                         if (!is.null(pattern)) {
[17:39:51.647]                           computeRestarts <- base::computeRestarts
[17:39:51.647]                           grepl <- base::grepl
[17:39:51.647]                           restarts <- computeRestarts(cond)
[17:39:51.647]                           for (restart in restarts) {
[17:39:51.647]                             name <- restart$name
[17:39:51.647]                             if (is.null(name)) 
[17:39:51.647]                               next
[17:39:51.647]                             if (!grepl(pattern, name)) 
[17:39:51.647]                               next
[17:39:51.647]                             invokeRestart(restart)
[17:39:51.647]                             muffled <- TRUE
[17:39:51.647]                             break
[17:39:51.647]                           }
[17:39:51.647]                         }
[17:39:51.647]                       }
[17:39:51.647]                       invisible(muffled)
[17:39:51.647]                     }
[17:39:51.647]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.647]                   }
[17:39:51.647]                 }
[17:39:51.647]                 else {
[17:39:51.647]                   if (TRUE) {
[17:39:51.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.647]                     {
[17:39:51.647]                       inherits <- base::inherits
[17:39:51.647]                       invokeRestart <- base::invokeRestart
[17:39:51.647]                       is.null <- base::is.null
[17:39:51.647]                       muffled <- FALSE
[17:39:51.647]                       if (inherits(cond, "message")) {
[17:39:51.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.647]                         if (muffled) 
[17:39:51.647]                           invokeRestart("muffleMessage")
[17:39:51.647]                       }
[17:39:51.647]                       else if (inherits(cond, "warning")) {
[17:39:51.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.647]                         if (muffled) 
[17:39:51.647]                           invokeRestart("muffleWarning")
[17:39:51.647]                       }
[17:39:51.647]                       else if (inherits(cond, "condition")) {
[17:39:51.647]                         if (!is.null(pattern)) {
[17:39:51.647]                           computeRestarts <- base::computeRestarts
[17:39:51.647]                           grepl <- base::grepl
[17:39:51.647]                           restarts <- computeRestarts(cond)
[17:39:51.647]                           for (restart in restarts) {
[17:39:51.647]                             name <- restart$name
[17:39:51.647]                             if (is.null(name)) 
[17:39:51.647]                               next
[17:39:51.647]                             if (!grepl(pattern, name)) 
[17:39:51.647]                               next
[17:39:51.647]                             invokeRestart(restart)
[17:39:51.647]                             muffled <- TRUE
[17:39:51.647]                             break
[17:39:51.647]                           }
[17:39:51.647]                         }
[17:39:51.647]                       }
[17:39:51.647]                       invisible(muffled)
[17:39:51.647]                     }
[17:39:51.647]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.647]                   }
[17:39:51.647]                 }
[17:39:51.647]             }
[17:39:51.647]         }))
[17:39:51.647]     }, error = function(ex) {
[17:39:51.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.647]                 ...future.rng), started = ...future.startTime, 
[17:39:51.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.647]             version = "1.8"), class = "FutureResult")
[17:39:51.647]     }, finally = {
[17:39:51.647]         if (!identical(...future.workdir, getwd())) 
[17:39:51.647]             setwd(...future.workdir)
[17:39:51.647]         {
[17:39:51.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.647]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.647]             }
[17:39:51.647]             base::options(...future.oldOptions)
[17:39:51.647]             if (.Platform$OS.type == "windows") {
[17:39:51.647]                 old_names <- names(...future.oldEnvVars)
[17:39:51.647]                 envs <- base::Sys.getenv()
[17:39:51.647]                 names <- names(envs)
[17:39:51.647]                 common <- intersect(names, old_names)
[17:39:51.647]                 added <- setdiff(names, old_names)
[17:39:51.647]                 removed <- setdiff(old_names, names)
[17:39:51.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.647]                   envs[common]]
[17:39:51.647]                 NAMES <- toupper(changed)
[17:39:51.647]                 args <- list()
[17:39:51.647]                 for (kk in seq_along(NAMES)) {
[17:39:51.647]                   name <- changed[[kk]]
[17:39:51.647]                   NAME <- NAMES[[kk]]
[17:39:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.647]                     next
[17:39:51.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.647]                 }
[17:39:51.647]                 NAMES <- toupper(added)
[17:39:51.647]                 for (kk in seq_along(NAMES)) {
[17:39:51.647]                   name <- added[[kk]]
[17:39:51.647]                   NAME <- NAMES[[kk]]
[17:39:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.647]                     next
[17:39:51.647]                   args[[name]] <- ""
[17:39:51.647]                 }
[17:39:51.647]                 NAMES <- toupper(removed)
[17:39:51.647]                 for (kk in seq_along(NAMES)) {
[17:39:51.647]                   name <- removed[[kk]]
[17:39:51.647]                   NAME <- NAMES[[kk]]
[17:39:51.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.647]                     next
[17:39:51.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.647]                 }
[17:39:51.647]                 if (length(args) > 0) 
[17:39:51.647]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.647]             }
[17:39:51.647]             else {
[17:39:51.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.647]             }
[17:39:51.647]             {
[17:39:51.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.647]                   0L) {
[17:39:51.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.647]                   base::options(opts)
[17:39:51.647]                 }
[17:39:51.647]                 {
[17:39:51.647]                   {
[17:39:51.647]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.647]                     NULL
[17:39:51.647]                   }
[17:39:51.647]                   options(future.plan = NULL)
[17:39:51.647]                   if (is.na(NA_character_)) 
[17:39:51.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.647]                     .init = FALSE)
[17:39:51.647]                 }
[17:39:51.647]             }
[17:39:51.647]         }
[17:39:51.647]     })
[17:39:51.647]     if (TRUE) {
[17:39:51.647]         base::sink(type = "output", split = FALSE)
[17:39:51.647]         if (TRUE) {
[17:39:51.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.647]         }
[17:39:51.647]         else {
[17:39:51.647]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.647]         }
[17:39:51.647]         base::close(...future.stdout)
[17:39:51.647]         ...future.stdout <- NULL
[17:39:51.647]     }
[17:39:51.647]     ...future.result$conditions <- ...future.conditions
[17:39:51.647]     ...future.result$finished <- base::Sys.time()
[17:39:51.647]     ...future.result
[17:39:51.647] }
[17:39:51.650] assign_globals() ...
[17:39:51.650] List of 1
[17:39:51.650]  $ x: list()
[17:39:51.650]  - attr(*, "where")=List of 1
[17:39:51.650]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.650]  - attr(*, "resolved")= logi TRUE
[17:39:51.650]  - attr(*, "total_size")= num 0
[17:39:51.650]  - attr(*, "already-done")= logi TRUE
[17:39:51.652] - copied ‘x’ to environment
[17:39:51.653] assign_globals() ... done
[17:39:51.653] requestCore(): workers = 2
[17:39:51.654] MulticoreFuture started
[17:39:51.655] - Launch lazy future ... done
[17:39:51.655] run() for ‘MulticoreFuture’ ... done
[17:39:51.655] result() for MulticoreFuture ...
[17:39:51.656] plan(): Setting new future strategy stack:
[17:39:51.656] List of future strategies:
[17:39:51.656] 1. sequential:
[17:39:51.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.656]    - tweaked: FALSE
[17:39:51.656]    - call: NULL
[17:39:51.657] plan(): nbrOfWorkers() = 1
[17:39:51.659] plan(): Setting new future strategy stack:
[17:39:51.659] List of future strategies:
[17:39:51.659] 1. multicore:
[17:39:51.659]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.659]    - tweaked: FALSE
[17:39:51.659]    - call: plan(strategy)
[17:39:51.664] plan(): nbrOfWorkers() = 2
[17:39:51.664] result() for MulticoreFuture ...
[17:39:51.665] result() for MulticoreFuture ... done
[17:39:51.665] result() for MulticoreFuture ... done
[17:39:51.665] result() for MulticoreFuture ...
[17:39:51.665] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.666] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.666] Searching for globals...
[17:39:51.668] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.669] Searching for globals ... DONE
[17:39:51.669] Resolving globals: TRUE
[17:39:51.669] Resolving any globals that are futures ...
[17:39:51.669] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.669] Resolving any globals that are futures ... DONE
[17:39:51.670] Resolving futures part of globals (recursively) ...
[17:39:51.670] resolve() on list ...
[17:39:51.670]  recursive: 99
[17:39:51.670]  length: 1
[17:39:51.670]  elements: ‘x’
[17:39:51.670]  length: 0 (resolved future 1)
[17:39:51.670] resolve() on list ... DONE
[17:39:51.671] - globals: [1] ‘x’
[17:39:51.671] Resolving futures part of globals (recursively) ... DONE
[17:39:51.671] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.671] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.671] - globals: [1] ‘x’
[17:39:51.672] 
[17:39:51.672] getGlobalsAndPackages() ... DONE
[17:39:51.672] run() for ‘Future’ ...
[17:39:51.672] - state: ‘created’
[17:39:51.672] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.678]   - Field: ‘label’
[17:39:51.678]   - Field: ‘local’
[17:39:51.679]   - Field: ‘owner’
[17:39:51.679]   - Field: ‘envir’
[17:39:51.679]   - Field: ‘workers’
[17:39:51.679]   - Field: ‘packages’
[17:39:51.679]   - Field: ‘gc’
[17:39:51.679]   - Field: ‘job’
[17:39:51.679]   - Field: ‘conditions’
[17:39:51.679]   - Field: ‘expr’
[17:39:51.680]   - Field: ‘uuid’
[17:39:51.680]   - Field: ‘seed’
[17:39:51.680]   - Field: ‘version’
[17:39:51.680]   - Field: ‘result’
[17:39:51.680]   - Field: ‘asynchronous’
[17:39:51.680]   - Field: ‘calls’
[17:39:51.680]   - Field: ‘globals’
[17:39:51.680]   - Field: ‘stdout’
[17:39:51.681]   - Field: ‘earlySignal’
[17:39:51.681]   - Field: ‘lazy’
[17:39:51.681]   - Field: ‘state’
[17:39:51.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.681] - Launch lazy future ...
[17:39:51.681] Packages needed by the future expression (n = 0): <none>
[17:39:51.681] Packages needed by future strategies (n = 0): <none>
[17:39:51.682] {
[17:39:51.682]     {
[17:39:51.682]         {
[17:39:51.682]             ...future.startTime <- base::Sys.time()
[17:39:51.682]             {
[17:39:51.682]                 {
[17:39:51.682]                   {
[17:39:51.682]                     {
[17:39:51.682]                       base::local({
[17:39:51.682]                         has_future <- base::requireNamespace("future", 
[17:39:51.682]                           quietly = TRUE)
[17:39:51.682]                         if (has_future) {
[17:39:51.682]                           ns <- base::getNamespace("future")
[17:39:51.682]                           version <- ns[[".package"]][["version"]]
[17:39:51.682]                           if (is.null(version)) 
[17:39:51.682]                             version <- utils::packageVersion("future")
[17:39:51.682]                         }
[17:39:51.682]                         else {
[17:39:51.682]                           version <- NULL
[17:39:51.682]                         }
[17:39:51.682]                         if (!has_future || version < "1.8.0") {
[17:39:51.682]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.682]                             "", base::R.version$version.string), 
[17:39:51.682]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.682]                               "release", "version")], collapse = " "), 
[17:39:51.682]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.682]                             info)
[17:39:51.682]                           info <- base::paste(info, collapse = "; ")
[17:39:51.682]                           if (!has_future) {
[17:39:51.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.682]                               info)
[17:39:51.682]                           }
[17:39:51.682]                           else {
[17:39:51.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.682]                               info, version)
[17:39:51.682]                           }
[17:39:51.682]                           base::stop(msg)
[17:39:51.682]                         }
[17:39:51.682]                       })
[17:39:51.682]                     }
[17:39:51.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.682]                     base::options(mc.cores = 1L)
[17:39:51.682]                   }
[17:39:51.682]                   ...future.strategy.old <- future::plan("list")
[17:39:51.682]                   options(future.plan = NULL)
[17:39:51.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.682]                 }
[17:39:51.682]                 ...future.workdir <- getwd()
[17:39:51.682]             }
[17:39:51.682]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.682]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.682]         }
[17:39:51.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.682]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.682]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.682]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.682]             base::names(...future.oldOptions))
[17:39:51.682]     }
[17:39:51.682]     if (FALSE) {
[17:39:51.682]     }
[17:39:51.682]     else {
[17:39:51.682]         if (TRUE) {
[17:39:51.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.682]                 open = "w")
[17:39:51.682]         }
[17:39:51.682]         else {
[17:39:51.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.682]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.682]         }
[17:39:51.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.682]             base::sink(type = "output", split = FALSE)
[17:39:51.682]             base::close(...future.stdout)
[17:39:51.682]         }, add = TRUE)
[17:39:51.682]     }
[17:39:51.682]     ...future.frame <- base::sys.nframe()
[17:39:51.682]     ...future.conditions <- base::list()
[17:39:51.682]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.682]     if (FALSE) {
[17:39:51.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.682]     }
[17:39:51.682]     ...future.result <- base::tryCatch({
[17:39:51.682]         base::withCallingHandlers({
[17:39:51.682]             ...future.value <- base::withVisible(base::local({
[17:39:51.682]                 withCallingHandlers({
[17:39:51.682]                   {
[17:39:51.682]                     x$a <- 1
[17:39:51.682]                     x
[17:39:51.682]                   }
[17:39:51.682]                 }, immediateCondition = function(cond) {
[17:39:51.682]                   save_rds <- function (object, pathname, ...) 
[17:39:51.682]                   {
[17:39:51.682]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.682]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.682]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.682]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.682]                         fi_tmp[["mtime"]])
[17:39:51.682]                     }
[17:39:51.682]                     tryCatch({
[17:39:51.682]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.682]                     }, error = function(ex) {
[17:39:51.682]                       msg <- conditionMessage(ex)
[17:39:51.682]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.682]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.682]                         fi_tmp[["mtime"]], msg)
[17:39:51.682]                       ex$message <- msg
[17:39:51.682]                       stop(ex)
[17:39:51.682]                     })
[17:39:51.682]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.682]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.682]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.682]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.682]                       fi <- file.info(pathname)
[17:39:51.682]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.682]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.682]                         fi[["size"]], fi[["mtime"]])
[17:39:51.682]                       stop(msg)
[17:39:51.682]                     }
[17:39:51.682]                     invisible(pathname)
[17:39:51.682]                   }
[17:39:51.682]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.682]                     rootPath = tempdir()) 
[17:39:51.682]                   {
[17:39:51.682]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.682]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.682]                       tmpdir = path, fileext = ".rds")
[17:39:51.682]                     save_rds(obj, file)
[17:39:51.682]                   }
[17:39:51.682]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.682]                   {
[17:39:51.682]                     inherits <- base::inherits
[17:39:51.682]                     invokeRestart <- base::invokeRestart
[17:39:51.682]                     is.null <- base::is.null
[17:39:51.682]                     muffled <- FALSE
[17:39:51.682]                     if (inherits(cond, "message")) {
[17:39:51.682]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.682]                       if (muffled) 
[17:39:51.682]                         invokeRestart("muffleMessage")
[17:39:51.682]                     }
[17:39:51.682]                     else if (inherits(cond, "warning")) {
[17:39:51.682]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.682]                       if (muffled) 
[17:39:51.682]                         invokeRestart("muffleWarning")
[17:39:51.682]                     }
[17:39:51.682]                     else if (inherits(cond, "condition")) {
[17:39:51.682]                       if (!is.null(pattern)) {
[17:39:51.682]                         computeRestarts <- base::computeRestarts
[17:39:51.682]                         grepl <- base::grepl
[17:39:51.682]                         restarts <- computeRestarts(cond)
[17:39:51.682]                         for (restart in restarts) {
[17:39:51.682]                           name <- restart$name
[17:39:51.682]                           if (is.null(name)) 
[17:39:51.682]                             next
[17:39:51.682]                           if (!grepl(pattern, name)) 
[17:39:51.682]                             next
[17:39:51.682]                           invokeRestart(restart)
[17:39:51.682]                           muffled <- TRUE
[17:39:51.682]                           break
[17:39:51.682]                         }
[17:39:51.682]                       }
[17:39:51.682]                     }
[17:39:51.682]                     invisible(muffled)
[17:39:51.682]                   }
[17:39:51.682]                   muffleCondition(cond)
[17:39:51.682]                 })
[17:39:51.682]             }))
[17:39:51.682]             future::FutureResult(value = ...future.value$value, 
[17:39:51.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.682]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.682]                     ...future.globalenv.names))
[17:39:51.682]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.682]         }, condition = base::local({
[17:39:51.682]             c <- base::c
[17:39:51.682]             inherits <- base::inherits
[17:39:51.682]             invokeRestart <- base::invokeRestart
[17:39:51.682]             length <- base::length
[17:39:51.682]             list <- base::list
[17:39:51.682]             seq.int <- base::seq.int
[17:39:51.682]             signalCondition <- base::signalCondition
[17:39:51.682]             sys.calls <- base::sys.calls
[17:39:51.682]             `[[` <- base::`[[`
[17:39:51.682]             `+` <- base::`+`
[17:39:51.682]             `<<-` <- base::`<<-`
[17:39:51.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.682]                   3L)]
[17:39:51.682]             }
[17:39:51.682]             function(cond) {
[17:39:51.682]                 is_error <- inherits(cond, "error")
[17:39:51.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.682]                   NULL)
[17:39:51.682]                 if (is_error) {
[17:39:51.682]                   sessionInformation <- function() {
[17:39:51.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.682]                       search = base::search(), system = base::Sys.info())
[17:39:51.682]                   }
[17:39:51.682]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.682]                     cond$call), session = sessionInformation(), 
[17:39:51.682]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.682]                   signalCondition(cond)
[17:39:51.682]                 }
[17:39:51.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.682]                 "immediateCondition"))) {
[17:39:51.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.682]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.682]                   if (TRUE && !signal) {
[17:39:51.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.682]                     {
[17:39:51.682]                       inherits <- base::inherits
[17:39:51.682]                       invokeRestart <- base::invokeRestart
[17:39:51.682]                       is.null <- base::is.null
[17:39:51.682]                       muffled <- FALSE
[17:39:51.682]                       if (inherits(cond, "message")) {
[17:39:51.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.682]                         if (muffled) 
[17:39:51.682]                           invokeRestart("muffleMessage")
[17:39:51.682]                       }
[17:39:51.682]                       else if (inherits(cond, "warning")) {
[17:39:51.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.682]                         if (muffled) 
[17:39:51.682]                           invokeRestart("muffleWarning")
[17:39:51.682]                       }
[17:39:51.682]                       else if (inherits(cond, "condition")) {
[17:39:51.682]                         if (!is.null(pattern)) {
[17:39:51.682]                           computeRestarts <- base::computeRestarts
[17:39:51.682]                           grepl <- base::grepl
[17:39:51.682]                           restarts <- computeRestarts(cond)
[17:39:51.682]                           for (restart in restarts) {
[17:39:51.682]                             name <- restart$name
[17:39:51.682]                             if (is.null(name)) 
[17:39:51.682]                               next
[17:39:51.682]                             if (!grepl(pattern, name)) 
[17:39:51.682]                               next
[17:39:51.682]                             invokeRestart(restart)
[17:39:51.682]                             muffled <- TRUE
[17:39:51.682]                             break
[17:39:51.682]                           }
[17:39:51.682]                         }
[17:39:51.682]                       }
[17:39:51.682]                       invisible(muffled)
[17:39:51.682]                     }
[17:39:51.682]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.682]                   }
[17:39:51.682]                 }
[17:39:51.682]                 else {
[17:39:51.682]                   if (TRUE) {
[17:39:51.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.682]                     {
[17:39:51.682]                       inherits <- base::inherits
[17:39:51.682]                       invokeRestart <- base::invokeRestart
[17:39:51.682]                       is.null <- base::is.null
[17:39:51.682]                       muffled <- FALSE
[17:39:51.682]                       if (inherits(cond, "message")) {
[17:39:51.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.682]                         if (muffled) 
[17:39:51.682]                           invokeRestart("muffleMessage")
[17:39:51.682]                       }
[17:39:51.682]                       else if (inherits(cond, "warning")) {
[17:39:51.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.682]                         if (muffled) 
[17:39:51.682]                           invokeRestart("muffleWarning")
[17:39:51.682]                       }
[17:39:51.682]                       else if (inherits(cond, "condition")) {
[17:39:51.682]                         if (!is.null(pattern)) {
[17:39:51.682]                           computeRestarts <- base::computeRestarts
[17:39:51.682]                           grepl <- base::grepl
[17:39:51.682]                           restarts <- computeRestarts(cond)
[17:39:51.682]                           for (restart in restarts) {
[17:39:51.682]                             name <- restart$name
[17:39:51.682]                             if (is.null(name)) 
[17:39:51.682]                               next
[17:39:51.682]                             if (!grepl(pattern, name)) 
[17:39:51.682]                               next
[17:39:51.682]                             invokeRestart(restart)
[17:39:51.682]                             muffled <- TRUE
[17:39:51.682]                             break
[17:39:51.682]                           }
[17:39:51.682]                         }
[17:39:51.682]                       }
[17:39:51.682]                       invisible(muffled)
[17:39:51.682]                     }
[17:39:51.682]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.682]                   }
[17:39:51.682]                 }
[17:39:51.682]             }
[17:39:51.682]         }))
[17:39:51.682]     }, error = function(ex) {
[17:39:51.682]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.682]                 ...future.rng), started = ...future.startTime, 
[17:39:51.682]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.682]             version = "1.8"), class = "FutureResult")
[17:39:51.682]     }, finally = {
[17:39:51.682]         if (!identical(...future.workdir, getwd())) 
[17:39:51.682]             setwd(...future.workdir)
[17:39:51.682]         {
[17:39:51.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.682]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.682]             }
[17:39:51.682]             base::options(...future.oldOptions)
[17:39:51.682]             if (.Platform$OS.type == "windows") {
[17:39:51.682]                 old_names <- names(...future.oldEnvVars)
[17:39:51.682]                 envs <- base::Sys.getenv()
[17:39:51.682]                 names <- names(envs)
[17:39:51.682]                 common <- intersect(names, old_names)
[17:39:51.682]                 added <- setdiff(names, old_names)
[17:39:51.682]                 removed <- setdiff(old_names, names)
[17:39:51.682]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.682]                   envs[common]]
[17:39:51.682]                 NAMES <- toupper(changed)
[17:39:51.682]                 args <- list()
[17:39:51.682]                 for (kk in seq_along(NAMES)) {
[17:39:51.682]                   name <- changed[[kk]]
[17:39:51.682]                   NAME <- NAMES[[kk]]
[17:39:51.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.682]                     next
[17:39:51.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.682]                 }
[17:39:51.682]                 NAMES <- toupper(added)
[17:39:51.682]                 for (kk in seq_along(NAMES)) {
[17:39:51.682]                   name <- added[[kk]]
[17:39:51.682]                   NAME <- NAMES[[kk]]
[17:39:51.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.682]                     next
[17:39:51.682]                   args[[name]] <- ""
[17:39:51.682]                 }
[17:39:51.682]                 NAMES <- toupper(removed)
[17:39:51.682]                 for (kk in seq_along(NAMES)) {
[17:39:51.682]                   name <- removed[[kk]]
[17:39:51.682]                   NAME <- NAMES[[kk]]
[17:39:51.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.682]                     next
[17:39:51.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.682]                 }
[17:39:51.682]                 if (length(args) > 0) 
[17:39:51.682]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.682]             }
[17:39:51.682]             else {
[17:39:51.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.682]             }
[17:39:51.682]             {
[17:39:51.682]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.682]                   0L) {
[17:39:51.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.682]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.682]                   base::options(opts)
[17:39:51.682]                 }
[17:39:51.682]                 {
[17:39:51.682]                   {
[17:39:51.682]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.682]                     NULL
[17:39:51.682]                   }
[17:39:51.682]                   options(future.plan = NULL)
[17:39:51.682]                   if (is.na(NA_character_)) 
[17:39:51.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.682]                     .init = FALSE)
[17:39:51.682]                 }
[17:39:51.682]             }
[17:39:51.682]         }
[17:39:51.682]     })
[17:39:51.682]     if (TRUE) {
[17:39:51.682]         base::sink(type = "output", split = FALSE)
[17:39:51.682]         if (TRUE) {
[17:39:51.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.682]         }
[17:39:51.682]         else {
[17:39:51.682]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.682]         }
[17:39:51.682]         base::close(...future.stdout)
[17:39:51.682]         ...future.stdout <- NULL
[17:39:51.682]     }
[17:39:51.682]     ...future.result$conditions <- ...future.conditions
[17:39:51.682]     ...future.result$finished <- base::Sys.time()
[17:39:51.682]     ...future.result
[17:39:51.682] }
[17:39:51.684] assign_globals() ...
[17:39:51.684] List of 1
[17:39:51.684]  $ x: list()
[17:39:51.684]  - attr(*, "where")=List of 1
[17:39:51.684]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.684]  - attr(*, "resolved")= logi TRUE
[17:39:51.684]  - attr(*, "total_size")= num 0
[17:39:51.684]  - attr(*, "already-done")= logi TRUE
[17:39:51.687] - copied ‘x’ to environment
[17:39:51.687] assign_globals() ... done
[17:39:51.687] requestCore(): workers = 2
[17:39:51.689] MulticoreFuture started
[17:39:51.689] - Launch lazy future ... done
[17:39:51.690] run() for ‘MulticoreFuture’ ... done
[17:39:51.690] result() for MulticoreFuture ...
[17:39:51.690] plan(): Setting new future strategy stack:
[17:39:51.690] List of future strategies:
[17:39:51.690] 1. sequential:
[17:39:51.690]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.690]    - tweaked: FALSE
[17:39:51.690]    - call: NULL
[17:39:51.691] plan(): nbrOfWorkers() = 1
[17:39:51.693] plan(): Setting new future strategy stack:
[17:39:51.693] List of future strategies:
[17:39:51.693] 1. multicore:
[17:39:51.693]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.693]    - tweaked: FALSE
[17:39:51.693]    - call: plan(strategy)
[17:39:51.699] plan(): nbrOfWorkers() = 2
[17:39:51.700] result() for MulticoreFuture ...
[17:39:51.700] result() for MulticoreFuture ... done
[17:39:51.700] result() for MulticoreFuture ... done
[17:39:51.700] result() for MulticoreFuture ...
[17:39:51.700] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.701] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.701] Searching for globals...
[17:39:51.704] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.704] Searching for globals ... DONE
[17:39:51.704] Resolving globals: TRUE
[17:39:51.704] Resolving any globals that are futures ...
[17:39:51.704] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:51.705] Resolving any globals that are futures ... DONE
[17:39:51.705] Resolving futures part of globals (recursively) ...
[17:39:51.705] resolve() on list ...
[17:39:51.705]  recursive: 99
[17:39:51.706]  length: 1
[17:39:51.706]  elements: ‘x’
[17:39:51.706]  length: 0 (resolved future 1)
[17:39:51.706] resolve() on list ... DONE
[17:39:51.706] - globals: [1] ‘x’
[17:39:51.706] Resolving futures part of globals (recursively) ... DONE
[17:39:51.706] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.707] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.707] - globals: [1] ‘x’
[17:39:51.707] 
[17:39:51.707] getGlobalsAndPackages() ... DONE
[17:39:51.708] run() for ‘Future’ ...
[17:39:51.708] - state: ‘created’
[17:39:51.708] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.712] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.712]   - Field: ‘label’
[17:39:51.712]   - Field: ‘local’
[17:39:51.712]   - Field: ‘owner’
[17:39:51.712]   - Field: ‘envir’
[17:39:51.712]   - Field: ‘workers’
[17:39:51.713]   - Field: ‘packages’
[17:39:51.713]   - Field: ‘gc’
[17:39:51.713]   - Field: ‘job’
[17:39:51.713]   - Field: ‘conditions’
[17:39:51.713]   - Field: ‘expr’
[17:39:51.713]   - Field: ‘uuid’
[17:39:51.713]   - Field: ‘seed’
[17:39:51.713]   - Field: ‘version’
[17:39:51.713]   - Field: ‘result’
[17:39:51.714]   - Field: ‘asynchronous’
[17:39:51.714]   - Field: ‘calls’
[17:39:51.714]   - Field: ‘globals’
[17:39:51.714]   - Field: ‘stdout’
[17:39:51.714]   - Field: ‘earlySignal’
[17:39:51.714]   - Field: ‘lazy’
[17:39:51.714]   - Field: ‘state’
[17:39:51.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.714] - Launch lazy future ...
[17:39:51.715] Packages needed by the future expression (n = 0): <none>
[17:39:51.715] Packages needed by future strategies (n = 0): <none>
[17:39:51.715] {
[17:39:51.715]     {
[17:39:51.715]         {
[17:39:51.715]             ...future.startTime <- base::Sys.time()
[17:39:51.715]             {
[17:39:51.715]                 {
[17:39:51.715]                   {
[17:39:51.715]                     {
[17:39:51.715]                       base::local({
[17:39:51.715]                         has_future <- base::requireNamespace("future", 
[17:39:51.715]                           quietly = TRUE)
[17:39:51.715]                         if (has_future) {
[17:39:51.715]                           ns <- base::getNamespace("future")
[17:39:51.715]                           version <- ns[[".package"]][["version"]]
[17:39:51.715]                           if (is.null(version)) 
[17:39:51.715]                             version <- utils::packageVersion("future")
[17:39:51.715]                         }
[17:39:51.715]                         else {
[17:39:51.715]                           version <- NULL
[17:39:51.715]                         }
[17:39:51.715]                         if (!has_future || version < "1.8.0") {
[17:39:51.715]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.715]                             "", base::R.version$version.string), 
[17:39:51.715]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.715]                               "release", "version")], collapse = " "), 
[17:39:51.715]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.715]                             info)
[17:39:51.715]                           info <- base::paste(info, collapse = "; ")
[17:39:51.715]                           if (!has_future) {
[17:39:51.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.715]                               info)
[17:39:51.715]                           }
[17:39:51.715]                           else {
[17:39:51.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.715]                               info, version)
[17:39:51.715]                           }
[17:39:51.715]                           base::stop(msg)
[17:39:51.715]                         }
[17:39:51.715]                       })
[17:39:51.715]                     }
[17:39:51.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.715]                     base::options(mc.cores = 1L)
[17:39:51.715]                   }
[17:39:51.715]                   ...future.strategy.old <- future::plan("list")
[17:39:51.715]                   options(future.plan = NULL)
[17:39:51.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.715]                 }
[17:39:51.715]                 ...future.workdir <- getwd()
[17:39:51.715]             }
[17:39:51.715]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.715]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.715]         }
[17:39:51.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.715]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.715]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.715]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.715]             base::names(...future.oldOptions))
[17:39:51.715]     }
[17:39:51.715]     if (FALSE) {
[17:39:51.715]     }
[17:39:51.715]     else {
[17:39:51.715]         if (TRUE) {
[17:39:51.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.715]                 open = "w")
[17:39:51.715]         }
[17:39:51.715]         else {
[17:39:51.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.715]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.715]         }
[17:39:51.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.715]             base::sink(type = "output", split = FALSE)
[17:39:51.715]             base::close(...future.stdout)
[17:39:51.715]         }, add = TRUE)
[17:39:51.715]     }
[17:39:51.715]     ...future.frame <- base::sys.nframe()
[17:39:51.715]     ...future.conditions <- base::list()
[17:39:51.715]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.715]     if (FALSE) {
[17:39:51.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.715]     }
[17:39:51.715]     ...future.result <- base::tryCatch({
[17:39:51.715]         base::withCallingHandlers({
[17:39:51.715]             ...future.value <- base::withVisible(base::local({
[17:39:51.715]                 withCallingHandlers({
[17:39:51.715]                   {
[17:39:51.715]                     x$a <- 1
[17:39:51.715]                     x
[17:39:51.715]                   }
[17:39:51.715]                 }, immediateCondition = function(cond) {
[17:39:51.715]                   save_rds <- function (object, pathname, ...) 
[17:39:51.715]                   {
[17:39:51.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.715]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.715]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.715]                         fi_tmp[["mtime"]])
[17:39:51.715]                     }
[17:39:51.715]                     tryCatch({
[17:39:51.715]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.715]                     }, error = function(ex) {
[17:39:51.715]                       msg <- conditionMessage(ex)
[17:39:51.715]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.715]                         fi_tmp[["mtime"]], msg)
[17:39:51.715]                       ex$message <- msg
[17:39:51.715]                       stop(ex)
[17:39:51.715]                     })
[17:39:51.715]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.715]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.715]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.715]                       fi <- file.info(pathname)
[17:39:51.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.715]                         fi[["size"]], fi[["mtime"]])
[17:39:51.715]                       stop(msg)
[17:39:51.715]                     }
[17:39:51.715]                     invisible(pathname)
[17:39:51.715]                   }
[17:39:51.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.715]                     rootPath = tempdir()) 
[17:39:51.715]                   {
[17:39:51.715]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.715]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.715]                       tmpdir = path, fileext = ".rds")
[17:39:51.715]                     save_rds(obj, file)
[17:39:51.715]                   }
[17:39:51.715]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.715]                   {
[17:39:51.715]                     inherits <- base::inherits
[17:39:51.715]                     invokeRestart <- base::invokeRestart
[17:39:51.715]                     is.null <- base::is.null
[17:39:51.715]                     muffled <- FALSE
[17:39:51.715]                     if (inherits(cond, "message")) {
[17:39:51.715]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.715]                       if (muffled) 
[17:39:51.715]                         invokeRestart("muffleMessage")
[17:39:51.715]                     }
[17:39:51.715]                     else if (inherits(cond, "warning")) {
[17:39:51.715]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.715]                       if (muffled) 
[17:39:51.715]                         invokeRestart("muffleWarning")
[17:39:51.715]                     }
[17:39:51.715]                     else if (inherits(cond, "condition")) {
[17:39:51.715]                       if (!is.null(pattern)) {
[17:39:51.715]                         computeRestarts <- base::computeRestarts
[17:39:51.715]                         grepl <- base::grepl
[17:39:51.715]                         restarts <- computeRestarts(cond)
[17:39:51.715]                         for (restart in restarts) {
[17:39:51.715]                           name <- restart$name
[17:39:51.715]                           if (is.null(name)) 
[17:39:51.715]                             next
[17:39:51.715]                           if (!grepl(pattern, name)) 
[17:39:51.715]                             next
[17:39:51.715]                           invokeRestart(restart)
[17:39:51.715]                           muffled <- TRUE
[17:39:51.715]                           break
[17:39:51.715]                         }
[17:39:51.715]                       }
[17:39:51.715]                     }
[17:39:51.715]                     invisible(muffled)
[17:39:51.715]                   }
[17:39:51.715]                   muffleCondition(cond)
[17:39:51.715]                 })
[17:39:51.715]             }))
[17:39:51.715]             future::FutureResult(value = ...future.value$value, 
[17:39:51.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.715]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.715]                     ...future.globalenv.names))
[17:39:51.715]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.715]         }, condition = base::local({
[17:39:51.715]             c <- base::c
[17:39:51.715]             inherits <- base::inherits
[17:39:51.715]             invokeRestart <- base::invokeRestart
[17:39:51.715]             length <- base::length
[17:39:51.715]             list <- base::list
[17:39:51.715]             seq.int <- base::seq.int
[17:39:51.715]             signalCondition <- base::signalCondition
[17:39:51.715]             sys.calls <- base::sys.calls
[17:39:51.715]             `[[` <- base::`[[`
[17:39:51.715]             `+` <- base::`+`
[17:39:51.715]             `<<-` <- base::`<<-`
[17:39:51.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.715]                   3L)]
[17:39:51.715]             }
[17:39:51.715]             function(cond) {
[17:39:51.715]                 is_error <- inherits(cond, "error")
[17:39:51.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.715]                   NULL)
[17:39:51.715]                 if (is_error) {
[17:39:51.715]                   sessionInformation <- function() {
[17:39:51.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.715]                       search = base::search(), system = base::Sys.info())
[17:39:51.715]                   }
[17:39:51.715]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.715]                     cond$call), session = sessionInformation(), 
[17:39:51.715]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.715]                   signalCondition(cond)
[17:39:51.715]                 }
[17:39:51.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.715]                 "immediateCondition"))) {
[17:39:51.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.715]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.715]                   if (TRUE && !signal) {
[17:39:51.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.715]                     {
[17:39:51.715]                       inherits <- base::inherits
[17:39:51.715]                       invokeRestart <- base::invokeRestart
[17:39:51.715]                       is.null <- base::is.null
[17:39:51.715]                       muffled <- FALSE
[17:39:51.715]                       if (inherits(cond, "message")) {
[17:39:51.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.715]                         if (muffled) 
[17:39:51.715]                           invokeRestart("muffleMessage")
[17:39:51.715]                       }
[17:39:51.715]                       else if (inherits(cond, "warning")) {
[17:39:51.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.715]                         if (muffled) 
[17:39:51.715]                           invokeRestart("muffleWarning")
[17:39:51.715]                       }
[17:39:51.715]                       else if (inherits(cond, "condition")) {
[17:39:51.715]                         if (!is.null(pattern)) {
[17:39:51.715]                           computeRestarts <- base::computeRestarts
[17:39:51.715]                           grepl <- base::grepl
[17:39:51.715]                           restarts <- computeRestarts(cond)
[17:39:51.715]                           for (restart in restarts) {
[17:39:51.715]                             name <- restart$name
[17:39:51.715]                             if (is.null(name)) 
[17:39:51.715]                               next
[17:39:51.715]                             if (!grepl(pattern, name)) 
[17:39:51.715]                               next
[17:39:51.715]                             invokeRestart(restart)
[17:39:51.715]                             muffled <- TRUE
[17:39:51.715]                             break
[17:39:51.715]                           }
[17:39:51.715]                         }
[17:39:51.715]                       }
[17:39:51.715]                       invisible(muffled)
[17:39:51.715]                     }
[17:39:51.715]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.715]                   }
[17:39:51.715]                 }
[17:39:51.715]                 else {
[17:39:51.715]                   if (TRUE) {
[17:39:51.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.715]                     {
[17:39:51.715]                       inherits <- base::inherits
[17:39:51.715]                       invokeRestart <- base::invokeRestart
[17:39:51.715]                       is.null <- base::is.null
[17:39:51.715]                       muffled <- FALSE
[17:39:51.715]                       if (inherits(cond, "message")) {
[17:39:51.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.715]                         if (muffled) 
[17:39:51.715]                           invokeRestart("muffleMessage")
[17:39:51.715]                       }
[17:39:51.715]                       else if (inherits(cond, "warning")) {
[17:39:51.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.715]                         if (muffled) 
[17:39:51.715]                           invokeRestart("muffleWarning")
[17:39:51.715]                       }
[17:39:51.715]                       else if (inherits(cond, "condition")) {
[17:39:51.715]                         if (!is.null(pattern)) {
[17:39:51.715]                           computeRestarts <- base::computeRestarts
[17:39:51.715]                           grepl <- base::grepl
[17:39:51.715]                           restarts <- computeRestarts(cond)
[17:39:51.715]                           for (restart in restarts) {
[17:39:51.715]                             name <- restart$name
[17:39:51.715]                             if (is.null(name)) 
[17:39:51.715]                               next
[17:39:51.715]                             if (!grepl(pattern, name)) 
[17:39:51.715]                               next
[17:39:51.715]                             invokeRestart(restart)
[17:39:51.715]                             muffled <- TRUE
[17:39:51.715]                             break
[17:39:51.715]                           }
[17:39:51.715]                         }
[17:39:51.715]                       }
[17:39:51.715]                       invisible(muffled)
[17:39:51.715]                     }
[17:39:51.715]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.715]                   }
[17:39:51.715]                 }
[17:39:51.715]             }
[17:39:51.715]         }))
[17:39:51.715]     }, error = function(ex) {
[17:39:51.715]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.715]                 ...future.rng), started = ...future.startTime, 
[17:39:51.715]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.715]             version = "1.8"), class = "FutureResult")
[17:39:51.715]     }, finally = {
[17:39:51.715]         if (!identical(...future.workdir, getwd())) 
[17:39:51.715]             setwd(...future.workdir)
[17:39:51.715]         {
[17:39:51.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.715]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.715]             }
[17:39:51.715]             base::options(...future.oldOptions)
[17:39:51.715]             if (.Platform$OS.type == "windows") {
[17:39:51.715]                 old_names <- names(...future.oldEnvVars)
[17:39:51.715]                 envs <- base::Sys.getenv()
[17:39:51.715]                 names <- names(envs)
[17:39:51.715]                 common <- intersect(names, old_names)
[17:39:51.715]                 added <- setdiff(names, old_names)
[17:39:51.715]                 removed <- setdiff(old_names, names)
[17:39:51.715]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.715]                   envs[common]]
[17:39:51.715]                 NAMES <- toupper(changed)
[17:39:51.715]                 args <- list()
[17:39:51.715]                 for (kk in seq_along(NAMES)) {
[17:39:51.715]                   name <- changed[[kk]]
[17:39:51.715]                   NAME <- NAMES[[kk]]
[17:39:51.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.715]                     next
[17:39:51.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.715]                 }
[17:39:51.715]                 NAMES <- toupper(added)
[17:39:51.715]                 for (kk in seq_along(NAMES)) {
[17:39:51.715]                   name <- added[[kk]]
[17:39:51.715]                   NAME <- NAMES[[kk]]
[17:39:51.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.715]                     next
[17:39:51.715]                   args[[name]] <- ""
[17:39:51.715]                 }
[17:39:51.715]                 NAMES <- toupper(removed)
[17:39:51.715]                 for (kk in seq_along(NAMES)) {
[17:39:51.715]                   name <- removed[[kk]]
[17:39:51.715]                   NAME <- NAMES[[kk]]
[17:39:51.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.715]                     next
[17:39:51.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.715]                 }
[17:39:51.715]                 if (length(args) > 0) 
[17:39:51.715]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.715]             }
[17:39:51.715]             else {
[17:39:51.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.715]             }
[17:39:51.715]             {
[17:39:51.715]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.715]                   0L) {
[17:39:51.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.715]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.715]                   base::options(opts)
[17:39:51.715]                 }
[17:39:51.715]                 {
[17:39:51.715]                   {
[17:39:51.715]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.715]                     NULL
[17:39:51.715]                   }
[17:39:51.715]                   options(future.plan = NULL)
[17:39:51.715]                   if (is.na(NA_character_)) 
[17:39:51.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.715]                     .init = FALSE)
[17:39:51.715]                 }
[17:39:51.715]             }
[17:39:51.715]         }
[17:39:51.715]     })
[17:39:51.715]     if (TRUE) {
[17:39:51.715]         base::sink(type = "output", split = FALSE)
[17:39:51.715]         if (TRUE) {
[17:39:51.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.715]         }
[17:39:51.715]         else {
[17:39:51.715]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.715]         }
[17:39:51.715]         base::close(...future.stdout)
[17:39:51.715]         ...future.stdout <- NULL
[17:39:51.715]     }
[17:39:51.715]     ...future.result$conditions <- ...future.conditions
[17:39:51.715]     ...future.result$finished <- base::Sys.time()
[17:39:51.715]     ...future.result
[17:39:51.715] }
[17:39:51.718] assign_globals() ...
[17:39:51.718] List of 1
[17:39:51.718]  $ x: list()
[17:39:51.718]  - attr(*, "where")=List of 1
[17:39:51.718]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.718]  - attr(*, "resolved")= logi TRUE
[17:39:51.718]  - attr(*, "total_size")= num 0
[17:39:51.718]  - attr(*, "already-done")= logi TRUE
[17:39:51.721] - copied ‘x’ to environment
[17:39:51.721] assign_globals() ... done
[17:39:51.721] requestCore(): workers = 2
[17:39:51.723] MulticoreFuture started
[17:39:51.723] - Launch lazy future ... done
[17:39:51.724] run() for ‘MulticoreFuture’ ... done
[17:39:51.724] result() for MulticoreFuture ...
[17:39:51.724] plan(): Setting new future strategy stack:
[17:39:51.724] List of future strategies:
[17:39:51.724] 1. sequential:
[17:39:51.724]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.724]    - tweaked: FALSE
[17:39:51.724]    - call: NULL
[17:39:51.726] plan(): nbrOfWorkers() = 1
[17:39:51.727] plan(): Setting new future strategy stack:
[17:39:51.728] List of future strategies:
[17:39:51.728] 1. multicore:
[17:39:51.728]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.728]    - tweaked: FALSE
[17:39:51.728]    - call: plan(strategy)
[17:39:51.737] plan(): nbrOfWorkers() = 2
[17:39:51.738] result() for MulticoreFuture ...
[17:39:51.738] result() for MulticoreFuture ... done
[17:39:51.738] result() for MulticoreFuture ... done
[17:39:51.738] result() for MulticoreFuture ...
[17:39:51.738] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.739] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.740] Searching for globals...
[17:39:51.746] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:39:51.746] Searching for globals ... DONE
[17:39:51.746] Resolving globals: TRUE
[17:39:51.746] Resolving any globals that are futures ...
[17:39:51.746] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:39:51.747] Resolving any globals that are futures ... DONE
[17:39:51.747] 
[17:39:51.747] 
[17:39:51.747] getGlobalsAndPackages() ... DONE
[17:39:51.748] run() for ‘Future’ ...
[17:39:51.748] - state: ‘created’
[17:39:51.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.753]   - Field: ‘label’
[17:39:51.753]   - Field: ‘local’
[17:39:51.753]   - Field: ‘owner’
[17:39:51.753]   - Field: ‘envir’
[17:39:51.753]   - Field: ‘workers’
[17:39:51.753]   - Field: ‘packages’
[17:39:51.754]   - Field: ‘gc’
[17:39:51.754]   - Field: ‘job’
[17:39:51.754]   - Field: ‘conditions’
[17:39:51.754]   - Field: ‘expr’
[17:39:51.754]   - Field: ‘uuid’
[17:39:51.754]   - Field: ‘seed’
[17:39:51.754]   - Field: ‘version’
[17:39:51.755]   - Field: ‘result’
[17:39:51.755]   - Field: ‘asynchronous’
[17:39:51.755]   - Field: ‘calls’
[17:39:51.755]   - Field: ‘globals’
[17:39:51.755]   - Field: ‘stdout’
[17:39:51.755]   - Field: ‘earlySignal’
[17:39:51.755]   - Field: ‘lazy’
[17:39:51.755]   - Field: ‘state’
[17:39:51.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.756] - Launch lazy future ...
[17:39:51.756] Packages needed by the future expression (n = 0): <none>
[17:39:51.756] Packages needed by future strategies (n = 0): <none>
[17:39:51.757] {
[17:39:51.757]     {
[17:39:51.757]         {
[17:39:51.757]             ...future.startTime <- base::Sys.time()
[17:39:51.757]             {
[17:39:51.757]                 {
[17:39:51.757]                   {
[17:39:51.757]                     {
[17:39:51.757]                       base::local({
[17:39:51.757]                         has_future <- base::requireNamespace("future", 
[17:39:51.757]                           quietly = TRUE)
[17:39:51.757]                         if (has_future) {
[17:39:51.757]                           ns <- base::getNamespace("future")
[17:39:51.757]                           version <- ns[[".package"]][["version"]]
[17:39:51.757]                           if (is.null(version)) 
[17:39:51.757]                             version <- utils::packageVersion("future")
[17:39:51.757]                         }
[17:39:51.757]                         else {
[17:39:51.757]                           version <- NULL
[17:39:51.757]                         }
[17:39:51.757]                         if (!has_future || version < "1.8.0") {
[17:39:51.757]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.757]                             "", base::R.version$version.string), 
[17:39:51.757]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.757]                               "release", "version")], collapse = " "), 
[17:39:51.757]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.757]                             info)
[17:39:51.757]                           info <- base::paste(info, collapse = "; ")
[17:39:51.757]                           if (!has_future) {
[17:39:51.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.757]                               info)
[17:39:51.757]                           }
[17:39:51.757]                           else {
[17:39:51.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.757]                               info, version)
[17:39:51.757]                           }
[17:39:51.757]                           base::stop(msg)
[17:39:51.757]                         }
[17:39:51.757]                       })
[17:39:51.757]                     }
[17:39:51.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.757]                     base::options(mc.cores = 1L)
[17:39:51.757]                   }
[17:39:51.757]                   ...future.strategy.old <- future::plan("list")
[17:39:51.757]                   options(future.plan = NULL)
[17:39:51.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.757]                 }
[17:39:51.757]                 ...future.workdir <- getwd()
[17:39:51.757]             }
[17:39:51.757]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.757]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.757]         }
[17:39:51.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.757]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.757]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.757]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.757]             base::names(...future.oldOptions))
[17:39:51.757]     }
[17:39:51.757]     if (FALSE) {
[17:39:51.757]     }
[17:39:51.757]     else {
[17:39:51.757]         if (TRUE) {
[17:39:51.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.757]                 open = "w")
[17:39:51.757]         }
[17:39:51.757]         else {
[17:39:51.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.757]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.757]         }
[17:39:51.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.757]             base::sink(type = "output", split = FALSE)
[17:39:51.757]             base::close(...future.stdout)
[17:39:51.757]         }, add = TRUE)
[17:39:51.757]     }
[17:39:51.757]     ...future.frame <- base::sys.nframe()
[17:39:51.757]     ...future.conditions <- base::list()
[17:39:51.757]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.757]     if (FALSE) {
[17:39:51.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.757]     }
[17:39:51.757]     ...future.result <- base::tryCatch({
[17:39:51.757]         base::withCallingHandlers({
[17:39:51.757]             ...future.value <- base::withVisible(base::local({
[17:39:51.757]                 withCallingHandlers({
[17:39:51.757]                   {
[17:39:51.757]                     x <- list(b = 2)
[17:39:51.757]                     x$a <- 1
[17:39:51.757]                     x
[17:39:51.757]                   }
[17:39:51.757]                 }, immediateCondition = function(cond) {
[17:39:51.757]                   save_rds <- function (object, pathname, ...) 
[17:39:51.757]                   {
[17:39:51.757]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.757]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.757]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.757]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.757]                         fi_tmp[["mtime"]])
[17:39:51.757]                     }
[17:39:51.757]                     tryCatch({
[17:39:51.757]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.757]                     }, error = function(ex) {
[17:39:51.757]                       msg <- conditionMessage(ex)
[17:39:51.757]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.757]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.757]                         fi_tmp[["mtime"]], msg)
[17:39:51.757]                       ex$message <- msg
[17:39:51.757]                       stop(ex)
[17:39:51.757]                     })
[17:39:51.757]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.757]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.757]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.757]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.757]                       fi <- file.info(pathname)
[17:39:51.757]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.757]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.757]                         fi[["size"]], fi[["mtime"]])
[17:39:51.757]                       stop(msg)
[17:39:51.757]                     }
[17:39:51.757]                     invisible(pathname)
[17:39:51.757]                   }
[17:39:51.757]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.757]                     rootPath = tempdir()) 
[17:39:51.757]                   {
[17:39:51.757]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.757]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.757]                       tmpdir = path, fileext = ".rds")
[17:39:51.757]                     save_rds(obj, file)
[17:39:51.757]                   }
[17:39:51.757]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.757]                   {
[17:39:51.757]                     inherits <- base::inherits
[17:39:51.757]                     invokeRestart <- base::invokeRestart
[17:39:51.757]                     is.null <- base::is.null
[17:39:51.757]                     muffled <- FALSE
[17:39:51.757]                     if (inherits(cond, "message")) {
[17:39:51.757]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.757]                       if (muffled) 
[17:39:51.757]                         invokeRestart("muffleMessage")
[17:39:51.757]                     }
[17:39:51.757]                     else if (inherits(cond, "warning")) {
[17:39:51.757]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.757]                       if (muffled) 
[17:39:51.757]                         invokeRestart("muffleWarning")
[17:39:51.757]                     }
[17:39:51.757]                     else if (inherits(cond, "condition")) {
[17:39:51.757]                       if (!is.null(pattern)) {
[17:39:51.757]                         computeRestarts <- base::computeRestarts
[17:39:51.757]                         grepl <- base::grepl
[17:39:51.757]                         restarts <- computeRestarts(cond)
[17:39:51.757]                         for (restart in restarts) {
[17:39:51.757]                           name <- restart$name
[17:39:51.757]                           if (is.null(name)) 
[17:39:51.757]                             next
[17:39:51.757]                           if (!grepl(pattern, name)) 
[17:39:51.757]                             next
[17:39:51.757]                           invokeRestart(restart)
[17:39:51.757]                           muffled <- TRUE
[17:39:51.757]                           break
[17:39:51.757]                         }
[17:39:51.757]                       }
[17:39:51.757]                     }
[17:39:51.757]                     invisible(muffled)
[17:39:51.757]                   }
[17:39:51.757]                   muffleCondition(cond)
[17:39:51.757]                 })
[17:39:51.757]             }))
[17:39:51.757]             future::FutureResult(value = ...future.value$value, 
[17:39:51.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.757]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.757]                     ...future.globalenv.names))
[17:39:51.757]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.757]         }, condition = base::local({
[17:39:51.757]             c <- base::c
[17:39:51.757]             inherits <- base::inherits
[17:39:51.757]             invokeRestart <- base::invokeRestart
[17:39:51.757]             length <- base::length
[17:39:51.757]             list <- base::list
[17:39:51.757]             seq.int <- base::seq.int
[17:39:51.757]             signalCondition <- base::signalCondition
[17:39:51.757]             sys.calls <- base::sys.calls
[17:39:51.757]             `[[` <- base::`[[`
[17:39:51.757]             `+` <- base::`+`
[17:39:51.757]             `<<-` <- base::`<<-`
[17:39:51.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.757]                   3L)]
[17:39:51.757]             }
[17:39:51.757]             function(cond) {
[17:39:51.757]                 is_error <- inherits(cond, "error")
[17:39:51.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.757]                   NULL)
[17:39:51.757]                 if (is_error) {
[17:39:51.757]                   sessionInformation <- function() {
[17:39:51.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.757]                       search = base::search(), system = base::Sys.info())
[17:39:51.757]                   }
[17:39:51.757]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.757]                     cond$call), session = sessionInformation(), 
[17:39:51.757]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.757]                   signalCondition(cond)
[17:39:51.757]                 }
[17:39:51.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.757]                 "immediateCondition"))) {
[17:39:51.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.757]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.757]                   if (TRUE && !signal) {
[17:39:51.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.757]                     {
[17:39:51.757]                       inherits <- base::inherits
[17:39:51.757]                       invokeRestart <- base::invokeRestart
[17:39:51.757]                       is.null <- base::is.null
[17:39:51.757]                       muffled <- FALSE
[17:39:51.757]                       if (inherits(cond, "message")) {
[17:39:51.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.757]                         if (muffled) 
[17:39:51.757]                           invokeRestart("muffleMessage")
[17:39:51.757]                       }
[17:39:51.757]                       else if (inherits(cond, "warning")) {
[17:39:51.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.757]                         if (muffled) 
[17:39:51.757]                           invokeRestart("muffleWarning")
[17:39:51.757]                       }
[17:39:51.757]                       else if (inherits(cond, "condition")) {
[17:39:51.757]                         if (!is.null(pattern)) {
[17:39:51.757]                           computeRestarts <- base::computeRestarts
[17:39:51.757]                           grepl <- base::grepl
[17:39:51.757]                           restarts <- computeRestarts(cond)
[17:39:51.757]                           for (restart in restarts) {
[17:39:51.757]                             name <- restart$name
[17:39:51.757]                             if (is.null(name)) 
[17:39:51.757]                               next
[17:39:51.757]                             if (!grepl(pattern, name)) 
[17:39:51.757]                               next
[17:39:51.757]                             invokeRestart(restart)
[17:39:51.757]                             muffled <- TRUE
[17:39:51.757]                             break
[17:39:51.757]                           }
[17:39:51.757]                         }
[17:39:51.757]                       }
[17:39:51.757]                       invisible(muffled)
[17:39:51.757]                     }
[17:39:51.757]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.757]                   }
[17:39:51.757]                 }
[17:39:51.757]                 else {
[17:39:51.757]                   if (TRUE) {
[17:39:51.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.757]                     {
[17:39:51.757]                       inherits <- base::inherits
[17:39:51.757]                       invokeRestart <- base::invokeRestart
[17:39:51.757]                       is.null <- base::is.null
[17:39:51.757]                       muffled <- FALSE
[17:39:51.757]                       if (inherits(cond, "message")) {
[17:39:51.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.757]                         if (muffled) 
[17:39:51.757]                           invokeRestart("muffleMessage")
[17:39:51.757]                       }
[17:39:51.757]                       else if (inherits(cond, "warning")) {
[17:39:51.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.757]                         if (muffled) 
[17:39:51.757]                           invokeRestart("muffleWarning")
[17:39:51.757]                       }
[17:39:51.757]                       else if (inherits(cond, "condition")) {
[17:39:51.757]                         if (!is.null(pattern)) {
[17:39:51.757]                           computeRestarts <- base::computeRestarts
[17:39:51.757]                           grepl <- base::grepl
[17:39:51.757]                           restarts <- computeRestarts(cond)
[17:39:51.757]                           for (restart in restarts) {
[17:39:51.757]                             name <- restart$name
[17:39:51.757]                             if (is.null(name)) 
[17:39:51.757]                               next
[17:39:51.757]                             if (!grepl(pattern, name)) 
[17:39:51.757]                               next
[17:39:51.757]                             invokeRestart(restart)
[17:39:51.757]                             muffled <- TRUE
[17:39:51.757]                             break
[17:39:51.757]                           }
[17:39:51.757]                         }
[17:39:51.757]                       }
[17:39:51.757]                       invisible(muffled)
[17:39:51.757]                     }
[17:39:51.757]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.757]                   }
[17:39:51.757]                 }
[17:39:51.757]             }
[17:39:51.757]         }))
[17:39:51.757]     }, error = function(ex) {
[17:39:51.757]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.757]                 ...future.rng), started = ...future.startTime, 
[17:39:51.757]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.757]             version = "1.8"), class = "FutureResult")
[17:39:51.757]     }, finally = {
[17:39:51.757]         if (!identical(...future.workdir, getwd())) 
[17:39:51.757]             setwd(...future.workdir)
[17:39:51.757]         {
[17:39:51.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.757]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.757]             }
[17:39:51.757]             base::options(...future.oldOptions)
[17:39:51.757]             if (.Platform$OS.type == "windows") {
[17:39:51.757]                 old_names <- names(...future.oldEnvVars)
[17:39:51.757]                 envs <- base::Sys.getenv()
[17:39:51.757]                 names <- names(envs)
[17:39:51.757]                 common <- intersect(names, old_names)
[17:39:51.757]                 added <- setdiff(names, old_names)
[17:39:51.757]                 removed <- setdiff(old_names, names)
[17:39:51.757]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.757]                   envs[common]]
[17:39:51.757]                 NAMES <- toupper(changed)
[17:39:51.757]                 args <- list()
[17:39:51.757]                 for (kk in seq_along(NAMES)) {
[17:39:51.757]                   name <- changed[[kk]]
[17:39:51.757]                   NAME <- NAMES[[kk]]
[17:39:51.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.757]                     next
[17:39:51.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.757]                 }
[17:39:51.757]                 NAMES <- toupper(added)
[17:39:51.757]                 for (kk in seq_along(NAMES)) {
[17:39:51.757]                   name <- added[[kk]]
[17:39:51.757]                   NAME <- NAMES[[kk]]
[17:39:51.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.757]                     next
[17:39:51.757]                   args[[name]] <- ""
[17:39:51.757]                 }
[17:39:51.757]                 NAMES <- toupper(removed)
[17:39:51.757]                 for (kk in seq_along(NAMES)) {
[17:39:51.757]                   name <- removed[[kk]]
[17:39:51.757]                   NAME <- NAMES[[kk]]
[17:39:51.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.757]                     next
[17:39:51.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.757]                 }
[17:39:51.757]                 if (length(args) > 0) 
[17:39:51.757]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.757]             }
[17:39:51.757]             else {
[17:39:51.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.757]             }
[17:39:51.757]             {
[17:39:51.757]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.757]                   0L) {
[17:39:51.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.757]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.757]                   base::options(opts)
[17:39:51.757]                 }
[17:39:51.757]                 {
[17:39:51.757]                   {
[17:39:51.757]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.757]                     NULL
[17:39:51.757]                   }
[17:39:51.757]                   options(future.plan = NULL)
[17:39:51.757]                   if (is.na(NA_character_)) 
[17:39:51.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.757]                     .init = FALSE)
[17:39:51.757]                 }
[17:39:51.757]             }
[17:39:51.757]         }
[17:39:51.757]     })
[17:39:51.757]     if (TRUE) {
[17:39:51.757]         base::sink(type = "output", split = FALSE)
[17:39:51.757]         if (TRUE) {
[17:39:51.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.757]         }
[17:39:51.757]         else {
[17:39:51.757]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.757]         }
[17:39:51.757]         base::close(...future.stdout)
[17:39:51.757]         ...future.stdout <- NULL
[17:39:51.757]     }
[17:39:51.757]     ...future.result$conditions <- ...future.conditions
[17:39:51.757]     ...future.result$finished <- base::Sys.time()
[17:39:51.757]     ...future.result
[17:39:51.757] }
[17:39:51.759] requestCore(): workers = 2
[17:39:51.761] MulticoreFuture started
[17:39:51.761] - Launch lazy future ... done
[17:39:51.761] run() for ‘MulticoreFuture’ ... done
[17:39:51.762] result() for MulticoreFuture ...
[17:39:51.762] plan(): Setting new future strategy stack:
[17:39:51.762] List of future strategies:
[17:39:51.762] 1. sequential:
[17:39:51.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.762]    - tweaked: FALSE
[17:39:51.762]    - call: NULL
[17:39:51.763] plan(): nbrOfWorkers() = 1
[17:39:51.765] plan(): Setting new future strategy stack:
[17:39:51.765] List of future strategies:
[17:39:51.765] 1. multicore:
[17:39:51.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.765]    - tweaked: FALSE
[17:39:51.765]    - call: plan(strategy)
[17:39:51.771] plan(): nbrOfWorkers() = 2
[17:39:51.772] result() for MulticoreFuture ...
[17:39:51.772] result() for MulticoreFuture ... done
[17:39:51.772] result() for MulticoreFuture ... done
[17:39:51.772] result() for MulticoreFuture ...
[17:39:51.772] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.773] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.773] Searching for globals...
[17:39:51.776] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.776] Searching for globals ... DONE
[17:39:51.776] Resolving globals: TRUE
[17:39:51.776] Resolving any globals that are futures ...
[17:39:51.776] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.777] Resolving any globals that are futures ... DONE
[17:39:51.777] Resolving futures part of globals (recursively) ...
[17:39:51.777] resolve() on list ...
[17:39:51.778]  recursive: 99
[17:39:51.778]  length: 1
[17:39:51.778]  elements: ‘x’
[17:39:51.778]  length: 0 (resolved future 1)
[17:39:51.778] resolve() on list ... DONE
[17:39:51.778] - globals: [1] ‘x’
[17:39:51.778] Resolving futures part of globals (recursively) ... DONE
[17:39:51.778] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.779] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.779] - globals: [1] ‘x’
[17:39:51.779] 
[17:39:51.779] getGlobalsAndPackages() ... DONE
[17:39:51.780] run() for ‘Future’ ...
[17:39:51.780] - state: ‘created’
[17:39:51.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.784] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.784]   - Field: ‘label’
[17:39:51.785]   - Field: ‘local’
[17:39:51.785]   - Field: ‘owner’
[17:39:51.785]   - Field: ‘envir’
[17:39:51.785]   - Field: ‘workers’
[17:39:51.785]   - Field: ‘packages’
[17:39:51.785]   - Field: ‘gc’
[17:39:51.785]   - Field: ‘job’
[17:39:51.785]   - Field: ‘conditions’
[17:39:51.785]   - Field: ‘expr’
[17:39:51.786]   - Field: ‘uuid’
[17:39:51.786]   - Field: ‘seed’
[17:39:51.786]   - Field: ‘version’
[17:39:51.786]   - Field: ‘result’
[17:39:51.786]   - Field: ‘asynchronous’
[17:39:51.786]   - Field: ‘calls’
[17:39:51.786]   - Field: ‘globals’
[17:39:51.786]   - Field: ‘stdout’
[17:39:51.786]   - Field: ‘earlySignal’
[17:39:51.787]   - Field: ‘lazy’
[17:39:51.787]   - Field: ‘state’
[17:39:51.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.787] - Launch lazy future ...
[17:39:51.787] Packages needed by the future expression (n = 0): <none>
[17:39:51.787] Packages needed by future strategies (n = 0): <none>
[17:39:51.788] {
[17:39:51.788]     {
[17:39:51.788]         {
[17:39:51.788]             ...future.startTime <- base::Sys.time()
[17:39:51.788]             {
[17:39:51.788]                 {
[17:39:51.788]                   {
[17:39:51.788]                     {
[17:39:51.788]                       base::local({
[17:39:51.788]                         has_future <- base::requireNamespace("future", 
[17:39:51.788]                           quietly = TRUE)
[17:39:51.788]                         if (has_future) {
[17:39:51.788]                           ns <- base::getNamespace("future")
[17:39:51.788]                           version <- ns[[".package"]][["version"]]
[17:39:51.788]                           if (is.null(version)) 
[17:39:51.788]                             version <- utils::packageVersion("future")
[17:39:51.788]                         }
[17:39:51.788]                         else {
[17:39:51.788]                           version <- NULL
[17:39:51.788]                         }
[17:39:51.788]                         if (!has_future || version < "1.8.0") {
[17:39:51.788]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.788]                             "", base::R.version$version.string), 
[17:39:51.788]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.788]                               "release", "version")], collapse = " "), 
[17:39:51.788]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.788]                             info)
[17:39:51.788]                           info <- base::paste(info, collapse = "; ")
[17:39:51.788]                           if (!has_future) {
[17:39:51.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.788]                               info)
[17:39:51.788]                           }
[17:39:51.788]                           else {
[17:39:51.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.788]                               info, version)
[17:39:51.788]                           }
[17:39:51.788]                           base::stop(msg)
[17:39:51.788]                         }
[17:39:51.788]                       })
[17:39:51.788]                     }
[17:39:51.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.788]                     base::options(mc.cores = 1L)
[17:39:51.788]                   }
[17:39:51.788]                   ...future.strategy.old <- future::plan("list")
[17:39:51.788]                   options(future.plan = NULL)
[17:39:51.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.788]                 }
[17:39:51.788]                 ...future.workdir <- getwd()
[17:39:51.788]             }
[17:39:51.788]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.788]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.788]         }
[17:39:51.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.788]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.788]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.788]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.788]             base::names(...future.oldOptions))
[17:39:51.788]     }
[17:39:51.788]     if (FALSE) {
[17:39:51.788]     }
[17:39:51.788]     else {
[17:39:51.788]         if (TRUE) {
[17:39:51.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.788]                 open = "w")
[17:39:51.788]         }
[17:39:51.788]         else {
[17:39:51.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.788]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.788]         }
[17:39:51.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.788]             base::sink(type = "output", split = FALSE)
[17:39:51.788]             base::close(...future.stdout)
[17:39:51.788]         }, add = TRUE)
[17:39:51.788]     }
[17:39:51.788]     ...future.frame <- base::sys.nframe()
[17:39:51.788]     ...future.conditions <- base::list()
[17:39:51.788]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.788]     if (FALSE) {
[17:39:51.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.788]     }
[17:39:51.788]     ...future.result <- base::tryCatch({
[17:39:51.788]         base::withCallingHandlers({
[17:39:51.788]             ...future.value <- base::withVisible(base::local({
[17:39:51.788]                 withCallingHandlers({
[17:39:51.788]                   {
[17:39:51.788]                     x[["a"]] <- 1
[17:39:51.788]                     x
[17:39:51.788]                   }
[17:39:51.788]                 }, immediateCondition = function(cond) {
[17:39:51.788]                   save_rds <- function (object, pathname, ...) 
[17:39:51.788]                   {
[17:39:51.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.788]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.788]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.788]                         fi_tmp[["mtime"]])
[17:39:51.788]                     }
[17:39:51.788]                     tryCatch({
[17:39:51.788]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.788]                     }, error = function(ex) {
[17:39:51.788]                       msg <- conditionMessage(ex)
[17:39:51.788]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.788]                         fi_tmp[["mtime"]], msg)
[17:39:51.788]                       ex$message <- msg
[17:39:51.788]                       stop(ex)
[17:39:51.788]                     })
[17:39:51.788]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.788]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.788]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.788]                       fi <- file.info(pathname)
[17:39:51.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.788]                         fi[["size"]], fi[["mtime"]])
[17:39:51.788]                       stop(msg)
[17:39:51.788]                     }
[17:39:51.788]                     invisible(pathname)
[17:39:51.788]                   }
[17:39:51.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.788]                     rootPath = tempdir()) 
[17:39:51.788]                   {
[17:39:51.788]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.788]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.788]                       tmpdir = path, fileext = ".rds")
[17:39:51.788]                     save_rds(obj, file)
[17:39:51.788]                   }
[17:39:51.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.788]                   {
[17:39:51.788]                     inherits <- base::inherits
[17:39:51.788]                     invokeRestart <- base::invokeRestart
[17:39:51.788]                     is.null <- base::is.null
[17:39:51.788]                     muffled <- FALSE
[17:39:51.788]                     if (inherits(cond, "message")) {
[17:39:51.788]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.788]                       if (muffled) 
[17:39:51.788]                         invokeRestart("muffleMessage")
[17:39:51.788]                     }
[17:39:51.788]                     else if (inherits(cond, "warning")) {
[17:39:51.788]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.788]                       if (muffled) 
[17:39:51.788]                         invokeRestart("muffleWarning")
[17:39:51.788]                     }
[17:39:51.788]                     else if (inherits(cond, "condition")) {
[17:39:51.788]                       if (!is.null(pattern)) {
[17:39:51.788]                         computeRestarts <- base::computeRestarts
[17:39:51.788]                         grepl <- base::grepl
[17:39:51.788]                         restarts <- computeRestarts(cond)
[17:39:51.788]                         for (restart in restarts) {
[17:39:51.788]                           name <- restart$name
[17:39:51.788]                           if (is.null(name)) 
[17:39:51.788]                             next
[17:39:51.788]                           if (!grepl(pattern, name)) 
[17:39:51.788]                             next
[17:39:51.788]                           invokeRestart(restart)
[17:39:51.788]                           muffled <- TRUE
[17:39:51.788]                           break
[17:39:51.788]                         }
[17:39:51.788]                       }
[17:39:51.788]                     }
[17:39:51.788]                     invisible(muffled)
[17:39:51.788]                   }
[17:39:51.788]                   muffleCondition(cond)
[17:39:51.788]                 })
[17:39:51.788]             }))
[17:39:51.788]             future::FutureResult(value = ...future.value$value, 
[17:39:51.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.788]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.788]                     ...future.globalenv.names))
[17:39:51.788]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.788]         }, condition = base::local({
[17:39:51.788]             c <- base::c
[17:39:51.788]             inherits <- base::inherits
[17:39:51.788]             invokeRestart <- base::invokeRestart
[17:39:51.788]             length <- base::length
[17:39:51.788]             list <- base::list
[17:39:51.788]             seq.int <- base::seq.int
[17:39:51.788]             signalCondition <- base::signalCondition
[17:39:51.788]             sys.calls <- base::sys.calls
[17:39:51.788]             `[[` <- base::`[[`
[17:39:51.788]             `+` <- base::`+`
[17:39:51.788]             `<<-` <- base::`<<-`
[17:39:51.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.788]                   3L)]
[17:39:51.788]             }
[17:39:51.788]             function(cond) {
[17:39:51.788]                 is_error <- inherits(cond, "error")
[17:39:51.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.788]                   NULL)
[17:39:51.788]                 if (is_error) {
[17:39:51.788]                   sessionInformation <- function() {
[17:39:51.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.788]                       search = base::search(), system = base::Sys.info())
[17:39:51.788]                   }
[17:39:51.788]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.788]                     cond$call), session = sessionInformation(), 
[17:39:51.788]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.788]                   signalCondition(cond)
[17:39:51.788]                 }
[17:39:51.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.788]                 "immediateCondition"))) {
[17:39:51.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.788]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.788]                   if (TRUE && !signal) {
[17:39:51.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.788]                     {
[17:39:51.788]                       inherits <- base::inherits
[17:39:51.788]                       invokeRestart <- base::invokeRestart
[17:39:51.788]                       is.null <- base::is.null
[17:39:51.788]                       muffled <- FALSE
[17:39:51.788]                       if (inherits(cond, "message")) {
[17:39:51.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.788]                         if (muffled) 
[17:39:51.788]                           invokeRestart("muffleMessage")
[17:39:51.788]                       }
[17:39:51.788]                       else if (inherits(cond, "warning")) {
[17:39:51.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.788]                         if (muffled) 
[17:39:51.788]                           invokeRestart("muffleWarning")
[17:39:51.788]                       }
[17:39:51.788]                       else if (inherits(cond, "condition")) {
[17:39:51.788]                         if (!is.null(pattern)) {
[17:39:51.788]                           computeRestarts <- base::computeRestarts
[17:39:51.788]                           grepl <- base::grepl
[17:39:51.788]                           restarts <- computeRestarts(cond)
[17:39:51.788]                           for (restart in restarts) {
[17:39:51.788]                             name <- restart$name
[17:39:51.788]                             if (is.null(name)) 
[17:39:51.788]                               next
[17:39:51.788]                             if (!grepl(pattern, name)) 
[17:39:51.788]                               next
[17:39:51.788]                             invokeRestart(restart)
[17:39:51.788]                             muffled <- TRUE
[17:39:51.788]                             break
[17:39:51.788]                           }
[17:39:51.788]                         }
[17:39:51.788]                       }
[17:39:51.788]                       invisible(muffled)
[17:39:51.788]                     }
[17:39:51.788]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.788]                   }
[17:39:51.788]                 }
[17:39:51.788]                 else {
[17:39:51.788]                   if (TRUE) {
[17:39:51.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.788]                     {
[17:39:51.788]                       inherits <- base::inherits
[17:39:51.788]                       invokeRestart <- base::invokeRestart
[17:39:51.788]                       is.null <- base::is.null
[17:39:51.788]                       muffled <- FALSE
[17:39:51.788]                       if (inherits(cond, "message")) {
[17:39:51.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.788]                         if (muffled) 
[17:39:51.788]                           invokeRestart("muffleMessage")
[17:39:51.788]                       }
[17:39:51.788]                       else if (inherits(cond, "warning")) {
[17:39:51.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.788]                         if (muffled) 
[17:39:51.788]                           invokeRestart("muffleWarning")
[17:39:51.788]                       }
[17:39:51.788]                       else if (inherits(cond, "condition")) {
[17:39:51.788]                         if (!is.null(pattern)) {
[17:39:51.788]                           computeRestarts <- base::computeRestarts
[17:39:51.788]                           grepl <- base::grepl
[17:39:51.788]                           restarts <- computeRestarts(cond)
[17:39:51.788]                           for (restart in restarts) {
[17:39:51.788]                             name <- restart$name
[17:39:51.788]                             if (is.null(name)) 
[17:39:51.788]                               next
[17:39:51.788]                             if (!grepl(pattern, name)) 
[17:39:51.788]                               next
[17:39:51.788]                             invokeRestart(restart)
[17:39:51.788]                             muffled <- TRUE
[17:39:51.788]                             break
[17:39:51.788]                           }
[17:39:51.788]                         }
[17:39:51.788]                       }
[17:39:51.788]                       invisible(muffled)
[17:39:51.788]                     }
[17:39:51.788]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.788]                   }
[17:39:51.788]                 }
[17:39:51.788]             }
[17:39:51.788]         }))
[17:39:51.788]     }, error = function(ex) {
[17:39:51.788]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.788]                 ...future.rng), started = ...future.startTime, 
[17:39:51.788]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.788]             version = "1.8"), class = "FutureResult")
[17:39:51.788]     }, finally = {
[17:39:51.788]         if (!identical(...future.workdir, getwd())) 
[17:39:51.788]             setwd(...future.workdir)
[17:39:51.788]         {
[17:39:51.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.788]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.788]             }
[17:39:51.788]             base::options(...future.oldOptions)
[17:39:51.788]             if (.Platform$OS.type == "windows") {
[17:39:51.788]                 old_names <- names(...future.oldEnvVars)
[17:39:51.788]                 envs <- base::Sys.getenv()
[17:39:51.788]                 names <- names(envs)
[17:39:51.788]                 common <- intersect(names, old_names)
[17:39:51.788]                 added <- setdiff(names, old_names)
[17:39:51.788]                 removed <- setdiff(old_names, names)
[17:39:51.788]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.788]                   envs[common]]
[17:39:51.788]                 NAMES <- toupper(changed)
[17:39:51.788]                 args <- list()
[17:39:51.788]                 for (kk in seq_along(NAMES)) {
[17:39:51.788]                   name <- changed[[kk]]
[17:39:51.788]                   NAME <- NAMES[[kk]]
[17:39:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.788]                     next
[17:39:51.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.788]                 }
[17:39:51.788]                 NAMES <- toupper(added)
[17:39:51.788]                 for (kk in seq_along(NAMES)) {
[17:39:51.788]                   name <- added[[kk]]
[17:39:51.788]                   NAME <- NAMES[[kk]]
[17:39:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.788]                     next
[17:39:51.788]                   args[[name]] <- ""
[17:39:51.788]                 }
[17:39:51.788]                 NAMES <- toupper(removed)
[17:39:51.788]                 for (kk in seq_along(NAMES)) {
[17:39:51.788]                   name <- removed[[kk]]
[17:39:51.788]                   NAME <- NAMES[[kk]]
[17:39:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.788]                     next
[17:39:51.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.788]                 }
[17:39:51.788]                 if (length(args) > 0) 
[17:39:51.788]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.788]             }
[17:39:51.788]             else {
[17:39:51.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.788]             }
[17:39:51.788]             {
[17:39:51.788]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.788]                   0L) {
[17:39:51.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.788]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.788]                   base::options(opts)
[17:39:51.788]                 }
[17:39:51.788]                 {
[17:39:51.788]                   {
[17:39:51.788]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.788]                     NULL
[17:39:51.788]                   }
[17:39:51.788]                   options(future.plan = NULL)
[17:39:51.788]                   if (is.na(NA_character_)) 
[17:39:51.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.788]                     .init = FALSE)
[17:39:51.788]                 }
[17:39:51.788]             }
[17:39:51.788]         }
[17:39:51.788]     })
[17:39:51.788]     if (TRUE) {
[17:39:51.788]         base::sink(type = "output", split = FALSE)
[17:39:51.788]         if (TRUE) {
[17:39:51.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.788]         }
[17:39:51.788]         else {
[17:39:51.788]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.788]         }
[17:39:51.788]         base::close(...future.stdout)
[17:39:51.788]         ...future.stdout <- NULL
[17:39:51.788]     }
[17:39:51.788]     ...future.result$conditions <- ...future.conditions
[17:39:51.788]     ...future.result$finished <- base::Sys.time()
[17:39:51.788]     ...future.result
[17:39:51.788] }
[17:39:51.790] assign_globals() ...
[17:39:51.790] List of 1
[17:39:51.790]  $ x: list()
[17:39:51.790]  - attr(*, "where")=List of 1
[17:39:51.790]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.790]  - attr(*, "resolved")= logi TRUE
[17:39:51.790]  - attr(*, "total_size")= num 0
[17:39:51.790]  - attr(*, "already-done")= logi TRUE
[17:39:51.793] - copied ‘x’ to environment
[17:39:51.794] assign_globals() ... done
[17:39:51.794] requestCore(): workers = 2
[17:39:51.795] MulticoreFuture started
[17:39:51.796] - Launch lazy future ... done
[17:39:51.796] run() for ‘MulticoreFuture’ ... done
[17:39:51.797] plan(): Setting new future strategy stack:
[17:39:51.796] result() for MulticoreFuture ...
[17:39:51.797] List of future strategies:
[17:39:51.797] 1. sequential:
[17:39:51.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.797]    - tweaked: FALSE
[17:39:51.797]    - call: NULL
[17:39:51.802] plan(): nbrOfWorkers() = 1
[17:39:51.804] plan(): Setting new future strategy stack:
[17:39:51.804] List of future strategies:
[17:39:51.804] 1. multicore:
[17:39:51.804]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.804]    - tweaked: FALSE
[17:39:51.804]    - call: plan(strategy)
[17:39:51.809] plan(): nbrOfWorkers() = 2
[17:39:51.810] result() for MulticoreFuture ...
[17:39:51.810] result() for MulticoreFuture ... done
[17:39:51.810] result() for MulticoreFuture ... done
[17:39:51.810] result() for MulticoreFuture ...
[17:39:51.810] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.811] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.811] Searching for globals...
[17:39:51.814] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.814] Searching for globals ... DONE
[17:39:51.814] Resolving globals: TRUE
[17:39:51.814] Resolving any globals that are futures ...
[17:39:51.814] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.814] Resolving any globals that are futures ... DONE
[17:39:51.815] Resolving futures part of globals (recursively) ...
[17:39:51.815] resolve() on list ...
[17:39:51.815]  recursive: 99
[17:39:51.815]  length: 1
[17:39:51.815]  elements: ‘x’
[17:39:51.816]  length: 0 (resolved future 1)
[17:39:51.816] resolve() on list ... DONE
[17:39:51.816] - globals: [1] ‘x’
[17:39:51.816] Resolving futures part of globals (recursively) ... DONE
[17:39:51.816] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.817] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.817] - globals: [1] ‘x’
[17:39:51.817] 
[17:39:51.817] getGlobalsAndPackages() ... DONE
[17:39:51.817] run() for ‘Future’ ...
[17:39:51.817] - state: ‘created’
[17:39:51.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.821] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.822]   - Field: ‘label’
[17:39:51.822]   - Field: ‘local’
[17:39:51.822]   - Field: ‘owner’
[17:39:51.822]   - Field: ‘envir’
[17:39:51.822]   - Field: ‘workers’
[17:39:51.822]   - Field: ‘packages’
[17:39:51.822]   - Field: ‘gc’
[17:39:51.823]   - Field: ‘job’
[17:39:51.823]   - Field: ‘conditions’
[17:39:51.823]   - Field: ‘expr’
[17:39:51.823]   - Field: ‘uuid’
[17:39:51.823]   - Field: ‘seed’
[17:39:51.823]   - Field: ‘version’
[17:39:51.823]   - Field: ‘result’
[17:39:51.823]   - Field: ‘asynchronous’
[17:39:51.823]   - Field: ‘calls’
[17:39:51.823]   - Field: ‘globals’
[17:39:51.824]   - Field: ‘stdout’
[17:39:51.824]   - Field: ‘earlySignal’
[17:39:51.824]   - Field: ‘lazy’
[17:39:51.824]   - Field: ‘state’
[17:39:51.824] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.824] - Launch lazy future ...
[17:39:51.825] Packages needed by the future expression (n = 0): <none>
[17:39:51.825] Packages needed by future strategies (n = 0): <none>
[17:39:51.825] {
[17:39:51.825]     {
[17:39:51.825]         {
[17:39:51.825]             ...future.startTime <- base::Sys.time()
[17:39:51.825]             {
[17:39:51.825]                 {
[17:39:51.825]                   {
[17:39:51.825]                     {
[17:39:51.825]                       base::local({
[17:39:51.825]                         has_future <- base::requireNamespace("future", 
[17:39:51.825]                           quietly = TRUE)
[17:39:51.825]                         if (has_future) {
[17:39:51.825]                           ns <- base::getNamespace("future")
[17:39:51.825]                           version <- ns[[".package"]][["version"]]
[17:39:51.825]                           if (is.null(version)) 
[17:39:51.825]                             version <- utils::packageVersion("future")
[17:39:51.825]                         }
[17:39:51.825]                         else {
[17:39:51.825]                           version <- NULL
[17:39:51.825]                         }
[17:39:51.825]                         if (!has_future || version < "1.8.0") {
[17:39:51.825]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.825]                             "", base::R.version$version.string), 
[17:39:51.825]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.825]                               "release", "version")], collapse = " "), 
[17:39:51.825]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.825]                             info)
[17:39:51.825]                           info <- base::paste(info, collapse = "; ")
[17:39:51.825]                           if (!has_future) {
[17:39:51.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.825]                               info)
[17:39:51.825]                           }
[17:39:51.825]                           else {
[17:39:51.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.825]                               info, version)
[17:39:51.825]                           }
[17:39:51.825]                           base::stop(msg)
[17:39:51.825]                         }
[17:39:51.825]                       })
[17:39:51.825]                     }
[17:39:51.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.825]                     base::options(mc.cores = 1L)
[17:39:51.825]                   }
[17:39:51.825]                   ...future.strategy.old <- future::plan("list")
[17:39:51.825]                   options(future.plan = NULL)
[17:39:51.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.825]                 }
[17:39:51.825]                 ...future.workdir <- getwd()
[17:39:51.825]             }
[17:39:51.825]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.825]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.825]         }
[17:39:51.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.825]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.825]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.825]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.825]             base::names(...future.oldOptions))
[17:39:51.825]     }
[17:39:51.825]     if (FALSE) {
[17:39:51.825]     }
[17:39:51.825]     else {
[17:39:51.825]         if (TRUE) {
[17:39:51.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.825]                 open = "w")
[17:39:51.825]         }
[17:39:51.825]         else {
[17:39:51.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.825]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.825]         }
[17:39:51.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.825]             base::sink(type = "output", split = FALSE)
[17:39:51.825]             base::close(...future.stdout)
[17:39:51.825]         }, add = TRUE)
[17:39:51.825]     }
[17:39:51.825]     ...future.frame <- base::sys.nframe()
[17:39:51.825]     ...future.conditions <- base::list()
[17:39:51.825]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.825]     if (FALSE) {
[17:39:51.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.825]     }
[17:39:51.825]     ...future.result <- base::tryCatch({
[17:39:51.825]         base::withCallingHandlers({
[17:39:51.825]             ...future.value <- base::withVisible(base::local({
[17:39:51.825]                 withCallingHandlers({
[17:39:51.825]                   {
[17:39:51.825]                     x[["a"]] <- 1
[17:39:51.825]                     x
[17:39:51.825]                   }
[17:39:51.825]                 }, immediateCondition = function(cond) {
[17:39:51.825]                   save_rds <- function (object, pathname, ...) 
[17:39:51.825]                   {
[17:39:51.825]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.825]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.825]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.825]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.825]                         fi_tmp[["mtime"]])
[17:39:51.825]                     }
[17:39:51.825]                     tryCatch({
[17:39:51.825]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.825]                     }, error = function(ex) {
[17:39:51.825]                       msg <- conditionMessage(ex)
[17:39:51.825]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.825]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.825]                         fi_tmp[["mtime"]], msg)
[17:39:51.825]                       ex$message <- msg
[17:39:51.825]                       stop(ex)
[17:39:51.825]                     })
[17:39:51.825]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.825]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.825]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.825]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.825]                       fi <- file.info(pathname)
[17:39:51.825]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.825]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.825]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.825]                         fi[["size"]], fi[["mtime"]])
[17:39:51.825]                       stop(msg)
[17:39:51.825]                     }
[17:39:51.825]                     invisible(pathname)
[17:39:51.825]                   }
[17:39:51.825]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.825]                     rootPath = tempdir()) 
[17:39:51.825]                   {
[17:39:51.825]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.825]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.825]                       tmpdir = path, fileext = ".rds")
[17:39:51.825]                     save_rds(obj, file)
[17:39:51.825]                   }
[17:39:51.825]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.825]                   {
[17:39:51.825]                     inherits <- base::inherits
[17:39:51.825]                     invokeRestart <- base::invokeRestart
[17:39:51.825]                     is.null <- base::is.null
[17:39:51.825]                     muffled <- FALSE
[17:39:51.825]                     if (inherits(cond, "message")) {
[17:39:51.825]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.825]                       if (muffled) 
[17:39:51.825]                         invokeRestart("muffleMessage")
[17:39:51.825]                     }
[17:39:51.825]                     else if (inherits(cond, "warning")) {
[17:39:51.825]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.825]                       if (muffled) 
[17:39:51.825]                         invokeRestart("muffleWarning")
[17:39:51.825]                     }
[17:39:51.825]                     else if (inherits(cond, "condition")) {
[17:39:51.825]                       if (!is.null(pattern)) {
[17:39:51.825]                         computeRestarts <- base::computeRestarts
[17:39:51.825]                         grepl <- base::grepl
[17:39:51.825]                         restarts <- computeRestarts(cond)
[17:39:51.825]                         for (restart in restarts) {
[17:39:51.825]                           name <- restart$name
[17:39:51.825]                           if (is.null(name)) 
[17:39:51.825]                             next
[17:39:51.825]                           if (!grepl(pattern, name)) 
[17:39:51.825]                             next
[17:39:51.825]                           invokeRestart(restart)
[17:39:51.825]                           muffled <- TRUE
[17:39:51.825]                           break
[17:39:51.825]                         }
[17:39:51.825]                       }
[17:39:51.825]                     }
[17:39:51.825]                     invisible(muffled)
[17:39:51.825]                   }
[17:39:51.825]                   muffleCondition(cond)
[17:39:51.825]                 })
[17:39:51.825]             }))
[17:39:51.825]             future::FutureResult(value = ...future.value$value, 
[17:39:51.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.825]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.825]                     ...future.globalenv.names))
[17:39:51.825]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.825]         }, condition = base::local({
[17:39:51.825]             c <- base::c
[17:39:51.825]             inherits <- base::inherits
[17:39:51.825]             invokeRestart <- base::invokeRestart
[17:39:51.825]             length <- base::length
[17:39:51.825]             list <- base::list
[17:39:51.825]             seq.int <- base::seq.int
[17:39:51.825]             signalCondition <- base::signalCondition
[17:39:51.825]             sys.calls <- base::sys.calls
[17:39:51.825]             `[[` <- base::`[[`
[17:39:51.825]             `+` <- base::`+`
[17:39:51.825]             `<<-` <- base::`<<-`
[17:39:51.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.825]                   3L)]
[17:39:51.825]             }
[17:39:51.825]             function(cond) {
[17:39:51.825]                 is_error <- inherits(cond, "error")
[17:39:51.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.825]                   NULL)
[17:39:51.825]                 if (is_error) {
[17:39:51.825]                   sessionInformation <- function() {
[17:39:51.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.825]                       search = base::search(), system = base::Sys.info())
[17:39:51.825]                   }
[17:39:51.825]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.825]                     cond$call), session = sessionInformation(), 
[17:39:51.825]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.825]                   signalCondition(cond)
[17:39:51.825]                 }
[17:39:51.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.825]                 "immediateCondition"))) {
[17:39:51.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.825]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.825]                   if (TRUE && !signal) {
[17:39:51.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.825]                     {
[17:39:51.825]                       inherits <- base::inherits
[17:39:51.825]                       invokeRestart <- base::invokeRestart
[17:39:51.825]                       is.null <- base::is.null
[17:39:51.825]                       muffled <- FALSE
[17:39:51.825]                       if (inherits(cond, "message")) {
[17:39:51.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.825]                         if (muffled) 
[17:39:51.825]                           invokeRestart("muffleMessage")
[17:39:51.825]                       }
[17:39:51.825]                       else if (inherits(cond, "warning")) {
[17:39:51.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.825]                         if (muffled) 
[17:39:51.825]                           invokeRestart("muffleWarning")
[17:39:51.825]                       }
[17:39:51.825]                       else if (inherits(cond, "condition")) {
[17:39:51.825]                         if (!is.null(pattern)) {
[17:39:51.825]                           computeRestarts <- base::computeRestarts
[17:39:51.825]                           grepl <- base::grepl
[17:39:51.825]                           restarts <- computeRestarts(cond)
[17:39:51.825]                           for (restart in restarts) {
[17:39:51.825]                             name <- restart$name
[17:39:51.825]                             if (is.null(name)) 
[17:39:51.825]                               next
[17:39:51.825]                             if (!grepl(pattern, name)) 
[17:39:51.825]                               next
[17:39:51.825]                             invokeRestart(restart)
[17:39:51.825]                             muffled <- TRUE
[17:39:51.825]                             break
[17:39:51.825]                           }
[17:39:51.825]                         }
[17:39:51.825]                       }
[17:39:51.825]                       invisible(muffled)
[17:39:51.825]                     }
[17:39:51.825]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.825]                   }
[17:39:51.825]                 }
[17:39:51.825]                 else {
[17:39:51.825]                   if (TRUE) {
[17:39:51.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.825]                     {
[17:39:51.825]                       inherits <- base::inherits
[17:39:51.825]                       invokeRestart <- base::invokeRestart
[17:39:51.825]                       is.null <- base::is.null
[17:39:51.825]                       muffled <- FALSE
[17:39:51.825]                       if (inherits(cond, "message")) {
[17:39:51.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.825]                         if (muffled) 
[17:39:51.825]                           invokeRestart("muffleMessage")
[17:39:51.825]                       }
[17:39:51.825]                       else if (inherits(cond, "warning")) {
[17:39:51.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.825]                         if (muffled) 
[17:39:51.825]                           invokeRestart("muffleWarning")
[17:39:51.825]                       }
[17:39:51.825]                       else if (inherits(cond, "condition")) {
[17:39:51.825]                         if (!is.null(pattern)) {
[17:39:51.825]                           computeRestarts <- base::computeRestarts
[17:39:51.825]                           grepl <- base::grepl
[17:39:51.825]                           restarts <- computeRestarts(cond)
[17:39:51.825]                           for (restart in restarts) {
[17:39:51.825]                             name <- restart$name
[17:39:51.825]                             if (is.null(name)) 
[17:39:51.825]                               next
[17:39:51.825]                             if (!grepl(pattern, name)) 
[17:39:51.825]                               next
[17:39:51.825]                             invokeRestart(restart)
[17:39:51.825]                             muffled <- TRUE
[17:39:51.825]                             break
[17:39:51.825]                           }
[17:39:51.825]                         }
[17:39:51.825]                       }
[17:39:51.825]                       invisible(muffled)
[17:39:51.825]                     }
[17:39:51.825]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.825]                   }
[17:39:51.825]                 }
[17:39:51.825]             }
[17:39:51.825]         }))
[17:39:51.825]     }, error = function(ex) {
[17:39:51.825]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.825]                 ...future.rng), started = ...future.startTime, 
[17:39:51.825]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.825]             version = "1.8"), class = "FutureResult")
[17:39:51.825]     }, finally = {
[17:39:51.825]         if (!identical(...future.workdir, getwd())) 
[17:39:51.825]             setwd(...future.workdir)
[17:39:51.825]         {
[17:39:51.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.825]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.825]             }
[17:39:51.825]             base::options(...future.oldOptions)
[17:39:51.825]             if (.Platform$OS.type == "windows") {
[17:39:51.825]                 old_names <- names(...future.oldEnvVars)
[17:39:51.825]                 envs <- base::Sys.getenv()
[17:39:51.825]                 names <- names(envs)
[17:39:51.825]                 common <- intersect(names, old_names)
[17:39:51.825]                 added <- setdiff(names, old_names)
[17:39:51.825]                 removed <- setdiff(old_names, names)
[17:39:51.825]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.825]                   envs[common]]
[17:39:51.825]                 NAMES <- toupper(changed)
[17:39:51.825]                 args <- list()
[17:39:51.825]                 for (kk in seq_along(NAMES)) {
[17:39:51.825]                   name <- changed[[kk]]
[17:39:51.825]                   NAME <- NAMES[[kk]]
[17:39:51.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.825]                     next
[17:39:51.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.825]                 }
[17:39:51.825]                 NAMES <- toupper(added)
[17:39:51.825]                 for (kk in seq_along(NAMES)) {
[17:39:51.825]                   name <- added[[kk]]
[17:39:51.825]                   NAME <- NAMES[[kk]]
[17:39:51.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.825]                     next
[17:39:51.825]                   args[[name]] <- ""
[17:39:51.825]                 }
[17:39:51.825]                 NAMES <- toupper(removed)
[17:39:51.825]                 for (kk in seq_along(NAMES)) {
[17:39:51.825]                   name <- removed[[kk]]
[17:39:51.825]                   NAME <- NAMES[[kk]]
[17:39:51.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.825]                     next
[17:39:51.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.825]                 }
[17:39:51.825]                 if (length(args) > 0) 
[17:39:51.825]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.825]             }
[17:39:51.825]             else {
[17:39:51.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.825]             }
[17:39:51.825]             {
[17:39:51.825]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.825]                   0L) {
[17:39:51.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.825]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.825]                   base::options(opts)
[17:39:51.825]                 }
[17:39:51.825]                 {
[17:39:51.825]                   {
[17:39:51.825]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.825]                     NULL
[17:39:51.825]                   }
[17:39:51.825]                   options(future.plan = NULL)
[17:39:51.825]                   if (is.na(NA_character_)) 
[17:39:51.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.825]                     .init = FALSE)
[17:39:51.825]                 }
[17:39:51.825]             }
[17:39:51.825]         }
[17:39:51.825]     })
[17:39:51.825]     if (TRUE) {
[17:39:51.825]         base::sink(type = "output", split = FALSE)
[17:39:51.825]         if (TRUE) {
[17:39:51.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.825]         }
[17:39:51.825]         else {
[17:39:51.825]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.825]         }
[17:39:51.825]         base::close(...future.stdout)
[17:39:51.825]         ...future.stdout <- NULL
[17:39:51.825]     }
[17:39:51.825]     ...future.result$conditions <- ...future.conditions
[17:39:51.825]     ...future.result$finished <- base::Sys.time()
[17:39:51.825]     ...future.result
[17:39:51.825] }
[17:39:51.827] assign_globals() ...
[17:39:51.827] List of 1
[17:39:51.827]  $ x: list()
[17:39:51.827]  - attr(*, "where")=List of 1
[17:39:51.827]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.827]  - attr(*, "resolved")= logi TRUE
[17:39:51.827]  - attr(*, "total_size")= num 0
[17:39:51.827]  - attr(*, "already-done")= logi TRUE
[17:39:51.830] - copied ‘x’ to environment
[17:39:51.830] assign_globals() ... done
[17:39:51.831] requestCore(): workers = 2
[17:39:51.832] MulticoreFuture started
[17:39:51.833] - Launch lazy future ... done
[17:39:51.833] run() for ‘MulticoreFuture’ ... done
[17:39:51.833] result() for MulticoreFuture ...
[17:39:51.833] plan(): Setting new future strategy stack:
[17:39:51.834] List of future strategies:
[17:39:51.834] 1. sequential:
[17:39:51.834]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.834]    - tweaked: FALSE
[17:39:51.834]    - call: NULL
[17:39:51.835] plan(): nbrOfWorkers() = 1
[17:39:51.837] plan(): Setting new future strategy stack:
[17:39:51.837] List of future strategies:
[17:39:51.837] 1. multicore:
[17:39:51.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.837]    - tweaked: FALSE
[17:39:51.837]    - call: plan(strategy)
[17:39:51.842] plan(): nbrOfWorkers() = 2
[17:39:51.843] result() for MulticoreFuture ...
[17:39:51.843] result() for MulticoreFuture ... done
[17:39:51.843] result() for MulticoreFuture ... done
[17:39:51.843] result() for MulticoreFuture ...
[17:39:51.843] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.844] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.844] Searching for globals...
[17:39:51.847] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.847] Searching for globals ... DONE
[17:39:51.847] Resolving globals: TRUE
[17:39:51.847] Resolving any globals that are futures ...
[17:39:51.847] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:51.847] Resolving any globals that are futures ... DONE
[17:39:51.848] Resolving futures part of globals (recursively) ...
[17:39:51.848] resolve() on list ...
[17:39:51.848]  recursive: 99
[17:39:51.848]  length: 1
[17:39:51.849]  elements: ‘x’
[17:39:51.849]  length: 0 (resolved future 1)
[17:39:51.849] resolve() on list ... DONE
[17:39:51.849] - globals: [1] ‘x’
[17:39:51.849] Resolving futures part of globals (recursively) ... DONE
[17:39:51.849] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.850] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.850] - globals: [1] ‘x’
[17:39:51.850] 
[17:39:51.850] getGlobalsAndPackages() ... DONE
[17:39:51.850] run() for ‘Future’ ...
[17:39:51.850] - state: ‘created’
[17:39:51.851] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.854] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.855]   - Field: ‘label’
[17:39:51.855]   - Field: ‘local’
[17:39:51.855]   - Field: ‘owner’
[17:39:51.855]   - Field: ‘envir’
[17:39:51.855]   - Field: ‘workers’
[17:39:51.855]   - Field: ‘packages’
[17:39:51.855]   - Field: ‘gc’
[17:39:51.855]   - Field: ‘job’
[17:39:51.856]   - Field: ‘conditions’
[17:39:51.856]   - Field: ‘expr’
[17:39:51.856]   - Field: ‘uuid’
[17:39:51.858]   - Field: ‘seed’
[17:39:51.858]   - Field: ‘version’
[17:39:51.858]   - Field: ‘result’
[17:39:51.859]   - Field: ‘asynchronous’
[17:39:51.859]   - Field: ‘calls’
[17:39:51.859]   - Field: ‘globals’
[17:39:51.859]   - Field: ‘stdout’
[17:39:51.859]   - Field: ‘earlySignal’
[17:39:51.859]   - Field: ‘lazy’
[17:39:51.859]   - Field: ‘state’
[17:39:51.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.860] - Launch lazy future ...
[17:39:51.860] Packages needed by the future expression (n = 0): <none>
[17:39:51.860] Packages needed by future strategies (n = 0): <none>
[17:39:51.861] {
[17:39:51.861]     {
[17:39:51.861]         {
[17:39:51.861]             ...future.startTime <- base::Sys.time()
[17:39:51.861]             {
[17:39:51.861]                 {
[17:39:51.861]                   {
[17:39:51.861]                     {
[17:39:51.861]                       base::local({
[17:39:51.861]                         has_future <- base::requireNamespace("future", 
[17:39:51.861]                           quietly = TRUE)
[17:39:51.861]                         if (has_future) {
[17:39:51.861]                           ns <- base::getNamespace("future")
[17:39:51.861]                           version <- ns[[".package"]][["version"]]
[17:39:51.861]                           if (is.null(version)) 
[17:39:51.861]                             version <- utils::packageVersion("future")
[17:39:51.861]                         }
[17:39:51.861]                         else {
[17:39:51.861]                           version <- NULL
[17:39:51.861]                         }
[17:39:51.861]                         if (!has_future || version < "1.8.0") {
[17:39:51.861]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.861]                             "", base::R.version$version.string), 
[17:39:51.861]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.861]                               "release", "version")], collapse = " "), 
[17:39:51.861]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.861]                             info)
[17:39:51.861]                           info <- base::paste(info, collapse = "; ")
[17:39:51.861]                           if (!has_future) {
[17:39:51.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.861]                               info)
[17:39:51.861]                           }
[17:39:51.861]                           else {
[17:39:51.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.861]                               info, version)
[17:39:51.861]                           }
[17:39:51.861]                           base::stop(msg)
[17:39:51.861]                         }
[17:39:51.861]                       })
[17:39:51.861]                     }
[17:39:51.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.861]                     base::options(mc.cores = 1L)
[17:39:51.861]                   }
[17:39:51.861]                   ...future.strategy.old <- future::plan("list")
[17:39:51.861]                   options(future.plan = NULL)
[17:39:51.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.861]                 }
[17:39:51.861]                 ...future.workdir <- getwd()
[17:39:51.861]             }
[17:39:51.861]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.861]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.861]         }
[17:39:51.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.861]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.861]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.861]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.861]             base::names(...future.oldOptions))
[17:39:51.861]     }
[17:39:51.861]     if (FALSE) {
[17:39:51.861]     }
[17:39:51.861]     else {
[17:39:51.861]         if (TRUE) {
[17:39:51.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.861]                 open = "w")
[17:39:51.861]         }
[17:39:51.861]         else {
[17:39:51.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.861]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.861]         }
[17:39:51.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.861]             base::sink(type = "output", split = FALSE)
[17:39:51.861]             base::close(...future.stdout)
[17:39:51.861]         }, add = TRUE)
[17:39:51.861]     }
[17:39:51.861]     ...future.frame <- base::sys.nframe()
[17:39:51.861]     ...future.conditions <- base::list()
[17:39:51.861]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.861]     if (FALSE) {
[17:39:51.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.861]     }
[17:39:51.861]     ...future.result <- base::tryCatch({
[17:39:51.861]         base::withCallingHandlers({
[17:39:51.861]             ...future.value <- base::withVisible(base::local({
[17:39:51.861]                 withCallingHandlers({
[17:39:51.861]                   {
[17:39:51.861]                     x[["a"]] <- 1
[17:39:51.861]                     x
[17:39:51.861]                   }
[17:39:51.861]                 }, immediateCondition = function(cond) {
[17:39:51.861]                   save_rds <- function (object, pathname, ...) 
[17:39:51.861]                   {
[17:39:51.861]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.861]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.861]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.861]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.861]                         fi_tmp[["mtime"]])
[17:39:51.861]                     }
[17:39:51.861]                     tryCatch({
[17:39:51.861]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.861]                     }, error = function(ex) {
[17:39:51.861]                       msg <- conditionMessage(ex)
[17:39:51.861]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.861]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.861]                         fi_tmp[["mtime"]], msg)
[17:39:51.861]                       ex$message <- msg
[17:39:51.861]                       stop(ex)
[17:39:51.861]                     })
[17:39:51.861]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.861]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.861]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.861]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.861]                       fi <- file.info(pathname)
[17:39:51.861]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.861]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.861]                         fi[["size"]], fi[["mtime"]])
[17:39:51.861]                       stop(msg)
[17:39:51.861]                     }
[17:39:51.861]                     invisible(pathname)
[17:39:51.861]                   }
[17:39:51.861]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.861]                     rootPath = tempdir()) 
[17:39:51.861]                   {
[17:39:51.861]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.861]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.861]                       tmpdir = path, fileext = ".rds")
[17:39:51.861]                     save_rds(obj, file)
[17:39:51.861]                   }
[17:39:51.861]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.861]                   {
[17:39:51.861]                     inherits <- base::inherits
[17:39:51.861]                     invokeRestart <- base::invokeRestart
[17:39:51.861]                     is.null <- base::is.null
[17:39:51.861]                     muffled <- FALSE
[17:39:51.861]                     if (inherits(cond, "message")) {
[17:39:51.861]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.861]                       if (muffled) 
[17:39:51.861]                         invokeRestart("muffleMessage")
[17:39:51.861]                     }
[17:39:51.861]                     else if (inherits(cond, "warning")) {
[17:39:51.861]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.861]                       if (muffled) 
[17:39:51.861]                         invokeRestart("muffleWarning")
[17:39:51.861]                     }
[17:39:51.861]                     else if (inherits(cond, "condition")) {
[17:39:51.861]                       if (!is.null(pattern)) {
[17:39:51.861]                         computeRestarts <- base::computeRestarts
[17:39:51.861]                         grepl <- base::grepl
[17:39:51.861]                         restarts <- computeRestarts(cond)
[17:39:51.861]                         for (restart in restarts) {
[17:39:51.861]                           name <- restart$name
[17:39:51.861]                           if (is.null(name)) 
[17:39:51.861]                             next
[17:39:51.861]                           if (!grepl(pattern, name)) 
[17:39:51.861]                             next
[17:39:51.861]                           invokeRestart(restart)
[17:39:51.861]                           muffled <- TRUE
[17:39:51.861]                           break
[17:39:51.861]                         }
[17:39:51.861]                       }
[17:39:51.861]                     }
[17:39:51.861]                     invisible(muffled)
[17:39:51.861]                   }
[17:39:51.861]                   muffleCondition(cond)
[17:39:51.861]                 })
[17:39:51.861]             }))
[17:39:51.861]             future::FutureResult(value = ...future.value$value, 
[17:39:51.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.861]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.861]                     ...future.globalenv.names))
[17:39:51.861]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.861]         }, condition = base::local({
[17:39:51.861]             c <- base::c
[17:39:51.861]             inherits <- base::inherits
[17:39:51.861]             invokeRestart <- base::invokeRestart
[17:39:51.861]             length <- base::length
[17:39:51.861]             list <- base::list
[17:39:51.861]             seq.int <- base::seq.int
[17:39:51.861]             signalCondition <- base::signalCondition
[17:39:51.861]             sys.calls <- base::sys.calls
[17:39:51.861]             `[[` <- base::`[[`
[17:39:51.861]             `+` <- base::`+`
[17:39:51.861]             `<<-` <- base::`<<-`
[17:39:51.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.861]                   3L)]
[17:39:51.861]             }
[17:39:51.861]             function(cond) {
[17:39:51.861]                 is_error <- inherits(cond, "error")
[17:39:51.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.861]                   NULL)
[17:39:51.861]                 if (is_error) {
[17:39:51.861]                   sessionInformation <- function() {
[17:39:51.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.861]                       search = base::search(), system = base::Sys.info())
[17:39:51.861]                   }
[17:39:51.861]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.861]                     cond$call), session = sessionInformation(), 
[17:39:51.861]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.861]                   signalCondition(cond)
[17:39:51.861]                 }
[17:39:51.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.861]                 "immediateCondition"))) {
[17:39:51.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.861]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.861]                   if (TRUE && !signal) {
[17:39:51.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.861]                     {
[17:39:51.861]                       inherits <- base::inherits
[17:39:51.861]                       invokeRestart <- base::invokeRestart
[17:39:51.861]                       is.null <- base::is.null
[17:39:51.861]                       muffled <- FALSE
[17:39:51.861]                       if (inherits(cond, "message")) {
[17:39:51.861]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.861]                         if (muffled) 
[17:39:51.861]                           invokeRestart("muffleMessage")
[17:39:51.861]                       }
[17:39:51.861]                       else if (inherits(cond, "warning")) {
[17:39:51.861]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.861]                         if (muffled) 
[17:39:51.861]                           invokeRestart("muffleWarning")
[17:39:51.861]                       }
[17:39:51.861]                       else if (inherits(cond, "condition")) {
[17:39:51.861]                         if (!is.null(pattern)) {
[17:39:51.861]                           computeRestarts <- base::computeRestarts
[17:39:51.861]                           grepl <- base::grepl
[17:39:51.861]                           restarts <- computeRestarts(cond)
[17:39:51.861]                           for (restart in restarts) {
[17:39:51.861]                             name <- restart$name
[17:39:51.861]                             if (is.null(name)) 
[17:39:51.861]                               next
[17:39:51.861]                             if (!grepl(pattern, name)) 
[17:39:51.861]                               next
[17:39:51.861]                             invokeRestart(restart)
[17:39:51.861]                             muffled <- TRUE
[17:39:51.861]                             break
[17:39:51.861]                           }
[17:39:51.861]                         }
[17:39:51.861]                       }
[17:39:51.861]                       invisible(muffled)
[17:39:51.861]                     }
[17:39:51.861]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.861]                   }
[17:39:51.861]                 }
[17:39:51.861]                 else {
[17:39:51.861]                   if (TRUE) {
[17:39:51.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.861]                     {
[17:39:51.861]                       inherits <- base::inherits
[17:39:51.861]                       invokeRestart <- base::invokeRestart
[17:39:51.861]                       is.null <- base::is.null
[17:39:51.861]                       muffled <- FALSE
[17:39:51.861]                       if (inherits(cond, "message")) {
[17:39:51.861]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.861]                         if (muffled) 
[17:39:51.861]                           invokeRestart("muffleMessage")
[17:39:51.861]                       }
[17:39:51.861]                       else if (inherits(cond, "warning")) {
[17:39:51.861]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.861]                         if (muffled) 
[17:39:51.861]                           invokeRestart("muffleWarning")
[17:39:51.861]                       }
[17:39:51.861]                       else if (inherits(cond, "condition")) {
[17:39:51.861]                         if (!is.null(pattern)) {
[17:39:51.861]                           computeRestarts <- base::computeRestarts
[17:39:51.861]                           grepl <- base::grepl
[17:39:51.861]                           restarts <- computeRestarts(cond)
[17:39:51.861]                           for (restart in restarts) {
[17:39:51.861]                             name <- restart$name
[17:39:51.861]                             if (is.null(name)) 
[17:39:51.861]                               next
[17:39:51.861]                             if (!grepl(pattern, name)) 
[17:39:51.861]                               next
[17:39:51.861]                             invokeRestart(restart)
[17:39:51.861]                             muffled <- TRUE
[17:39:51.861]                             break
[17:39:51.861]                           }
[17:39:51.861]                         }
[17:39:51.861]                       }
[17:39:51.861]                       invisible(muffled)
[17:39:51.861]                     }
[17:39:51.861]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.861]                   }
[17:39:51.861]                 }
[17:39:51.861]             }
[17:39:51.861]         }))
[17:39:51.861]     }, error = function(ex) {
[17:39:51.861]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.861]                 ...future.rng), started = ...future.startTime, 
[17:39:51.861]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.861]             version = "1.8"), class = "FutureResult")
[17:39:51.861]     }, finally = {
[17:39:51.861]         if (!identical(...future.workdir, getwd())) 
[17:39:51.861]             setwd(...future.workdir)
[17:39:51.861]         {
[17:39:51.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.861]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.861]             }
[17:39:51.861]             base::options(...future.oldOptions)
[17:39:51.861]             if (.Platform$OS.type == "windows") {
[17:39:51.861]                 old_names <- names(...future.oldEnvVars)
[17:39:51.861]                 envs <- base::Sys.getenv()
[17:39:51.861]                 names <- names(envs)
[17:39:51.861]                 common <- intersect(names, old_names)
[17:39:51.861]                 added <- setdiff(names, old_names)
[17:39:51.861]                 removed <- setdiff(old_names, names)
[17:39:51.861]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.861]                   envs[common]]
[17:39:51.861]                 NAMES <- toupper(changed)
[17:39:51.861]                 args <- list()
[17:39:51.861]                 for (kk in seq_along(NAMES)) {
[17:39:51.861]                   name <- changed[[kk]]
[17:39:51.861]                   NAME <- NAMES[[kk]]
[17:39:51.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.861]                     next
[17:39:51.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.861]                 }
[17:39:51.861]                 NAMES <- toupper(added)
[17:39:51.861]                 for (kk in seq_along(NAMES)) {
[17:39:51.861]                   name <- added[[kk]]
[17:39:51.861]                   NAME <- NAMES[[kk]]
[17:39:51.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.861]                     next
[17:39:51.861]                   args[[name]] <- ""
[17:39:51.861]                 }
[17:39:51.861]                 NAMES <- toupper(removed)
[17:39:51.861]                 for (kk in seq_along(NAMES)) {
[17:39:51.861]                   name <- removed[[kk]]
[17:39:51.861]                   NAME <- NAMES[[kk]]
[17:39:51.861]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.861]                     next
[17:39:51.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.861]                 }
[17:39:51.861]                 if (length(args) > 0) 
[17:39:51.861]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.861]             }
[17:39:51.861]             else {
[17:39:51.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.861]             }
[17:39:51.861]             {
[17:39:51.861]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.861]                   0L) {
[17:39:51.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.861]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.861]                   base::options(opts)
[17:39:51.861]                 }
[17:39:51.861]                 {
[17:39:51.861]                   {
[17:39:51.861]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.861]                     NULL
[17:39:51.861]                   }
[17:39:51.861]                   options(future.plan = NULL)
[17:39:51.861]                   if (is.na(NA_character_)) 
[17:39:51.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.861]                     .init = FALSE)
[17:39:51.861]                 }
[17:39:51.861]             }
[17:39:51.861]         }
[17:39:51.861]     })
[17:39:51.861]     if (TRUE) {
[17:39:51.861]         base::sink(type = "output", split = FALSE)
[17:39:51.861]         if (TRUE) {
[17:39:51.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.861]         }
[17:39:51.861]         else {
[17:39:51.861]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.861]         }
[17:39:51.861]         base::close(...future.stdout)
[17:39:51.861]         ...future.stdout <- NULL
[17:39:51.861]     }
[17:39:51.861]     ...future.result$conditions <- ...future.conditions
[17:39:51.861]     ...future.result$finished <- base::Sys.time()
[17:39:51.861]     ...future.result
[17:39:51.861] }
[17:39:51.863] assign_globals() ...
[17:39:51.863] List of 1
[17:39:51.863]  $ x: list()
[17:39:51.863]  - attr(*, "where")=List of 1
[17:39:51.863]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.863]  - attr(*, "resolved")= logi TRUE
[17:39:51.863]  - attr(*, "total_size")= num 0
[17:39:51.863]  - attr(*, "already-done")= logi TRUE
[17:39:51.866] - copied ‘x’ to environment
[17:39:51.866] assign_globals() ... done
[17:39:51.866] requestCore(): workers = 2
[17:39:51.868] MulticoreFuture started
[17:39:51.868] - Launch lazy future ... done
[17:39:51.868] run() for ‘MulticoreFuture’ ... done
[17:39:51.869] result() for MulticoreFuture ...
[17:39:51.869] plan(): Setting new future strategy stack:
[17:39:51.869] List of future strategies:
[17:39:51.869] 1. sequential:
[17:39:51.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.869]    - tweaked: FALSE
[17:39:51.869]    - call: NULL
[17:39:51.870] plan(): nbrOfWorkers() = 1
[17:39:51.872] plan(): Setting new future strategy stack:
[17:39:51.872] List of future strategies:
[17:39:51.872] 1. multicore:
[17:39:51.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.872]    - tweaked: FALSE
[17:39:51.872]    - call: plan(strategy)
[17:39:51.877] plan(): nbrOfWorkers() = 2
[17:39:51.878] result() for MulticoreFuture ...
[17:39:51.878] result() for MulticoreFuture ... done
[17:39:51.878] result() for MulticoreFuture ... done
[17:39:51.878] result() for MulticoreFuture ...
[17:39:51.878] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.879] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.879] Searching for globals...
[17:39:51.882] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.882] Searching for globals ... DONE
[17:39:51.882] Resolving globals: TRUE
[17:39:51.882] Resolving any globals that are futures ...
[17:39:51.882] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.882] Resolving any globals that are futures ... DONE
[17:39:51.883] Resolving futures part of globals (recursively) ...
[17:39:51.883] resolve() on list ...
[17:39:51.883]  recursive: 99
[17:39:51.884]  length: 1
[17:39:51.884]  elements: ‘x’
[17:39:51.884]  length: 0 (resolved future 1)
[17:39:51.884] resolve() on list ... DONE
[17:39:51.884] - globals: [1] ‘x’
[17:39:51.884] Resolving futures part of globals (recursively) ... DONE
[17:39:51.884] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.885] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.885] - globals: [1] ‘x’
[17:39:51.885] 
[17:39:51.885] getGlobalsAndPackages() ... DONE
[17:39:51.885] run() for ‘Future’ ...
[17:39:51.886] - state: ‘created’
[17:39:51.886] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.890] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.890]   - Field: ‘label’
[17:39:51.890]   - Field: ‘local’
[17:39:51.890]   - Field: ‘owner’
[17:39:51.890]   - Field: ‘envir’
[17:39:51.890]   - Field: ‘workers’
[17:39:51.890]   - Field: ‘packages’
[17:39:51.891]   - Field: ‘gc’
[17:39:51.891]   - Field: ‘job’
[17:39:51.891]   - Field: ‘conditions’
[17:39:51.891]   - Field: ‘expr’
[17:39:51.891]   - Field: ‘uuid’
[17:39:51.891]   - Field: ‘seed’
[17:39:51.891]   - Field: ‘version’
[17:39:51.891]   - Field: ‘result’
[17:39:51.891]   - Field: ‘asynchronous’
[17:39:51.891]   - Field: ‘calls’
[17:39:51.892]   - Field: ‘globals’
[17:39:51.892]   - Field: ‘stdout’
[17:39:51.892]   - Field: ‘earlySignal’
[17:39:51.892]   - Field: ‘lazy’
[17:39:51.892]   - Field: ‘state’
[17:39:51.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.892] - Launch lazy future ...
[17:39:51.893] Packages needed by the future expression (n = 0): <none>
[17:39:51.893] Packages needed by future strategies (n = 0): <none>
[17:39:51.893] {
[17:39:51.893]     {
[17:39:51.893]         {
[17:39:51.893]             ...future.startTime <- base::Sys.time()
[17:39:51.893]             {
[17:39:51.893]                 {
[17:39:51.893]                   {
[17:39:51.893]                     {
[17:39:51.893]                       base::local({
[17:39:51.893]                         has_future <- base::requireNamespace("future", 
[17:39:51.893]                           quietly = TRUE)
[17:39:51.893]                         if (has_future) {
[17:39:51.893]                           ns <- base::getNamespace("future")
[17:39:51.893]                           version <- ns[[".package"]][["version"]]
[17:39:51.893]                           if (is.null(version)) 
[17:39:51.893]                             version <- utils::packageVersion("future")
[17:39:51.893]                         }
[17:39:51.893]                         else {
[17:39:51.893]                           version <- NULL
[17:39:51.893]                         }
[17:39:51.893]                         if (!has_future || version < "1.8.0") {
[17:39:51.893]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.893]                             "", base::R.version$version.string), 
[17:39:51.893]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.893]                               "release", "version")], collapse = " "), 
[17:39:51.893]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.893]                             info)
[17:39:51.893]                           info <- base::paste(info, collapse = "; ")
[17:39:51.893]                           if (!has_future) {
[17:39:51.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.893]                               info)
[17:39:51.893]                           }
[17:39:51.893]                           else {
[17:39:51.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.893]                               info, version)
[17:39:51.893]                           }
[17:39:51.893]                           base::stop(msg)
[17:39:51.893]                         }
[17:39:51.893]                       })
[17:39:51.893]                     }
[17:39:51.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.893]                     base::options(mc.cores = 1L)
[17:39:51.893]                   }
[17:39:51.893]                   ...future.strategy.old <- future::plan("list")
[17:39:51.893]                   options(future.plan = NULL)
[17:39:51.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.893]                 }
[17:39:51.893]                 ...future.workdir <- getwd()
[17:39:51.893]             }
[17:39:51.893]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.893]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.893]         }
[17:39:51.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.893]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.893]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.893]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.893]             base::names(...future.oldOptions))
[17:39:51.893]     }
[17:39:51.893]     if (FALSE) {
[17:39:51.893]     }
[17:39:51.893]     else {
[17:39:51.893]         if (TRUE) {
[17:39:51.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.893]                 open = "w")
[17:39:51.893]         }
[17:39:51.893]         else {
[17:39:51.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.893]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.893]         }
[17:39:51.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.893]             base::sink(type = "output", split = FALSE)
[17:39:51.893]             base::close(...future.stdout)
[17:39:51.893]         }, add = TRUE)
[17:39:51.893]     }
[17:39:51.893]     ...future.frame <- base::sys.nframe()
[17:39:51.893]     ...future.conditions <- base::list()
[17:39:51.893]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.893]     if (FALSE) {
[17:39:51.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.893]     }
[17:39:51.893]     ...future.result <- base::tryCatch({
[17:39:51.893]         base::withCallingHandlers({
[17:39:51.893]             ...future.value <- base::withVisible(base::local({
[17:39:51.893]                 withCallingHandlers({
[17:39:51.893]                   {
[17:39:51.893]                     x["a"] <- list(1)
[17:39:51.893]                     x
[17:39:51.893]                   }
[17:39:51.893]                 }, immediateCondition = function(cond) {
[17:39:51.893]                   save_rds <- function (object, pathname, ...) 
[17:39:51.893]                   {
[17:39:51.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.893]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.893]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.893]                         fi_tmp[["mtime"]])
[17:39:51.893]                     }
[17:39:51.893]                     tryCatch({
[17:39:51.893]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.893]                     }, error = function(ex) {
[17:39:51.893]                       msg <- conditionMessage(ex)
[17:39:51.893]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.893]                         fi_tmp[["mtime"]], msg)
[17:39:51.893]                       ex$message <- msg
[17:39:51.893]                       stop(ex)
[17:39:51.893]                     })
[17:39:51.893]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.893]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.893]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.893]                       fi <- file.info(pathname)
[17:39:51.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.893]                         fi[["size"]], fi[["mtime"]])
[17:39:51.893]                       stop(msg)
[17:39:51.893]                     }
[17:39:51.893]                     invisible(pathname)
[17:39:51.893]                   }
[17:39:51.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.893]                     rootPath = tempdir()) 
[17:39:51.893]                   {
[17:39:51.893]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.893]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.893]                       tmpdir = path, fileext = ".rds")
[17:39:51.893]                     save_rds(obj, file)
[17:39:51.893]                   }
[17:39:51.893]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.893]                   {
[17:39:51.893]                     inherits <- base::inherits
[17:39:51.893]                     invokeRestart <- base::invokeRestart
[17:39:51.893]                     is.null <- base::is.null
[17:39:51.893]                     muffled <- FALSE
[17:39:51.893]                     if (inherits(cond, "message")) {
[17:39:51.893]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.893]                       if (muffled) 
[17:39:51.893]                         invokeRestart("muffleMessage")
[17:39:51.893]                     }
[17:39:51.893]                     else if (inherits(cond, "warning")) {
[17:39:51.893]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.893]                       if (muffled) 
[17:39:51.893]                         invokeRestart("muffleWarning")
[17:39:51.893]                     }
[17:39:51.893]                     else if (inherits(cond, "condition")) {
[17:39:51.893]                       if (!is.null(pattern)) {
[17:39:51.893]                         computeRestarts <- base::computeRestarts
[17:39:51.893]                         grepl <- base::grepl
[17:39:51.893]                         restarts <- computeRestarts(cond)
[17:39:51.893]                         for (restart in restarts) {
[17:39:51.893]                           name <- restart$name
[17:39:51.893]                           if (is.null(name)) 
[17:39:51.893]                             next
[17:39:51.893]                           if (!grepl(pattern, name)) 
[17:39:51.893]                             next
[17:39:51.893]                           invokeRestart(restart)
[17:39:51.893]                           muffled <- TRUE
[17:39:51.893]                           break
[17:39:51.893]                         }
[17:39:51.893]                       }
[17:39:51.893]                     }
[17:39:51.893]                     invisible(muffled)
[17:39:51.893]                   }
[17:39:51.893]                   muffleCondition(cond)
[17:39:51.893]                 })
[17:39:51.893]             }))
[17:39:51.893]             future::FutureResult(value = ...future.value$value, 
[17:39:51.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.893]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.893]                     ...future.globalenv.names))
[17:39:51.893]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.893]         }, condition = base::local({
[17:39:51.893]             c <- base::c
[17:39:51.893]             inherits <- base::inherits
[17:39:51.893]             invokeRestart <- base::invokeRestart
[17:39:51.893]             length <- base::length
[17:39:51.893]             list <- base::list
[17:39:51.893]             seq.int <- base::seq.int
[17:39:51.893]             signalCondition <- base::signalCondition
[17:39:51.893]             sys.calls <- base::sys.calls
[17:39:51.893]             `[[` <- base::`[[`
[17:39:51.893]             `+` <- base::`+`
[17:39:51.893]             `<<-` <- base::`<<-`
[17:39:51.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.893]                   3L)]
[17:39:51.893]             }
[17:39:51.893]             function(cond) {
[17:39:51.893]                 is_error <- inherits(cond, "error")
[17:39:51.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.893]                   NULL)
[17:39:51.893]                 if (is_error) {
[17:39:51.893]                   sessionInformation <- function() {
[17:39:51.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.893]                       search = base::search(), system = base::Sys.info())
[17:39:51.893]                   }
[17:39:51.893]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.893]                     cond$call), session = sessionInformation(), 
[17:39:51.893]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.893]                   signalCondition(cond)
[17:39:51.893]                 }
[17:39:51.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.893]                 "immediateCondition"))) {
[17:39:51.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.893]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.893]                   if (TRUE && !signal) {
[17:39:51.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.893]                     {
[17:39:51.893]                       inherits <- base::inherits
[17:39:51.893]                       invokeRestart <- base::invokeRestart
[17:39:51.893]                       is.null <- base::is.null
[17:39:51.893]                       muffled <- FALSE
[17:39:51.893]                       if (inherits(cond, "message")) {
[17:39:51.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.893]                         if (muffled) 
[17:39:51.893]                           invokeRestart("muffleMessage")
[17:39:51.893]                       }
[17:39:51.893]                       else if (inherits(cond, "warning")) {
[17:39:51.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.893]                         if (muffled) 
[17:39:51.893]                           invokeRestart("muffleWarning")
[17:39:51.893]                       }
[17:39:51.893]                       else if (inherits(cond, "condition")) {
[17:39:51.893]                         if (!is.null(pattern)) {
[17:39:51.893]                           computeRestarts <- base::computeRestarts
[17:39:51.893]                           grepl <- base::grepl
[17:39:51.893]                           restarts <- computeRestarts(cond)
[17:39:51.893]                           for (restart in restarts) {
[17:39:51.893]                             name <- restart$name
[17:39:51.893]                             if (is.null(name)) 
[17:39:51.893]                               next
[17:39:51.893]                             if (!grepl(pattern, name)) 
[17:39:51.893]                               next
[17:39:51.893]                             invokeRestart(restart)
[17:39:51.893]                             muffled <- TRUE
[17:39:51.893]                             break
[17:39:51.893]                           }
[17:39:51.893]                         }
[17:39:51.893]                       }
[17:39:51.893]                       invisible(muffled)
[17:39:51.893]                     }
[17:39:51.893]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.893]                   }
[17:39:51.893]                 }
[17:39:51.893]                 else {
[17:39:51.893]                   if (TRUE) {
[17:39:51.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.893]                     {
[17:39:51.893]                       inherits <- base::inherits
[17:39:51.893]                       invokeRestart <- base::invokeRestart
[17:39:51.893]                       is.null <- base::is.null
[17:39:51.893]                       muffled <- FALSE
[17:39:51.893]                       if (inherits(cond, "message")) {
[17:39:51.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.893]                         if (muffled) 
[17:39:51.893]                           invokeRestart("muffleMessage")
[17:39:51.893]                       }
[17:39:51.893]                       else if (inherits(cond, "warning")) {
[17:39:51.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.893]                         if (muffled) 
[17:39:51.893]                           invokeRestart("muffleWarning")
[17:39:51.893]                       }
[17:39:51.893]                       else if (inherits(cond, "condition")) {
[17:39:51.893]                         if (!is.null(pattern)) {
[17:39:51.893]                           computeRestarts <- base::computeRestarts
[17:39:51.893]                           grepl <- base::grepl
[17:39:51.893]                           restarts <- computeRestarts(cond)
[17:39:51.893]                           for (restart in restarts) {
[17:39:51.893]                             name <- restart$name
[17:39:51.893]                             if (is.null(name)) 
[17:39:51.893]                               next
[17:39:51.893]                             if (!grepl(pattern, name)) 
[17:39:51.893]                               next
[17:39:51.893]                             invokeRestart(restart)
[17:39:51.893]                             muffled <- TRUE
[17:39:51.893]                             break
[17:39:51.893]                           }
[17:39:51.893]                         }
[17:39:51.893]                       }
[17:39:51.893]                       invisible(muffled)
[17:39:51.893]                     }
[17:39:51.893]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.893]                   }
[17:39:51.893]                 }
[17:39:51.893]             }
[17:39:51.893]         }))
[17:39:51.893]     }, error = function(ex) {
[17:39:51.893]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.893]                 ...future.rng), started = ...future.startTime, 
[17:39:51.893]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.893]             version = "1.8"), class = "FutureResult")
[17:39:51.893]     }, finally = {
[17:39:51.893]         if (!identical(...future.workdir, getwd())) 
[17:39:51.893]             setwd(...future.workdir)
[17:39:51.893]         {
[17:39:51.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.893]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.893]             }
[17:39:51.893]             base::options(...future.oldOptions)
[17:39:51.893]             if (.Platform$OS.type == "windows") {
[17:39:51.893]                 old_names <- names(...future.oldEnvVars)
[17:39:51.893]                 envs <- base::Sys.getenv()
[17:39:51.893]                 names <- names(envs)
[17:39:51.893]                 common <- intersect(names, old_names)
[17:39:51.893]                 added <- setdiff(names, old_names)
[17:39:51.893]                 removed <- setdiff(old_names, names)
[17:39:51.893]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.893]                   envs[common]]
[17:39:51.893]                 NAMES <- toupper(changed)
[17:39:51.893]                 args <- list()
[17:39:51.893]                 for (kk in seq_along(NAMES)) {
[17:39:51.893]                   name <- changed[[kk]]
[17:39:51.893]                   NAME <- NAMES[[kk]]
[17:39:51.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.893]                     next
[17:39:51.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.893]                 }
[17:39:51.893]                 NAMES <- toupper(added)
[17:39:51.893]                 for (kk in seq_along(NAMES)) {
[17:39:51.893]                   name <- added[[kk]]
[17:39:51.893]                   NAME <- NAMES[[kk]]
[17:39:51.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.893]                     next
[17:39:51.893]                   args[[name]] <- ""
[17:39:51.893]                 }
[17:39:51.893]                 NAMES <- toupper(removed)
[17:39:51.893]                 for (kk in seq_along(NAMES)) {
[17:39:51.893]                   name <- removed[[kk]]
[17:39:51.893]                   NAME <- NAMES[[kk]]
[17:39:51.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.893]                     next
[17:39:51.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.893]                 }
[17:39:51.893]                 if (length(args) > 0) 
[17:39:51.893]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.893]             }
[17:39:51.893]             else {
[17:39:51.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.893]             }
[17:39:51.893]             {
[17:39:51.893]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.893]                   0L) {
[17:39:51.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.893]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.893]                   base::options(opts)
[17:39:51.893]                 }
[17:39:51.893]                 {
[17:39:51.893]                   {
[17:39:51.893]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.893]                     NULL
[17:39:51.893]                   }
[17:39:51.893]                   options(future.plan = NULL)
[17:39:51.893]                   if (is.na(NA_character_)) 
[17:39:51.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.893]                     .init = FALSE)
[17:39:51.893]                 }
[17:39:51.893]             }
[17:39:51.893]         }
[17:39:51.893]     })
[17:39:51.893]     if (TRUE) {
[17:39:51.893]         base::sink(type = "output", split = FALSE)
[17:39:51.893]         if (TRUE) {
[17:39:51.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.893]         }
[17:39:51.893]         else {
[17:39:51.893]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.893]         }
[17:39:51.893]         base::close(...future.stdout)
[17:39:51.893]         ...future.stdout <- NULL
[17:39:51.893]     }
[17:39:51.893]     ...future.result$conditions <- ...future.conditions
[17:39:51.893]     ...future.result$finished <- base::Sys.time()
[17:39:51.893]     ...future.result
[17:39:51.893] }
[17:39:51.896] assign_globals() ...
[17:39:51.896] List of 1
[17:39:51.896]  $ x: list()
[17:39:51.896]  - attr(*, "where")=List of 1
[17:39:51.896]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.896]  - attr(*, "resolved")= logi TRUE
[17:39:51.896]  - attr(*, "total_size")= num 0
[17:39:51.896]  - attr(*, "already-done")= logi TRUE
[17:39:51.898] - copied ‘x’ to environment
[17:39:51.899] assign_globals() ... done
[17:39:51.899] requestCore(): workers = 2
[17:39:51.900] MulticoreFuture started
[17:39:51.901] - Launch lazy future ... done
[17:39:51.901] run() for ‘MulticoreFuture’ ... done
[17:39:51.901] result() for MulticoreFuture ...
[17:39:51.902] plan(): Setting new future strategy stack:
[17:39:51.902] List of future strategies:
[17:39:51.902] 1. sequential:
[17:39:51.902]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.902]    - tweaked: FALSE
[17:39:51.902]    - call: NULL
[17:39:51.903] plan(): nbrOfWorkers() = 1
[17:39:51.905] plan(): Setting new future strategy stack:
[17:39:51.905] List of future strategies:
[17:39:51.905] 1. multicore:
[17:39:51.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.905]    - tweaked: FALSE
[17:39:51.905]    - call: plan(strategy)
[17:39:51.910] plan(): nbrOfWorkers() = 2
[17:39:51.911] result() for MulticoreFuture ...
[17:39:51.911] result() for MulticoreFuture ... done
[17:39:51.911] result() for MulticoreFuture ... done
[17:39:51.911] result() for MulticoreFuture ...
[17:39:51.911] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.912] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.912] Searching for globals...
[17:39:51.917] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.917] Searching for globals ... DONE
[17:39:51.918] Resolving globals: TRUE
[17:39:51.918] Resolving any globals that are futures ...
[17:39:51.918] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.918] Resolving any globals that are futures ... DONE
[17:39:51.919] Resolving futures part of globals (recursively) ...
[17:39:51.919] resolve() on list ...
[17:39:51.919]  recursive: 99
[17:39:51.919]  length: 1
[17:39:51.919]  elements: ‘x’
[17:39:51.919]  length: 0 (resolved future 1)
[17:39:51.919] resolve() on list ... DONE
[17:39:51.920] - globals: [1] ‘x’
[17:39:51.920] Resolving futures part of globals (recursively) ... DONE
[17:39:51.920] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.920] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.921] - globals: [1] ‘x’
[17:39:51.921] 
[17:39:51.921] getGlobalsAndPackages() ... DONE
[17:39:51.921] run() for ‘Future’ ...
[17:39:51.921] - state: ‘created’
[17:39:51.921] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.925] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.926]   - Field: ‘label’
[17:39:51.926]   - Field: ‘local’
[17:39:51.926]   - Field: ‘owner’
[17:39:51.926]   - Field: ‘envir’
[17:39:51.926]   - Field: ‘workers’
[17:39:51.926]   - Field: ‘packages’
[17:39:51.926]   - Field: ‘gc’
[17:39:51.926]   - Field: ‘job’
[17:39:51.927]   - Field: ‘conditions’
[17:39:51.927]   - Field: ‘expr’
[17:39:51.927]   - Field: ‘uuid’
[17:39:51.927]   - Field: ‘seed’
[17:39:51.927]   - Field: ‘version’
[17:39:51.927]   - Field: ‘result’
[17:39:51.927]   - Field: ‘asynchronous’
[17:39:51.927]   - Field: ‘calls’
[17:39:51.927]   - Field: ‘globals’
[17:39:51.928]   - Field: ‘stdout’
[17:39:51.928]   - Field: ‘earlySignal’
[17:39:51.928]   - Field: ‘lazy’
[17:39:51.928]   - Field: ‘state’
[17:39:51.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.928] - Launch lazy future ...
[17:39:51.928] Packages needed by the future expression (n = 0): <none>
[17:39:51.929] Packages needed by future strategies (n = 0): <none>
[17:39:51.929] {
[17:39:51.929]     {
[17:39:51.929]         {
[17:39:51.929]             ...future.startTime <- base::Sys.time()
[17:39:51.929]             {
[17:39:51.929]                 {
[17:39:51.929]                   {
[17:39:51.929]                     {
[17:39:51.929]                       base::local({
[17:39:51.929]                         has_future <- base::requireNamespace("future", 
[17:39:51.929]                           quietly = TRUE)
[17:39:51.929]                         if (has_future) {
[17:39:51.929]                           ns <- base::getNamespace("future")
[17:39:51.929]                           version <- ns[[".package"]][["version"]]
[17:39:51.929]                           if (is.null(version)) 
[17:39:51.929]                             version <- utils::packageVersion("future")
[17:39:51.929]                         }
[17:39:51.929]                         else {
[17:39:51.929]                           version <- NULL
[17:39:51.929]                         }
[17:39:51.929]                         if (!has_future || version < "1.8.0") {
[17:39:51.929]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.929]                             "", base::R.version$version.string), 
[17:39:51.929]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.929]                               "release", "version")], collapse = " "), 
[17:39:51.929]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.929]                             info)
[17:39:51.929]                           info <- base::paste(info, collapse = "; ")
[17:39:51.929]                           if (!has_future) {
[17:39:51.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.929]                               info)
[17:39:51.929]                           }
[17:39:51.929]                           else {
[17:39:51.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.929]                               info, version)
[17:39:51.929]                           }
[17:39:51.929]                           base::stop(msg)
[17:39:51.929]                         }
[17:39:51.929]                       })
[17:39:51.929]                     }
[17:39:51.929]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.929]                     base::options(mc.cores = 1L)
[17:39:51.929]                   }
[17:39:51.929]                   ...future.strategy.old <- future::plan("list")
[17:39:51.929]                   options(future.plan = NULL)
[17:39:51.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.929]                 }
[17:39:51.929]                 ...future.workdir <- getwd()
[17:39:51.929]             }
[17:39:51.929]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.929]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.929]         }
[17:39:51.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.929]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.929]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.929]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.929]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.929]             base::names(...future.oldOptions))
[17:39:51.929]     }
[17:39:51.929]     if (FALSE) {
[17:39:51.929]     }
[17:39:51.929]     else {
[17:39:51.929]         if (TRUE) {
[17:39:51.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.929]                 open = "w")
[17:39:51.929]         }
[17:39:51.929]         else {
[17:39:51.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.929]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.929]         }
[17:39:51.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.929]             base::sink(type = "output", split = FALSE)
[17:39:51.929]             base::close(...future.stdout)
[17:39:51.929]         }, add = TRUE)
[17:39:51.929]     }
[17:39:51.929]     ...future.frame <- base::sys.nframe()
[17:39:51.929]     ...future.conditions <- base::list()
[17:39:51.929]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.929]     if (FALSE) {
[17:39:51.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.929]     }
[17:39:51.929]     ...future.result <- base::tryCatch({
[17:39:51.929]         base::withCallingHandlers({
[17:39:51.929]             ...future.value <- base::withVisible(base::local({
[17:39:51.929]                 withCallingHandlers({
[17:39:51.929]                   {
[17:39:51.929]                     x["a"] <- list(1)
[17:39:51.929]                     x
[17:39:51.929]                   }
[17:39:51.929]                 }, immediateCondition = function(cond) {
[17:39:51.929]                   save_rds <- function (object, pathname, ...) 
[17:39:51.929]                   {
[17:39:51.929]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.929]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.929]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.929]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.929]                         fi_tmp[["mtime"]])
[17:39:51.929]                     }
[17:39:51.929]                     tryCatch({
[17:39:51.929]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.929]                     }, error = function(ex) {
[17:39:51.929]                       msg <- conditionMessage(ex)
[17:39:51.929]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.929]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.929]                         fi_tmp[["mtime"]], msg)
[17:39:51.929]                       ex$message <- msg
[17:39:51.929]                       stop(ex)
[17:39:51.929]                     })
[17:39:51.929]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.929]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.929]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.929]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.929]                       fi <- file.info(pathname)
[17:39:51.929]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.929]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.929]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.929]                         fi[["size"]], fi[["mtime"]])
[17:39:51.929]                       stop(msg)
[17:39:51.929]                     }
[17:39:51.929]                     invisible(pathname)
[17:39:51.929]                   }
[17:39:51.929]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.929]                     rootPath = tempdir()) 
[17:39:51.929]                   {
[17:39:51.929]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.929]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.929]                       tmpdir = path, fileext = ".rds")
[17:39:51.929]                     save_rds(obj, file)
[17:39:51.929]                   }
[17:39:51.929]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.929]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.929]                   {
[17:39:51.929]                     inherits <- base::inherits
[17:39:51.929]                     invokeRestart <- base::invokeRestart
[17:39:51.929]                     is.null <- base::is.null
[17:39:51.929]                     muffled <- FALSE
[17:39:51.929]                     if (inherits(cond, "message")) {
[17:39:51.929]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.929]                       if (muffled) 
[17:39:51.929]                         invokeRestart("muffleMessage")
[17:39:51.929]                     }
[17:39:51.929]                     else if (inherits(cond, "warning")) {
[17:39:51.929]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.929]                       if (muffled) 
[17:39:51.929]                         invokeRestart("muffleWarning")
[17:39:51.929]                     }
[17:39:51.929]                     else if (inherits(cond, "condition")) {
[17:39:51.929]                       if (!is.null(pattern)) {
[17:39:51.929]                         computeRestarts <- base::computeRestarts
[17:39:51.929]                         grepl <- base::grepl
[17:39:51.929]                         restarts <- computeRestarts(cond)
[17:39:51.929]                         for (restart in restarts) {
[17:39:51.929]                           name <- restart$name
[17:39:51.929]                           if (is.null(name)) 
[17:39:51.929]                             next
[17:39:51.929]                           if (!grepl(pattern, name)) 
[17:39:51.929]                             next
[17:39:51.929]                           invokeRestart(restart)
[17:39:51.929]                           muffled <- TRUE
[17:39:51.929]                           break
[17:39:51.929]                         }
[17:39:51.929]                       }
[17:39:51.929]                     }
[17:39:51.929]                     invisible(muffled)
[17:39:51.929]                   }
[17:39:51.929]                   muffleCondition(cond)
[17:39:51.929]                 })
[17:39:51.929]             }))
[17:39:51.929]             future::FutureResult(value = ...future.value$value, 
[17:39:51.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.929]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.929]                     ...future.globalenv.names))
[17:39:51.929]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.929]         }, condition = base::local({
[17:39:51.929]             c <- base::c
[17:39:51.929]             inherits <- base::inherits
[17:39:51.929]             invokeRestart <- base::invokeRestart
[17:39:51.929]             length <- base::length
[17:39:51.929]             list <- base::list
[17:39:51.929]             seq.int <- base::seq.int
[17:39:51.929]             signalCondition <- base::signalCondition
[17:39:51.929]             sys.calls <- base::sys.calls
[17:39:51.929]             `[[` <- base::`[[`
[17:39:51.929]             `+` <- base::`+`
[17:39:51.929]             `<<-` <- base::`<<-`
[17:39:51.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.929]                   3L)]
[17:39:51.929]             }
[17:39:51.929]             function(cond) {
[17:39:51.929]                 is_error <- inherits(cond, "error")
[17:39:51.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.929]                   NULL)
[17:39:51.929]                 if (is_error) {
[17:39:51.929]                   sessionInformation <- function() {
[17:39:51.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.929]                       search = base::search(), system = base::Sys.info())
[17:39:51.929]                   }
[17:39:51.929]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.929]                     cond$call), session = sessionInformation(), 
[17:39:51.929]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.929]                   signalCondition(cond)
[17:39:51.929]                 }
[17:39:51.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.929]                 "immediateCondition"))) {
[17:39:51.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.929]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.929]                   if (TRUE && !signal) {
[17:39:51.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.929]                     {
[17:39:51.929]                       inherits <- base::inherits
[17:39:51.929]                       invokeRestart <- base::invokeRestart
[17:39:51.929]                       is.null <- base::is.null
[17:39:51.929]                       muffled <- FALSE
[17:39:51.929]                       if (inherits(cond, "message")) {
[17:39:51.929]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.929]                         if (muffled) 
[17:39:51.929]                           invokeRestart("muffleMessage")
[17:39:51.929]                       }
[17:39:51.929]                       else if (inherits(cond, "warning")) {
[17:39:51.929]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.929]                         if (muffled) 
[17:39:51.929]                           invokeRestart("muffleWarning")
[17:39:51.929]                       }
[17:39:51.929]                       else if (inherits(cond, "condition")) {
[17:39:51.929]                         if (!is.null(pattern)) {
[17:39:51.929]                           computeRestarts <- base::computeRestarts
[17:39:51.929]                           grepl <- base::grepl
[17:39:51.929]                           restarts <- computeRestarts(cond)
[17:39:51.929]                           for (restart in restarts) {
[17:39:51.929]                             name <- restart$name
[17:39:51.929]                             if (is.null(name)) 
[17:39:51.929]                               next
[17:39:51.929]                             if (!grepl(pattern, name)) 
[17:39:51.929]                               next
[17:39:51.929]                             invokeRestart(restart)
[17:39:51.929]                             muffled <- TRUE
[17:39:51.929]                             break
[17:39:51.929]                           }
[17:39:51.929]                         }
[17:39:51.929]                       }
[17:39:51.929]                       invisible(muffled)
[17:39:51.929]                     }
[17:39:51.929]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.929]                   }
[17:39:51.929]                 }
[17:39:51.929]                 else {
[17:39:51.929]                   if (TRUE) {
[17:39:51.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.929]                     {
[17:39:51.929]                       inherits <- base::inherits
[17:39:51.929]                       invokeRestart <- base::invokeRestart
[17:39:51.929]                       is.null <- base::is.null
[17:39:51.929]                       muffled <- FALSE
[17:39:51.929]                       if (inherits(cond, "message")) {
[17:39:51.929]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.929]                         if (muffled) 
[17:39:51.929]                           invokeRestart("muffleMessage")
[17:39:51.929]                       }
[17:39:51.929]                       else if (inherits(cond, "warning")) {
[17:39:51.929]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.929]                         if (muffled) 
[17:39:51.929]                           invokeRestart("muffleWarning")
[17:39:51.929]                       }
[17:39:51.929]                       else if (inherits(cond, "condition")) {
[17:39:51.929]                         if (!is.null(pattern)) {
[17:39:51.929]                           computeRestarts <- base::computeRestarts
[17:39:51.929]                           grepl <- base::grepl
[17:39:51.929]                           restarts <- computeRestarts(cond)
[17:39:51.929]                           for (restart in restarts) {
[17:39:51.929]                             name <- restart$name
[17:39:51.929]                             if (is.null(name)) 
[17:39:51.929]                               next
[17:39:51.929]                             if (!grepl(pattern, name)) 
[17:39:51.929]                               next
[17:39:51.929]                             invokeRestart(restart)
[17:39:51.929]                             muffled <- TRUE
[17:39:51.929]                             break
[17:39:51.929]                           }
[17:39:51.929]                         }
[17:39:51.929]                       }
[17:39:51.929]                       invisible(muffled)
[17:39:51.929]                     }
[17:39:51.929]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.929]                   }
[17:39:51.929]                 }
[17:39:51.929]             }
[17:39:51.929]         }))
[17:39:51.929]     }, error = function(ex) {
[17:39:51.929]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.929]                 ...future.rng), started = ...future.startTime, 
[17:39:51.929]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.929]             version = "1.8"), class = "FutureResult")
[17:39:51.929]     }, finally = {
[17:39:51.929]         if (!identical(...future.workdir, getwd())) 
[17:39:51.929]             setwd(...future.workdir)
[17:39:51.929]         {
[17:39:51.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.929]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.929]             }
[17:39:51.929]             base::options(...future.oldOptions)
[17:39:51.929]             if (.Platform$OS.type == "windows") {
[17:39:51.929]                 old_names <- names(...future.oldEnvVars)
[17:39:51.929]                 envs <- base::Sys.getenv()
[17:39:51.929]                 names <- names(envs)
[17:39:51.929]                 common <- intersect(names, old_names)
[17:39:51.929]                 added <- setdiff(names, old_names)
[17:39:51.929]                 removed <- setdiff(old_names, names)
[17:39:51.929]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.929]                   envs[common]]
[17:39:51.929]                 NAMES <- toupper(changed)
[17:39:51.929]                 args <- list()
[17:39:51.929]                 for (kk in seq_along(NAMES)) {
[17:39:51.929]                   name <- changed[[kk]]
[17:39:51.929]                   NAME <- NAMES[[kk]]
[17:39:51.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.929]                     next
[17:39:51.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.929]                 }
[17:39:51.929]                 NAMES <- toupper(added)
[17:39:51.929]                 for (kk in seq_along(NAMES)) {
[17:39:51.929]                   name <- added[[kk]]
[17:39:51.929]                   NAME <- NAMES[[kk]]
[17:39:51.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.929]                     next
[17:39:51.929]                   args[[name]] <- ""
[17:39:51.929]                 }
[17:39:51.929]                 NAMES <- toupper(removed)
[17:39:51.929]                 for (kk in seq_along(NAMES)) {
[17:39:51.929]                   name <- removed[[kk]]
[17:39:51.929]                   NAME <- NAMES[[kk]]
[17:39:51.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.929]                     next
[17:39:51.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.929]                 }
[17:39:51.929]                 if (length(args) > 0) 
[17:39:51.929]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.929]             }
[17:39:51.929]             else {
[17:39:51.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.929]             }
[17:39:51.929]             {
[17:39:51.929]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.929]                   0L) {
[17:39:51.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.929]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.929]                   base::options(opts)
[17:39:51.929]                 }
[17:39:51.929]                 {
[17:39:51.929]                   {
[17:39:51.929]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.929]                     NULL
[17:39:51.929]                   }
[17:39:51.929]                   options(future.plan = NULL)
[17:39:51.929]                   if (is.na(NA_character_)) 
[17:39:51.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.929]                     .init = FALSE)
[17:39:51.929]                 }
[17:39:51.929]             }
[17:39:51.929]         }
[17:39:51.929]     })
[17:39:51.929]     if (TRUE) {
[17:39:51.929]         base::sink(type = "output", split = FALSE)
[17:39:51.929]         if (TRUE) {
[17:39:51.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.929]         }
[17:39:51.929]         else {
[17:39:51.929]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.929]         }
[17:39:51.929]         base::close(...future.stdout)
[17:39:51.929]         ...future.stdout <- NULL
[17:39:51.929]     }
[17:39:51.929]     ...future.result$conditions <- ...future.conditions
[17:39:51.929]     ...future.result$finished <- base::Sys.time()
[17:39:51.929]     ...future.result
[17:39:51.929] }
[17:39:51.931] assign_globals() ...
[17:39:51.931] List of 1
[17:39:51.931]  $ x: list()
[17:39:51.931]  - attr(*, "where")=List of 1
[17:39:51.931]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.931]  - attr(*, "resolved")= logi TRUE
[17:39:51.931]  - attr(*, "total_size")= num 0
[17:39:51.931]  - attr(*, "already-done")= logi TRUE
[17:39:51.934] - copied ‘x’ to environment
[17:39:51.934] assign_globals() ... done
[17:39:51.935] requestCore(): workers = 2
[17:39:51.936] MulticoreFuture started
[17:39:51.937] - Launch lazy future ... done
[17:39:51.937] run() for ‘MulticoreFuture’ ... done
[17:39:51.937] result() for MulticoreFuture ...
[17:39:51.937] plan(): Setting new future strategy stack:
[17:39:51.938] List of future strategies:
[17:39:51.938] 1. sequential:
[17:39:51.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.938]    - tweaked: FALSE
[17:39:51.938]    - call: NULL
[17:39:51.939] plan(): nbrOfWorkers() = 1
[17:39:51.941] plan(): Setting new future strategy stack:
[17:39:51.941] List of future strategies:
[17:39:51.941] 1. multicore:
[17:39:51.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.941]    - tweaked: FALSE
[17:39:51.941]    - call: plan(strategy)
[17:39:51.946] plan(): nbrOfWorkers() = 2
[17:39:51.946] result() for MulticoreFuture ...
[17:39:51.946] result() for MulticoreFuture ... done
[17:39:51.947] result() for MulticoreFuture ... done
[17:39:51.947] result() for MulticoreFuture ...
[17:39:51.947] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.948] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.948] Searching for globals...
[17:39:51.950] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.951] Searching for globals ... DONE
[17:39:51.951] Resolving globals: TRUE
[17:39:51.951] Resolving any globals that are futures ...
[17:39:51.951] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:51.951] Resolving any globals that are futures ... DONE
[17:39:51.952] Resolving futures part of globals (recursively) ...
[17:39:51.952] resolve() on list ...
[17:39:51.952]  recursive: 99
[17:39:51.952]  length: 1
[17:39:51.952]  elements: ‘x’
[17:39:51.952]  length: 0 (resolved future 1)
[17:39:51.953] resolve() on list ... DONE
[17:39:51.953] - globals: [1] ‘x’
[17:39:51.953] Resolving futures part of globals (recursively) ... DONE
[17:39:51.953] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:51.953] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:51.954] - globals: [1] ‘x’
[17:39:51.954] 
[17:39:51.954] getGlobalsAndPackages() ... DONE
[17:39:51.954] run() for ‘Future’ ...
[17:39:51.954] - state: ‘created’
[17:39:51.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.958] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.959]   - Field: ‘label’
[17:39:51.959]   - Field: ‘local’
[17:39:51.959]   - Field: ‘owner’
[17:39:51.959]   - Field: ‘envir’
[17:39:51.959]   - Field: ‘workers’
[17:39:51.959]   - Field: ‘packages’
[17:39:51.959]   - Field: ‘gc’
[17:39:51.959]   - Field: ‘job’
[17:39:51.960]   - Field: ‘conditions’
[17:39:51.960]   - Field: ‘expr’
[17:39:51.960]   - Field: ‘uuid’
[17:39:51.960]   - Field: ‘seed’
[17:39:51.960]   - Field: ‘version’
[17:39:51.960]   - Field: ‘result’
[17:39:51.960]   - Field: ‘asynchronous’
[17:39:51.960]   - Field: ‘calls’
[17:39:51.960]   - Field: ‘globals’
[17:39:51.961]   - Field: ‘stdout’
[17:39:51.961]   - Field: ‘earlySignal’
[17:39:51.961]   - Field: ‘lazy’
[17:39:51.961]   - Field: ‘state’
[17:39:51.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.961] - Launch lazy future ...
[17:39:51.961] Packages needed by the future expression (n = 0): <none>
[17:39:51.961] Packages needed by future strategies (n = 0): <none>
[17:39:51.962] {
[17:39:51.962]     {
[17:39:51.962]         {
[17:39:51.962]             ...future.startTime <- base::Sys.time()
[17:39:51.962]             {
[17:39:51.962]                 {
[17:39:51.962]                   {
[17:39:51.962]                     {
[17:39:51.962]                       base::local({
[17:39:51.962]                         has_future <- base::requireNamespace("future", 
[17:39:51.962]                           quietly = TRUE)
[17:39:51.962]                         if (has_future) {
[17:39:51.962]                           ns <- base::getNamespace("future")
[17:39:51.962]                           version <- ns[[".package"]][["version"]]
[17:39:51.962]                           if (is.null(version)) 
[17:39:51.962]                             version <- utils::packageVersion("future")
[17:39:51.962]                         }
[17:39:51.962]                         else {
[17:39:51.962]                           version <- NULL
[17:39:51.962]                         }
[17:39:51.962]                         if (!has_future || version < "1.8.0") {
[17:39:51.962]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.962]                             "", base::R.version$version.string), 
[17:39:51.962]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.962]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.962]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.962]                               "release", "version")], collapse = " "), 
[17:39:51.962]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.962]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.962]                             info)
[17:39:51.962]                           info <- base::paste(info, collapse = "; ")
[17:39:51.962]                           if (!has_future) {
[17:39:51.962]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.962]                               info)
[17:39:51.962]                           }
[17:39:51.962]                           else {
[17:39:51.962]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.962]                               info, version)
[17:39:51.962]                           }
[17:39:51.962]                           base::stop(msg)
[17:39:51.962]                         }
[17:39:51.962]                       })
[17:39:51.962]                     }
[17:39:51.962]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.962]                     base::options(mc.cores = 1L)
[17:39:51.962]                   }
[17:39:51.962]                   ...future.strategy.old <- future::plan("list")
[17:39:51.962]                   options(future.plan = NULL)
[17:39:51.962]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.962]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.962]                 }
[17:39:51.962]                 ...future.workdir <- getwd()
[17:39:51.962]             }
[17:39:51.962]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.962]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.962]         }
[17:39:51.962]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.962]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.962]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.962]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.962]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.962]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.962]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.962]             base::names(...future.oldOptions))
[17:39:51.962]     }
[17:39:51.962]     if (FALSE) {
[17:39:51.962]     }
[17:39:51.962]     else {
[17:39:51.962]         if (TRUE) {
[17:39:51.962]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.962]                 open = "w")
[17:39:51.962]         }
[17:39:51.962]         else {
[17:39:51.962]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.962]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.962]         }
[17:39:51.962]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.962]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.962]             base::sink(type = "output", split = FALSE)
[17:39:51.962]             base::close(...future.stdout)
[17:39:51.962]         }, add = TRUE)
[17:39:51.962]     }
[17:39:51.962]     ...future.frame <- base::sys.nframe()
[17:39:51.962]     ...future.conditions <- base::list()
[17:39:51.962]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.962]     if (FALSE) {
[17:39:51.962]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.962]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.962]     }
[17:39:51.962]     ...future.result <- base::tryCatch({
[17:39:51.962]         base::withCallingHandlers({
[17:39:51.962]             ...future.value <- base::withVisible(base::local({
[17:39:51.962]                 withCallingHandlers({
[17:39:51.962]                   {
[17:39:51.962]                     x["a"] <- list(1)
[17:39:51.962]                     x
[17:39:51.962]                   }
[17:39:51.962]                 }, immediateCondition = function(cond) {
[17:39:51.962]                   save_rds <- function (object, pathname, ...) 
[17:39:51.962]                   {
[17:39:51.962]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.962]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.962]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.962]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.962]                         fi_tmp[["mtime"]])
[17:39:51.962]                     }
[17:39:51.962]                     tryCatch({
[17:39:51.962]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.962]                     }, error = function(ex) {
[17:39:51.962]                       msg <- conditionMessage(ex)
[17:39:51.962]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.962]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.962]                         fi_tmp[["mtime"]], msg)
[17:39:51.962]                       ex$message <- msg
[17:39:51.962]                       stop(ex)
[17:39:51.962]                     })
[17:39:51.962]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.962]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.962]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.962]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.962]                       fi <- file.info(pathname)
[17:39:51.962]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.962]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.962]                         fi[["size"]], fi[["mtime"]])
[17:39:51.962]                       stop(msg)
[17:39:51.962]                     }
[17:39:51.962]                     invisible(pathname)
[17:39:51.962]                   }
[17:39:51.962]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.962]                     rootPath = tempdir()) 
[17:39:51.962]                   {
[17:39:51.962]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.962]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.962]                       tmpdir = path, fileext = ".rds")
[17:39:51.962]                     save_rds(obj, file)
[17:39:51.962]                   }
[17:39:51.962]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.962]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.962]                   {
[17:39:51.962]                     inherits <- base::inherits
[17:39:51.962]                     invokeRestart <- base::invokeRestart
[17:39:51.962]                     is.null <- base::is.null
[17:39:51.962]                     muffled <- FALSE
[17:39:51.962]                     if (inherits(cond, "message")) {
[17:39:51.962]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.962]                       if (muffled) 
[17:39:51.962]                         invokeRestart("muffleMessage")
[17:39:51.962]                     }
[17:39:51.962]                     else if (inherits(cond, "warning")) {
[17:39:51.962]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.962]                       if (muffled) 
[17:39:51.962]                         invokeRestart("muffleWarning")
[17:39:51.962]                     }
[17:39:51.962]                     else if (inherits(cond, "condition")) {
[17:39:51.962]                       if (!is.null(pattern)) {
[17:39:51.962]                         computeRestarts <- base::computeRestarts
[17:39:51.962]                         grepl <- base::grepl
[17:39:51.962]                         restarts <- computeRestarts(cond)
[17:39:51.962]                         for (restart in restarts) {
[17:39:51.962]                           name <- restart$name
[17:39:51.962]                           if (is.null(name)) 
[17:39:51.962]                             next
[17:39:51.962]                           if (!grepl(pattern, name)) 
[17:39:51.962]                             next
[17:39:51.962]                           invokeRestart(restart)
[17:39:51.962]                           muffled <- TRUE
[17:39:51.962]                           break
[17:39:51.962]                         }
[17:39:51.962]                       }
[17:39:51.962]                     }
[17:39:51.962]                     invisible(muffled)
[17:39:51.962]                   }
[17:39:51.962]                   muffleCondition(cond)
[17:39:51.962]                 })
[17:39:51.962]             }))
[17:39:51.962]             future::FutureResult(value = ...future.value$value, 
[17:39:51.962]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.962]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.962]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.962]                     ...future.globalenv.names))
[17:39:51.962]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.962]         }, condition = base::local({
[17:39:51.962]             c <- base::c
[17:39:51.962]             inherits <- base::inherits
[17:39:51.962]             invokeRestart <- base::invokeRestart
[17:39:51.962]             length <- base::length
[17:39:51.962]             list <- base::list
[17:39:51.962]             seq.int <- base::seq.int
[17:39:51.962]             signalCondition <- base::signalCondition
[17:39:51.962]             sys.calls <- base::sys.calls
[17:39:51.962]             `[[` <- base::`[[`
[17:39:51.962]             `+` <- base::`+`
[17:39:51.962]             `<<-` <- base::`<<-`
[17:39:51.962]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.962]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.962]                   3L)]
[17:39:51.962]             }
[17:39:51.962]             function(cond) {
[17:39:51.962]                 is_error <- inherits(cond, "error")
[17:39:51.962]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.962]                   NULL)
[17:39:51.962]                 if (is_error) {
[17:39:51.962]                   sessionInformation <- function() {
[17:39:51.962]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.962]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.962]                       search = base::search(), system = base::Sys.info())
[17:39:51.962]                   }
[17:39:51.962]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.962]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.962]                     cond$call), session = sessionInformation(), 
[17:39:51.962]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.962]                   signalCondition(cond)
[17:39:51.962]                 }
[17:39:51.962]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.962]                 "immediateCondition"))) {
[17:39:51.962]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.962]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.962]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.962]                   if (TRUE && !signal) {
[17:39:51.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.962]                     {
[17:39:51.962]                       inherits <- base::inherits
[17:39:51.962]                       invokeRestart <- base::invokeRestart
[17:39:51.962]                       is.null <- base::is.null
[17:39:51.962]                       muffled <- FALSE
[17:39:51.962]                       if (inherits(cond, "message")) {
[17:39:51.962]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.962]                         if (muffled) 
[17:39:51.962]                           invokeRestart("muffleMessage")
[17:39:51.962]                       }
[17:39:51.962]                       else if (inherits(cond, "warning")) {
[17:39:51.962]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.962]                         if (muffled) 
[17:39:51.962]                           invokeRestart("muffleWarning")
[17:39:51.962]                       }
[17:39:51.962]                       else if (inherits(cond, "condition")) {
[17:39:51.962]                         if (!is.null(pattern)) {
[17:39:51.962]                           computeRestarts <- base::computeRestarts
[17:39:51.962]                           grepl <- base::grepl
[17:39:51.962]                           restarts <- computeRestarts(cond)
[17:39:51.962]                           for (restart in restarts) {
[17:39:51.962]                             name <- restart$name
[17:39:51.962]                             if (is.null(name)) 
[17:39:51.962]                               next
[17:39:51.962]                             if (!grepl(pattern, name)) 
[17:39:51.962]                               next
[17:39:51.962]                             invokeRestart(restart)
[17:39:51.962]                             muffled <- TRUE
[17:39:51.962]                             break
[17:39:51.962]                           }
[17:39:51.962]                         }
[17:39:51.962]                       }
[17:39:51.962]                       invisible(muffled)
[17:39:51.962]                     }
[17:39:51.962]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.962]                   }
[17:39:51.962]                 }
[17:39:51.962]                 else {
[17:39:51.962]                   if (TRUE) {
[17:39:51.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.962]                     {
[17:39:51.962]                       inherits <- base::inherits
[17:39:51.962]                       invokeRestart <- base::invokeRestart
[17:39:51.962]                       is.null <- base::is.null
[17:39:51.962]                       muffled <- FALSE
[17:39:51.962]                       if (inherits(cond, "message")) {
[17:39:51.962]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.962]                         if (muffled) 
[17:39:51.962]                           invokeRestart("muffleMessage")
[17:39:51.962]                       }
[17:39:51.962]                       else if (inherits(cond, "warning")) {
[17:39:51.962]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.962]                         if (muffled) 
[17:39:51.962]                           invokeRestart("muffleWarning")
[17:39:51.962]                       }
[17:39:51.962]                       else if (inherits(cond, "condition")) {
[17:39:51.962]                         if (!is.null(pattern)) {
[17:39:51.962]                           computeRestarts <- base::computeRestarts
[17:39:51.962]                           grepl <- base::grepl
[17:39:51.962]                           restarts <- computeRestarts(cond)
[17:39:51.962]                           for (restart in restarts) {
[17:39:51.962]                             name <- restart$name
[17:39:51.962]                             if (is.null(name)) 
[17:39:51.962]                               next
[17:39:51.962]                             if (!grepl(pattern, name)) 
[17:39:51.962]                               next
[17:39:51.962]                             invokeRestart(restart)
[17:39:51.962]                             muffled <- TRUE
[17:39:51.962]                             break
[17:39:51.962]                           }
[17:39:51.962]                         }
[17:39:51.962]                       }
[17:39:51.962]                       invisible(muffled)
[17:39:51.962]                     }
[17:39:51.962]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.962]                   }
[17:39:51.962]                 }
[17:39:51.962]             }
[17:39:51.962]         }))
[17:39:51.962]     }, error = function(ex) {
[17:39:51.962]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.962]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.962]                 ...future.rng), started = ...future.startTime, 
[17:39:51.962]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.962]             version = "1.8"), class = "FutureResult")
[17:39:51.962]     }, finally = {
[17:39:51.962]         if (!identical(...future.workdir, getwd())) 
[17:39:51.962]             setwd(...future.workdir)
[17:39:51.962]         {
[17:39:51.962]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.962]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.962]             }
[17:39:51.962]             base::options(...future.oldOptions)
[17:39:51.962]             if (.Platform$OS.type == "windows") {
[17:39:51.962]                 old_names <- names(...future.oldEnvVars)
[17:39:51.962]                 envs <- base::Sys.getenv()
[17:39:51.962]                 names <- names(envs)
[17:39:51.962]                 common <- intersect(names, old_names)
[17:39:51.962]                 added <- setdiff(names, old_names)
[17:39:51.962]                 removed <- setdiff(old_names, names)
[17:39:51.962]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.962]                   envs[common]]
[17:39:51.962]                 NAMES <- toupper(changed)
[17:39:51.962]                 args <- list()
[17:39:51.962]                 for (kk in seq_along(NAMES)) {
[17:39:51.962]                   name <- changed[[kk]]
[17:39:51.962]                   NAME <- NAMES[[kk]]
[17:39:51.962]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.962]                     next
[17:39:51.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.962]                 }
[17:39:51.962]                 NAMES <- toupper(added)
[17:39:51.962]                 for (kk in seq_along(NAMES)) {
[17:39:51.962]                   name <- added[[kk]]
[17:39:51.962]                   NAME <- NAMES[[kk]]
[17:39:51.962]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.962]                     next
[17:39:51.962]                   args[[name]] <- ""
[17:39:51.962]                 }
[17:39:51.962]                 NAMES <- toupper(removed)
[17:39:51.962]                 for (kk in seq_along(NAMES)) {
[17:39:51.962]                   name <- removed[[kk]]
[17:39:51.962]                   NAME <- NAMES[[kk]]
[17:39:51.962]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.962]                     next
[17:39:51.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.962]                 }
[17:39:51.962]                 if (length(args) > 0) 
[17:39:51.962]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.962]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.962]             }
[17:39:51.962]             else {
[17:39:51.962]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.962]             }
[17:39:51.962]             {
[17:39:51.962]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.962]                   0L) {
[17:39:51.962]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.962]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.962]                   base::options(opts)
[17:39:51.962]                 }
[17:39:51.962]                 {
[17:39:51.962]                   {
[17:39:51.962]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.962]                     NULL
[17:39:51.962]                   }
[17:39:51.962]                   options(future.plan = NULL)
[17:39:51.962]                   if (is.na(NA_character_)) 
[17:39:51.962]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.962]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.962]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.962]                     .init = FALSE)
[17:39:51.962]                 }
[17:39:51.962]             }
[17:39:51.962]         }
[17:39:51.962]     })
[17:39:51.962]     if (TRUE) {
[17:39:51.962]         base::sink(type = "output", split = FALSE)
[17:39:51.962]         if (TRUE) {
[17:39:51.962]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.962]         }
[17:39:51.962]         else {
[17:39:51.962]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.962]         }
[17:39:51.962]         base::close(...future.stdout)
[17:39:51.962]         ...future.stdout <- NULL
[17:39:51.962]     }
[17:39:51.962]     ...future.result$conditions <- ...future.conditions
[17:39:51.962]     ...future.result$finished <- base::Sys.time()
[17:39:51.962]     ...future.result
[17:39:51.962] }
[17:39:51.965] assign_globals() ...
[17:39:51.965] List of 1
[17:39:51.965]  $ x: list()
[17:39:51.965]  - attr(*, "where")=List of 1
[17:39:51.965]   ..$ x:<environment: R_EmptyEnv> 
[17:39:51.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:51.965]  - attr(*, "resolved")= logi TRUE
[17:39:51.965]  - attr(*, "total_size")= num 0
[17:39:51.965]  - attr(*, "already-done")= logi TRUE
[17:39:51.970] - copied ‘x’ to environment
[17:39:51.970] assign_globals() ... done
[17:39:51.970] requestCore(): workers = 2
[17:39:51.972] MulticoreFuture started
[17:39:51.972] - Launch lazy future ... done
[17:39:51.973] run() for ‘MulticoreFuture’ ... done
[17:39:51.973] result() for MulticoreFuture ...
[17:39:51.973] plan(): Setting new future strategy stack:
[17:39:51.973] List of future strategies:
[17:39:51.973] 1. sequential:
[17:39:51.973]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:51.973]    - tweaked: FALSE
[17:39:51.973]    - call: NULL
[17:39:51.974] plan(): nbrOfWorkers() = 1
[17:39:51.976] plan(): Setting new future strategy stack:
[17:39:51.976] List of future strategies:
[17:39:51.976] 1. multicore:
[17:39:51.976]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:51.976]    - tweaked: FALSE
[17:39:51.976]    - call: plan(strategy)
[17:39:51.981] plan(): nbrOfWorkers() = 2
[17:39:51.982] result() for MulticoreFuture ...
[17:39:51.982] result() for MulticoreFuture ... done
[17:39:51.982] result() for MulticoreFuture ... done
[17:39:51.983] result() for MulticoreFuture ...
[17:39:51.983] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:51.983] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:51.984] Searching for globals...
[17:39:51.987] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:39:51.987] Searching for globals ... DONE
[17:39:51.987] Resolving globals: TRUE
[17:39:51.987] Resolving any globals that are futures ...
[17:39:51.987] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:39:51.987] Resolving any globals that are futures ... DONE
[17:39:51.988] Resolving futures part of globals (recursively) ...
[17:39:51.988] resolve() on list ...
[17:39:51.988]  recursive: 99
[17:39:51.988]  length: 2
[17:39:51.988]  elements: ‘x’, ‘name’
[17:39:51.989]  length: 1 (resolved future 1)
[17:39:51.989]  length: 0 (resolved future 2)
[17:39:51.989] resolve() on list ... DONE
[17:39:51.989] - globals: [2] ‘x’, ‘name’
[17:39:51.989] Resolving futures part of globals (recursively) ... DONE
[17:39:51.989] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:51.990] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:39:51.990] - globals: [2] ‘x’, ‘name’
[17:39:51.990] 
[17:39:51.990] getGlobalsAndPackages() ... DONE
[17:39:51.990] run() for ‘Future’ ...
[17:39:51.991] - state: ‘created’
[17:39:51.991] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:51.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:51.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:51.995]   - Field: ‘label’
[17:39:51.995]   - Field: ‘local’
[17:39:51.995]   - Field: ‘owner’
[17:39:51.995]   - Field: ‘envir’
[17:39:51.995]   - Field: ‘workers’
[17:39:51.995]   - Field: ‘packages’
[17:39:51.996]   - Field: ‘gc’
[17:39:51.996]   - Field: ‘job’
[17:39:51.996]   - Field: ‘conditions’
[17:39:51.996]   - Field: ‘expr’
[17:39:51.996]   - Field: ‘uuid’
[17:39:51.996]   - Field: ‘seed’
[17:39:51.996]   - Field: ‘version’
[17:39:51.996]   - Field: ‘result’
[17:39:51.997]   - Field: ‘asynchronous’
[17:39:51.997]   - Field: ‘calls’
[17:39:51.997]   - Field: ‘globals’
[17:39:51.997]   - Field: ‘stdout’
[17:39:51.997]   - Field: ‘earlySignal’
[17:39:51.997]   - Field: ‘lazy’
[17:39:51.997]   - Field: ‘state’
[17:39:51.997] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:51.997] - Launch lazy future ...
[17:39:51.998] Packages needed by the future expression (n = 0): <none>
[17:39:51.998] Packages needed by future strategies (n = 0): <none>
[17:39:51.998] {
[17:39:51.998]     {
[17:39:51.998]         {
[17:39:51.998]             ...future.startTime <- base::Sys.time()
[17:39:51.998]             {
[17:39:51.998]                 {
[17:39:51.998]                   {
[17:39:51.998]                     {
[17:39:51.998]                       base::local({
[17:39:51.998]                         has_future <- base::requireNamespace("future", 
[17:39:51.998]                           quietly = TRUE)
[17:39:51.998]                         if (has_future) {
[17:39:51.998]                           ns <- base::getNamespace("future")
[17:39:51.998]                           version <- ns[[".package"]][["version"]]
[17:39:51.998]                           if (is.null(version)) 
[17:39:51.998]                             version <- utils::packageVersion("future")
[17:39:51.998]                         }
[17:39:51.998]                         else {
[17:39:51.998]                           version <- NULL
[17:39:51.998]                         }
[17:39:51.998]                         if (!has_future || version < "1.8.0") {
[17:39:51.998]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:51.998]                             "", base::R.version$version.string), 
[17:39:51.998]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:51.998]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:51.998]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:51.998]                               "release", "version")], collapse = " "), 
[17:39:51.998]                             hostname = base::Sys.info()[["nodename"]])
[17:39:51.998]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:51.998]                             info)
[17:39:51.998]                           info <- base::paste(info, collapse = "; ")
[17:39:51.998]                           if (!has_future) {
[17:39:51.998]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:51.998]                               info)
[17:39:51.998]                           }
[17:39:51.998]                           else {
[17:39:51.998]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:51.998]                               info, version)
[17:39:51.998]                           }
[17:39:51.998]                           base::stop(msg)
[17:39:51.998]                         }
[17:39:51.998]                       })
[17:39:51.998]                     }
[17:39:51.998]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:51.998]                     base::options(mc.cores = 1L)
[17:39:51.998]                   }
[17:39:51.998]                   ...future.strategy.old <- future::plan("list")
[17:39:51.998]                   options(future.plan = NULL)
[17:39:51.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:51.998]                 }
[17:39:51.998]                 ...future.workdir <- getwd()
[17:39:51.998]             }
[17:39:51.998]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:51.998]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:51.998]         }
[17:39:51.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:51.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:51.998]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:51.998]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:51.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:51.998]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:51.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:51.998]             base::names(...future.oldOptions))
[17:39:51.998]     }
[17:39:51.998]     if (FALSE) {
[17:39:51.998]     }
[17:39:51.998]     else {
[17:39:51.998]         if (TRUE) {
[17:39:51.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:51.998]                 open = "w")
[17:39:51.998]         }
[17:39:51.998]         else {
[17:39:51.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:51.998]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:51.998]         }
[17:39:51.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:51.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:51.998]             base::sink(type = "output", split = FALSE)
[17:39:51.998]             base::close(...future.stdout)
[17:39:51.998]         }, add = TRUE)
[17:39:51.998]     }
[17:39:51.998]     ...future.frame <- base::sys.nframe()
[17:39:51.998]     ...future.conditions <- base::list()
[17:39:51.998]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:51.998]     if (FALSE) {
[17:39:51.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:51.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:51.998]     }
[17:39:51.998]     ...future.result <- base::tryCatch({
[17:39:51.998]         base::withCallingHandlers({
[17:39:51.998]             ...future.value <- base::withVisible(base::local({
[17:39:51.998]                 withCallingHandlers({
[17:39:51.998]                   {
[17:39:51.998]                     x[name] <- list(1)
[17:39:51.998]                     x
[17:39:51.998]                   }
[17:39:51.998]                 }, immediateCondition = function(cond) {
[17:39:51.998]                   save_rds <- function (object, pathname, ...) 
[17:39:51.998]                   {
[17:39:51.998]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:51.998]                     if (file_test("-f", pathname_tmp)) {
[17:39:51.998]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.998]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:51.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.998]                         fi_tmp[["mtime"]])
[17:39:51.998]                     }
[17:39:51.998]                     tryCatch({
[17:39:51.998]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:51.998]                     }, error = function(ex) {
[17:39:51.998]                       msg <- conditionMessage(ex)
[17:39:51.998]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.998]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:51.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.998]                         fi_tmp[["mtime"]], msg)
[17:39:51.998]                       ex$message <- msg
[17:39:51.998]                       stop(ex)
[17:39:51.998]                     })
[17:39:51.998]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:51.998]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:51.998]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:51.998]                       fi_tmp <- file.info(pathname_tmp)
[17:39:51.998]                       fi <- file.info(pathname)
[17:39:51.998]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:51.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:51.998]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:51.998]                         fi[["size"]], fi[["mtime"]])
[17:39:51.998]                       stop(msg)
[17:39:51.998]                     }
[17:39:51.998]                     invisible(pathname)
[17:39:51.998]                   }
[17:39:51.998]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:51.998]                     rootPath = tempdir()) 
[17:39:51.998]                   {
[17:39:51.998]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:51.998]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:51.998]                       tmpdir = path, fileext = ".rds")
[17:39:51.998]                     save_rds(obj, file)
[17:39:51.998]                   }
[17:39:51.998]                   saveImmediateCondition(cond, path = "/tmp/RtmpK1DN2C/.future/immediateConditions")
[17:39:51.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.998]                   {
[17:39:51.998]                     inherits <- base::inherits
[17:39:51.998]                     invokeRestart <- base::invokeRestart
[17:39:51.998]                     is.null <- base::is.null
[17:39:51.998]                     muffled <- FALSE
[17:39:51.998]                     if (inherits(cond, "message")) {
[17:39:51.998]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:51.998]                       if (muffled) 
[17:39:51.998]                         invokeRestart("muffleMessage")
[17:39:51.998]                     }
[17:39:51.998]                     else if (inherits(cond, "warning")) {
[17:39:51.998]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:51.998]                       if (muffled) 
[17:39:51.998]                         invokeRestart("muffleWarning")
[17:39:51.998]                     }
[17:39:51.998]                     else if (inherits(cond, "condition")) {
[17:39:51.998]                       if (!is.null(pattern)) {
[17:39:51.998]                         computeRestarts <- base::computeRestarts
[17:39:51.998]                         grepl <- base::grepl
[17:39:51.998]                         restarts <- computeRestarts(cond)
[17:39:51.998]                         for (restart in restarts) {
[17:39:51.998]                           name <- restart$name
[17:39:51.998]                           if (is.null(name)) 
[17:39:51.998]                             next
[17:39:51.998]                           if (!grepl(pattern, name)) 
[17:39:51.998]                             next
[17:39:51.998]                           invokeRestart(restart)
[17:39:51.998]                           muffled <- TRUE
[17:39:51.998]                           break
[17:39:51.998]                         }
[17:39:51.998]                       }
[17:39:51.998]                     }
[17:39:51.998]                     invisible(muffled)
[17:39:51.998]                   }
[17:39:51.998]                   muffleCondition(cond)
[17:39:51.998]                 })
[17:39:51.998]             }))
[17:39:51.998]             future::FutureResult(value = ...future.value$value, 
[17:39:51.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.998]                   ...future.rng), globalenv = if (FALSE) 
[17:39:51.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:51.998]                     ...future.globalenv.names))
[17:39:51.998]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:51.998]         }, condition = base::local({
[17:39:51.998]             c <- base::c
[17:39:51.998]             inherits <- base::inherits
[17:39:51.998]             invokeRestart <- base::invokeRestart
[17:39:51.998]             length <- base::length
[17:39:51.998]             list <- base::list
[17:39:51.998]             seq.int <- base::seq.int
[17:39:51.998]             signalCondition <- base::signalCondition
[17:39:51.998]             sys.calls <- base::sys.calls
[17:39:51.998]             `[[` <- base::`[[`
[17:39:51.998]             `+` <- base::`+`
[17:39:51.998]             `<<-` <- base::`<<-`
[17:39:51.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:51.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:51.998]                   3L)]
[17:39:51.998]             }
[17:39:51.998]             function(cond) {
[17:39:51.998]                 is_error <- inherits(cond, "error")
[17:39:51.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:51.998]                   NULL)
[17:39:51.998]                 if (is_error) {
[17:39:51.998]                   sessionInformation <- function() {
[17:39:51.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:51.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:51.998]                       search = base::search(), system = base::Sys.info())
[17:39:51.998]                   }
[17:39:51.998]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:51.998]                     cond$call), session = sessionInformation(), 
[17:39:51.998]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:51.998]                   signalCondition(cond)
[17:39:51.998]                 }
[17:39:51.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:51.998]                 "immediateCondition"))) {
[17:39:51.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:51.998]                   ...future.conditions[[length(...future.conditions) + 
[17:39:51.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:51.998]                   if (TRUE && !signal) {
[17:39:51.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.998]                     {
[17:39:51.998]                       inherits <- base::inherits
[17:39:51.998]                       invokeRestart <- base::invokeRestart
[17:39:51.998]                       is.null <- base::is.null
[17:39:51.998]                       muffled <- FALSE
[17:39:51.998]                       if (inherits(cond, "message")) {
[17:39:51.998]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.998]                         if (muffled) 
[17:39:51.998]                           invokeRestart("muffleMessage")
[17:39:51.998]                       }
[17:39:51.998]                       else if (inherits(cond, "warning")) {
[17:39:51.998]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.998]                         if (muffled) 
[17:39:51.998]                           invokeRestart("muffleWarning")
[17:39:51.998]                       }
[17:39:51.998]                       else if (inherits(cond, "condition")) {
[17:39:51.998]                         if (!is.null(pattern)) {
[17:39:51.998]                           computeRestarts <- base::computeRestarts
[17:39:51.998]                           grepl <- base::grepl
[17:39:51.998]                           restarts <- computeRestarts(cond)
[17:39:51.998]                           for (restart in restarts) {
[17:39:51.998]                             name <- restart$name
[17:39:51.998]                             if (is.null(name)) 
[17:39:51.998]                               next
[17:39:51.998]                             if (!grepl(pattern, name)) 
[17:39:51.998]                               next
[17:39:51.998]                             invokeRestart(restart)
[17:39:51.998]                             muffled <- TRUE
[17:39:51.998]                             break
[17:39:51.998]                           }
[17:39:51.998]                         }
[17:39:51.998]                       }
[17:39:51.998]                       invisible(muffled)
[17:39:51.998]                     }
[17:39:51.998]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.998]                   }
[17:39:51.998]                 }
[17:39:51.998]                 else {
[17:39:51.998]                   if (TRUE) {
[17:39:51.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:51.998]                     {
[17:39:51.998]                       inherits <- base::inherits
[17:39:51.998]                       invokeRestart <- base::invokeRestart
[17:39:51.998]                       is.null <- base::is.null
[17:39:51.998]                       muffled <- FALSE
[17:39:51.998]                       if (inherits(cond, "message")) {
[17:39:51.998]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:51.998]                         if (muffled) 
[17:39:51.998]                           invokeRestart("muffleMessage")
[17:39:51.998]                       }
[17:39:51.998]                       else if (inherits(cond, "warning")) {
[17:39:51.998]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:51.998]                         if (muffled) 
[17:39:51.998]                           invokeRestart("muffleWarning")
[17:39:51.998]                       }
[17:39:51.998]                       else if (inherits(cond, "condition")) {
[17:39:51.998]                         if (!is.null(pattern)) {
[17:39:51.998]                           computeRestarts <- base::computeRestarts
[17:39:51.998]                           grepl <- base::grepl
[17:39:51.998]                           restarts <- computeRestarts(cond)
[17:39:51.998]                           for (restart in restarts) {
[17:39:51.998]                             name <- restart$name
[17:39:51.998]                             if (is.null(name)) 
[17:39:51.998]                               next
[17:39:51.998]                             if (!grepl(pattern, name)) 
[17:39:51.998]                               next
[17:39:51.998]                             invokeRestart(restart)
[17:39:51.998]                             muffled <- TRUE
[17:39:51.998]                             break
[17:39:51.998]                           }
[17:39:51.998]                         }
[17:39:51.998]                       }
[17:39:51.998]                       invisible(muffled)
[17:39:51.998]                     }
[17:39:51.998]                     muffleCondition(cond, pattern = "^muffle")
[17:39:51.998]                   }
[17:39:51.998]                 }
[17:39:51.998]             }
[17:39:51.998]         }))
[17:39:51.998]     }, error = function(ex) {
[17:39:51.998]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:51.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:51.998]                 ...future.rng), started = ...future.startTime, 
[17:39:51.998]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:51.998]             version = "1.8"), class = "FutureResult")
[17:39:51.998]     }, finally = {
[17:39:51.998]         if (!identical(...future.workdir, getwd())) 
[17:39:51.998]             setwd(...future.workdir)
[17:39:51.998]         {
[17:39:51.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:51.998]                 ...future.oldOptions$nwarnings <- NULL
[17:39:51.998]             }
[17:39:51.998]             base::options(...future.oldOptions)
[17:39:51.998]             if (.Platform$OS.type == "windows") {
[17:39:51.998]                 old_names <- names(...future.oldEnvVars)
[17:39:51.998]                 envs <- base::Sys.getenv()
[17:39:51.998]                 names <- names(envs)
[17:39:51.998]                 common <- intersect(names, old_names)
[17:39:51.998]                 added <- setdiff(names, old_names)
[17:39:51.998]                 removed <- setdiff(old_names, names)
[17:39:51.998]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:51.998]                   envs[common]]
[17:39:51.998]                 NAMES <- toupper(changed)
[17:39:51.998]                 args <- list()
[17:39:51.998]                 for (kk in seq_along(NAMES)) {
[17:39:51.998]                   name <- changed[[kk]]
[17:39:51.998]                   NAME <- NAMES[[kk]]
[17:39:51.998]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.998]                     next
[17:39:51.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.998]                 }
[17:39:51.998]                 NAMES <- toupper(added)
[17:39:51.998]                 for (kk in seq_along(NAMES)) {
[17:39:51.998]                   name <- added[[kk]]
[17:39:51.998]                   NAME <- NAMES[[kk]]
[17:39:51.998]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.998]                     next
[17:39:51.998]                   args[[name]] <- ""
[17:39:51.998]                 }
[17:39:51.998]                 NAMES <- toupper(removed)
[17:39:51.998]                 for (kk in seq_along(NAMES)) {
[17:39:51.998]                   name <- removed[[kk]]
[17:39:51.998]                   NAME <- NAMES[[kk]]
[17:39:51.998]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:51.998]                     next
[17:39:51.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:51.998]                 }
[17:39:51.998]                 if (length(args) > 0) 
[17:39:51.998]                   base::do.call(base::Sys.setenv, args = args)
[17:39:51.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:51.998]             }
[17:39:51.998]             else {
[17:39:51.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:51.998]             }
[17:39:51.998]             {
[17:39:51.998]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:51.998]                   0L) {
[17:39:51.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:51.998]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:51.998]                   base::options(opts)
[17:39:51.998]                 }
[17:39:51.998]                 {
[17:39:51.998]                   {
[17:39:51.998]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:51.998]                     NULL
[17:39:51.998]                   }
[17:39:51.998]                   options(future.plan = NULL)
[17:39:51.998]                   if (is.na(NA_character_)) 
[17:39:51.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:51.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:51.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:51.998]                     .init = FALSE)
[17:39:51.998]                 }
[17:39:51.998]             }
[17:39:51.998]         }
[17:39:51.998]     })
[17:39:51.998]     if (TRUE) {
[17:39:51.998]         base::sink(type = "output", split = FALSE)
[17:39:51.998]         if (TRUE) {
[17:39:51.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:51.998]         }
[17:39:51.998]         else {
[17:39:51.998]             ...future.result["stdout"] <- base::list(NULL)
[17:39:51.998]         }
[17:39:51.998]         base::close(...future.stdout)
[17:39:51.998]         ...future.stdout <- NULL
[17:39:51.998]     }
[17:39:51.998]     ...future.result$conditions <- ...future.conditions
[17:39:51.998]     ...future.result$finished <- base::Sys.time()
[17:39:51.998]     ...future.result
[17:39:51.998] }
[17:39:52.001] assign_globals() ...
[17:39:52.001] List of 2
[17:39:52.001]  $ x   : list()
[17:39:52.001]  $ name: chr "a"
[17:39:52.001]  - attr(*, "where")=List of 2
[17:39:52.001]   ..$ x   :<environment: R_EmptyEnv> 
[17:39:52.001]   ..$ name:<environment: R_EmptyEnv> 
[17:39:52.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:52.001]  - attr(*, "resolved")= logi TRUE
[17:39:52.001]  - attr(*, "total_size")= num 112
[17:39:52.001]  - attr(*, "already-done")= logi TRUE
[17:39:52.004] - copied ‘x’ to environment
[17:39:52.004] - copied ‘name’ to environment
[17:39:52.005] assign_globals() ... done
[17:39:52.005] requestCore(): workers = 2
[17:39:52.006] MulticoreFuture started
[17:39:52.007] - Launch lazy future ... done
[17:39:52.007] run() for ‘MulticoreFuture’ ... done
[17:39:52.007] result() for MulticoreFuture ...
[17:39:52.007] plan(): Setting new future strategy stack:
[17:39:52.008] List of future strategies:
[17:39:52.008] 1. sequential:
[17:39:52.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:52.008]    - tweaked: FALSE
[17:39:52.008]    - call: NULL
[17:39:52.009] plan(): nbrOfWorkers() = 1
[17:39:52.010] plan(): Setting new future strategy stack:
[17:39:52.011] List of future strategies:
[17:39:52.011] 1. multicore:
[17:39:52.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:52.011]    - tweaked: FALSE
[17:39:52.011]    - call: plan(strategy)
[17:39:52.016] plan(): nbrOfWorkers() = 2
[17:39:52.017] result() for MulticoreFuture ...
[17:39:52.017] result() for MulticoreFuture ... done
[17:39:52.017] result() for MulticoreFuture ... done
[17:39:52.017] result() for MulticoreFuture ...
[17:39:52.018] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[17:39:52.018] plan(): Setting new future strategy stack:
[17:39:52.018] List of future strategies:
[17:39:52.018] 1. multisession:
[17:39:52.018]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:52.018]    - tweaked: FALSE
[17:39:52.018]    - call: plan(strategy)
[17:39:52.019] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:52.019] multisession:
[17:39:52.019] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:52.019] - tweaked: FALSE
[17:39:52.019] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.028] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.028] Not searching for globals
[17:39:52.029] - globals: [0] <none>
[17:39:52.029] getGlobalsAndPackages() ... DONE
[17:39:52.029] [local output] makeClusterPSOCK() ...
[17:39:52.073] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:52.074] [local output] Base port: 11959
[17:39:52.074] [local output] Getting setup options for 2 cluster nodes ...
[17:39:52.074] [local output]  - Node 1 of 2 ...
[17:39:52.075] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:52.075] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpK1DN2C/worker.rank=1.parallelly.parent=44176.ac9022053265.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpK1DN2C/worker.rank=1.parallelly.parent=44176.ac9022053265.pid")'’
[17:39:52.264] - Possible to infer worker's PID: TRUE
[17:39:52.264] [local output] Rscript port: 11959

[17:39:52.265] [local output]  - Node 2 of 2 ...
[17:39:52.265] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:52.266] [local output] Rscript port: 11959

[17:39:52.266] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:52.266] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:52.266] [local output] Setting up PSOCK nodes in parallel
[17:39:52.267] List of 36
[17:39:52.267]  $ worker          : chr "localhost"
[17:39:52.267]   ..- attr(*, "localhost")= logi TRUE
[17:39:52.267]  $ master          : chr "localhost"
[17:39:52.267]  $ port            : int 11959
[17:39:52.267]  $ connectTimeout  : num 120
[17:39:52.267]  $ timeout         : num 2592000
[17:39:52.267]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:52.267]  $ homogeneous     : logi TRUE
[17:39:52.267]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:52.267]  $ rscript_envs    : NULL
[17:39:52.267]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:52.267]  $ rscript_startup : NULL
[17:39:52.267]  $ rscript_sh      : chr "sh"
[17:39:52.267]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:52.267]  $ methods         : logi TRUE
[17:39:52.267]  $ socketOptions   : chr "no-delay"
[17:39:52.267]  $ useXDR          : logi FALSE
[17:39:52.267]  $ outfile         : chr "/dev/null"
[17:39:52.267]  $ renice          : int NA
[17:39:52.267]  $ rshcmd          : NULL
[17:39:52.267]  $ user            : chr(0) 
[17:39:52.267]  $ revtunnel       : logi FALSE
[17:39:52.267]  $ rshlogfile      : NULL
[17:39:52.267]  $ rshopts         : chr(0) 
[17:39:52.267]  $ rank            : int 1
[17:39:52.267]  $ manual          : logi FALSE
[17:39:52.267]  $ dryrun          : logi FALSE
[17:39:52.267]  $ quiet           : logi FALSE
[17:39:52.267]  $ setup_strategy  : chr "parallel"
[17:39:52.267]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:52.267]  $ pidfile         : chr "/tmp/RtmpK1DN2C/worker.rank=1.parallelly.parent=44176.ac9022053265.pid"
[17:39:52.267]  $ rshcmd_label    : NULL
[17:39:52.267]  $ rsh_call        : NULL
[17:39:52.267]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:52.267]  $ localMachine    : logi TRUE
[17:39:52.267]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:52.267]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:52.267]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:52.267]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:52.267]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:52.267]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:52.267]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:52.267]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:52.267]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:52.267]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:52.267]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:52.267]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:52.267]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:52.267]  $ arguments       :List of 28
[17:39:52.267]   ..$ worker          : chr "localhost"
[17:39:52.267]   ..$ master          : NULL
[17:39:52.267]   ..$ port            : int 11959
[17:39:52.267]   ..$ connectTimeout  : num 120
[17:39:52.267]   ..$ timeout         : num 2592000
[17:39:52.267]   ..$ rscript         : NULL
[17:39:52.267]   ..$ homogeneous     : NULL
[17:39:52.267]   ..$ rscript_args    : NULL
[17:39:52.267]   ..$ rscript_envs    : NULL
[17:39:52.267]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:52.267]   ..$ rscript_startup : NULL
[17:39:52.267]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:52.267]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:52.267]   ..$ methods         : logi TRUE
[17:39:52.267]   ..$ socketOptions   : chr "no-delay"
[17:39:52.267]   ..$ useXDR          : logi FALSE
[17:39:52.267]   ..$ outfile         : chr "/dev/null"
[17:39:52.267]   ..$ renice          : int NA
[17:39:52.267]   ..$ rshcmd          : NULL
[17:39:52.267]   ..$ user            : NULL
[17:39:52.267]   ..$ revtunnel       : logi NA
[17:39:52.267]   ..$ rshlogfile      : NULL
[17:39:52.267]   ..$ rshopts         : NULL
[17:39:52.267]   ..$ rank            : int 1
[17:39:52.267]   ..$ manual          : logi FALSE
[17:39:52.267]   ..$ dryrun          : logi FALSE
[17:39:52.267]   ..$ quiet           : logi FALSE
[17:39:52.267]   ..$ setup_strategy  : chr "parallel"
[17:39:52.267]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:52.283] [local output] System call to launch all workers:
[17:39:52.283] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpK1DN2C/worker.rank=1.parallelly.parent=44176.ac9022053265.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11959 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:52.283] [local output] Starting PSOCK main server
[17:39:52.289] [local output] Workers launched
[17:39:52.289] [local output] Waiting for workers to connect back
[17:39:52.289]  - [local output] 0 workers out of 2 ready
[17:39:52.532]  - [local output] 0 workers out of 2 ready
[17:39:52.532]  - [local output] 1 workers out of 2 ready
[17:39:52.537]  - [local output] 1 workers out of 2 ready
[17:39:52.537]  - [local output] 2 workers out of 2 ready
[17:39:52.537] [local output] Launching of workers completed
[17:39:52.537] [local output] Collecting session information from workers
[17:39:52.538] [local output]  - Worker #1 of 2
[17:39:52.539] [local output]  - Worker #2 of 2
[17:39:52.539] [local output] makeClusterPSOCK() ... done
[17:39:52.552] Packages needed by the future expression (n = 0): <none>
[17:39:52.552] Packages needed by future strategies (n = 0): <none>
[17:39:52.552] {
[17:39:52.552]     {
[17:39:52.552]         {
[17:39:52.552]             ...future.startTime <- base::Sys.time()
[17:39:52.552]             {
[17:39:52.552]                 {
[17:39:52.552]                   {
[17:39:52.552]                     {
[17:39:52.552]                       base::local({
[17:39:52.552]                         has_future <- base::requireNamespace("future", 
[17:39:52.552]                           quietly = TRUE)
[17:39:52.552]                         if (has_future) {
[17:39:52.552]                           ns <- base::getNamespace("future")
[17:39:52.552]                           version <- ns[[".package"]][["version"]]
[17:39:52.552]                           if (is.null(version)) 
[17:39:52.552]                             version <- utils::packageVersion("future")
[17:39:52.552]                         }
[17:39:52.552]                         else {
[17:39:52.552]                           version <- NULL
[17:39:52.552]                         }
[17:39:52.552]                         if (!has_future || version < "1.8.0") {
[17:39:52.552]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.552]                             "", base::R.version$version.string), 
[17:39:52.552]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.552]                               "release", "version")], collapse = " "), 
[17:39:52.552]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.552]                             info)
[17:39:52.552]                           info <- base::paste(info, collapse = "; ")
[17:39:52.552]                           if (!has_future) {
[17:39:52.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.552]                               info)
[17:39:52.552]                           }
[17:39:52.552]                           else {
[17:39:52.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.552]                               info, version)
[17:39:52.552]                           }
[17:39:52.552]                           base::stop(msg)
[17:39:52.552]                         }
[17:39:52.552]                       })
[17:39:52.552]                     }
[17:39:52.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.552]                     base::options(mc.cores = 1L)
[17:39:52.552]                   }
[17:39:52.552]                   ...future.strategy.old <- future::plan("list")
[17:39:52.552]                   options(future.plan = NULL)
[17:39:52.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.552]                 }
[17:39:52.552]                 ...future.workdir <- getwd()
[17:39:52.552]             }
[17:39:52.552]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.552]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.552]         }
[17:39:52.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.552]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.552]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.552]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.552]             base::names(...future.oldOptions))
[17:39:52.552]     }
[17:39:52.552]     if (FALSE) {
[17:39:52.552]     }
[17:39:52.552]     else {
[17:39:52.552]         if (TRUE) {
[17:39:52.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.552]                 open = "w")
[17:39:52.552]         }
[17:39:52.552]         else {
[17:39:52.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.552]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.552]         }
[17:39:52.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.552]             base::sink(type = "output", split = FALSE)
[17:39:52.552]             base::close(...future.stdout)
[17:39:52.552]         }, add = TRUE)
[17:39:52.552]     }
[17:39:52.552]     ...future.frame <- base::sys.nframe()
[17:39:52.552]     ...future.conditions <- base::list()
[17:39:52.552]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.552]     if (FALSE) {
[17:39:52.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.552]     }
[17:39:52.552]     ...future.result <- base::tryCatch({
[17:39:52.552]         base::withCallingHandlers({
[17:39:52.552]             ...future.value <- base::withVisible(base::local({
[17:39:52.552]                 ...future.makeSendCondition <- base::local({
[17:39:52.552]                   sendCondition <- NULL
[17:39:52.552]                   function(frame = 1L) {
[17:39:52.552]                     if (is.function(sendCondition)) 
[17:39:52.552]                       return(sendCondition)
[17:39:52.552]                     ns <- getNamespace("parallel")
[17:39:52.552]                     if (exists("sendData", mode = "function", 
[17:39:52.552]                       envir = ns)) {
[17:39:52.552]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.552]                         envir = ns)
[17:39:52.552]                       envir <- sys.frame(frame)
[17:39:52.552]                       master <- NULL
[17:39:52.552]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.552]                         !identical(envir, emptyenv())) {
[17:39:52.552]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.552]                           inherits = FALSE)) {
[17:39:52.552]                           master <- get("master", mode = "list", 
[17:39:52.552]                             envir = envir, inherits = FALSE)
[17:39:52.552]                           if (inherits(master, c("SOCKnode", 
[17:39:52.552]                             "SOCK0node"))) {
[17:39:52.552]                             sendCondition <<- function(cond) {
[17:39:52.552]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.552]                                 success = TRUE)
[17:39:52.552]                               parallel_sendData(master, data)
[17:39:52.552]                             }
[17:39:52.552]                             return(sendCondition)
[17:39:52.552]                           }
[17:39:52.552]                         }
[17:39:52.552]                         frame <- frame + 1L
[17:39:52.552]                         envir <- sys.frame(frame)
[17:39:52.552]                       }
[17:39:52.552]                     }
[17:39:52.552]                     sendCondition <<- function(cond) NULL
[17:39:52.552]                   }
[17:39:52.552]                 })
[17:39:52.552]                 withCallingHandlers({
[17:39:52.552]                   NA
[17:39:52.552]                 }, immediateCondition = function(cond) {
[17:39:52.552]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.552]                   sendCondition(cond)
[17:39:52.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.552]                   {
[17:39:52.552]                     inherits <- base::inherits
[17:39:52.552]                     invokeRestart <- base::invokeRestart
[17:39:52.552]                     is.null <- base::is.null
[17:39:52.552]                     muffled <- FALSE
[17:39:52.552]                     if (inherits(cond, "message")) {
[17:39:52.552]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.552]                       if (muffled) 
[17:39:52.552]                         invokeRestart("muffleMessage")
[17:39:52.552]                     }
[17:39:52.552]                     else if (inherits(cond, "warning")) {
[17:39:52.552]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.552]                       if (muffled) 
[17:39:52.552]                         invokeRestart("muffleWarning")
[17:39:52.552]                     }
[17:39:52.552]                     else if (inherits(cond, "condition")) {
[17:39:52.552]                       if (!is.null(pattern)) {
[17:39:52.552]                         computeRestarts <- base::computeRestarts
[17:39:52.552]                         grepl <- base::grepl
[17:39:52.552]                         restarts <- computeRestarts(cond)
[17:39:52.552]                         for (restart in restarts) {
[17:39:52.552]                           name <- restart$name
[17:39:52.552]                           if (is.null(name)) 
[17:39:52.552]                             next
[17:39:52.552]                           if (!grepl(pattern, name)) 
[17:39:52.552]                             next
[17:39:52.552]                           invokeRestart(restart)
[17:39:52.552]                           muffled <- TRUE
[17:39:52.552]                           break
[17:39:52.552]                         }
[17:39:52.552]                       }
[17:39:52.552]                     }
[17:39:52.552]                     invisible(muffled)
[17:39:52.552]                   }
[17:39:52.552]                   muffleCondition(cond)
[17:39:52.552]                 })
[17:39:52.552]             }))
[17:39:52.552]             future::FutureResult(value = ...future.value$value, 
[17:39:52.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.552]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.552]                     ...future.globalenv.names))
[17:39:52.552]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.552]         }, condition = base::local({
[17:39:52.552]             c <- base::c
[17:39:52.552]             inherits <- base::inherits
[17:39:52.552]             invokeRestart <- base::invokeRestart
[17:39:52.552]             length <- base::length
[17:39:52.552]             list <- base::list
[17:39:52.552]             seq.int <- base::seq.int
[17:39:52.552]             signalCondition <- base::signalCondition
[17:39:52.552]             sys.calls <- base::sys.calls
[17:39:52.552]             `[[` <- base::`[[`
[17:39:52.552]             `+` <- base::`+`
[17:39:52.552]             `<<-` <- base::`<<-`
[17:39:52.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.552]                   3L)]
[17:39:52.552]             }
[17:39:52.552]             function(cond) {
[17:39:52.552]                 is_error <- inherits(cond, "error")
[17:39:52.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.552]                   NULL)
[17:39:52.552]                 if (is_error) {
[17:39:52.552]                   sessionInformation <- function() {
[17:39:52.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.552]                       search = base::search(), system = base::Sys.info())
[17:39:52.552]                   }
[17:39:52.552]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.552]                     cond$call), session = sessionInformation(), 
[17:39:52.552]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.552]                   signalCondition(cond)
[17:39:52.552]                 }
[17:39:52.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.552]                 "immediateCondition"))) {
[17:39:52.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.552]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.552]                   if (TRUE && !signal) {
[17:39:52.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.552]                     {
[17:39:52.552]                       inherits <- base::inherits
[17:39:52.552]                       invokeRestart <- base::invokeRestart
[17:39:52.552]                       is.null <- base::is.null
[17:39:52.552]                       muffled <- FALSE
[17:39:52.552]                       if (inherits(cond, "message")) {
[17:39:52.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.552]                         if (muffled) 
[17:39:52.552]                           invokeRestart("muffleMessage")
[17:39:52.552]                       }
[17:39:52.552]                       else if (inherits(cond, "warning")) {
[17:39:52.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.552]                         if (muffled) 
[17:39:52.552]                           invokeRestart("muffleWarning")
[17:39:52.552]                       }
[17:39:52.552]                       else if (inherits(cond, "condition")) {
[17:39:52.552]                         if (!is.null(pattern)) {
[17:39:52.552]                           computeRestarts <- base::computeRestarts
[17:39:52.552]                           grepl <- base::grepl
[17:39:52.552]                           restarts <- computeRestarts(cond)
[17:39:52.552]                           for (restart in restarts) {
[17:39:52.552]                             name <- restart$name
[17:39:52.552]                             if (is.null(name)) 
[17:39:52.552]                               next
[17:39:52.552]                             if (!grepl(pattern, name)) 
[17:39:52.552]                               next
[17:39:52.552]                             invokeRestart(restart)
[17:39:52.552]                             muffled <- TRUE
[17:39:52.552]                             break
[17:39:52.552]                           }
[17:39:52.552]                         }
[17:39:52.552]                       }
[17:39:52.552]                       invisible(muffled)
[17:39:52.552]                     }
[17:39:52.552]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.552]                   }
[17:39:52.552]                 }
[17:39:52.552]                 else {
[17:39:52.552]                   if (TRUE) {
[17:39:52.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.552]                     {
[17:39:52.552]                       inherits <- base::inherits
[17:39:52.552]                       invokeRestart <- base::invokeRestart
[17:39:52.552]                       is.null <- base::is.null
[17:39:52.552]                       muffled <- FALSE
[17:39:52.552]                       if (inherits(cond, "message")) {
[17:39:52.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.552]                         if (muffled) 
[17:39:52.552]                           invokeRestart("muffleMessage")
[17:39:52.552]                       }
[17:39:52.552]                       else if (inherits(cond, "warning")) {
[17:39:52.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.552]                         if (muffled) 
[17:39:52.552]                           invokeRestart("muffleWarning")
[17:39:52.552]                       }
[17:39:52.552]                       else if (inherits(cond, "condition")) {
[17:39:52.552]                         if (!is.null(pattern)) {
[17:39:52.552]                           computeRestarts <- base::computeRestarts
[17:39:52.552]                           grepl <- base::grepl
[17:39:52.552]                           restarts <- computeRestarts(cond)
[17:39:52.552]                           for (restart in restarts) {
[17:39:52.552]                             name <- restart$name
[17:39:52.552]                             if (is.null(name)) 
[17:39:52.552]                               next
[17:39:52.552]                             if (!grepl(pattern, name)) 
[17:39:52.552]                               next
[17:39:52.552]                             invokeRestart(restart)
[17:39:52.552]                             muffled <- TRUE
[17:39:52.552]                             break
[17:39:52.552]                           }
[17:39:52.552]                         }
[17:39:52.552]                       }
[17:39:52.552]                       invisible(muffled)
[17:39:52.552]                     }
[17:39:52.552]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.552]                   }
[17:39:52.552]                 }
[17:39:52.552]             }
[17:39:52.552]         }))
[17:39:52.552]     }, error = function(ex) {
[17:39:52.552]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.552]                 ...future.rng), started = ...future.startTime, 
[17:39:52.552]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.552]             version = "1.8"), class = "FutureResult")
[17:39:52.552]     }, finally = {
[17:39:52.552]         if (!identical(...future.workdir, getwd())) 
[17:39:52.552]             setwd(...future.workdir)
[17:39:52.552]         {
[17:39:52.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.552]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.552]             }
[17:39:52.552]             base::options(...future.oldOptions)
[17:39:52.552]             if (.Platform$OS.type == "windows") {
[17:39:52.552]                 old_names <- names(...future.oldEnvVars)
[17:39:52.552]                 envs <- base::Sys.getenv()
[17:39:52.552]                 names <- names(envs)
[17:39:52.552]                 common <- intersect(names, old_names)
[17:39:52.552]                 added <- setdiff(names, old_names)
[17:39:52.552]                 removed <- setdiff(old_names, names)
[17:39:52.552]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.552]                   envs[common]]
[17:39:52.552]                 NAMES <- toupper(changed)
[17:39:52.552]                 args <- list()
[17:39:52.552]                 for (kk in seq_along(NAMES)) {
[17:39:52.552]                   name <- changed[[kk]]
[17:39:52.552]                   NAME <- NAMES[[kk]]
[17:39:52.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.552]                     next
[17:39:52.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.552]                 }
[17:39:52.552]                 NAMES <- toupper(added)
[17:39:52.552]                 for (kk in seq_along(NAMES)) {
[17:39:52.552]                   name <- added[[kk]]
[17:39:52.552]                   NAME <- NAMES[[kk]]
[17:39:52.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.552]                     next
[17:39:52.552]                   args[[name]] <- ""
[17:39:52.552]                 }
[17:39:52.552]                 NAMES <- toupper(removed)
[17:39:52.552]                 for (kk in seq_along(NAMES)) {
[17:39:52.552]                   name <- removed[[kk]]
[17:39:52.552]                   NAME <- NAMES[[kk]]
[17:39:52.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.552]                     next
[17:39:52.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.552]                 }
[17:39:52.552]                 if (length(args) > 0) 
[17:39:52.552]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.552]             }
[17:39:52.552]             else {
[17:39:52.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.552]             }
[17:39:52.552]             {
[17:39:52.552]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.552]                   0L) {
[17:39:52.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.552]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.552]                   base::options(opts)
[17:39:52.552]                 }
[17:39:52.552]                 {
[17:39:52.552]                   {
[17:39:52.552]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.552]                     NULL
[17:39:52.552]                   }
[17:39:52.552]                   options(future.plan = NULL)
[17:39:52.552]                   if (is.na(NA_character_)) 
[17:39:52.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.552]                     .init = FALSE)
[17:39:52.552]                 }
[17:39:52.552]             }
[17:39:52.552]         }
[17:39:52.552]     })
[17:39:52.552]     if (TRUE) {
[17:39:52.552]         base::sink(type = "output", split = FALSE)
[17:39:52.552]         if (TRUE) {
[17:39:52.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.552]         }
[17:39:52.552]         else {
[17:39:52.552]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.552]         }
[17:39:52.552]         base::close(...future.stdout)
[17:39:52.552]         ...future.stdout <- NULL
[17:39:52.552]     }
[17:39:52.552]     ...future.result$conditions <- ...future.conditions
[17:39:52.552]     ...future.result$finished <- base::Sys.time()
[17:39:52.552]     ...future.result
[17:39:52.552] }
[17:39:52.604] MultisessionFuture started
[17:39:52.604] result() for ClusterFuture ...
[17:39:52.605] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.605] - Validating connection of MultisessionFuture
[17:39:52.636] - received message: FutureResult
[17:39:52.636] - Received FutureResult
[17:39:52.636] - Erased future from FutureRegistry
[17:39:52.636] result() for ClusterFuture ...
[17:39:52.636] - result already collected: FutureResult
[17:39:52.637] result() for ClusterFuture ... done
[17:39:52.637] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.637] result() for ClusterFuture ... done
[17:39:52.637] result() for ClusterFuture ...
[17:39:52.637] - result already collected: FutureResult
[17:39:52.637] result() for ClusterFuture ... done
[17:39:52.637] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:52.641] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.642] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.642] Searching for globals...
[17:39:52.644] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.645] Searching for globals ... DONE
[17:39:52.645] Resolving globals: TRUE
[17:39:52.645] Resolving any globals that are futures ...
[17:39:52.645] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.645] Resolving any globals that are futures ... DONE
[17:39:52.646] Resolving futures part of globals (recursively) ...
[17:39:52.646] resolve() on list ...
[17:39:52.646]  recursive: 99
[17:39:52.646]  length: 1
[17:39:52.646]  elements: ‘x’
[17:39:52.646]  length: 0 (resolved future 1)
[17:39:52.646] resolve() on list ... DONE
[17:39:52.647] - globals: [1] ‘x’
[17:39:52.647] Resolving futures part of globals (recursively) ... DONE
[17:39:52.647] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.647] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.647] - globals: [1] ‘x’
[17:39:52.648] 
[17:39:52.648] getGlobalsAndPackages() ... DONE
[17:39:52.648] run() for ‘Future’ ...
[17:39:52.648] - state: ‘created’
[17:39:52.648] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.663]   - Field: ‘node’
[17:39:52.663]   - Field: ‘label’
[17:39:52.663]   - Field: ‘local’
[17:39:52.663]   - Field: ‘owner’
[17:39:52.663]   - Field: ‘envir’
[17:39:52.663]   - Field: ‘workers’
[17:39:52.663]   - Field: ‘packages’
[17:39:52.663]   - Field: ‘gc’
[17:39:52.663]   - Field: ‘conditions’
[17:39:52.664]   - Field: ‘persistent’
[17:39:52.664]   - Field: ‘expr’
[17:39:52.664]   - Field: ‘uuid’
[17:39:52.664]   - Field: ‘seed’
[17:39:52.664]   - Field: ‘version’
[17:39:52.664]   - Field: ‘result’
[17:39:52.664]   - Field: ‘asynchronous’
[17:39:52.664]   - Field: ‘calls’
[17:39:52.664]   - Field: ‘globals’
[17:39:52.665]   - Field: ‘stdout’
[17:39:52.665]   - Field: ‘earlySignal’
[17:39:52.665]   - Field: ‘lazy’
[17:39:52.665]   - Field: ‘state’
[17:39:52.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.665] - Launch lazy future ...
[17:39:52.665] Packages needed by the future expression (n = 0): <none>
[17:39:52.666] Packages needed by future strategies (n = 0): <none>
[17:39:52.666] {
[17:39:52.666]     {
[17:39:52.666]         {
[17:39:52.666]             ...future.startTime <- base::Sys.time()
[17:39:52.666]             {
[17:39:52.666]                 {
[17:39:52.666]                   {
[17:39:52.666]                     {
[17:39:52.666]                       base::local({
[17:39:52.666]                         has_future <- base::requireNamespace("future", 
[17:39:52.666]                           quietly = TRUE)
[17:39:52.666]                         if (has_future) {
[17:39:52.666]                           ns <- base::getNamespace("future")
[17:39:52.666]                           version <- ns[[".package"]][["version"]]
[17:39:52.666]                           if (is.null(version)) 
[17:39:52.666]                             version <- utils::packageVersion("future")
[17:39:52.666]                         }
[17:39:52.666]                         else {
[17:39:52.666]                           version <- NULL
[17:39:52.666]                         }
[17:39:52.666]                         if (!has_future || version < "1.8.0") {
[17:39:52.666]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.666]                             "", base::R.version$version.string), 
[17:39:52.666]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.666]                               "release", "version")], collapse = " "), 
[17:39:52.666]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.666]                             info)
[17:39:52.666]                           info <- base::paste(info, collapse = "; ")
[17:39:52.666]                           if (!has_future) {
[17:39:52.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.666]                               info)
[17:39:52.666]                           }
[17:39:52.666]                           else {
[17:39:52.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.666]                               info, version)
[17:39:52.666]                           }
[17:39:52.666]                           base::stop(msg)
[17:39:52.666]                         }
[17:39:52.666]                       })
[17:39:52.666]                     }
[17:39:52.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.666]                     base::options(mc.cores = 1L)
[17:39:52.666]                   }
[17:39:52.666]                   ...future.strategy.old <- future::plan("list")
[17:39:52.666]                   options(future.plan = NULL)
[17:39:52.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.666]                 }
[17:39:52.666]                 ...future.workdir <- getwd()
[17:39:52.666]             }
[17:39:52.666]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.666]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.666]         }
[17:39:52.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.666]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.666]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.666]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.666]             base::names(...future.oldOptions))
[17:39:52.666]     }
[17:39:52.666]     if (FALSE) {
[17:39:52.666]     }
[17:39:52.666]     else {
[17:39:52.666]         if (TRUE) {
[17:39:52.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.666]                 open = "w")
[17:39:52.666]         }
[17:39:52.666]         else {
[17:39:52.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.666]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.666]         }
[17:39:52.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.666]             base::sink(type = "output", split = FALSE)
[17:39:52.666]             base::close(...future.stdout)
[17:39:52.666]         }, add = TRUE)
[17:39:52.666]     }
[17:39:52.666]     ...future.frame <- base::sys.nframe()
[17:39:52.666]     ...future.conditions <- base::list()
[17:39:52.666]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.666]     if (FALSE) {
[17:39:52.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.666]     }
[17:39:52.666]     ...future.result <- base::tryCatch({
[17:39:52.666]         base::withCallingHandlers({
[17:39:52.666]             ...future.value <- base::withVisible(base::local({
[17:39:52.666]                 ...future.makeSendCondition <- base::local({
[17:39:52.666]                   sendCondition <- NULL
[17:39:52.666]                   function(frame = 1L) {
[17:39:52.666]                     if (is.function(sendCondition)) 
[17:39:52.666]                       return(sendCondition)
[17:39:52.666]                     ns <- getNamespace("parallel")
[17:39:52.666]                     if (exists("sendData", mode = "function", 
[17:39:52.666]                       envir = ns)) {
[17:39:52.666]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.666]                         envir = ns)
[17:39:52.666]                       envir <- sys.frame(frame)
[17:39:52.666]                       master <- NULL
[17:39:52.666]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.666]                         !identical(envir, emptyenv())) {
[17:39:52.666]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.666]                           inherits = FALSE)) {
[17:39:52.666]                           master <- get("master", mode = "list", 
[17:39:52.666]                             envir = envir, inherits = FALSE)
[17:39:52.666]                           if (inherits(master, c("SOCKnode", 
[17:39:52.666]                             "SOCK0node"))) {
[17:39:52.666]                             sendCondition <<- function(cond) {
[17:39:52.666]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.666]                                 success = TRUE)
[17:39:52.666]                               parallel_sendData(master, data)
[17:39:52.666]                             }
[17:39:52.666]                             return(sendCondition)
[17:39:52.666]                           }
[17:39:52.666]                         }
[17:39:52.666]                         frame <- frame + 1L
[17:39:52.666]                         envir <- sys.frame(frame)
[17:39:52.666]                       }
[17:39:52.666]                     }
[17:39:52.666]                     sendCondition <<- function(cond) NULL
[17:39:52.666]                   }
[17:39:52.666]                 })
[17:39:52.666]                 withCallingHandlers({
[17:39:52.666]                   {
[17:39:52.666]                     x$a <- 1
[17:39:52.666]                     x
[17:39:52.666]                   }
[17:39:52.666]                 }, immediateCondition = function(cond) {
[17:39:52.666]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.666]                   sendCondition(cond)
[17:39:52.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.666]                   {
[17:39:52.666]                     inherits <- base::inherits
[17:39:52.666]                     invokeRestart <- base::invokeRestart
[17:39:52.666]                     is.null <- base::is.null
[17:39:52.666]                     muffled <- FALSE
[17:39:52.666]                     if (inherits(cond, "message")) {
[17:39:52.666]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.666]                       if (muffled) 
[17:39:52.666]                         invokeRestart("muffleMessage")
[17:39:52.666]                     }
[17:39:52.666]                     else if (inherits(cond, "warning")) {
[17:39:52.666]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.666]                       if (muffled) 
[17:39:52.666]                         invokeRestart("muffleWarning")
[17:39:52.666]                     }
[17:39:52.666]                     else if (inherits(cond, "condition")) {
[17:39:52.666]                       if (!is.null(pattern)) {
[17:39:52.666]                         computeRestarts <- base::computeRestarts
[17:39:52.666]                         grepl <- base::grepl
[17:39:52.666]                         restarts <- computeRestarts(cond)
[17:39:52.666]                         for (restart in restarts) {
[17:39:52.666]                           name <- restart$name
[17:39:52.666]                           if (is.null(name)) 
[17:39:52.666]                             next
[17:39:52.666]                           if (!grepl(pattern, name)) 
[17:39:52.666]                             next
[17:39:52.666]                           invokeRestart(restart)
[17:39:52.666]                           muffled <- TRUE
[17:39:52.666]                           break
[17:39:52.666]                         }
[17:39:52.666]                       }
[17:39:52.666]                     }
[17:39:52.666]                     invisible(muffled)
[17:39:52.666]                   }
[17:39:52.666]                   muffleCondition(cond)
[17:39:52.666]                 })
[17:39:52.666]             }))
[17:39:52.666]             future::FutureResult(value = ...future.value$value, 
[17:39:52.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.666]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.666]                     ...future.globalenv.names))
[17:39:52.666]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.666]         }, condition = base::local({
[17:39:52.666]             c <- base::c
[17:39:52.666]             inherits <- base::inherits
[17:39:52.666]             invokeRestart <- base::invokeRestart
[17:39:52.666]             length <- base::length
[17:39:52.666]             list <- base::list
[17:39:52.666]             seq.int <- base::seq.int
[17:39:52.666]             signalCondition <- base::signalCondition
[17:39:52.666]             sys.calls <- base::sys.calls
[17:39:52.666]             `[[` <- base::`[[`
[17:39:52.666]             `+` <- base::`+`
[17:39:52.666]             `<<-` <- base::`<<-`
[17:39:52.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.666]                   3L)]
[17:39:52.666]             }
[17:39:52.666]             function(cond) {
[17:39:52.666]                 is_error <- inherits(cond, "error")
[17:39:52.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.666]                   NULL)
[17:39:52.666]                 if (is_error) {
[17:39:52.666]                   sessionInformation <- function() {
[17:39:52.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.666]                       search = base::search(), system = base::Sys.info())
[17:39:52.666]                   }
[17:39:52.666]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.666]                     cond$call), session = sessionInformation(), 
[17:39:52.666]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.666]                   signalCondition(cond)
[17:39:52.666]                 }
[17:39:52.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.666]                 "immediateCondition"))) {
[17:39:52.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.666]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.666]                   if (TRUE && !signal) {
[17:39:52.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.666]                     {
[17:39:52.666]                       inherits <- base::inherits
[17:39:52.666]                       invokeRestart <- base::invokeRestart
[17:39:52.666]                       is.null <- base::is.null
[17:39:52.666]                       muffled <- FALSE
[17:39:52.666]                       if (inherits(cond, "message")) {
[17:39:52.666]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.666]                         if (muffled) 
[17:39:52.666]                           invokeRestart("muffleMessage")
[17:39:52.666]                       }
[17:39:52.666]                       else if (inherits(cond, "warning")) {
[17:39:52.666]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.666]                         if (muffled) 
[17:39:52.666]                           invokeRestart("muffleWarning")
[17:39:52.666]                       }
[17:39:52.666]                       else if (inherits(cond, "condition")) {
[17:39:52.666]                         if (!is.null(pattern)) {
[17:39:52.666]                           computeRestarts <- base::computeRestarts
[17:39:52.666]                           grepl <- base::grepl
[17:39:52.666]                           restarts <- computeRestarts(cond)
[17:39:52.666]                           for (restart in restarts) {
[17:39:52.666]                             name <- restart$name
[17:39:52.666]                             if (is.null(name)) 
[17:39:52.666]                               next
[17:39:52.666]                             if (!grepl(pattern, name)) 
[17:39:52.666]                               next
[17:39:52.666]                             invokeRestart(restart)
[17:39:52.666]                             muffled <- TRUE
[17:39:52.666]                             break
[17:39:52.666]                           }
[17:39:52.666]                         }
[17:39:52.666]                       }
[17:39:52.666]                       invisible(muffled)
[17:39:52.666]                     }
[17:39:52.666]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.666]                   }
[17:39:52.666]                 }
[17:39:52.666]                 else {
[17:39:52.666]                   if (TRUE) {
[17:39:52.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.666]                     {
[17:39:52.666]                       inherits <- base::inherits
[17:39:52.666]                       invokeRestart <- base::invokeRestart
[17:39:52.666]                       is.null <- base::is.null
[17:39:52.666]                       muffled <- FALSE
[17:39:52.666]                       if (inherits(cond, "message")) {
[17:39:52.666]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.666]                         if (muffled) 
[17:39:52.666]                           invokeRestart("muffleMessage")
[17:39:52.666]                       }
[17:39:52.666]                       else if (inherits(cond, "warning")) {
[17:39:52.666]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.666]                         if (muffled) 
[17:39:52.666]                           invokeRestart("muffleWarning")
[17:39:52.666]                       }
[17:39:52.666]                       else if (inherits(cond, "condition")) {
[17:39:52.666]                         if (!is.null(pattern)) {
[17:39:52.666]                           computeRestarts <- base::computeRestarts
[17:39:52.666]                           grepl <- base::grepl
[17:39:52.666]                           restarts <- computeRestarts(cond)
[17:39:52.666]                           for (restart in restarts) {
[17:39:52.666]                             name <- restart$name
[17:39:52.666]                             if (is.null(name)) 
[17:39:52.666]                               next
[17:39:52.666]                             if (!grepl(pattern, name)) 
[17:39:52.666]                               next
[17:39:52.666]                             invokeRestart(restart)
[17:39:52.666]                             muffled <- TRUE
[17:39:52.666]                             break
[17:39:52.666]                           }
[17:39:52.666]                         }
[17:39:52.666]                       }
[17:39:52.666]                       invisible(muffled)
[17:39:52.666]                     }
[17:39:52.666]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.666]                   }
[17:39:52.666]                 }
[17:39:52.666]             }
[17:39:52.666]         }))
[17:39:52.666]     }, error = function(ex) {
[17:39:52.666]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.666]                 ...future.rng), started = ...future.startTime, 
[17:39:52.666]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.666]             version = "1.8"), class = "FutureResult")
[17:39:52.666]     }, finally = {
[17:39:52.666]         if (!identical(...future.workdir, getwd())) 
[17:39:52.666]             setwd(...future.workdir)
[17:39:52.666]         {
[17:39:52.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.666]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.666]             }
[17:39:52.666]             base::options(...future.oldOptions)
[17:39:52.666]             if (.Platform$OS.type == "windows") {
[17:39:52.666]                 old_names <- names(...future.oldEnvVars)
[17:39:52.666]                 envs <- base::Sys.getenv()
[17:39:52.666]                 names <- names(envs)
[17:39:52.666]                 common <- intersect(names, old_names)
[17:39:52.666]                 added <- setdiff(names, old_names)
[17:39:52.666]                 removed <- setdiff(old_names, names)
[17:39:52.666]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.666]                   envs[common]]
[17:39:52.666]                 NAMES <- toupper(changed)
[17:39:52.666]                 args <- list()
[17:39:52.666]                 for (kk in seq_along(NAMES)) {
[17:39:52.666]                   name <- changed[[kk]]
[17:39:52.666]                   NAME <- NAMES[[kk]]
[17:39:52.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.666]                     next
[17:39:52.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.666]                 }
[17:39:52.666]                 NAMES <- toupper(added)
[17:39:52.666]                 for (kk in seq_along(NAMES)) {
[17:39:52.666]                   name <- added[[kk]]
[17:39:52.666]                   NAME <- NAMES[[kk]]
[17:39:52.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.666]                     next
[17:39:52.666]                   args[[name]] <- ""
[17:39:52.666]                 }
[17:39:52.666]                 NAMES <- toupper(removed)
[17:39:52.666]                 for (kk in seq_along(NAMES)) {
[17:39:52.666]                   name <- removed[[kk]]
[17:39:52.666]                   NAME <- NAMES[[kk]]
[17:39:52.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.666]                     next
[17:39:52.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.666]                 }
[17:39:52.666]                 if (length(args) > 0) 
[17:39:52.666]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.666]             }
[17:39:52.666]             else {
[17:39:52.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.666]             }
[17:39:52.666]             {
[17:39:52.666]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.666]                   0L) {
[17:39:52.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.666]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.666]                   base::options(opts)
[17:39:52.666]                 }
[17:39:52.666]                 {
[17:39:52.666]                   {
[17:39:52.666]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.666]                     NULL
[17:39:52.666]                   }
[17:39:52.666]                   options(future.plan = NULL)
[17:39:52.666]                   if (is.na(NA_character_)) 
[17:39:52.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.666]                     .init = FALSE)
[17:39:52.666]                 }
[17:39:52.666]             }
[17:39:52.666]         }
[17:39:52.666]     })
[17:39:52.666]     if (TRUE) {
[17:39:52.666]         base::sink(type = "output", split = FALSE)
[17:39:52.666]         if (TRUE) {
[17:39:52.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.666]         }
[17:39:52.666]         else {
[17:39:52.666]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.666]         }
[17:39:52.666]         base::close(...future.stdout)
[17:39:52.666]         ...future.stdout <- NULL
[17:39:52.666]     }
[17:39:52.666]     ...future.result$conditions <- ...future.conditions
[17:39:52.666]     ...future.result$finished <- base::Sys.time()
[17:39:52.666]     ...future.result
[17:39:52.666] }
[17:39:52.669] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.669] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.670] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.670] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.670] MultisessionFuture started
[17:39:52.670] - Launch lazy future ... done
[17:39:52.670] run() for ‘MultisessionFuture’ ... done
[17:39:52.671] result() for ClusterFuture ...
[17:39:52.671] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.671] - Validating connection of MultisessionFuture
[17:39:52.672] - received message: FutureResult
[17:39:52.672] - Received FutureResult
[17:39:52.672] - Erased future from FutureRegistry
[17:39:52.672] result() for ClusterFuture ...
[17:39:52.672] - result already collected: FutureResult
[17:39:52.672] result() for ClusterFuture ... done
[17:39:52.672] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.673] result() for ClusterFuture ... done
[17:39:52.673] result() for ClusterFuture ...
[17:39:52.673] - result already collected: FutureResult
[17:39:52.673] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.673] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.673] Searching for globals...
[17:39:52.676] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.676] Searching for globals ... DONE
[17:39:52.676] Resolving globals: TRUE
[17:39:52.676] Resolving any globals that are futures ...
[17:39:52.676] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.676] Resolving any globals that are futures ... DONE
[17:39:52.677] Resolving futures part of globals (recursively) ...
[17:39:52.677] resolve() on list ...
[17:39:52.677]  recursive: 99
[17:39:52.677]  length: 1
[17:39:52.677]  elements: ‘x’
[17:39:52.678]  length: 0 (resolved future 1)
[17:39:52.678] resolve() on list ... DONE
[17:39:52.678] - globals: [1] ‘x’
[17:39:52.678] Resolving futures part of globals (recursively) ... DONE
[17:39:52.678] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.678] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.679] - globals: [1] ‘x’
[17:39:52.679] 
[17:39:52.679] getGlobalsAndPackages() ... DONE
[17:39:52.679] run() for ‘Future’ ...
[17:39:52.679] - state: ‘created’
[17:39:52.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.694]   - Field: ‘node’
[17:39:52.694]   - Field: ‘label’
[17:39:52.694]   - Field: ‘local’
[17:39:52.694]   - Field: ‘owner’
[17:39:52.694]   - Field: ‘envir’
[17:39:52.694]   - Field: ‘workers’
[17:39:52.694]   - Field: ‘packages’
[17:39:52.694]   - Field: ‘gc’
[17:39:52.695]   - Field: ‘conditions’
[17:39:52.695]   - Field: ‘persistent’
[17:39:52.695]   - Field: ‘expr’
[17:39:52.695]   - Field: ‘uuid’
[17:39:52.695]   - Field: ‘seed’
[17:39:52.695]   - Field: ‘version’
[17:39:52.695]   - Field: ‘result’
[17:39:52.695]   - Field: ‘asynchronous’
[17:39:52.695]   - Field: ‘calls’
[17:39:52.696]   - Field: ‘globals’
[17:39:52.696]   - Field: ‘stdout’
[17:39:52.696]   - Field: ‘earlySignal’
[17:39:52.696]   - Field: ‘lazy’
[17:39:52.696]   - Field: ‘state’
[17:39:52.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.696] - Launch lazy future ...
[17:39:52.697] Packages needed by the future expression (n = 0): <none>
[17:39:52.697] Packages needed by future strategies (n = 0): <none>
[17:39:52.697] {
[17:39:52.697]     {
[17:39:52.697]         {
[17:39:52.697]             ...future.startTime <- base::Sys.time()
[17:39:52.697]             {
[17:39:52.697]                 {
[17:39:52.697]                   {
[17:39:52.697]                     {
[17:39:52.697]                       base::local({
[17:39:52.697]                         has_future <- base::requireNamespace("future", 
[17:39:52.697]                           quietly = TRUE)
[17:39:52.697]                         if (has_future) {
[17:39:52.697]                           ns <- base::getNamespace("future")
[17:39:52.697]                           version <- ns[[".package"]][["version"]]
[17:39:52.697]                           if (is.null(version)) 
[17:39:52.697]                             version <- utils::packageVersion("future")
[17:39:52.697]                         }
[17:39:52.697]                         else {
[17:39:52.697]                           version <- NULL
[17:39:52.697]                         }
[17:39:52.697]                         if (!has_future || version < "1.8.0") {
[17:39:52.697]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.697]                             "", base::R.version$version.string), 
[17:39:52.697]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.697]                               "release", "version")], collapse = " "), 
[17:39:52.697]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.697]                             info)
[17:39:52.697]                           info <- base::paste(info, collapse = "; ")
[17:39:52.697]                           if (!has_future) {
[17:39:52.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.697]                               info)
[17:39:52.697]                           }
[17:39:52.697]                           else {
[17:39:52.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.697]                               info, version)
[17:39:52.697]                           }
[17:39:52.697]                           base::stop(msg)
[17:39:52.697]                         }
[17:39:52.697]                       })
[17:39:52.697]                     }
[17:39:52.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.697]                     base::options(mc.cores = 1L)
[17:39:52.697]                   }
[17:39:52.697]                   ...future.strategy.old <- future::plan("list")
[17:39:52.697]                   options(future.plan = NULL)
[17:39:52.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.697]                 }
[17:39:52.697]                 ...future.workdir <- getwd()
[17:39:52.697]             }
[17:39:52.697]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.697]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.697]         }
[17:39:52.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.697]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.697]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.697]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.697]             base::names(...future.oldOptions))
[17:39:52.697]     }
[17:39:52.697]     if (FALSE) {
[17:39:52.697]     }
[17:39:52.697]     else {
[17:39:52.697]         if (TRUE) {
[17:39:52.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.697]                 open = "w")
[17:39:52.697]         }
[17:39:52.697]         else {
[17:39:52.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.697]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.697]         }
[17:39:52.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.697]             base::sink(type = "output", split = FALSE)
[17:39:52.697]             base::close(...future.stdout)
[17:39:52.697]         }, add = TRUE)
[17:39:52.697]     }
[17:39:52.697]     ...future.frame <- base::sys.nframe()
[17:39:52.697]     ...future.conditions <- base::list()
[17:39:52.697]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.697]     if (FALSE) {
[17:39:52.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.697]     }
[17:39:52.697]     ...future.result <- base::tryCatch({
[17:39:52.697]         base::withCallingHandlers({
[17:39:52.697]             ...future.value <- base::withVisible(base::local({
[17:39:52.697]                 ...future.makeSendCondition <- base::local({
[17:39:52.697]                   sendCondition <- NULL
[17:39:52.697]                   function(frame = 1L) {
[17:39:52.697]                     if (is.function(sendCondition)) 
[17:39:52.697]                       return(sendCondition)
[17:39:52.697]                     ns <- getNamespace("parallel")
[17:39:52.697]                     if (exists("sendData", mode = "function", 
[17:39:52.697]                       envir = ns)) {
[17:39:52.697]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.697]                         envir = ns)
[17:39:52.697]                       envir <- sys.frame(frame)
[17:39:52.697]                       master <- NULL
[17:39:52.697]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.697]                         !identical(envir, emptyenv())) {
[17:39:52.697]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.697]                           inherits = FALSE)) {
[17:39:52.697]                           master <- get("master", mode = "list", 
[17:39:52.697]                             envir = envir, inherits = FALSE)
[17:39:52.697]                           if (inherits(master, c("SOCKnode", 
[17:39:52.697]                             "SOCK0node"))) {
[17:39:52.697]                             sendCondition <<- function(cond) {
[17:39:52.697]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.697]                                 success = TRUE)
[17:39:52.697]                               parallel_sendData(master, data)
[17:39:52.697]                             }
[17:39:52.697]                             return(sendCondition)
[17:39:52.697]                           }
[17:39:52.697]                         }
[17:39:52.697]                         frame <- frame + 1L
[17:39:52.697]                         envir <- sys.frame(frame)
[17:39:52.697]                       }
[17:39:52.697]                     }
[17:39:52.697]                     sendCondition <<- function(cond) NULL
[17:39:52.697]                   }
[17:39:52.697]                 })
[17:39:52.697]                 withCallingHandlers({
[17:39:52.697]                   {
[17:39:52.697]                     x$a <- 1
[17:39:52.697]                     x
[17:39:52.697]                   }
[17:39:52.697]                 }, immediateCondition = function(cond) {
[17:39:52.697]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.697]                   sendCondition(cond)
[17:39:52.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.697]                   {
[17:39:52.697]                     inherits <- base::inherits
[17:39:52.697]                     invokeRestart <- base::invokeRestart
[17:39:52.697]                     is.null <- base::is.null
[17:39:52.697]                     muffled <- FALSE
[17:39:52.697]                     if (inherits(cond, "message")) {
[17:39:52.697]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.697]                       if (muffled) 
[17:39:52.697]                         invokeRestart("muffleMessage")
[17:39:52.697]                     }
[17:39:52.697]                     else if (inherits(cond, "warning")) {
[17:39:52.697]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.697]                       if (muffled) 
[17:39:52.697]                         invokeRestart("muffleWarning")
[17:39:52.697]                     }
[17:39:52.697]                     else if (inherits(cond, "condition")) {
[17:39:52.697]                       if (!is.null(pattern)) {
[17:39:52.697]                         computeRestarts <- base::computeRestarts
[17:39:52.697]                         grepl <- base::grepl
[17:39:52.697]                         restarts <- computeRestarts(cond)
[17:39:52.697]                         for (restart in restarts) {
[17:39:52.697]                           name <- restart$name
[17:39:52.697]                           if (is.null(name)) 
[17:39:52.697]                             next
[17:39:52.697]                           if (!grepl(pattern, name)) 
[17:39:52.697]                             next
[17:39:52.697]                           invokeRestart(restart)
[17:39:52.697]                           muffled <- TRUE
[17:39:52.697]                           break
[17:39:52.697]                         }
[17:39:52.697]                       }
[17:39:52.697]                     }
[17:39:52.697]                     invisible(muffled)
[17:39:52.697]                   }
[17:39:52.697]                   muffleCondition(cond)
[17:39:52.697]                 })
[17:39:52.697]             }))
[17:39:52.697]             future::FutureResult(value = ...future.value$value, 
[17:39:52.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.697]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.697]                     ...future.globalenv.names))
[17:39:52.697]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.697]         }, condition = base::local({
[17:39:52.697]             c <- base::c
[17:39:52.697]             inherits <- base::inherits
[17:39:52.697]             invokeRestart <- base::invokeRestart
[17:39:52.697]             length <- base::length
[17:39:52.697]             list <- base::list
[17:39:52.697]             seq.int <- base::seq.int
[17:39:52.697]             signalCondition <- base::signalCondition
[17:39:52.697]             sys.calls <- base::sys.calls
[17:39:52.697]             `[[` <- base::`[[`
[17:39:52.697]             `+` <- base::`+`
[17:39:52.697]             `<<-` <- base::`<<-`
[17:39:52.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.697]                   3L)]
[17:39:52.697]             }
[17:39:52.697]             function(cond) {
[17:39:52.697]                 is_error <- inherits(cond, "error")
[17:39:52.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.697]                   NULL)
[17:39:52.697]                 if (is_error) {
[17:39:52.697]                   sessionInformation <- function() {
[17:39:52.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.697]                       search = base::search(), system = base::Sys.info())
[17:39:52.697]                   }
[17:39:52.697]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.697]                     cond$call), session = sessionInformation(), 
[17:39:52.697]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.697]                   signalCondition(cond)
[17:39:52.697]                 }
[17:39:52.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.697]                 "immediateCondition"))) {
[17:39:52.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.697]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.697]                   if (TRUE && !signal) {
[17:39:52.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.697]                     {
[17:39:52.697]                       inherits <- base::inherits
[17:39:52.697]                       invokeRestart <- base::invokeRestart
[17:39:52.697]                       is.null <- base::is.null
[17:39:52.697]                       muffled <- FALSE
[17:39:52.697]                       if (inherits(cond, "message")) {
[17:39:52.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.697]                         if (muffled) 
[17:39:52.697]                           invokeRestart("muffleMessage")
[17:39:52.697]                       }
[17:39:52.697]                       else if (inherits(cond, "warning")) {
[17:39:52.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.697]                         if (muffled) 
[17:39:52.697]                           invokeRestart("muffleWarning")
[17:39:52.697]                       }
[17:39:52.697]                       else if (inherits(cond, "condition")) {
[17:39:52.697]                         if (!is.null(pattern)) {
[17:39:52.697]                           computeRestarts <- base::computeRestarts
[17:39:52.697]                           grepl <- base::grepl
[17:39:52.697]                           restarts <- computeRestarts(cond)
[17:39:52.697]                           for (restart in restarts) {
[17:39:52.697]                             name <- restart$name
[17:39:52.697]                             if (is.null(name)) 
[17:39:52.697]                               next
[17:39:52.697]                             if (!grepl(pattern, name)) 
[17:39:52.697]                               next
[17:39:52.697]                             invokeRestart(restart)
[17:39:52.697]                             muffled <- TRUE
[17:39:52.697]                             break
[17:39:52.697]                           }
[17:39:52.697]                         }
[17:39:52.697]                       }
[17:39:52.697]                       invisible(muffled)
[17:39:52.697]                     }
[17:39:52.697]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.697]                   }
[17:39:52.697]                 }
[17:39:52.697]                 else {
[17:39:52.697]                   if (TRUE) {
[17:39:52.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.697]                     {
[17:39:52.697]                       inherits <- base::inherits
[17:39:52.697]                       invokeRestart <- base::invokeRestart
[17:39:52.697]                       is.null <- base::is.null
[17:39:52.697]                       muffled <- FALSE
[17:39:52.697]                       if (inherits(cond, "message")) {
[17:39:52.697]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.697]                         if (muffled) 
[17:39:52.697]                           invokeRestart("muffleMessage")
[17:39:52.697]                       }
[17:39:52.697]                       else if (inherits(cond, "warning")) {
[17:39:52.697]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.697]                         if (muffled) 
[17:39:52.697]                           invokeRestart("muffleWarning")
[17:39:52.697]                       }
[17:39:52.697]                       else if (inherits(cond, "condition")) {
[17:39:52.697]                         if (!is.null(pattern)) {
[17:39:52.697]                           computeRestarts <- base::computeRestarts
[17:39:52.697]                           grepl <- base::grepl
[17:39:52.697]                           restarts <- computeRestarts(cond)
[17:39:52.697]                           for (restart in restarts) {
[17:39:52.697]                             name <- restart$name
[17:39:52.697]                             if (is.null(name)) 
[17:39:52.697]                               next
[17:39:52.697]                             if (!grepl(pattern, name)) 
[17:39:52.697]                               next
[17:39:52.697]                             invokeRestart(restart)
[17:39:52.697]                             muffled <- TRUE
[17:39:52.697]                             break
[17:39:52.697]                           }
[17:39:52.697]                         }
[17:39:52.697]                       }
[17:39:52.697]                       invisible(muffled)
[17:39:52.697]                     }
[17:39:52.697]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.697]                   }
[17:39:52.697]                 }
[17:39:52.697]             }
[17:39:52.697]         }))
[17:39:52.697]     }, error = function(ex) {
[17:39:52.697]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.697]                 ...future.rng), started = ...future.startTime, 
[17:39:52.697]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.697]             version = "1.8"), class = "FutureResult")
[17:39:52.697]     }, finally = {
[17:39:52.697]         if (!identical(...future.workdir, getwd())) 
[17:39:52.697]             setwd(...future.workdir)
[17:39:52.697]         {
[17:39:52.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.697]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.697]             }
[17:39:52.697]             base::options(...future.oldOptions)
[17:39:52.697]             if (.Platform$OS.type == "windows") {
[17:39:52.697]                 old_names <- names(...future.oldEnvVars)
[17:39:52.697]                 envs <- base::Sys.getenv()
[17:39:52.697]                 names <- names(envs)
[17:39:52.697]                 common <- intersect(names, old_names)
[17:39:52.697]                 added <- setdiff(names, old_names)
[17:39:52.697]                 removed <- setdiff(old_names, names)
[17:39:52.697]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.697]                   envs[common]]
[17:39:52.697]                 NAMES <- toupper(changed)
[17:39:52.697]                 args <- list()
[17:39:52.697]                 for (kk in seq_along(NAMES)) {
[17:39:52.697]                   name <- changed[[kk]]
[17:39:52.697]                   NAME <- NAMES[[kk]]
[17:39:52.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.697]                     next
[17:39:52.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.697]                 }
[17:39:52.697]                 NAMES <- toupper(added)
[17:39:52.697]                 for (kk in seq_along(NAMES)) {
[17:39:52.697]                   name <- added[[kk]]
[17:39:52.697]                   NAME <- NAMES[[kk]]
[17:39:52.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.697]                     next
[17:39:52.697]                   args[[name]] <- ""
[17:39:52.697]                 }
[17:39:52.697]                 NAMES <- toupper(removed)
[17:39:52.697]                 for (kk in seq_along(NAMES)) {
[17:39:52.697]                   name <- removed[[kk]]
[17:39:52.697]                   NAME <- NAMES[[kk]]
[17:39:52.697]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.697]                     next
[17:39:52.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.697]                 }
[17:39:52.697]                 if (length(args) > 0) 
[17:39:52.697]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.697]             }
[17:39:52.697]             else {
[17:39:52.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.697]             }
[17:39:52.697]             {
[17:39:52.697]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.697]                   0L) {
[17:39:52.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.697]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.697]                   base::options(opts)
[17:39:52.697]                 }
[17:39:52.697]                 {
[17:39:52.697]                   {
[17:39:52.697]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.697]                     NULL
[17:39:52.697]                   }
[17:39:52.697]                   options(future.plan = NULL)
[17:39:52.697]                   if (is.na(NA_character_)) 
[17:39:52.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.697]                     .init = FALSE)
[17:39:52.697]                 }
[17:39:52.697]             }
[17:39:52.697]         }
[17:39:52.697]     })
[17:39:52.697]     if (TRUE) {
[17:39:52.697]         base::sink(type = "output", split = FALSE)
[17:39:52.697]         if (TRUE) {
[17:39:52.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.697]         }
[17:39:52.697]         else {
[17:39:52.697]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.697]         }
[17:39:52.697]         base::close(...future.stdout)
[17:39:52.697]         ...future.stdout <- NULL
[17:39:52.697]     }
[17:39:52.697]     ...future.result$conditions <- ...future.conditions
[17:39:52.697]     ...future.result$finished <- base::Sys.time()
[17:39:52.697]     ...future.result
[17:39:52.697] }
[17:39:52.700] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.700] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.701] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.701] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.701] MultisessionFuture started
[17:39:52.701] - Launch lazy future ... done
[17:39:52.701] run() for ‘MultisessionFuture’ ... done
[17:39:52.702] result() for ClusterFuture ...
[17:39:52.702] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.702] - Validating connection of MultisessionFuture
[17:39:52.706] - received message: FutureResult
[17:39:52.706] - Received FutureResult
[17:39:52.706] - Erased future from FutureRegistry
[17:39:52.706] result() for ClusterFuture ...
[17:39:52.707] - result already collected: FutureResult
[17:39:52.707] result() for ClusterFuture ... done
[17:39:52.707] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.707] result() for ClusterFuture ... done
[17:39:52.707] result() for ClusterFuture ...
[17:39:52.707] - result already collected: FutureResult
[17:39:52.707] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.708] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.708] Searching for globals...
[17:39:52.710] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.711] Searching for globals ... DONE
[17:39:52.711] Resolving globals: TRUE
[17:39:52.711] Resolving any globals that are futures ...
[17:39:52.711] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.711] Resolving any globals that are futures ... DONE
[17:39:52.711] Resolving futures part of globals (recursively) ...
[17:39:52.712] resolve() on list ...
[17:39:52.712]  recursive: 99
[17:39:52.712]  length: 1
[17:39:52.712]  elements: ‘x’
[17:39:52.712]  length: 0 (resolved future 1)
[17:39:52.712] resolve() on list ... DONE
[17:39:52.712] - globals: [1] ‘x’
[17:39:52.713] Resolving futures part of globals (recursively) ... DONE
[17:39:52.713] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.713] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.713] - globals: [1] ‘x’
[17:39:52.713] 
[17:39:52.713] getGlobalsAndPackages() ... DONE
[17:39:52.714] run() for ‘Future’ ...
[17:39:52.714] - state: ‘created’
[17:39:52.714] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.731] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.731] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.731]   - Field: ‘node’
[17:39:52.731]   - Field: ‘label’
[17:39:52.731]   - Field: ‘local’
[17:39:52.731]   - Field: ‘owner’
[17:39:52.731]   - Field: ‘envir’
[17:39:52.731]   - Field: ‘workers’
[17:39:52.731]   - Field: ‘packages’
[17:39:52.731]   - Field: ‘gc’
[17:39:52.732]   - Field: ‘conditions’
[17:39:52.732]   - Field: ‘persistent’
[17:39:52.732]   - Field: ‘expr’
[17:39:52.732]   - Field: ‘uuid’
[17:39:52.732]   - Field: ‘seed’
[17:39:52.732]   - Field: ‘version’
[17:39:52.732]   - Field: ‘result’
[17:39:52.732]   - Field: ‘asynchronous’
[17:39:52.732]   - Field: ‘calls’
[17:39:52.732]   - Field: ‘globals’
[17:39:52.732]   - Field: ‘stdout’
[17:39:52.732]   - Field: ‘earlySignal’
[17:39:52.733]   - Field: ‘lazy’
[17:39:52.733]   - Field: ‘state’
[17:39:52.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.733] - Launch lazy future ...
[17:39:52.733] Packages needed by the future expression (n = 0): <none>
[17:39:52.733] Packages needed by future strategies (n = 0): <none>
[17:39:52.734] {
[17:39:52.734]     {
[17:39:52.734]         {
[17:39:52.734]             ...future.startTime <- base::Sys.time()
[17:39:52.734]             {
[17:39:52.734]                 {
[17:39:52.734]                   {
[17:39:52.734]                     {
[17:39:52.734]                       base::local({
[17:39:52.734]                         has_future <- base::requireNamespace("future", 
[17:39:52.734]                           quietly = TRUE)
[17:39:52.734]                         if (has_future) {
[17:39:52.734]                           ns <- base::getNamespace("future")
[17:39:52.734]                           version <- ns[[".package"]][["version"]]
[17:39:52.734]                           if (is.null(version)) 
[17:39:52.734]                             version <- utils::packageVersion("future")
[17:39:52.734]                         }
[17:39:52.734]                         else {
[17:39:52.734]                           version <- NULL
[17:39:52.734]                         }
[17:39:52.734]                         if (!has_future || version < "1.8.0") {
[17:39:52.734]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.734]                             "", base::R.version$version.string), 
[17:39:52.734]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.734]                               "release", "version")], collapse = " "), 
[17:39:52.734]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.734]                             info)
[17:39:52.734]                           info <- base::paste(info, collapse = "; ")
[17:39:52.734]                           if (!has_future) {
[17:39:52.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.734]                               info)
[17:39:52.734]                           }
[17:39:52.734]                           else {
[17:39:52.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.734]                               info, version)
[17:39:52.734]                           }
[17:39:52.734]                           base::stop(msg)
[17:39:52.734]                         }
[17:39:52.734]                       })
[17:39:52.734]                     }
[17:39:52.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.734]                     base::options(mc.cores = 1L)
[17:39:52.734]                   }
[17:39:52.734]                   ...future.strategy.old <- future::plan("list")
[17:39:52.734]                   options(future.plan = NULL)
[17:39:52.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.734]                 }
[17:39:52.734]                 ...future.workdir <- getwd()
[17:39:52.734]             }
[17:39:52.734]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.734]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.734]         }
[17:39:52.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.734]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.734]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.734]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.734]             base::names(...future.oldOptions))
[17:39:52.734]     }
[17:39:52.734]     if (FALSE) {
[17:39:52.734]     }
[17:39:52.734]     else {
[17:39:52.734]         if (TRUE) {
[17:39:52.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.734]                 open = "w")
[17:39:52.734]         }
[17:39:52.734]         else {
[17:39:52.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.734]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.734]         }
[17:39:52.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.734]             base::sink(type = "output", split = FALSE)
[17:39:52.734]             base::close(...future.stdout)
[17:39:52.734]         }, add = TRUE)
[17:39:52.734]     }
[17:39:52.734]     ...future.frame <- base::sys.nframe()
[17:39:52.734]     ...future.conditions <- base::list()
[17:39:52.734]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.734]     if (FALSE) {
[17:39:52.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.734]     }
[17:39:52.734]     ...future.result <- base::tryCatch({
[17:39:52.734]         base::withCallingHandlers({
[17:39:52.734]             ...future.value <- base::withVisible(base::local({
[17:39:52.734]                 ...future.makeSendCondition <- base::local({
[17:39:52.734]                   sendCondition <- NULL
[17:39:52.734]                   function(frame = 1L) {
[17:39:52.734]                     if (is.function(sendCondition)) 
[17:39:52.734]                       return(sendCondition)
[17:39:52.734]                     ns <- getNamespace("parallel")
[17:39:52.734]                     if (exists("sendData", mode = "function", 
[17:39:52.734]                       envir = ns)) {
[17:39:52.734]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.734]                         envir = ns)
[17:39:52.734]                       envir <- sys.frame(frame)
[17:39:52.734]                       master <- NULL
[17:39:52.734]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.734]                         !identical(envir, emptyenv())) {
[17:39:52.734]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.734]                           inherits = FALSE)) {
[17:39:52.734]                           master <- get("master", mode = "list", 
[17:39:52.734]                             envir = envir, inherits = FALSE)
[17:39:52.734]                           if (inherits(master, c("SOCKnode", 
[17:39:52.734]                             "SOCK0node"))) {
[17:39:52.734]                             sendCondition <<- function(cond) {
[17:39:52.734]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.734]                                 success = TRUE)
[17:39:52.734]                               parallel_sendData(master, data)
[17:39:52.734]                             }
[17:39:52.734]                             return(sendCondition)
[17:39:52.734]                           }
[17:39:52.734]                         }
[17:39:52.734]                         frame <- frame + 1L
[17:39:52.734]                         envir <- sys.frame(frame)
[17:39:52.734]                       }
[17:39:52.734]                     }
[17:39:52.734]                     sendCondition <<- function(cond) NULL
[17:39:52.734]                   }
[17:39:52.734]                 })
[17:39:52.734]                 withCallingHandlers({
[17:39:52.734]                   {
[17:39:52.734]                     x$a <- 1
[17:39:52.734]                     x
[17:39:52.734]                   }
[17:39:52.734]                 }, immediateCondition = function(cond) {
[17:39:52.734]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.734]                   sendCondition(cond)
[17:39:52.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.734]                   {
[17:39:52.734]                     inherits <- base::inherits
[17:39:52.734]                     invokeRestart <- base::invokeRestart
[17:39:52.734]                     is.null <- base::is.null
[17:39:52.734]                     muffled <- FALSE
[17:39:52.734]                     if (inherits(cond, "message")) {
[17:39:52.734]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.734]                       if (muffled) 
[17:39:52.734]                         invokeRestart("muffleMessage")
[17:39:52.734]                     }
[17:39:52.734]                     else if (inherits(cond, "warning")) {
[17:39:52.734]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.734]                       if (muffled) 
[17:39:52.734]                         invokeRestart("muffleWarning")
[17:39:52.734]                     }
[17:39:52.734]                     else if (inherits(cond, "condition")) {
[17:39:52.734]                       if (!is.null(pattern)) {
[17:39:52.734]                         computeRestarts <- base::computeRestarts
[17:39:52.734]                         grepl <- base::grepl
[17:39:52.734]                         restarts <- computeRestarts(cond)
[17:39:52.734]                         for (restart in restarts) {
[17:39:52.734]                           name <- restart$name
[17:39:52.734]                           if (is.null(name)) 
[17:39:52.734]                             next
[17:39:52.734]                           if (!grepl(pattern, name)) 
[17:39:52.734]                             next
[17:39:52.734]                           invokeRestart(restart)
[17:39:52.734]                           muffled <- TRUE
[17:39:52.734]                           break
[17:39:52.734]                         }
[17:39:52.734]                       }
[17:39:52.734]                     }
[17:39:52.734]                     invisible(muffled)
[17:39:52.734]                   }
[17:39:52.734]                   muffleCondition(cond)
[17:39:52.734]                 })
[17:39:52.734]             }))
[17:39:52.734]             future::FutureResult(value = ...future.value$value, 
[17:39:52.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.734]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.734]                     ...future.globalenv.names))
[17:39:52.734]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.734]         }, condition = base::local({
[17:39:52.734]             c <- base::c
[17:39:52.734]             inherits <- base::inherits
[17:39:52.734]             invokeRestart <- base::invokeRestart
[17:39:52.734]             length <- base::length
[17:39:52.734]             list <- base::list
[17:39:52.734]             seq.int <- base::seq.int
[17:39:52.734]             signalCondition <- base::signalCondition
[17:39:52.734]             sys.calls <- base::sys.calls
[17:39:52.734]             `[[` <- base::`[[`
[17:39:52.734]             `+` <- base::`+`
[17:39:52.734]             `<<-` <- base::`<<-`
[17:39:52.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.734]                   3L)]
[17:39:52.734]             }
[17:39:52.734]             function(cond) {
[17:39:52.734]                 is_error <- inherits(cond, "error")
[17:39:52.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.734]                   NULL)
[17:39:52.734]                 if (is_error) {
[17:39:52.734]                   sessionInformation <- function() {
[17:39:52.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.734]                       search = base::search(), system = base::Sys.info())
[17:39:52.734]                   }
[17:39:52.734]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.734]                     cond$call), session = sessionInformation(), 
[17:39:52.734]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.734]                   signalCondition(cond)
[17:39:52.734]                 }
[17:39:52.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.734]                 "immediateCondition"))) {
[17:39:52.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.734]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.734]                   if (TRUE && !signal) {
[17:39:52.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.734]                     {
[17:39:52.734]                       inherits <- base::inherits
[17:39:52.734]                       invokeRestart <- base::invokeRestart
[17:39:52.734]                       is.null <- base::is.null
[17:39:52.734]                       muffled <- FALSE
[17:39:52.734]                       if (inherits(cond, "message")) {
[17:39:52.734]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.734]                         if (muffled) 
[17:39:52.734]                           invokeRestart("muffleMessage")
[17:39:52.734]                       }
[17:39:52.734]                       else if (inherits(cond, "warning")) {
[17:39:52.734]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.734]                         if (muffled) 
[17:39:52.734]                           invokeRestart("muffleWarning")
[17:39:52.734]                       }
[17:39:52.734]                       else if (inherits(cond, "condition")) {
[17:39:52.734]                         if (!is.null(pattern)) {
[17:39:52.734]                           computeRestarts <- base::computeRestarts
[17:39:52.734]                           grepl <- base::grepl
[17:39:52.734]                           restarts <- computeRestarts(cond)
[17:39:52.734]                           for (restart in restarts) {
[17:39:52.734]                             name <- restart$name
[17:39:52.734]                             if (is.null(name)) 
[17:39:52.734]                               next
[17:39:52.734]                             if (!grepl(pattern, name)) 
[17:39:52.734]                               next
[17:39:52.734]                             invokeRestart(restart)
[17:39:52.734]                             muffled <- TRUE
[17:39:52.734]                             break
[17:39:52.734]                           }
[17:39:52.734]                         }
[17:39:52.734]                       }
[17:39:52.734]                       invisible(muffled)
[17:39:52.734]                     }
[17:39:52.734]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.734]                   }
[17:39:52.734]                 }
[17:39:52.734]                 else {
[17:39:52.734]                   if (TRUE) {
[17:39:52.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.734]                     {
[17:39:52.734]                       inherits <- base::inherits
[17:39:52.734]                       invokeRestart <- base::invokeRestart
[17:39:52.734]                       is.null <- base::is.null
[17:39:52.734]                       muffled <- FALSE
[17:39:52.734]                       if (inherits(cond, "message")) {
[17:39:52.734]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.734]                         if (muffled) 
[17:39:52.734]                           invokeRestart("muffleMessage")
[17:39:52.734]                       }
[17:39:52.734]                       else if (inherits(cond, "warning")) {
[17:39:52.734]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.734]                         if (muffled) 
[17:39:52.734]                           invokeRestart("muffleWarning")
[17:39:52.734]                       }
[17:39:52.734]                       else if (inherits(cond, "condition")) {
[17:39:52.734]                         if (!is.null(pattern)) {
[17:39:52.734]                           computeRestarts <- base::computeRestarts
[17:39:52.734]                           grepl <- base::grepl
[17:39:52.734]                           restarts <- computeRestarts(cond)
[17:39:52.734]                           for (restart in restarts) {
[17:39:52.734]                             name <- restart$name
[17:39:52.734]                             if (is.null(name)) 
[17:39:52.734]                               next
[17:39:52.734]                             if (!grepl(pattern, name)) 
[17:39:52.734]                               next
[17:39:52.734]                             invokeRestart(restart)
[17:39:52.734]                             muffled <- TRUE
[17:39:52.734]                             break
[17:39:52.734]                           }
[17:39:52.734]                         }
[17:39:52.734]                       }
[17:39:52.734]                       invisible(muffled)
[17:39:52.734]                     }
[17:39:52.734]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.734]                   }
[17:39:52.734]                 }
[17:39:52.734]             }
[17:39:52.734]         }))
[17:39:52.734]     }, error = function(ex) {
[17:39:52.734]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.734]                 ...future.rng), started = ...future.startTime, 
[17:39:52.734]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.734]             version = "1.8"), class = "FutureResult")
[17:39:52.734]     }, finally = {
[17:39:52.734]         if (!identical(...future.workdir, getwd())) 
[17:39:52.734]             setwd(...future.workdir)
[17:39:52.734]         {
[17:39:52.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.734]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.734]             }
[17:39:52.734]             base::options(...future.oldOptions)
[17:39:52.734]             if (.Platform$OS.type == "windows") {
[17:39:52.734]                 old_names <- names(...future.oldEnvVars)
[17:39:52.734]                 envs <- base::Sys.getenv()
[17:39:52.734]                 names <- names(envs)
[17:39:52.734]                 common <- intersect(names, old_names)
[17:39:52.734]                 added <- setdiff(names, old_names)
[17:39:52.734]                 removed <- setdiff(old_names, names)
[17:39:52.734]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.734]                   envs[common]]
[17:39:52.734]                 NAMES <- toupper(changed)
[17:39:52.734]                 args <- list()
[17:39:52.734]                 for (kk in seq_along(NAMES)) {
[17:39:52.734]                   name <- changed[[kk]]
[17:39:52.734]                   NAME <- NAMES[[kk]]
[17:39:52.734]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.734]                     next
[17:39:52.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.734]                 }
[17:39:52.734]                 NAMES <- toupper(added)
[17:39:52.734]                 for (kk in seq_along(NAMES)) {
[17:39:52.734]                   name <- added[[kk]]
[17:39:52.734]                   NAME <- NAMES[[kk]]
[17:39:52.734]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.734]                     next
[17:39:52.734]                   args[[name]] <- ""
[17:39:52.734]                 }
[17:39:52.734]                 NAMES <- toupper(removed)
[17:39:52.734]                 for (kk in seq_along(NAMES)) {
[17:39:52.734]                   name <- removed[[kk]]
[17:39:52.734]                   NAME <- NAMES[[kk]]
[17:39:52.734]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.734]                     next
[17:39:52.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.734]                 }
[17:39:52.734]                 if (length(args) > 0) 
[17:39:52.734]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.734]             }
[17:39:52.734]             else {
[17:39:52.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.734]             }
[17:39:52.734]             {
[17:39:52.734]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.734]                   0L) {
[17:39:52.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.734]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.734]                   base::options(opts)
[17:39:52.734]                 }
[17:39:52.734]                 {
[17:39:52.734]                   {
[17:39:52.734]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.734]                     NULL
[17:39:52.734]                   }
[17:39:52.734]                   options(future.plan = NULL)
[17:39:52.734]                   if (is.na(NA_character_)) 
[17:39:52.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.734]                     .init = FALSE)
[17:39:52.734]                 }
[17:39:52.734]             }
[17:39:52.734]         }
[17:39:52.734]     })
[17:39:52.734]     if (TRUE) {
[17:39:52.734]         base::sink(type = "output", split = FALSE)
[17:39:52.734]         if (TRUE) {
[17:39:52.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.734]         }
[17:39:52.734]         else {
[17:39:52.734]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.734]         }
[17:39:52.734]         base::close(...future.stdout)
[17:39:52.734]         ...future.stdout <- NULL
[17:39:52.734]     }
[17:39:52.734]     ...future.result$conditions <- ...future.conditions
[17:39:52.734]     ...future.result$finished <- base::Sys.time()
[17:39:52.734]     ...future.result
[17:39:52.734] }
[17:39:52.736] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.736] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.737] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.737] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.737] MultisessionFuture started
[17:39:52.737] - Launch lazy future ... done
[17:39:52.737] run() for ‘MultisessionFuture’ ... done
[17:39:52.737] result() for ClusterFuture ...
[17:39:52.738] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.738] - Validating connection of MultisessionFuture
[17:39:52.739] - received message: FutureResult
[17:39:52.739] - Received FutureResult
[17:39:52.739] - Erased future from FutureRegistry
[17:39:52.739] result() for ClusterFuture ...
[17:39:52.739] - result already collected: FutureResult
[17:39:52.739] result() for ClusterFuture ... done
[17:39:52.739] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.739] result() for ClusterFuture ... done
[17:39:52.739] result() for ClusterFuture ...
[17:39:52.739] - result already collected: FutureResult
[17:39:52.739] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.740] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.740] Searching for globals...
[17:39:52.742] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.742] Searching for globals ... DONE
[17:39:52.742] Resolving globals: TRUE
[17:39:52.742] Resolving any globals that are futures ...
[17:39:52.742] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:39:52.742] Resolving any globals that are futures ... DONE
[17:39:52.743] Resolving futures part of globals (recursively) ...
[17:39:52.743] resolve() on list ...
[17:39:52.743]  recursive: 99
[17:39:52.743]  length: 1
[17:39:52.743]  elements: ‘x’
[17:39:52.743]  length: 0 (resolved future 1)
[17:39:52.743] resolve() on list ... DONE
[17:39:52.743] - globals: [1] ‘x’
[17:39:52.743] Resolving futures part of globals (recursively) ... DONE
[17:39:52.744] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.744] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.744] - globals: [1] ‘x’
[17:39:52.744] 
[17:39:52.744] getGlobalsAndPackages() ... DONE
[17:39:52.744] run() for ‘Future’ ...
[17:39:52.745] - state: ‘created’
[17:39:52.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.758] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.758]   - Field: ‘node’
[17:39:52.758]   - Field: ‘label’
[17:39:52.758]   - Field: ‘local’
[17:39:52.758]   - Field: ‘owner’
[17:39:52.758]   - Field: ‘envir’
[17:39:52.758]   - Field: ‘workers’
[17:39:52.758]   - Field: ‘packages’
[17:39:52.758]   - Field: ‘gc’
[17:39:52.759]   - Field: ‘conditions’
[17:39:52.759]   - Field: ‘persistent’
[17:39:52.759]   - Field: ‘expr’
[17:39:52.759]   - Field: ‘uuid’
[17:39:52.759]   - Field: ‘seed’
[17:39:52.759]   - Field: ‘version’
[17:39:52.759]   - Field: ‘result’
[17:39:52.759]   - Field: ‘asynchronous’
[17:39:52.759]   - Field: ‘calls’
[17:39:52.759]   - Field: ‘globals’
[17:39:52.759]   - Field: ‘stdout’
[17:39:52.759]   - Field: ‘earlySignal’
[17:39:52.760]   - Field: ‘lazy’
[17:39:52.760]   - Field: ‘state’
[17:39:52.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.760] - Launch lazy future ...
[17:39:52.760] Packages needed by the future expression (n = 0): <none>
[17:39:52.760] Packages needed by future strategies (n = 0): <none>
[17:39:52.761] {
[17:39:52.761]     {
[17:39:52.761]         {
[17:39:52.761]             ...future.startTime <- base::Sys.time()
[17:39:52.761]             {
[17:39:52.761]                 {
[17:39:52.761]                   {
[17:39:52.761]                     {
[17:39:52.761]                       base::local({
[17:39:52.761]                         has_future <- base::requireNamespace("future", 
[17:39:52.761]                           quietly = TRUE)
[17:39:52.761]                         if (has_future) {
[17:39:52.761]                           ns <- base::getNamespace("future")
[17:39:52.761]                           version <- ns[[".package"]][["version"]]
[17:39:52.761]                           if (is.null(version)) 
[17:39:52.761]                             version <- utils::packageVersion("future")
[17:39:52.761]                         }
[17:39:52.761]                         else {
[17:39:52.761]                           version <- NULL
[17:39:52.761]                         }
[17:39:52.761]                         if (!has_future || version < "1.8.0") {
[17:39:52.761]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.761]                             "", base::R.version$version.string), 
[17:39:52.761]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.761]                               "release", "version")], collapse = " "), 
[17:39:52.761]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.761]                             info)
[17:39:52.761]                           info <- base::paste(info, collapse = "; ")
[17:39:52.761]                           if (!has_future) {
[17:39:52.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.761]                               info)
[17:39:52.761]                           }
[17:39:52.761]                           else {
[17:39:52.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.761]                               info, version)
[17:39:52.761]                           }
[17:39:52.761]                           base::stop(msg)
[17:39:52.761]                         }
[17:39:52.761]                       })
[17:39:52.761]                     }
[17:39:52.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.761]                     base::options(mc.cores = 1L)
[17:39:52.761]                   }
[17:39:52.761]                   ...future.strategy.old <- future::plan("list")
[17:39:52.761]                   options(future.plan = NULL)
[17:39:52.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.761]                 }
[17:39:52.761]                 ...future.workdir <- getwd()
[17:39:52.761]             }
[17:39:52.761]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.761]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.761]         }
[17:39:52.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.761]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.761]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.761]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.761]             base::names(...future.oldOptions))
[17:39:52.761]     }
[17:39:52.761]     if (FALSE) {
[17:39:52.761]     }
[17:39:52.761]     else {
[17:39:52.761]         if (TRUE) {
[17:39:52.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.761]                 open = "w")
[17:39:52.761]         }
[17:39:52.761]         else {
[17:39:52.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.761]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.761]         }
[17:39:52.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.761]             base::sink(type = "output", split = FALSE)
[17:39:52.761]             base::close(...future.stdout)
[17:39:52.761]         }, add = TRUE)
[17:39:52.761]     }
[17:39:52.761]     ...future.frame <- base::sys.nframe()
[17:39:52.761]     ...future.conditions <- base::list()
[17:39:52.761]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.761]     if (FALSE) {
[17:39:52.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.761]     }
[17:39:52.761]     ...future.result <- base::tryCatch({
[17:39:52.761]         base::withCallingHandlers({
[17:39:52.761]             ...future.value <- base::withVisible(base::local({
[17:39:52.761]                 ...future.makeSendCondition <- base::local({
[17:39:52.761]                   sendCondition <- NULL
[17:39:52.761]                   function(frame = 1L) {
[17:39:52.761]                     if (is.function(sendCondition)) 
[17:39:52.761]                       return(sendCondition)
[17:39:52.761]                     ns <- getNamespace("parallel")
[17:39:52.761]                     if (exists("sendData", mode = "function", 
[17:39:52.761]                       envir = ns)) {
[17:39:52.761]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.761]                         envir = ns)
[17:39:52.761]                       envir <- sys.frame(frame)
[17:39:52.761]                       master <- NULL
[17:39:52.761]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.761]                         !identical(envir, emptyenv())) {
[17:39:52.761]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.761]                           inherits = FALSE)) {
[17:39:52.761]                           master <- get("master", mode = "list", 
[17:39:52.761]                             envir = envir, inherits = FALSE)
[17:39:52.761]                           if (inherits(master, c("SOCKnode", 
[17:39:52.761]                             "SOCK0node"))) {
[17:39:52.761]                             sendCondition <<- function(cond) {
[17:39:52.761]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.761]                                 success = TRUE)
[17:39:52.761]                               parallel_sendData(master, data)
[17:39:52.761]                             }
[17:39:52.761]                             return(sendCondition)
[17:39:52.761]                           }
[17:39:52.761]                         }
[17:39:52.761]                         frame <- frame + 1L
[17:39:52.761]                         envir <- sys.frame(frame)
[17:39:52.761]                       }
[17:39:52.761]                     }
[17:39:52.761]                     sendCondition <<- function(cond) NULL
[17:39:52.761]                   }
[17:39:52.761]                 })
[17:39:52.761]                 withCallingHandlers({
[17:39:52.761]                   {
[17:39:52.761]                     x$a <- 1
[17:39:52.761]                     x
[17:39:52.761]                   }
[17:39:52.761]                 }, immediateCondition = function(cond) {
[17:39:52.761]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.761]                   sendCondition(cond)
[17:39:52.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.761]                   {
[17:39:52.761]                     inherits <- base::inherits
[17:39:52.761]                     invokeRestart <- base::invokeRestart
[17:39:52.761]                     is.null <- base::is.null
[17:39:52.761]                     muffled <- FALSE
[17:39:52.761]                     if (inherits(cond, "message")) {
[17:39:52.761]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.761]                       if (muffled) 
[17:39:52.761]                         invokeRestart("muffleMessage")
[17:39:52.761]                     }
[17:39:52.761]                     else if (inherits(cond, "warning")) {
[17:39:52.761]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.761]                       if (muffled) 
[17:39:52.761]                         invokeRestart("muffleWarning")
[17:39:52.761]                     }
[17:39:52.761]                     else if (inherits(cond, "condition")) {
[17:39:52.761]                       if (!is.null(pattern)) {
[17:39:52.761]                         computeRestarts <- base::computeRestarts
[17:39:52.761]                         grepl <- base::grepl
[17:39:52.761]                         restarts <- computeRestarts(cond)
[17:39:52.761]                         for (restart in restarts) {
[17:39:52.761]                           name <- restart$name
[17:39:52.761]                           if (is.null(name)) 
[17:39:52.761]                             next
[17:39:52.761]                           if (!grepl(pattern, name)) 
[17:39:52.761]                             next
[17:39:52.761]                           invokeRestart(restart)
[17:39:52.761]                           muffled <- TRUE
[17:39:52.761]                           break
[17:39:52.761]                         }
[17:39:52.761]                       }
[17:39:52.761]                     }
[17:39:52.761]                     invisible(muffled)
[17:39:52.761]                   }
[17:39:52.761]                   muffleCondition(cond)
[17:39:52.761]                 })
[17:39:52.761]             }))
[17:39:52.761]             future::FutureResult(value = ...future.value$value, 
[17:39:52.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.761]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.761]                     ...future.globalenv.names))
[17:39:52.761]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.761]         }, condition = base::local({
[17:39:52.761]             c <- base::c
[17:39:52.761]             inherits <- base::inherits
[17:39:52.761]             invokeRestart <- base::invokeRestart
[17:39:52.761]             length <- base::length
[17:39:52.761]             list <- base::list
[17:39:52.761]             seq.int <- base::seq.int
[17:39:52.761]             signalCondition <- base::signalCondition
[17:39:52.761]             sys.calls <- base::sys.calls
[17:39:52.761]             `[[` <- base::`[[`
[17:39:52.761]             `+` <- base::`+`
[17:39:52.761]             `<<-` <- base::`<<-`
[17:39:52.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.761]                   3L)]
[17:39:52.761]             }
[17:39:52.761]             function(cond) {
[17:39:52.761]                 is_error <- inherits(cond, "error")
[17:39:52.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.761]                   NULL)
[17:39:52.761]                 if (is_error) {
[17:39:52.761]                   sessionInformation <- function() {
[17:39:52.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.761]                       search = base::search(), system = base::Sys.info())
[17:39:52.761]                   }
[17:39:52.761]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.761]                     cond$call), session = sessionInformation(), 
[17:39:52.761]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.761]                   signalCondition(cond)
[17:39:52.761]                 }
[17:39:52.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.761]                 "immediateCondition"))) {
[17:39:52.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.761]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.761]                   if (TRUE && !signal) {
[17:39:52.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.761]                     {
[17:39:52.761]                       inherits <- base::inherits
[17:39:52.761]                       invokeRestart <- base::invokeRestart
[17:39:52.761]                       is.null <- base::is.null
[17:39:52.761]                       muffled <- FALSE
[17:39:52.761]                       if (inherits(cond, "message")) {
[17:39:52.761]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.761]                         if (muffled) 
[17:39:52.761]                           invokeRestart("muffleMessage")
[17:39:52.761]                       }
[17:39:52.761]                       else if (inherits(cond, "warning")) {
[17:39:52.761]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.761]                         if (muffled) 
[17:39:52.761]                           invokeRestart("muffleWarning")
[17:39:52.761]                       }
[17:39:52.761]                       else if (inherits(cond, "condition")) {
[17:39:52.761]                         if (!is.null(pattern)) {
[17:39:52.761]                           computeRestarts <- base::computeRestarts
[17:39:52.761]                           grepl <- base::grepl
[17:39:52.761]                           restarts <- computeRestarts(cond)
[17:39:52.761]                           for (restart in restarts) {
[17:39:52.761]                             name <- restart$name
[17:39:52.761]                             if (is.null(name)) 
[17:39:52.761]                               next
[17:39:52.761]                             if (!grepl(pattern, name)) 
[17:39:52.761]                               next
[17:39:52.761]                             invokeRestart(restart)
[17:39:52.761]                             muffled <- TRUE
[17:39:52.761]                             break
[17:39:52.761]                           }
[17:39:52.761]                         }
[17:39:52.761]                       }
[17:39:52.761]                       invisible(muffled)
[17:39:52.761]                     }
[17:39:52.761]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.761]                   }
[17:39:52.761]                 }
[17:39:52.761]                 else {
[17:39:52.761]                   if (TRUE) {
[17:39:52.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.761]                     {
[17:39:52.761]                       inherits <- base::inherits
[17:39:52.761]                       invokeRestart <- base::invokeRestart
[17:39:52.761]                       is.null <- base::is.null
[17:39:52.761]                       muffled <- FALSE
[17:39:52.761]                       if (inherits(cond, "message")) {
[17:39:52.761]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.761]                         if (muffled) 
[17:39:52.761]                           invokeRestart("muffleMessage")
[17:39:52.761]                       }
[17:39:52.761]                       else if (inherits(cond, "warning")) {
[17:39:52.761]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.761]                         if (muffled) 
[17:39:52.761]                           invokeRestart("muffleWarning")
[17:39:52.761]                       }
[17:39:52.761]                       else if (inherits(cond, "condition")) {
[17:39:52.761]                         if (!is.null(pattern)) {
[17:39:52.761]                           computeRestarts <- base::computeRestarts
[17:39:52.761]                           grepl <- base::grepl
[17:39:52.761]                           restarts <- computeRestarts(cond)
[17:39:52.761]                           for (restart in restarts) {
[17:39:52.761]                             name <- restart$name
[17:39:52.761]                             if (is.null(name)) 
[17:39:52.761]                               next
[17:39:52.761]                             if (!grepl(pattern, name)) 
[17:39:52.761]                               next
[17:39:52.761]                             invokeRestart(restart)
[17:39:52.761]                             muffled <- TRUE
[17:39:52.761]                             break
[17:39:52.761]                           }
[17:39:52.761]                         }
[17:39:52.761]                       }
[17:39:52.761]                       invisible(muffled)
[17:39:52.761]                     }
[17:39:52.761]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.761]                   }
[17:39:52.761]                 }
[17:39:52.761]             }
[17:39:52.761]         }))
[17:39:52.761]     }, error = function(ex) {
[17:39:52.761]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.761]                 ...future.rng), started = ...future.startTime, 
[17:39:52.761]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.761]             version = "1.8"), class = "FutureResult")
[17:39:52.761]     }, finally = {
[17:39:52.761]         if (!identical(...future.workdir, getwd())) 
[17:39:52.761]             setwd(...future.workdir)
[17:39:52.761]         {
[17:39:52.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.761]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.761]             }
[17:39:52.761]             base::options(...future.oldOptions)
[17:39:52.761]             if (.Platform$OS.type == "windows") {
[17:39:52.761]                 old_names <- names(...future.oldEnvVars)
[17:39:52.761]                 envs <- base::Sys.getenv()
[17:39:52.761]                 names <- names(envs)
[17:39:52.761]                 common <- intersect(names, old_names)
[17:39:52.761]                 added <- setdiff(names, old_names)
[17:39:52.761]                 removed <- setdiff(old_names, names)
[17:39:52.761]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.761]                   envs[common]]
[17:39:52.761]                 NAMES <- toupper(changed)
[17:39:52.761]                 args <- list()
[17:39:52.761]                 for (kk in seq_along(NAMES)) {
[17:39:52.761]                   name <- changed[[kk]]
[17:39:52.761]                   NAME <- NAMES[[kk]]
[17:39:52.761]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.761]                     next
[17:39:52.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.761]                 }
[17:39:52.761]                 NAMES <- toupper(added)
[17:39:52.761]                 for (kk in seq_along(NAMES)) {
[17:39:52.761]                   name <- added[[kk]]
[17:39:52.761]                   NAME <- NAMES[[kk]]
[17:39:52.761]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.761]                     next
[17:39:52.761]                   args[[name]] <- ""
[17:39:52.761]                 }
[17:39:52.761]                 NAMES <- toupper(removed)
[17:39:52.761]                 for (kk in seq_along(NAMES)) {
[17:39:52.761]                   name <- removed[[kk]]
[17:39:52.761]                   NAME <- NAMES[[kk]]
[17:39:52.761]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.761]                     next
[17:39:52.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.761]                 }
[17:39:52.761]                 if (length(args) > 0) 
[17:39:52.761]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.761]             }
[17:39:52.761]             else {
[17:39:52.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.761]             }
[17:39:52.761]             {
[17:39:52.761]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.761]                   0L) {
[17:39:52.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.761]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.761]                   base::options(opts)
[17:39:52.761]                 }
[17:39:52.761]                 {
[17:39:52.761]                   {
[17:39:52.761]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.761]                     NULL
[17:39:52.761]                   }
[17:39:52.761]                   options(future.plan = NULL)
[17:39:52.761]                   if (is.na(NA_character_)) 
[17:39:52.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.761]                     .init = FALSE)
[17:39:52.761]                 }
[17:39:52.761]             }
[17:39:52.761]         }
[17:39:52.761]     })
[17:39:52.761]     if (TRUE) {
[17:39:52.761]         base::sink(type = "output", split = FALSE)
[17:39:52.761]         if (TRUE) {
[17:39:52.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.761]         }
[17:39:52.761]         else {
[17:39:52.761]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.761]         }
[17:39:52.761]         base::close(...future.stdout)
[17:39:52.761]         ...future.stdout <- NULL
[17:39:52.761]     }
[17:39:52.761]     ...future.result$conditions <- ...future.conditions
[17:39:52.761]     ...future.result$finished <- base::Sys.time()
[17:39:52.761]     ...future.result
[17:39:52.761] }
[17:39:52.763] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.763] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.763] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.764] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.764] MultisessionFuture started
[17:39:52.764] - Launch lazy future ... done
[17:39:52.764] run() for ‘MultisessionFuture’ ... done
[17:39:52.764] result() for ClusterFuture ...
[17:39:52.764] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.765] - Validating connection of MultisessionFuture
[17:39:52.765] - received message: FutureResult
[17:39:52.766] - Received FutureResult
[17:39:52.766] - Erased future from FutureRegistry
[17:39:52.766] result() for ClusterFuture ...
[17:39:52.766] - result already collected: FutureResult
[17:39:52.766] result() for ClusterFuture ... done
[17:39:52.766] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.766] result() for ClusterFuture ... done
[17:39:52.766] result() for ClusterFuture ...
[17:39:52.766] - result already collected: FutureResult
[17:39:52.766] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.767] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.767] Searching for globals...
[17:39:52.769] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:39:52.769] Searching for globals ... DONE
[17:39:52.769] Resolving globals: TRUE
[17:39:52.769] Resolving any globals that are futures ...
[17:39:52.770] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:39:52.770] Resolving any globals that are futures ... DONE
[17:39:52.770] 
[17:39:52.770] 
[17:39:52.770] getGlobalsAndPackages() ... DONE
[17:39:52.770] run() for ‘Future’ ...
[17:39:52.770] - state: ‘created’
[17:39:52.771] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.785]   - Field: ‘node’
[17:39:52.785]   - Field: ‘label’
[17:39:52.786]   - Field: ‘local’
[17:39:52.786]   - Field: ‘owner’
[17:39:52.786]   - Field: ‘envir’
[17:39:52.786]   - Field: ‘workers’
[17:39:52.786]   - Field: ‘packages’
[17:39:52.786]   - Field: ‘gc’
[17:39:52.786]   - Field: ‘conditions’
[17:39:52.786]   - Field: ‘persistent’
[17:39:52.786]   - Field: ‘expr’
[17:39:52.786]   - Field: ‘uuid’
[17:39:52.786]   - Field: ‘seed’
[17:39:52.787]   - Field: ‘version’
[17:39:52.787]   - Field: ‘result’
[17:39:52.787]   - Field: ‘asynchronous’
[17:39:52.787]   - Field: ‘calls’
[17:39:52.787]   - Field: ‘globals’
[17:39:52.787]   - Field: ‘stdout’
[17:39:52.787]   - Field: ‘earlySignal’
[17:39:52.787]   - Field: ‘lazy’
[17:39:52.787]   - Field: ‘state’
[17:39:52.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.787] - Launch lazy future ...
[17:39:52.788] Packages needed by the future expression (n = 0): <none>
[17:39:52.788] Packages needed by future strategies (n = 0): <none>
[17:39:52.788] {
[17:39:52.788]     {
[17:39:52.788]         {
[17:39:52.788]             ...future.startTime <- base::Sys.time()
[17:39:52.788]             {
[17:39:52.788]                 {
[17:39:52.788]                   {
[17:39:52.788]                     {
[17:39:52.788]                       base::local({
[17:39:52.788]                         has_future <- base::requireNamespace("future", 
[17:39:52.788]                           quietly = TRUE)
[17:39:52.788]                         if (has_future) {
[17:39:52.788]                           ns <- base::getNamespace("future")
[17:39:52.788]                           version <- ns[[".package"]][["version"]]
[17:39:52.788]                           if (is.null(version)) 
[17:39:52.788]                             version <- utils::packageVersion("future")
[17:39:52.788]                         }
[17:39:52.788]                         else {
[17:39:52.788]                           version <- NULL
[17:39:52.788]                         }
[17:39:52.788]                         if (!has_future || version < "1.8.0") {
[17:39:52.788]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.788]                             "", base::R.version$version.string), 
[17:39:52.788]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.788]                               "release", "version")], collapse = " "), 
[17:39:52.788]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.788]                             info)
[17:39:52.788]                           info <- base::paste(info, collapse = "; ")
[17:39:52.788]                           if (!has_future) {
[17:39:52.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.788]                               info)
[17:39:52.788]                           }
[17:39:52.788]                           else {
[17:39:52.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.788]                               info, version)
[17:39:52.788]                           }
[17:39:52.788]                           base::stop(msg)
[17:39:52.788]                         }
[17:39:52.788]                       })
[17:39:52.788]                     }
[17:39:52.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.788]                     base::options(mc.cores = 1L)
[17:39:52.788]                   }
[17:39:52.788]                   ...future.strategy.old <- future::plan("list")
[17:39:52.788]                   options(future.plan = NULL)
[17:39:52.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.788]                 }
[17:39:52.788]                 ...future.workdir <- getwd()
[17:39:52.788]             }
[17:39:52.788]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.788]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.788]         }
[17:39:52.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.788]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.788]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.788]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.788]             base::names(...future.oldOptions))
[17:39:52.788]     }
[17:39:52.788]     if (FALSE) {
[17:39:52.788]     }
[17:39:52.788]     else {
[17:39:52.788]         if (TRUE) {
[17:39:52.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.788]                 open = "w")
[17:39:52.788]         }
[17:39:52.788]         else {
[17:39:52.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.788]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.788]         }
[17:39:52.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.788]             base::sink(type = "output", split = FALSE)
[17:39:52.788]             base::close(...future.stdout)
[17:39:52.788]         }, add = TRUE)
[17:39:52.788]     }
[17:39:52.788]     ...future.frame <- base::sys.nframe()
[17:39:52.788]     ...future.conditions <- base::list()
[17:39:52.788]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.788]     if (FALSE) {
[17:39:52.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.788]     }
[17:39:52.788]     ...future.result <- base::tryCatch({
[17:39:52.788]         base::withCallingHandlers({
[17:39:52.788]             ...future.value <- base::withVisible(base::local({
[17:39:52.788]                 ...future.makeSendCondition <- base::local({
[17:39:52.788]                   sendCondition <- NULL
[17:39:52.788]                   function(frame = 1L) {
[17:39:52.788]                     if (is.function(sendCondition)) 
[17:39:52.788]                       return(sendCondition)
[17:39:52.788]                     ns <- getNamespace("parallel")
[17:39:52.788]                     if (exists("sendData", mode = "function", 
[17:39:52.788]                       envir = ns)) {
[17:39:52.788]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.788]                         envir = ns)
[17:39:52.788]                       envir <- sys.frame(frame)
[17:39:52.788]                       master <- NULL
[17:39:52.788]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.788]                         !identical(envir, emptyenv())) {
[17:39:52.788]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.788]                           inherits = FALSE)) {
[17:39:52.788]                           master <- get("master", mode = "list", 
[17:39:52.788]                             envir = envir, inherits = FALSE)
[17:39:52.788]                           if (inherits(master, c("SOCKnode", 
[17:39:52.788]                             "SOCK0node"))) {
[17:39:52.788]                             sendCondition <<- function(cond) {
[17:39:52.788]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.788]                                 success = TRUE)
[17:39:52.788]                               parallel_sendData(master, data)
[17:39:52.788]                             }
[17:39:52.788]                             return(sendCondition)
[17:39:52.788]                           }
[17:39:52.788]                         }
[17:39:52.788]                         frame <- frame + 1L
[17:39:52.788]                         envir <- sys.frame(frame)
[17:39:52.788]                       }
[17:39:52.788]                     }
[17:39:52.788]                     sendCondition <<- function(cond) NULL
[17:39:52.788]                   }
[17:39:52.788]                 })
[17:39:52.788]                 withCallingHandlers({
[17:39:52.788]                   {
[17:39:52.788]                     x <- list(b = 2)
[17:39:52.788]                     x$a <- 1
[17:39:52.788]                     x
[17:39:52.788]                   }
[17:39:52.788]                 }, immediateCondition = function(cond) {
[17:39:52.788]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.788]                   sendCondition(cond)
[17:39:52.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.788]                   {
[17:39:52.788]                     inherits <- base::inherits
[17:39:52.788]                     invokeRestart <- base::invokeRestart
[17:39:52.788]                     is.null <- base::is.null
[17:39:52.788]                     muffled <- FALSE
[17:39:52.788]                     if (inherits(cond, "message")) {
[17:39:52.788]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.788]                       if (muffled) 
[17:39:52.788]                         invokeRestart("muffleMessage")
[17:39:52.788]                     }
[17:39:52.788]                     else if (inherits(cond, "warning")) {
[17:39:52.788]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.788]                       if (muffled) 
[17:39:52.788]                         invokeRestart("muffleWarning")
[17:39:52.788]                     }
[17:39:52.788]                     else if (inherits(cond, "condition")) {
[17:39:52.788]                       if (!is.null(pattern)) {
[17:39:52.788]                         computeRestarts <- base::computeRestarts
[17:39:52.788]                         grepl <- base::grepl
[17:39:52.788]                         restarts <- computeRestarts(cond)
[17:39:52.788]                         for (restart in restarts) {
[17:39:52.788]                           name <- restart$name
[17:39:52.788]                           if (is.null(name)) 
[17:39:52.788]                             next
[17:39:52.788]                           if (!grepl(pattern, name)) 
[17:39:52.788]                             next
[17:39:52.788]                           invokeRestart(restart)
[17:39:52.788]                           muffled <- TRUE
[17:39:52.788]                           break
[17:39:52.788]                         }
[17:39:52.788]                       }
[17:39:52.788]                     }
[17:39:52.788]                     invisible(muffled)
[17:39:52.788]                   }
[17:39:52.788]                   muffleCondition(cond)
[17:39:52.788]                 })
[17:39:52.788]             }))
[17:39:52.788]             future::FutureResult(value = ...future.value$value, 
[17:39:52.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.788]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.788]                     ...future.globalenv.names))
[17:39:52.788]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.788]         }, condition = base::local({
[17:39:52.788]             c <- base::c
[17:39:52.788]             inherits <- base::inherits
[17:39:52.788]             invokeRestart <- base::invokeRestart
[17:39:52.788]             length <- base::length
[17:39:52.788]             list <- base::list
[17:39:52.788]             seq.int <- base::seq.int
[17:39:52.788]             signalCondition <- base::signalCondition
[17:39:52.788]             sys.calls <- base::sys.calls
[17:39:52.788]             `[[` <- base::`[[`
[17:39:52.788]             `+` <- base::`+`
[17:39:52.788]             `<<-` <- base::`<<-`
[17:39:52.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.788]                   3L)]
[17:39:52.788]             }
[17:39:52.788]             function(cond) {
[17:39:52.788]                 is_error <- inherits(cond, "error")
[17:39:52.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.788]                   NULL)
[17:39:52.788]                 if (is_error) {
[17:39:52.788]                   sessionInformation <- function() {
[17:39:52.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.788]                       search = base::search(), system = base::Sys.info())
[17:39:52.788]                   }
[17:39:52.788]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.788]                     cond$call), session = sessionInformation(), 
[17:39:52.788]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.788]                   signalCondition(cond)
[17:39:52.788]                 }
[17:39:52.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.788]                 "immediateCondition"))) {
[17:39:52.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.788]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.788]                   if (TRUE && !signal) {
[17:39:52.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.788]                     {
[17:39:52.788]                       inherits <- base::inherits
[17:39:52.788]                       invokeRestart <- base::invokeRestart
[17:39:52.788]                       is.null <- base::is.null
[17:39:52.788]                       muffled <- FALSE
[17:39:52.788]                       if (inherits(cond, "message")) {
[17:39:52.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.788]                         if (muffled) 
[17:39:52.788]                           invokeRestart("muffleMessage")
[17:39:52.788]                       }
[17:39:52.788]                       else if (inherits(cond, "warning")) {
[17:39:52.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.788]                         if (muffled) 
[17:39:52.788]                           invokeRestart("muffleWarning")
[17:39:52.788]                       }
[17:39:52.788]                       else if (inherits(cond, "condition")) {
[17:39:52.788]                         if (!is.null(pattern)) {
[17:39:52.788]                           computeRestarts <- base::computeRestarts
[17:39:52.788]                           grepl <- base::grepl
[17:39:52.788]                           restarts <- computeRestarts(cond)
[17:39:52.788]                           for (restart in restarts) {
[17:39:52.788]                             name <- restart$name
[17:39:52.788]                             if (is.null(name)) 
[17:39:52.788]                               next
[17:39:52.788]                             if (!grepl(pattern, name)) 
[17:39:52.788]                               next
[17:39:52.788]                             invokeRestart(restart)
[17:39:52.788]                             muffled <- TRUE
[17:39:52.788]                             break
[17:39:52.788]                           }
[17:39:52.788]                         }
[17:39:52.788]                       }
[17:39:52.788]                       invisible(muffled)
[17:39:52.788]                     }
[17:39:52.788]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.788]                   }
[17:39:52.788]                 }
[17:39:52.788]                 else {
[17:39:52.788]                   if (TRUE) {
[17:39:52.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.788]                     {
[17:39:52.788]                       inherits <- base::inherits
[17:39:52.788]                       invokeRestart <- base::invokeRestart
[17:39:52.788]                       is.null <- base::is.null
[17:39:52.788]                       muffled <- FALSE
[17:39:52.788]                       if (inherits(cond, "message")) {
[17:39:52.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.788]                         if (muffled) 
[17:39:52.788]                           invokeRestart("muffleMessage")
[17:39:52.788]                       }
[17:39:52.788]                       else if (inherits(cond, "warning")) {
[17:39:52.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.788]                         if (muffled) 
[17:39:52.788]                           invokeRestart("muffleWarning")
[17:39:52.788]                       }
[17:39:52.788]                       else if (inherits(cond, "condition")) {
[17:39:52.788]                         if (!is.null(pattern)) {
[17:39:52.788]                           computeRestarts <- base::computeRestarts
[17:39:52.788]                           grepl <- base::grepl
[17:39:52.788]                           restarts <- computeRestarts(cond)
[17:39:52.788]                           for (restart in restarts) {
[17:39:52.788]                             name <- restart$name
[17:39:52.788]                             if (is.null(name)) 
[17:39:52.788]                               next
[17:39:52.788]                             if (!grepl(pattern, name)) 
[17:39:52.788]                               next
[17:39:52.788]                             invokeRestart(restart)
[17:39:52.788]                             muffled <- TRUE
[17:39:52.788]                             break
[17:39:52.788]                           }
[17:39:52.788]                         }
[17:39:52.788]                       }
[17:39:52.788]                       invisible(muffled)
[17:39:52.788]                     }
[17:39:52.788]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.788]                   }
[17:39:52.788]                 }
[17:39:52.788]             }
[17:39:52.788]         }))
[17:39:52.788]     }, error = function(ex) {
[17:39:52.788]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.788]                 ...future.rng), started = ...future.startTime, 
[17:39:52.788]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.788]             version = "1.8"), class = "FutureResult")
[17:39:52.788]     }, finally = {
[17:39:52.788]         if (!identical(...future.workdir, getwd())) 
[17:39:52.788]             setwd(...future.workdir)
[17:39:52.788]         {
[17:39:52.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.788]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.788]             }
[17:39:52.788]             base::options(...future.oldOptions)
[17:39:52.788]             if (.Platform$OS.type == "windows") {
[17:39:52.788]                 old_names <- names(...future.oldEnvVars)
[17:39:52.788]                 envs <- base::Sys.getenv()
[17:39:52.788]                 names <- names(envs)
[17:39:52.788]                 common <- intersect(names, old_names)
[17:39:52.788]                 added <- setdiff(names, old_names)
[17:39:52.788]                 removed <- setdiff(old_names, names)
[17:39:52.788]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.788]                   envs[common]]
[17:39:52.788]                 NAMES <- toupper(changed)
[17:39:52.788]                 args <- list()
[17:39:52.788]                 for (kk in seq_along(NAMES)) {
[17:39:52.788]                   name <- changed[[kk]]
[17:39:52.788]                   NAME <- NAMES[[kk]]
[17:39:52.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.788]                     next
[17:39:52.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.788]                 }
[17:39:52.788]                 NAMES <- toupper(added)
[17:39:52.788]                 for (kk in seq_along(NAMES)) {
[17:39:52.788]                   name <- added[[kk]]
[17:39:52.788]                   NAME <- NAMES[[kk]]
[17:39:52.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.788]                     next
[17:39:52.788]                   args[[name]] <- ""
[17:39:52.788]                 }
[17:39:52.788]                 NAMES <- toupper(removed)
[17:39:52.788]                 for (kk in seq_along(NAMES)) {
[17:39:52.788]                   name <- removed[[kk]]
[17:39:52.788]                   NAME <- NAMES[[kk]]
[17:39:52.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.788]                     next
[17:39:52.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.788]                 }
[17:39:52.788]                 if (length(args) > 0) 
[17:39:52.788]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.788]             }
[17:39:52.788]             else {
[17:39:52.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.788]             }
[17:39:52.788]             {
[17:39:52.788]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.788]                   0L) {
[17:39:52.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.788]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.788]                   base::options(opts)
[17:39:52.788]                 }
[17:39:52.788]                 {
[17:39:52.788]                   {
[17:39:52.788]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.788]                     NULL
[17:39:52.788]                   }
[17:39:52.788]                   options(future.plan = NULL)
[17:39:52.788]                   if (is.na(NA_character_)) 
[17:39:52.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.788]                     .init = FALSE)
[17:39:52.788]                 }
[17:39:52.788]             }
[17:39:52.788]         }
[17:39:52.788]     })
[17:39:52.788]     if (TRUE) {
[17:39:52.788]         base::sink(type = "output", split = FALSE)
[17:39:52.788]         if (TRUE) {
[17:39:52.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.788]         }
[17:39:52.788]         else {
[17:39:52.788]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.788]         }
[17:39:52.788]         base::close(...future.stdout)
[17:39:52.788]         ...future.stdout <- NULL
[17:39:52.788]     }
[17:39:52.788]     ...future.result$conditions <- ...future.conditions
[17:39:52.788]     ...future.result$finished <- base::Sys.time()
[17:39:52.788]     ...future.result
[17:39:52.788] }
[17:39:52.791] MultisessionFuture started
[17:39:52.791] - Launch lazy future ... done
[17:39:52.791] run() for ‘MultisessionFuture’ ... done
[17:39:52.791] result() for ClusterFuture ...
[17:39:52.791] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.792] - Validating connection of MultisessionFuture
[17:39:52.792] - received message: FutureResult
[17:39:52.793] - Received FutureResult
[17:39:52.793] - Erased future from FutureRegistry
[17:39:52.793] result() for ClusterFuture ...
[17:39:52.793] - result already collected: FutureResult
[17:39:52.793] result() for ClusterFuture ... done
[17:39:52.793] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.793] result() for ClusterFuture ... done
[17:39:52.793] result() for ClusterFuture ...
[17:39:52.793] - result already collected: FutureResult
[17:39:52.793] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.794] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.794] Searching for globals...
[17:39:52.796] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:52.796] Searching for globals ... DONE
[17:39:52.796] Resolving globals: TRUE
[17:39:52.796] Resolving any globals that are futures ...
[17:39:52.796] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:52.796] Resolving any globals that are futures ... DONE
[17:39:52.796] Resolving futures part of globals (recursively) ...
[17:39:52.797] resolve() on list ...
[17:39:52.797]  recursive: 99
[17:39:52.797]  length: 1
[17:39:52.797]  elements: ‘x’
[17:39:52.797]  length: 0 (resolved future 1)
[17:39:52.797] resolve() on list ... DONE
[17:39:52.797] - globals: [1] ‘x’
[17:39:52.797] Resolving futures part of globals (recursively) ... DONE
[17:39:52.798] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.798] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.798] - globals: [1] ‘x’
[17:39:52.798] 
[17:39:52.798] getGlobalsAndPackages() ... DONE
[17:39:52.798] run() for ‘Future’ ...
[17:39:52.798] - state: ‘created’
[17:39:52.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.812] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.812]   - Field: ‘node’
[17:39:52.812]   - Field: ‘label’
[17:39:52.812]   - Field: ‘local’
[17:39:52.813]   - Field: ‘owner’
[17:39:52.813]   - Field: ‘envir’
[17:39:52.813]   - Field: ‘workers’
[17:39:52.813]   - Field: ‘packages’
[17:39:52.813]   - Field: ‘gc’
[17:39:52.813]   - Field: ‘conditions’
[17:39:52.813]   - Field: ‘persistent’
[17:39:52.813]   - Field: ‘expr’
[17:39:52.813]   - Field: ‘uuid’
[17:39:52.813]   - Field: ‘seed’
[17:39:52.813]   - Field: ‘version’
[17:39:52.813]   - Field: ‘result’
[17:39:52.814]   - Field: ‘asynchronous’
[17:39:52.814]   - Field: ‘calls’
[17:39:52.814]   - Field: ‘globals’
[17:39:52.814]   - Field: ‘stdout’
[17:39:52.814]   - Field: ‘earlySignal’
[17:39:52.814]   - Field: ‘lazy’
[17:39:52.814]   - Field: ‘state’
[17:39:52.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.814] - Launch lazy future ...
[17:39:52.815] Packages needed by the future expression (n = 0): <none>
[17:39:52.815] Packages needed by future strategies (n = 0): <none>
[17:39:52.815] {
[17:39:52.815]     {
[17:39:52.815]         {
[17:39:52.815]             ...future.startTime <- base::Sys.time()
[17:39:52.815]             {
[17:39:52.815]                 {
[17:39:52.815]                   {
[17:39:52.815]                     {
[17:39:52.815]                       base::local({
[17:39:52.815]                         has_future <- base::requireNamespace("future", 
[17:39:52.815]                           quietly = TRUE)
[17:39:52.815]                         if (has_future) {
[17:39:52.815]                           ns <- base::getNamespace("future")
[17:39:52.815]                           version <- ns[[".package"]][["version"]]
[17:39:52.815]                           if (is.null(version)) 
[17:39:52.815]                             version <- utils::packageVersion("future")
[17:39:52.815]                         }
[17:39:52.815]                         else {
[17:39:52.815]                           version <- NULL
[17:39:52.815]                         }
[17:39:52.815]                         if (!has_future || version < "1.8.0") {
[17:39:52.815]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.815]                             "", base::R.version$version.string), 
[17:39:52.815]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.815]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.815]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.815]                               "release", "version")], collapse = " "), 
[17:39:52.815]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.815]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.815]                             info)
[17:39:52.815]                           info <- base::paste(info, collapse = "; ")
[17:39:52.815]                           if (!has_future) {
[17:39:52.815]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.815]                               info)
[17:39:52.815]                           }
[17:39:52.815]                           else {
[17:39:52.815]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.815]                               info, version)
[17:39:52.815]                           }
[17:39:52.815]                           base::stop(msg)
[17:39:52.815]                         }
[17:39:52.815]                       })
[17:39:52.815]                     }
[17:39:52.815]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.815]                     base::options(mc.cores = 1L)
[17:39:52.815]                   }
[17:39:52.815]                   ...future.strategy.old <- future::plan("list")
[17:39:52.815]                   options(future.plan = NULL)
[17:39:52.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.815]                 }
[17:39:52.815]                 ...future.workdir <- getwd()
[17:39:52.815]             }
[17:39:52.815]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.815]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.815]         }
[17:39:52.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.815]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.815]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.815]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.815]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.815]             base::names(...future.oldOptions))
[17:39:52.815]     }
[17:39:52.815]     if (FALSE) {
[17:39:52.815]     }
[17:39:52.815]     else {
[17:39:52.815]         if (TRUE) {
[17:39:52.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.815]                 open = "w")
[17:39:52.815]         }
[17:39:52.815]         else {
[17:39:52.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.815]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.815]         }
[17:39:52.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.815]             base::sink(type = "output", split = FALSE)
[17:39:52.815]             base::close(...future.stdout)
[17:39:52.815]         }, add = TRUE)
[17:39:52.815]     }
[17:39:52.815]     ...future.frame <- base::sys.nframe()
[17:39:52.815]     ...future.conditions <- base::list()
[17:39:52.815]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.815]     if (FALSE) {
[17:39:52.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.815]     }
[17:39:52.815]     ...future.result <- base::tryCatch({
[17:39:52.815]         base::withCallingHandlers({
[17:39:52.815]             ...future.value <- base::withVisible(base::local({
[17:39:52.815]                 ...future.makeSendCondition <- base::local({
[17:39:52.815]                   sendCondition <- NULL
[17:39:52.815]                   function(frame = 1L) {
[17:39:52.815]                     if (is.function(sendCondition)) 
[17:39:52.815]                       return(sendCondition)
[17:39:52.815]                     ns <- getNamespace("parallel")
[17:39:52.815]                     if (exists("sendData", mode = "function", 
[17:39:52.815]                       envir = ns)) {
[17:39:52.815]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.815]                         envir = ns)
[17:39:52.815]                       envir <- sys.frame(frame)
[17:39:52.815]                       master <- NULL
[17:39:52.815]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.815]                         !identical(envir, emptyenv())) {
[17:39:52.815]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.815]                           inherits = FALSE)) {
[17:39:52.815]                           master <- get("master", mode = "list", 
[17:39:52.815]                             envir = envir, inherits = FALSE)
[17:39:52.815]                           if (inherits(master, c("SOCKnode", 
[17:39:52.815]                             "SOCK0node"))) {
[17:39:52.815]                             sendCondition <<- function(cond) {
[17:39:52.815]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.815]                                 success = TRUE)
[17:39:52.815]                               parallel_sendData(master, data)
[17:39:52.815]                             }
[17:39:52.815]                             return(sendCondition)
[17:39:52.815]                           }
[17:39:52.815]                         }
[17:39:52.815]                         frame <- frame + 1L
[17:39:52.815]                         envir <- sys.frame(frame)
[17:39:52.815]                       }
[17:39:52.815]                     }
[17:39:52.815]                     sendCondition <<- function(cond) NULL
[17:39:52.815]                   }
[17:39:52.815]                 })
[17:39:52.815]                 withCallingHandlers({
[17:39:52.815]                   {
[17:39:52.815]                     x[["a"]] <- 1
[17:39:52.815]                     x
[17:39:52.815]                   }
[17:39:52.815]                 }, immediateCondition = function(cond) {
[17:39:52.815]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.815]                   sendCondition(cond)
[17:39:52.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.815]                   {
[17:39:52.815]                     inherits <- base::inherits
[17:39:52.815]                     invokeRestart <- base::invokeRestart
[17:39:52.815]                     is.null <- base::is.null
[17:39:52.815]                     muffled <- FALSE
[17:39:52.815]                     if (inherits(cond, "message")) {
[17:39:52.815]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.815]                       if (muffled) 
[17:39:52.815]                         invokeRestart("muffleMessage")
[17:39:52.815]                     }
[17:39:52.815]                     else if (inherits(cond, "warning")) {
[17:39:52.815]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.815]                       if (muffled) 
[17:39:52.815]                         invokeRestart("muffleWarning")
[17:39:52.815]                     }
[17:39:52.815]                     else if (inherits(cond, "condition")) {
[17:39:52.815]                       if (!is.null(pattern)) {
[17:39:52.815]                         computeRestarts <- base::computeRestarts
[17:39:52.815]                         grepl <- base::grepl
[17:39:52.815]                         restarts <- computeRestarts(cond)
[17:39:52.815]                         for (restart in restarts) {
[17:39:52.815]                           name <- restart$name
[17:39:52.815]                           if (is.null(name)) 
[17:39:52.815]                             next
[17:39:52.815]                           if (!grepl(pattern, name)) 
[17:39:52.815]                             next
[17:39:52.815]                           invokeRestart(restart)
[17:39:52.815]                           muffled <- TRUE
[17:39:52.815]                           break
[17:39:52.815]                         }
[17:39:52.815]                       }
[17:39:52.815]                     }
[17:39:52.815]                     invisible(muffled)
[17:39:52.815]                   }
[17:39:52.815]                   muffleCondition(cond)
[17:39:52.815]                 })
[17:39:52.815]             }))
[17:39:52.815]             future::FutureResult(value = ...future.value$value, 
[17:39:52.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.815]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.815]                     ...future.globalenv.names))
[17:39:52.815]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.815]         }, condition = base::local({
[17:39:52.815]             c <- base::c
[17:39:52.815]             inherits <- base::inherits
[17:39:52.815]             invokeRestart <- base::invokeRestart
[17:39:52.815]             length <- base::length
[17:39:52.815]             list <- base::list
[17:39:52.815]             seq.int <- base::seq.int
[17:39:52.815]             signalCondition <- base::signalCondition
[17:39:52.815]             sys.calls <- base::sys.calls
[17:39:52.815]             `[[` <- base::`[[`
[17:39:52.815]             `+` <- base::`+`
[17:39:52.815]             `<<-` <- base::`<<-`
[17:39:52.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.815]                   3L)]
[17:39:52.815]             }
[17:39:52.815]             function(cond) {
[17:39:52.815]                 is_error <- inherits(cond, "error")
[17:39:52.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.815]                   NULL)
[17:39:52.815]                 if (is_error) {
[17:39:52.815]                   sessionInformation <- function() {
[17:39:52.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.815]                       search = base::search(), system = base::Sys.info())
[17:39:52.815]                   }
[17:39:52.815]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.815]                     cond$call), session = sessionInformation(), 
[17:39:52.815]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.815]                   signalCondition(cond)
[17:39:52.815]                 }
[17:39:52.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.815]                 "immediateCondition"))) {
[17:39:52.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.815]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.815]                   if (TRUE && !signal) {
[17:39:52.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.815]                     {
[17:39:52.815]                       inherits <- base::inherits
[17:39:52.815]                       invokeRestart <- base::invokeRestart
[17:39:52.815]                       is.null <- base::is.null
[17:39:52.815]                       muffled <- FALSE
[17:39:52.815]                       if (inherits(cond, "message")) {
[17:39:52.815]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.815]                         if (muffled) 
[17:39:52.815]                           invokeRestart("muffleMessage")
[17:39:52.815]                       }
[17:39:52.815]                       else if (inherits(cond, "warning")) {
[17:39:52.815]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.815]                         if (muffled) 
[17:39:52.815]                           invokeRestart("muffleWarning")
[17:39:52.815]                       }
[17:39:52.815]                       else if (inherits(cond, "condition")) {
[17:39:52.815]                         if (!is.null(pattern)) {
[17:39:52.815]                           computeRestarts <- base::computeRestarts
[17:39:52.815]                           grepl <- base::grepl
[17:39:52.815]                           restarts <- computeRestarts(cond)
[17:39:52.815]                           for (restart in restarts) {
[17:39:52.815]                             name <- restart$name
[17:39:52.815]                             if (is.null(name)) 
[17:39:52.815]                               next
[17:39:52.815]                             if (!grepl(pattern, name)) 
[17:39:52.815]                               next
[17:39:52.815]                             invokeRestart(restart)
[17:39:52.815]                             muffled <- TRUE
[17:39:52.815]                             break
[17:39:52.815]                           }
[17:39:52.815]                         }
[17:39:52.815]                       }
[17:39:52.815]                       invisible(muffled)
[17:39:52.815]                     }
[17:39:52.815]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.815]                   }
[17:39:52.815]                 }
[17:39:52.815]                 else {
[17:39:52.815]                   if (TRUE) {
[17:39:52.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.815]                     {
[17:39:52.815]                       inherits <- base::inherits
[17:39:52.815]                       invokeRestart <- base::invokeRestart
[17:39:52.815]                       is.null <- base::is.null
[17:39:52.815]                       muffled <- FALSE
[17:39:52.815]                       if (inherits(cond, "message")) {
[17:39:52.815]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.815]                         if (muffled) 
[17:39:52.815]                           invokeRestart("muffleMessage")
[17:39:52.815]                       }
[17:39:52.815]                       else if (inherits(cond, "warning")) {
[17:39:52.815]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.815]                         if (muffled) 
[17:39:52.815]                           invokeRestart("muffleWarning")
[17:39:52.815]                       }
[17:39:52.815]                       else if (inherits(cond, "condition")) {
[17:39:52.815]                         if (!is.null(pattern)) {
[17:39:52.815]                           computeRestarts <- base::computeRestarts
[17:39:52.815]                           grepl <- base::grepl
[17:39:52.815]                           restarts <- computeRestarts(cond)
[17:39:52.815]                           for (restart in restarts) {
[17:39:52.815]                             name <- restart$name
[17:39:52.815]                             if (is.null(name)) 
[17:39:52.815]                               next
[17:39:52.815]                             if (!grepl(pattern, name)) 
[17:39:52.815]                               next
[17:39:52.815]                             invokeRestart(restart)
[17:39:52.815]                             muffled <- TRUE
[17:39:52.815]                             break
[17:39:52.815]                           }
[17:39:52.815]                         }
[17:39:52.815]                       }
[17:39:52.815]                       invisible(muffled)
[17:39:52.815]                     }
[17:39:52.815]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.815]                   }
[17:39:52.815]                 }
[17:39:52.815]             }
[17:39:52.815]         }))
[17:39:52.815]     }, error = function(ex) {
[17:39:52.815]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.815]                 ...future.rng), started = ...future.startTime, 
[17:39:52.815]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.815]             version = "1.8"), class = "FutureResult")
[17:39:52.815]     }, finally = {
[17:39:52.815]         if (!identical(...future.workdir, getwd())) 
[17:39:52.815]             setwd(...future.workdir)
[17:39:52.815]         {
[17:39:52.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.815]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.815]             }
[17:39:52.815]             base::options(...future.oldOptions)
[17:39:52.815]             if (.Platform$OS.type == "windows") {
[17:39:52.815]                 old_names <- names(...future.oldEnvVars)
[17:39:52.815]                 envs <- base::Sys.getenv()
[17:39:52.815]                 names <- names(envs)
[17:39:52.815]                 common <- intersect(names, old_names)
[17:39:52.815]                 added <- setdiff(names, old_names)
[17:39:52.815]                 removed <- setdiff(old_names, names)
[17:39:52.815]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.815]                   envs[common]]
[17:39:52.815]                 NAMES <- toupper(changed)
[17:39:52.815]                 args <- list()
[17:39:52.815]                 for (kk in seq_along(NAMES)) {
[17:39:52.815]                   name <- changed[[kk]]
[17:39:52.815]                   NAME <- NAMES[[kk]]
[17:39:52.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.815]                     next
[17:39:52.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.815]                 }
[17:39:52.815]                 NAMES <- toupper(added)
[17:39:52.815]                 for (kk in seq_along(NAMES)) {
[17:39:52.815]                   name <- added[[kk]]
[17:39:52.815]                   NAME <- NAMES[[kk]]
[17:39:52.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.815]                     next
[17:39:52.815]                   args[[name]] <- ""
[17:39:52.815]                 }
[17:39:52.815]                 NAMES <- toupper(removed)
[17:39:52.815]                 for (kk in seq_along(NAMES)) {
[17:39:52.815]                   name <- removed[[kk]]
[17:39:52.815]                   NAME <- NAMES[[kk]]
[17:39:52.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.815]                     next
[17:39:52.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.815]                 }
[17:39:52.815]                 if (length(args) > 0) 
[17:39:52.815]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.815]             }
[17:39:52.815]             else {
[17:39:52.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.815]             }
[17:39:52.815]             {
[17:39:52.815]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.815]                   0L) {
[17:39:52.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.815]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.815]                   base::options(opts)
[17:39:52.815]                 }
[17:39:52.815]                 {
[17:39:52.815]                   {
[17:39:52.815]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.815]                     NULL
[17:39:52.815]                   }
[17:39:52.815]                   options(future.plan = NULL)
[17:39:52.815]                   if (is.na(NA_character_)) 
[17:39:52.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.815]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.815]                     .init = FALSE)
[17:39:52.815]                 }
[17:39:52.815]             }
[17:39:52.815]         }
[17:39:52.815]     })
[17:39:52.815]     if (TRUE) {
[17:39:52.815]         base::sink(type = "output", split = FALSE)
[17:39:52.815]         if (TRUE) {
[17:39:52.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.815]         }
[17:39:52.815]         else {
[17:39:52.815]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.815]         }
[17:39:52.815]         base::close(...future.stdout)
[17:39:52.815]         ...future.stdout <- NULL
[17:39:52.815]     }
[17:39:52.815]     ...future.result$conditions <- ...future.conditions
[17:39:52.815]     ...future.result$finished <- base::Sys.time()
[17:39:52.815]     ...future.result
[17:39:52.815] }
[17:39:52.817] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.817] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.818] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.818] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.818] MultisessionFuture started
[17:39:52.818] - Launch lazy future ... done
[17:39:52.819] run() for ‘MultisessionFuture’ ... done
[17:39:52.819] result() for ClusterFuture ...
[17:39:52.819] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.819] - Validating connection of MultisessionFuture
[17:39:52.820] - received message: FutureResult
[17:39:52.820] - Received FutureResult
[17:39:52.820] - Erased future from FutureRegistry
[17:39:52.820] result() for ClusterFuture ...
[17:39:52.820] - result already collected: FutureResult
[17:39:52.820] result() for ClusterFuture ... done
[17:39:52.820] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.820] result() for ClusterFuture ... done
[17:39:52.821] result() for ClusterFuture ...
[17:39:52.821] - result already collected: FutureResult
[17:39:52.821] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.821] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.821] Searching for globals...
[17:39:52.823] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:52.823] Searching for globals ... DONE
[17:39:52.823] Resolving globals: TRUE
[17:39:52.823] Resolving any globals that are futures ...
[17:39:52.823] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:52.823] Resolving any globals that are futures ... DONE
[17:39:52.824] Resolving futures part of globals (recursively) ...
[17:39:52.824] resolve() on list ...
[17:39:52.824]  recursive: 99
[17:39:52.824]  length: 1
[17:39:52.824]  elements: ‘x’
[17:39:52.824]  length: 0 (resolved future 1)
[17:39:52.824] resolve() on list ... DONE
[17:39:52.825] - globals: [1] ‘x’
[17:39:52.825] Resolving futures part of globals (recursively) ... DONE
[17:39:52.825] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.825] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.825] - globals: [1] ‘x’
[17:39:52.825] 
[17:39:52.825] getGlobalsAndPackages() ... DONE
[17:39:52.826] run() for ‘Future’ ...
[17:39:52.826] - state: ‘created’
[17:39:52.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.839] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.840]   - Field: ‘node’
[17:39:52.840]   - Field: ‘label’
[17:39:52.840]   - Field: ‘local’
[17:39:52.840]   - Field: ‘owner’
[17:39:52.840]   - Field: ‘envir’
[17:39:52.840]   - Field: ‘workers’
[17:39:52.840]   - Field: ‘packages’
[17:39:52.840]   - Field: ‘gc’
[17:39:52.840]   - Field: ‘conditions’
[17:39:52.840]   - Field: ‘persistent’
[17:39:52.840]   - Field: ‘expr’
[17:39:52.841]   - Field: ‘uuid’
[17:39:52.841]   - Field: ‘seed’
[17:39:52.841]   - Field: ‘version’
[17:39:52.841]   - Field: ‘result’
[17:39:52.841]   - Field: ‘asynchronous’
[17:39:52.841]   - Field: ‘calls’
[17:39:52.841]   - Field: ‘globals’
[17:39:52.841]   - Field: ‘stdout’
[17:39:52.841]   - Field: ‘earlySignal’
[17:39:52.841]   - Field: ‘lazy’
[17:39:52.841]   - Field: ‘state’
[17:39:52.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.842] - Launch lazy future ...
[17:39:52.842] Packages needed by the future expression (n = 0): <none>
[17:39:52.842] Packages needed by future strategies (n = 0): <none>
[17:39:52.842] {
[17:39:52.842]     {
[17:39:52.842]         {
[17:39:52.842]             ...future.startTime <- base::Sys.time()
[17:39:52.842]             {
[17:39:52.842]                 {
[17:39:52.842]                   {
[17:39:52.842]                     {
[17:39:52.842]                       base::local({
[17:39:52.842]                         has_future <- base::requireNamespace("future", 
[17:39:52.842]                           quietly = TRUE)
[17:39:52.842]                         if (has_future) {
[17:39:52.842]                           ns <- base::getNamespace("future")
[17:39:52.842]                           version <- ns[[".package"]][["version"]]
[17:39:52.842]                           if (is.null(version)) 
[17:39:52.842]                             version <- utils::packageVersion("future")
[17:39:52.842]                         }
[17:39:52.842]                         else {
[17:39:52.842]                           version <- NULL
[17:39:52.842]                         }
[17:39:52.842]                         if (!has_future || version < "1.8.0") {
[17:39:52.842]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.842]                             "", base::R.version$version.string), 
[17:39:52.842]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.842]                               "release", "version")], collapse = " "), 
[17:39:52.842]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.842]                             info)
[17:39:52.842]                           info <- base::paste(info, collapse = "; ")
[17:39:52.842]                           if (!has_future) {
[17:39:52.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.842]                               info)
[17:39:52.842]                           }
[17:39:52.842]                           else {
[17:39:52.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.842]                               info, version)
[17:39:52.842]                           }
[17:39:52.842]                           base::stop(msg)
[17:39:52.842]                         }
[17:39:52.842]                       })
[17:39:52.842]                     }
[17:39:52.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.842]                     base::options(mc.cores = 1L)
[17:39:52.842]                   }
[17:39:52.842]                   ...future.strategy.old <- future::plan("list")
[17:39:52.842]                   options(future.plan = NULL)
[17:39:52.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.842]                 }
[17:39:52.842]                 ...future.workdir <- getwd()
[17:39:52.842]             }
[17:39:52.842]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.842]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.842]         }
[17:39:52.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.842]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.842]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.842]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.842]             base::names(...future.oldOptions))
[17:39:52.842]     }
[17:39:52.842]     if (FALSE) {
[17:39:52.842]     }
[17:39:52.842]     else {
[17:39:52.842]         if (TRUE) {
[17:39:52.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.842]                 open = "w")
[17:39:52.842]         }
[17:39:52.842]         else {
[17:39:52.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.842]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.842]         }
[17:39:52.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.842]             base::sink(type = "output", split = FALSE)
[17:39:52.842]             base::close(...future.stdout)
[17:39:52.842]         }, add = TRUE)
[17:39:52.842]     }
[17:39:52.842]     ...future.frame <- base::sys.nframe()
[17:39:52.842]     ...future.conditions <- base::list()
[17:39:52.842]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.842]     if (FALSE) {
[17:39:52.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.842]     }
[17:39:52.842]     ...future.result <- base::tryCatch({
[17:39:52.842]         base::withCallingHandlers({
[17:39:52.842]             ...future.value <- base::withVisible(base::local({
[17:39:52.842]                 ...future.makeSendCondition <- base::local({
[17:39:52.842]                   sendCondition <- NULL
[17:39:52.842]                   function(frame = 1L) {
[17:39:52.842]                     if (is.function(sendCondition)) 
[17:39:52.842]                       return(sendCondition)
[17:39:52.842]                     ns <- getNamespace("parallel")
[17:39:52.842]                     if (exists("sendData", mode = "function", 
[17:39:52.842]                       envir = ns)) {
[17:39:52.842]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.842]                         envir = ns)
[17:39:52.842]                       envir <- sys.frame(frame)
[17:39:52.842]                       master <- NULL
[17:39:52.842]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.842]                         !identical(envir, emptyenv())) {
[17:39:52.842]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.842]                           inherits = FALSE)) {
[17:39:52.842]                           master <- get("master", mode = "list", 
[17:39:52.842]                             envir = envir, inherits = FALSE)
[17:39:52.842]                           if (inherits(master, c("SOCKnode", 
[17:39:52.842]                             "SOCK0node"))) {
[17:39:52.842]                             sendCondition <<- function(cond) {
[17:39:52.842]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.842]                                 success = TRUE)
[17:39:52.842]                               parallel_sendData(master, data)
[17:39:52.842]                             }
[17:39:52.842]                             return(sendCondition)
[17:39:52.842]                           }
[17:39:52.842]                         }
[17:39:52.842]                         frame <- frame + 1L
[17:39:52.842]                         envir <- sys.frame(frame)
[17:39:52.842]                       }
[17:39:52.842]                     }
[17:39:52.842]                     sendCondition <<- function(cond) NULL
[17:39:52.842]                   }
[17:39:52.842]                 })
[17:39:52.842]                 withCallingHandlers({
[17:39:52.842]                   {
[17:39:52.842]                     x[["a"]] <- 1
[17:39:52.842]                     x
[17:39:52.842]                   }
[17:39:52.842]                 }, immediateCondition = function(cond) {
[17:39:52.842]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.842]                   sendCondition(cond)
[17:39:52.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.842]                   {
[17:39:52.842]                     inherits <- base::inherits
[17:39:52.842]                     invokeRestart <- base::invokeRestart
[17:39:52.842]                     is.null <- base::is.null
[17:39:52.842]                     muffled <- FALSE
[17:39:52.842]                     if (inherits(cond, "message")) {
[17:39:52.842]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.842]                       if (muffled) 
[17:39:52.842]                         invokeRestart("muffleMessage")
[17:39:52.842]                     }
[17:39:52.842]                     else if (inherits(cond, "warning")) {
[17:39:52.842]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.842]                       if (muffled) 
[17:39:52.842]                         invokeRestart("muffleWarning")
[17:39:52.842]                     }
[17:39:52.842]                     else if (inherits(cond, "condition")) {
[17:39:52.842]                       if (!is.null(pattern)) {
[17:39:52.842]                         computeRestarts <- base::computeRestarts
[17:39:52.842]                         grepl <- base::grepl
[17:39:52.842]                         restarts <- computeRestarts(cond)
[17:39:52.842]                         for (restart in restarts) {
[17:39:52.842]                           name <- restart$name
[17:39:52.842]                           if (is.null(name)) 
[17:39:52.842]                             next
[17:39:52.842]                           if (!grepl(pattern, name)) 
[17:39:52.842]                             next
[17:39:52.842]                           invokeRestart(restart)
[17:39:52.842]                           muffled <- TRUE
[17:39:52.842]                           break
[17:39:52.842]                         }
[17:39:52.842]                       }
[17:39:52.842]                     }
[17:39:52.842]                     invisible(muffled)
[17:39:52.842]                   }
[17:39:52.842]                   muffleCondition(cond)
[17:39:52.842]                 })
[17:39:52.842]             }))
[17:39:52.842]             future::FutureResult(value = ...future.value$value, 
[17:39:52.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.842]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.842]                     ...future.globalenv.names))
[17:39:52.842]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.842]         }, condition = base::local({
[17:39:52.842]             c <- base::c
[17:39:52.842]             inherits <- base::inherits
[17:39:52.842]             invokeRestart <- base::invokeRestart
[17:39:52.842]             length <- base::length
[17:39:52.842]             list <- base::list
[17:39:52.842]             seq.int <- base::seq.int
[17:39:52.842]             signalCondition <- base::signalCondition
[17:39:52.842]             sys.calls <- base::sys.calls
[17:39:52.842]             `[[` <- base::`[[`
[17:39:52.842]             `+` <- base::`+`
[17:39:52.842]             `<<-` <- base::`<<-`
[17:39:52.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.842]                   3L)]
[17:39:52.842]             }
[17:39:52.842]             function(cond) {
[17:39:52.842]                 is_error <- inherits(cond, "error")
[17:39:52.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.842]                   NULL)
[17:39:52.842]                 if (is_error) {
[17:39:52.842]                   sessionInformation <- function() {
[17:39:52.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.842]                       search = base::search(), system = base::Sys.info())
[17:39:52.842]                   }
[17:39:52.842]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.842]                     cond$call), session = sessionInformation(), 
[17:39:52.842]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.842]                   signalCondition(cond)
[17:39:52.842]                 }
[17:39:52.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.842]                 "immediateCondition"))) {
[17:39:52.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.842]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.842]                   if (TRUE && !signal) {
[17:39:52.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.842]                     {
[17:39:52.842]                       inherits <- base::inherits
[17:39:52.842]                       invokeRestart <- base::invokeRestart
[17:39:52.842]                       is.null <- base::is.null
[17:39:52.842]                       muffled <- FALSE
[17:39:52.842]                       if (inherits(cond, "message")) {
[17:39:52.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.842]                         if (muffled) 
[17:39:52.842]                           invokeRestart("muffleMessage")
[17:39:52.842]                       }
[17:39:52.842]                       else if (inherits(cond, "warning")) {
[17:39:52.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.842]                         if (muffled) 
[17:39:52.842]                           invokeRestart("muffleWarning")
[17:39:52.842]                       }
[17:39:52.842]                       else if (inherits(cond, "condition")) {
[17:39:52.842]                         if (!is.null(pattern)) {
[17:39:52.842]                           computeRestarts <- base::computeRestarts
[17:39:52.842]                           grepl <- base::grepl
[17:39:52.842]                           restarts <- computeRestarts(cond)
[17:39:52.842]                           for (restart in restarts) {
[17:39:52.842]                             name <- restart$name
[17:39:52.842]                             if (is.null(name)) 
[17:39:52.842]                               next
[17:39:52.842]                             if (!grepl(pattern, name)) 
[17:39:52.842]                               next
[17:39:52.842]                             invokeRestart(restart)
[17:39:52.842]                             muffled <- TRUE
[17:39:52.842]                             break
[17:39:52.842]                           }
[17:39:52.842]                         }
[17:39:52.842]                       }
[17:39:52.842]                       invisible(muffled)
[17:39:52.842]                     }
[17:39:52.842]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.842]                   }
[17:39:52.842]                 }
[17:39:52.842]                 else {
[17:39:52.842]                   if (TRUE) {
[17:39:52.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.842]                     {
[17:39:52.842]                       inherits <- base::inherits
[17:39:52.842]                       invokeRestart <- base::invokeRestart
[17:39:52.842]                       is.null <- base::is.null
[17:39:52.842]                       muffled <- FALSE
[17:39:52.842]                       if (inherits(cond, "message")) {
[17:39:52.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.842]                         if (muffled) 
[17:39:52.842]                           invokeRestart("muffleMessage")
[17:39:52.842]                       }
[17:39:52.842]                       else if (inherits(cond, "warning")) {
[17:39:52.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.842]                         if (muffled) 
[17:39:52.842]                           invokeRestart("muffleWarning")
[17:39:52.842]                       }
[17:39:52.842]                       else if (inherits(cond, "condition")) {
[17:39:52.842]                         if (!is.null(pattern)) {
[17:39:52.842]                           computeRestarts <- base::computeRestarts
[17:39:52.842]                           grepl <- base::grepl
[17:39:52.842]                           restarts <- computeRestarts(cond)
[17:39:52.842]                           for (restart in restarts) {
[17:39:52.842]                             name <- restart$name
[17:39:52.842]                             if (is.null(name)) 
[17:39:52.842]                               next
[17:39:52.842]                             if (!grepl(pattern, name)) 
[17:39:52.842]                               next
[17:39:52.842]                             invokeRestart(restart)
[17:39:52.842]                             muffled <- TRUE
[17:39:52.842]                             break
[17:39:52.842]                           }
[17:39:52.842]                         }
[17:39:52.842]                       }
[17:39:52.842]                       invisible(muffled)
[17:39:52.842]                     }
[17:39:52.842]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.842]                   }
[17:39:52.842]                 }
[17:39:52.842]             }
[17:39:52.842]         }))
[17:39:52.842]     }, error = function(ex) {
[17:39:52.842]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.842]                 ...future.rng), started = ...future.startTime, 
[17:39:52.842]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.842]             version = "1.8"), class = "FutureResult")
[17:39:52.842]     }, finally = {
[17:39:52.842]         if (!identical(...future.workdir, getwd())) 
[17:39:52.842]             setwd(...future.workdir)
[17:39:52.842]         {
[17:39:52.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.842]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.842]             }
[17:39:52.842]             base::options(...future.oldOptions)
[17:39:52.842]             if (.Platform$OS.type == "windows") {
[17:39:52.842]                 old_names <- names(...future.oldEnvVars)
[17:39:52.842]                 envs <- base::Sys.getenv()
[17:39:52.842]                 names <- names(envs)
[17:39:52.842]                 common <- intersect(names, old_names)
[17:39:52.842]                 added <- setdiff(names, old_names)
[17:39:52.842]                 removed <- setdiff(old_names, names)
[17:39:52.842]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.842]                   envs[common]]
[17:39:52.842]                 NAMES <- toupper(changed)
[17:39:52.842]                 args <- list()
[17:39:52.842]                 for (kk in seq_along(NAMES)) {
[17:39:52.842]                   name <- changed[[kk]]
[17:39:52.842]                   NAME <- NAMES[[kk]]
[17:39:52.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.842]                     next
[17:39:52.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.842]                 }
[17:39:52.842]                 NAMES <- toupper(added)
[17:39:52.842]                 for (kk in seq_along(NAMES)) {
[17:39:52.842]                   name <- added[[kk]]
[17:39:52.842]                   NAME <- NAMES[[kk]]
[17:39:52.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.842]                     next
[17:39:52.842]                   args[[name]] <- ""
[17:39:52.842]                 }
[17:39:52.842]                 NAMES <- toupper(removed)
[17:39:52.842]                 for (kk in seq_along(NAMES)) {
[17:39:52.842]                   name <- removed[[kk]]
[17:39:52.842]                   NAME <- NAMES[[kk]]
[17:39:52.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.842]                     next
[17:39:52.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.842]                 }
[17:39:52.842]                 if (length(args) > 0) 
[17:39:52.842]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.842]             }
[17:39:52.842]             else {
[17:39:52.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.842]             }
[17:39:52.842]             {
[17:39:52.842]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.842]                   0L) {
[17:39:52.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.842]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.842]                   base::options(opts)
[17:39:52.842]                 }
[17:39:52.842]                 {
[17:39:52.842]                   {
[17:39:52.842]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.842]                     NULL
[17:39:52.842]                   }
[17:39:52.842]                   options(future.plan = NULL)
[17:39:52.842]                   if (is.na(NA_character_)) 
[17:39:52.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.842]                     .init = FALSE)
[17:39:52.842]                 }
[17:39:52.842]             }
[17:39:52.842]         }
[17:39:52.842]     })
[17:39:52.842]     if (TRUE) {
[17:39:52.842]         base::sink(type = "output", split = FALSE)
[17:39:52.842]         if (TRUE) {
[17:39:52.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.842]         }
[17:39:52.842]         else {
[17:39:52.842]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.842]         }
[17:39:52.842]         base::close(...future.stdout)
[17:39:52.842]         ...future.stdout <- NULL
[17:39:52.842]     }
[17:39:52.842]     ...future.result$conditions <- ...future.conditions
[17:39:52.842]     ...future.result$finished <- base::Sys.time()
[17:39:52.842]     ...future.result
[17:39:52.842] }
[17:39:52.845] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.845] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.845] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.845] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.846] MultisessionFuture started
[17:39:52.846] - Launch lazy future ... done
[17:39:52.846] run() for ‘MultisessionFuture’ ... done
[17:39:52.846] result() for ClusterFuture ...
[17:39:52.846] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.846] - Validating connection of MultisessionFuture
[17:39:52.847] - received message: FutureResult
[17:39:52.847] - Received FutureResult
[17:39:52.848] - Erased future from FutureRegistry
[17:39:52.848] result() for ClusterFuture ...
[17:39:52.848] - result already collected: FutureResult
[17:39:52.848] result() for ClusterFuture ... done
[17:39:52.848] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.848] result() for ClusterFuture ... done
[17:39:52.848] result() for ClusterFuture ...
[17:39:52.848] - result already collected: FutureResult
[17:39:52.848] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.849] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.849] Searching for globals...
[17:39:52.851] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:52.851] Searching for globals ... DONE
[17:39:52.851] Resolving globals: TRUE
[17:39:52.851] Resolving any globals that are futures ...
[17:39:52.851] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:39:52.851] Resolving any globals that are futures ... DONE
[17:39:52.852] Resolving futures part of globals (recursively) ...
[17:39:52.852] resolve() on list ...
[17:39:52.852]  recursive: 99
[17:39:52.852]  length: 1
[17:39:52.852]  elements: ‘x’
[17:39:52.852]  length: 0 (resolved future 1)
[17:39:52.852] resolve() on list ... DONE
[17:39:52.852] - globals: [1] ‘x’
[17:39:52.853] Resolving futures part of globals (recursively) ... DONE
[17:39:52.853] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.853] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.853] - globals: [1] ‘x’
[17:39:52.853] 
[17:39:52.853] getGlobalsAndPackages() ... DONE
[17:39:52.859] run() for ‘Future’ ...
[17:39:52.859] - state: ‘created’
[17:39:52.859] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.873] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.873]   - Field: ‘node’
[17:39:52.873]   - Field: ‘label’
[17:39:52.873]   - Field: ‘local’
[17:39:52.873]   - Field: ‘owner’
[17:39:52.873]   - Field: ‘envir’
[17:39:52.873]   - Field: ‘workers’
[17:39:52.873]   - Field: ‘packages’
[17:39:52.873]   - Field: ‘gc’
[17:39:52.874]   - Field: ‘conditions’
[17:39:52.874]   - Field: ‘persistent’
[17:39:52.874]   - Field: ‘expr’
[17:39:52.874]   - Field: ‘uuid’
[17:39:52.874]   - Field: ‘seed’
[17:39:52.874]   - Field: ‘version’
[17:39:52.874]   - Field: ‘result’
[17:39:52.874]   - Field: ‘asynchronous’
[17:39:52.874]   - Field: ‘calls’
[17:39:52.874]   - Field: ‘globals’
[17:39:52.874]   - Field: ‘stdout’
[17:39:52.874]   - Field: ‘earlySignal’
[17:39:52.875]   - Field: ‘lazy’
[17:39:52.875]   - Field: ‘state’
[17:39:52.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.875] - Launch lazy future ...
[17:39:52.875] Packages needed by the future expression (n = 0): <none>
[17:39:52.875] Packages needed by future strategies (n = 0): <none>
[17:39:52.876] {
[17:39:52.876]     {
[17:39:52.876]         {
[17:39:52.876]             ...future.startTime <- base::Sys.time()
[17:39:52.876]             {
[17:39:52.876]                 {
[17:39:52.876]                   {
[17:39:52.876]                     {
[17:39:52.876]                       base::local({
[17:39:52.876]                         has_future <- base::requireNamespace("future", 
[17:39:52.876]                           quietly = TRUE)
[17:39:52.876]                         if (has_future) {
[17:39:52.876]                           ns <- base::getNamespace("future")
[17:39:52.876]                           version <- ns[[".package"]][["version"]]
[17:39:52.876]                           if (is.null(version)) 
[17:39:52.876]                             version <- utils::packageVersion("future")
[17:39:52.876]                         }
[17:39:52.876]                         else {
[17:39:52.876]                           version <- NULL
[17:39:52.876]                         }
[17:39:52.876]                         if (!has_future || version < "1.8.0") {
[17:39:52.876]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.876]                             "", base::R.version$version.string), 
[17:39:52.876]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.876]                               "release", "version")], collapse = " "), 
[17:39:52.876]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.876]                             info)
[17:39:52.876]                           info <- base::paste(info, collapse = "; ")
[17:39:52.876]                           if (!has_future) {
[17:39:52.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.876]                               info)
[17:39:52.876]                           }
[17:39:52.876]                           else {
[17:39:52.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.876]                               info, version)
[17:39:52.876]                           }
[17:39:52.876]                           base::stop(msg)
[17:39:52.876]                         }
[17:39:52.876]                       })
[17:39:52.876]                     }
[17:39:52.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.876]                     base::options(mc.cores = 1L)
[17:39:52.876]                   }
[17:39:52.876]                   ...future.strategy.old <- future::plan("list")
[17:39:52.876]                   options(future.plan = NULL)
[17:39:52.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.876]                 }
[17:39:52.876]                 ...future.workdir <- getwd()
[17:39:52.876]             }
[17:39:52.876]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.876]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.876]         }
[17:39:52.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.876]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.876]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.876]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.876]             base::names(...future.oldOptions))
[17:39:52.876]     }
[17:39:52.876]     if (FALSE) {
[17:39:52.876]     }
[17:39:52.876]     else {
[17:39:52.876]         if (TRUE) {
[17:39:52.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.876]                 open = "w")
[17:39:52.876]         }
[17:39:52.876]         else {
[17:39:52.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.876]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.876]         }
[17:39:52.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.876]             base::sink(type = "output", split = FALSE)
[17:39:52.876]             base::close(...future.stdout)
[17:39:52.876]         }, add = TRUE)
[17:39:52.876]     }
[17:39:52.876]     ...future.frame <- base::sys.nframe()
[17:39:52.876]     ...future.conditions <- base::list()
[17:39:52.876]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.876]     if (FALSE) {
[17:39:52.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.876]     }
[17:39:52.876]     ...future.result <- base::tryCatch({
[17:39:52.876]         base::withCallingHandlers({
[17:39:52.876]             ...future.value <- base::withVisible(base::local({
[17:39:52.876]                 ...future.makeSendCondition <- base::local({
[17:39:52.876]                   sendCondition <- NULL
[17:39:52.876]                   function(frame = 1L) {
[17:39:52.876]                     if (is.function(sendCondition)) 
[17:39:52.876]                       return(sendCondition)
[17:39:52.876]                     ns <- getNamespace("parallel")
[17:39:52.876]                     if (exists("sendData", mode = "function", 
[17:39:52.876]                       envir = ns)) {
[17:39:52.876]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.876]                         envir = ns)
[17:39:52.876]                       envir <- sys.frame(frame)
[17:39:52.876]                       master <- NULL
[17:39:52.876]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.876]                         !identical(envir, emptyenv())) {
[17:39:52.876]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.876]                           inherits = FALSE)) {
[17:39:52.876]                           master <- get("master", mode = "list", 
[17:39:52.876]                             envir = envir, inherits = FALSE)
[17:39:52.876]                           if (inherits(master, c("SOCKnode", 
[17:39:52.876]                             "SOCK0node"))) {
[17:39:52.876]                             sendCondition <<- function(cond) {
[17:39:52.876]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.876]                                 success = TRUE)
[17:39:52.876]                               parallel_sendData(master, data)
[17:39:52.876]                             }
[17:39:52.876]                             return(sendCondition)
[17:39:52.876]                           }
[17:39:52.876]                         }
[17:39:52.876]                         frame <- frame + 1L
[17:39:52.876]                         envir <- sys.frame(frame)
[17:39:52.876]                       }
[17:39:52.876]                     }
[17:39:52.876]                     sendCondition <<- function(cond) NULL
[17:39:52.876]                   }
[17:39:52.876]                 })
[17:39:52.876]                 withCallingHandlers({
[17:39:52.876]                   {
[17:39:52.876]                     x[["a"]] <- 1
[17:39:52.876]                     x
[17:39:52.876]                   }
[17:39:52.876]                 }, immediateCondition = function(cond) {
[17:39:52.876]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.876]                   sendCondition(cond)
[17:39:52.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.876]                   {
[17:39:52.876]                     inherits <- base::inherits
[17:39:52.876]                     invokeRestart <- base::invokeRestart
[17:39:52.876]                     is.null <- base::is.null
[17:39:52.876]                     muffled <- FALSE
[17:39:52.876]                     if (inherits(cond, "message")) {
[17:39:52.876]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.876]                       if (muffled) 
[17:39:52.876]                         invokeRestart("muffleMessage")
[17:39:52.876]                     }
[17:39:52.876]                     else if (inherits(cond, "warning")) {
[17:39:52.876]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.876]                       if (muffled) 
[17:39:52.876]                         invokeRestart("muffleWarning")
[17:39:52.876]                     }
[17:39:52.876]                     else if (inherits(cond, "condition")) {
[17:39:52.876]                       if (!is.null(pattern)) {
[17:39:52.876]                         computeRestarts <- base::computeRestarts
[17:39:52.876]                         grepl <- base::grepl
[17:39:52.876]                         restarts <- computeRestarts(cond)
[17:39:52.876]                         for (restart in restarts) {
[17:39:52.876]                           name <- restart$name
[17:39:52.876]                           if (is.null(name)) 
[17:39:52.876]                             next
[17:39:52.876]                           if (!grepl(pattern, name)) 
[17:39:52.876]                             next
[17:39:52.876]                           invokeRestart(restart)
[17:39:52.876]                           muffled <- TRUE
[17:39:52.876]                           break
[17:39:52.876]                         }
[17:39:52.876]                       }
[17:39:52.876]                     }
[17:39:52.876]                     invisible(muffled)
[17:39:52.876]                   }
[17:39:52.876]                   muffleCondition(cond)
[17:39:52.876]                 })
[17:39:52.876]             }))
[17:39:52.876]             future::FutureResult(value = ...future.value$value, 
[17:39:52.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.876]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.876]                     ...future.globalenv.names))
[17:39:52.876]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.876]         }, condition = base::local({
[17:39:52.876]             c <- base::c
[17:39:52.876]             inherits <- base::inherits
[17:39:52.876]             invokeRestart <- base::invokeRestart
[17:39:52.876]             length <- base::length
[17:39:52.876]             list <- base::list
[17:39:52.876]             seq.int <- base::seq.int
[17:39:52.876]             signalCondition <- base::signalCondition
[17:39:52.876]             sys.calls <- base::sys.calls
[17:39:52.876]             `[[` <- base::`[[`
[17:39:52.876]             `+` <- base::`+`
[17:39:52.876]             `<<-` <- base::`<<-`
[17:39:52.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.876]                   3L)]
[17:39:52.876]             }
[17:39:52.876]             function(cond) {
[17:39:52.876]                 is_error <- inherits(cond, "error")
[17:39:52.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.876]                   NULL)
[17:39:52.876]                 if (is_error) {
[17:39:52.876]                   sessionInformation <- function() {
[17:39:52.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.876]                       search = base::search(), system = base::Sys.info())
[17:39:52.876]                   }
[17:39:52.876]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.876]                     cond$call), session = sessionInformation(), 
[17:39:52.876]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.876]                   signalCondition(cond)
[17:39:52.876]                 }
[17:39:52.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.876]                 "immediateCondition"))) {
[17:39:52.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.876]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.876]                   if (TRUE && !signal) {
[17:39:52.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.876]                     {
[17:39:52.876]                       inherits <- base::inherits
[17:39:52.876]                       invokeRestart <- base::invokeRestart
[17:39:52.876]                       is.null <- base::is.null
[17:39:52.876]                       muffled <- FALSE
[17:39:52.876]                       if (inherits(cond, "message")) {
[17:39:52.876]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.876]                         if (muffled) 
[17:39:52.876]                           invokeRestart("muffleMessage")
[17:39:52.876]                       }
[17:39:52.876]                       else if (inherits(cond, "warning")) {
[17:39:52.876]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.876]                         if (muffled) 
[17:39:52.876]                           invokeRestart("muffleWarning")
[17:39:52.876]                       }
[17:39:52.876]                       else if (inherits(cond, "condition")) {
[17:39:52.876]                         if (!is.null(pattern)) {
[17:39:52.876]                           computeRestarts <- base::computeRestarts
[17:39:52.876]                           grepl <- base::grepl
[17:39:52.876]                           restarts <- computeRestarts(cond)
[17:39:52.876]                           for (restart in restarts) {
[17:39:52.876]                             name <- restart$name
[17:39:52.876]                             if (is.null(name)) 
[17:39:52.876]                               next
[17:39:52.876]                             if (!grepl(pattern, name)) 
[17:39:52.876]                               next
[17:39:52.876]                             invokeRestart(restart)
[17:39:52.876]                             muffled <- TRUE
[17:39:52.876]                             break
[17:39:52.876]                           }
[17:39:52.876]                         }
[17:39:52.876]                       }
[17:39:52.876]                       invisible(muffled)
[17:39:52.876]                     }
[17:39:52.876]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.876]                   }
[17:39:52.876]                 }
[17:39:52.876]                 else {
[17:39:52.876]                   if (TRUE) {
[17:39:52.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.876]                     {
[17:39:52.876]                       inherits <- base::inherits
[17:39:52.876]                       invokeRestart <- base::invokeRestart
[17:39:52.876]                       is.null <- base::is.null
[17:39:52.876]                       muffled <- FALSE
[17:39:52.876]                       if (inherits(cond, "message")) {
[17:39:52.876]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.876]                         if (muffled) 
[17:39:52.876]                           invokeRestart("muffleMessage")
[17:39:52.876]                       }
[17:39:52.876]                       else if (inherits(cond, "warning")) {
[17:39:52.876]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.876]                         if (muffled) 
[17:39:52.876]                           invokeRestart("muffleWarning")
[17:39:52.876]                       }
[17:39:52.876]                       else if (inherits(cond, "condition")) {
[17:39:52.876]                         if (!is.null(pattern)) {
[17:39:52.876]                           computeRestarts <- base::computeRestarts
[17:39:52.876]                           grepl <- base::grepl
[17:39:52.876]                           restarts <- computeRestarts(cond)
[17:39:52.876]                           for (restart in restarts) {
[17:39:52.876]                             name <- restart$name
[17:39:52.876]                             if (is.null(name)) 
[17:39:52.876]                               next
[17:39:52.876]                             if (!grepl(pattern, name)) 
[17:39:52.876]                               next
[17:39:52.876]                             invokeRestart(restart)
[17:39:52.876]                             muffled <- TRUE
[17:39:52.876]                             break
[17:39:52.876]                           }
[17:39:52.876]                         }
[17:39:52.876]                       }
[17:39:52.876]                       invisible(muffled)
[17:39:52.876]                     }
[17:39:52.876]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.876]                   }
[17:39:52.876]                 }
[17:39:52.876]             }
[17:39:52.876]         }))
[17:39:52.876]     }, error = function(ex) {
[17:39:52.876]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.876]                 ...future.rng), started = ...future.startTime, 
[17:39:52.876]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.876]             version = "1.8"), class = "FutureResult")
[17:39:52.876]     }, finally = {
[17:39:52.876]         if (!identical(...future.workdir, getwd())) 
[17:39:52.876]             setwd(...future.workdir)
[17:39:52.876]         {
[17:39:52.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.876]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.876]             }
[17:39:52.876]             base::options(...future.oldOptions)
[17:39:52.876]             if (.Platform$OS.type == "windows") {
[17:39:52.876]                 old_names <- names(...future.oldEnvVars)
[17:39:52.876]                 envs <- base::Sys.getenv()
[17:39:52.876]                 names <- names(envs)
[17:39:52.876]                 common <- intersect(names, old_names)
[17:39:52.876]                 added <- setdiff(names, old_names)
[17:39:52.876]                 removed <- setdiff(old_names, names)
[17:39:52.876]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.876]                   envs[common]]
[17:39:52.876]                 NAMES <- toupper(changed)
[17:39:52.876]                 args <- list()
[17:39:52.876]                 for (kk in seq_along(NAMES)) {
[17:39:52.876]                   name <- changed[[kk]]
[17:39:52.876]                   NAME <- NAMES[[kk]]
[17:39:52.876]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.876]                     next
[17:39:52.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.876]                 }
[17:39:52.876]                 NAMES <- toupper(added)
[17:39:52.876]                 for (kk in seq_along(NAMES)) {
[17:39:52.876]                   name <- added[[kk]]
[17:39:52.876]                   NAME <- NAMES[[kk]]
[17:39:52.876]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.876]                     next
[17:39:52.876]                   args[[name]] <- ""
[17:39:52.876]                 }
[17:39:52.876]                 NAMES <- toupper(removed)
[17:39:52.876]                 for (kk in seq_along(NAMES)) {
[17:39:52.876]                   name <- removed[[kk]]
[17:39:52.876]                   NAME <- NAMES[[kk]]
[17:39:52.876]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.876]                     next
[17:39:52.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.876]                 }
[17:39:52.876]                 if (length(args) > 0) 
[17:39:52.876]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.876]             }
[17:39:52.876]             else {
[17:39:52.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.876]             }
[17:39:52.876]             {
[17:39:52.876]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.876]                   0L) {
[17:39:52.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.876]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.876]                   base::options(opts)
[17:39:52.876]                 }
[17:39:52.876]                 {
[17:39:52.876]                   {
[17:39:52.876]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.876]                     NULL
[17:39:52.876]                   }
[17:39:52.876]                   options(future.plan = NULL)
[17:39:52.876]                   if (is.na(NA_character_)) 
[17:39:52.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.876]                     .init = FALSE)
[17:39:52.876]                 }
[17:39:52.876]             }
[17:39:52.876]         }
[17:39:52.876]     })
[17:39:52.876]     if (TRUE) {
[17:39:52.876]         base::sink(type = "output", split = FALSE)
[17:39:52.876]         if (TRUE) {
[17:39:52.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.876]         }
[17:39:52.876]         else {
[17:39:52.876]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.876]         }
[17:39:52.876]         base::close(...future.stdout)
[17:39:52.876]         ...future.stdout <- NULL
[17:39:52.876]     }
[17:39:52.876]     ...future.result$conditions <- ...future.conditions
[17:39:52.876]     ...future.result$finished <- base::Sys.time()
[17:39:52.876]     ...future.result
[17:39:52.876] }
[17:39:52.878] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.878] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.879] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.879] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.879] MultisessionFuture started
[17:39:52.879] - Launch lazy future ... done
[17:39:52.879] run() for ‘MultisessionFuture’ ... done
[17:39:52.880] result() for ClusterFuture ...
[17:39:52.880] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.880] - Validating connection of MultisessionFuture
[17:39:52.881] - received message: FutureResult
[17:39:52.881] - Received FutureResult
[17:39:52.881] - Erased future from FutureRegistry
[17:39:52.881] result() for ClusterFuture ...
[17:39:52.881] - result already collected: FutureResult
[17:39:52.882] result() for ClusterFuture ... done
[17:39:52.882] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.882] result() for ClusterFuture ... done
[17:39:52.882] result() for ClusterFuture ...
[17:39:52.882] - result already collected: FutureResult
[17:39:52.882] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.882] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.882] Searching for globals...
[17:39:52.884] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:52.884] Searching for globals ... DONE
[17:39:52.885] Resolving globals: TRUE
[17:39:52.885] Resolving any globals that are futures ...
[17:39:52.885] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:52.885] Resolving any globals that are futures ... DONE
[17:39:52.885] Resolving futures part of globals (recursively) ...
[17:39:52.885] resolve() on list ...
[17:39:52.885]  recursive: 99
[17:39:52.886]  length: 1
[17:39:52.886]  elements: ‘x’
[17:39:52.886]  length: 0 (resolved future 1)
[17:39:52.886] resolve() on list ... DONE
[17:39:52.886] - globals: [1] ‘x’
[17:39:52.886] Resolving futures part of globals (recursively) ... DONE
[17:39:52.886] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.886] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.887] - globals: [1] ‘x’
[17:39:52.887] 
[17:39:52.887] getGlobalsAndPackages() ... DONE
[17:39:52.887] run() for ‘Future’ ...
[17:39:52.887] - state: ‘created’
[17:39:52.887] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.900] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.900]   - Field: ‘node’
[17:39:52.901]   - Field: ‘label’
[17:39:52.901]   - Field: ‘local’
[17:39:52.901]   - Field: ‘owner’
[17:39:52.901]   - Field: ‘envir’
[17:39:52.901]   - Field: ‘workers’
[17:39:52.901]   - Field: ‘packages’
[17:39:52.901]   - Field: ‘gc’
[17:39:52.901]   - Field: ‘conditions’
[17:39:52.901]   - Field: ‘persistent’
[17:39:52.901]   - Field: ‘expr’
[17:39:52.901]   - Field: ‘uuid’
[17:39:52.902]   - Field: ‘seed’
[17:39:52.902]   - Field: ‘version’
[17:39:52.902]   - Field: ‘result’
[17:39:52.902]   - Field: ‘asynchronous’
[17:39:52.902]   - Field: ‘calls’
[17:39:52.902]   - Field: ‘globals’
[17:39:52.902]   - Field: ‘stdout’
[17:39:52.902]   - Field: ‘earlySignal’
[17:39:52.902]   - Field: ‘lazy’
[17:39:52.902]   - Field: ‘state’
[17:39:52.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.902] - Launch lazy future ...
[17:39:52.903] Packages needed by the future expression (n = 0): <none>
[17:39:52.903] Packages needed by future strategies (n = 0): <none>
[17:39:52.903] {
[17:39:52.903]     {
[17:39:52.903]         {
[17:39:52.903]             ...future.startTime <- base::Sys.time()
[17:39:52.903]             {
[17:39:52.903]                 {
[17:39:52.903]                   {
[17:39:52.903]                     {
[17:39:52.903]                       base::local({
[17:39:52.903]                         has_future <- base::requireNamespace("future", 
[17:39:52.903]                           quietly = TRUE)
[17:39:52.903]                         if (has_future) {
[17:39:52.903]                           ns <- base::getNamespace("future")
[17:39:52.903]                           version <- ns[[".package"]][["version"]]
[17:39:52.903]                           if (is.null(version)) 
[17:39:52.903]                             version <- utils::packageVersion("future")
[17:39:52.903]                         }
[17:39:52.903]                         else {
[17:39:52.903]                           version <- NULL
[17:39:52.903]                         }
[17:39:52.903]                         if (!has_future || version < "1.8.0") {
[17:39:52.903]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.903]                             "", base::R.version$version.string), 
[17:39:52.903]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.903]                               "release", "version")], collapse = " "), 
[17:39:52.903]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.903]                             info)
[17:39:52.903]                           info <- base::paste(info, collapse = "; ")
[17:39:52.903]                           if (!has_future) {
[17:39:52.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.903]                               info)
[17:39:52.903]                           }
[17:39:52.903]                           else {
[17:39:52.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.903]                               info, version)
[17:39:52.903]                           }
[17:39:52.903]                           base::stop(msg)
[17:39:52.903]                         }
[17:39:52.903]                       })
[17:39:52.903]                     }
[17:39:52.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.903]                     base::options(mc.cores = 1L)
[17:39:52.903]                   }
[17:39:52.903]                   ...future.strategy.old <- future::plan("list")
[17:39:52.903]                   options(future.plan = NULL)
[17:39:52.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.903]                 }
[17:39:52.903]                 ...future.workdir <- getwd()
[17:39:52.903]             }
[17:39:52.903]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.903]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.903]         }
[17:39:52.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.903]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.903]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.903]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.903]             base::names(...future.oldOptions))
[17:39:52.903]     }
[17:39:52.903]     if (FALSE) {
[17:39:52.903]     }
[17:39:52.903]     else {
[17:39:52.903]         if (TRUE) {
[17:39:52.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.903]                 open = "w")
[17:39:52.903]         }
[17:39:52.903]         else {
[17:39:52.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.903]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.903]         }
[17:39:52.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.903]             base::sink(type = "output", split = FALSE)
[17:39:52.903]             base::close(...future.stdout)
[17:39:52.903]         }, add = TRUE)
[17:39:52.903]     }
[17:39:52.903]     ...future.frame <- base::sys.nframe()
[17:39:52.903]     ...future.conditions <- base::list()
[17:39:52.903]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.903]     if (FALSE) {
[17:39:52.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.903]     }
[17:39:52.903]     ...future.result <- base::tryCatch({
[17:39:52.903]         base::withCallingHandlers({
[17:39:52.903]             ...future.value <- base::withVisible(base::local({
[17:39:52.903]                 ...future.makeSendCondition <- base::local({
[17:39:52.903]                   sendCondition <- NULL
[17:39:52.903]                   function(frame = 1L) {
[17:39:52.903]                     if (is.function(sendCondition)) 
[17:39:52.903]                       return(sendCondition)
[17:39:52.903]                     ns <- getNamespace("parallel")
[17:39:52.903]                     if (exists("sendData", mode = "function", 
[17:39:52.903]                       envir = ns)) {
[17:39:52.903]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.903]                         envir = ns)
[17:39:52.903]                       envir <- sys.frame(frame)
[17:39:52.903]                       master <- NULL
[17:39:52.903]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.903]                         !identical(envir, emptyenv())) {
[17:39:52.903]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.903]                           inherits = FALSE)) {
[17:39:52.903]                           master <- get("master", mode = "list", 
[17:39:52.903]                             envir = envir, inherits = FALSE)
[17:39:52.903]                           if (inherits(master, c("SOCKnode", 
[17:39:52.903]                             "SOCK0node"))) {
[17:39:52.903]                             sendCondition <<- function(cond) {
[17:39:52.903]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.903]                                 success = TRUE)
[17:39:52.903]                               parallel_sendData(master, data)
[17:39:52.903]                             }
[17:39:52.903]                             return(sendCondition)
[17:39:52.903]                           }
[17:39:52.903]                         }
[17:39:52.903]                         frame <- frame + 1L
[17:39:52.903]                         envir <- sys.frame(frame)
[17:39:52.903]                       }
[17:39:52.903]                     }
[17:39:52.903]                     sendCondition <<- function(cond) NULL
[17:39:52.903]                   }
[17:39:52.903]                 })
[17:39:52.903]                 withCallingHandlers({
[17:39:52.903]                   {
[17:39:52.903]                     x["a"] <- list(1)
[17:39:52.903]                     x
[17:39:52.903]                   }
[17:39:52.903]                 }, immediateCondition = function(cond) {
[17:39:52.903]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.903]                   sendCondition(cond)
[17:39:52.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.903]                   {
[17:39:52.903]                     inherits <- base::inherits
[17:39:52.903]                     invokeRestart <- base::invokeRestart
[17:39:52.903]                     is.null <- base::is.null
[17:39:52.903]                     muffled <- FALSE
[17:39:52.903]                     if (inherits(cond, "message")) {
[17:39:52.903]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.903]                       if (muffled) 
[17:39:52.903]                         invokeRestart("muffleMessage")
[17:39:52.903]                     }
[17:39:52.903]                     else if (inherits(cond, "warning")) {
[17:39:52.903]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.903]                       if (muffled) 
[17:39:52.903]                         invokeRestart("muffleWarning")
[17:39:52.903]                     }
[17:39:52.903]                     else if (inherits(cond, "condition")) {
[17:39:52.903]                       if (!is.null(pattern)) {
[17:39:52.903]                         computeRestarts <- base::computeRestarts
[17:39:52.903]                         grepl <- base::grepl
[17:39:52.903]                         restarts <- computeRestarts(cond)
[17:39:52.903]                         for (restart in restarts) {
[17:39:52.903]                           name <- restart$name
[17:39:52.903]                           if (is.null(name)) 
[17:39:52.903]                             next
[17:39:52.903]                           if (!grepl(pattern, name)) 
[17:39:52.903]                             next
[17:39:52.903]                           invokeRestart(restart)
[17:39:52.903]                           muffled <- TRUE
[17:39:52.903]                           break
[17:39:52.903]                         }
[17:39:52.903]                       }
[17:39:52.903]                     }
[17:39:52.903]                     invisible(muffled)
[17:39:52.903]                   }
[17:39:52.903]                   muffleCondition(cond)
[17:39:52.903]                 })
[17:39:52.903]             }))
[17:39:52.903]             future::FutureResult(value = ...future.value$value, 
[17:39:52.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.903]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.903]                     ...future.globalenv.names))
[17:39:52.903]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.903]         }, condition = base::local({
[17:39:52.903]             c <- base::c
[17:39:52.903]             inherits <- base::inherits
[17:39:52.903]             invokeRestart <- base::invokeRestart
[17:39:52.903]             length <- base::length
[17:39:52.903]             list <- base::list
[17:39:52.903]             seq.int <- base::seq.int
[17:39:52.903]             signalCondition <- base::signalCondition
[17:39:52.903]             sys.calls <- base::sys.calls
[17:39:52.903]             `[[` <- base::`[[`
[17:39:52.903]             `+` <- base::`+`
[17:39:52.903]             `<<-` <- base::`<<-`
[17:39:52.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.903]                   3L)]
[17:39:52.903]             }
[17:39:52.903]             function(cond) {
[17:39:52.903]                 is_error <- inherits(cond, "error")
[17:39:52.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.903]                   NULL)
[17:39:52.903]                 if (is_error) {
[17:39:52.903]                   sessionInformation <- function() {
[17:39:52.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.903]                       search = base::search(), system = base::Sys.info())
[17:39:52.903]                   }
[17:39:52.903]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.903]                     cond$call), session = sessionInformation(), 
[17:39:52.903]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.903]                   signalCondition(cond)
[17:39:52.903]                 }
[17:39:52.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.903]                 "immediateCondition"))) {
[17:39:52.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.903]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.903]                   if (TRUE && !signal) {
[17:39:52.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.903]                     {
[17:39:52.903]                       inherits <- base::inherits
[17:39:52.903]                       invokeRestart <- base::invokeRestart
[17:39:52.903]                       is.null <- base::is.null
[17:39:52.903]                       muffled <- FALSE
[17:39:52.903]                       if (inherits(cond, "message")) {
[17:39:52.903]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.903]                         if (muffled) 
[17:39:52.903]                           invokeRestart("muffleMessage")
[17:39:52.903]                       }
[17:39:52.903]                       else if (inherits(cond, "warning")) {
[17:39:52.903]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.903]                         if (muffled) 
[17:39:52.903]                           invokeRestart("muffleWarning")
[17:39:52.903]                       }
[17:39:52.903]                       else if (inherits(cond, "condition")) {
[17:39:52.903]                         if (!is.null(pattern)) {
[17:39:52.903]                           computeRestarts <- base::computeRestarts
[17:39:52.903]                           grepl <- base::grepl
[17:39:52.903]                           restarts <- computeRestarts(cond)
[17:39:52.903]                           for (restart in restarts) {
[17:39:52.903]                             name <- restart$name
[17:39:52.903]                             if (is.null(name)) 
[17:39:52.903]                               next
[17:39:52.903]                             if (!grepl(pattern, name)) 
[17:39:52.903]                               next
[17:39:52.903]                             invokeRestart(restart)
[17:39:52.903]                             muffled <- TRUE
[17:39:52.903]                             break
[17:39:52.903]                           }
[17:39:52.903]                         }
[17:39:52.903]                       }
[17:39:52.903]                       invisible(muffled)
[17:39:52.903]                     }
[17:39:52.903]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.903]                   }
[17:39:52.903]                 }
[17:39:52.903]                 else {
[17:39:52.903]                   if (TRUE) {
[17:39:52.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.903]                     {
[17:39:52.903]                       inherits <- base::inherits
[17:39:52.903]                       invokeRestart <- base::invokeRestart
[17:39:52.903]                       is.null <- base::is.null
[17:39:52.903]                       muffled <- FALSE
[17:39:52.903]                       if (inherits(cond, "message")) {
[17:39:52.903]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.903]                         if (muffled) 
[17:39:52.903]                           invokeRestart("muffleMessage")
[17:39:52.903]                       }
[17:39:52.903]                       else if (inherits(cond, "warning")) {
[17:39:52.903]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.903]                         if (muffled) 
[17:39:52.903]                           invokeRestart("muffleWarning")
[17:39:52.903]                       }
[17:39:52.903]                       else if (inherits(cond, "condition")) {
[17:39:52.903]                         if (!is.null(pattern)) {
[17:39:52.903]                           computeRestarts <- base::computeRestarts
[17:39:52.903]                           grepl <- base::grepl
[17:39:52.903]                           restarts <- computeRestarts(cond)
[17:39:52.903]                           for (restart in restarts) {
[17:39:52.903]                             name <- restart$name
[17:39:52.903]                             if (is.null(name)) 
[17:39:52.903]                               next
[17:39:52.903]                             if (!grepl(pattern, name)) 
[17:39:52.903]                               next
[17:39:52.903]                             invokeRestart(restart)
[17:39:52.903]                             muffled <- TRUE
[17:39:52.903]                             break
[17:39:52.903]                           }
[17:39:52.903]                         }
[17:39:52.903]                       }
[17:39:52.903]                       invisible(muffled)
[17:39:52.903]                     }
[17:39:52.903]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.903]                   }
[17:39:52.903]                 }
[17:39:52.903]             }
[17:39:52.903]         }))
[17:39:52.903]     }, error = function(ex) {
[17:39:52.903]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.903]                 ...future.rng), started = ...future.startTime, 
[17:39:52.903]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.903]             version = "1.8"), class = "FutureResult")
[17:39:52.903]     }, finally = {
[17:39:52.903]         if (!identical(...future.workdir, getwd())) 
[17:39:52.903]             setwd(...future.workdir)
[17:39:52.903]         {
[17:39:52.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.903]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.903]             }
[17:39:52.903]             base::options(...future.oldOptions)
[17:39:52.903]             if (.Platform$OS.type == "windows") {
[17:39:52.903]                 old_names <- names(...future.oldEnvVars)
[17:39:52.903]                 envs <- base::Sys.getenv()
[17:39:52.903]                 names <- names(envs)
[17:39:52.903]                 common <- intersect(names, old_names)
[17:39:52.903]                 added <- setdiff(names, old_names)
[17:39:52.903]                 removed <- setdiff(old_names, names)
[17:39:52.903]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.903]                   envs[common]]
[17:39:52.903]                 NAMES <- toupper(changed)
[17:39:52.903]                 args <- list()
[17:39:52.903]                 for (kk in seq_along(NAMES)) {
[17:39:52.903]                   name <- changed[[kk]]
[17:39:52.903]                   NAME <- NAMES[[kk]]
[17:39:52.903]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.903]                     next
[17:39:52.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.903]                 }
[17:39:52.903]                 NAMES <- toupper(added)
[17:39:52.903]                 for (kk in seq_along(NAMES)) {
[17:39:52.903]                   name <- added[[kk]]
[17:39:52.903]                   NAME <- NAMES[[kk]]
[17:39:52.903]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.903]                     next
[17:39:52.903]                   args[[name]] <- ""
[17:39:52.903]                 }
[17:39:52.903]                 NAMES <- toupper(removed)
[17:39:52.903]                 for (kk in seq_along(NAMES)) {
[17:39:52.903]                   name <- removed[[kk]]
[17:39:52.903]                   NAME <- NAMES[[kk]]
[17:39:52.903]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.903]                     next
[17:39:52.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.903]                 }
[17:39:52.903]                 if (length(args) > 0) 
[17:39:52.903]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.903]             }
[17:39:52.903]             else {
[17:39:52.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.903]             }
[17:39:52.903]             {
[17:39:52.903]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.903]                   0L) {
[17:39:52.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.903]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.903]                   base::options(opts)
[17:39:52.903]                 }
[17:39:52.903]                 {
[17:39:52.903]                   {
[17:39:52.903]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.903]                     NULL
[17:39:52.903]                   }
[17:39:52.903]                   options(future.plan = NULL)
[17:39:52.903]                   if (is.na(NA_character_)) 
[17:39:52.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.903]                     .init = FALSE)
[17:39:52.903]                 }
[17:39:52.903]             }
[17:39:52.903]         }
[17:39:52.903]     })
[17:39:52.903]     if (TRUE) {
[17:39:52.903]         base::sink(type = "output", split = FALSE)
[17:39:52.903]         if (TRUE) {
[17:39:52.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.903]         }
[17:39:52.903]         else {
[17:39:52.903]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.903]         }
[17:39:52.903]         base::close(...future.stdout)
[17:39:52.903]         ...future.stdout <- NULL
[17:39:52.903]     }
[17:39:52.903]     ...future.result$conditions <- ...future.conditions
[17:39:52.903]     ...future.result$finished <- base::Sys.time()
[17:39:52.903]     ...future.result
[17:39:52.903] }
[17:39:52.906] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.906] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.906] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.906] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.907] MultisessionFuture started
[17:39:52.907] - Launch lazy future ... done
[17:39:52.907] run() for ‘MultisessionFuture’ ... done
[17:39:52.907] result() for ClusterFuture ...
[17:39:52.907] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.908] - Validating connection of MultisessionFuture
[17:39:52.909] - received message: FutureResult
[17:39:52.909] - Received FutureResult
[17:39:52.909] - Erased future from FutureRegistry
[17:39:52.909] result() for ClusterFuture ...
[17:39:52.909] - result already collected: FutureResult
[17:39:52.909] result() for ClusterFuture ... done
[17:39:52.909] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.909] result() for ClusterFuture ... done
[17:39:52.910] result() for ClusterFuture ...
[17:39:52.910] - result already collected: FutureResult
[17:39:52.910] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.910] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.910] Searching for globals...
[17:39:52.912] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:52.912] Searching for globals ... DONE
[17:39:52.913] Resolving globals: TRUE
[17:39:52.913] Resolving any globals that are futures ...
[17:39:52.913] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:52.913] Resolving any globals that are futures ... DONE
[17:39:52.913] Resolving futures part of globals (recursively) ...
[17:39:52.913] resolve() on list ...
[17:39:52.914]  recursive: 99
[17:39:52.914]  length: 1
[17:39:52.914]  elements: ‘x’
[17:39:52.914]  length: 0 (resolved future 1)
[17:39:52.914] resolve() on list ... DONE
[17:39:52.914] - globals: [1] ‘x’
[17:39:52.914] Resolving futures part of globals (recursively) ... DONE
[17:39:52.914] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.915] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.915] - globals: [1] ‘x’
[17:39:52.915] 
[17:39:52.915] getGlobalsAndPackages() ... DONE
[17:39:52.915] run() for ‘Future’ ...
[17:39:52.915] - state: ‘created’
[17:39:52.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.930]   - Field: ‘node’
[17:39:52.930]   - Field: ‘label’
[17:39:52.930]   - Field: ‘local’
[17:39:52.930]   - Field: ‘owner’
[17:39:52.930]   - Field: ‘envir’
[17:39:52.930]   - Field: ‘workers’
[17:39:52.930]   - Field: ‘packages’
[17:39:52.930]   - Field: ‘gc’
[17:39:52.930]   - Field: ‘conditions’
[17:39:52.930]   - Field: ‘persistent’
[17:39:52.931]   - Field: ‘expr’
[17:39:52.931]   - Field: ‘uuid’
[17:39:52.931]   - Field: ‘seed’
[17:39:52.931]   - Field: ‘version’
[17:39:52.931]   - Field: ‘result’
[17:39:52.931]   - Field: ‘asynchronous’
[17:39:52.931]   - Field: ‘calls’
[17:39:52.931]   - Field: ‘globals’
[17:39:52.931]   - Field: ‘stdout’
[17:39:52.931]   - Field: ‘earlySignal’
[17:39:52.932]   - Field: ‘lazy’
[17:39:52.932]   - Field: ‘state’
[17:39:52.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.932] - Launch lazy future ...
[17:39:52.932] Packages needed by the future expression (n = 0): <none>
[17:39:52.932] Packages needed by future strategies (n = 0): <none>
[17:39:52.933] {
[17:39:52.933]     {
[17:39:52.933]         {
[17:39:52.933]             ...future.startTime <- base::Sys.time()
[17:39:52.933]             {
[17:39:52.933]                 {
[17:39:52.933]                   {
[17:39:52.933]                     {
[17:39:52.933]                       base::local({
[17:39:52.933]                         has_future <- base::requireNamespace("future", 
[17:39:52.933]                           quietly = TRUE)
[17:39:52.933]                         if (has_future) {
[17:39:52.933]                           ns <- base::getNamespace("future")
[17:39:52.933]                           version <- ns[[".package"]][["version"]]
[17:39:52.933]                           if (is.null(version)) 
[17:39:52.933]                             version <- utils::packageVersion("future")
[17:39:52.933]                         }
[17:39:52.933]                         else {
[17:39:52.933]                           version <- NULL
[17:39:52.933]                         }
[17:39:52.933]                         if (!has_future || version < "1.8.0") {
[17:39:52.933]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.933]                             "", base::R.version$version.string), 
[17:39:52.933]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.933]                               "release", "version")], collapse = " "), 
[17:39:52.933]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.933]                             info)
[17:39:52.933]                           info <- base::paste(info, collapse = "; ")
[17:39:52.933]                           if (!has_future) {
[17:39:52.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.933]                               info)
[17:39:52.933]                           }
[17:39:52.933]                           else {
[17:39:52.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.933]                               info, version)
[17:39:52.933]                           }
[17:39:52.933]                           base::stop(msg)
[17:39:52.933]                         }
[17:39:52.933]                       })
[17:39:52.933]                     }
[17:39:52.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.933]                     base::options(mc.cores = 1L)
[17:39:52.933]                   }
[17:39:52.933]                   ...future.strategy.old <- future::plan("list")
[17:39:52.933]                   options(future.plan = NULL)
[17:39:52.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.933]                 }
[17:39:52.933]                 ...future.workdir <- getwd()
[17:39:52.933]             }
[17:39:52.933]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.933]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.933]         }
[17:39:52.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.933]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.933]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.933]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.933]             base::names(...future.oldOptions))
[17:39:52.933]     }
[17:39:52.933]     if (FALSE) {
[17:39:52.933]     }
[17:39:52.933]     else {
[17:39:52.933]         if (TRUE) {
[17:39:52.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.933]                 open = "w")
[17:39:52.933]         }
[17:39:52.933]         else {
[17:39:52.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.933]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.933]         }
[17:39:52.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.933]             base::sink(type = "output", split = FALSE)
[17:39:52.933]             base::close(...future.stdout)
[17:39:52.933]         }, add = TRUE)
[17:39:52.933]     }
[17:39:52.933]     ...future.frame <- base::sys.nframe()
[17:39:52.933]     ...future.conditions <- base::list()
[17:39:52.933]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.933]     if (FALSE) {
[17:39:52.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.933]     }
[17:39:52.933]     ...future.result <- base::tryCatch({
[17:39:52.933]         base::withCallingHandlers({
[17:39:52.933]             ...future.value <- base::withVisible(base::local({
[17:39:52.933]                 ...future.makeSendCondition <- base::local({
[17:39:52.933]                   sendCondition <- NULL
[17:39:52.933]                   function(frame = 1L) {
[17:39:52.933]                     if (is.function(sendCondition)) 
[17:39:52.933]                       return(sendCondition)
[17:39:52.933]                     ns <- getNamespace("parallel")
[17:39:52.933]                     if (exists("sendData", mode = "function", 
[17:39:52.933]                       envir = ns)) {
[17:39:52.933]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.933]                         envir = ns)
[17:39:52.933]                       envir <- sys.frame(frame)
[17:39:52.933]                       master <- NULL
[17:39:52.933]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.933]                         !identical(envir, emptyenv())) {
[17:39:52.933]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.933]                           inherits = FALSE)) {
[17:39:52.933]                           master <- get("master", mode = "list", 
[17:39:52.933]                             envir = envir, inherits = FALSE)
[17:39:52.933]                           if (inherits(master, c("SOCKnode", 
[17:39:52.933]                             "SOCK0node"))) {
[17:39:52.933]                             sendCondition <<- function(cond) {
[17:39:52.933]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.933]                                 success = TRUE)
[17:39:52.933]                               parallel_sendData(master, data)
[17:39:52.933]                             }
[17:39:52.933]                             return(sendCondition)
[17:39:52.933]                           }
[17:39:52.933]                         }
[17:39:52.933]                         frame <- frame + 1L
[17:39:52.933]                         envir <- sys.frame(frame)
[17:39:52.933]                       }
[17:39:52.933]                     }
[17:39:52.933]                     sendCondition <<- function(cond) NULL
[17:39:52.933]                   }
[17:39:52.933]                 })
[17:39:52.933]                 withCallingHandlers({
[17:39:52.933]                   {
[17:39:52.933]                     x["a"] <- list(1)
[17:39:52.933]                     x
[17:39:52.933]                   }
[17:39:52.933]                 }, immediateCondition = function(cond) {
[17:39:52.933]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.933]                   sendCondition(cond)
[17:39:52.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.933]                   {
[17:39:52.933]                     inherits <- base::inherits
[17:39:52.933]                     invokeRestart <- base::invokeRestart
[17:39:52.933]                     is.null <- base::is.null
[17:39:52.933]                     muffled <- FALSE
[17:39:52.933]                     if (inherits(cond, "message")) {
[17:39:52.933]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.933]                       if (muffled) 
[17:39:52.933]                         invokeRestart("muffleMessage")
[17:39:52.933]                     }
[17:39:52.933]                     else if (inherits(cond, "warning")) {
[17:39:52.933]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.933]                       if (muffled) 
[17:39:52.933]                         invokeRestart("muffleWarning")
[17:39:52.933]                     }
[17:39:52.933]                     else if (inherits(cond, "condition")) {
[17:39:52.933]                       if (!is.null(pattern)) {
[17:39:52.933]                         computeRestarts <- base::computeRestarts
[17:39:52.933]                         grepl <- base::grepl
[17:39:52.933]                         restarts <- computeRestarts(cond)
[17:39:52.933]                         for (restart in restarts) {
[17:39:52.933]                           name <- restart$name
[17:39:52.933]                           if (is.null(name)) 
[17:39:52.933]                             next
[17:39:52.933]                           if (!grepl(pattern, name)) 
[17:39:52.933]                             next
[17:39:52.933]                           invokeRestart(restart)
[17:39:52.933]                           muffled <- TRUE
[17:39:52.933]                           break
[17:39:52.933]                         }
[17:39:52.933]                       }
[17:39:52.933]                     }
[17:39:52.933]                     invisible(muffled)
[17:39:52.933]                   }
[17:39:52.933]                   muffleCondition(cond)
[17:39:52.933]                 })
[17:39:52.933]             }))
[17:39:52.933]             future::FutureResult(value = ...future.value$value, 
[17:39:52.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.933]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.933]                     ...future.globalenv.names))
[17:39:52.933]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.933]         }, condition = base::local({
[17:39:52.933]             c <- base::c
[17:39:52.933]             inherits <- base::inherits
[17:39:52.933]             invokeRestart <- base::invokeRestart
[17:39:52.933]             length <- base::length
[17:39:52.933]             list <- base::list
[17:39:52.933]             seq.int <- base::seq.int
[17:39:52.933]             signalCondition <- base::signalCondition
[17:39:52.933]             sys.calls <- base::sys.calls
[17:39:52.933]             `[[` <- base::`[[`
[17:39:52.933]             `+` <- base::`+`
[17:39:52.933]             `<<-` <- base::`<<-`
[17:39:52.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.933]                   3L)]
[17:39:52.933]             }
[17:39:52.933]             function(cond) {
[17:39:52.933]                 is_error <- inherits(cond, "error")
[17:39:52.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.933]                   NULL)
[17:39:52.933]                 if (is_error) {
[17:39:52.933]                   sessionInformation <- function() {
[17:39:52.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.933]                       search = base::search(), system = base::Sys.info())
[17:39:52.933]                   }
[17:39:52.933]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.933]                     cond$call), session = sessionInformation(), 
[17:39:52.933]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.933]                   signalCondition(cond)
[17:39:52.933]                 }
[17:39:52.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.933]                 "immediateCondition"))) {
[17:39:52.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.933]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.933]                   if (TRUE && !signal) {
[17:39:52.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.933]                     {
[17:39:52.933]                       inherits <- base::inherits
[17:39:52.933]                       invokeRestart <- base::invokeRestart
[17:39:52.933]                       is.null <- base::is.null
[17:39:52.933]                       muffled <- FALSE
[17:39:52.933]                       if (inherits(cond, "message")) {
[17:39:52.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.933]                         if (muffled) 
[17:39:52.933]                           invokeRestart("muffleMessage")
[17:39:52.933]                       }
[17:39:52.933]                       else if (inherits(cond, "warning")) {
[17:39:52.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.933]                         if (muffled) 
[17:39:52.933]                           invokeRestart("muffleWarning")
[17:39:52.933]                       }
[17:39:52.933]                       else if (inherits(cond, "condition")) {
[17:39:52.933]                         if (!is.null(pattern)) {
[17:39:52.933]                           computeRestarts <- base::computeRestarts
[17:39:52.933]                           grepl <- base::grepl
[17:39:52.933]                           restarts <- computeRestarts(cond)
[17:39:52.933]                           for (restart in restarts) {
[17:39:52.933]                             name <- restart$name
[17:39:52.933]                             if (is.null(name)) 
[17:39:52.933]                               next
[17:39:52.933]                             if (!grepl(pattern, name)) 
[17:39:52.933]                               next
[17:39:52.933]                             invokeRestart(restart)
[17:39:52.933]                             muffled <- TRUE
[17:39:52.933]                             break
[17:39:52.933]                           }
[17:39:52.933]                         }
[17:39:52.933]                       }
[17:39:52.933]                       invisible(muffled)
[17:39:52.933]                     }
[17:39:52.933]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.933]                   }
[17:39:52.933]                 }
[17:39:52.933]                 else {
[17:39:52.933]                   if (TRUE) {
[17:39:52.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.933]                     {
[17:39:52.933]                       inherits <- base::inherits
[17:39:52.933]                       invokeRestart <- base::invokeRestart
[17:39:52.933]                       is.null <- base::is.null
[17:39:52.933]                       muffled <- FALSE
[17:39:52.933]                       if (inherits(cond, "message")) {
[17:39:52.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.933]                         if (muffled) 
[17:39:52.933]                           invokeRestart("muffleMessage")
[17:39:52.933]                       }
[17:39:52.933]                       else if (inherits(cond, "warning")) {
[17:39:52.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.933]                         if (muffled) 
[17:39:52.933]                           invokeRestart("muffleWarning")
[17:39:52.933]                       }
[17:39:52.933]                       else if (inherits(cond, "condition")) {
[17:39:52.933]                         if (!is.null(pattern)) {
[17:39:52.933]                           computeRestarts <- base::computeRestarts
[17:39:52.933]                           grepl <- base::grepl
[17:39:52.933]                           restarts <- computeRestarts(cond)
[17:39:52.933]                           for (restart in restarts) {
[17:39:52.933]                             name <- restart$name
[17:39:52.933]                             if (is.null(name)) 
[17:39:52.933]                               next
[17:39:52.933]                             if (!grepl(pattern, name)) 
[17:39:52.933]                               next
[17:39:52.933]                             invokeRestart(restart)
[17:39:52.933]                             muffled <- TRUE
[17:39:52.933]                             break
[17:39:52.933]                           }
[17:39:52.933]                         }
[17:39:52.933]                       }
[17:39:52.933]                       invisible(muffled)
[17:39:52.933]                     }
[17:39:52.933]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.933]                   }
[17:39:52.933]                 }
[17:39:52.933]             }
[17:39:52.933]         }))
[17:39:52.933]     }, error = function(ex) {
[17:39:52.933]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.933]                 ...future.rng), started = ...future.startTime, 
[17:39:52.933]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.933]             version = "1.8"), class = "FutureResult")
[17:39:52.933]     }, finally = {
[17:39:52.933]         if (!identical(...future.workdir, getwd())) 
[17:39:52.933]             setwd(...future.workdir)
[17:39:52.933]         {
[17:39:52.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.933]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.933]             }
[17:39:52.933]             base::options(...future.oldOptions)
[17:39:52.933]             if (.Platform$OS.type == "windows") {
[17:39:52.933]                 old_names <- names(...future.oldEnvVars)
[17:39:52.933]                 envs <- base::Sys.getenv()
[17:39:52.933]                 names <- names(envs)
[17:39:52.933]                 common <- intersect(names, old_names)
[17:39:52.933]                 added <- setdiff(names, old_names)
[17:39:52.933]                 removed <- setdiff(old_names, names)
[17:39:52.933]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.933]                   envs[common]]
[17:39:52.933]                 NAMES <- toupper(changed)
[17:39:52.933]                 args <- list()
[17:39:52.933]                 for (kk in seq_along(NAMES)) {
[17:39:52.933]                   name <- changed[[kk]]
[17:39:52.933]                   NAME <- NAMES[[kk]]
[17:39:52.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.933]                     next
[17:39:52.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.933]                 }
[17:39:52.933]                 NAMES <- toupper(added)
[17:39:52.933]                 for (kk in seq_along(NAMES)) {
[17:39:52.933]                   name <- added[[kk]]
[17:39:52.933]                   NAME <- NAMES[[kk]]
[17:39:52.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.933]                     next
[17:39:52.933]                   args[[name]] <- ""
[17:39:52.933]                 }
[17:39:52.933]                 NAMES <- toupper(removed)
[17:39:52.933]                 for (kk in seq_along(NAMES)) {
[17:39:52.933]                   name <- removed[[kk]]
[17:39:52.933]                   NAME <- NAMES[[kk]]
[17:39:52.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.933]                     next
[17:39:52.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.933]                 }
[17:39:52.933]                 if (length(args) > 0) 
[17:39:52.933]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.933]             }
[17:39:52.933]             else {
[17:39:52.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.933]             }
[17:39:52.933]             {
[17:39:52.933]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.933]                   0L) {
[17:39:52.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.933]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.933]                   base::options(opts)
[17:39:52.933]                 }
[17:39:52.933]                 {
[17:39:52.933]                   {
[17:39:52.933]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.933]                     NULL
[17:39:52.933]                   }
[17:39:52.933]                   options(future.plan = NULL)
[17:39:52.933]                   if (is.na(NA_character_)) 
[17:39:52.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.933]                     .init = FALSE)
[17:39:52.933]                 }
[17:39:52.933]             }
[17:39:52.933]         }
[17:39:52.933]     })
[17:39:52.933]     if (TRUE) {
[17:39:52.933]         base::sink(type = "output", split = FALSE)
[17:39:52.933]         if (TRUE) {
[17:39:52.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.933]         }
[17:39:52.933]         else {
[17:39:52.933]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.933]         }
[17:39:52.933]         base::close(...future.stdout)
[17:39:52.933]         ...future.stdout <- NULL
[17:39:52.933]     }
[17:39:52.933]     ...future.result$conditions <- ...future.conditions
[17:39:52.933]     ...future.result$finished <- base::Sys.time()
[17:39:52.933]     ...future.result
[17:39:52.933] }
[17:39:52.935] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.935] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.936] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.936] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.937] MultisessionFuture started
[17:39:52.937] - Launch lazy future ... done
[17:39:52.937] run() for ‘MultisessionFuture’ ... done
[17:39:52.937] result() for ClusterFuture ...
[17:39:52.937] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.937] - Validating connection of MultisessionFuture
[17:39:52.938] - received message: FutureResult
[17:39:52.939] - Received FutureResult
[17:39:52.939] - Erased future from FutureRegistry
[17:39:52.939] result() for ClusterFuture ...
[17:39:52.939] - result already collected: FutureResult
[17:39:52.939] result() for ClusterFuture ... done
[17:39:52.939] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.939] result() for ClusterFuture ... done
[17:39:52.939] result() for ClusterFuture ...
[17:39:52.939] - result already collected: FutureResult
[17:39:52.939] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.940] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.940] Searching for globals...
[17:39:52.942] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:52.942] Searching for globals ... DONE
[17:39:52.943] Resolving globals: TRUE
[17:39:52.943] Resolving any globals that are futures ...
[17:39:52.943] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:39:52.943] Resolving any globals that are futures ... DONE
[17:39:52.943] Resolving futures part of globals (recursively) ...
[17:39:52.943] resolve() on list ...
[17:39:52.944]  recursive: 99
[17:39:52.944]  length: 1
[17:39:52.944]  elements: ‘x’
[17:39:52.944]  length: 0 (resolved future 1)
[17:39:52.944] resolve() on list ... DONE
[17:39:52.944] - globals: [1] ‘x’
[17:39:52.944] Resolving futures part of globals (recursively) ... DONE
[17:39:52.944] The total size of the 1 globals is 0 bytes (0 bytes)
[17:39:52.945] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:39:52.945] - globals: [1] ‘x’
[17:39:52.945] 
[17:39:52.945] getGlobalsAndPackages() ... DONE
[17:39:52.945] run() for ‘Future’ ...
[17:39:52.945] - state: ‘created’
[17:39:52.946] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.963] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.964]   - Field: ‘node’
[17:39:52.964]   - Field: ‘label’
[17:39:52.964]   - Field: ‘local’
[17:39:52.964]   - Field: ‘owner’
[17:39:52.964]   - Field: ‘envir’
[17:39:52.964]   - Field: ‘workers’
[17:39:52.965]   - Field: ‘packages’
[17:39:52.965]   - Field: ‘gc’
[17:39:52.965]   - Field: ‘conditions’
[17:39:52.965]   - Field: ‘persistent’
[17:39:52.965]   - Field: ‘expr’
[17:39:52.965]   - Field: ‘uuid’
[17:39:52.965]   - Field: ‘seed’
[17:39:52.965]   - Field: ‘version’
[17:39:52.965]   - Field: ‘result’
[17:39:52.966]   - Field: ‘asynchronous’
[17:39:52.966]   - Field: ‘calls’
[17:39:52.966]   - Field: ‘globals’
[17:39:52.966]   - Field: ‘stdout’
[17:39:52.966]   - Field: ‘earlySignal’
[17:39:52.966]   - Field: ‘lazy’
[17:39:52.966]   - Field: ‘state’
[17:39:52.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:52.966] - Launch lazy future ...
[17:39:52.967] Packages needed by the future expression (n = 0): <none>
[17:39:52.967] Packages needed by future strategies (n = 0): <none>
[17:39:52.967] {
[17:39:52.967]     {
[17:39:52.967]         {
[17:39:52.967]             ...future.startTime <- base::Sys.time()
[17:39:52.967]             {
[17:39:52.967]                 {
[17:39:52.967]                   {
[17:39:52.967]                     {
[17:39:52.967]                       base::local({
[17:39:52.967]                         has_future <- base::requireNamespace("future", 
[17:39:52.967]                           quietly = TRUE)
[17:39:52.967]                         if (has_future) {
[17:39:52.967]                           ns <- base::getNamespace("future")
[17:39:52.967]                           version <- ns[[".package"]][["version"]]
[17:39:52.967]                           if (is.null(version)) 
[17:39:52.967]                             version <- utils::packageVersion("future")
[17:39:52.967]                         }
[17:39:52.967]                         else {
[17:39:52.967]                           version <- NULL
[17:39:52.967]                         }
[17:39:52.967]                         if (!has_future || version < "1.8.0") {
[17:39:52.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:52.967]                             "", base::R.version$version.string), 
[17:39:52.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:52.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:52.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:52.967]                               "release", "version")], collapse = " "), 
[17:39:52.967]                             hostname = base::Sys.info()[["nodename"]])
[17:39:52.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:52.967]                             info)
[17:39:52.967]                           info <- base::paste(info, collapse = "; ")
[17:39:52.967]                           if (!has_future) {
[17:39:52.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:52.967]                               info)
[17:39:52.967]                           }
[17:39:52.967]                           else {
[17:39:52.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:52.967]                               info, version)
[17:39:52.967]                           }
[17:39:52.967]                           base::stop(msg)
[17:39:52.967]                         }
[17:39:52.967]                       })
[17:39:52.967]                     }
[17:39:52.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:52.967]                     base::options(mc.cores = 1L)
[17:39:52.967]                   }
[17:39:52.967]                   ...future.strategy.old <- future::plan("list")
[17:39:52.967]                   options(future.plan = NULL)
[17:39:52.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:52.967]                 }
[17:39:52.967]                 ...future.workdir <- getwd()
[17:39:52.967]             }
[17:39:52.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:52.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:52.967]         }
[17:39:52.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:52.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:52.967]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:52.967]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:52.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:52.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:52.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:52.967]             base::names(...future.oldOptions))
[17:39:52.967]     }
[17:39:52.967]     if (FALSE) {
[17:39:52.967]     }
[17:39:52.967]     else {
[17:39:52.967]         if (TRUE) {
[17:39:52.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:52.967]                 open = "w")
[17:39:52.967]         }
[17:39:52.967]         else {
[17:39:52.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:52.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:52.967]         }
[17:39:52.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:52.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:52.967]             base::sink(type = "output", split = FALSE)
[17:39:52.967]             base::close(...future.stdout)
[17:39:52.967]         }, add = TRUE)
[17:39:52.967]     }
[17:39:52.967]     ...future.frame <- base::sys.nframe()
[17:39:52.967]     ...future.conditions <- base::list()
[17:39:52.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:52.967]     if (FALSE) {
[17:39:52.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:52.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:52.967]     }
[17:39:52.967]     ...future.result <- base::tryCatch({
[17:39:52.967]         base::withCallingHandlers({
[17:39:52.967]             ...future.value <- base::withVisible(base::local({
[17:39:52.967]                 ...future.makeSendCondition <- base::local({
[17:39:52.967]                   sendCondition <- NULL
[17:39:52.967]                   function(frame = 1L) {
[17:39:52.967]                     if (is.function(sendCondition)) 
[17:39:52.967]                       return(sendCondition)
[17:39:52.967]                     ns <- getNamespace("parallel")
[17:39:52.967]                     if (exists("sendData", mode = "function", 
[17:39:52.967]                       envir = ns)) {
[17:39:52.967]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:52.967]                         envir = ns)
[17:39:52.967]                       envir <- sys.frame(frame)
[17:39:52.967]                       master <- NULL
[17:39:52.967]                       while (!identical(envir, .GlobalEnv) && 
[17:39:52.967]                         !identical(envir, emptyenv())) {
[17:39:52.967]                         if (exists("master", mode = "list", envir = envir, 
[17:39:52.967]                           inherits = FALSE)) {
[17:39:52.967]                           master <- get("master", mode = "list", 
[17:39:52.967]                             envir = envir, inherits = FALSE)
[17:39:52.967]                           if (inherits(master, c("SOCKnode", 
[17:39:52.967]                             "SOCK0node"))) {
[17:39:52.967]                             sendCondition <<- function(cond) {
[17:39:52.967]                               data <- list(type = "VALUE", value = cond, 
[17:39:52.967]                                 success = TRUE)
[17:39:52.967]                               parallel_sendData(master, data)
[17:39:52.967]                             }
[17:39:52.967]                             return(sendCondition)
[17:39:52.967]                           }
[17:39:52.967]                         }
[17:39:52.967]                         frame <- frame + 1L
[17:39:52.967]                         envir <- sys.frame(frame)
[17:39:52.967]                       }
[17:39:52.967]                     }
[17:39:52.967]                     sendCondition <<- function(cond) NULL
[17:39:52.967]                   }
[17:39:52.967]                 })
[17:39:52.967]                 withCallingHandlers({
[17:39:52.967]                   {
[17:39:52.967]                     x["a"] <- list(1)
[17:39:52.967]                     x
[17:39:52.967]                   }
[17:39:52.967]                 }, immediateCondition = function(cond) {
[17:39:52.967]                   sendCondition <- ...future.makeSendCondition()
[17:39:52.967]                   sendCondition(cond)
[17:39:52.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.967]                   {
[17:39:52.967]                     inherits <- base::inherits
[17:39:52.967]                     invokeRestart <- base::invokeRestart
[17:39:52.967]                     is.null <- base::is.null
[17:39:52.967]                     muffled <- FALSE
[17:39:52.967]                     if (inherits(cond, "message")) {
[17:39:52.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:52.967]                       if (muffled) 
[17:39:52.967]                         invokeRestart("muffleMessage")
[17:39:52.967]                     }
[17:39:52.967]                     else if (inherits(cond, "warning")) {
[17:39:52.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:52.967]                       if (muffled) 
[17:39:52.967]                         invokeRestart("muffleWarning")
[17:39:52.967]                     }
[17:39:52.967]                     else if (inherits(cond, "condition")) {
[17:39:52.967]                       if (!is.null(pattern)) {
[17:39:52.967]                         computeRestarts <- base::computeRestarts
[17:39:52.967]                         grepl <- base::grepl
[17:39:52.967]                         restarts <- computeRestarts(cond)
[17:39:52.967]                         for (restart in restarts) {
[17:39:52.967]                           name <- restart$name
[17:39:52.967]                           if (is.null(name)) 
[17:39:52.967]                             next
[17:39:52.967]                           if (!grepl(pattern, name)) 
[17:39:52.967]                             next
[17:39:52.967]                           invokeRestart(restart)
[17:39:52.967]                           muffled <- TRUE
[17:39:52.967]                           break
[17:39:52.967]                         }
[17:39:52.967]                       }
[17:39:52.967]                     }
[17:39:52.967]                     invisible(muffled)
[17:39:52.967]                   }
[17:39:52.967]                   muffleCondition(cond)
[17:39:52.967]                 })
[17:39:52.967]             }))
[17:39:52.967]             future::FutureResult(value = ...future.value$value, 
[17:39:52.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.967]                   ...future.rng), globalenv = if (FALSE) 
[17:39:52.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:52.967]                     ...future.globalenv.names))
[17:39:52.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:52.967]         }, condition = base::local({
[17:39:52.967]             c <- base::c
[17:39:52.967]             inherits <- base::inherits
[17:39:52.967]             invokeRestart <- base::invokeRestart
[17:39:52.967]             length <- base::length
[17:39:52.967]             list <- base::list
[17:39:52.967]             seq.int <- base::seq.int
[17:39:52.967]             signalCondition <- base::signalCondition
[17:39:52.967]             sys.calls <- base::sys.calls
[17:39:52.967]             `[[` <- base::`[[`
[17:39:52.967]             `+` <- base::`+`
[17:39:52.967]             `<<-` <- base::`<<-`
[17:39:52.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:52.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:52.967]                   3L)]
[17:39:52.967]             }
[17:39:52.967]             function(cond) {
[17:39:52.967]                 is_error <- inherits(cond, "error")
[17:39:52.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:52.967]                   NULL)
[17:39:52.967]                 if (is_error) {
[17:39:52.967]                   sessionInformation <- function() {
[17:39:52.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:52.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:52.967]                       search = base::search(), system = base::Sys.info())
[17:39:52.967]                   }
[17:39:52.967]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:52.967]                     cond$call), session = sessionInformation(), 
[17:39:52.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:52.967]                   signalCondition(cond)
[17:39:52.967]                 }
[17:39:52.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:52.967]                 "immediateCondition"))) {
[17:39:52.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:52.967]                   ...future.conditions[[length(...future.conditions) + 
[17:39:52.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:52.967]                   if (TRUE && !signal) {
[17:39:52.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.967]                     {
[17:39:52.967]                       inherits <- base::inherits
[17:39:52.967]                       invokeRestart <- base::invokeRestart
[17:39:52.967]                       is.null <- base::is.null
[17:39:52.967]                       muffled <- FALSE
[17:39:52.967]                       if (inherits(cond, "message")) {
[17:39:52.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.967]                         if (muffled) 
[17:39:52.967]                           invokeRestart("muffleMessage")
[17:39:52.967]                       }
[17:39:52.967]                       else if (inherits(cond, "warning")) {
[17:39:52.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.967]                         if (muffled) 
[17:39:52.967]                           invokeRestart("muffleWarning")
[17:39:52.967]                       }
[17:39:52.967]                       else if (inherits(cond, "condition")) {
[17:39:52.967]                         if (!is.null(pattern)) {
[17:39:52.967]                           computeRestarts <- base::computeRestarts
[17:39:52.967]                           grepl <- base::grepl
[17:39:52.967]                           restarts <- computeRestarts(cond)
[17:39:52.967]                           for (restart in restarts) {
[17:39:52.967]                             name <- restart$name
[17:39:52.967]                             if (is.null(name)) 
[17:39:52.967]                               next
[17:39:52.967]                             if (!grepl(pattern, name)) 
[17:39:52.967]                               next
[17:39:52.967]                             invokeRestart(restart)
[17:39:52.967]                             muffled <- TRUE
[17:39:52.967]                             break
[17:39:52.967]                           }
[17:39:52.967]                         }
[17:39:52.967]                       }
[17:39:52.967]                       invisible(muffled)
[17:39:52.967]                     }
[17:39:52.967]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.967]                   }
[17:39:52.967]                 }
[17:39:52.967]                 else {
[17:39:52.967]                   if (TRUE) {
[17:39:52.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:52.967]                     {
[17:39:52.967]                       inherits <- base::inherits
[17:39:52.967]                       invokeRestart <- base::invokeRestart
[17:39:52.967]                       is.null <- base::is.null
[17:39:52.967]                       muffled <- FALSE
[17:39:52.967]                       if (inherits(cond, "message")) {
[17:39:52.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:52.967]                         if (muffled) 
[17:39:52.967]                           invokeRestart("muffleMessage")
[17:39:52.967]                       }
[17:39:52.967]                       else if (inherits(cond, "warning")) {
[17:39:52.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:52.967]                         if (muffled) 
[17:39:52.967]                           invokeRestart("muffleWarning")
[17:39:52.967]                       }
[17:39:52.967]                       else if (inherits(cond, "condition")) {
[17:39:52.967]                         if (!is.null(pattern)) {
[17:39:52.967]                           computeRestarts <- base::computeRestarts
[17:39:52.967]                           grepl <- base::grepl
[17:39:52.967]                           restarts <- computeRestarts(cond)
[17:39:52.967]                           for (restart in restarts) {
[17:39:52.967]                             name <- restart$name
[17:39:52.967]                             if (is.null(name)) 
[17:39:52.967]                               next
[17:39:52.967]                             if (!grepl(pattern, name)) 
[17:39:52.967]                               next
[17:39:52.967]                             invokeRestart(restart)
[17:39:52.967]                             muffled <- TRUE
[17:39:52.967]                             break
[17:39:52.967]                           }
[17:39:52.967]                         }
[17:39:52.967]                       }
[17:39:52.967]                       invisible(muffled)
[17:39:52.967]                     }
[17:39:52.967]                     muffleCondition(cond, pattern = "^muffle")
[17:39:52.967]                   }
[17:39:52.967]                 }
[17:39:52.967]             }
[17:39:52.967]         }))
[17:39:52.967]     }, error = function(ex) {
[17:39:52.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:52.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:52.967]                 ...future.rng), started = ...future.startTime, 
[17:39:52.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:52.967]             version = "1.8"), class = "FutureResult")
[17:39:52.967]     }, finally = {
[17:39:52.967]         if (!identical(...future.workdir, getwd())) 
[17:39:52.967]             setwd(...future.workdir)
[17:39:52.967]         {
[17:39:52.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:52.967]                 ...future.oldOptions$nwarnings <- NULL
[17:39:52.967]             }
[17:39:52.967]             base::options(...future.oldOptions)
[17:39:52.967]             if (.Platform$OS.type == "windows") {
[17:39:52.967]                 old_names <- names(...future.oldEnvVars)
[17:39:52.967]                 envs <- base::Sys.getenv()
[17:39:52.967]                 names <- names(envs)
[17:39:52.967]                 common <- intersect(names, old_names)
[17:39:52.967]                 added <- setdiff(names, old_names)
[17:39:52.967]                 removed <- setdiff(old_names, names)
[17:39:52.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:52.967]                   envs[common]]
[17:39:52.967]                 NAMES <- toupper(changed)
[17:39:52.967]                 args <- list()
[17:39:52.967]                 for (kk in seq_along(NAMES)) {
[17:39:52.967]                   name <- changed[[kk]]
[17:39:52.967]                   NAME <- NAMES[[kk]]
[17:39:52.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.967]                     next
[17:39:52.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.967]                 }
[17:39:52.967]                 NAMES <- toupper(added)
[17:39:52.967]                 for (kk in seq_along(NAMES)) {
[17:39:52.967]                   name <- added[[kk]]
[17:39:52.967]                   NAME <- NAMES[[kk]]
[17:39:52.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.967]                     next
[17:39:52.967]                   args[[name]] <- ""
[17:39:52.967]                 }
[17:39:52.967]                 NAMES <- toupper(removed)
[17:39:52.967]                 for (kk in seq_along(NAMES)) {
[17:39:52.967]                   name <- removed[[kk]]
[17:39:52.967]                   NAME <- NAMES[[kk]]
[17:39:52.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:52.967]                     next
[17:39:52.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:52.967]                 }
[17:39:52.967]                 if (length(args) > 0) 
[17:39:52.967]                   base::do.call(base::Sys.setenv, args = args)
[17:39:52.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:52.967]             }
[17:39:52.967]             else {
[17:39:52.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:52.967]             }
[17:39:52.967]             {
[17:39:52.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:52.967]                   0L) {
[17:39:52.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:52.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:52.967]                   base::options(opts)
[17:39:52.967]                 }
[17:39:52.967]                 {
[17:39:52.967]                   {
[17:39:52.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:52.967]                     NULL
[17:39:52.967]                   }
[17:39:52.967]                   options(future.plan = NULL)
[17:39:52.967]                   if (is.na(NA_character_)) 
[17:39:52.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:52.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:52.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:52.967]                     .init = FALSE)
[17:39:52.967]                 }
[17:39:52.967]             }
[17:39:52.967]         }
[17:39:52.967]     })
[17:39:52.967]     if (TRUE) {
[17:39:52.967]         base::sink(type = "output", split = FALSE)
[17:39:52.967]         if (TRUE) {
[17:39:52.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:52.967]         }
[17:39:52.967]         else {
[17:39:52.967]             ...future.result["stdout"] <- base::list(NULL)
[17:39:52.967]         }
[17:39:52.967]         base::close(...future.stdout)
[17:39:52.967]         ...future.stdout <- NULL
[17:39:52.967]     }
[17:39:52.967]     ...future.result$conditions <- ...future.conditions
[17:39:52.967]     ...future.result$finished <- base::Sys.time()
[17:39:52.967]     ...future.result
[17:39:52.967] }
[17:39:52.969] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:39:52.970] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:52.970] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:52.970] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:39:52.971] MultisessionFuture started
[17:39:52.971] - Launch lazy future ... done
[17:39:52.971] run() for ‘MultisessionFuture’ ... done
[17:39:52.971] result() for ClusterFuture ...
[17:39:52.972] receiveMessageFromWorker() for ClusterFuture ...
[17:39:52.972] - Validating connection of MultisessionFuture
[17:39:52.972] - received message: FutureResult
[17:39:52.972] - Received FutureResult
[17:39:52.973] - Erased future from FutureRegistry
[17:39:52.973] result() for ClusterFuture ...
[17:39:52.973] - result already collected: FutureResult
[17:39:52.973] result() for ClusterFuture ... done
[17:39:52.973] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:52.973] result() for ClusterFuture ... done
[17:39:52.973] result() for ClusterFuture ...
[17:39:52.974] - result already collected: FutureResult
[17:39:52.974] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:52.974] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:52.975] Searching for globals...
[17:39:52.978] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:39:52.978] Searching for globals ... DONE
[17:39:52.978] Resolving globals: TRUE
[17:39:52.978] Resolving any globals that are futures ...
[17:39:52.978] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:39:52.978] Resolving any globals that are futures ... DONE
[17:39:52.979] Resolving futures part of globals (recursively) ...
[17:39:52.979] resolve() on list ...
[17:39:52.979]  recursive: 99
[17:39:52.979]  length: 2
[17:39:52.980]  elements: ‘x’, ‘name’
[17:39:52.980]  length: 1 (resolved future 1)
[17:39:52.980]  length: 0 (resolved future 2)
[17:39:52.980] resolve() on list ... DONE
[17:39:52.980] - globals: [2] ‘x’, ‘name’
[17:39:52.980] Resolving futures part of globals (recursively) ... DONE
[17:39:52.981] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:52.981] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:39:52.981] - globals: [2] ‘x’, ‘name’
[17:39:52.981] 
[17:39:52.982] getGlobalsAndPackages() ... DONE
[17:39:52.982] run() for ‘Future’ ...
[17:39:52.982] - state: ‘created’
[17:39:52.982] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:52.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:52.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:52.999]   - Field: ‘node’
[17:39:52.999]   - Field: ‘label’
[17:39:52.999]   - Field: ‘local’
[17:39:52.999]   - Field: ‘owner’
[17:39:52.999]   - Field: ‘envir’
[17:39:52.999]   - Field: ‘workers’
[17:39:52.999]   - Field: ‘packages’
[17:39:53.000]   - Field: ‘gc’
[17:39:53.000]   - Field: ‘conditions’
[17:39:53.000]   - Field: ‘persistent’
[17:39:53.000]   - Field: ‘expr’
[17:39:53.000]   - Field: ‘uuid’
[17:39:53.000]   - Field: ‘seed’
[17:39:53.000]   - Field: ‘version’
[17:39:53.000]   - Field: ‘result’
[17:39:53.000]   - Field: ‘asynchronous’
[17:39:53.000]   - Field: ‘calls’
[17:39:53.001]   - Field: ‘globals’
[17:39:53.001]   - Field: ‘stdout’
[17:39:53.001]   - Field: ‘earlySignal’
[17:39:53.001]   - Field: ‘lazy’
[17:39:53.001]   - Field: ‘state’
[17:39:53.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:53.001] - Launch lazy future ...
[17:39:53.001] Packages needed by the future expression (n = 0): <none>
[17:39:53.001] Packages needed by future strategies (n = 0): <none>
[17:39:53.002] {
[17:39:53.002]     {
[17:39:53.002]         {
[17:39:53.002]             ...future.startTime <- base::Sys.time()
[17:39:53.002]             {
[17:39:53.002]                 {
[17:39:53.002]                   {
[17:39:53.002]                     {
[17:39:53.002]                       base::local({
[17:39:53.002]                         has_future <- base::requireNamespace("future", 
[17:39:53.002]                           quietly = TRUE)
[17:39:53.002]                         if (has_future) {
[17:39:53.002]                           ns <- base::getNamespace("future")
[17:39:53.002]                           version <- ns[[".package"]][["version"]]
[17:39:53.002]                           if (is.null(version)) 
[17:39:53.002]                             version <- utils::packageVersion("future")
[17:39:53.002]                         }
[17:39:53.002]                         else {
[17:39:53.002]                           version <- NULL
[17:39:53.002]                         }
[17:39:53.002]                         if (!has_future || version < "1.8.0") {
[17:39:53.002]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:53.002]                             "", base::R.version$version.string), 
[17:39:53.002]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:53.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:53.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:53.002]                               "release", "version")], collapse = " "), 
[17:39:53.002]                             hostname = base::Sys.info()[["nodename"]])
[17:39:53.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:53.002]                             info)
[17:39:53.002]                           info <- base::paste(info, collapse = "; ")
[17:39:53.002]                           if (!has_future) {
[17:39:53.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:53.002]                               info)
[17:39:53.002]                           }
[17:39:53.002]                           else {
[17:39:53.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:53.002]                               info, version)
[17:39:53.002]                           }
[17:39:53.002]                           base::stop(msg)
[17:39:53.002]                         }
[17:39:53.002]                       })
[17:39:53.002]                     }
[17:39:53.002]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:53.002]                     base::options(mc.cores = 1L)
[17:39:53.002]                   }
[17:39:53.002]                   ...future.strategy.old <- future::plan("list")
[17:39:53.002]                   options(future.plan = NULL)
[17:39:53.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:53.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:53.002]                 }
[17:39:53.002]                 ...future.workdir <- getwd()
[17:39:53.002]             }
[17:39:53.002]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:53.002]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:53.002]         }
[17:39:53.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:53.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:53.002]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:53.002]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:53.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:53.002]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:53.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:53.002]             base::names(...future.oldOptions))
[17:39:53.002]     }
[17:39:53.002]     if (FALSE) {
[17:39:53.002]     }
[17:39:53.002]     else {
[17:39:53.002]         if (TRUE) {
[17:39:53.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:53.002]                 open = "w")
[17:39:53.002]         }
[17:39:53.002]         else {
[17:39:53.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:53.002]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:53.002]         }
[17:39:53.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:53.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:53.002]             base::sink(type = "output", split = FALSE)
[17:39:53.002]             base::close(...future.stdout)
[17:39:53.002]         }, add = TRUE)
[17:39:53.002]     }
[17:39:53.002]     ...future.frame <- base::sys.nframe()
[17:39:53.002]     ...future.conditions <- base::list()
[17:39:53.002]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:53.002]     if (FALSE) {
[17:39:53.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:53.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:53.002]     }
[17:39:53.002]     ...future.result <- base::tryCatch({
[17:39:53.002]         base::withCallingHandlers({
[17:39:53.002]             ...future.value <- base::withVisible(base::local({
[17:39:53.002]                 ...future.makeSendCondition <- base::local({
[17:39:53.002]                   sendCondition <- NULL
[17:39:53.002]                   function(frame = 1L) {
[17:39:53.002]                     if (is.function(sendCondition)) 
[17:39:53.002]                       return(sendCondition)
[17:39:53.002]                     ns <- getNamespace("parallel")
[17:39:53.002]                     if (exists("sendData", mode = "function", 
[17:39:53.002]                       envir = ns)) {
[17:39:53.002]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:53.002]                         envir = ns)
[17:39:53.002]                       envir <- sys.frame(frame)
[17:39:53.002]                       master <- NULL
[17:39:53.002]                       while (!identical(envir, .GlobalEnv) && 
[17:39:53.002]                         !identical(envir, emptyenv())) {
[17:39:53.002]                         if (exists("master", mode = "list", envir = envir, 
[17:39:53.002]                           inherits = FALSE)) {
[17:39:53.002]                           master <- get("master", mode = "list", 
[17:39:53.002]                             envir = envir, inherits = FALSE)
[17:39:53.002]                           if (inherits(master, c("SOCKnode", 
[17:39:53.002]                             "SOCK0node"))) {
[17:39:53.002]                             sendCondition <<- function(cond) {
[17:39:53.002]                               data <- list(type = "VALUE", value = cond, 
[17:39:53.002]                                 success = TRUE)
[17:39:53.002]                               parallel_sendData(master, data)
[17:39:53.002]                             }
[17:39:53.002]                             return(sendCondition)
[17:39:53.002]                           }
[17:39:53.002]                         }
[17:39:53.002]                         frame <- frame + 1L
[17:39:53.002]                         envir <- sys.frame(frame)
[17:39:53.002]                       }
[17:39:53.002]                     }
[17:39:53.002]                     sendCondition <<- function(cond) NULL
[17:39:53.002]                   }
[17:39:53.002]                 })
[17:39:53.002]                 withCallingHandlers({
[17:39:53.002]                   {
[17:39:53.002]                     x[name] <- list(1)
[17:39:53.002]                     x
[17:39:53.002]                   }
[17:39:53.002]                 }, immediateCondition = function(cond) {
[17:39:53.002]                   sendCondition <- ...future.makeSendCondition()
[17:39:53.002]                   sendCondition(cond)
[17:39:53.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:53.002]                   {
[17:39:53.002]                     inherits <- base::inherits
[17:39:53.002]                     invokeRestart <- base::invokeRestart
[17:39:53.002]                     is.null <- base::is.null
[17:39:53.002]                     muffled <- FALSE
[17:39:53.002]                     if (inherits(cond, "message")) {
[17:39:53.002]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:53.002]                       if (muffled) 
[17:39:53.002]                         invokeRestart("muffleMessage")
[17:39:53.002]                     }
[17:39:53.002]                     else if (inherits(cond, "warning")) {
[17:39:53.002]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:53.002]                       if (muffled) 
[17:39:53.002]                         invokeRestart("muffleWarning")
[17:39:53.002]                     }
[17:39:53.002]                     else if (inherits(cond, "condition")) {
[17:39:53.002]                       if (!is.null(pattern)) {
[17:39:53.002]                         computeRestarts <- base::computeRestarts
[17:39:53.002]                         grepl <- base::grepl
[17:39:53.002]                         restarts <- computeRestarts(cond)
[17:39:53.002]                         for (restart in restarts) {
[17:39:53.002]                           name <- restart$name
[17:39:53.002]                           if (is.null(name)) 
[17:39:53.002]                             next
[17:39:53.002]                           if (!grepl(pattern, name)) 
[17:39:53.002]                             next
[17:39:53.002]                           invokeRestart(restart)
[17:39:53.002]                           muffled <- TRUE
[17:39:53.002]                           break
[17:39:53.002]                         }
[17:39:53.002]                       }
[17:39:53.002]                     }
[17:39:53.002]                     invisible(muffled)
[17:39:53.002]                   }
[17:39:53.002]                   muffleCondition(cond)
[17:39:53.002]                 })
[17:39:53.002]             }))
[17:39:53.002]             future::FutureResult(value = ...future.value$value, 
[17:39:53.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:53.002]                   ...future.rng), globalenv = if (FALSE) 
[17:39:53.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:53.002]                     ...future.globalenv.names))
[17:39:53.002]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:53.002]         }, condition = base::local({
[17:39:53.002]             c <- base::c
[17:39:53.002]             inherits <- base::inherits
[17:39:53.002]             invokeRestart <- base::invokeRestart
[17:39:53.002]             length <- base::length
[17:39:53.002]             list <- base::list
[17:39:53.002]             seq.int <- base::seq.int
[17:39:53.002]             signalCondition <- base::signalCondition
[17:39:53.002]             sys.calls <- base::sys.calls
[17:39:53.002]             `[[` <- base::`[[`
[17:39:53.002]             `+` <- base::`+`
[17:39:53.002]             `<<-` <- base::`<<-`
[17:39:53.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:53.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:53.002]                   3L)]
[17:39:53.002]             }
[17:39:53.002]             function(cond) {
[17:39:53.002]                 is_error <- inherits(cond, "error")
[17:39:53.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:53.002]                   NULL)
[17:39:53.002]                 if (is_error) {
[17:39:53.002]                   sessionInformation <- function() {
[17:39:53.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:53.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:53.002]                       search = base::search(), system = base::Sys.info())
[17:39:53.002]                   }
[17:39:53.002]                   ...future.conditions[[length(...future.conditions) + 
[17:39:53.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:53.002]                     cond$call), session = sessionInformation(), 
[17:39:53.002]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:53.002]                   signalCondition(cond)
[17:39:53.002]                 }
[17:39:53.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:53.002]                 "immediateCondition"))) {
[17:39:53.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:53.002]                   ...future.conditions[[length(...future.conditions) + 
[17:39:53.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:53.002]                   if (TRUE && !signal) {
[17:39:53.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:53.002]                     {
[17:39:53.002]                       inherits <- base::inherits
[17:39:53.002]                       invokeRestart <- base::invokeRestart
[17:39:53.002]                       is.null <- base::is.null
[17:39:53.002]                       muffled <- FALSE
[17:39:53.002]                       if (inherits(cond, "message")) {
[17:39:53.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:53.002]                         if (muffled) 
[17:39:53.002]                           invokeRestart("muffleMessage")
[17:39:53.002]                       }
[17:39:53.002]                       else if (inherits(cond, "warning")) {
[17:39:53.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:53.002]                         if (muffled) 
[17:39:53.002]                           invokeRestart("muffleWarning")
[17:39:53.002]                       }
[17:39:53.002]                       else if (inherits(cond, "condition")) {
[17:39:53.002]                         if (!is.null(pattern)) {
[17:39:53.002]                           computeRestarts <- base::computeRestarts
[17:39:53.002]                           grepl <- base::grepl
[17:39:53.002]                           restarts <- computeRestarts(cond)
[17:39:53.002]                           for (restart in restarts) {
[17:39:53.002]                             name <- restart$name
[17:39:53.002]                             if (is.null(name)) 
[17:39:53.002]                               next
[17:39:53.002]                             if (!grepl(pattern, name)) 
[17:39:53.002]                               next
[17:39:53.002]                             invokeRestart(restart)
[17:39:53.002]                             muffled <- TRUE
[17:39:53.002]                             break
[17:39:53.002]                           }
[17:39:53.002]                         }
[17:39:53.002]                       }
[17:39:53.002]                       invisible(muffled)
[17:39:53.002]                     }
[17:39:53.002]                     muffleCondition(cond, pattern = "^muffle")
[17:39:53.002]                   }
[17:39:53.002]                 }
[17:39:53.002]                 else {
[17:39:53.002]                   if (TRUE) {
[17:39:53.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:53.002]                     {
[17:39:53.002]                       inherits <- base::inherits
[17:39:53.002]                       invokeRestart <- base::invokeRestart
[17:39:53.002]                       is.null <- base::is.null
[17:39:53.002]                       muffled <- FALSE
[17:39:53.002]                       if (inherits(cond, "message")) {
[17:39:53.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:53.002]                         if (muffled) 
[17:39:53.002]                           invokeRestart("muffleMessage")
[17:39:53.002]                       }
[17:39:53.002]                       else if (inherits(cond, "warning")) {
[17:39:53.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:53.002]                         if (muffled) 
[17:39:53.002]                           invokeRestart("muffleWarning")
[17:39:53.002]                       }
[17:39:53.002]                       else if (inherits(cond, "condition")) {
[17:39:53.002]                         if (!is.null(pattern)) {
[17:39:53.002]                           computeRestarts <- base::computeRestarts
[17:39:53.002]                           grepl <- base::grepl
[17:39:53.002]                           restarts <- computeRestarts(cond)
[17:39:53.002]                           for (restart in restarts) {
[17:39:53.002]                             name <- restart$name
[17:39:53.002]                             if (is.null(name)) 
[17:39:53.002]                               next
[17:39:53.002]                             if (!grepl(pattern, name)) 
[17:39:53.002]                               next
[17:39:53.002]                             invokeRestart(restart)
[17:39:53.002]                             muffled <- TRUE
[17:39:53.002]                             break
[17:39:53.002]                           }
[17:39:53.002]                         }
[17:39:53.002]                       }
[17:39:53.002]                       invisible(muffled)
[17:39:53.002]                     }
[17:39:53.002]                     muffleCondition(cond, pattern = "^muffle")
[17:39:53.002]                   }
[17:39:53.002]                 }
[17:39:53.002]             }
[17:39:53.002]         }))
[17:39:53.002]     }, error = function(ex) {
[17:39:53.002]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:53.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:53.002]                 ...future.rng), started = ...future.startTime, 
[17:39:53.002]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:53.002]             version = "1.8"), class = "FutureResult")
[17:39:53.002]     }, finally = {
[17:39:53.002]         if (!identical(...future.workdir, getwd())) 
[17:39:53.002]             setwd(...future.workdir)
[17:39:53.002]         {
[17:39:53.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:53.002]                 ...future.oldOptions$nwarnings <- NULL
[17:39:53.002]             }
[17:39:53.002]             base::options(...future.oldOptions)
[17:39:53.002]             if (.Platform$OS.type == "windows") {
[17:39:53.002]                 old_names <- names(...future.oldEnvVars)
[17:39:53.002]                 envs <- base::Sys.getenv()
[17:39:53.002]                 names <- names(envs)
[17:39:53.002]                 common <- intersect(names, old_names)
[17:39:53.002]                 added <- setdiff(names, old_names)
[17:39:53.002]                 removed <- setdiff(old_names, names)
[17:39:53.002]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:53.002]                   envs[common]]
[17:39:53.002]                 NAMES <- toupper(changed)
[17:39:53.002]                 args <- list()
[17:39:53.002]                 for (kk in seq_along(NAMES)) {
[17:39:53.002]                   name <- changed[[kk]]
[17:39:53.002]                   NAME <- NAMES[[kk]]
[17:39:53.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:53.002]                     next
[17:39:53.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:53.002]                 }
[17:39:53.002]                 NAMES <- toupper(added)
[17:39:53.002]                 for (kk in seq_along(NAMES)) {
[17:39:53.002]                   name <- added[[kk]]
[17:39:53.002]                   NAME <- NAMES[[kk]]
[17:39:53.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:53.002]                     next
[17:39:53.002]                   args[[name]] <- ""
[17:39:53.002]                 }
[17:39:53.002]                 NAMES <- toupper(removed)
[17:39:53.002]                 for (kk in seq_along(NAMES)) {
[17:39:53.002]                   name <- removed[[kk]]
[17:39:53.002]                   NAME <- NAMES[[kk]]
[17:39:53.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:53.002]                     next
[17:39:53.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:53.002]                 }
[17:39:53.002]                 if (length(args) > 0) 
[17:39:53.002]                   base::do.call(base::Sys.setenv, args = args)
[17:39:53.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:53.002]             }
[17:39:53.002]             else {
[17:39:53.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:53.002]             }
[17:39:53.002]             {
[17:39:53.002]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:53.002]                   0L) {
[17:39:53.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:53.002]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:53.002]                   base::options(opts)
[17:39:53.002]                 }
[17:39:53.002]                 {
[17:39:53.002]                   {
[17:39:53.002]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:53.002]                     NULL
[17:39:53.002]                   }
[17:39:53.002]                   options(future.plan = NULL)
[17:39:53.002]                   if (is.na(NA_character_)) 
[17:39:53.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:53.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:53.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:53.002]                     .init = FALSE)
[17:39:53.002]                 }
[17:39:53.002]             }
[17:39:53.002]         }
[17:39:53.002]     })
[17:39:53.002]     if (TRUE) {
[17:39:53.002]         base::sink(type = "output", split = FALSE)
[17:39:53.002]         if (TRUE) {
[17:39:53.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:53.002]         }
[17:39:53.002]         else {
[17:39:53.002]             ...future.result["stdout"] <- base::list(NULL)
[17:39:53.002]         }
[17:39:53.002]         base::close(...future.stdout)
[17:39:53.002]         ...future.stdout <- NULL
[17:39:53.002]     }
[17:39:53.002]     ...future.result$conditions <- ...future.conditions
[17:39:53.002]     ...future.result$finished <- base::Sys.time()
[17:39:53.002]     ...future.result
[17:39:53.002] }
[17:39:53.004] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:39:53.005] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:39:53.005] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:39:53.005] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[17:39:53.005] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[17:39:53.005] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:39:53.006] MultisessionFuture started
[17:39:53.006] - Launch lazy future ... done
[17:39:53.006] run() for ‘MultisessionFuture’ ... done
[17:39:53.006] result() for ClusterFuture ...
[17:39:53.006] receiveMessageFromWorker() for ClusterFuture ...
[17:39:53.007] - Validating connection of MultisessionFuture
[17:39:53.007] - received message: FutureResult
[17:39:53.008] - Received FutureResult
[17:39:53.008] - Erased future from FutureRegistry
[17:39:53.008] result() for ClusterFuture ...
[17:39:53.008] - result already collected: FutureResult
[17:39:53.008] result() for ClusterFuture ... done
[17:39:53.008] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:53.008] result() for ClusterFuture ... done
[17:39:53.008] result() for ClusterFuture ...
[17:39:53.008] - result already collected: FutureResult
[17:39:53.008] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[17:39:53.011] plan(): Setting new future strategy stack:
[17:39:53.011] List of future strategies:
[17:39:53.011] 1. FutureStrategy:
[17:39:53.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:53.011]    - tweaked: FALSE
[17:39:53.011]    - call: future::plan(oplan)
[17:39:53.012] plan(): nbrOfWorkers() = 1
> 
