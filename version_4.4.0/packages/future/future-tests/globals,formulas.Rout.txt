
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:31:18.176] plan(): Setting new future strategy stack:
[09:31:18.176] List of future strategies:
[09:31:18.176] 1. sequential:
[09:31:18.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.176]    - tweaked: FALSE
[09:31:18.176]    - call: future::plan("sequential")
[09:31:18.187] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[09:31:18.244] plan(): Setting new future strategy stack:
[09:31:18.244] List of future strategies:
[09:31:18.244] 1. sequential:
[09:31:18.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.244]    - tweaked: FALSE
[09:31:18.244]    - call: plan(strategy)
[09:31:18.255] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[09:31:18.256] getGlobalsAndPackages() ...
[09:31:18.256] Searching for globals...
[09:31:18.263] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.263] Searching for globals ... DONE
[09:31:18.263] Resolving globals: FALSE
[09:31:18.264] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.264] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.265] - globals: [2] ‘weight’, ‘group’
[09:31:18.265] - packages: [1] ‘stats’
[09:31:18.265] getGlobalsAndPackages() ... DONE
[09:31:18.265] run() for ‘Future’ ...
[09:31:18.265] - state: ‘created’
[09:31:18.266] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.266] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.266]   - Field: ‘label’
[09:31:18.266]   - Field: ‘local’
[09:31:18.266]   - Field: ‘owner’
[09:31:18.266]   - Field: ‘envir’
[09:31:18.267]   - Field: ‘packages’
[09:31:18.267]   - Field: ‘gc’
[09:31:18.267]   - Field: ‘conditions’
[09:31:18.267]   - Field: ‘expr’
[09:31:18.267]   - Field: ‘uuid’
[09:31:18.267]   - Field: ‘seed’
[09:31:18.267]   - Field: ‘version’
[09:31:18.267]   - Field: ‘result’
[09:31:18.267]   - Field: ‘asynchronous’
[09:31:18.267]   - Field: ‘calls’
[09:31:18.267]   - Field: ‘globals’
[09:31:18.268]   - Field: ‘stdout’
[09:31:18.268]   - Field: ‘earlySignal’
[09:31:18.268]   - Field: ‘lazy’
[09:31:18.268]   - Field: ‘state’
[09:31:18.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.268] - Launch lazy future ...
[09:31:18.269] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.269] Packages needed by future strategies (n = 0): <none>
[09:31:18.270] {
[09:31:18.270]     {
[09:31:18.270]         {
[09:31:18.270]             ...future.startTime <- base::Sys.time()
[09:31:18.270]             {
[09:31:18.270]                 {
[09:31:18.270]                   {
[09:31:18.270]                     {
[09:31:18.270]                       base::local({
[09:31:18.270]                         has_future <- base::requireNamespace("future", 
[09:31:18.270]                           quietly = TRUE)
[09:31:18.270]                         if (has_future) {
[09:31:18.270]                           ns <- base::getNamespace("future")
[09:31:18.270]                           version <- ns[[".package"]][["version"]]
[09:31:18.270]                           if (is.null(version)) 
[09:31:18.270]                             version <- utils::packageVersion("future")
[09:31:18.270]                         }
[09:31:18.270]                         else {
[09:31:18.270]                           version <- NULL
[09:31:18.270]                         }
[09:31:18.270]                         if (!has_future || version < "1.8.0") {
[09:31:18.270]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.270]                             "", base::R.version$version.string), 
[09:31:18.270]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.270]                               "release", "version")], collapse = " "), 
[09:31:18.270]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.270]                             info)
[09:31:18.270]                           info <- base::paste(info, collapse = "; ")
[09:31:18.270]                           if (!has_future) {
[09:31:18.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.270]                               info)
[09:31:18.270]                           }
[09:31:18.270]                           else {
[09:31:18.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.270]                               info, version)
[09:31:18.270]                           }
[09:31:18.270]                           base::stop(msg)
[09:31:18.270]                         }
[09:31:18.270]                       })
[09:31:18.270]                     }
[09:31:18.270]                     base::local({
[09:31:18.270]                       for (pkg in "stats") {
[09:31:18.270]                         base::loadNamespace(pkg)
[09:31:18.270]                         base::library(pkg, character.only = TRUE)
[09:31:18.270]                       }
[09:31:18.270]                     })
[09:31:18.270]                   }
[09:31:18.270]                   ...future.strategy.old <- future::plan("list")
[09:31:18.270]                   options(future.plan = NULL)
[09:31:18.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.270]                 }
[09:31:18.270]                 ...future.workdir <- getwd()
[09:31:18.270]             }
[09:31:18.270]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.270]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.270]         }
[09:31:18.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.270]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.270]             base::names(...future.oldOptions))
[09:31:18.270]     }
[09:31:18.270]     if (FALSE) {
[09:31:18.270]     }
[09:31:18.270]     else {
[09:31:18.270]         if (TRUE) {
[09:31:18.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.270]                 open = "w")
[09:31:18.270]         }
[09:31:18.270]         else {
[09:31:18.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.270]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.270]         }
[09:31:18.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.270]             base::sink(type = "output", split = FALSE)
[09:31:18.270]             base::close(...future.stdout)
[09:31:18.270]         }, add = TRUE)
[09:31:18.270]     }
[09:31:18.270]     ...future.frame <- base::sys.nframe()
[09:31:18.270]     ...future.conditions <- base::list()
[09:31:18.270]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.270]     if (FALSE) {
[09:31:18.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.270]     }
[09:31:18.270]     ...future.result <- base::tryCatch({
[09:31:18.270]         base::withCallingHandlers({
[09:31:18.270]             ...future.value <- base::withVisible(base::local({
[09:31:18.270]                 lm(weight ~ group - 1)
[09:31:18.270]             }))
[09:31:18.270]             future::FutureResult(value = ...future.value$value, 
[09:31:18.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.270]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.270]                     ...future.globalenv.names))
[09:31:18.270]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.270]         }, condition = base::local({
[09:31:18.270]             c <- base::c
[09:31:18.270]             inherits <- base::inherits
[09:31:18.270]             invokeRestart <- base::invokeRestart
[09:31:18.270]             length <- base::length
[09:31:18.270]             list <- base::list
[09:31:18.270]             seq.int <- base::seq.int
[09:31:18.270]             signalCondition <- base::signalCondition
[09:31:18.270]             sys.calls <- base::sys.calls
[09:31:18.270]             `[[` <- base::`[[`
[09:31:18.270]             `+` <- base::`+`
[09:31:18.270]             `<<-` <- base::`<<-`
[09:31:18.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.270]                   3L)]
[09:31:18.270]             }
[09:31:18.270]             function(cond) {
[09:31:18.270]                 is_error <- inherits(cond, "error")
[09:31:18.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.270]                   NULL)
[09:31:18.270]                 if (is_error) {
[09:31:18.270]                   sessionInformation <- function() {
[09:31:18.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.270]                       search = base::search(), system = base::Sys.info())
[09:31:18.270]                   }
[09:31:18.270]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.270]                     cond$call), session = sessionInformation(), 
[09:31:18.270]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.270]                   signalCondition(cond)
[09:31:18.270]                 }
[09:31:18.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.270]                 "immediateCondition"))) {
[09:31:18.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.270]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.270]                   if (TRUE && !signal) {
[09:31:18.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.270]                     {
[09:31:18.270]                       inherits <- base::inherits
[09:31:18.270]                       invokeRestart <- base::invokeRestart
[09:31:18.270]                       is.null <- base::is.null
[09:31:18.270]                       muffled <- FALSE
[09:31:18.270]                       if (inherits(cond, "message")) {
[09:31:18.270]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.270]                         if (muffled) 
[09:31:18.270]                           invokeRestart("muffleMessage")
[09:31:18.270]                       }
[09:31:18.270]                       else if (inherits(cond, "warning")) {
[09:31:18.270]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.270]                         if (muffled) 
[09:31:18.270]                           invokeRestart("muffleWarning")
[09:31:18.270]                       }
[09:31:18.270]                       else if (inherits(cond, "condition")) {
[09:31:18.270]                         if (!is.null(pattern)) {
[09:31:18.270]                           computeRestarts <- base::computeRestarts
[09:31:18.270]                           grepl <- base::grepl
[09:31:18.270]                           restarts <- computeRestarts(cond)
[09:31:18.270]                           for (restart in restarts) {
[09:31:18.270]                             name <- restart$name
[09:31:18.270]                             if (is.null(name)) 
[09:31:18.270]                               next
[09:31:18.270]                             if (!grepl(pattern, name)) 
[09:31:18.270]                               next
[09:31:18.270]                             invokeRestart(restart)
[09:31:18.270]                             muffled <- TRUE
[09:31:18.270]                             break
[09:31:18.270]                           }
[09:31:18.270]                         }
[09:31:18.270]                       }
[09:31:18.270]                       invisible(muffled)
[09:31:18.270]                     }
[09:31:18.270]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.270]                   }
[09:31:18.270]                 }
[09:31:18.270]                 else {
[09:31:18.270]                   if (TRUE) {
[09:31:18.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.270]                     {
[09:31:18.270]                       inherits <- base::inherits
[09:31:18.270]                       invokeRestart <- base::invokeRestart
[09:31:18.270]                       is.null <- base::is.null
[09:31:18.270]                       muffled <- FALSE
[09:31:18.270]                       if (inherits(cond, "message")) {
[09:31:18.270]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.270]                         if (muffled) 
[09:31:18.270]                           invokeRestart("muffleMessage")
[09:31:18.270]                       }
[09:31:18.270]                       else if (inherits(cond, "warning")) {
[09:31:18.270]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.270]                         if (muffled) 
[09:31:18.270]                           invokeRestart("muffleWarning")
[09:31:18.270]                       }
[09:31:18.270]                       else if (inherits(cond, "condition")) {
[09:31:18.270]                         if (!is.null(pattern)) {
[09:31:18.270]                           computeRestarts <- base::computeRestarts
[09:31:18.270]                           grepl <- base::grepl
[09:31:18.270]                           restarts <- computeRestarts(cond)
[09:31:18.270]                           for (restart in restarts) {
[09:31:18.270]                             name <- restart$name
[09:31:18.270]                             if (is.null(name)) 
[09:31:18.270]                               next
[09:31:18.270]                             if (!grepl(pattern, name)) 
[09:31:18.270]                               next
[09:31:18.270]                             invokeRestart(restart)
[09:31:18.270]                             muffled <- TRUE
[09:31:18.270]                             break
[09:31:18.270]                           }
[09:31:18.270]                         }
[09:31:18.270]                       }
[09:31:18.270]                       invisible(muffled)
[09:31:18.270]                     }
[09:31:18.270]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.270]                   }
[09:31:18.270]                 }
[09:31:18.270]             }
[09:31:18.270]         }))
[09:31:18.270]     }, error = function(ex) {
[09:31:18.270]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.270]                 ...future.rng), started = ...future.startTime, 
[09:31:18.270]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.270]             version = "1.8"), class = "FutureResult")
[09:31:18.270]     }, finally = {
[09:31:18.270]         if (!identical(...future.workdir, getwd())) 
[09:31:18.270]             setwd(...future.workdir)
[09:31:18.270]         {
[09:31:18.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.270]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.270]             }
[09:31:18.270]             base::options(...future.oldOptions)
[09:31:18.270]             if (.Platform$OS.type == "windows") {
[09:31:18.270]                 old_names <- names(...future.oldEnvVars)
[09:31:18.270]                 envs <- base::Sys.getenv()
[09:31:18.270]                 names <- names(envs)
[09:31:18.270]                 common <- intersect(names, old_names)
[09:31:18.270]                 added <- setdiff(names, old_names)
[09:31:18.270]                 removed <- setdiff(old_names, names)
[09:31:18.270]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.270]                   envs[common]]
[09:31:18.270]                 NAMES <- toupper(changed)
[09:31:18.270]                 args <- list()
[09:31:18.270]                 for (kk in seq_along(NAMES)) {
[09:31:18.270]                   name <- changed[[kk]]
[09:31:18.270]                   NAME <- NAMES[[kk]]
[09:31:18.270]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.270]                     next
[09:31:18.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.270]                 }
[09:31:18.270]                 NAMES <- toupper(added)
[09:31:18.270]                 for (kk in seq_along(NAMES)) {
[09:31:18.270]                   name <- added[[kk]]
[09:31:18.270]                   NAME <- NAMES[[kk]]
[09:31:18.270]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.270]                     next
[09:31:18.270]                   args[[name]] <- ""
[09:31:18.270]                 }
[09:31:18.270]                 NAMES <- toupper(removed)
[09:31:18.270]                 for (kk in seq_along(NAMES)) {
[09:31:18.270]                   name <- removed[[kk]]
[09:31:18.270]                   NAME <- NAMES[[kk]]
[09:31:18.270]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.270]                     next
[09:31:18.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.270]                 }
[09:31:18.270]                 if (length(args) > 0) 
[09:31:18.270]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.270]             }
[09:31:18.270]             else {
[09:31:18.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.270]             }
[09:31:18.270]             {
[09:31:18.270]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.270]                   0L) {
[09:31:18.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.270]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.270]                   base::options(opts)
[09:31:18.270]                 }
[09:31:18.270]                 {
[09:31:18.270]                   {
[09:31:18.270]                     NULL
[09:31:18.270]                     RNGkind("Mersenne-Twister")
[09:31:18.270]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.270]                       inherits = FALSE)
[09:31:18.270]                   }
[09:31:18.270]                   options(future.plan = NULL)
[09:31:18.270]                   if (is.na(NA_character_)) 
[09:31:18.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.270]                     .init = FALSE)
[09:31:18.270]                 }
[09:31:18.270]             }
[09:31:18.270]         }
[09:31:18.270]     })
[09:31:18.270]     if (TRUE) {
[09:31:18.270]         base::sink(type = "output", split = FALSE)
[09:31:18.270]         if (TRUE) {
[09:31:18.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.270]         }
[09:31:18.270]         else {
[09:31:18.270]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.270]         }
[09:31:18.270]         base::close(...future.stdout)
[09:31:18.270]         ...future.stdout <- NULL
[09:31:18.270]     }
[09:31:18.270]     ...future.result$conditions <- ...future.conditions
[09:31:18.270]     ...future.result$finished <- base::Sys.time()
[09:31:18.270]     ...future.result
[09:31:18.270] }
[09:31:18.271] assign_globals() ...
[09:31:18.271] List of 2
[09:31:18.271]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.271]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.271]  - attr(*, "where")=List of 2
[09:31:18.271]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.271]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.271]  - attr(*, "resolved")= logi FALSE
[09:31:18.271]  - attr(*, "total_size")= num 896
[09:31:18.271]  - attr(*, "already-done")= logi TRUE
[09:31:18.274] - copied ‘weight’ to environment
[09:31:18.275] - copied ‘group’ to environment
[09:31:18.275] assign_globals() ... done
[09:31:18.275] plan(): Setting new future strategy stack:
[09:31:18.275] List of future strategies:
[09:31:18.275] 1. sequential:
[09:31:18.275]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.275]    - tweaked: FALSE
[09:31:18.275]    - call: NULL
[09:31:18.276] plan(): nbrOfWorkers() = 1
[09:31:18.277] plan(): Setting new future strategy stack:
[09:31:18.277] List of future strategies:
[09:31:18.277] 1. sequential:
[09:31:18.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.277]    - tweaked: FALSE
[09:31:18.277]    - call: plan(strategy)
[09:31:18.278] plan(): nbrOfWorkers() = 1
[09:31:18.278] SequentialFuture started (and completed)
[09:31:18.278] - Launch lazy future ... done
[09:31:18.279] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.281] getGlobalsAndPackages() ...
[09:31:18.281] Searching for globals...
[09:31:18.282] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.283] Searching for globals ... DONE
[09:31:18.283] Resolving globals: FALSE
[09:31:18.283] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.284] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.284] - globals: [2] ‘weight’, ‘group’
[09:31:18.284] - packages: [1] ‘stats’
[09:31:18.284] getGlobalsAndPackages() ... DONE
[09:31:18.284] run() for ‘Future’ ...
[09:31:18.284] - state: ‘created’
[09:31:18.284] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.285] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.285]   - Field: ‘label’
[09:31:18.285]   - Field: ‘local’
[09:31:18.285]   - Field: ‘owner’
[09:31:18.285]   - Field: ‘envir’
[09:31:18.285]   - Field: ‘packages’
[09:31:18.285]   - Field: ‘gc’
[09:31:18.285]   - Field: ‘conditions’
[09:31:18.285]   - Field: ‘expr’
[09:31:18.286]   - Field: ‘uuid’
[09:31:18.286]   - Field: ‘seed’
[09:31:18.286]   - Field: ‘version’
[09:31:18.286]   - Field: ‘result’
[09:31:18.286]   - Field: ‘asynchronous’
[09:31:18.288]   - Field: ‘calls’
[09:31:18.288]   - Field: ‘globals’
[09:31:18.288]   - Field: ‘stdout’
[09:31:18.288]   - Field: ‘earlySignal’
[09:31:18.288]   - Field: ‘lazy’
[09:31:18.288]   - Field: ‘state’
[09:31:18.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.288] - Launch lazy future ...
[09:31:18.288] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.289] Packages needed by future strategies (n = 0): <none>
[09:31:18.289] {
[09:31:18.289]     {
[09:31:18.289]         {
[09:31:18.289]             ...future.startTime <- base::Sys.time()
[09:31:18.289]             {
[09:31:18.289]                 {
[09:31:18.289]                   {
[09:31:18.289]                     {
[09:31:18.289]                       base::local({
[09:31:18.289]                         has_future <- base::requireNamespace("future", 
[09:31:18.289]                           quietly = TRUE)
[09:31:18.289]                         if (has_future) {
[09:31:18.289]                           ns <- base::getNamespace("future")
[09:31:18.289]                           version <- ns[[".package"]][["version"]]
[09:31:18.289]                           if (is.null(version)) 
[09:31:18.289]                             version <- utils::packageVersion("future")
[09:31:18.289]                         }
[09:31:18.289]                         else {
[09:31:18.289]                           version <- NULL
[09:31:18.289]                         }
[09:31:18.289]                         if (!has_future || version < "1.8.0") {
[09:31:18.289]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.289]                             "", base::R.version$version.string), 
[09:31:18.289]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.289]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.289]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.289]                               "release", "version")], collapse = " "), 
[09:31:18.289]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.289]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.289]                             info)
[09:31:18.289]                           info <- base::paste(info, collapse = "; ")
[09:31:18.289]                           if (!has_future) {
[09:31:18.289]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.289]                               info)
[09:31:18.289]                           }
[09:31:18.289]                           else {
[09:31:18.289]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.289]                               info, version)
[09:31:18.289]                           }
[09:31:18.289]                           base::stop(msg)
[09:31:18.289]                         }
[09:31:18.289]                       })
[09:31:18.289]                     }
[09:31:18.289]                     base::local({
[09:31:18.289]                       for (pkg in "stats") {
[09:31:18.289]                         base::loadNamespace(pkg)
[09:31:18.289]                         base::library(pkg, character.only = TRUE)
[09:31:18.289]                       }
[09:31:18.289]                     })
[09:31:18.289]                   }
[09:31:18.289]                   ...future.strategy.old <- future::plan("list")
[09:31:18.289]                   options(future.plan = NULL)
[09:31:18.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.289]                 }
[09:31:18.289]                 ...future.workdir <- getwd()
[09:31:18.289]             }
[09:31:18.289]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.289]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.289]         }
[09:31:18.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.289]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.289]             base::names(...future.oldOptions))
[09:31:18.289]     }
[09:31:18.289]     if (FALSE) {
[09:31:18.289]     }
[09:31:18.289]     else {
[09:31:18.289]         if (TRUE) {
[09:31:18.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.289]                 open = "w")
[09:31:18.289]         }
[09:31:18.289]         else {
[09:31:18.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.289]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.289]         }
[09:31:18.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.289]             base::sink(type = "output", split = FALSE)
[09:31:18.289]             base::close(...future.stdout)
[09:31:18.289]         }, add = TRUE)
[09:31:18.289]     }
[09:31:18.289]     ...future.frame <- base::sys.nframe()
[09:31:18.289]     ...future.conditions <- base::list()
[09:31:18.289]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.289]     if (FALSE) {
[09:31:18.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.289]     }
[09:31:18.289]     ...future.result <- base::tryCatch({
[09:31:18.289]         base::withCallingHandlers({
[09:31:18.289]             ...future.value <- base::withVisible(base::local({
[09:31:18.289]                 lm(weight ~ group - 1)
[09:31:18.289]             }))
[09:31:18.289]             future::FutureResult(value = ...future.value$value, 
[09:31:18.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.289]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.289]                     ...future.globalenv.names))
[09:31:18.289]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.289]         }, condition = base::local({
[09:31:18.289]             c <- base::c
[09:31:18.289]             inherits <- base::inherits
[09:31:18.289]             invokeRestart <- base::invokeRestart
[09:31:18.289]             length <- base::length
[09:31:18.289]             list <- base::list
[09:31:18.289]             seq.int <- base::seq.int
[09:31:18.289]             signalCondition <- base::signalCondition
[09:31:18.289]             sys.calls <- base::sys.calls
[09:31:18.289]             `[[` <- base::`[[`
[09:31:18.289]             `+` <- base::`+`
[09:31:18.289]             `<<-` <- base::`<<-`
[09:31:18.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.289]                   3L)]
[09:31:18.289]             }
[09:31:18.289]             function(cond) {
[09:31:18.289]                 is_error <- inherits(cond, "error")
[09:31:18.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.289]                   NULL)
[09:31:18.289]                 if (is_error) {
[09:31:18.289]                   sessionInformation <- function() {
[09:31:18.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.289]                       search = base::search(), system = base::Sys.info())
[09:31:18.289]                   }
[09:31:18.289]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.289]                     cond$call), session = sessionInformation(), 
[09:31:18.289]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.289]                   signalCondition(cond)
[09:31:18.289]                 }
[09:31:18.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.289]                 "immediateCondition"))) {
[09:31:18.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.289]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.289]                   if (TRUE && !signal) {
[09:31:18.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.289]                     {
[09:31:18.289]                       inherits <- base::inherits
[09:31:18.289]                       invokeRestart <- base::invokeRestart
[09:31:18.289]                       is.null <- base::is.null
[09:31:18.289]                       muffled <- FALSE
[09:31:18.289]                       if (inherits(cond, "message")) {
[09:31:18.289]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.289]                         if (muffled) 
[09:31:18.289]                           invokeRestart("muffleMessage")
[09:31:18.289]                       }
[09:31:18.289]                       else if (inherits(cond, "warning")) {
[09:31:18.289]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.289]                         if (muffled) 
[09:31:18.289]                           invokeRestart("muffleWarning")
[09:31:18.289]                       }
[09:31:18.289]                       else if (inherits(cond, "condition")) {
[09:31:18.289]                         if (!is.null(pattern)) {
[09:31:18.289]                           computeRestarts <- base::computeRestarts
[09:31:18.289]                           grepl <- base::grepl
[09:31:18.289]                           restarts <- computeRestarts(cond)
[09:31:18.289]                           for (restart in restarts) {
[09:31:18.289]                             name <- restart$name
[09:31:18.289]                             if (is.null(name)) 
[09:31:18.289]                               next
[09:31:18.289]                             if (!grepl(pattern, name)) 
[09:31:18.289]                               next
[09:31:18.289]                             invokeRestart(restart)
[09:31:18.289]                             muffled <- TRUE
[09:31:18.289]                             break
[09:31:18.289]                           }
[09:31:18.289]                         }
[09:31:18.289]                       }
[09:31:18.289]                       invisible(muffled)
[09:31:18.289]                     }
[09:31:18.289]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.289]                   }
[09:31:18.289]                 }
[09:31:18.289]                 else {
[09:31:18.289]                   if (TRUE) {
[09:31:18.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.289]                     {
[09:31:18.289]                       inherits <- base::inherits
[09:31:18.289]                       invokeRestart <- base::invokeRestart
[09:31:18.289]                       is.null <- base::is.null
[09:31:18.289]                       muffled <- FALSE
[09:31:18.289]                       if (inherits(cond, "message")) {
[09:31:18.289]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.289]                         if (muffled) 
[09:31:18.289]                           invokeRestart("muffleMessage")
[09:31:18.289]                       }
[09:31:18.289]                       else if (inherits(cond, "warning")) {
[09:31:18.289]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.289]                         if (muffled) 
[09:31:18.289]                           invokeRestart("muffleWarning")
[09:31:18.289]                       }
[09:31:18.289]                       else if (inherits(cond, "condition")) {
[09:31:18.289]                         if (!is.null(pattern)) {
[09:31:18.289]                           computeRestarts <- base::computeRestarts
[09:31:18.289]                           grepl <- base::grepl
[09:31:18.289]                           restarts <- computeRestarts(cond)
[09:31:18.289]                           for (restart in restarts) {
[09:31:18.289]                             name <- restart$name
[09:31:18.289]                             if (is.null(name)) 
[09:31:18.289]                               next
[09:31:18.289]                             if (!grepl(pattern, name)) 
[09:31:18.289]                               next
[09:31:18.289]                             invokeRestart(restart)
[09:31:18.289]                             muffled <- TRUE
[09:31:18.289]                             break
[09:31:18.289]                           }
[09:31:18.289]                         }
[09:31:18.289]                       }
[09:31:18.289]                       invisible(muffled)
[09:31:18.289]                     }
[09:31:18.289]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.289]                   }
[09:31:18.289]                 }
[09:31:18.289]             }
[09:31:18.289]         }))
[09:31:18.289]     }, error = function(ex) {
[09:31:18.289]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.289]                 ...future.rng), started = ...future.startTime, 
[09:31:18.289]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.289]             version = "1.8"), class = "FutureResult")
[09:31:18.289]     }, finally = {
[09:31:18.289]         if (!identical(...future.workdir, getwd())) 
[09:31:18.289]             setwd(...future.workdir)
[09:31:18.289]         {
[09:31:18.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.289]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.289]             }
[09:31:18.289]             base::options(...future.oldOptions)
[09:31:18.289]             if (.Platform$OS.type == "windows") {
[09:31:18.289]                 old_names <- names(...future.oldEnvVars)
[09:31:18.289]                 envs <- base::Sys.getenv()
[09:31:18.289]                 names <- names(envs)
[09:31:18.289]                 common <- intersect(names, old_names)
[09:31:18.289]                 added <- setdiff(names, old_names)
[09:31:18.289]                 removed <- setdiff(old_names, names)
[09:31:18.289]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.289]                   envs[common]]
[09:31:18.289]                 NAMES <- toupper(changed)
[09:31:18.289]                 args <- list()
[09:31:18.289]                 for (kk in seq_along(NAMES)) {
[09:31:18.289]                   name <- changed[[kk]]
[09:31:18.289]                   NAME <- NAMES[[kk]]
[09:31:18.289]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.289]                     next
[09:31:18.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.289]                 }
[09:31:18.289]                 NAMES <- toupper(added)
[09:31:18.289]                 for (kk in seq_along(NAMES)) {
[09:31:18.289]                   name <- added[[kk]]
[09:31:18.289]                   NAME <- NAMES[[kk]]
[09:31:18.289]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.289]                     next
[09:31:18.289]                   args[[name]] <- ""
[09:31:18.289]                 }
[09:31:18.289]                 NAMES <- toupper(removed)
[09:31:18.289]                 for (kk in seq_along(NAMES)) {
[09:31:18.289]                   name <- removed[[kk]]
[09:31:18.289]                   NAME <- NAMES[[kk]]
[09:31:18.289]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.289]                     next
[09:31:18.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.289]                 }
[09:31:18.289]                 if (length(args) > 0) 
[09:31:18.289]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.289]             }
[09:31:18.289]             else {
[09:31:18.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.289]             }
[09:31:18.289]             {
[09:31:18.289]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.289]                   0L) {
[09:31:18.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.289]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.289]                   base::options(opts)
[09:31:18.289]                 }
[09:31:18.289]                 {
[09:31:18.289]                   {
[09:31:18.289]                     NULL
[09:31:18.289]                     RNGkind("Mersenne-Twister")
[09:31:18.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.289]                       inherits = FALSE)
[09:31:18.289]                   }
[09:31:18.289]                   options(future.plan = NULL)
[09:31:18.289]                   if (is.na(NA_character_)) 
[09:31:18.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.289]                     .init = FALSE)
[09:31:18.289]                 }
[09:31:18.289]             }
[09:31:18.289]         }
[09:31:18.289]     })
[09:31:18.289]     if (TRUE) {
[09:31:18.289]         base::sink(type = "output", split = FALSE)
[09:31:18.289]         if (TRUE) {
[09:31:18.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.289]         }
[09:31:18.289]         else {
[09:31:18.289]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.289]         }
[09:31:18.289]         base::close(...future.stdout)
[09:31:18.289]         ...future.stdout <- NULL
[09:31:18.289]     }
[09:31:18.289]     ...future.result$conditions <- ...future.conditions
[09:31:18.289]     ...future.result$finished <- base::Sys.time()
[09:31:18.289]     ...future.result
[09:31:18.289] }
[09:31:18.291] assign_globals() ...
[09:31:18.291] List of 2
[09:31:18.291]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.291]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.291]  - attr(*, "where")=List of 2
[09:31:18.291]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.291]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.291]  - attr(*, "resolved")= logi FALSE
[09:31:18.291]  - attr(*, "total_size")= num 896
[09:31:18.291]  - attr(*, "already-done")= logi TRUE
[09:31:18.294] - copied ‘weight’ to environment
[09:31:18.294] - copied ‘group’ to environment
[09:31:18.294] assign_globals() ... done
[09:31:18.294] plan(): Setting new future strategy stack:
[09:31:18.294] List of future strategies:
[09:31:18.294] 1. sequential:
[09:31:18.294]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.294]    - tweaked: FALSE
[09:31:18.294]    - call: NULL
[09:31:18.295] plan(): nbrOfWorkers() = 1
[09:31:18.296] plan(): Setting new future strategy stack:
[09:31:18.296] List of future strategies:
[09:31:18.296] 1. sequential:
[09:31:18.296]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.296]    - tweaked: FALSE
[09:31:18.296]    - call: plan(strategy)
[09:31:18.296] plan(): nbrOfWorkers() = 1
[09:31:18.297] SequentialFuture started (and completed)
[09:31:18.297] - Launch lazy future ... done
[09:31:18.297] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.299] getGlobalsAndPackages() ...
[09:31:18.299] Searching for globals...
[09:31:18.301] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.301] Searching for globals ... DONE
[09:31:18.301] Resolving globals: FALSE
[09:31:18.301] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.302] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.302] - globals: [2] ‘weight’, ‘group’
[09:31:18.302] - packages: [1] ‘stats’
[09:31:18.302] getGlobalsAndPackages() ... DONE
[09:31:18.302] run() for ‘Future’ ...
[09:31:18.302] - state: ‘created’
[09:31:18.302] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.303]   - Field: ‘label’
[09:31:18.303]   - Field: ‘local’
[09:31:18.303]   - Field: ‘owner’
[09:31:18.303]   - Field: ‘envir’
[09:31:18.303]   - Field: ‘packages’
[09:31:18.303]   - Field: ‘gc’
[09:31:18.303]   - Field: ‘conditions’
[09:31:18.303]   - Field: ‘expr’
[09:31:18.303]   - Field: ‘uuid’
[09:31:18.304]   - Field: ‘seed’
[09:31:18.304]   - Field: ‘version’
[09:31:18.304]   - Field: ‘result’
[09:31:18.304]   - Field: ‘asynchronous’
[09:31:18.304]   - Field: ‘calls’
[09:31:18.304]   - Field: ‘globals’
[09:31:18.304]   - Field: ‘stdout’
[09:31:18.304]   - Field: ‘earlySignal’
[09:31:18.304]   - Field: ‘lazy’
[09:31:18.304]   - Field: ‘state’
[09:31:18.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.305] - Launch lazy future ...
[09:31:18.305] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.305] Packages needed by future strategies (n = 0): <none>
[09:31:18.305] {
[09:31:18.305]     {
[09:31:18.305]         {
[09:31:18.305]             ...future.startTime <- base::Sys.time()
[09:31:18.305]             {
[09:31:18.305]                 {
[09:31:18.305]                   {
[09:31:18.305]                     {
[09:31:18.305]                       base::local({
[09:31:18.305]                         has_future <- base::requireNamespace("future", 
[09:31:18.305]                           quietly = TRUE)
[09:31:18.305]                         if (has_future) {
[09:31:18.305]                           ns <- base::getNamespace("future")
[09:31:18.305]                           version <- ns[[".package"]][["version"]]
[09:31:18.305]                           if (is.null(version)) 
[09:31:18.305]                             version <- utils::packageVersion("future")
[09:31:18.305]                         }
[09:31:18.305]                         else {
[09:31:18.305]                           version <- NULL
[09:31:18.305]                         }
[09:31:18.305]                         if (!has_future || version < "1.8.0") {
[09:31:18.305]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.305]                             "", base::R.version$version.string), 
[09:31:18.305]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.305]                               "release", "version")], collapse = " "), 
[09:31:18.305]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.305]                             info)
[09:31:18.305]                           info <- base::paste(info, collapse = "; ")
[09:31:18.305]                           if (!has_future) {
[09:31:18.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.305]                               info)
[09:31:18.305]                           }
[09:31:18.305]                           else {
[09:31:18.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.305]                               info, version)
[09:31:18.305]                           }
[09:31:18.305]                           base::stop(msg)
[09:31:18.305]                         }
[09:31:18.305]                       })
[09:31:18.305]                     }
[09:31:18.305]                     base::local({
[09:31:18.305]                       for (pkg in "stats") {
[09:31:18.305]                         base::loadNamespace(pkg)
[09:31:18.305]                         base::library(pkg, character.only = TRUE)
[09:31:18.305]                       }
[09:31:18.305]                     })
[09:31:18.305]                   }
[09:31:18.305]                   ...future.strategy.old <- future::plan("list")
[09:31:18.305]                   options(future.plan = NULL)
[09:31:18.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.305]                 }
[09:31:18.305]                 ...future.workdir <- getwd()
[09:31:18.305]             }
[09:31:18.305]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.305]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.305]         }
[09:31:18.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.305]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.305]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.305]             base::names(...future.oldOptions))
[09:31:18.305]     }
[09:31:18.305]     if (FALSE) {
[09:31:18.305]     }
[09:31:18.305]     else {
[09:31:18.305]         if (TRUE) {
[09:31:18.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.305]                 open = "w")
[09:31:18.305]         }
[09:31:18.305]         else {
[09:31:18.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.305]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.305]         }
[09:31:18.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.305]             base::sink(type = "output", split = FALSE)
[09:31:18.305]             base::close(...future.stdout)
[09:31:18.305]         }, add = TRUE)
[09:31:18.305]     }
[09:31:18.305]     ...future.frame <- base::sys.nframe()
[09:31:18.305]     ...future.conditions <- base::list()
[09:31:18.305]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.305]     if (FALSE) {
[09:31:18.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.305]     }
[09:31:18.305]     ...future.result <- base::tryCatch({
[09:31:18.305]         base::withCallingHandlers({
[09:31:18.305]             ...future.value <- base::withVisible(base::local({
[09:31:18.305]                 lm(weight ~ group - 1)
[09:31:18.305]             }))
[09:31:18.305]             future::FutureResult(value = ...future.value$value, 
[09:31:18.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.305]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.305]                     ...future.globalenv.names))
[09:31:18.305]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.305]         }, condition = base::local({
[09:31:18.305]             c <- base::c
[09:31:18.305]             inherits <- base::inherits
[09:31:18.305]             invokeRestart <- base::invokeRestart
[09:31:18.305]             length <- base::length
[09:31:18.305]             list <- base::list
[09:31:18.305]             seq.int <- base::seq.int
[09:31:18.305]             signalCondition <- base::signalCondition
[09:31:18.305]             sys.calls <- base::sys.calls
[09:31:18.305]             `[[` <- base::`[[`
[09:31:18.305]             `+` <- base::`+`
[09:31:18.305]             `<<-` <- base::`<<-`
[09:31:18.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.305]                   3L)]
[09:31:18.305]             }
[09:31:18.305]             function(cond) {
[09:31:18.305]                 is_error <- inherits(cond, "error")
[09:31:18.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.305]                   NULL)
[09:31:18.305]                 if (is_error) {
[09:31:18.305]                   sessionInformation <- function() {
[09:31:18.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.305]                       search = base::search(), system = base::Sys.info())
[09:31:18.305]                   }
[09:31:18.305]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.305]                     cond$call), session = sessionInformation(), 
[09:31:18.305]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.305]                   signalCondition(cond)
[09:31:18.305]                 }
[09:31:18.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.305]                 "immediateCondition"))) {
[09:31:18.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.305]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.305]                   if (TRUE && !signal) {
[09:31:18.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.305]                     {
[09:31:18.305]                       inherits <- base::inherits
[09:31:18.305]                       invokeRestart <- base::invokeRestart
[09:31:18.305]                       is.null <- base::is.null
[09:31:18.305]                       muffled <- FALSE
[09:31:18.305]                       if (inherits(cond, "message")) {
[09:31:18.305]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.305]                         if (muffled) 
[09:31:18.305]                           invokeRestart("muffleMessage")
[09:31:18.305]                       }
[09:31:18.305]                       else if (inherits(cond, "warning")) {
[09:31:18.305]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.305]                         if (muffled) 
[09:31:18.305]                           invokeRestart("muffleWarning")
[09:31:18.305]                       }
[09:31:18.305]                       else if (inherits(cond, "condition")) {
[09:31:18.305]                         if (!is.null(pattern)) {
[09:31:18.305]                           computeRestarts <- base::computeRestarts
[09:31:18.305]                           grepl <- base::grepl
[09:31:18.305]                           restarts <- computeRestarts(cond)
[09:31:18.305]                           for (restart in restarts) {
[09:31:18.305]                             name <- restart$name
[09:31:18.305]                             if (is.null(name)) 
[09:31:18.305]                               next
[09:31:18.305]                             if (!grepl(pattern, name)) 
[09:31:18.305]                               next
[09:31:18.305]                             invokeRestart(restart)
[09:31:18.305]                             muffled <- TRUE
[09:31:18.305]                             break
[09:31:18.305]                           }
[09:31:18.305]                         }
[09:31:18.305]                       }
[09:31:18.305]                       invisible(muffled)
[09:31:18.305]                     }
[09:31:18.305]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.305]                   }
[09:31:18.305]                 }
[09:31:18.305]                 else {
[09:31:18.305]                   if (TRUE) {
[09:31:18.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.305]                     {
[09:31:18.305]                       inherits <- base::inherits
[09:31:18.305]                       invokeRestart <- base::invokeRestart
[09:31:18.305]                       is.null <- base::is.null
[09:31:18.305]                       muffled <- FALSE
[09:31:18.305]                       if (inherits(cond, "message")) {
[09:31:18.305]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.305]                         if (muffled) 
[09:31:18.305]                           invokeRestart("muffleMessage")
[09:31:18.305]                       }
[09:31:18.305]                       else if (inherits(cond, "warning")) {
[09:31:18.305]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.305]                         if (muffled) 
[09:31:18.305]                           invokeRestart("muffleWarning")
[09:31:18.305]                       }
[09:31:18.305]                       else if (inherits(cond, "condition")) {
[09:31:18.305]                         if (!is.null(pattern)) {
[09:31:18.305]                           computeRestarts <- base::computeRestarts
[09:31:18.305]                           grepl <- base::grepl
[09:31:18.305]                           restarts <- computeRestarts(cond)
[09:31:18.305]                           for (restart in restarts) {
[09:31:18.305]                             name <- restart$name
[09:31:18.305]                             if (is.null(name)) 
[09:31:18.305]                               next
[09:31:18.305]                             if (!grepl(pattern, name)) 
[09:31:18.305]                               next
[09:31:18.305]                             invokeRestart(restart)
[09:31:18.305]                             muffled <- TRUE
[09:31:18.305]                             break
[09:31:18.305]                           }
[09:31:18.305]                         }
[09:31:18.305]                       }
[09:31:18.305]                       invisible(muffled)
[09:31:18.305]                     }
[09:31:18.305]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.305]                   }
[09:31:18.305]                 }
[09:31:18.305]             }
[09:31:18.305]         }))
[09:31:18.305]     }, error = function(ex) {
[09:31:18.305]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.305]                 ...future.rng), started = ...future.startTime, 
[09:31:18.305]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.305]             version = "1.8"), class = "FutureResult")
[09:31:18.305]     }, finally = {
[09:31:18.305]         if (!identical(...future.workdir, getwd())) 
[09:31:18.305]             setwd(...future.workdir)
[09:31:18.305]         {
[09:31:18.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.305]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.305]             }
[09:31:18.305]             base::options(...future.oldOptions)
[09:31:18.305]             if (.Platform$OS.type == "windows") {
[09:31:18.305]                 old_names <- names(...future.oldEnvVars)
[09:31:18.305]                 envs <- base::Sys.getenv()
[09:31:18.305]                 names <- names(envs)
[09:31:18.305]                 common <- intersect(names, old_names)
[09:31:18.305]                 added <- setdiff(names, old_names)
[09:31:18.305]                 removed <- setdiff(old_names, names)
[09:31:18.305]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.305]                   envs[common]]
[09:31:18.305]                 NAMES <- toupper(changed)
[09:31:18.305]                 args <- list()
[09:31:18.305]                 for (kk in seq_along(NAMES)) {
[09:31:18.305]                   name <- changed[[kk]]
[09:31:18.305]                   NAME <- NAMES[[kk]]
[09:31:18.305]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.305]                     next
[09:31:18.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.305]                 }
[09:31:18.305]                 NAMES <- toupper(added)
[09:31:18.305]                 for (kk in seq_along(NAMES)) {
[09:31:18.305]                   name <- added[[kk]]
[09:31:18.305]                   NAME <- NAMES[[kk]]
[09:31:18.305]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.305]                     next
[09:31:18.305]                   args[[name]] <- ""
[09:31:18.305]                 }
[09:31:18.305]                 NAMES <- toupper(removed)
[09:31:18.305]                 for (kk in seq_along(NAMES)) {
[09:31:18.305]                   name <- removed[[kk]]
[09:31:18.305]                   NAME <- NAMES[[kk]]
[09:31:18.305]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.305]                     next
[09:31:18.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.305]                 }
[09:31:18.305]                 if (length(args) > 0) 
[09:31:18.305]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.305]             }
[09:31:18.305]             else {
[09:31:18.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.305]             }
[09:31:18.305]             {
[09:31:18.305]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.305]                   0L) {
[09:31:18.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.305]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.305]                   base::options(opts)
[09:31:18.305]                 }
[09:31:18.305]                 {
[09:31:18.305]                   {
[09:31:18.305]                     NULL
[09:31:18.305]                     RNGkind("Mersenne-Twister")
[09:31:18.305]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.305]                       inherits = FALSE)
[09:31:18.305]                   }
[09:31:18.305]                   options(future.plan = NULL)
[09:31:18.305]                   if (is.na(NA_character_)) 
[09:31:18.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.305]                     .init = FALSE)
[09:31:18.305]                 }
[09:31:18.305]             }
[09:31:18.305]         }
[09:31:18.305]     })
[09:31:18.305]     if (TRUE) {
[09:31:18.305]         base::sink(type = "output", split = FALSE)
[09:31:18.305]         if (TRUE) {
[09:31:18.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.305]         }
[09:31:18.305]         else {
[09:31:18.305]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.305]         }
[09:31:18.305]         base::close(...future.stdout)
[09:31:18.305]         ...future.stdout <- NULL
[09:31:18.305]     }
[09:31:18.305]     ...future.result$conditions <- ...future.conditions
[09:31:18.305]     ...future.result$finished <- base::Sys.time()
[09:31:18.305]     ...future.result
[09:31:18.305] }
[09:31:18.307] assign_globals() ...
[09:31:18.307] List of 2
[09:31:18.307]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.307]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.307]  - attr(*, "where")=List of 2
[09:31:18.307]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.307]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.307]  - attr(*, "resolved")= logi FALSE
[09:31:18.307]  - attr(*, "total_size")= num 896
[09:31:18.307]  - attr(*, "already-done")= logi TRUE
[09:31:18.310] - copied ‘weight’ to environment
[09:31:18.310] - copied ‘group’ to environment
[09:31:18.310] assign_globals() ... done
[09:31:18.310] plan(): Setting new future strategy stack:
[09:31:18.310] List of future strategies:
[09:31:18.310] 1. sequential:
[09:31:18.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.310]    - tweaked: FALSE
[09:31:18.310]    - call: NULL
[09:31:18.311] plan(): nbrOfWorkers() = 1
[09:31:18.312] plan(): Setting new future strategy stack:
[09:31:18.312] List of future strategies:
[09:31:18.312] 1. sequential:
[09:31:18.312]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.312]    - tweaked: FALSE
[09:31:18.312]    - call: plan(strategy)
[09:31:18.313] plan(): nbrOfWorkers() = 1
[09:31:18.313] SequentialFuture started (and completed)
[09:31:18.313] - Launch lazy future ... done
[09:31:18.313] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.316] getGlobalsAndPackages() ...
[09:31:18.316] Searching for globals...
[09:31:18.317] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.317] Searching for globals ... DONE
[09:31:18.317] Resolving globals: FALSE
[09:31:18.318] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.318] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.318] - globals: [2] ‘weight’, ‘group’
[09:31:18.318] - packages: [1] ‘stats’
[09:31:18.318] getGlobalsAndPackages() ... DONE
[09:31:18.319] run() for ‘Future’ ...
[09:31:18.319] - state: ‘created’
[09:31:18.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.319] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.319] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.319]   - Field: ‘label’
[09:31:18.319]   - Field: ‘local’
[09:31:18.319]   - Field: ‘owner’
[09:31:18.320]   - Field: ‘envir’
[09:31:18.320]   - Field: ‘packages’
[09:31:18.320]   - Field: ‘gc’
[09:31:18.320]   - Field: ‘conditions’
[09:31:18.320]   - Field: ‘expr’
[09:31:18.320]   - Field: ‘uuid’
[09:31:18.320]   - Field: ‘seed’
[09:31:18.320]   - Field: ‘version’
[09:31:18.320]   - Field: ‘result’
[09:31:18.320]   - Field: ‘asynchronous’
[09:31:18.320]   - Field: ‘calls’
[09:31:18.321]   - Field: ‘globals’
[09:31:18.321]   - Field: ‘stdout’
[09:31:18.321]   - Field: ‘earlySignal’
[09:31:18.321]   - Field: ‘lazy’
[09:31:18.321]   - Field: ‘state’
[09:31:18.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.321] - Launch lazy future ...
[09:31:18.321] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.321] Packages needed by future strategies (n = 0): <none>
[09:31:18.322] {
[09:31:18.322]     {
[09:31:18.322]         {
[09:31:18.322]             ...future.startTime <- base::Sys.time()
[09:31:18.322]             {
[09:31:18.322]                 {
[09:31:18.322]                   {
[09:31:18.322]                     {
[09:31:18.322]                       base::local({
[09:31:18.322]                         has_future <- base::requireNamespace("future", 
[09:31:18.322]                           quietly = TRUE)
[09:31:18.322]                         if (has_future) {
[09:31:18.322]                           ns <- base::getNamespace("future")
[09:31:18.322]                           version <- ns[[".package"]][["version"]]
[09:31:18.322]                           if (is.null(version)) 
[09:31:18.322]                             version <- utils::packageVersion("future")
[09:31:18.322]                         }
[09:31:18.322]                         else {
[09:31:18.322]                           version <- NULL
[09:31:18.322]                         }
[09:31:18.322]                         if (!has_future || version < "1.8.0") {
[09:31:18.322]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.322]                             "", base::R.version$version.string), 
[09:31:18.322]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.322]                               "release", "version")], collapse = " "), 
[09:31:18.322]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.322]                             info)
[09:31:18.322]                           info <- base::paste(info, collapse = "; ")
[09:31:18.322]                           if (!has_future) {
[09:31:18.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.322]                               info)
[09:31:18.322]                           }
[09:31:18.322]                           else {
[09:31:18.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.322]                               info, version)
[09:31:18.322]                           }
[09:31:18.322]                           base::stop(msg)
[09:31:18.322]                         }
[09:31:18.322]                       })
[09:31:18.322]                     }
[09:31:18.322]                     base::local({
[09:31:18.322]                       for (pkg in "stats") {
[09:31:18.322]                         base::loadNamespace(pkg)
[09:31:18.322]                         base::library(pkg, character.only = TRUE)
[09:31:18.322]                       }
[09:31:18.322]                     })
[09:31:18.322]                   }
[09:31:18.322]                   ...future.strategy.old <- future::plan("list")
[09:31:18.322]                   options(future.plan = NULL)
[09:31:18.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.322]                 }
[09:31:18.322]                 ...future.workdir <- getwd()
[09:31:18.322]             }
[09:31:18.322]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.322]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.322]         }
[09:31:18.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.322]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.322]             base::names(...future.oldOptions))
[09:31:18.322]     }
[09:31:18.322]     if (FALSE) {
[09:31:18.322]     }
[09:31:18.322]     else {
[09:31:18.322]         if (TRUE) {
[09:31:18.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.322]                 open = "w")
[09:31:18.322]         }
[09:31:18.322]         else {
[09:31:18.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.322]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.322]         }
[09:31:18.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.322]             base::sink(type = "output", split = FALSE)
[09:31:18.322]             base::close(...future.stdout)
[09:31:18.322]         }, add = TRUE)
[09:31:18.322]     }
[09:31:18.322]     ...future.frame <- base::sys.nframe()
[09:31:18.322]     ...future.conditions <- base::list()
[09:31:18.322]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.322]     if (FALSE) {
[09:31:18.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.322]     }
[09:31:18.322]     ...future.result <- base::tryCatch({
[09:31:18.322]         base::withCallingHandlers({
[09:31:18.322]             ...future.value <- base::withVisible(base::local({
[09:31:18.322]                 lm(weight ~ group - 1)
[09:31:18.322]             }))
[09:31:18.322]             future::FutureResult(value = ...future.value$value, 
[09:31:18.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.322]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.322]                     ...future.globalenv.names))
[09:31:18.322]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.322]         }, condition = base::local({
[09:31:18.322]             c <- base::c
[09:31:18.322]             inherits <- base::inherits
[09:31:18.322]             invokeRestart <- base::invokeRestart
[09:31:18.322]             length <- base::length
[09:31:18.322]             list <- base::list
[09:31:18.322]             seq.int <- base::seq.int
[09:31:18.322]             signalCondition <- base::signalCondition
[09:31:18.322]             sys.calls <- base::sys.calls
[09:31:18.322]             `[[` <- base::`[[`
[09:31:18.322]             `+` <- base::`+`
[09:31:18.322]             `<<-` <- base::`<<-`
[09:31:18.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.322]                   3L)]
[09:31:18.322]             }
[09:31:18.322]             function(cond) {
[09:31:18.322]                 is_error <- inherits(cond, "error")
[09:31:18.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.322]                   NULL)
[09:31:18.322]                 if (is_error) {
[09:31:18.322]                   sessionInformation <- function() {
[09:31:18.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.322]                       search = base::search(), system = base::Sys.info())
[09:31:18.322]                   }
[09:31:18.322]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.322]                     cond$call), session = sessionInformation(), 
[09:31:18.322]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.322]                   signalCondition(cond)
[09:31:18.322]                 }
[09:31:18.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.322]                 "immediateCondition"))) {
[09:31:18.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.322]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.322]                   if (TRUE && !signal) {
[09:31:18.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.322]                     {
[09:31:18.322]                       inherits <- base::inherits
[09:31:18.322]                       invokeRestart <- base::invokeRestart
[09:31:18.322]                       is.null <- base::is.null
[09:31:18.322]                       muffled <- FALSE
[09:31:18.322]                       if (inherits(cond, "message")) {
[09:31:18.322]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.322]                         if (muffled) 
[09:31:18.322]                           invokeRestart("muffleMessage")
[09:31:18.322]                       }
[09:31:18.322]                       else if (inherits(cond, "warning")) {
[09:31:18.322]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.322]                         if (muffled) 
[09:31:18.322]                           invokeRestart("muffleWarning")
[09:31:18.322]                       }
[09:31:18.322]                       else if (inherits(cond, "condition")) {
[09:31:18.322]                         if (!is.null(pattern)) {
[09:31:18.322]                           computeRestarts <- base::computeRestarts
[09:31:18.322]                           grepl <- base::grepl
[09:31:18.322]                           restarts <- computeRestarts(cond)
[09:31:18.322]                           for (restart in restarts) {
[09:31:18.322]                             name <- restart$name
[09:31:18.322]                             if (is.null(name)) 
[09:31:18.322]                               next
[09:31:18.322]                             if (!grepl(pattern, name)) 
[09:31:18.322]                               next
[09:31:18.322]                             invokeRestart(restart)
[09:31:18.322]                             muffled <- TRUE
[09:31:18.322]                             break
[09:31:18.322]                           }
[09:31:18.322]                         }
[09:31:18.322]                       }
[09:31:18.322]                       invisible(muffled)
[09:31:18.322]                     }
[09:31:18.322]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.322]                   }
[09:31:18.322]                 }
[09:31:18.322]                 else {
[09:31:18.322]                   if (TRUE) {
[09:31:18.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.322]                     {
[09:31:18.322]                       inherits <- base::inherits
[09:31:18.322]                       invokeRestart <- base::invokeRestart
[09:31:18.322]                       is.null <- base::is.null
[09:31:18.322]                       muffled <- FALSE
[09:31:18.322]                       if (inherits(cond, "message")) {
[09:31:18.322]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.322]                         if (muffled) 
[09:31:18.322]                           invokeRestart("muffleMessage")
[09:31:18.322]                       }
[09:31:18.322]                       else if (inherits(cond, "warning")) {
[09:31:18.322]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.322]                         if (muffled) 
[09:31:18.322]                           invokeRestart("muffleWarning")
[09:31:18.322]                       }
[09:31:18.322]                       else if (inherits(cond, "condition")) {
[09:31:18.322]                         if (!is.null(pattern)) {
[09:31:18.322]                           computeRestarts <- base::computeRestarts
[09:31:18.322]                           grepl <- base::grepl
[09:31:18.322]                           restarts <- computeRestarts(cond)
[09:31:18.322]                           for (restart in restarts) {
[09:31:18.322]                             name <- restart$name
[09:31:18.322]                             if (is.null(name)) 
[09:31:18.322]                               next
[09:31:18.322]                             if (!grepl(pattern, name)) 
[09:31:18.322]                               next
[09:31:18.322]                             invokeRestart(restart)
[09:31:18.322]                             muffled <- TRUE
[09:31:18.322]                             break
[09:31:18.322]                           }
[09:31:18.322]                         }
[09:31:18.322]                       }
[09:31:18.322]                       invisible(muffled)
[09:31:18.322]                     }
[09:31:18.322]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.322]                   }
[09:31:18.322]                 }
[09:31:18.322]             }
[09:31:18.322]         }))
[09:31:18.322]     }, error = function(ex) {
[09:31:18.322]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.322]                 ...future.rng), started = ...future.startTime, 
[09:31:18.322]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.322]             version = "1.8"), class = "FutureResult")
[09:31:18.322]     }, finally = {
[09:31:18.322]         if (!identical(...future.workdir, getwd())) 
[09:31:18.322]             setwd(...future.workdir)
[09:31:18.322]         {
[09:31:18.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.322]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.322]             }
[09:31:18.322]             base::options(...future.oldOptions)
[09:31:18.322]             if (.Platform$OS.type == "windows") {
[09:31:18.322]                 old_names <- names(...future.oldEnvVars)
[09:31:18.322]                 envs <- base::Sys.getenv()
[09:31:18.322]                 names <- names(envs)
[09:31:18.322]                 common <- intersect(names, old_names)
[09:31:18.322]                 added <- setdiff(names, old_names)
[09:31:18.322]                 removed <- setdiff(old_names, names)
[09:31:18.322]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.322]                   envs[common]]
[09:31:18.322]                 NAMES <- toupper(changed)
[09:31:18.322]                 args <- list()
[09:31:18.322]                 for (kk in seq_along(NAMES)) {
[09:31:18.322]                   name <- changed[[kk]]
[09:31:18.322]                   NAME <- NAMES[[kk]]
[09:31:18.322]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.322]                     next
[09:31:18.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.322]                 }
[09:31:18.322]                 NAMES <- toupper(added)
[09:31:18.322]                 for (kk in seq_along(NAMES)) {
[09:31:18.322]                   name <- added[[kk]]
[09:31:18.322]                   NAME <- NAMES[[kk]]
[09:31:18.322]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.322]                     next
[09:31:18.322]                   args[[name]] <- ""
[09:31:18.322]                 }
[09:31:18.322]                 NAMES <- toupper(removed)
[09:31:18.322]                 for (kk in seq_along(NAMES)) {
[09:31:18.322]                   name <- removed[[kk]]
[09:31:18.322]                   NAME <- NAMES[[kk]]
[09:31:18.322]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.322]                     next
[09:31:18.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.322]                 }
[09:31:18.322]                 if (length(args) > 0) 
[09:31:18.322]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.322]             }
[09:31:18.322]             else {
[09:31:18.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.322]             }
[09:31:18.322]             {
[09:31:18.322]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.322]                   0L) {
[09:31:18.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.322]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.322]                   base::options(opts)
[09:31:18.322]                 }
[09:31:18.322]                 {
[09:31:18.322]                   {
[09:31:18.322]                     NULL
[09:31:18.322]                     RNGkind("Mersenne-Twister")
[09:31:18.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.322]                       inherits = FALSE)
[09:31:18.322]                   }
[09:31:18.322]                   options(future.plan = NULL)
[09:31:18.322]                   if (is.na(NA_character_)) 
[09:31:18.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.322]                     .init = FALSE)
[09:31:18.322]                 }
[09:31:18.322]             }
[09:31:18.322]         }
[09:31:18.322]     })
[09:31:18.322]     if (TRUE) {
[09:31:18.322]         base::sink(type = "output", split = FALSE)
[09:31:18.322]         if (TRUE) {
[09:31:18.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.322]         }
[09:31:18.322]         else {
[09:31:18.322]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.322]         }
[09:31:18.322]         base::close(...future.stdout)
[09:31:18.322]         ...future.stdout <- NULL
[09:31:18.322]     }
[09:31:18.322]     ...future.result$conditions <- ...future.conditions
[09:31:18.322]     ...future.result$finished <- base::Sys.time()
[09:31:18.322]     ...future.result
[09:31:18.322] }
[09:31:18.323] assign_globals() ...
[09:31:18.323] List of 2
[09:31:18.323]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.323]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.323]  - attr(*, "where")=List of 2
[09:31:18.323]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.323]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.323]  - attr(*, "resolved")= logi FALSE
[09:31:18.323]  - attr(*, "total_size")= num 896
[09:31:18.323]  - attr(*, "already-done")= logi TRUE
[09:31:18.326] - copied ‘weight’ to environment
[09:31:18.326] - copied ‘group’ to environment
[09:31:18.326] assign_globals() ... done
[09:31:18.327] plan(): Setting new future strategy stack:
[09:31:18.327] List of future strategies:
[09:31:18.327] 1. sequential:
[09:31:18.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.327]    - tweaked: FALSE
[09:31:18.327]    - call: NULL
[09:31:18.327] plan(): nbrOfWorkers() = 1
[09:31:18.329] plan(): Setting new future strategy stack:
[09:31:18.329] List of future strategies:
[09:31:18.329] 1. sequential:
[09:31:18.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.329]    - tweaked: FALSE
[09:31:18.329]    - call: plan(strategy)
[09:31:18.329] plan(): nbrOfWorkers() = 1
[09:31:18.329] SequentialFuture started (and completed)
[09:31:18.329] - Launch lazy future ... done
[09:31:18.329] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.331] getGlobalsAndPackages() ...
[09:31:18.331] Searching for globals...
[09:31:18.333] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.333] Searching for globals ... DONE
[09:31:18.333] Resolving globals: FALSE
[09:31:18.333] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.333] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.334] - globals: [2] ‘weight’, ‘group’
[09:31:18.334] - packages: [1] ‘stats’
[09:31:18.334] getGlobalsAndPackages() ... DONE
[09:31:18.334] run() for ‘Future’ ...
[09:31:18.334] - state: ‘created’
[09:31:18.334] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.335] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.335]   - Field: ‘label’
[09:31:18.335]   - Field: ‘local’
[09:31:18.335]   - Field: ‘owner’
[09:31:18.335]   - Field: ‘envir’
[09:31:18.335]   - Field: ‘packages’
[09:31:18.335]   - Field: ‘gc’
[09:31:18.335]   - Field: ‘conditions’
[09:31:18.335]   - Field: ‘expr’
[09:31:18.335]   - Field: ‘uuid’
[09:31:18.336]   - Field: ‘seed’
[09:31:18.336]   - Field: ‘version’
[09:31:18.336]   - Field: ‘result’
[09:31:18.336]   - Field: ‘asynchronous’
[09:31:18.336]   - Field: ‘calls’
[09:31:18.336]   - Field: ‘globals’
[09:31:18.336]   - Field: ‘stdout’
[09:31:18.336]   - Field: ‘earlySignal’
[09:31:18.336]   - Field: ‘lazy’
[09:31:18.336]   - Field: ‘state’
[09:31:18.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.337] - Launch lazy future ...
[09:31:18.337] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.337] Packages needed by future strategies (n = 0): <none>
[09:31:18.338] {
[09:31:18.338]     {
[09:31:18.338]         {
[09:31:18.338]             ...future.startTime <- base::Sys.time()
[09:31:18.338]             {
[09:31:18.338]                 {
[09:31:18.338]                   {
[09:31:18.338]                     {
[09:31:18.338]                       base::local({
[09:31:18.338]                         has_future <- base::requireNamespace("future", 
[09:31:18.338]                           quietly = TRUE)
[09:31:18.338]                         if (has_future) {
[09:31:18.338]                           ns <- base::getNamespace("future")
[09:31:18.338]                           version <- ns[[".package"]][["version"]]
[09:31:18.338]                           if (is.null(version)) 
[09:31:18.338]                             version <- utils::packageVersion("future")
[09:31:18.338]                         }
[09:31:18.338]                         else {
[09:31:18.338]                           version <- NULL
[09:31:18.338]                         }
[09:31:18.338]                         if (!has_future || version < "1.8.0") {
[09:31:18.338]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.338]                             "", base::R.version$version.string), 
[09:31:18.338]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.338]                               "release", "version")], collapse = " "), 
[09:31:18.338]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.338]                             info)
[09:31:18.338]                           info <- base::paste(info, collapse = "; ")
[09:31:18.338]                           if (!has_future) {
[09:31:18.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.338]                               info)
[09:31:18.338]                           }
[09:31:18.338]                           else {
[09:31:18.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.338]                               info, version)
[09:31:18.338]                           }
[09:31:18.338]                           base::stop(msg)
[09:31:18.338]                         }
[09:31:18.338]                       })
[09:31:18.338]                     }
[09:31:18.338]                     base::local({
[09:31:18.338]                       for (pkg in "stats") {
[09:31:18.338]                         base::loadNamespace(pkg)
[09:31:18.338]                         base::library(pkg, character.only = TRUE)
[09:31:18.338]                       }
[09:31:18.338]                     })
[09:31:18.338]                   }
[09:31:18.338]                   ...future.strategy.old <- future::plan("list")
[09:31:18.338]                   options(future.plan = NULL)
[09:31:18.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.338]                 }
[09:31:18.338]                 ...future.workdir <- getwd()
[09:31:18.338]             }
[09:31:18.338]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.338]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.338]         }
[09:31:18.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.338]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.338]             base::names(...future.oldOptions))
[09:31:18.338]     }
[09:31:18.338]     if (FALSE) {
[09:31:18.338]     }
[09:31:18.338]     else {
[09:31:18.338]         if (TRUE) {
[09:31:18.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.338]                 open = "w")
[09:31:18.338]         }
[09:31:18.338]         else {
[09:31:18.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.338]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.338]         }
[09:31:18.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.338]             base::sink(type = "output", split = FALSE)
[09:31:18.338]             base::close(...future.stdout)
[09:31:18.338]         }, add = TRUE)
[09:31:18.338]     }
[09:31:18.338]     ...future.frame <- base::sys.nframe()
[09:31:18.338]     ...future.conditions <- base::list()
[09:31:18.338]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.338]     if (FALSE) {
[09:31:18.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.338]     }
[09:31:18.338]     ...future.result <- base::tryCatch({
[09:31:18.338]         base::withCallingHandlers({
[09:31:18.338]             ...future.value <- base::withVisible(base::local({
[09:31:18.338]                 lm(weight ~ group - 1)
[09:31:18.338]             }))
[09:31:18.338]             future::FutureResult(value = ...future.value$value, 
[09:31:18.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.338]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.338]                     ...future.globalenv.names))
[09:31:18.338]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.338]         }, condition = base::local({
[09:31:18.338]             c <- base::c
[09:31:18.338]             inherits <- base::inherits
[09:31:18.338]             invokeRestart <- base::invokeRestart
[09:31:18.338]             length <- base::length
[09:31:18.338]             list <- base::list
[09:31:18.338]             seq.int <- base::seq.int
[09:31:18.338]             signalCondition <- base::signalCondition
[09:31:18.338]             sys.calls <- base::sys.calls
[09:31:18.338]             `[[` <- base::`[[`
[09:31:18.338]             `+` <- base::`+`
[09:31:18.338]             `<<-` <- base::`<<-`
[09:31:18.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.338]                   3L)]
[09:31:18.338]             }
[09:31:18.338]             function(cond) {
[09:31:18.338]                 is_error <- inherits(cond, "error")
[09:31:18.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.338]                   NULL)
[09:31:18.338]                 if (is_error) {
[09:31:18.338]                   sessionInformation <- function() {
[09:31:18.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.338]                       search = base::search(), system = base::Sys.info())
[09:31:18.338]                   }
[09:31:18.338]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.338]                     cond$call), session = sessionInformation(), 
[09:31:18.338]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.338]                   signalCondition(cond)
[09:31:18.338]                 }
[09:31:18.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.338]                 "immediateCondition"))) {
[09:31:18.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.338]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.338]                   if (TRUE && !signal) {
[09:31:18.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.338]                     {
[09:31:18.338]                       inherits <- base::inherits
[09:31:18.338]                       invokeRestart <- base::invokeRestart
[09:31:18.338]                       is.null <- base::is.null
[09:31:18.338]                       muffled <- FALSE
[09:31:18.338]                       if (inherits(cond, "message")) {
[09:31:18.338]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.338]                         if (muffled) 
[09:31:18.338]                           invokeRestart("muffleMessage")
[09:31:18.338]                       }
[09:31:18.338]                       else if (inherits(cond, "warning")) {
[09:31:18.338]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.338]                         if (muffled) 
[09:31:18.338]                           invokeRestart("muffleWarning")
[09:31:18.338]                       }
[09:31:18.338]                       else if (inherits(cond, "condition")) {
[09:31:18.338]                         if (!is.null(pattern)) {
[09:31:18.338]                           computeRestarts <- base::computeRestarts
[09:31:18.338]                           grepl <- base::grepl
[09:31:18.338]                           restarts <- computeRestarts(cond)
[09:31:18.338]                           for (restart in restarts) {
[09:31:18.338]                             name <- restart$name
[09:31:18.338]                             if (is.null(name)) 
[09:31:18.338]                               next
[09:31:18.338]                             if (!grepl(pattern, name)) 
[09:31:18.338]                               next
[09:31:18.338]                             invokeRestart(restart)
[09:31:18.338]                             muffled <- TRUE
[09:31:18.338]                             break
[09:31:18.338]                           }
[09:31:18.338]                         }
[09:31:18.338]                       }
[09:31:18.338]                       invisible(muffled)
[09:31:18.338]                     }
[09:31:18.338]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.338]                   }
[09:31:18.338]                 }
[09:31:18.338]                 else {
[09:31:18.338]                   if (TRUE) {
[09:31:18.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.338]                     {
[09:31:18.338]                       inherits <- base::inherits
[09:31:18.338]                       invokeRestart <- base::invokeRestart
[09:31:18.338]                       is.null <- base::is.null
[09:31:18.338]                       muffled <- FALSE
[09:31:18.338]                       if (inherits(cond, "message")) {
[09:31:18.338]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.338]                         if (muffled) 
[09:31:18.338]                           invokeRestart("muffleMessage")
[09:31:18.338]                       }
[09:31:18.338]                       else if (inherits(cond, "warning")) {
[09:31:18.338]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.338]                         if (muffled) 
[09:31:18.338]                           invokeRestart("muffleWarning")
[09:31:18.338]                       }
[09:31:18.338]                       else if (inherits(cond, "condition")) {
[09:31:18.338]                         if (!is.null(pattern)) {
[09:31:18.338]                           computeRestarts <- base::computeRestarts
[09:31:18.338]                           grepl <- base::grepl
[09:31:18.338]                           restarts <- computeRestarts(cond)
[09:31:18.338]                           for (restart in restarts) {
[09:31:18.338]                             name <- restart$name
[09:31:18.338]                             if (is.null(name)) 
[09:31:18.338]                               next
[09:31:18.338]                             if (!grepl(pattern, name)) 
[09:31:18.338]                               next
[09:31:18.338]                             invokeRestart(restart)
[09:31:18.338]                             muffled <- TRUE
[09:31:18.338]                             break
[09:31:18.338]                           }
[09:31:18.338]                         }
[09:31:18.338]                       }
[09:31:18.338]                       invisible(muffled)
[09:31:18.338]                     }
[09:31:18.338]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.338]                   }
[09:31:18.338]                 }
[09:31:18.338]             }
[09:31:18.338]         }))
[09:31:18.338]     }, error = function(ex) {
[09:31:18.338]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.338]                 ...future.rng), started = ...future.startTime, 
[09:31:18.338]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.338]             version = "1.8"), class = "FutureResult")
[09:31:18.338]     }, finally = {
[09:31:18.338]         if (!identical(...future.workdir, getwd())) 
[09:31:18.338]             setwd(...future.workdir)
[09:31:18.338]         {
[09:31:18.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.338]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.338]             }
[09:31:18.338]             base::options(...future.oldOptions)
[09:31:18.338]             if (.Platform$OS.type == "windows") {
[09:31:18.338]                 old_names <- names(...future.oldEnvVars)
[09:31:18.338]                 envs <- base::Sys.getenv()
[09:31:18.338]                 names <- names(envs)
[09:31:18.338]                 common <- intersect(names, old_names)
[09:31:18.338]                 added <- setdiff(names, old_names)
[09:31:18.338]                 removed <- setdiff(old_names, names)
[09:31:18.338]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.338]                   envs[common]]
[09:31:18.338]                 NAMES <- toupper(changed)
[09:31:18.338]                 args <- list()
[09:31:18.338]                 for (kk in seq_along(NAMES)) {
[09:31:18.338]                   name <- changed[[kk]]
[09:31:18.338]                   NAME <- NAMES[[kk]]
[09:31:18.338]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.338]                     next
[09:31:18.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.338]                 }
[09:31:18.338]                 NAMES <- toupper(added)
[09:31:18.338]                 for (kk in seq_along(NAMES)) {
[09:31:18.338]                   name <- added[[kk]]
[09:31:18.338]                   NAME <- NAMES[[kk]]
[09:31:18.338]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.338]                     next
[09:31:18.338]                   args[[name]] <- ""
[09:31:18.338]                 }
[09:31:18.338]                 NAMES <- toupper(removed)
[09:31:18.338]                 for (kk in seq_along(NAMES)) {
[09:31:18.338]                   name <- removed[[kk]]
[09:31:18.338]                   NAME <- NAMES[[kk]]
[09:31:18.338]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.338]                     next
[09:31:18.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.338]                 }
[09:31:18.338]                 if (length(args) > 0) 
[09:31:18.338]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.338]             }
[09:31:18.338]             else {
[09:31:18.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.338]             }
[09:31:18.338]             {
[09:31:18.338]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.338]                   0L) {
[09:31:18.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.338]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.338]                   base::options(opts)
[09:31:18.338]                 }
[09:31:18.338]                 {
[09:31:18.338]                   {
[09:31:18.338]                     NULL
[09:31:18.338]                     RNGkind("Mersenne-Twister")
[09:31:18.338]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.338]                       inherits = FALSE)
[09:31:18.338]                   }
[09:31:18.338]                   options(future.plan = NULL)
[09:31:18.338]                   if (is.na(NA_character_)) 
[09:31:18.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.338]                     .init = FALSE)
[09:31:18.338]                 }
[09:31:18.338]             }
[09:31:18.338]         }
[09:31:18.338]     })
[09:31:18.338]     if (TRUE) {
[09:31:18.338]         base::sink(type = "output", split = FALSE)
[09:31:18.338]         if (TRUE) {
[09:31:18.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.338]         }
[09:31:18.338]         else {
[09:31:18.338]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.338]         }
[09:31:18.338]         base::close(...future.stdout)
[09:31:18.338]         ...future.stdout <- NULL
[09:31:18.338]     }
[09:31:18.338]     ...future.result$conditions <- ...future.conditions
[09:31:18.338]     ...future.result$finished <- base::Sys.time()
[09:31:18.338]     ...future.result
[09:31:18.338] }
[09:31:18.340] assign_globals() ...
[09:31:18.340] List of 2
[09:31:18.340]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.340]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.340]  - attr(*, "where")=List of 2
[09:31:18.340]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.340]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.340]  - attr(*, "resolved")= logi FALSE
[09:31:18.340]  - attr(*, "total_size")= num 896
[09:31:18.340]  - attr(*, "already-done")= logi TRUE
[09:31:18.343] - copied ‘weight’ to environment
[09:31:18.343] - copied ‘group’ to environment
[09:31:18.343] assign_globals() ... done
[09:31:18.343] plan(): Setting new future strategy stack:
[09:31:18.343] List of future strategies:
[09:31:18.343] 1. sequential:
[09:31:18.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.343]    - tweaked: FALSE
[09:31:18.343]    - call: NULL
[09:31:18.344] plan(): nbrOfWorkers() = 1
[09:31:18.345] plan(): Setting new future strategy stack:
[09:31:18.345] List of future strategies:
[09:31:18.345] 1. sequential:
[09:31:18.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.345]    - tweaked: FALSE
[09:31:18.345]    - call: plan(strategy)
[09:31:18.346] plan(): nbrOfWorkers() = 1
[09:31:18.346] SequentialFuture started (and completed)
[09:31:18.346] - Launch lazy future ... done
[09:31:18.346] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[09:31:18.348] getGlobalsAndPackages() ...
[09:31:18.348] Searching for globals...
[09:31:18.349] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[09:31:18.349] Searching for globals ... DONE
[09:31:18.349] Resolving globals: FALSE
[09:31:18.349] The total size of the 1 globals is 96 bytes (96 bytes)
[09:31:18.350] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[09:31:18.350] - globals: [1] ‘x’
[09:31:18.350] - packages: [1] ‘stats’
[09:31:18.350] getGlobalsAndPackages() ... DONE
[09:31:18.350] run() for ‘Future’ ...
[09:31:18.350] - state: ‘created’
[09:31:18.350] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.351] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.351] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.351]   - Field: ‘label’
[09:31:18.351]   - Field: ‘local’
[09:31:18.351]   - Field: ‘owner’
[09:31:18.351]   - Field: ‘envir’
[09:31:18.351]   - Field: ‘packages’
[09:31:18.351]   - Field: ‘gc’
[09:31:18.351]   - Field: ‘conditions’
[09:31:18.351]   - Field: ‘expr’
[09:31:18.351]   - Field: ‘uuid’
[09:31:18.352]   - Field: ‘seed’
[09:31:18.352]   - Field: ‘version’
[09:31:18.352]   - Field: ‘result’
[09:31:18.352]   - Field: ‘asynchronous’
[09:31:18.352]   - Field: ‘calls’
[09:31:18.352]   - Field: ‘globals’
[09:31:18.352]   - Field: ‘stdout’
[09:31:18.352]   - Field: ‘earlySignal’
[09:31:18.352]   - Field: ‘lazy’
[09:31:18.352]   - Field: ‘state’
[09:31:18.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.353] - Launch lazy future ...
[09:31:18.353] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.353] Packages needed by future strategies (n = 0): <none>
[09:31:18.353] {
[09:31:18.353]     {
[09:31:18.353]         {
[09:31:18.353]             ...future.startTime <- base::Sys.time()
[09:31:18.353]             {
[09:31:18.353]                 {
[09:31:18.353]                   {
[09:31:18.353]                     {
[09:31:18.353]                       base::local({
[09:31:18.353]                         has_future <- base::requireNamespace("future", 
[09:31:18.353]                           quietly = TRUE)
[09:31:18.353]                         if (has_future) {
[09:31:18.353]                           ns <- base::getNamespace("future")
[09:31:18.353]                           version <- ns[[".package"]][["version"]]
[09:31:18.353]                           if (is.null(version)) 
[09:31:18.353]                             version <- utils::packageVersion("future")
[09:31:18.353]                         }
[09:31:18.353]                         else {
[09:31:18.353]                           version <- NULL
[09:31:18.353]                         }
[09:31:18.353]                         if (!has_future || version < "1.8.0") {
[09:31:18.353]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.353]                             "", base::R.version$version.string), 
[09:31:18.353]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.353]                               "release", "version")], collapse = " "), 
[09:31:18.353]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.353]                             info)
[09:31:18.353]                           info <- base::paste(info, collapse = "; ")
[09:31:18.353]                           if (!has_future) {
[09:31:18.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.353]                               info)
[09:31:18.353]                           }
[09:31:18.353]                           else {
[09:31:18.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.353]                               info, version)
[09:31:18.353]                           }
[09:31:18.353]                           base::stop(msg)
[09:31:18.353]                         }
[09:31:18.353]                       })
[09:31:18.353]                     }
[09:31:18.353]                     base::local({
[09:31:18.353]                       for (pkg in "stats") {
[09:31:18.353]                         base::loadNamespace(pkg)
[09:31:18.353]                         base::library(pkg, character.only = TRUE)
[09:31:18.353]                       }
[09:31:18.353]                     })
[09:31:18.353]                   }
[09:31:18.353]                   ...future.strategy.old <- future::plan("list")
[09:31:18.353]                   options(future.plan = NULL)
[09:31:18.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.353]                 }
[09:31:18.353]                 ...future.workdir <- getwd()
[09:31:18.353]             }
[09:31:18.353]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.353]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.353]         }
[09:31:18.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.353]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.353]             base::names(...future.oldOptions))
[09:31:18.353]     }
[09:31:18.353]     if (FALSE) {
[09:31:18.353]     }
[09:31:18.353]     else {
[09:31:18.353]         if (TRUE) {
[09:31:18.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.353]                 open = "w")
[09:31:18.353]         }
[09:31:18.353]         else {
[09:31:18.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.353]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.353]         }
[09:31:18.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.353]             base::sink(type = "output", split = FALSE)
[09:31:18.353]             base::close(...future.stdout)
[09:31:18.353]         }, add = TRUE)
[09:31:18.353]     }
[09:31:18.353]     ...future.frame <- base::sys.nframe()
[09:31:18.353]     ...future.conditions <- base::list()
[09:31:18.353]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.353]     if (FALSE) {
[09:31:18.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.353]     }
[09:31:18.353]     ...future.result <- base::tryCatch({
[09:31:18.353]         base::withCallingHandlers({
[09:31:18.353]             ...future.value <- base::withVisible(base::local({
[09:31:18.353]                 xtabs(~x)
[09:31:18.353]             }))
[09:31:18.353]             future::FutureResult(value = ...future.value$value, 
[09:31:18.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.353]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.353]                     ...future.globalenv.names))
[09:31:18.353]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.353]         }, condition = base::local({
[09:31:18.353]             c <- base::c
[09:31:18.353]             inherits <- base::inherits
[09:31:18.353]             invokeRestart <- base::invokeRestart
[09:31:18.353]             length <- base::length
[09:31:18.353]             list <- base::list
[09:31:18.353]             seq.int <- base::seq.int
[09:31:18.353]             signalCondition <- base::signalCondition
[09:31:18.353]             sys.calls <- base::sys.calls
[09:31:18.353]             `[[` <- base::`[[`
[09:31:18.353]             `+` <- base::`+`
[09:31:18.353]             `<<-` <- base::`<<-`
[09:31:18.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.353]                   3L)]
[09:31:18.353]             }
[09:31:18.353]             function(cond) {
[09:31:18.353]                 is_error <- inherits(cond, "error")
[09:31:18.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.353]                   NULL)
[09:31:18.353]                 if (is_error) {
[09:31:18.353]                   sessionInformation <- function() {
[09:31:18.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.353]                       search = base::search(), system = base::Sys.info())
[09:31:18.353]                   }
[09:31:18.353]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.353]                     cond$call), session = sessionInformation(), 
[09:31:18.353]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.353]                   signalCondition(cond)
[09:31:18.353]                 }
[09:31:18.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.353]                 "immediateCondition"))) {
[09:31:18.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.353]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.353]                   if (TRUE && !signal) {
[09:31:18.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.353]                     {
[09:31:18.353]                       inherits <- base::inherits
[09:31:18.353]                       invokeRestart <- base::invokeRestart
[09:31:18.353]                       is.null <- base::is.null
[09:31:18.353]                       muffled <- FALSE
[09:31:18.353]                       if (inherits(cond, "message")) {
[09:31:18.353]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.353]                         if (muffled) 
[09:31:18.353]                           invokeRestart("muffleMessage")
[09:31:18.353]                       }
[09:31:18.353]                       else if (inherits(cond, "warning")) {
[09:31:18.353]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.353]                         if (muffled) 
[09:31:18.353]                           invokeRestart("muffleWarning")
[09:31:18.353]                       }
[09:31:18.353]                       else if (inherits(cond, "condition")) {
[09:31:18.353]                         if (!is.null(pattern)) {
[09:31:18.353]                           computeRestarts <- base::computeRestarts
[09:31:18.353]                           grepl <- base::grepl
[09:31:18.353]                           restarts <- computeRestarts(cond)
[09:31:18.353]                           for (restart in restarts) {
[09:31:18.353]                             name <- restart$name
[09:31:18.353]                             if (is.null(name)) 
[09:31:18.353]                               next
[09:31:18.353]                             if (!grepl(pattern, name)) 
[09:31:18.353]                               next
[09:31:18.353]                             invokeRestart(restart)
[09:31:18.353]                             muffled <- TRUE
[09:31:18.353]                             break
[09:31:18.353]                           }
[09:31:18.353]                         }
[09:31:18.353]                       }
[09:31:18.353]                       invisible(muffled)
[09:31:18.353]                     }
[09:31:18.353]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.353]                   }
[09:31:18.353]                 }
[09:31:18.353]                 else {
[09:31:18.353]                   if (TRUE) {
[09:31:18.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.353]                     {
[09:31:18.353]                       inherits <- base::inherits
[09:31:18.353]                       invokeRestart <- base::invokeRestart
[09:31:18.353]                       is.null <- base::is.null
[09:31:18.353]                       muffled <- FALSE
[09:31:18.353]                       if (inherits(cond, "message")) {
[09:31:18.353]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.353]                         if (muffled) 
[09:31:18.353]                           invokeRestart("muffleMessage")
[09:31:18.353]                       }
[09:31:18.353]                       else if (inherits(cond, "warning")) {
[09:31:18.353]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.353]                         if (muffled) 
[09:31:18.353]                           invokeRestart("muffleWarning")
[09:31:18.353]                       }
[09:31:18.353]                       else if (inherits(cond, "condition")) {
[09:31:18.353]                         if (!is.null(pattern)) {
[09:31:18.353]                           computeRestarts <- base::computeRestarts
[09:31:18.353]                           grepl <- base::grepl
[09:31:18.353]                           restarts <- computeRestarts(cond)
[09:31:18.353]                           for (restart in restarts) {
[09:31:18.353]                             name <- restart$name
[09:31:18.353]                             if (is.null(name)) 
[09:31:18.353]                               next
[09:31:18.353]                             if (!grepl(pattern, name)) 
[09:31:18.353]                               next
[09:31:18.353]                             invokeRestart(restart)
[09:31:18.353]                             muffled <- TRUE
[09:31:18.353]                             break
[09:31:18.353]                           }
[09:31:18.353]                         }
[09:31:18.353]                       }
[09:31:18.353]                       invisible(muffled)
[09:31:18.353]                     }
[09:31:18.353]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.353]                   }
[09:31:18.353]                 }
[09:31:18.353]             }
[09:31:18.353]         }))
[09:31:18.353]     }, error = function(ex) {
[09:31:18.353]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.353]                 ...future.rng), started = ...future.startTime, 
[09:31:18.353]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.353]             version = "1.8"), class = "FutureResult")
[09:31:18.353]     }, finally = {
[09:31:18.353]         if (!identical(...future.workdir, getwd())) 
[09:31:18.353]             setwd(...future.workdir)
[09:31:18.353]         {
[09:31:18.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.353]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.353]             }
[09:31:18.353]             base::options(...future.oldOptions)
[09:31:18.353]             if (.Platform$OS.type == "windows") {
[09:31:18.353]                 old_names <- names(...future.oldEnvVars)
[09:31:18.353]                 envs <- base::Sys.getenv()
[09:31:18.353]                 names <- names(envs)
[09:31:18.353]                 common <- intersect(names, old_names)
[09:31:18.353]                 added <- setdiff(names, old_names)
[09:31:18.353]                 removed <- setdiff(old_names, names)
[09:31:18.353]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.353]                   envs[common]]
[09:31:18.353]                 NAMES <- toupper(changed)
[09:31:18.353]                 args <- list()
[09:31:18.353]                 for (kk in seq_along(NAMES)) {
[09:31:18.353]                   name <- changed[[kk]]
[09:31:18.353]                   NAME <- NAMES[[kk]]
[09:31:18.353]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.353]                     next
[09:31:18.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.353]                 }
[09:31:18.353]                 NAMES <- toupper(added)
[09:31:18.353]                 for (kk in seq_along(NAMES)) {
[09:31:18.353]                   name <- added[[kk]]
[09:31:18.353]                   NAME <- NAMES[[kk]]
[09:31:18.353]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.353]                     next
[09:31:18.353]                   args[[name]] <- ""
[09:31:18.353]                 }
[09:31:18.353]                 NAMES <- toupper(removed)
[09:31:18.353]                 for (kk in seq_along(NAMES)) {
[09:31:18.353]                   name <- removed[[kk]]
[09:31:18.353]                   NAME <- NAMES[[kk]]
[09:31:18.353]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.353]                     next
[09:31:18.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.353]                 }
[09:31:18.353]                 if (length(args) > 0) 
[09:31:18.353]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.353]             }
[09:31:18.353]             else {
[09:31:18.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.353]             }
[09:31:18.353]             {
[09:31:18.353]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.353]                   0L) {
[09:31:18.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.353]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.353]                   base::options(opts)
[09:31:18.353]                 }
[09:31:18.353]                 {
[09:31:18.353]                   {
[09:31:18.353]                     NULL
[09:31:18.353]                     RNGkind("Mersenne-Twister")
[09:31:18.353]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.353]                       inherits = FALSE)
[09:31:18.353]                   }
[09:31:18.353]                   options(future.plan = NULL)
[09:31:18.353]                   if (is.na(NA_character_)) 
[09:31:18.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.353]                     .init = FALSE)
[09:31:18.353]                 }
[09:31:18.353]             }
[09:31:18.353]         }
[09:31:18.353]     })
[09:31:18.353]     if (TRUE) {
[09:31:18.353]         base::sink(type = "output", split = FALSE)
[09:31:18.353]         if (TRUE) {
[09:31:18.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.353]         }
[09:31:18.353]         else {
[09:31:18.353]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.353]         }
[09:31:18.353]         base::close(...future.stdout)
[09:31:18.353]         ...future.stdout <- NULL
[09:31:18.353]     }
[09:31:18.353]     ...future.result$conditions <- ...future.conditions
[09:31:18.353]     ...future.result$finished <- base::Sys.time()
[09:31:18.353]     ...future.result
[09:31:18.353] }
[09:31:18.355] assign_globals() ...
[09:31:18.355] List of 1
[09:31:18.355]  $ x: num [1:5] 1 1 2 2 2
[09:31:18.355]  - attr(*, "where")=List of 1
[09:31:18.355]   ..$ x:<environment: R_EmptyEnv> 
[09:31:18.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.355]  - attr(*, "resolved")= logi FALSE
[09:31:18.355]  - attr(*, "total_size")= num 96
[09:31:18.355]  - attr(*, "already-done")= logi TRUE
[09:31:18.357] - copied ‘x’ to environment
[09:31:18.357] assign_globals() ... done
[09:31:18.358] plan(): Setting new future strategy stack:
[09:31:18.358] List of future strategies:
[09:31:18.358] 1. sequential:
[09:31:18.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.358]    - tweaked: FALSE
[09:31:18.358]    - call: NULL
[09:31:18.358] plan(): nbrOfWorkers() = 1
[09:31:18.359] plan(): Setting new future strategy stack:
[09:31:18.359] List of future strategies:
[09:31:18.359] 1. sequential:
[09:31:18.359]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.359]    - tweaked: FALSE
[09:31:18.359]    - call: plan(strategy)
[09:31:18.359] plan(): nbrOfWorkers() = 1
[09:31:18.360] SequentialFuture started (and completed)
[09:31:18.360] - Launch lazy future ... done
[09:31:18.360] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[09:31:18.361] getGlobalsAndPackages() ...
[09:31:18.361] Searching for globals...
[09:31:18.362] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[09:31:18.362] Searching for globals ... DONE
[09:31:18.362] Resolving globals: FALSE
[09:31:18.362] The total size of the 1 globals is 96 bytes (96 bytes)
[09:31:18.362] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[09:31:18.363] - globals: [1] ‘x’
[09:31:18.364] - packages: [1] ‘stats’
[09:31:18.364] getGlobalsAndPackages() ... DONE
[09:31:18.364] run() for ‘Future’ ...
[09:31:18.364] - state: ‘created’
[09:31:18.364] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.364] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.365]   - Field: ‘label’
[09:31:18.365]   - Field: ‘local’
[09:31:18.365]   - Field: ‘owner’
[09:31:18.365]   - Field: ‘envir’
[09:31:18.365]   - Field: ‘packages’
[09:31:18.365]   - Field: ‘gc’
[09:31:18.365]   - Field: ‘conditions’
[09:31:18.365]   - Field: ‘expr’
[09:31:18.365]   - Field: ‘uuid’
[09:31:18.365]   - Field: ‘seed’
[09:31:18.366]   - Field: ‘version’
[09:31:18.366]   - Field: ‘result’
[09:31:18.366]   - Field: ‘asynchronous’
[09:31:18.366]   - Field: ‘calls’
[09:31:18.366]   - Field: ‘globals’
[09:31:18.366]   - Field: ‘stdout’
[09:31:18.366]   - Field: ‘earlySignal’
[09:31:18.366]   - Field: ‘lazy’
[09:31:18.366]   - Field: ‘state’
[09:31:18.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.366] - Launch lazy future ...
[09:31:18.367] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.367] Packages needed by future strategies (n = 0): <none>
[09:31:18.367] {
[09:31:18.367]     {
[09:31:18.367]         {
[09:31:18.367]             ...future.startTime <- base::Sys.time()
[09:31:18.367]             {
[09:31:18.367]                 {
[09:31:18.367]                   {
[09:31:18.367]                     {
[09:31:18.367]                       base::local({
[09:31:18.367]                         has_future <- base::requireNamespace("future", 
[09:31:18.367]                           quietly = TRUE)
[09:31:18.367]                         if (has_future) {
[09:31:18.367]                           ns <- base::getNamespace("future")
[09:31:18.367]                           version <- ns[[".package"]][["version"]]
[09:31:18.367]                           if (is.null(version)) 
[09:31:18.367]                             version <- utils::packageVersion("future")
[09:31:18.367]                         }
[09:31:18.367]                         else {
[09:31:18.367]                           version <- NULL
[09:31:18.367]                         }
[09:31:18.367]                         if (!has_future || version < "1.8.0") {
[09:31:18.367]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.367]                             "", base::R.version$version.string), 
[09:31:18.367]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.367]                               "release", "version")], collapse = " "), 
[09:31:18.367]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.367]                             info)
[09:31:18.367]                           info <- base::paste(info, collapse = "; ")
[09:31:18.367]                           if (!has_future) {
[09:31:18.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.367]                               info)
[09:31:18.367]                           }
[09:31:18.367]                           else {
[09:31:18.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.367]                               info, version)
[09:31:18.367]                           }
[09:31:18.367]                           base::stop(msg)
[09:31:18.367]                         }
[09:31:18.367]                       })
[09:31:18.367]                     }
[09:31:18.367]                     base::local({
[09:31:18.367]                       for (pkg in "stats") {
[09:31:18.367]                         base::loadNamespace(pkg)
[09:31:18.367]                         base::library(pkg, character.only = TRUE)
[09:31:18.367]                       }
[09:31:18.367]                     })
[09:31:18.367]                   }
[09:31:18.367]                   ...future.strategy.old <- future::plan("list")
[09:31:18.367]                   options(future.plan = NULL)
[09:31:18.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.367]                 }
[09:31:18.367]                 ...future.workdir <- getwd()
[09:31:18.367]             }
[09:31:18.367]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.367]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.367]         }
[09:31:18.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.367]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.367]             base::names(...future.oldOptions))
[09:31:18.367]     }
[09:31:18.367]     if (FALSE) {
[09:31:18.367]     }
[09:31:18.367]     else {
[09:31:18.367]         if (TRUE) {
[09:31:18.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.367]                 open = "w")
[09:31:18.367]         }
[09:31:18.367]         else {
[09:31:18.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.367]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.367]         }
[09:31:18.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.367]             base::sink(type = "output", split = FALSE)
[09:31:18.367]             base::close(...future.stdout)
[09:31:18.367]         }, add = TRUE)
[09:31:18.367]     }
[09:31:18.367]     ...future.frame <- base::sys.nframe()
[09:31:18.367]     ...future.conditions <- base::list()
[09:31:18.367]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.367]     if (FALSE) {
[09:31:18.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.367]     }
[09:31:18.367]     ...future.result <- base::tryCatch({
[09:31:18.367]         base::withCallingHandlers({
[09:31:18.367]             ...future.value <- base::withVisible(base::local({
[09:31:18.367]                 xtabs(~x)
[09:31:18.367]             }))
[09:31:18.367]             future::FutureResult(value = ...future.value$value, 
[09:31:18.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.367]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.367]                     ...future.globalenv.names))
[09:31:18.367]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.367]         }, condition = base::local({
[09:31:18.367]             c <- base::c
[09:31:18.367]             inherits <- base::inherits
[09:31:18.367]             invokeRestart <- base::invokeRestart
[09:31:18.367]             length <- base::length
[09:31:18.367]             list <- base::list
[09:31:18.367]             seq.int <- base::seq.int
[09:31:18.367]             signalCondition <- base::signalCondition
[09:31:18.367]             sys.calls <- base::sys.calls
[09:31:18.367]             `[[` <- base::`[[`
[09:31:18.367]             `+` <- base::`+`
[09:31:18.367]             `<<-` <- base::`<<-`
[09:31:18.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.367]                   3L)]
[09:31:18.367]             }
[09:31:18.367]             function(cond) {
[09:31:18.367]                 is_error <- inherits(cond, "error")
[09:31:18.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.367]                   NULL)
[09:31:18.367]                 if (is_error) {
[09:31:18.367]                   sessionInformation <- function() {
[09:31:18.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.367]                       search = base::search(), system = base::Sys.info())
[09:31:18.367]                   }
[09:31:18.367]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.367]                     cond$call), session = sessionInformation(), 
[09:31:18.367]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.367]                   signalCondition(cond)
[09:31:18.367]                 }
[09:31:18.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.367]                 "immediateCondition"))) {
[09:31:18.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.367]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.367]                   if (TRUE && !signal) {
[09:31:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.367]                     {
[09:31:18.367]                       inherits <- base::inherits
[09:31:18.367]                       invokeRestart <- base::invokeRestart
[09:31:18.367]                       is.null <- base::is.null
[09:31:18.367]                       muffled <- FALSE
[09:31:18.367]                       if (inherits(cond, "message")) {
[09:31:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.367]                         if (muffled) 
[09:31:18.367]                           invokeRestart("muffleMessage")
[09:31:18.367]                       }
[09:31:18.367]                       else if (inherits(cond, "warning")) {
[09:31:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.367]                         if (muffled) 
[09:31:18.367]                           invokeRestart("muffleWarning")
[09:31:18.367]                       }
[09:31:18.367]                       else if (inherits(cond, "condition")) {
[09:31:18.367]                         if (!is.null(pattern)) {
[09:31:18.367]                           computeRestarts <- base::computeRestarts
[09:31:18.367]                           grepl <- base::grepl
[09:31:18.367]                           restarts <- computeRestarts(cond)
[09:31:18.367]                           for (restart in restarts) {
[09:31:18.367]                             name <- restart$name
[09:31:18.367]                             if (is.null(name)) 
[09:31:18.367]                               next
[09:31:18.367]                             if (!grepl(pattern, name)) 
[09:31:18.367]                               next
[09:31:18.367]                             invokeRestart(restart)
[09:31:18.367]                             muffled <- TRUE
[09:31:18.367]                             break
[09:31:18.367]                           }
[09:31:18.367]                         }
[09:31:18.367]                       }
[09:31:18.367]                       invisible(muffled)
[09:31:18.367]                     }
[09:31:18.367]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.367]                   }
[09:31:18.367]                 }
[09:31:18.367]                 else {
[09:31:18.367]                   if (TRUE) {
[09:31:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.367]                     {
[09:31:18.367]                       inherits <- base::inherits
[09:31:18.367]                       invokeRestart <- base::invokeRestart
[09:31:18.367]                       is.null <- base::is.null
[09:31:18.367]                       muffled <- FALSE
[09:31:18.367]                       if (inherits(cond, "message")) {
[09:31:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.367]                         if (muffled) 
[09:31:18.367]                           invokeRestart("muffleMessage")
[09:31:18.367]                       }
[09:31:18.367]                       else if (inherits(cond, "warning")) {
[09:31:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.367]                         if (muffled) 
[09:31:18.367]                           invokeRestart("muffleWarning")
[09:31:18.367]                       }
[09:31:18.367]                       else if (inherits(cond, "condition")) {
[09:31:18.367]                         if (!is.null(pattern)) {
[09:31:18.367]                           computeRestarts <- base::computeRestarts
[09:31:18.367]                           grepl <- base::grepl
[09:31:18.367]                           restarts <- computeRestarts(cond)
[09:31:18.367]                           for (restart in restarts) {
[09:31:18.367]                             name <- restart$name
[09:31:18.367]                             if (is.null(name)) 
[09:31:18.367]                               next
[09:31:18.367]                             if (!grepl(pattern, name)) 
[09:31:18.367]                               next
[09:31:18.367]                             invokeRestart(restart)
[09:31:18.367]                             muffled <- TRUE
[09:31:18.367]                             break
[09:31:18.367]                           }
[09:31:18.367]                         }
[09:31:18.367]                       }
[09:31:18.367]                       invisible(muffled)
[09:31:18.367]                     }
[09:31:18.367]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.367]                   }
[09:31:18.367]                 }
[09:31:18.367]             }
[09:31:18.367]         }))
[09:31:18.367]     }, error = function(ex) {
[09:31:18.367]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.367]                 ...future.rng), started = ...future.startTime, 
[09:31:18.367]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.367]             version = "1.8"), class = "FutureResult")
[09:31:18.367]     }, finally = {
[09:31:18.367]         if (!identical(...future.workdir, getwd())) 
[09:31:18.367]             setwd(...future.workdir)
[09:31:18.367]         {
[09:31:18.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.367]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.367]             }
[09:31:18.367]             base::options(...future.oldOptions)
[09:31:18.367]             if (.Platform$OS.type == "windows") {
[09:31:18.367]                 old_names <- names(...future.oldEnvVars)
[09:31:18.367]                 envs <- base::Sys.getenv()
[09:31:18.367]                 names <- names(envs)
[09:31:18.367]                 common <- intersect(names, old_names)
[09:31:18.367]                 added <- setdiff(names, old_names)
[09:31:18.367]                 removed <- setdiff(old_names, names)
[09:31:18.367]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.367]                   envs[common]]
[09:31:18.367]                 NAMES <- toupper(changed)
[09:31:18.367]                 args <- list()
[09:31:18.367]                 for (kk in seq_along(NAMES)) {
[09:31:18.367]                   name <- changed[[kk]]
[09:31:18.367]                   NAME <- NAMES[[kk]]
[09:31:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.367]                     next
[09:31:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.367]                 }
[09:31:18.367]                 NAMES <- toupper(added)
[09:31:18.367]                 for (kk in seq_along(NAMES)) {
[09:31:18.367]                   name <- added[[kk]]
[09:31:18.367]                   NAME <- NAMES[[kk]]
[09:31:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.367]                     next
[09:31:18.367]                   args[[name]] <- ""
[09:31:18.367]                 }
[09:31:18.367]                 NAMES <- toupper(removed)
[09:31:18.367]                 for (kk in seq_along(NAMES)) {
[09:31:18.367]                   name <- removed[[kk]]
[09:31:18.367]                   NAME <- NAMES[[kk]]
[09:31:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.367]                     next
[09:31:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.367]                 }
[09:31:18.367]                 if (length(args) > 0) 
[09:31:18.367]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.367]             }
[09:31:18.367]             else {
[09:31:18.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.367]             }
[09:31:18.367]             {
[09:31:18.367]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.367]                   0L) {
[09:31:18.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.367]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.367]                   base::options(opts)
[09:31:18.367]                 }
[09:31:18.367]                 {
[09:31:18.367]                   {
[09:31:18.367]                     NULL
[09:31:18.367]                     RNGkind("Mersenne-Twister")
[09:31:18.367]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.367]                       inherits = FALSE)
[09:31:18.367]                   }
[09:31:18.367]                   options(future.plan = NULL)
[09:31:18.367]                   if (is.na(NA_character_)) 
[09:31:18.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.367]                     .init = FALSE)
[09:31:18.367]                 }
[09:31:18.367]             }
[09:31:18.367]         }
[09:31:18.367]     })
[09:31:18.367]     if (TRUE) {
[09:31:18.367]         base::sink(type = "output", split = FALSE)
[09:31:18.367]         if (TRUE) {
[09:31:18.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.367]         }
[09:31:18.367]         else {
[09:31:18.367]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.367]         }
[09:31:18.367]         base::close(...future.stdout)
[09:31:18.367]         ...future.stdout <- NULL
[09:31:18.367]     }
[09:31:18.367]     ...future.result$conditions <- ...future.conditions
[09:31:18.367]     ...future.result$finished <- base::Sys.time()
[09:31:18.367]     ...future.result
[09:31:18.367] }
[09:31:18.369] assign_globals() ...
[09:31:18.369] List of 1
[09:31:18.369]  $ x: num [1:5] 1 1 2 2 2
[09:31:18.369]  - attr(*, "where")=List of 1
[09:31:18.369]   ..$ x:<environment: R_EmptyEnv> 
[09:31:18.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.369]  - attr(*, "resolved")= logi FALSE
[09:31:18.369]  - attr(*, "total_size")= num 96
[09:31:18.369]  - attr(*, "already-done")= logi TRUE
[09:31:18.371] - copied ‘x’ to environment
[09:31:18.371] assign_globals() ... done
[09:31:18.371] plan(): Setting new future strategy stack:
[09:31:18.371] List of future strategies:
[09:31:18.371] 1. sequential:
[09:31:18.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.371]    - tweaked: FALSE
[09:31:18.371]    - call: NULL
[09:31:18.372] plan(): nbrOfWorkers() = 1
[09:31:18.373] plan(): Setting new future strategy stack:
[09:31:18.373] List of future strategies:
[09:31:18.373] 1. sequential:
[09:31:18.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.373]    - tweaked: FALSE
[09:31:18.373]    - call: plan(strategy)
[09:31:18.373] plan(): nbrOfWorkers() = 1
[09:31:18.373] SequentialFuture started (and completed)
[09:31:18.374] - Launch lazy future ... done
[09:31:18.374] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[09:31:18.375] getGlobalsAndPackages() ...
[09:31:18.375] Searching for globals...
[09:31:18.377] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[09:31:18.377] Searching for globals ... DONE
[09:31:18.377] Resolving globals: FALSE
[09:31:18.377] 
[09:31:18.378] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.378] getGlobalsAndPackages() ... DONE
[09:31:18.378] run() for ‘Future’ ...
[09:31:18.378] - state: ‘created’
[09:31:18.378] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.378] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.379]   - Field: ‘label’
[09:31:18.379]   - Field: ‘local’
[09:31:18.379]   - Field: ‘owner’
[09:31:18.379]   - Field: ‘envir’
[09:31:18.379]   - Field: ‘packages’
[09:31:18.379]   - Field: ‘gc’
[09:31:18.379]   - Field: ‘conditions’
[09:31:18.379]   - Field: ‘expr’
[09:31:18.379]   - Field: ‘uuid’
[09:31:18.379]   - Field: ‘seed’
[09:31:18.379]   - Field: ‘version’
[09:31:18.379]   - Field: ‘result’
[09:31:18.380]   - Field: ‘asynchronous’
[09:31:18.380]   - Field: ‘calls’
[09:31:18.380]   - Field: ‘globals’
[09:31:18.380]   - Field: ‘stdout’
[09:31:18.380]   - Field: ‘earlySignal’
[09:31:18.380]   - Field: ‘lazy’
[09:31:18.380]   - Field: ‘state’
[09:31:18.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.380] - Launch lazy future ...
[09:31:18.380] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.381] Packages needed by future strategies (n = 0): <none>
[09:31:18.381] {
[09:31:18.381]     {
[09:31:18.381]         {
[09:31:18.381]             ...future.startTime <- base::Sys.time()
[09:31:18.381]             {
[09:31:18.381]                 {
[09:31:18.381]                   {
[09:31:18.381]                     {
[09:31:18.381]                       base::local({
[09:31:18.381]                         has_future <- base::requireNamespace("future", 
[09:31:18.381]                           quietly = TRUE)
[09:31:18.381]                         if (has_future) {
[09:31:18.381]                           ns <- base::getNamespace("future")
[09:31:18.381]                           version <- ns[[".package"]][["version"]]
[09:31:18.381]                           if (is.null(version)) 
[09:31:18.381]                             version <- utils::packageVersion("future")
[09:31:18.381]                         }
[09:31:18.381]                         else {
[09:31:18.381]                           version <- NULL
[09:31:18.381]                         }
[09:31:18.381]                         if (!has_future || version < "1.8.0") {
[09:31:18.381]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.381]                             "", base::R.version$version.string), 
[09:31:18.381]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.381]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.381]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.381]                               "release", "version")], collapse = " "), 
[09:31:18.381]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.381]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.381]                             info)
[09:31:18.381]                           info <- base::paste(info, collapse = "; ")
[09:31:18.381]                           if (!has_future) {
[09:31:18.381]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.381]                               info)
[09:31:18.381]                           }
[09:31:18.381]                           else {
[09:31:18.381]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.381]                               info, version)
[09:31:18.381]                           }
[09:31:18.381]                           base::stop(msg)
[09:31:18.381]                         }
[09:31:18.381]                       })
[09:31:18.381]                     }
[09:31:18.381]                     base::local({
[09:31:18.381]                       for (pkg in c("stats", "datasets")) {
[09:31:18.381]                         base::loadNamespace(pkg)
[09:31:18.381]                         base::library(pkg, character.only = TRUE)
[09:31:18.381]                       }
[09:31:18.381]                     })
[09:31:18.381]                   }
[09:31:18.381]                   ...future.strategy.old <- future::plan("list")
[09:31:18.381]                   options(future.plan = NULL)
[09:31:18.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.381]                 }
[09:31:18.381]                 ...future.workdir <- getwd()
[09:31:18.381]             }
[09:31:18.381]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.381]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.381]         }
[09:31:18.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.381]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.381]             base::names(...future.oldOptions))
[09:31:18.381]     }
[09:31:18.381]     if (FALSE) {
[09:31:18.381]     }
[09:31:18.381]     else {
[09:31:18.381]         if (TRUE) {
[09:31:18.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.381]                 open = "w")
[09:31:18.381]         }
[09:31:18.381]         else {
[09:31:18.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.381]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.381]         }
[09:31:18.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.381]             base::sink(type = "output", split = FALSE)
[09:31:18.381]             base::close(...future.stdout)
[09:31:18.381]         }, add = TRUE)
[09:31:18.381]     }
[09:31:18.381]     ...future.frame <- base::sys.nframe()
[09:31:18.381]     ...future.conditions <- base::list()
[09:31:18.381]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.381]     if (FALSE) {
[09:31:18.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.381]     }
[09:31:18.381]     ...future.result <- base::tryCatch({
[09:31:18.381]         base::withCallingHandlers({
[09:31:18.381]             ...future.value <- base::withVisible(base::local({
[09:31:18.381]                 lm(dist ~ . - 1, data = cars)
[09:31:18.381]             }))
[09:31:18.381]             future::FutureResult(value = ...future.value$value, 
[09:31:18.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.381]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.381]                     ...future.globalenv.names))
[09:31:18.381]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.381]         }, condition = base::local({
[09:31:18.381]             c <- base::c
[09:31:18.381]             inherits <- base::inherits
[09:31:18.381]             invokeRestart <- base::invokeRestart
[09:31:18.381]             length <- base::length
[09:31:18.381]             list <- base::list
[09:31:18.381]             seq.int <- base::seq.int
[09:31:18.381]             signalCondition <- base::signalCondition
[09:31:18.381]             sys.calls <- base::sys.calls
[09:31:18.381]             `[[` <- base::`[[`
[09:31:18.381]             `+` <- base::`+`
[09:31:18.381]             `<<-` <- base::`<<-`
[09:31:18.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.381]                   3L)]
[09:31:18.381]             }
[09:31:18.381]             function(cond) {
[09:31:18.381]                 is_error <- inherits(cond, "error")
[09:31:18.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.381]                   NULL)
[09:31:18.381]                 if (is_error) {
[09:31:18.381]                   sessionInformation <- function() {
[09:31:18.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.381]                       search = base::search(), system = base::Sys.info())
[09:31:18.381]                   }
[09:31:18.381]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.381]                     cond$call), session = sessionInformation(), 
[09:31:18.381]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.381]                   signalCondition(cond)
[09:31:18.381]                 }
[09:31:18.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.381]                 "immediateCondition"))) {
[09:31:18.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.381]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.381]                   if (TRUE && !signal) {
[09:31:18.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.381]                     {
[09:31:18.381]                       inherits <- base::inherits
[09:31:18.381]                       invokeRestart <- base::invokeRestart
[09:31:18.381]                       is.null <- base::is.null
[09:31:18.381]                       muffled <- FALSE
[09:31:18.381]                       if (inherits(cond, "message")) {
[09:31:18.381]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.381]                         if (muffled) 
[09:31:18.381]                           invokeRestart("muffleMessage")
[09:31:18.381]                       }
[09:31:18.381]                       else if (inherits(cond, "warning")) {
[09:31:18.381]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.381]                         if (muffled) 
[09:31:18.381]                           invokeRestart("muffleWarning")
[09:31:18.381]                       }
[09:31:18.381]                       else if (inherits(cond, "condition")) {
[09:31:18.381]                         if (!is.null(pattern)) {
[09:31:18.381]                           computeRestarts <- base::computeRestarts
[09:31:18.381]                           grepl <- base::grepl
[09:31:18.381]                           restarts <- computeRestarts(cond)
[09:31:18.381]                           for (restart in restarts) {
[09:31:18.381]                             name <- restart$name
[09:31:18.381]                             if (is.null(name)) 
[09:31:18.381]                               next
[09:31:18.381]                             if (!grepl(pattern, name)) 
[09:31:18.381]                               next
[09:31:18.381]                             invokeRestart(restart)
[09:31:18.381]                             muffled <- TRUE
[09:31:18.381]                             break
[09:31:18.381]                           }
[09:31:18.381]                         }
[09:31:18.381]                       }
[09:31:18.381]                       invisible(muffled)
[09:31:18.381]                     }
[09:31:18.381]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.381]                   }
[09:31:18.381]                 }
[09:31:18.381]                 else {
[09:31:18.381]                   if (TRUE) {
[09:31:18.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.381]                     {
[09:31:18.381]                       inherits <- base::inherits
[09:31:18.381]                       invokeRestart <- base::invokeRestart
[09:31:18.381]                       is.null <- base::is.null
[09:31:18.381]                       muffled <- FALSE
[09:31:18.381]                       if (inherits(cond, "message")) {
[09:31:18.381]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.381]                         if (muffled) 
[09:31:18.381]                           invokeRestart("muffleMessage")
[09:31:18.381]                       }
[09:31:18.381]                       else if (inherits(cond, "warning")) {
[09:31:18.381]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.381]                         if (muffled) 
[09:31:18.381]                           invokeRestart("muffleWarning")
[09:31:18.381]                       }
[09:31:18.381]                       else if (inherits(cond, "condition")) {
[09:31:18.381]                         if (!is.null(pattern)) {
[09:31:18.381]                           computeRestarts <- base::computeRestarts
[09:31:18.381]                           grepl <- base::grepl
[09:31:18.381]                           restarts <- computeRestarts(cond)
[09:31:18.381]                           for (restart in restarts) {
[09:31:18.381]                             name <- restart$name
[09:31:18.381]                             if (is.null(name)) 
[09:31:18.381]                               next
[09:31:18.381]                             if (!grepl(pattern, name)) 
[09:31:18.381]                               next
[09:31:18.381]                             invokeRestart(restart)
[09:31:18.381]                             muffled <- TRUE
[09:31:18.381]                             break
[09:31:18.381]                           }
[09:31:18.381]                         }
[09:31:18.381]                       }
[09:31:18.381]                       invisible(muffled)
[09:31:18.381]                     }
[09:31:18.381]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.381]                   }
[09:31:18.381]                 }
[09:31:18.381]             }
[09:31:18.381]         }))
[09:31:18.381]     }, error = function(ex) {
[09:31:18.381]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.381]                 ...future.rng), started = ...future.startTime, 
[09:31:18.381]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.381]             version = "1.8"), class = "FutureResult")
[09:31:18.381]     }, finally = {
[09:31:18.381]         if (!identical(...future.workdir, getwd())) 
[09:31:18.381]             setwd(...future.workdir)
[09:31:18.381]         {
[09:31:18.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.381]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.381]             }
[09:31:18.381]             base::options(...future.oldOptions)
[09:31:18.381]             if (.Platform$OS.type == "windows") {
[09:31:18.381]                 old_names <- names(...future.oldEnvVars)
[09:31:18.381]                 envs <- base::Sys.getenv()
[09:31:18.381]                 names <- names(envs)
[09:31:18.381]                 common <- intersect(names, old_names)
[09:31:18.381]                 added <- setdiff(names, old_names)
[09:31:18.381]                 removed <- setdiff(old_names, names)
[09:31:18.381]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.381]                   envs[common]]
[09:31:18.381]                 NAMES <- toupper(changed)
[09:31:18.381]                 args <- list()
[09:31:18.381]                 for (kk in seq_along(NAMES)) {
[09:31:18.381]                   name <- changed[[kk]]
[09:31:18.381]                   NAME <- NAMES[[kk]]
[09:31:18.381]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.381]                     next
[09:31:18.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.381]                 }
[09:31:18.381]                 NAMES <- toupper(added)
[09:31:18.381]                 for (kk in seq_along(NAMES)) {
[09:31:18.381]                   name <- added[[kk]]
[09:31:18.381]                   NAME <- NAMES[[kk]]
[09:31:18.381]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.381]                     next
[09:31:18.381]                   args[[name]] <- ""
[09:31:18.381]                 }
[09:31:18.381]                 NAMES <- toupper(removed)
[09:31:18.381]                 for (kk in seq_along(NAMES)) {
[09:31:18.381]                   name <- removed[[kk]]
[09:31:18.381]                   NAME <- NAMES[[kk]]
[09:31:18.381]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.381]                     next
[09:31:18.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.381]                 }
[09:31:18.381]                 if (length(args) > 0) 
[09:31:18.381]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.381]             }
[09:31:18.381]             else {
[09:31:18.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.381]             }
[09:31:18.381]             {
[09:31:18.381]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.381]                   0L) {
[09:31:18.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.381]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.381]                   base::options(opts)
[09:31:18.381]                 }
[09:31:18.381]                 {
[09:31:18.381]                   {
[09:31:18.381]                     NULL
[09:31:18.381]                     RNGkind("Mersenne-Twister")
[09:31:18.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.381]                       inherits = FALSE)
[09:31:18.381]                   }
[09:31:18.381]                   options(future.plan = NULL)
[09:31:18.381]                   if (is.na(NA_character_)) 
[09:31:18.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.381]                     .init = FALSE)
[09:31:18.381]                 }
[09:31:18.381]             }
[09:31:18.381]         }
[09:31:18.381]     })
[09:31:18.381]     if (TRUE) {
[09:31:18.381]         base::sink(type = "output", split = FALSE)
[09:31:18.381]         if (TRUE) {
[09:31:18.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.381]         }
[09:31:18.381]         else {
[09:31:18.381]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.381]         }
[09:31:18.381]         base::close(...future.stdout)
[09:31:18.381]         ...future.stdout <- NULL
[09:31:18.381]     }
[09:31:18.381]     ...future.result$conditions <- ...future.conditions
[09:31:18.381]     ...future.result$finished <- base::Sys.time()
[09:31:18.381]     ...future.result
[09:31:18.381] }
[09:31:18.383] plan(): Setting new future strategy stack:
[09:31:18.383] List of future strategies:
[09:31:18.383] 1. sequential:
[09:31:18.383]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.383]    - tweaked: FALSE
[09:31:18.383]    - call: NULL
[09:31:18.383] plan(): nbrOfWorkers() = 1
[09:31:18.384] plan(): Setting new future strategy stack:
[09:31:18.385] List of future strategies:
[09:31:18.385] 1. sequential:
[09:31:18.385]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.385]    - tweaked: FALSE
[09:31:18.385]    - call: plan(strategy)
[09:31:18.385] plan(): nbrOfWorkers() = 1
[09:31:18.385] SequentialFuture started (and completed)
[09:31:18.385] - Launch lazy future ... done
[09:31:18.385] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[09:31:18.387] getGlobalsAndPackages() ...
[09:31:18.388] Searching for globals...
[09:31:18.390] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[09:31:18.390] Searching for globals ... DONE
[09:31:18.390] Resolving globals: FALSE
[09:31:18.390] 
[09:31:18.391] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.391] getGlobalsAndPackages() ... DONE
[09:31:18.391] run() for ‘Future’ ...
[09:31:18.391] - state: ‘created’
[09:31:18.391] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.391] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.392]   - Field: ‘label’
[09:31:18.392]   - Field: ‘local’
[09:31:18.392]   - Field: ‘owner’
[09:31:18.392]   - Field: ‘envir’
[09:31:18.392]   - Field: ‘packages’
[09:31:18.392]   - Field: ‘gc’
[09:31:18.392]   - Field: ‘conditions’
[09:31:18.392]   - Field: ‘expr’
[09:31:18.392]   - Field: ‘uuid’
[09:31:18.392]   - Field: ‘seed’
[09:31:18.392]   - Field: ‘version’
[09:31:18.393]   - Field: ‘result’
[09:31:18.393]   - Field: ‘asynchronous’
[09:31:18.393]   - Field: ‘calls’
[09:31:18.393]   - Field: ‘globals’
[09:31:18.393]   - Field: ‘stdout’
[09:31:18.393]   - Field: ‘earlySignal’
[09:31:18.393]   - Field: ‘lazy’
[09:31:18.393]   - Field: ‘state’
[09:31:18.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.393] - Launch lazy future ...
[09:31:18.393] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.394] Packages needed by future strategies (n = 0): <none>
[09:31:18.394] {
[09:31:18.394]     {
[09:31:18.394]         {
[09:31:18.394]             ...future.startTime <- base::Sys.time()
[09:31:18.394]             {
[09:31:18.394]                 {
[09:31:18.394]                   {
[09:31:18.394]                     {
[09:31:18.394]                       base::local({
[09:31:18.394]                         has_future <- base::requireNamespace("future", 
[09:31:18.394]                           quietly = TRUE)
[09:31:18.394]                         if (has_future) {
[09:31:18.394]                           ns <- base::getNamespace("future")
[09:31:18.394]                           version <- ns[[".package"]][["version"]]
[09:31:18.394]                           if (is.null(version)) 
[09:31:18.394]                             version <- utils::packageVersion("future")
[09:31:18.394]                         }
[09:31:18.394]                         else {
[09:31:18.394]                           version <- NULL
[09:31:18.394]                         }
[09:31:18.394]                         if (!has_future || version < "1.8.0") {
[09:31:18.394]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.394]                             "", base::R.version$version.string), 
[09:31:18.394]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.394]                               "release", "version")], collapse = " "), 
[09:31:18.394]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.394]                             info)
[09:31:18.394]                           info <- base::paste(info, collapse = "; ")
[09:31:18.394]                           if (!has_future) {
[09:31:18.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.394]                               info)
[09:31:18.394]                           }
[09:31:18.394]                           else {
[09:31:18.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.394]                               info, version)
[09:31:18.394]                           }
[09:31:18.394]                           base::stop(msg)
[09:31:18.394]                         }
[09:31:18.394]                       })
[09:31:18.394]                     }
[09:31:18.394]                     base::local({
[09:31:18.394]                       for (pkg in c("stats", "datasets")) {
[09:31:18.394]                         base::loadNamespace(pkg)
[09:31:18.394]                         base::library(pkg, character.only = TRUE)
[09:31:18.394]                       }
[09:31:18.394]                     })
[09:31:18.394]                   }
[09:31:18.394]                   ...future.strategy.old <- future::plan("list")
[09:31:18.394]                   options(future.plan = NULL)
[09:31:18.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.394]                 }
[09:31:18.394]                 ...future.workdir <- getwd()
[09:31:18.394]             }
[09:31:18.394]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.394]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.394]         }
[09:31:18.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.394]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.394]             base::names(...future.oldOptions))
[09:31:18.394]     }
[09:31:18.394]     if (FALSE) {
[09:31:18.394]     }
[09:31:18.394]     else {
[09:31:18.394]         if (TRUE) {
[09:31:18.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.394]                 open = "w")
[09:31:18.394]         }
[09:31:18.394]         else {
[09:31:18.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.394]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.394]         }
[09:31:18.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.394]             base::sink(type = "output", split = FALSE)
[09:31:18.394]             base::close(...future.stdout)
[09:31:18.394]         }, add = TRUE)
[09:31:18.394]     }
[09:31:18.394]     ...future.frame <- base::sys.nframe()
[09:31:18.394]     ...future.conditions <- base::list()
[09:31:18.394]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.394]     if (FALSE) {
[09:31:18.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.394]     }
[09:31:18.394]     ...future.result <- base::tryCatch({
[09:31:18.394]         base::withCallingHandlers({
[09:31:18.394]             ...future.value <- base::withVisible(base::local({
[09:31:18.394]                 lm(dist ~ . + 0, data = cars)
[09:31:18.394]             }))
[09:31:18.394]             future::FutureResult(value = ...future.value$value, 
[09:31:18.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.394]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.394]                     ...future.globalenv.names))
[09:31:18.394]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.394]         }, condition = base::local({
[09:31:18.394]             c <- base::c
[09:31:18.394]             inherits <- base::inherits
[09:31:18.394]             invokeRestart <- base::invokeRestart
[09:31:18.394]             length <- base::length
[09:31:18.394]             list <- base::list
[09:31:18.394]             seq.int <- base::seq.int
[09:31:18.394]             signalCondition <- base::signalCondition
[09:31:18.394]             sys.calls <- base::sys.calls
[09:31:18.394]             `[[` <- base::`[[`
[09:31:18.394]             `+` <- base::`+`
[09:31:18.394]             `<<-` <- base::`<<-`
[09:31:18.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.394]                   3L)]
[09:31:18.394]             }
[09:31:18.394]             function(cond) {
[09:31:18.394]                 is_error <- inherits(cond, "error")
[09:31:18.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.394]                   NULL)
[09:31:18.394]                 if (is_error) {
[09:31:18.394]                   sessionInformation <- function() {
[09:31:18.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.394]                       search = base::search(), system = base::Sys.info())
[09:31:18.394]                   }
[09:31:18.394]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.394]                     cond$call), session = sessionInformation(), 
[09:31:18.394]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.394]                   signalCondition(cond)
[09:31:18.394]                 }
[09:31:18.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.394]                 "immediateCondition"))) {
[09:31:18.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.394]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.394]                   if (TRUE && !signal) {
[09:31:18.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.394]                     {
[09:31:18.394]                       inherits <- base::inherits
[09:31:18.394]                       invokeRestart <- base::invokeRestart
[09:31:18.394]                       is.null <- base::is.null
[09:31:18.394]                       muffled <- FALSE
[09:31:18.394]                       if (inherits(cond, "message")) {
[09:31:18.394]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.394]                         if (muffled) 
[09:31:18.394]                           invokeRestart("muffleMessage")
[09:31:18.394]                       }
[09:31:18.394]                       else if (inherits(cond, "warning")) {
[09:31:18.394]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.394]                         if (muffled) 
[09:31:18.394]                           invokeRestart("muffleWarning")
[09:31:18.394]                       }
[09:31:18.394]                       else if (inherits(cond, "condition")) {
[09:31:18.394]                         if (!is.null(pattern)) {
[09:31:18.394]                           computeRestarts <- base::computeRestarts
[09:31:18.394]                           grepl <- base::grepl
[09:31:18.394]                           restarts <- computeRestarts(cond)
[09:31:18.394]                           for (restart in restarts) {
[09:31:18.394]                             name <- restart$name
[09:31:18.394]                             if (is.null(name)) 
[09:31:18.394]                               next
[09:31:18.394]                             if (!grepl(pattern, name)) 
[09:31:18.394]                               next
[09:31:18.394]                             invokeRestart(restart)
[09:31:18.394]                             muffled <- TRUE
[09:31:18.394]                             break
[09:31:18.394]                           }
[09:31:18.394]                         }
[09:31:18.394]                       }
[09:31:18.394]                       invisible(muffled)
[09:31:18.394]                     }
[09:31:18.394]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.394]                   }
[09:31:18.394]                 }
[09:31:18.394]                 else {
[09:31:18.394]                   if (TRUE) {
[09:31:18.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.394]                     {
[09:31:18.394]                       inherits <- base::inherits
[09:31:18.394]                       invokeRestart <- base::invokeRestart
[09:31:18.394]                       is.null <- base::is.null
[09:31:18.394]                       muffled <- FALSE
[09:31:18.394]                       if (inherits(cond, "message")) {
[09:31:18.394]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.394]                         if (muffled) 
[09:31:18.394]                           invokeRestart("muffleMessage")
[09:31:18.394]                       }
[09:31:18.394]                       else if (inherits(cond, "warning")) {
[09:31:18.394]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.394]                         if (muffled) 
[09:31:18.394]                           invokeRestart("muffleWarning")
[09:31:18.394]                       }
[09:31:18.394]                       else if (inherits(cond, "condition")) {
[09:31:18.394]                         if (!is.null(pattern)) {
[09:31:18.394]                           computeRestarts <- base::computeRestarts
[09:31:18.394]                           grepl <- base::grepl
[09:31:18.394]                           restarts <- computeRestarts(cond)
[09:31:18.394]                           for (restart in restarts) {
[09:31:18.394]                             name <- restart$name
[09:31:18.394]                             if (is.null(name)) 
[09:31:18.394]                               next
[09:31:18.394]                             if (!grepl(pattern, name)) 
[09:31:18.394]                               next
[09:31:18.394]                             invokeRestart(restart)
[09:31:18.394]                             muffled <- TRUE
[09:31:18.394]                             break
[09:31:18.394]                           }
[09:31:18.394]                         }
[09:31:18.394]                       }
[09:31:18.394]                       invisible(muffled)
[09:31:18.394]                     }
[09:31:18.394]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.394]                   }
[09:31:18.394]                 }
[09:31:18.394]             }
[09:31:18.394]         }))
[09:31:18.394]     }, error = function(ex) {
[09:31:18.394]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.394]                 ...future.rng), started = ...future.startTime, 
[09:31:18.394]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.394]             version = "1.8"), class = "FutureResult")
[09:31:18.394]     }, finally = {
[09:31:18.394]         if (!identical(...future.workdir, getwd())) 
[09:31:18.394]             setwd(...future.workdir)
[09:31:18.394]         {
[09:31:18.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.394]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.394]             }
[09:31:18.394]             base::options(...future.oldOptions)
[09:31:18.394]             if (.Platform$OS.type == "windows") {
[09:31:18.394]                 old_names <- names(...future.oldEnvVars)
[09:31:18.394]                 envs <- base::Sys.getenv()
[09:31:18.394]                 names <- names(envs)
[09:31:18.394]                 common <- intersect(names, old_names)
[09:31:18.394]                 added <- setdiff(names, old_names)
[09:31:18.394]                 removed <- setdiff(old_names, names)
[09:31:18.394]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.394]                   envs[common]]
[09:31:18.394]                 NAMES <- toupper(changed)
[09:31:18.394]                 args <- list()
[09:31:18.394]                 for (kk in seq_along(NAMES)) {
[09:31:18.394]                   name <- changed[[kk]]
[09:31:18.394]                   NAME <- NAMES[[kk]]
[09:31:18.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.394]                     next
[09:31:18.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.394]                 }
[09:31:18.394]                 NAMES <- toupper(added)
[09:31:18.394]                 for (kk in seq_along(NAMES)) {
[09:31:18.394]                   name <- added[[kk]]
[09:31:18.394]                   NAME <- NAMES[[kk]]
[09:31:18.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.394]                     next
[09:31:18.394]                   args[[name]] <- ""
[09:31:18.394]                 }
[09:31:18.394]                 NAMES <- toupper(removed)
[09:31:18.394]                 for (kk in seq_along(NAMES)) {
[09:31:18.394]                   name <- removed[[kk]]
[09:31:18.394]                   NAME <- NAMES[[kk]]
[09:31:18.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.394]                     next
[09:31:18.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.394]                 }
[09:31:18.394]                 if (length(args) > 0) 
[09:31:18.394]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.394]             }
[09:31:18.394]             else {
[09:31:18.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.394]             }
[09:31:18.394]             {
[09:31:18.394]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.394]                   0L) {
[09:31:18.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.394]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.394]                   base::options(opts)
[09:31:18.394]                 }
[09:31:18.394]                 {
[09:31:18.394]                   {
[09:31:18.394]                     NULL
[09:31:18.394]                     RNGkind("Mersenne-Twister")
[09:31:18.394]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.394]                       inherits = FALSE)
[09:31:18.394]                   }
[09:31:18.394]                   options(future.plan = NULL)
[09:31:18.394]                   if (is.na(NA_character_)) 
[09:31:18.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.394]                     .init = FALSE)
[09:31:18.394]                 }
[09:31:18.394]             }
[09:31:18.394]         }
[09:31:18.394]     })
[09:31:18.394]     if (TRUE) {
[09:31:18.394]         base::sink(type = "output", split = FALSE)
[09:31:18.394]         if (TRUE) {
[09:31:18.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.394]         }
[09:31:18.394]         else {
[09:31:18.394]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.394]         }
[09:31:18.394]         base::close(...future.stdout)
[09:31:18.394]         ...future.stdout <- NULL
[09:31:18.394]     }
[09:31:18.394]     ...future.result$conditions <- ...future.conditions
[09:31:18.394]     ...future.result$finished <- base::Sys.time()
[09:31:18.394]     ...future.result
[09:31:18.394] }
[09:31:18.396] plan(): Setting new future strategy stack:
[09:31:18.396] List of future strategies:
[09:31:18.396] 1. sequential:
[09:31:18.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.396]    - tweaked: FALSE
[09:31:18.396]    - call: NULL
[09:31:18.396] plan(): nbrOfWorkers() = 1
[09:31:18.398] plan(): Setting new future strategy stack:
[09:31:18.398] List of future strategies:
[09:31:18.398] 1. sequential:
[09:31:18.398]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.398]    - tweaked: FALSE
[09:31:18.398]    - call: plan(strategy)
[09:31:18.398] plan(): nbrOfWorkers() = 1
[09:31:18.398] SequentialFuture started (and completed)
[09:31:18.398] - Launch lazy future ... done
[09:31:18.398] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[09:31:18.401] getGlobalsAndPackages() ...
[09:31:18.401] Searching for globals...
[09:31:18.402] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[09:31:18.402] Searching for globals ... DONE
[09:31:18.402] Resolving globals: FALSE
[09:31:18.403] 
[09:31:18.403] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.403] getGlobalsAndPackages() ... DONE
[09:31:18.403] run() for ‘Future’ ...
[09:31:18.403] - state: ‘created’
[09:31:18.403] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.404] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.404]   - Field: ‘label’
[09:31:18.404]   - Field: ‘local’
[09:31:18.404]   - Field: ‘owner’
[09:31:18.404]   - Field: ‘envir’
[09:31:18.404]   - Field: ‘packages’
[09:31:18.404]   - Field: ‘gc’
[09:31:18.404]   - Field: ‘conditions’
[09:31:18.405]   - Field: ‘expr’
[09:31:18.405]   - Field: ‘uuid’
[09:31:18.405]   - Field: ‘seed’
[09:31:18.405]   - Field: ‘version’
[09:31:18.405]   - Field: ‘result’
[09:31:18.405]   - Field: ‘asynchronous’
[09:31:18.405]   - Field: ‘calls’
[09:31:18.405]   - Field: ‘globals’
[09:31:18.405]   - Field: ‘stdout’
[09:31:18.405]   - Field: ‘earlySignal’
[09:31:18.405]   - Field: ‘lazy’
[09:31:18.405]   - Field: ‘state’
[09:31:18.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.406] - Launch lazy future ...
[09:31:18.406] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.406] Packages needed by future strategies (n = 0): <none>
[09:31:18.406] {
[09:31:18.406]     {
[09:31:18.406]         {
[09:31:18.406]             ...future.startTime <- base::Sys.time()
[09:31:18.406]             {
[09:31:18.406]                 {
[09:31:18.406]                   {
[09:31:18.406]                     {
[09:31:18.406]                       base::local({
[09:31:18.406]                         has_future <- base::requireNamespace("future", 
[09:31:18.406]                           quietly = TRUE)
[09:31:18.406]                         if (has_future) {
[09:31:18.406]                           ns <- base::getNamespace("future")
[09:31:18.406]                           version <- ns[[".package"]][["version"]]
[09:31:18.406]                           if (is.null(version)) 
[09:31:18.406]                             version <- utils::packageVersion("future")
[09:31:18.406]                         }
[09:31:18.406]                         else {
[09:31:18.406]                           version <- NULL
[09:31:18.406]                         }
[09:31:18.406]                         if (!has_future || version < "1.8.0") {
[09:31:18.406]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.406]                             "", base::R.version$version.string), 
[09:31:18.406]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.406]                               "release", "version")], collapse = " "), 
[09:31:18.406]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.406]                             info)
[09:31:18.406]                           info <- base::paste(info, collapse = "; ")
[09:31:18.406]                           if (!has_future) {
[09:31:18.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.406]                               info)
[09:31:18.406]                           }
[09:31:18.406]                           else {
[09:31:18.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.406]                               info, version)
[09:31:18.406]                           }
[09:31:18.406]                           base::stop(msg)
[09:31:18.406]                         }
[09:31:18.406]                       })
[09:31:18.406]                     }
[09:31:18.406]                     base::local({
[09:31:18.406]                       for (pkg in c("stats", "datasets")) {
[09:31:18.406]                         base::loadNamespace(pkg)
[09:31:18.406]                         base::library(pkg, character.only = TRUE)
[09:31:18.406]                       }
[09:31:18.406]                     })
[09:31:18.406]                   }
[09:31:18.406]                   ...future.strategy.old <- future::plan("list")
[09:31:18.406]                   options(future.plan = NULL)
[09:31:18.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.406]                 }
[09:31:18.406]                 ...future.workdir <- getwd()
[09:31:18.406]             }
[09:31:18.406]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.406]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.406]         }
[09:31:18.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.406]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.406]             base::names(...future.oldOptions))
[09:31:18.406]     }
[09:31:18.406]     if (FALSE) {
[09:31:18.406]     }
[09:31:18.406]     else {
[09:31:18.406]         if (TRUE) {
[09:31:18.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.406]                 open = "w")
[09:31:18.406]         }
[09:31:18.406]         else {
[09:31:18.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.406]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.406]         }
[09:31:18.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.406]             base::sink(type = "output", split = FALSE)
[09:31:18.406]             base::close(...future.stdout)
[09:31:18.406]         }, add = TRUE)
[09:31:18.406]     }
[09:31:18.406]     ...future.frame <- base::sys.nframe()
[09:31:18.406]     ...future.conditions <- base::list()
[09:31:18.406]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.406]     if (FALSE) {
[09:31:18.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.406]     }
[09:31:18.406]     ...future.result <- base::tryCatch({
[09:31:18.406]         base::withCallingHandlers({
[09:31:18.406]             ...future.value <- base::withVisible(base::local({
[09:31:18.406]                 lm(dist ~ speed + speed^2, data = cars)
[09:31:18.406]             }))
[09:31:18.406]             future::FutureResult(value = ...future.value$value, 
[09:31:18.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.406]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.406]                     ...future.globalenv.names))
[09:31:18.406]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.406]         }, condition = base::local({
[09:31:18.406]             c <- base::c
[09:31:18.406]             inherits <- base::inherits
[09:31:18.406]             invokeRestart <- base::invokeRestart
[09:31:18.406]             length <- base::length
[09:31:18.406]             list <- base::list
[09:31:18.406]             seq.int <- base::seq.int
[09:31:18.406]             signalCondition <- base::signalCondition
[09:31:18.406]             sys.calls <- base::sys.calls
[09:31:18.406]             `[[` <- base::`[[`
[09:31:18.406]             `+` <- base::`+`
[09:31:18.406]             `<<-` <- base::`<<-`
[09:31:18.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.406]                   3L)]
[09:31:18.406]             }
[09:31:18.406]             function(cond) {
[09:31:18.406]                 is_error <- inherits(cond, "error")
[09:31:18.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.406]                   NULL)
[09:31:18.406]                 if (is_error) {
[09:31:18.406]                   sessionInformation <- function() {
[09:31:18.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.406]                       search = base::search(), system = base::Sys.info())
[09:31:18.406]                   }
[09:31:18.406]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.406]                     cond$call), session = sessionInformation(), 
[09:31:18.406]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.406]                   signalCondition(cond)
[09:31:18.406]                 }
[09:31:18.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.406]                 "immediateCondition"))) {
[09:31:18.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.406]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.406]                   if (TRUE && !signal) {
[09:31:18.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.406]                     {
[09:31:18.406]                       inherits <- base::inherits
[09:31:18.406]                       invokeRestart <- base::invokeRestart
[09:31:18.406]                       is.null <- base::is.null
[09:31:18.406]                       muffled <- FALSE
[09:31:18.406]                       if (inherits(cond, "message")) {
[09:31:18.406]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.406]                         if (muffled) 
[09:31:18.406]                           invokeRestart("muffleMessage")
[09:31:18.406]                       }
[09:31:18.406]                       else if (inherits(cond, "warning")) {
[09:31:18.406]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.406]                         if (muffled) 
[09:31:18.406]                           invokeRestart("muffleWarning")
[09:31:18.406]                       }
[09:31:18.406]                       else if (inherits(cond, "condition")) {
[09:31:18.406]                         if (!is.null(pattern)) {
[09:31:18.406]                           computeRestarts <- base::computeRestarts
[09:31:18.406]                           grepl <- base::grepl
[09:31:18.406]                           restarts <- computeRestarts(cond)
[09:31:18.406]                           for (restart in restarts) {
[09:31:18.406]                             name <- restart$name
[09:31:18.406]                             if (is.null(name)) 
[09:31:18.406]                               next
[09:31:18.406]                             if (!grepl(pattern, name)) 
[09:31:18.406]                               next
[09:31:18.406]                             invokeRestart(restart)
[09:31:18.406]                             muffled <- TRUE
[09:31:18.406]                             break
[09:31:18.406]                           }
[09:31:18.406]                         }
[09:31:18.406]                       }
[09:31:18.406]                       invisible(muffled)
[09:31:18.406]                     }
[09:31:18.406]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.406]                   }
[09:31:18.406]                 }
[09:31:18.406]                 else {
[09:31:18.406]                   if (TRUE) {
[09:31:18.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.406]                     {
[09:31:18.406]                       inherits <- base::inherits
[09:31:18.406]                       invokeRestart <- base::invokeRestart
[09:31:18.406]                       is.null <- base::is.null
[09:31:18.406]                       muffled <- FALSE
[09:31:18.406]                       if (inherits(cond, "message")) {
[09:31:18.406]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.406]                         if (muffled) 
[09:31:18.406]                           invokeRestart("muffleMessage")
[09:31:18.406]                       }
[09:31:18.406]                       else if (inherits(cond, "warning")) {
[09:31:18.406]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.406]                         if (muffled) 
[09:31:18.406]                           invokeRestart("muffleWarning")
[09:31:18.406]                       }
[09:31:18.406]                       else if (inherits(cond, "condition")) {
[09:31:18.406]                         if (!is.null(pattern)) {
[09:31:18.406]                           computeRestarts <- base::computeRestarts
[09:31:18.406]                           grepl <- base::grepl
[09:31:18.406]                           restarts <- computeRestarts(cond)
[09:31:18.406]                           for (restart in restarts) {
[09:31:18.406]                             name <- restart$name
[09:31:18.406]                             if (is.null(name)) 
[09:31:18.406]                               next
[09:31:18.406]                             if (!grepl(pattern, name)) 
[09:31:18.406]                               next
[09:31:18.406]                             invokeRestart(restart)
[09:31:18.406]                             muffled <- TRUE
[09:31:18.406]                             break
[09:31:18.406]                           }
[09:31:18.406]                         }
[09:31:18.406]                       }
[09:31:18.406]                       invisible(muffled)
[09:31:18.406]                     }
[09:31:18.406]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.406]                   }
[09:31:18.406]                 }
[09:31:18.406]             }
[09:31:18.406]         }))
[09:31:18.406]     }, error = function(ex) {
[09:31:18.406]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.406]                 ...future.rng), started = ...future.startTime, 
[09:31:18.406]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.406]             version = "1.8"), class = "FutureResult")
[09:31:18.406]     }, finally = {
[09:31:18.406]         if (!identical(...future.workdir, getwd())) 
[09:31:18.406]             setwd(...future.workdir)
[09:31:18.406]         {
[09:31:18.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.406]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.406]             }
[09:31:18.406]             base::options(...future.oldOptions)
[09:31:18.406]             if (.Platform$OS.type == "windows") {
[09:31:18.406]                 old_names <- names(...future.oldEnvVars)
[09:31:18.406]                 envs <- base::Sys.getenv()
[09:31:18.406]                 names <- names(envs)
[09:31:18.406]                 common <- intersect(names, old_names)
[09:31:18.406]                 added <- setdiff(names, old_names)
[09:31:18.406]                 removed <- setdiff(old_names, names)
[09:31:18.406]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.406]                   envs[common]]
[09:31:18.406]                 NAMES <- toupper(changed)
[09:31:18.406]                 args <- list()
[09:31:18.406]                 for (kk in seq_along(NAMES)) {
[09:31:18.406]                   name <- changed[[kk]]
[09:31:18.406]                   NAME <- NAMES[[kk]]
[09:31:18.406]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.406]                     next
[09:31:18.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.406]                 }
[09:31:18.406]                 NAMES <- toupper(added)
[09:31:18.406]                 for (kk in seq_along(NAMES)) {
[09:31:18.406]                   name <- added[[kk]]
[09:31:18.406]                   NAME <- NAMES[[kk]]
[09:31:18.406]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.406]                     next
[09:31:18.406]                   args[[name]] <- ""
[09:31:18.406]                 }
[09:31:18.406]                 NAMES <- toupper(removed)
[09:31:18.406]                 for (kk in seq_along(NAMES)) {
[09:31:18.406]                   name <- removed[[kk]]
[09:31:18.406]                   NAME <- NAMES[[kk]]
[09:31:18.406]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.406]                     next
[09:31:18.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.406]                 }
[09:31:18.406]                 if (length(args) > 0) 
[09:31:18.406]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.406]             }
[09:31:18.406]             else {
[09:31:18.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.406]             }
[09:31:18.406]             {
[09:31:18.406]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.406]                   0L) {
[09:31:18.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.406]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.406]                   base::options(opts)
[09:31:18.406]                 }
[09:31:18.406]                 {
[09:31:18.406]                   {
[09:31:18.406]                     NULL
[09:31:18.406]                     RNGkind("Mersenne-Twister")
[09:31:18.406]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.406]                       inherits = FALSE)
[09:31:18.406]                   }
[09:31:18.406]                   options(future.plan = NULL)
[09:31:18.406]                   if (is.na(NA_character_)) 
[09:31:18.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.406]                     .init = FALSE)
[09:31:18.406]                 }
[09:31:18.406]             }
[09:31:18.406]         }
[09:31:18.406]     })
[09:31:18.406]     if (TRUE) {
[09:31:18.406]         base::sink(type = "output", split = FALSE)
[09:31:18.406]         if (TRUE) {
[09:31:18.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.406]         }
[09:31:18.406]         else {
[09:31:18.406]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.406]         }
[09:31:18.406]         base::close(...future.stdout)
[09:31:18.406]         ...future.stdout <- NULL
[09:31:18.406]     }
[09:31:18.406]     ...future.result$conditions <- ...future.conditions
[09:31:18.406]     ...future.result$finished <- base::Sys.time()
[09:31:18.406]     ...future.result
[09:31:18.406] }
[09:31:18.408] plan(): Setting new future strategy stack:
[09:31:18.408] List of future strategies:
[09:31:18.408] 1. sequential:
[09:31:18.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.408]    - tweaked: FALSE
[09:31:18.408]    - call: NULL
[09:31:18.409] plan(): nbrOfWorkers() = 1
[09:31:18.410] plan(): Setting new future strategy stack:
[09:31:18.410] List of future strategies:
[09:31:18.410] 1. sequential:
[09:31:18.410]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.410]    - tweaked: FALSE
[09:31:18.410]    - call: plan(strategy)
[09:31:18.410] plan(): nbrOfWorkers() = 1
[09:31:18.410] SequentialFuture started (and completed)
[09:31:18.411] - Launch lazy future ... done
[09:31:18.411] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[09:31:18.414] getGlobalsAndPackages() ...
[09:31:18.414] Searching for globals...
[09:31:18.416] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[09:31:18.416] Searching for globals ... DONE
[09:31:18.416] Resolving globals: FALSE
[09:31:18.416] 
[09:31:18.416] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.417] getGlobalsAndPackages() ... DONE
[09:31:18.417] run() for ‘Future’ ...
[09:31:18.417] - state: ‘created’
[09:31:18.417] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.417] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.417]   - Field: ‘label’
[09:31:18.418]   - Field: ‘local’
[09:31:18.418]   - Field: ‘owner’
[09:31:18.418]   - Field: ‘envir’
[09:31:18.418]   - Field: ‘packages’
[09:31:18.418]   - Field: ‘gc’
[09:31:18.418]   - Field: ‘conditions’
[09:31:18.418]   - Field: ‘expr’
[09:31:18.418]   - Field: ‘uuid’
[09:31:18.418]   - Field: ‘seed’
[09:31:18.418]   - Field: ‘version’
[09:31:18.418]   - Field: ‘result’
[09:31:18.418]   - Field: ‘asynchronous’
[09:31:18.419]   - Field: ‘calls’
[09:31:18.419]   - Field: ‘globals’
[09:31:18.419]   - Field: ‘stdout’
[09:31:18.419]   - Field: ‘earlySignal’
[09:31:18.419]   - Field: ‘lazy’
[09:31:18.419]   - Field: ‘state’
[09:31:18.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.419] - Launch lazy future ...
[09:31:18.419] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.419] Packages needed by future strategies (n = 0): <none>
[09:31:18.420] {
[09:31:18.420]     {
[09:31:18.420]         {
[09:31:18.420]             ...future.startTime <- base::Sys.time()
[09:31:18.420]             {
[09:31:18.420]                 {
[09:31:18.420]                   {
[09:31:18.420]                     {
[09:31:18.420]                       base::local({
[09:31:18.420]                         has_future <- base::requireNamespace("future", 
[09:31:18.420]                           quietly = TRUE)
[09:31:18.420]                         if (has_future) {
[09:31:18.420]                           ns <- base::getNamespace("future")
[09:31:18.420]                           version <- ns[[".package"]][["version"]]
[09:31:18.420]                           if (is.null(version)) 
[09:31:18.420]                             version <- utils::packageVersion("future")
[09:31:18.420]                         }
[09:31:18.420]                         else {
[09:31:18.420]                           version <- NULL
[09:31:18.420]                         }
[09:31:18.420]                         if (!has_future || version < "1.8.0") {
[09:31:18.420]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.420]                             "", base::R.version$version.string), 
[09:31:18.420]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.420]                               "release", "version")], collapse = " "), 
[09:31:18.420]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.420]                             info)
[09:31:18.420]                           info <- base::paste(info, collapse = "; ")
[09:31:18.420]                           if (!has_future) {
[09:31:18.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.420]                               info)
[09:31:18.420]                           }
[09:31:18.420]                           else {
[09:31:18.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.420]                               info, version)
[09:31:18.420]                           }
[09:31:18.420]                           base::stop(msg)
[09:31:18.420]                         }
[09:31:18.420]                       })
[09:31:18.420]                     }
[09:31:18.420]                     base::local({
[09:31:18.420]                       for (pkg in c("stats", "datasets")) {
[09:31:18.420]                         base::loadNamespace(pkg)
[09:31:18.420]                         base::library(pkg, character.only = TRUE)
[09:31:18.420]                       }
[09:31:18.420]                     })
[09:31:18.420]                   }
[09:31:18.420]                   ...future.strategy.old <- future::plan("list")
[09:31:18.420]                   options(future.plan = NULL)
[09:31:18.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.420]                 }
[09:31:18.420]                 ...future.workdir <- getwd()
[09:31:18.420]             }
[09:31:18.420]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.420]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.420]         }
[09:31:18.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.420]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.420]             base::names(...future.oldOptions))
[09:31:18.420]     }
[09:31:18.420]     if (FALSE) {
[09:31:18.420]     }
[09:31:18.420]     else {
[09:31:18.420]         if (TRUE) {
[09:31:18.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.420]                 open = "w")
[09:31:18.420]         }
[09:31:18.420]         else {
[09:31:18.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.420]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.420]         }
[09:31:18.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.420]             base::sink(type = "output", split = FALSE)
[09:31:18.420]             base::close(...future.stdout)
[09:31:18.420]         }, add = TRUE)
[09:31:18.420]     }
[09:31:18.420]     ...future.frame <- base::sys.nframe()
[09:31:18.420]     ...future.conditions <- base::list()
[09:31:18.420]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.420]     if (FALSE) {
[09:31:18.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.420]     }
[09:31:18.420]     ...future.result <- base::tryCatch({
[09:31:18.420]         base::withCallingHandlers({
[09:31:18.420]             ...future.value <- base::withVisible(base::local({
[09:31:18.420]                 lm(dist ~ speed + I(speed^2), data = cars)
[09:31:18.420]             }))
[09:31:18.420]             future::FutureResult(value = ...future.value$value, 
[09:31:18.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.420]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.420]                     ...future.globalenv.names))
[09:31:18.420]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.420]         }, condition = base::local({
[09:31:18.420]             c <- base::c
[09:31:18.420]             inherits <- base::inherits
[09:31:18.420]             invokeRestart <- base::invokeRestart
[09:31:18.420]             length <- base::length
[09:31:18.420]             list <- base::list
[09:31:18.420]             seq.int <- base::seq.int
[09:31:18.420]             signalCondition <- base::signalCondition
[09:31:18.420]             sys.calls <- base::sys.calls
[09:31:18.420]             `[[` <- base::`[[`
[09:31:18.420]             `+` <- base::`+`
[09:31:18.420]             `<<-` <- base::`<<-`
[09:31:18.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.420]                   3L)]
[09:31:18.420]             }
[09:31:18.420]             function(cond) {
[09:31:18.420]                 is_error <- inherits(cond, "error")
[09:31:18.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.420]                   NULL)
[09:31:18.420]                 if (is_error) {
[09:31:18.420]                   sessionInformation <- function() {
[09:31:18.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.420]                       search = base::search(), system = base::Sys.info())
[09:31:18.420]                   }
[09:31:18.420]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.420]                     cond$call), session = sessionInformation(), 
[09:31:18.420]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.420]                   signalCondition(cond)
[09:31:18.420]                 }
[09:31:18.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.420]                 "immediateCondition"))) {
[09:31:18.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.420]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.420]                   if (TRUE && !signal) {
[09:31:18.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.420]                     {
[09:31:18.420]                       inherits <- base::inherits
[09:31:18.420]                       invokeRestart <- base::invokeRestart
[09:31:18.420]                       is.null <- base::is.null
[09:31:18.420]                       muffled <- FALSE
[09:31:18.420]                       if (inherits(cond, "message")) {
[09:31:18.420]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.420]                         if (muffled) 
[09:31:18.420]                           invokeRestart("muffleMessage")
[09:31:18.420]                       }
[09:31:18.420]                       else if (inherits(cond, "warning")) {
[09:31:18.420]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.420]                         if (muffled) 
[09:31:18.420]                           invokeRestart("muffleWarning")
[09:31:18.420]                       }
[09:31:18.420]                       else if (inherits(cond, "condition")) {
[09:31:18.420]                         if (!is.null(pattern)) {
[09:31:18.420]                           computeRestarts <- base::computeRestarts
[09:31:18.420]                           grepl <- base::grepl
[09:31:18.420]                           restarts <- computeRestarts(cond)
[09:31:18.420]                           for (restart in restarts) {
[09:31:18.420]                             name <- restart$name
[09:31:18.420]                             if (is.null(name)) 
[09:31:18.420]                               next
[09:31:18.420]                             if (!grepl(pattern, name)) 
[09:31:18.420]                               next
[09:31:18.420]                             invokeRestart(restart)
[09:31:18.420]                             muffled <- TRUE
[09:31:18.420]                             break
[09:31:18.420]                           }
[09:31:18.420]                         }
[09:31:18.420]                       }
[09:31:18.420]                       invisible(muffled)
[09:31:18.420]                     }
[09:31:18.420]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.420]                   }
[09:31:18.420]                 }
[09:31:18.420]                 else {
[09:31:18.420]                   if (TRUE) {
[09:31:18.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.420]                     {
[09:31:18.420]                       inherits <- base::inherits
[09:31:18.420]                       invokeRestart <- base::invokeRestart
[09:31:18.420]                       is.null <- base::is.null
[09:31:18.420]                       muffled <- FALSE
[09:31:18.420]                       if (inherits(cond, "message")) {
[09:31:18.420]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.420]                         if (muffled) 
[09:31:18.420]                           invokeRestart("muffleMessage")
[09:31:18.420]                       }
[09:31:18.420]                       else if (inherits(cond, "warning")) {
[09:31:18.420]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.420]                         if (muffled) 
[09:31:18.420]                           invokeRestart("muffleWarning")
[09:31:18.420]                       }
[09:31:18.420]                       else if (inherits(cond, "condition")) {
[09:31:18.420]                         if (!is.null(pattern)) {
[09:31:18.420]                           computeRestarts <- base::computeRestarts
[09:31:18.420]                           grepl <- base::grepl
[09:31:18.420]                           restarts <- computeRestarts(cond)
[09:31:18.420]                           for (restart in restarts) {
[09:31:18.420]                             name <- restart$name
[09:31:18.420]                             if (is.null(name)) 
[09:31:18.420]                               next
[09:31:18.420]                             if (!grepl(pattern, name)) 
[09:31:18.420]                               next
[09:31:18.420]                             invokeRestart(restart)
[09:31:18.420]                             muffled <- TRUE
[09:31:18.420]                             break
[09:31:18.420]                           }
[09:31:18.420]                         }
[09:31:18.420]                       }
[09:31:18.420]                       invisible(muffled)
[09:31:18.420]                     }
[09:31:18.420]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.420]                   }
[09:31:18.420]                 }
[09:31:18.420]             }
[09:31:18.420]         }))
[09:31:18.420]     }, error = function(ex) {
[09:31:18.420]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.420]                 ...future.rng), started = ...future.startTime, 
[09:31:18.420]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.420]             version = "1.8"), class = "FutureResult")
[09:31:18.420]     }, finally = {
[09:31:18.420]         if (!identical(...future.workdir, getwd())) 
[09:31:18.420]             setwd(...future.workdir)
[09:31:18.420]         {
[09:31:18.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.420]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.420]             }
[09:31:18.420]             base::options(...future.oldOptions)
[09:31:18.420]             if (.Platform$OS.type == "windows") {
[09:31:18.420]                 old_names <- names(...future.oldEnvVars)
[09:31:18.420]                 envs <- base::Sys.getenv()
[09:31:18.420]                 names <- names(envs)
[09:31:18.420]                 common <- intersect(names, old_names)
[09:31:18.420]                 added <- setdiff(names, old_names)
[09:31:18.420]                 removed <- setdiff(old_names, names)
[09:31:18.420]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.420]                   envs[common]]
[09:31:18.420]                 NAMES <- toupper(changed)
[09:31:18.420]                 args <- list()
[09:31:18.420]                 for (kk in seq_along(NAMES)) {
[09:31:18.420]                   name <- changed[[kk]]
[09:31:18.420]                   NAME <- NAMES[[kk]]
[09:31:18.420]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.420]                     next
[09:31:18.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.420]                 }
[09:31:18.420]                 NAMES <- toupper(added)
[09:31:18.420]                 for (kk in seq_along(NAMES)) {
[09:31:18.420]                   name <- added[[kk]]
[09:31:18.420]                   NAME <- NAMES[[kk]]
[09:31:18.420]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.420]                     next
[09:31:18.420]                   args[[name]] <- ""
[09:31:18.420]                 }
[09:31:18.420]                 NAMES <- toupper(removed)
[09:31:18.420]                 for (kk in seq_along(NAMES)) {
[09:31:18.420]                   name <- removed[[kk]]
[09:31:18.420]                   NAME <- NAMES[[kk]]
[09:31:18.420]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.420]                     next
[09:31:18.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.420]                 }
[09:31:18.420]                 if (length(args) > 0) 
[09:31:18.420]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.420]             }
[09:31:18.420]             else {
[09:31:18.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.420]             }
[09:31:18.420]             {
[09:31:18.420]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.420]                   0L) {
[09:31:18.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.420]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.420]                   base::options(opts)
[09:31:18.420]                 }
[09:31:18.420]                 {
[09:31:18.420]                   {
[09:31:18.420]                     NULL
[09:31:18.420]                     RNGkind("Mersenne-Twister")
[09:31:18.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.420]                       inherits = FALSE)
[09:31:18.420]                   }
[09:31:18.420]                   options(future.plan = NULL)
[09:31:18.420]                   if (is.na(NA_character_)) 
[09:31:18.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.420]                     .init = FALSE)
[09:31:18.420]                 }
[09:31:18.420]             }
[09:31:18.420]         }
[09:31:18.420]     })
[09:31:18.420]     if (TRUE) {
[09:31:18.420]         base::sink(type = "output", split = FALSE)
[09:31:18.420]         if (TRUE) {
[09:31:18.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.420]         }
[09:31:18.420]         else {
[09:31:18.420]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.420]         }
[09:31:18.420]         base::close(...future.stdout)
[09:31:18.420]         ...future.stdout <- NULL
[09:31:18.420]     }
[09:31:18.420]     ...future.result$conditions <- ...future.conditions
[09:31:18.420]     ...future.result$finished <- base::Sys.time()
[09:31:18.420]     ...future.result
[09:31:18.420] }
[09:31:18.422] plan(): Setting new future strategy stack:
[09:31:18.422] List of future strategies:
[09:31:18.422] 1. sequential:
[09:31:18.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.422]    - tweaked: FALSE
[09:31:18.422]    - call: NULL
[09:31:18.422] plan(): nbrOfWorkers() = 1
[09:31:18.423] plan(): Setting new future strategy stack:
[09:31:18.424] List of future strategies:
[09:31:18.424] 1. sequential:
[09:31:18.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.424]    - tweaked: FALSE
[09:31:18.424]    - call: plan(strategy)
[09:31:18.424] plan(): nbrOfWorkers() = 1
[09:31:18.424] SequentialFuture started (and completed)
[09:31:18.424] - Launch lazy future ... done
[09:31:18.424] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[09:31:18.428] getGlobalsAndPackages() ...
[09:31:18.428] Searching for globals...
[09:31:18.429] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[09:31:18.429] Searching for globals ... DONE
[09:31:18.429] Resolving globals: FALSE
[09:31:18.430] 
[09:31:18.430] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.430] getGlobalsAndPackages() ... DONE
[09:31:18.430] run() for ‘Future’ ...
[09:31:18.430] - state: ‘created’
[09:31:18.430] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.431]   - Field: ‘label’
[09:31:18.431]   - Field: ‘local’
[09:31:18.431]   - Field: ‘owner’
[09:31:18.431]   - Field: ‘envir’
[09:31:18.431]   - Field: ‘packages’
[09:31:18.431]   - Field: ‘gc’
[09:31:18.431]   - Field: ‘conditions’
[09:31:18.431]   - Field: ‘expr’
[09:31:18.431]   - Field: ‘uuid’
[09:31:18.432]   - Field: ‘seed’
[09:31:18.432]   - Field: ‘version’
[09:31:18.432]   - Field: ‘result’
[09:31:18.432]   - Field: ‘asynchronous’
[09:31:18.432]   - Field: ‘calls’
[09:31:18.432]   - Field: ‘globals’
[09:31:18.432]   - Field: ‘stdout’
[09:31:18.432]   - Field: ‘earlySignal’
[09:31:18.432]   - Field: ‘lazy’
[09:31:18.432]   - Field: ‘state’
[09:31:18.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.433] - Launch lazy future ...
[09:31:18.433] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.433] Packages needed by future strategies (n = 0): <none>
[09:31:18.433] {
[09:31:18.433]     {
[09:31:18.433]         {
[09:31:18.433]             ...future.startTime <- base::Sys.time()
[09:31:18.433]             {
[09:31:18.433]                 {
[09:31:18.433]                   {
[09:31:18.433]                     {
[09:31:18.433]                       base::local({
[09:31:18.433]                         has_future <- base::requireNamespace("future", 
[09:31:18.433]                           quietly = TRUE)
[09:31:18.433]                         if (has_future) {
[09:31:18.433]                           ns <- base::getNamespace("future")
[09:31:18.433]                           version <- ns[[".package"]][["version"]]
[09:31:18.433]                           if (is.null(version)) 
[09:31:18.433]                             version <- utils::packageVersion("future")
[09:31:18.433]                         }
[09:31:18.433]                         else {
[09:31:18.433]                           version <- NULL
[09:31:18.433]                         }
[09:31:18.433]                         if (!has_future || version < "1.8.0") {
[09:31:18.433]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.433]                             "", base::R.version$version.string), 
[09:31:18.433]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.433]                               "release", "version")], collapse = " "), 
[09:31:18.433]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.433]                             info)
[09:31:18.433]                           info <- base::paste(info, collapse = "; ")
[09:31:18.433]                           if (!has_future) {
[09:31:18.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.433]                               info)
[09:31:18.433]                           }
[09:31:18.433]                           else {
[09:31:18.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.433]                               info, version)
[09:31:18.433]                           }
[09:31:18.433]                           base::stop(msg)
[09:31:18.433]                         }
[09:31:18.433]                       })
[09:31:18.433]                     }
[09:31:18.433]                     base::local({
[09:31:18.433]                       for (pkg in c("stats", "datasets")) {
[09:31:18.433]                         base::loadNamespace(pkg)
[09:31:18.433]                         base::library(pkg, character.only = TRUE)
[09:31:18.433]                       }
[09:31:18.433]                     })
[09:31:18.433]                   }
[09:31:18.433]                   ...future.strategy.old <- future::plan("list")
[09:31:18.433]                   options(future.plan = NULL)
[09:31:18.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.433]                 }
[09:31:18.433]                 ...future.workdir <- getwd()
[09:31:18.433]             }
[09:31:18.433]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.433]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.433]         }
[09:31:18.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.433]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.433]             base::names(...future.oldOptions))
[09:31:18.433]     }
[09:31:18.433]     if (FALSE) {
[09:31:18.433]     }
[09:31:18.433]     else {
[09:31:18.433]         if (TRUE) {
[09:31:18.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.433]                 open = "w")
[09:31:18.433]         }
[09:31:18.433]         else {
[09:31:18.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.433]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.433]         }
[09:31:18.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.433]             base::sink(type = "output", split = FALSE)
[09:31:18.433]             base::close(...future.stdout)
[09:31:18.433]         }, add = TRUE)
[09:31:18.433]     }
[09:31:18.433]     ...future.frame <- base::sys.nframe()
[09:31:18.433]     ...future.conditions <- base::list()
[09:31:18.433]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.433]     if (FALSE) {
[09:31:18.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.433]     }
[09:31:18.433]     ...future.result <- base::tryCatch({
[09:31:18.433]         base::withCallingHandlers({
[09:31:18.433]             ...future.value <- base::withVisible(base::local({
[09:31:18.433]                 lm(dist ~ poly(speed, 2), data = cars)
[09:31:18.433]             }))
[09:31:18.433]             future::FutureResult(value = ...future.value$value, 
[09:31:18.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.433]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.433]                     ...future.globalenv.names))
[09:31:18.433]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.433]         }, condition = base::local({
[09:31:18.433]             c <- base::c
[09:31:18.433]             inherits <- base::inherits
[09:31:18.433]             invokeRestart <- base::invokeRestart
[09:31:18.433]             length <- base::length
[09:31:18.433]             list <- base::list
[09:31:18.433]             seq.int <- base::seq.int
[09:31:18.433]             signalCondition <- base::signalCondition
[09:31:18.433]             sys.calls <- base::sys.calls
[09:31:18.433]             `[[` <- base::`[[`
[09:31:18.433]             `+` <- base::`+`
[09:31:18.433]             `<<-` <- base::`<<-`
[09:31:18.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.433]                   3L)]
[09:31:18.433]             }
[09:31:18.433]             function(cond) {
[09:31:18.433]                 is_error <- inherits(cond, "error")
[09:31:18.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.433]                   NULL)
[09:31:18.433]                 if (is_error) {
[09:31:18.433]                   sessionInformation <- function() {
[09:31:18.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.433]                       search = base::search(), system = base::Sys.info())
[09:31:18.433]                   }
[09:31:18.433]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.433]                     cond$call), session = sessionInformation(), 
[09:31:18.433]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.433]                   signalCondition(cond)
[09:31:18.433]                 }
[09:31:18.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.433]                 "immediateCondition"))) {
[09:31:18.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.433]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.433]                   if (TRUE && !signal) {
[09:31:18.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.433]                     {
[09:31:18.433]                       inherits <- base::inherits
[09:31:18.433]                       invokeRestart <- base::invokeRestart
[09:31:18.433]                       is.null <- base::is.null
[09:31:18.433]                       muffled <- FALSE
[09:31:18.433]                       if (inherits(cond, "message")) {
[09:31:18.433]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.433]                         if (muffled) 
[09:31:18.433]                           invokeRestart("muffleMessage")
[09:31:18.433]                       }
[09:31:18.433]                       else if (inherits(cond, "warning")) {
[09:31:18.433]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.433]                         if (muffled) 
[09:31:18.433]                           invokeRestart("muffleWarning")
[09:31:18.433]                       }
[09:31:18.433]                       else if (inherits(cond, "condition")) {
[09:31:18.433]                         if (!is.null(pattern)) {
[09:31:18.433]                           computeRestarts <- base::computeRestarts
[09:31:18.433]                           grepl <- base::grepl
[09:31:18.433]                           restarts <- computeRestarts(cond)
[09:31:18.433]                           for (restart in restarts) {
[09:31:18.433]                             name <- restart$name
[09:31:18.433]                             if (is.null(name)) 
[09:31:18.433]                               next
[09:31:18.433]                             if (!grepl(pattern, name)) 
[09:31:18.433]                               next
[09:31:18.433]                             invokeRestart(restart)
[09:31:18.433]                             muffled <- TRUE
[09:31:18.433]                             break
[09:31:18.433]                           }
[09:31:18.433]                         }
[09:31:18.433]                       }
[09:31:18.433]                       invisible(muffled)
[09:31:18.433]                     }
[09:31:18.433]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.433]                   }
[09:31:18.433]                 }
[09:31:18.433]                 else {
[09:31:18.433]                   if (TRUE) {
[09:31:18.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.433]                     {
[09:31:18.433]                       inherits <- base::inherits
[09:31:18.433]                       invokeRestart <- base::invokeRestart
[09:31:18.433]                       is.null <- base::is.null
[09:31:18.433]                       muffled <- FALSE
[09:31:18.433]                       if (inherits(cond, "message")) {
[09:31:18.433]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.433]                         if (muffled) 
[09:31:18.433]                           invokeRestart("muffleMessage")
[09:31:18.433]                       }
[09:31:18.433]                       else if (inherits(cond, "warning")) {
[09:31:18.433]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.433]                         if (muffled) 
[09:31:18.433]                           invokeRestart("muffleWarning")
[09:31:18.433]                       }
[09:31:18.433]                       else if (inherits(cond, "condition")) {
[09:31:18.433]                         if (!is.null(pattern)) {
[09:31:18.433]                           computeRestarts <- base::computeRestarts
[09:31:18.433]                           grepl <- base::grepl
[09:31:18.433]                           restarts <- computeRestarts(cond)
[09:31:18.433]                           for (restart in restarts) {
[09:31:18.433]                             name <- restart$name
[09:31:18.433]                             if (is.null(name)) 
[09:31:18.433]                               next
[09:31:18.433]                             if (!grepl(pattern, name)) 
[09:31:18.433]                               next
[09:31:18.433]                             invokeRestart(restart)
[09:31:18.433]                             muffled <- TRUE
[09:31:18.433]                             break
[09:31:18.433]                           }
[09:31:18.433]                         }
[09:31:18.433]                       }
[09:31:18.433]                       invisible(muffled)
[09:31:18.433]                     }
[09:31:18.433]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.433]                   }
[09:31:18.433]                 }
[09:31:18.433]             }
[09:31:18.433]         }))
[09:31:18.433]     }, error = function(ex) {
[09:31:18.433]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.433]                 ...future.rng), started = ...future.startTime, 
[09:31:18.433]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.433]             version = "1.8"), class = "FutureResult")
[09:31:18.433]     }, finally = {
[09:31:18.433]         if (!identical(...future.workdir, getwd())) 
[09:31:18.433]             setwd(...future.workdir)
[09:31:18.433]         {
[09:31:18.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.433]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.433]             }
[09:31:18.433]             base::options(...future.oldOptions)
[09:31:18.433]             if (.Platform$OS.type == "windows") {
[09:31:18.433]                 old_names <- names(...future.oldEnvVars)
[09:31:18.433]                 envs <- base::Sys.getenv()
[09:31:18.433]                 names <- names(envs)
[09:31:18.433]                 common <- intersect(names, old_names)
[09:31:18.433]                 added <- setdiff(names, old_names)
[09:31:18.433]                 removed <- setdiff(old_names, names)
[09:31:18.433]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.433]                   envs[common]]
[09:31:18.433]                 NAMES <- toupper(changed)
[09:31:18.433]                 args <- list()
[09:31:18.433]                 for (kk in seq_along(NAMES)) {
[09:31:18.433]                   name <- changed[[kk]]
[09:31:18.433]                   NAME <- NAMES[[kk]]
[09:31:18.433]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.433]                     next
[09:31:18.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.433]                 }
[09:31:18.433]                 NAMES <- toupper(added)
[09:31:18.433]                 for (kk in seq_along(NAMES)) {
[09:31:18.433]                   name <- added[[kk]]
[09:31:18.433]                   NAME <- NAMES[[kk]]
[09:31:18.433]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.433]                     next
[09:31:18.433]                   args[[name]] <- ""
[09:31:18.433]                 }
[09:31:18.433]                 NAMES <- toupper(removed)
[09:31:18.433]                 for (kk in seq_along(NAMES)) {
[09:31:18.433]                   name <- removed[[kk]]
[09:31:18.433]                   NAME <- NAMES[[kk]]
[09:31:18.433]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.433]                     next
[09:31:18.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.433]                 }
[09:31:18.433]                 if (length(args) > 0) 
[09:31:18.433]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.433]             }
[09:31:18.433]             else {
[09:31:18.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.433]             }
[09:31:18.433]             {
[09:31:18.433]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.433]                   0L) {
[09:31:18.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.433]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.433]                   base::options(opts)
[09:31:18.433]                 }
[09:31:18.433]                 {
[09:31:18.433]                   {
[09:31:18.433]                     NULL
[09:31:18.433]                     RNGkind("Mersenne-Twister")
[09:31:18.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.433]                       inherits = FALSE)
[09:31:18.433]                   }
[09:31:18.433]                   options(future.plan = NULL)
[09:31:18.433]                   if (is.na(NA_character_)) 
[09:31:18.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.433]                     .init = FALSE)
[09:31:18.433]                 }
[09:31:18.433]             }
[09:31:18.433]         }
[09:31:18.433]     })
[09:31:18.433]     if (TRUE) {
[09:31:18.433]         base::sink(type = "output", split = FALSE)
[09:31:18.433]         if (TRUE) {
[09:31:18.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.433]         }
[09:31:18.433]         else {
[09:31:18.433]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.433]         }
[09:31:18.433]         base::close(...future.stdout)
[09:31:18.433]         ...future.stdout <- NULL
[09:31:18.433]     }
[09:31:18.433]     ...future.result$conditions <- ...future.conditions
[09:31:18.433]     ...future.result$finished <- base::Sys.time()
[09:31:18.433]     ...future.result
[09:31:18.433] }
[09:31:18.435] plan(): Setting new future strategy stack:
[09:31:18.435] List of future strategies:
[09:31:18.435] 1. sequential:
[09:31:18.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.435]    - tweaked: FALSE
[09:31:18.435]    - call: NULL
[09:31:18.436] plan(): nbrOfWorkers() = 1
[09:31:18.438] plan(): Setting new future strategy stack:
[09:31:18.438] List of future strategies:
[09:31:18.438] 1. sequential:
[09:31:18.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.438]    - tweaked: FALSE
[09:31:18.438]    - call: plan(strategy)
[09:31:18.439] plan(): nbrOfWorkers() = 1
[09:31:18.439] SequentialFuture started (and completed)
[09:31:18.439] - Launch lazy future ... done
[09:31:18.439] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[09:31:18.441] getGlobalsAndPackages() ...
[09:31:18.441] Searching for globals...
[09:31:18.445] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[09:31:18.445] Searching for globals ... DONE
[09:31:18.446] Resolving globals: FALSE
[09:31:18.446] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[09:31:18.447] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[09:31:18.447] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[09:31:18.447] 
[09:31:18.447] getGlobalsAndPackages() ... DONE
[09:31:18.447] run() for ‘Future’ ...
[09:31:18.447] - state: ‘created’
[09:31:18.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.448]   - Field: ‘label’
[09:31:18.448]   - Field: ‘local’
[09:31:18.448]   - Field: ‘owner’
[09:31:18.448]   - Field: ‘envir’
[09:31:18.448]   - Field: ‘packages’
[09:31:18.448]   - Field: ‘gc’
[09:31:18.448]   - Field: ‘conditions’
[09:31:18.448]   - Field: ‘expr’
[09:31:18.448]   - Field: ‘uuid’
[09:31:18.449]   - Field: ‘seed’
[09:31:18.449]   - Field: ‘version’
[09:31:18.449]   - Field: ‘result’
[09:31:18.449]   - Field: ‘asynchronous’
[09:31:18.449]   - Field: ‘calls’
[09:31:18.449]   - Field: ‘globals’
[09:31:18.449]   - Field: ‘stdout’
[09:31:18.449]   - Field: ‘earlySignal’
[09:31:18.449]   - Field: ‘lazy’
[09:31:18.449]   - Field: ‘state’
[09:31:18.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.449] - Launch lazy future ...
[09:31:18.450] Packages needed by the future expression (n = 0): <none>
[09:31:18.450] Packages needed by future strategies (n = 0): <none>
[09:31:18.450] {
[09:31:18.450]     {
[09:31:18.450]         {
[09:31:18.450]             ...future.startTime <- base::Sys.time()
[09:31:18.450]             {
[09:31:18.450]                 {
[09:31:18.450]                   {
[09:31:18.450]                     base::local({
[09:31:18.450]                       has_future <- base::requireNamespace("future", 
[09:31:18.450]                         quietly = TRUE)
[09:31:18.450]                       if (has_future) {
[09:31:18.450]                         ns <- base::getNamespace("future")
[09:31:18.450]                         version <- ns[[".package"]][["version"]]
[09:31:18.450]                         if (is.null(version)) 
[09:31:18.450]                           version <- utils::packageVersion("future")
[09:31:18.450]                       }
[09:31:18.450]                       else {
[09:31:18.450]                         version <- NULL
[09:31:18.450]                       }
[09:31:18.450]                       if (!has_future || version < "1.8.0") {
[09:31:18.450]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.450]                           "", base::R.version$version.string), 
[09:31:18.450]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:18.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.450]                             "release", "version")], collapse = " "), 
[09:31:18.450]                           hostname = base::Sys.info()[["nodename"]])
[09:31:18.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.450]                           info)
[09:31:18.450]                         info <- base::paste(info, collapse = "; ")
[09:31:18.450]                         if (!has_future) {
[09:31:18.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.450]                             info)
[09:31:18.450]                         }
[09:31:18.450]                         else {
[09:31:18.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.450]                             info, version)
[09:31:18.450]                         }
[09:31:18.450]                         base::stop(msg)
[09:31:18.450]                       }
[09:31:18.450]                     })
[09:31:18.450]                   }
[09:31:18.450]                   ...future.strategy.old <- future::plan("list")
[09:31:18.450]                   options(future.plan = NULL)
[09:31:18.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.450]                 }
[09:31:18.450]                 ...future.workdir <- getwd()
[09:31:18.450]             }
[09:31:18.450]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.450]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.450]         }
[09:31:18.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.450]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.450]             base::names(...future.oldOptions))
[09:31:18.450]     }
[09:31:18.450]     if (FALSE) {
[09:31:18.450]     }
[09:31:18.450]     else {
[09:31:18.450]         if (TRUE) {
[09:31:18.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.450]                 open = "w")
[09:31:18.450]         }
[09:31:18.450]         else {
[09:31:18.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.450]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.450]         }
[09:31:18.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.450]             base::sink(type = "output", split = FALSE)
[09:31:18.450]             base::close(...future.stdout)
[09:31:18.450]         }, add = TRUE)
[09:31:18.450]     }
[09:31:18.450]     ...future.frame <- base::sys.nframe()
[09:31:18.450]     ...future.conditions <- base::list()
[09:31:18.450]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.450]     if (FALSE) {
[09:31:18.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.450]     }
[09:31:18.450]     ...future.result <- base::tryCatch({
[09:31:18.450]         base::withCallingHandlers({
[09:31:18.450]             ...future.value <- base::withVisible(base::local({
[09:31:18.450]                 outer_function(1L)
[09:31:18.450]             }))
[09:31:18.450]             future::FutureResult(value = ...future.value$value, 
[09:31:18.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.450]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.450]                     ...future.globalenv.names))
[09:31:18.450]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.450]         }, condition = base::local({
[09:31:18.450]             c <- base::c
[09:31:18.450]             inherits <- base::inherits
[09:31:18.450]             invokeRestart <- base::invokeRestart
[09:31:18.450]             length <- base::length
[09:31:18.450]             list <- base::list
[09:31:18.450]             seq.int <- base::seq.int
[09:31:18.450]             signalCondition <- base::signalCondition
[09:31:18.450]             sys.calls <- base::sys.calls
[09:31:18.450]             `[[` <- base::`[[`
[09:31:18.450]             `+` <- base::`+`
[09:31:18.450]             `<<-` <- base::`<<-`
[09:31:18.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.450]                   3L)]
[09:31:18.450]             }
[09:31:18.450]             function(cond) {
[09:31:18.450]                 is_error <- inherits(cond, "error")
[09:31:18.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.450]                   NULL)
[09:31:18.450]                 if (is_error) {
[09:31:18.450]                   sessionInformation <- function() {
[09:31:18.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.450]                       search = base::search(), system = base::Sys.info())
[09:31:18.450]                   }
[09:31:18.450]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.450]                     cond$call), session = sessionInformation(), 
[09:31:18.450]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.450]                   signalCondition(cond)
[09:31:18.450]                 }
[09:31:18.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.450]                 "immediateCondition"))) {
[09:31:18.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.450]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.450]                   if (TRUE && !signal) {
[09:31:18.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.450]                     {
[09:31:18.450]                       inherits <- base::inherits
[09:31:18.450]                       invokeRestart <- base::invokeRestart
[09:31:18.450]                       is.null <- base::is.null
[09:31:18.450]                       muffled <- FALSE
[09:31:18.450]                       if (inherits(cond, "message")) {
[09:31:18.450]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.450]                         if (muffled) 
[09:31:18.450]                           invokeRestart("muffleMessage")
[09:31:18.450]                       }
[09:31:18.450]                       else if (inherits(cond, "warning")) {
[09:31:18.450]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.450]                         if (muffled) 
[09:31:18.450]                           invokeRestart("muffleWarning")
[09:31:18.450]                       }
[09:31:18.450]                       else if (inherits(cond, "condition")) {
[09:31:18.450]                         if (!is.null(pattern)) {
[09:31:18.450]                           computeRestarts <- base::computeRestarts
[09:31:18.450]                           grepl <- base::grepl
[09:31:18.450]                           restarts <- computeRestarts(cond)
[09:31:18.450]                           for (restart in restarts) {
[09:31:18.450]                             name <- restart$name
[09:31:18.450]                             if (is.null(name)) 
[09:31:18.450]                               next
[09:31:18.450]                             if (!grepl(pattern, name)) 
[09:31:18.450]                               next
[09:31:18.450]                             invokeRestart(restart)
[09:31:18.450]                             muffled <- TRUE
[09:31:18.450]                             break
[09:31:18.450]                           }
[09:31:18.450]                         }
[09:31:18.450]                       }
[09:31:18.450]                       invisible(muffled)
[09:31:18.450]                     }
[09:31:18.450]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.450]                   }
[09:31:18.450]                 }
[09:31:18.450]                 else {
[09:31:18.450]                   if (TRUE) {
[09:31:18.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.450]                     {
[09:31:18.450]                       inherits <- base::inherits
[09:31:18.450]                       invokeRestart <- base::invokeRestart
[09:31:18.450]                       is.null <- base::is.null
[09:31:18.450]                       muffled <- FALSE
[09:31:18.450]                       if (inherits(cond, "message")) {
[09:31:18.450]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.450]                         if (muffled) 
[09:31:18.450]                           invokeRestart("muffleMessage")
[09:31:18.450]                       }
[09:31:18.450]                       else if (inherits(cond, "warning")) {
[09:31:18.450]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.450]                         if (muffled) 
[09:31:18.450]                           invokeRestart("muffleWarning")
[09:31:18.450]                       }
[09:31:18.450]                       else if (inherits(cond, "condition")) {
[09:31:18.450]                         if (!is.null(pattern)) {
[09:31:18.450]                           computeRestarts <- base::computeRestarts
[09:31:18.450]                           grepl <- base::grepl
[09:31:18.450]                           restarts <- computeRestarts(cond)
[09:31:18.450]                           for (restart in restarts) {
[09:31:18.450]                             name <- restart$name
[09:31:18.450]                             if (is.null(name)) 
[09:31:18.450]                               next
[09:31:18.450]                             if (!grepl(pattern, name)) 
[09:31:18.450]                               next
[09:31:18.450]                             invokeRestart(restart)
[09:31:18.450]                             muffled <- TRUE
[09:31:18.450]                             break
[09:31:18.450]                           }
[09:31:18.450]                         }
[09:31:18.450]                       }
[09:31:18.450]                       invisible(muffled)
[09:31:18.450]                     }
[09:31:18.450]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.450]                   }
[09:31:18.450]                 }
[09:31:18.450]             }
[09:31:18.450]         }))
[09:31:18.450]     }, error = function(ex) {
[09:31:18.450]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.450]                 ...future.rng), started = ...future.startTime, 
[09:31:18.450]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.450]             version = "1.8"), class = "FutureResult")
[09:31:18.450]     }, finally = {
[09:31:18.450]         if (!identical(...future.workdir, getwd())) 
[09:31:18.450]             setwd(...future.workdir)
[09:31:18.450]         {
[09:31:18.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.450]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.450]             }
[09:31:18.450]             base::options(...future.oldOptions)
[09:31:18.450]             if (.Platform$OS.type == "windows") {
[09:31:18.450]                 old_names <- names(...future.oldEnvVars)
[09:31:18.450]                 envs <- base::Sys.getenv()
[09:31:18.450]                 names <- names(envs)
[09:31:18.450]                 common <- intersect(names, old_names)
[09:31:18.450]                 added <- setdiff(names, old_names)
[09:31:18.450]                 removed <- setdiff(old_names, names)
[09:31:18.450]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.450]                   envs[common]]
[09:31:18.450]                 NAMES <- toupper(changed)
[09:31:18.450]                 args <- list()
[09:31:18.450]                 for (kk in seq_along(NAMES)) {
[09:31:18.450]                   name <- changed[[kk]]
[09:31:18.450]                   NAME <- NAMES[[kk]]
[09:31:18.450]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.450]                     next
[09:31:18.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.450]                 }
[09:31:18.450]                 NAMES <- toupper(added)
[09:31:18.450]                 for (kk in seq_along(NAMES)) {
[09:31:18.450]                   name <- added[[kk]]
[09:31:18.450]                   NAME <- NAMES[[kk]]
[09:31:18.450]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.450]                     next
[09:31:18.450]                   args[[name]] <- ""
[09:31:18.450]                 }
[09:31:18.450]                 NAMES <- toupper(removed)
[09:31:18.450]                 for (kk in seq_along(NAMES)) {
[09:31:18.450]                   name <- removed[[kk]]
[09:31:18.450]                   NAME <- NAMES[[kk]]
[09:31:18.450]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.450]                     next
[09:31:18.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.450]                 }
[09:31:18.450]                 if (length(args) > 0) 
[09:31:18.450]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.450]             }
[09:31:18.450]             else {
[09:31:18.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.450]             }
[09:31:18.450]             {
[09:31:18.450]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.450]                   0L) {
[09:31:18.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.450]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.450]                   base::options(opts)
[09:31:18.450]                 }
[09:31:18.450]                 {
[09:31:18.450]                   {
[09:31:18.450]                     NULL
[09:31:18.450]                     RNGkind("Mersenne-Twister")
[09:31:18.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.450]                       inherits = FALSE)
[09:31:18.450]                   }
[09:31:18.450]                   options(future.plan = NULL)
[09:31:18.450]                   if (is.na(NA_character_)) 
[09:31:18.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.450]                     .init = FALSE)
[09:31:18.450]                 }
[09:31:18.450]             }
[09:31:18.450]         }
[09:31:18.450]     })
[09:31:18.450]     if (TRUE) {
[09:31:18.450]         base::sink(type = "output", split = FALSE)
[09:31:18.450]         if (TRUE) {
[09:31:18.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.450]         }
[09:31:18.450]         else {
[09:31:18.450]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.450]         }
[09:31:18.450]         base::close(...future.stdout)
[09:31:18.450]         ...future.stdout <- NULL
[09:31:18.450]     }
[09:31:18.450]     ...future.result$conditions <- ...future.conditions
[09:31:18.450]     ...future.result$finished <- base::Sys.time()
[09:31:18.450]     ...future.result
[09:31:18.450] }
[09:31:18.452] assign_globals() ...
[09:31:18.452] List of 3
[09:31:18.452]  $ outer_function:function (x)  
[09:31:18.452]  $ map           :function (.x, .f, ...)  
[09:31:18.452]  $ inner_function:function (x)  
[09:31:18.452]  - attr(*, "where")=List of 3
[09:31:18.452]   ..$ outer_function:<environment: R_EmptyEnv> 
[09:31:18.452]   ..$ map           :<environment: R_EmptyEnv> 
[09:31:18.452]   ..$ inner_function:<environment: R_EmptyEnv> 
[09:31:18.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.452]  - attr(*, "resolved")= logi FALSE
[09:31:18.452]  - attr(*, "total_size")= num 7704
[09:31:18.452]  - attr(*, "already-done")= logi TRUE
[09:31:18.455] - reassign environment for ‘outer_function’
[09:31:18.455] - copied ‘outer_function’ to environment
[09:31:18.455] - reassign environment for ‘map’
[09:31:18.455] - copied ‘map’ to environment
[09:31:18.455] - reassign environment for ‘inner_function’
[09:31:18.455] - copied ‘inner_function’ to environment
[09:31:18.455] assign_globals() ... done
[09:31:18.455] plan(): Setting new future strategy stack:
[09:31:18.456] List of future strategies:
[09:31:18.456] 1. sequential:
[09:31:18.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.456]    - tweaked: FALSE
[09:31:18.456]    - call: NULL
[09:31:18.456] plan(): nbrOfWorkers() = 1
[09:31:18.462] plan(): Setting new future strategy stack:
[09:31:18.462] List of future strategies:
[09:31:18.462] 1. sequential:
[09:31:18.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.462]    - tweaked: FALSE
[09:31:18.462]    - call: plan(strategy)
[09:31:18.462] plan(): nbrOfWorkers() = 1
[09:31:18.462] SequentialFuture started (and completed)
[09:31:18.462] - Launch lazy future ... done
[09:31:18.462] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[09:31:18.464] getGlobalsAndPackages() ...
[09:31:18.464] Searching for globals...
[09:31:18.467] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[09:31:18.468] Searching for globals ... DONE
[09:31:18.468] Resolving globals: FALSE
[09:31:18.468] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[09:31:18.469] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[09:31:18.469] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[09:31:18.469] 
[09:31:18.469] getGlobalsAndPackages() ... DONE
[09:31:18.469] run() for ‘Future’ ...
[09:31:18.469] - state: ‘created’
[09:31:18.469] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:18.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:18.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:18.470]   - Field: ‘label’
[09:31:18.470]   - Field: ‘local’
[09:31:18.470]   - Field: ‘owner’
[09:31:18.470]   - Field: ‘envir’
[09:31:18.470]   - Field: ‘packages’
[09:31:18.470]   - Field: ‘gc’
[09:31:18.470]   - Field: ‘conditions’
[09:31:18.470]   - Field: ‘expr’
[09:31:18.471]   - Field: ‘uuid’
[09:31:18.471]   - Field: ‘seed’
[09:31:18.471]   - Field: ‘version’
[09:31:18.471]   - Field: ‘result’
[09:31:18.471]   - Field: ‘asynchronous’
[09:31:18.471]   - Field: ‘calls’
[09:31:18.471]   - Field: ‘globals’
[09:31:18.471]   - Field: ‘stdout’
[09:31:18.471]   - Field: ‘earlySignal’
[09:31:18.471]   - Field: ‘lazy’
[09:31:18.471]   - Field: ‘state’
[09:31:18.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:18.472] - Launch lazy future ...
[09:31:18.472] Packages needed by the future expression (n = 0): <none>
[09:31:18.472] Packages needed by future strategies (n = 0): <none>
[09:31:18.472] {
[09:31:18.472]     {
[09:31:18.472]         {
[09:31:18.472]             ...future.startTime <- base::Sys.time()
[09:31:18.472]             {
[09:31:18.472]                 {
[09:31:18.472]                   {
[09:31:18.472]                     base::local({
[09:31:18.472]                       has_future <- base::requireNamespace("future", 
[09:31:18.472]                         quietly = TRUE)
[09:31:18.472]                       if (has_future) {
[09:31:18.472]                         ns <- base::getNamespace("future")
[09:31:18.472]                         version <- ns[[".package"]][["version"]]
[09:31:18.472]                         if (is.null(version)) 
[09:31:18.472]                           version <- utils::packageVersion("future")
[09:31:18.472]                       }
[09:31:18.472]                       else {
[09:31:18.472]                         version <- NULL
[09:31:18.472]                       }
[09:31:18.472]                       if (!has_future || version < "1.8.0") {
[09:31:18.472]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.472]                           "", base::R.version$version.string), 
[09:31:18.472]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:18.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.472]                             "release", "version")], collapse = " "), 
[09:31:18.472]                           hostname = base::Sys.info()[["nodename"]])
[09:31:18.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.472]                           info)
[09:31:18.472]                         info <- base::paste(info, collapse = "; ")
[09:31:18.472]                         if (!has_future) {
[09:31:18.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.472]                             info)
[09:31:18.472]                         }
[09:31:18.472]                         else {
[09:31:18.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.472]                             info, version)
[09:31:18.472]                         }
[09:31:18.472]                         base::stop(msg)
[09:31:18.472]                       }
[09:31:18.472]                     })
[09:31:18.472]                   }
[09:31:18.472]                   ...future.strategy.old <- future::plan("list")
[09:31:18.472]                   options(future.plan = NULL)
[09:31:18.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.472]                 }
[09:31:18.472]                 ...future.workdir <- getwd()
[09:31:18.472]             }
[09:31:18.472]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.472]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.472]         }
[09:31:18.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.472]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.472]             base::names(...future.oldOptions))
[09:31:18.472]     }
[09:31:18.472]     if (FALSE) {
[09:31:18.472]     }
[09:31:18.472]     else {
[09:31:18.472]         if (TRUE) {
[09:31:18.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.472]                 open = "w")
[09:31:18.472]         }
[09:31:18.472]         else {
[09:31:18.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.472]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.472]         }
[09:31:18.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.472]             base::sink(type = "output", split = FALSE)
[09:31:18.472]             base::close(...future.stdout)
[09:31:18.472]         }, add = TRUE)
[09:31:18.472]     }
[09:31:18.472]     ...future.frame <- base::sys.nframe()
[09:31:18.472]     ...future.conditions <- base::list()
[09:31:18.472]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.472]     if (FALSE) {
[09:31:18.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.472]     }
[09:31:18.472]     ...future.result <- base::tryCatch({
[09:31:18.472]         base::withCallingHandlers({
[09:31:18.472]             ...future.value <- base::withVisible(base::local({
[09:31:18.472]                 outer_function(1L)
[09:31:18.472]             }))
[09:31:18.472]             future::FutureResult(value = ...future.value$value, 
[09:31:18.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.472]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.472]                     ...future.globalenv.names))
[09:31:18.472]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.472]         }, condition = base::local({
[09:31:18.472]             c <- base::c
[09:31:18.472]             inherits <- base::inherits
[09:31:18.472]             invokeRestart <- base::invokeRestart
[09:31:18.472]             length <- base::length
[09:31:18.472]             list <- base::list
[09:31:18.472]             seq.int <- base::seq.int
[09:31:18.472]             signalCondition <- base::signalCondition
[09:31:18.472]             sys.calls <- base::sys.calls
[09:31:18.472]             `[[` <- base::`[[`
[09:31:18.472]             `+` <- base::`+`
[09:31:18.472]             `<<-` <- base::`<<-`
[09:31:18.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.472]                   3L)]
[09:31:18.472]             }
[09:31:18.472]             function(cond) {
[09:31:18.472]                 is_error <- inherits(cond, "error")
[09:31:18.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.472]                   NULL)
[09:31:18.472]                 if (is_error) {
[09:31:18.472]                   sessionInformation <- function() {
[09:31:18.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.472]                       search = base::search(), system = base::Sys.info())
[09:31:18.472]                   }
[09:31:18.472]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.472]                     cond$call), session = sessionInformation(), 
[09:31:18.472]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.472]                   signalCondition(cond)
[09:31:18.472]                 }
[09:31:18.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.472]                 "immediateCondition"))) {
[09:31:18.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.472]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.472]                   if (TRUE && !signal) {
[09:31:18.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.472]                     {
[09:31:18.472]                       inherits <- base::inherits
[09:31:18.472]                       invokeRestart <- base::invokeRestart
[09:31:18.472]                       is.null <- base::is.null
[09:31:18.472]                       muffled <- FALSE
[09:31:18.472]                       if (inherits(cond, "message")) {
[09:31:18.472]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.472]                         if (muffled) 
[09:31:18.472]                           invokeRestart("muffleMessage")
[09:31:18.472]                       }
[09:31:18.472]                       else if (inherits(cond, "warning")) {
[09:31:18.472]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.472]                         if (muffled) 
[09:31:18.472]                           invokeRestart("muffleWarning")
[09:31:18.472]                       }
[09:31:18.472]                       else if (inherits(cond, "condition")) {
[09:31:18.472]                         if (!is.null(pattern)) {
[09:31:18.472]                           computeRestarts <- base::computeRestarts
[09:31:18.472]                           grepl <- base::grepl
[09:31:18.472]                           restarts <- computeRestarts(cond)
[09:31:18.472]                           for (restart in restarts) {
[09:31:18.472]                             name <- restart$name
[09:31:18.472]                             if (is.null(name)) 
[09:31:18.472]                               next
[09:31:18.472]                             if (!grepl(pattern, name)) 
[09:31:18.472]                               next
[09:31:18.472]                             invokeRestart(restart)
[09:31:18.472]                             muffled <- TRUE
[09:31:18.472]                             break
[09:31:18.472]                           }
[09:31:18.472]                         }
[09:31:18.472]                       }
[09:31:18.472]                       invisible(muffled)
[09:31:18.472]                     }
[09:31:18.472]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.472]                   }
[09:31:18.472]                 }
[09:31:18.472]                 else {
[09:31:18.472]                   if (TRUE) {
[09:31:18.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.472]                     {
[09:31:18.472]                       inherits <- base::inherits
[09:31:18.472]                       invokeRestart <- base::invokeRestart
[09:31:18.472]                       is.null <- base::is.null
[09:31:18.472]                       muffled <- FALSE
[09:31:18.472]                       if (inherits(cond, "message")) {
[09:31:18.472]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.472]                         if (muffled) 
[09:31:18.472]                           invokeRestart("muffleMessage")
[09:31:18.472]                       }
[09:31:18.472]                       else if (inherits(cond, "warning")) {
[09:31:18.472]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.472]                         if (muffled) 
[09:31:18.472]                           invokeRestart("muffleWarning")
[09:31:18.472]                       }
[09:31:18.472]                       else if (inherits(cond, "condition")) {
[09:31:18.472]                         if (!is.null(pattern)) {
[09:31:18.472]                           computeRestarts <- base::computeRestarts
[09:31:18.472]                           grepl <- base::grepl
[09:31:18.472]                           restarts <- computeRestarts(cond)
[09:31:18.472]                           for (restart in restarts) {
[09:31:18.472]                             name <- restart$name
[09:31:18.472]                             if (is.null(name)) 
[09:31:18.472]                               next
[09:31:18.472]                             if (!grepl(pattern, name)) 
[09:31:18.472]                               next
[09:31:18.472]                             invokeRestart(restart)
[09:31:18.472]                             muffled <- TRUE
[09:31:18.472]                             break
[09:31:18.472]                           }
[09:31:18.472]                         }
[09:31:18.472]                       }
[09:31:18.472]                       invisible(muffled)
[09:31:18.472]                     }
[09:31:18.472]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.472]                   }
[09:31:18.472]                 }
[09:31:18.472]             }
[09:31:18.472]         }))
[09:31:18.472]     }, error = function(ex) {
[09:31:18.472]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.472]                 ...future.rng), started = ...future.startTime, 
[09:31:18.472]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.472]             version = "1.8"), class = "FutureResult")
[09:31:18.472]     }, finally = {
[09:31:18.472]         if (!identical(...future.workdir, getwd())) 
[09:31:18.472]             setwd(...future.workdir)
[09:31:18.472]         {
[09:31:18.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.472]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.472]             }
[09:31:18.472]             base::options(...future.oldOptions)
[09:31:18.472]             if (.Platform$OS.type == "windows") {
[09:31:18.472]                 old_names <- names(...future.oldEnvVars)
[09:31:18.472]                 envs <- base::Sys.getenv()
[09:31:18.472]                 names <- names(envs)
[09:31:18.472]                 common <- intersect(names, old_names)
[09:31:18.472]                 added <- setdiff(names, old_names)
[09:31:18.472]                 removed <- setdiff(old_names, names)
[09:31:18.472]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.472]                   envs[common]]
[09:31:18.472]                 NAMES <- toupper(changed)
[09:31:18.472]                 args <- list()
[09:31:18.472]                 for (kk in seq_along(NAMES)) {
[09:31:18.472]                   name <- changed[[kk]]
[09:31:18.472]                   NAME <- NAMES[[kk]]
[09:31:18.472]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.472]                     next
[09:31:18.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.472]                 }
[09:31:18.472]                 NAMES <- toupper(added)
[09:31:18.472]                 for (kk in seq_along(NAMES)) {
[09:31:18.472]                   name <- added[[kk]]
[09:31:18.472]                   NAME <- NAMES[[kk]]
[09:31:18.472]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.472]                     next
[09:31:18.472]                   args[[name]] <- ""
[09:31:18.472]                 }
[09:31:18.472]                 NAMES <- toupper(removed)
[09:31:18.472]                 for (kk in seq_along(NAMES)) {
[09:31:18.472]                   name <- removed[[kk]]
[09:31:18.472]                   NAME <- NAMES[[kk]]
[09:31:18.472]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.472]                     next
[09:31:18.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.472]                 }
[09:31:18.472]                 if (length(args) > 0) 
[09:31:18.472]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.472]             }
[09:31:18.472]             else {
[09:31:18.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.472]             }
[09:31:18.472]             {
[09:31:18.472]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.472]                   0L) {
[09:31:18.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.472]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.472]                   base::options(opts)
[09:31:18.472]                 }
[09:31:18.472]                 {
[09:31:18.472]                   {
[09:31:18.472]                     NULL
[09:31:18.472]                     RNGkind("Mersenne-Twister")
[09:31:18.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:18.472]                       inherits = FALSE)
[09:31:18.472]                   }
[09:31:18.472]                   options(future.plan = NULL)
[09:31:18.472]                   if (is.na(NA_character_)) 
[09:31:18.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.472]                     .init = FALSE)
[09:31:18.472]                 }
[09:31:18.472]             }
[09:31:18.472]         }
[09:31:18.472]     })
[09:31:18.472]     if (TRUE) {
[09:31:18.472]         base::sink(type = "output", split = FALSE)
[09:31:18.472]         if (TRUE) {
[09:31:18.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.472]         }
[09:31:18.472]         else {
[09:31:18.472]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.472]         }
[09:31:18.472]         base::close(...future.stdout)
[09:31:18.472]         ...future.stdout <- NULL
[09:31:18.472]     }
[09:31:18.472]     ...future.result$conditions <- ...future.conditions
[09:31:18.472]     ...future.result$finished <- base::Sys.time()
[09:31:18.472]     ...future.result
[09:31:18.472] }
[09:31:18.474] assign_globals() ...
[09:31:18.474] List of 3
[09:31:18.474]  $ outer_function:function (x)  
[09:31:18.474]  $ map           :function (.x, .f, ...)  
[09:31:18.474]  $ inner_function:function (x)  
[09:31:18.474]  - attr(*, "where")=List of 3
[09:31:18.474]   ..$ outer_function:<environment: R_EmptyEnv> 
[09:31:18.474]   ..$ map           :<environment: R_EmptyEnv> 
[09:31:18.474]   ..$ inner_function:<environment: R_EmptyEnv> 
[09:31:18.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.474]  - attr(*, "resolved")= logi FALSE
[09:31:18.474]  - attr(*, "total_size")= num 7704
[09:31:18.474]  - attr(*, "already-done")= logi TRUE
[09:31:18.477] - reassign environment for ‘outer_function’
[09:31:18.477] - copied ‘outer_function’ to environment
[09:31:18.477] - reassign environment for ‘map’
[09:31:18.477] - copied ‘map’ to environment
[09:31:18.477] - reassign environment for ‘inner_function’
[09:31:18.477] - copied ‘inner_function’ to environment
[09:31:18.477] assign_globals() ... done
[09:31:18.478] plan(): Setting new future strategy stack:
[09:31:18.478] List of future strategies:
[09:31:18.478] 1. sequential:
[09:31:18.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.478]    - tweaked: FALSE
[09:31:18.478]    - call: NULL
[09:31:18.478] plan(): nbrOfWorkers() = 1
[09:31:18.479] plan(): Setting new future strategy stack:
[09:31:18.479] List of future strategies:
[09:31:18.479] 1. sequential:
[09:31:18.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.479]    - tweaked: FALSE
[09:31:18.479]    - call: plan(strategy)
[09:31:18.479] plan(): nbrOfWorkers() = 1
[09:31:18.479] SequentialFuture started (and completed)
[09:31:18.480] - Launch lazy future ... done
[09:31:18.480] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[09:31:18.489] plan(): Setting new future strategy stack:
[09:31:18.489] List of future strategies:
[09:31:18.489] 1. multicore:
[09:31:18.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.489]    - tweaked: FALSE
[09:31:18.489]    - call: plan(strategy)
[09:31:18.493] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[09:31:18.493] getGlobalsAndPackages() ...
[09:31:18.493] Searching for globals...
[09:31:18.495] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.495] Searching for globals ... DONE
[09:31:18.495] Resolving globals: FALSE
[09:31:18.495] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.496] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.496] - globals: [2] ‘weight’, ‘group’
[09:31:18.496] - packages: [1] ‘stats’
[09:31:18.496] getGlobalsAndPackages() ... DONE
[09:31:18.496] run() for ‘Future’ ...
[09:31:18.496] - state: ‘created’
[09:31:18.496] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.500]   - Field: ‘label’
[09:31:18.500]   - Field: ‘local’
[09:31:18.500]   - Field: ‘owner’
[09:31:18.500]   - Field: ‘envir’
[09:31:18.500]   - Field: ‘workers’
[09:31:18.500]   - Field: ‘packages’
[09:31:18.501]   - Field: ‘gc’
[09:31:18.501]   - Field: ‘job’
[09:31:18.501]   - Field: ‘conditions’
[09:31:18.501]   - Field: ‘expr’
[09:31:18.501]   - Field: ‘uuid’
[09:31:18.501]   - Field: ‘seed’
[09:31:18.501]   - Field: ‘version’
[09:31:18.501]   - Field: ‘result’
[09:31:18.501]   - Field: ‘asynchronous’
[09:31:18.501]   - Field: ‘calls’
[09:31:18.501]   - Field: ‘globals’
[09:31:18.501]   - Field: ‘stdout’
[09:31:18.502]   - Field: ‘earlySignal’
[09:31:18.502]   - Field: ‘lazy’
[09:31:18.502]   - Field: ‘state’
[09:31:18.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.502] - Launch lazy future ...
[09:31:18.503] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.503] Packages needed by future strategies (n = 0): <none>
[09:31:18.503] {
[09:31:18.503]     {
[09:31:18.503]         {
[09:31:18.503]             ...future.startTime <- base::Sys.time()
[09:31:18.503]             {
[09:31:18.503]                 {
[09:31:18.503]                   {
[09:31:18.503]                     {
[09:31:18.503]                       {
[09:31:18.503]                         base::local({
[09:31:18.503]                           has_future <- base::requireNamespace("future", 
[09:31:18.503]                             quietly = TRUE)
[09:31:18.503]                           if (has_future) {
[09:31:18.503]                             ns <- base::getNamespace("future")
[09:31:18.503]                             version <- ns[[".package"]][["version"]]
[09:31:18.503]                             if (is.null(version)) 
[09:31:18.503]                               version <- utils::packageVersion("future")
[09:31:18.503]                           }
[09:31:18.503]                           else {
[09:31:18.503]                             version <- NULL
[09:31:18.503]                           }
[09:31:18.503]                           if (!has_future || version < "1.8.0") {
[09:31:18.503]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.503]                               "", base::R.version$version.string), 
[09:31:18.503]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.503]                                 base::R.version$platform, 8 * 
[09:31:18.503]                                   base::.Machine$sizeof.pointer), 
[09:31:18.503]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.503]                                 "release", "version")], collapse = " "), 
[09:31:18.503]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.503]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.503]                               info)
[09:31:18.503]                             info <- base::paste(info, collapse = "; ")
[09:31:18.503]                             if (!has_future) {
[09:31:18.503]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.503]                                 info)
[09:31:18.503]                             }
[09:31:18.503]                             else {
[09:31:18.503]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.503]                                 info, version)
[09:31:18.503]                             }
[09:31:18.503]                             base::stop(msg)
[09:31:18.503]                           }
[09:31:18.503]                         })
[09:31:18.503]                       }
[09:31:18.503]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.503]                       base::options(mc.cores = 1L)
[09:31:18.503]                     }
[09:31:18.503]                     base::local({
[09:31:18.503]                       for (pkg in "stats") {
[09:31:18.503]                         base::loadNamespace(pkg)
[09:31:18.503]                         base::library(pkg, character.only = TRUE)
[09:31:18.503]                       }
[09:31:18.503]                     })
[09:31:18.503]                   }
[09:31:18.503]                   ...future.strategy.old <- future::plan("list")
[09:31:18.503]                   options(future.plan = NULL)
[09:31:18.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.503]                 }
[09:31:18.503]                 ...future.workdir <- getwd()
[09:31:18.503]             }
[09:31:18.503]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.503]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.503]         }
[09:31:18.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.503]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.503]             base::names(...future.oldOptions))
[09:31:18.503]     }
[09:31:18.503]     if (FALSE) {
[09:31:18.503]     }
[09:31:18.503]     else {
[09:31:18.503]         if (TRUE) {
[09:31:18.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.503]                 open = "w")
[09:31:18.503]         }
[09:31:18.503]         else {
[09:31:18.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.503]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.503]         }
[09:31:18.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.503]             base::sink(type = "output", split = FALSE)
[09:31:18.503]             base::close(...future.stdout)
[09:31:18.503]         }, add = TRUE)
[09:31:18.503]     }
[09:31:18.503]     ...future.frame <- base::sys.nframe()
[09:31:18.503]     ...future.conditions <- base::list()
[09:31:18.503]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.503]     if (FALSE) {
[09:31:18.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.503]     }
[09:31:18.503]     ...future.result <- base::tryCatch({
[09:31:18.503]         base::withCallingHandlers({
[09:31:18.503]             ...future.value <- base::withVisible(base::local({
[09:31:18.503]                 withCallingHandlers({
[09:31:18.503]                   {
[09:31:18.503]                     lm(weight ~ group - 1)
[09:31:18.503]                   }
[09:31:18.503]                 }, immediateCondition = function(cond) {
[09:31:18.503]                   save_rds <- function (object, pathname, ...) 
[09:31:18.503]                   {
[09:31:18.503]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.503]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.503]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.503]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.503]                         fi_tmp[["mtime"]])
[09:31:18.503]                     }
[09:31:18.503]                     tryCatch({
[09:31:18.503]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.503]                     }, error = function(ex) {
[09:31:18.503]                       msg <- conditionMessage(ex)
[09:31:18.503]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.503]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.503]                         fi_tmp[["mtime"]], msg)
[09:31:18.503]                       ex$message <- msg
[09:31:18.503]                       stop(ex)
[09:31:18.503]                     })
[09:31:18.503]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.503]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.503]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.503]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.503]                       fi <- file.info(pathname)
[09:31:18.503]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.503]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.503]                         fi[["size"]], fi[["mtime"]])
[09:31:18.503]                       stop(msg)
[09:31:18.503]                     }
[09:31:18.503]                     invisible(pathname)
[09:31:18.503]                   }
[09:31:18.503]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.503]                     rootPath = tempdir()) 
[09:31:18.503]                   {
[09:31:18.503]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.503]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.503]                       tmpdir = path, fileext = ".rds")
[09:31:18.503]                     save_rds(obj, file)
[09:31:18.503]                   }
[09:31:18.503]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.503]                   {
[09:31:18.503]                     inherits <- base::inherits
[09:31:18.503]                     invokeRestart <- base::invokeRestart
[09:31:18.503]                     is.null <- base::is.null
[09:31:18.503]                     muffled <- FALSE
[09:31:18.503]                     if (inherits(cond, "message")) {
[09:31:18.503]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.503]                       if (muffled) 
[09:31:18.503]                         invokeRestart("muffleMessage")
[09:31:18.503]                     }
[09:31:18.503]                     else if (inherits(cond, "warning")) {
[09:31:18.503]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.503]                       if (muffled) 
[09:31:18.503]                         invokeRestart("muffleWarning")
[09:31:18.503]                     }
[09:31:18.503]                     else if (inherits(cond, "condition")) {
[09:31:18.503]                       if (!is.null(pattern)) {
[09:31:18.503]                         computeRestarts <- base::computeRestarts
[09:31:18.503]                         grepl <- base::grepl
[09:31:18.503]                         restarts <- computeRestarts(cond)
[09:31:18.503]                         for (restart in restarts) {
[09:31:18.503]                           name <- restart$name
[09:31:18.503]                           if (is.null(name)) 
[09:31:18.503]                             next
[09:31:18.503]                           if (!grepl(pattern, name)) 
[09:31:18.503]                             next
[09:31:18.503]                           invokeRestart(restart)
[09:31:18.503]                           muffled <- TRUE
[09:31:18.503]                           break
[09:31:18.503]                         }
[09:31:18.503]                       }
[09:31:18.503]                     }
[09:31:18.503]                     invisible(muffled)
[09:31:18.503]                   }
[09:31:18.503]                   muffleCondition(cond)
[09:31:18.503]                 })
[09:31:18.503]             }))
[09:31:18.503]             future::FutureResult(value = ...future.value$value, 
[09:31:18.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.503]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.503]                     ...future.globalenv.names))
[09:31:18.503]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.503]         }, condition = base::local({
[09:31:18.503]             c <- base::c
[09:31:18.503]             inherits <- base::inherits
[09:31:18.503]             invokeRestart <- base::invokeRestart
[09:31:18.503]             length <- base::length
[09:31:18.503]             list <- base::list
[09:31:18.503]             seq.int <- base::seq.int
[09:31:18.503]             signalCondition <- base::signalCondition
[09:31:18.503]             sys.calls <- base::sys.calls
[09:31:18.503]             `[[` <- base::`[[`
[09:31:18.503]             `+` <- base::`+`
[09:31:18.503]             `<<-` <- base::`<<-`
[09:31:18.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.503]                   3L)]
[09:31:18.503]             }
[09:31:18.503]             function(cond) {
[09:31:18.503]                 is_error <- inherits(cond, "error")
[09:31:18.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.503]                   NULL)
[09:31:18.503]                 if (is_error) {
[09:31:18.503]                   sessionInformation <- function() {
[09:31:18.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.503]                       search = base::search(), system = base::Sys.info())
[09:31:18.503]                   }
[09:31:18.503]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.503]                     cond$call), session = sessionInformation(), 
[09:31:18.503]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.503]                   signalCondition(cond)
[09:31:18.503]                 }
[09:31:18.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.503]                 "immediateCondition"))) {
[09:31:18.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.503]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.503]                   if (TRUE && !signal) {
[09:31:18.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.503]                     {
[09:31:18.503]                       inherits <- base::inherits
[09:31:18.503]                       invokeRestart <- base::invokeRestart
[09:31:18.503]                       is.null <- base::is.null
[09:31:18.503]                       muffled <- FALSE
[09:31:18.503]                       if (inherits(cond, "message")) {
[09:31:18.503]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.503]                         if (muffled) 
[09:31:18.503]                           invokeRestart("muffleMessage")
[09:31:18.503]                       }
[09:31:18.503]                       else if (inherits(cond, "warning")) {
[09:31:18.503]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.503]                         if (muffled) 
[09:31:18.503]                           invokeRestart("muffleWarning")
[09:31:18.503]                       }
[09:31:18.503]                       else if (inherits(cond, "condition")) {
[09:31:18.503]                         if (!is.null(pattern)) {
[09:31:18.503]                           computeRestarts <- base::computeRestarts
[09:31:18.503]                           grepl <- base::grepl
[09:31:18.503]                           restarts <- computeRestarts(cond)
[09:31:18.503]                           for (restart in restarts) {
[09:31:18.503]                             name <- restart$name
[09:31:18.503]                             if (is.null(name)) 
[09:31:18.503]                               next
[09:31:18.503]                             if (!grepl(pattern, name)) 
[09:31:18.503]                               next
[09:31:18.503]                             invokeRestart(restart)
[09:31:18.503]                             muffled <- TRUE
[09:31:18.503]                             break
[09:31:18.503]                           }
[09:31:18.503]                         }
[09:31:18.503]                       }
[09:31:18.503]                       invisible(muffled)
[09:31:18.503]                     }
[09:31:18.503]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.503]                   }
[09:31:18.503]                 }
[09:31:18.503]                 else {
[09:31:18.503]                   if (TRUE) {
[09:31:18.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.503]                     {
[09:31:18.503]                       inherits <- base::inherits
[09:31:18.503]                       invokeRestart <- base::invokeRestart
[09:31:18.503]                       is.null <- base::is.null
[09:31:18.503]                       muffled <- FALSE
[09:31:18.503]                       if (inherits(cond, "message")) {
[09:31:18.503]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.503]                         if (muffled) 
[09:31:18.503]                           invokeRestart("muffleMessage")
[09:31:18.503]                       }
[09:31:18.503]                       else if (inherits(cond, "warning")) {
[09:31:18.503]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.503]                         if (muffled) 
[09:31:18.503]                           invokeRestart("muffleWarning")
[09:31:18.503]                       }
[09:31:18.503]                       else if (inherits(cond, "condition")) {
[09:31:18.503]                         if (!is.null(pattern)) {
[09:31:18.503]                           computeRestarts <- base::computeRestarts
[09:31:18.503]                           grepl <- base::grepl
[09:31:18.503]                           restarts <- computeRestarts(cond)
[09:31:18.503]                           for (restart in restarts) {
[09:31:18.503]                             name <- restart$name
[09:31:18.503]                             if (is.null(name)) 
[09:31:18.503]                               next
[09:31:18.503]                             if (!grepl(pattern, name)) 
[09:31:18.503]                               next
[09:31:18.503]                             invokeRestart(restart)
[09:31:18.503]                             muffled <- TRUE
[09:31:18.503]                             break
[09:31:18.503]                           }
[09:31:18.503]                         }
[09:31:18.503]                       }
[09:31:18.503]                       invisible(muffled)
[09:31:18.503]                     }
[09:31:18.503]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.503]                   }
[09:31:18.503]                 }
[09:31:18.503]             }
[09:31:18.503]         }))
[09:31:18.503]     }, error = function(ex) {
[09:31:18.503]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.503]                 ...future.rng), started = ...future.startTime, 
[09:31:18.503]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.503]             version = "1.8"), class = "FutureResult")
[09:31:18.503]     }, finally = {
[09:31:18.503]         if (!identical(...future.workdir, getwd())) 
[09:31:18.503]             setwd(...future.workdir)
[09:31:18.503]         {
[09:31:18.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.503]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.503]             }
[09:31:18.503]             base::options(...future.oldOptions)
[09:31:18.503]             if (.Platform$OS.type == "windows") {
[09:31:18.503]                 old_names <- names(...future.oldEnvVars)
[09:31:18.503]                 envs <- base::Sys.getenv()
[09:31:18.503]                 names <- names(envs)
[09:31:18.503]                 common <- intersect(names, old_names)
[09:31:18.503]                 added <- setdiff(names, old_names)
[09:31:18.503]                 removed <- setdiff(old_names, names)
[09:31:18.503]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.503]                   envs[common]]
[09:31:18.503]                 NAMES <- toupper(changed)
[09:31:18.503]                 args <- list()
[09:31:18.503]                 for (kk in seq_along(NAMES)) {
[09:31:18.503]                   name <- changed[[kk]]
[09:31:18.503]                   NAME <- NAMES[[kk]]
[09:31:18.503]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.503]                     next
[09:31:18.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.503]                 }
[09:31:18.503]                 NAMES <- toupper(added)
[09:31:18.503]                 for (kk in seq_along(NAMES)) {
[09:31:18.503]                   name <- added[[kk]]
[09:31:18.503]                   NAME <- NAMES[[kk]]
[09:31:18.503]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.503]                     next
[09:31:18.503]                   args[[name]] <- ""
[09:31:18.503]                 }
[09:31:18.503]                 NAMES <- toupper(removed)
[09:31:18.503]                 for (kk in seq_along(NAMES)) {
[09:31:18.503]                   name <- removed[[kk]]
[09:31:18.503]                   NAME <- NAMES[[kk]]
[09:31:18.503]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.503]                     next
[09:31:18.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.503]                 }
[09:31:18.503]                 if (length(args) > 0) 
[09:31:18.503]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.503]             }
[09:31:18.503]             else {
[09:31:18.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.503]             }
[09:31:18.503]             {
[09:31:18.503]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.503]                   0L) {
[09:31:18.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.503]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.503]                   base::options(opts)
[09:31:18.503]                 }
[09:31:18.503]                 {
[09:31:18.503]                   {
[09:31:18.503]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.503]                     NULL
[09:31:18.503]                   }
[09:31:18.503]                   options(future.plan = NULL)
[09:31:18.503]                   if (is.na(NA_character_)) 
[09:31:18.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.503]                     .init = FALSE)
[09:31:18.503]                 }
[09:31:18.503]             }
[09:31:18.503]         }
[09:31:18.503]     })
[09:31:18.503]     if (TRUE) {
[09:31:18.503]         base::sink(type = "output", split = FALSE)
[09:31:18.503]         if (TRUE) {
[09:31:18.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.503]         }
[09:31:18.503]         else {
[09:31:18.503]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.503]         }
[09:31:18.503]         base::close(...future.stdout)
[09:31:18.503]         ...future.stdout <- NULL
[09:31:18.503]     }
[09:31:18.503]     ...future.result$conditions <- ...future.conditions
[09:31:18.503]     ...future.result$finished <- base::Sys.time()
[09:31:18.503]     ...future.result
[09:31:18.503] }
[09:31:18.505] assign_globals() ...
[09:31:18.506] List of 2
[09:31:18.506]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.506]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.506]  - attr(*, "where")=List of 2
[09:31:18.506]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.506]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.506]  - attr(*, "resolved")= logi FALSE
[09:31:18.506]  - attr(*, "total_size")= num 896
[09:31:18.506]  - attr(*, "already-done")= logi TRUE
[09:31:18.508] - copied ‘weight’ to environment
[09:31:18.509] - copied ‘group’ to environment
[09:31:18.509] assign_globals() ... done
[09:31:18.509] requestCore(): workers = 2
[09:31:18.512] MulticoreFuture started
[09:31:18.516] - Launch lazy future ... done
[09:31:18.516] run() for ‘MulticoreFuture’ ... done
[09:31:18.517] plan(): Setting new future strategy stack:
[09:31:18.517] result() for MulticoreFuture ...
[09:31:18.517] List of future strategies:
[09:31:18.517] 1. sequential:
[09:31:18.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.517]    - tweaked: FALSE
[09:31:18.517]    - call: NULL
[09:31:18.518] plan(): nbrOfWorkers() = 1
[09:31:18.522] plan(): Setting new future strategy stack:
[09:31:18.522] List of future strategies:
[09:31:18.522] 1. multicore:
[09:31:18.522]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.522]    - tweaked: FALSE
[09:31:18.522]    - call: plan(strategy)
[09:31:18.527] plan(): nbrOfWorkers() = 2
[09:31:18.533] result() for MulticoreFuture ...
[09:31:18.533] result() for MulticoreFuture ... done
[09:31:18.533] result() for MulticoreFuture ... done
[09:31:18.533] result() for MulticoreFuture ...
[09:31:18.533] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.535] getGlobalsAndPackages() ...
[09:31:18.535] Searching for globals...
[09:31:18.537] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.537] Searching for globals ... DONE
[09:31:18.537] Resolving globals: FALSE
[09:31:18.538] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.538] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.539] - globals: [2] ‘weight’, ‘group’
[09:31:18.539] - packages: [1] ‘stats’
[09:31:18.539] getGlobalsAndPackages() ... DONE
[09:31:18.539] run() for ‘Future’ ...
[09:31:18.539] - state: ‘created’
[09:31:18.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.543] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.543]   - Field: ‘label’
[09:31:18.544]   - Field: ‘local’
[09:31:18.544]   - Field: ‘owner’
[09:31:18.544]   - Field: ‘envir’
[09:31:18.544]   - Field: ‘workers’
[09:31:18.544]   - Field: ‘packages’
[09:31:18.544]   - Field: ‘gc’
[09:31:18.544]   - Field: ‘job’
[09:31:18.544]   - Field: ‘conditions’
[09:31:18.544]   - Field: ‘expr’
[09:31:18.545]   - Field: ‘uuid’
[09:31:18.545]   - Field: ‘seed’
[09:31:18.545]   - Field: ‘version’
[09:31:18.545]   - Field: ‘result’
[09:31:18.545]   - Field: ‘asynchronous’
[09:31:18.545]   - Field: ‘calls’
[09:31:18.545]   - Field: ‘globals’
[09:31:18.545]   - Field: ‘stdout’
[09:31:18.545]   - Field: ‘earlySignal’
[09:31:18.546]   - Field: ‘lazy’
[09:31:18.546]   - Field: ‘state’
[09:31:18.546] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.546] - Launch lazy future ...
[09:31:18.546] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.546] Packages needed by future strategies (n = 0): <none>
[09:31:18.547] {
[09:31:18.547]     {
[09:31:18.547]         {
[09:31:18.547]             ...future.startTime <- base::Sys.time()
[09:31:18.547]             {
[09:31:18.547]                 {
[09:31:18.547]                   {
[09:31:18.547]                     {
[09:31:18.547]                       {
[09:31:18.547]                         base::local({
[09:31:18.547]                           has_future <- base::requireNamespace("future", 
[09:31:18.547]                             quietly = TRUE)
[09:31:18.547]                           if (has_future) {
[09:31:18.547]                             ns <- base::getNamespace("future")
[09:31:18.547]                             version <- ns[[".package"]][["version"]]
[09:31:18.547]                             if (is.null(version)) 
[09:31:18.547]                               version <- utils::packageVersion("future")
[09:31:18.547]                           }
[09:31:18.547]                           else {
[09:31:18.547]                             version <- NULL
[09:31:18.547]                           }
[09:31:18.547]                           if (!has_future || version < "1.8.0") {
[09:31:18.547]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.547]                               "", base::R.version$version.string), 
[09:31:18.547]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.547]                                 base::R.version$platform, 8 * 
[09:31:18.547]                                   base::.Machine$sizeof.pointer), 
[09:31:18.547]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.547]                                 "release", "version")], collapse = " "), 
[09:31:18.547]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.547]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.547]                               info)
[09:31:18.547]                             info <- base::paste(info, collapse = "; ")
[09:31:18.547]                             if (!has_future) {
[09:31:18.547]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.547]                                 info)
[09:31:18.547]                             }
[09:31:18.547]                             else {
[09:31:18.547]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.547]                                 info, version)
[09:31:18.547]                             }
[09:31:18.547]                             base::stop(msg)
[09:31:18.547]                           }
[09:31:18.547]                         })
[09:31:18.547]                       }
[09:31:18.547]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.547]                       base::options(mc.cores = 1L)
[09:31:18.547]                     }
[09:31:18.547]                     base::local({
[09:31:18.547]                       for (pkg in "stats") {
[09:31:18.547]                         base::loadNamespace(pkg)
[09:31:18.547]                         base::library(pkg, character.only = TRUE)
[09:31:18.547]                       }
[09:31:18.547]                     })
[09:31:18.547]                   }
[09:31:18.547]                   ...future.strategy.old <- future::plan("list")
[09:31:18.547]                   options(future.plan = NULL)
[09:31:18.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.547]                 }
[09:31:18.547]                 ...future.workdir <- getwd()
[09:31:18.547]             }
[09:31:18.547]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.547]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.547]         }
[09:31:18.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.547]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.547]             base::names(...future.oldOptions))
[09:31:18.547]     }
[09:31:18.547]     if (FALSE) {
[09:31:18.547]     }
[09:31:18.547]     else {
[09:31:18.547]         if (TRUE) {
[09:31:18.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.547]                 open = "w")
[09:31:18.547]         }
[09:31:18.547]         else {
[09:31:18.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.547]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.547]         }
[09:31:18.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.547]             base::sink(type = "output", split = FALSE)
[09:31:18.547]             base::close(...future.stdout)
[09:31:18.547]         }, add = TRUE)
[09:31:18.547]     }
[09:31:18.547]     ...future.frame <- base::sys.nframe()
[09:31:18.547]     ...future.conditions <- base::list()
[09:31:18.547]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.547]     if (FALSE) {
[09:31:18.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.547]     }
[09:31:18.547]     ...future.result <- base::tryCatch({
[09:31:18.547]         base::withCallingHandlers({
[09:31:18.547]             ...future.value <- base::withVisible(base::local({
[09:31:18.547]                 withCallingHandlers({
[09:31:18.547]                   {
[09:31:18.547]                     lm(weight ~ group - 1)
[09:31:18.547]                   }
[09:31:18.547]                 }, immediateCondition = function(cond) {
[09:31:18.547]                   save_rds <- function (object, pathname, ...) 
[09:31:18.547]                   {
[09:31:18.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.547]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.547]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.547]                         fi_tmp[["mtime"]])
[09:31:18.547]                     }
[09:31:18.547]                     tryCatch({
[09:31:18.547]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.547]                     }, error = function(ex) {
[09:31:18.547]                       msg <- conditionMessage(ex)
[09:31:18.547]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.547]                         fi_tmp[["mtime"]], msg)
[09:31:18.547]                       ex$message <- msg
[09:31:18.547]                       stop(ex)
[09:31:18.547]                     })
[09:31:18.547]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.547]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.547]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.547]                       fi <- file.info(pathname)
[09:31:18.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.547]                         fi[["size"]], fi[["mtime"]])
[09:31:18.547]                       stop(msg)
[09:31:18.547]                     }
[09:31:18.547]                     invisible(pathname)
[09:31:18.547]                   }
[09:31:18.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.547]                     rootPath = tempdir()) 
[09:31:18.547]                   {
[09:31:18.547]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.547]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.547]                       tmpdir = path, fileext = ".rds")
[09:31:18.547]                     save_rds(obj, file)
[09:31:18.547]                   }
[09:31:18.547]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.547]                   {
[09:31:18.547]                     inherits <- base::inherits
[09:31:18.547]                     invokeRestart <- base::invokeRestart
[09:31:18.547]                     is.null <- base::is.null
[09:31:18.547]                     muffled <- FALSE
[09:31:18.547]                     if (inherits(cond, "message")) {
[09:31:18.547]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.547]                       if (muffled) 
[09:31:18.547]                         invokeRestart("muffleMessage")
[09:31:18.547]                     }
[09:31:18.547]                     else if (inherits(cond, "warning")) {
[09:31:18.547]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.547]                       if (muffled) 
[09:31:18.547]                         invokeRestart("muffleWarning")
[09:31:18.547]                     }
[09:31:18.547]                     else if (inherits(cond, "condition")) {
[09:31:18.547]                       if (!is.null(pattern)) {
[09:31:18.547]                         computeRestarts <- base::computeRestarts
[09:31:18.547]                         grepl <- base::grepl
[09:31:18.547]                         restarts <- computeRestarts(cond)
[09:31:18.547]                         for (restart in restarts) {
[09:31:18.547]                           name <- restart$name
[09:31:18.547]                           if (is.null(name)) 
[09:31:18.547]                             next
[09:31:18.547]                           if (!grepl(pattern, name)) 
[09:31:18.547]                             next
[09:31:18.547]                           invokeRestart(restart)
[09:31:18.547]                           muffled <- TRUE
[09:31:18.547]                           break
[09:31:18.547]                         }
[09:31:18.547]                       }
[09:31:18.547]                     }
[09:31:18.547]                     invisible(muffled)
[09:31:18.547]                   }
[09:31:18.547]                   muffleCondition(cond)
[09:31:18.547]                 })
[09:31:18.547]             }))
[09:31:18.547]             future::FutureResult(value = ...future.value$value, 
[09:31:18.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.547]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.547]                     ...future.globalenv.names))
[09:31:18.547]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.547]         }, condition = base::local({
[09:31:18.547]             c <- base::c
[09:31:18.547]             inherits <- base::inherits
[09:31:18.547]             invokeRestart <- base::invokeRestart
[09:31:18.547]             length <- base::length
[09:31:18.547]             list <- base::list
[09:31:18.547]             seq.int <- base::seq.int
[09:31:18.547]             signalCondition <- base::signalCondition
[09:31:18.547]             sys.calls <- base::sys.calls
[09:31:18.547]             `[[` <- base::`[[`
[09:31:18.547]             `+` <- base::`+`
[09:31:18.547]             `<<-` <- base::`<<-`
[09:31:18.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.547]                   3L)]
[09:31:18.547]             }
[09:31:18.547]             function(cond) {
[09:31:18.547]                 is_error <- inherits(cond, "error")
[09:31:18.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.547]                   NULL)
[09:31:18.547]                 if (is_error) {
[09:31:18.547]                   sessionInformation <- function() {
[09:31:18.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.547]                       search = base::search(), system = base::Sys.info())
[09:31:18.547]                   }
[09:31:18.547]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.547]                     cond$call), session = sessionInformation(), 
[09:31:18.547]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.547]                   signalCondition(cond)
[09:31:18.547]                 }
[09:31:18.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.547]                 "immediateCondition"))) {
[09:31:18.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.547]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.547]                   if (TRUE && !signal) {
[09:31:18.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.547]                     {
[09:31:18.547]                       inherits <- base::inherits
[09:31:18.547]                       invokeRestart <- base::invokeRestart
[09:31:18.547]                       is.null <- base::is.null
[09:31:18.547]                       muffled <- FALSE
[09:31:18.547]                       if (inherits(cond, "message")) {
[09:31:18.547]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.547]                         if (muffled) 
[09:31:18.547]                           invokeRestart("muffleMessage")
[09:31:18.547]                       }
[09:31:18.547]                       else if (inherits(cond, "warning")) {
[09:31:18.547]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.547]                         if (muffled) 
[09:31:18.547]                           invokeRestart("muffleWarning")
[09:31:18.547]                       }
[09:31:18.547]                       else if (inherits(cond, "condition")) {
[09:31:18.547]                         if (!is.null(pattern)) {
[09:31:18.547]                           computeRestarts <- base::computeRestarts
[09:31:18.547]                           grepl <- base::grepl
[09:31:18.547]                           restarts <- computeRestarts(cond)
[09:31:18.547]                           for (restart in restarts) {
[09:31:18.547]                             name <- restart$name
[09:31:18.547]                             if (is.null(name)) 
[09:31:18.547]                               next
[09:31:18.547]                             if (!grepl(pattern, name)) 
[09:31:18.547]                               next
[09:31:18.547]                             invokeRestart(restart)
[09:31:18.547]                             muffled <- TRUE
[09:31:18.547]                             break
[09:31:18.547]                           }
[09:31:18.547]                         }
[09:31:18.547]                       }
[09:31:18.547]                       invisible(muffled)
[09:31:18.547]                     }
[09:31:18.547]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.547]                   }
[09:31:18.547]                 }
[09:31:18.547]                 else {
[09:31:18.547]                   if (TRUE) {
[09:31:18.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.547]                     {
[09:31:18.547]                       inherits <- base::inherits
[09:31:18.547]                       invokeRestart <- base::invokeRestart
[09:31:18.547]                       is.null <- base::is.null
[09:31:18.547]                       muffled <- FALSE
[09:31:18.547]                       if (inherits(cond, "message")) {
[09:31:18.547]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.547]                         if (muffled) 
[09:31:18.547]                           invokeRestart("muffleMessage")
[09:31:18.547]                       }
[09:31:18.547]                       else if (inherits(cond, "warning")) {
[09:31:18.547]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.547]                         if (muffled) 
[09:31:18.547]                           invokeRestart("muffleWarning")
[09:31:18.547]                       }
[09:31:18.547]                       else if (inherits(cond, "condition")) {
[09:31:18.547]                         if (!is.null(pattern)) {
[09:31:18.547]                           computeRestarts <- base::computeRestarts
[09:31:18.547]                           grepl <- base::grepl
[09:31:18.547]                           restarts <- computeRestarts(cond)
[09:31:18.547]                           for (restart in restarts) {
[09:31:18.547]                             name <- restart$name
[09:31:18.547]                             if (is.null(name)) 
[09:31:18.547]                               next
[09:31:18.547]                             if (!grepl(pattern, name)) 
[09:31:18.547]                               next
[09:31:18.547]                             invokeRestart(restart)
[09:31:18.547]                             muffled <- TRUE
[09:31:18.547]                             break
[09:31:18.547]                           }
[09:31:18.547]                         }
[09:31:18.547]                       }
[09:31:18.547]                       invisible(muffled)
[09:31:18.547]                     }
[09:31:18.547]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.547]                   }
[09:31:18.547]                 }
[09:31:18.547]             }
[09:31:18.547]         }))
[09:31:18.547]     }, error = function(ex) {
[09:31:18.547]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.547]                 ...future.rng), started = ...future.startTime, 
[09:31:18.547]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.547]             version = "1.8"), class = "FutureResult")
[09:31:18.547]     }, finally = {
[09:31:18.547]         if (!identical(...future.workdir, getwd())) 
[09:31:18.547]             setwd(...future.workdir)
[09:31:18.547]         {
[09:31:18.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.547]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.547]             }
[09:31:18.547]             base::options(...future.oldOptions)
[09:31:18.547]             if (.Platform$OS.type == "windows") {
[09:31:18.547]                 old_names <- names(...future.oldEnvVars)
[09:31:18.547]                 envs <- base::Sys.getenv()
[09:31:18.547]                 names <- names(envs)
[09:31:18.547]                 common <- intersect(names, old_names)
[09:31:18.547]                 added <- setdiff(names, old_names)
[09:31:18.547]                 removed <- setdiff(old_names, names)
[09:31:18.547]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.547]                   envs[common]]
[09:31:18.547]                 NAMES <- toupper(changed)
[09:31:18.547]                 args <- list()
[09:31:18.547]                 for (kk in seq_along(NAMES)) {
[09:31:18.547]                   name <- changed[[kk]]
[09:31:18.547]                   NAME <- NAMES[[kk]]
[09:31:18.547]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.547]                     next
[09:31:18.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.547]                 }
[09:31:18.547]                 NAMES <- toupper(added)
[09:31:18.547]                 for (kk in seq_along(NAMES)) {
[09:31:18.547]                   name <- added[[kk]]
[09:31:18.547]                   NAME <- NAMES[[kk]]
[09:31:18.547]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.547]                     next
[09:31:18.547]                   args[[name]] <- ""
[09:31:18.547]                 }
[09:31:18.547]                 NAMES <- toupper(removed)
[09:31:18.547]                 for (kk in seq_along(NAMES)) {
[09:31:18.547]                   name <- removed[[kk]]
[09:31:18.547]                   NAME <- NAMES[[kk]]
[09:31:18.547]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.547]                     next
[09:31:18.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.547]                 }
[09:31:18.547]                 if (length(args) > 0) 
[09:31:18.547]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.547]             }
[09:31:18.547]             else {
[09:31:18.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.547]             }
[09:31:18.547]             {
[09:31:18.547]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.547]                   0L) {
[09:31:18.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.547]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.547]                   base::options(opts)
[09:31:18.547]                 }
[09:31:18.547]                 {
[09:31:18.547]                   {
[09:31:18.547]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.547]                     NULL
[09:31:18.547]                   }
[09:31:18.547]                   options(future.plan = NULL)
[09:31:18.547]                   if (is.na(NA_character_)) 
[09:31:18.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.547]                     .init = FALSE)
[09:31:18.547]                 }
[09:31:18.547]             }
[09:31:18.547]         }
[09:31:18.547]     })
[09:31:18.547]     if (TRUE) {
[09:31:18.547]         base::sink(type = "output", split = FALSE)
[09:31:18.547]         if (TRUE) {
[09:31:18.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.547]         }
[09:31:18.547]         else {
[09:31:18.547]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.547]         }
[09:31:18.547]         base::close(...future.stdout)
[09:31:18.547]         ...future.stdout <- NULL
[09:31:18.547]     }
[09:31:18.547]     ...future.result$conditions <- ...future.conditions
[09:31:18.547]     ...future.result$finished <- base::Sys.time()
[09:31:18.547]     ...future.result
[09:31:18.547] }
[09:31:18.549] assign_globals() ...
[09:31:18.549] List of 2
[09:31:18.549]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.549]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.549]  - attr(*, "where")=List of 2
[09:31:18.549]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.549]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.549]  - attr(*, "resolved")= logi FALSE
[09:31:18.549]  - attr(*, "total_size")= num 896
[09:31:18.549]  - attr(*, "already-done")= logi TRUE
[09:31:18.553] - copied ‘weight’ to environment
[09:31:18.553] - copied ‘group’ to environment
[09:31:18.553] assign_globals() ... done
[09:31:18.553] requestCore(): workers = 2
[09:31:18.555] MulticoreFuture started
[09:31:18.555] - Launch lazy future ... done
[09:31:18.555] run() for ‘MulticoreFuture’ ... done
[09:31:18.556] result() for MulticoreFuture ...
[09:31:18.556] plan(): Setting new future strategy stack:
[09:31:18.557] List of future strategies:
[09:31:18.557] 1. sequential:
[09:31:18.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.557]    - tweaked: FALSE
[09:31:18.557]    - call: NULL
[09:31:18.558] plan(): nbrOfWorkers() = 1
[09:31:18.561] plan(): Setting new future strategy stack:
[09:31:18.561] List of future strategies:
[09:31:18.561] 1. multicore:
[09:31:18.561]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.561]    - tweaked: FALSE
[09:31:18.561]    - call: plan(strategy)
[09:31:18.570] plan(): nbrOfWorkers() = 2
[09:31:18.572] result() for MulticoreFuture ...
[09:31:18.572] result() for MulticoreFuture ... done
[09:31:18.572] result() for MulticoreFuture ... done
[09:31:18.573] result() for MulticoreFuture ...
[09:31:18.573] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.577] getGlobalsAndPackages() ...
[09:31:18.578] Searching for globals...
[09:31:18.580] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.580] Searching for globals ... DONE
[09:31:18.580] Resolving globals: FALSE
[09:31:18.581] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.581] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.581] - globals: [2] ‘weight’, ‘group’
[09:31:18.581] - packages: [1] ‘stats’
[09:31:18.582] getGlobalsAndPackages() ... DONE
[09:31:18.582] run() for ‘Future’ ...
[09:31:18.582] - state: ‘created’
[09:31:18.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.586]   - Field: ‘label’
[09:31:18.586]   - Field: ‘local’
[09:31:18.586]   - Field: ‘owner’
[09:31:18.587]   - Field: ‘envir’
[09:31:18.587]   - Field: ‘workers’
[09:31:18.587]   - Field: ‘packages’
[09:31:18.587]   - Field: ‘gc’
[09:31:18.587]   - Field: ‘job’
[09:31:18.587]   - Field: ‘conditions’
[09:31:18.587]   - Field: ‘expr’
[09:31:18.587]   - Field: ‘uuid’
[09:31:18.587]   - Field: ‘seed’
[09:31:18.588]   - Field: ‘version’
[09:31:18.588]   - Field: ‘result’
[09:31:18.588]   - Field: ‘asynchronous’
[09:31:18.588]   - Field: ‘calls’
[09:31:18.588]   - Field: ‘globals’
[09:31:18.588]   - Field: ‘stdout’
[09:31:18.588]   - Field: ‘earlySignal’
[09:31:18.588]   - Field: ‘lazy’
[09:31:18.588]   - Field: ‘state’
[09:31:18.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.589] - Launch lazy future ...
[09:31:18.589] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.589] Packages needed by future strategies (n = 0): <none>
[09:31:18.590] {
[09:31:18.590]     {
[09:31:18.590]         {
[09:31:18.590]             ...future.startTime <- base::Sys.time()
[09:31:18.590]             {
[09:31:18.590]                 {
[09:31:18.590]                   {
[09:31:18.590]                     {
[09:31:18.590]                       {
[09:31:18.590]                         base::local({
[09:31:18.590]                           has_future <- base::requireNamespace("future", 
[09:31:18.590]                             quietly = TRUE)
[09:31:18.590]                           if (has_future) {
[09:31:18.590]                             ns <- base::getNamespace("future")
[09:31:18.590]                             version <- ns[[".package"]][["version"]]
[09:31:18.590]                             if (is.null(version)) 
[09:31:18.590]                               version <- utils::packageVersion("future")
[09:31:18.590]                           }
[09:31:18.590]                           else {
[09:31:18.590]                             version <- NULL
[09:31:18.590]                           }
[09:31:18.590]                           if (!has_future || version < "1.8.0") {
[09:31:18.590]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.590]                               "", base::R.version$version.string), 
[09:31:18.590]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.590]                                 base::R.version$platform, 8 * 
[09:31:18.590]                                   base::.Machine$sizeof.pointer), 
[09:31:18.590]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.590]                                 "release", "version")], collapse = " "), 
[09:31:18.590]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.590]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.590]                               info)
[09:31:18.590]                             info <- base::paste(info, collapse = "; ")
[09:31:18.590]                             if (!has_future) {
[09:31:18.590]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.590]                                 info)
[09:31:18.590]                             }
[09:31:18.590]                             else {
[09:31:18.590]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.590]                                 info, version)
[09:31:18.590]                             }
[09:31:18.590]                             base::stop(msg)
[09:31:18.590]                           }
[09:31:18.590]                         })
[09:31:18.590]                       }
[09:31:18.590]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.590]                       base::options(mc.cores = 1L)
[09:31:18.590]                     }
[09:31:18.590]                     base::local({
[09:31:18.590]                       for (pkg in "stats") {
[09:31:18.590]                         base::loadNamespace(pkg)
[09:31:18.590]                         base::library(pkg, character.only = TRUE)
[09:31:18.590]                       }
[09:31:18.590]                     })
[09:31:18.590]                   }
[09:31:18.590]                   ...future.strategy.old <- future::plan("list")
[09:31:18.590]                   options(future.plan = NULL)
[09:31:18.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.590]                 }
[09:31:18.590]                 ...future.workdir <- getwd()
[09:31:18.590]             }
[09:31:18.590]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.590]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.590]         }
[09:31:18.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.590]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.590]             base::names(...future.oldOptions))
[09:31:18.590]     }
[09:31:18.590]     if (FALSE) {
[09:31:18.590]     }
[09:31:18.590]     else {
[09:31:18.590]         if (TRUE) {
[09:31:18.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.590]                 open = "w")
[09:31:18.590]         }
[09:31:18.590]         else {
[09:31:18.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.590]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.590]         }
[09:31:18.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.590]             base::sink(type = "output", split = FALSE)
[09:31:18.590]             base::close(...future.stdout)
[09:31:18.590]         }, add = TRUE)
[09:31:18.590]     }
[09:31:18.590]     ...future.frame <- base::sys.nframe()
[09:31:18.590]     ...future.conditions <- base::list()
[09:31:18.590]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.590]     if (FALSE) {
[09:31:18.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.590]     }
[09:31:18.590]     ...future.result <- base::tryCatch({
[09:31:18.590]         base::withCallingHandlers({
[09:31:18.590]             ...future.value <- base::withVisible(base::local({
[09:31:18.590]                 withCallingHandlers({
[09:31:18.590]                   {
[09:31:18.590]                     lm(weight ~ group - 1)
[09:31:18.590]                   }
[09:31:18.590]                 }, immediateCondition = function(cond) {
[09:31:18.590]                   save_rds <- function (object, pathname, ...) 
[09:31:18.590]                   {
[09:31:18.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.590]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.590]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.590]                         fi_tmp[["mtime"]])
[09:31:18.590]                     }
[09:31:18.590]                     tryCatch({
[09:31:18.590]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.590]                     }, error = function(ex) {
[09:31:18.590]                       msg <- conditionMessage(ex)
[09:31:18.590]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.590]                         fi_tmp[["mtime"]], msg)
[09:31:18.590]                       ex$message <- msg
[09:31:18.590]                       stop(ex)
[09:31:18.590]                     })
[09:31:18.590]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.590]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.590]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.590]                       fi <- file.info(pathname)
[09:31:18.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.590]                         fi[["size"]], fi[["mtime"]])
[09:31:18.590]                       stop(msg)
[09:31:18.590]                     }
[09:31:18.590]                     invisible(pathname)
[09:31:18.590]                   }
[09:31:18.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.590]                     rootPath = tempdir()) 
[09:31:18.590]                   {
[09:31:18.590]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.590]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.590]                       tmpdir = path, fileext = ".rds")
[09:31:18.590]                     save_rds(obj, file)
[09:31:18.590]                   }
[09:31:18.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.590]                   {
[09:31:18.590]                     inherits <- base::inherits
[09:31:18.590]                     invokeRestart <- base::invokeRestart
[09:31:18.590]                     is.null <- base::is.null
[09:31:18.590]                     muffled <- FALSE
[09:31:18.590]                     if (inherits(cond, "message")) {
[09:31:18.590]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.590]                       if (muffled) 
[09:31:18.590]                         invokeRestart("muffleMessage")
[09:31:18.590]                     }
[09:31:18.590]                     else if (inherits(cond, "warning")) {
[09:31:18.590]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.590]                       if (muffled) 
[09:31:18.590]                         invokeRestart("muffleWarning")
[09:31:18.590]                     }
[09:31:18.590]                     else if (inherits(cond, "condition")) {
[09:31:18.590]                       if (!is.null(pattern)) {
[09:31:18.590]                         computeRestarts <- base::computeRestarts
[09:31:18.590]                         grepl <- base::grepl
[09:31:18.590]                         restarts <- computeRestarts(cond)
[09:31:18.590]                         for (restart in restarts) {
[09:31:18.590]                           name <- restart$name
[09:31:18.590]                           if (is.null(name)) 
[09:31:18.590]                             next
[09:31:18.590]                           if (!grepl(pattern, name)) 
[09:31:18.590]                             next
[09:31:18.590]                           invokeRestart(restart)
[09:31:18.590]                           muffled <- TRUE
[09:31:18.590]                           break
[09:31:18.590]                         }
[09:31:18.590]                       }
[09:31:18.590]                     }
[09:31:18.590]                     invisible(muffled)
[09:31:18.590]                   }
[09:31:18.590]                   muffleCondition(cond)
[09:31:18.590]                 })
[09:31:18.590]             }))
[09:31:18.590]             future::FutureResult(value = ...future.value$value, 
[09:31:18.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.590]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.590]                     ...future.globalenv.names))
[09:31:18.590]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.590]         }, condition = base::local({
[09:31:18.590]             c <- base::c
[09:31:18.590]             inherits <- base::inherits
[09:31:18.590]             invokeRestart <- base::invokeRestart
[09:31:18.590]             length <- base::length
[09:31:18.590]             list <- base::list
[09:31:18.590]             seq.int <- base::seq.int
[09:31:18.590]             signalCondition <- base::signalCondition
[09:31:18.590]             sys.calls <- base::sys.calls
[09:31:18.590]             `[[` <- base::`[[`
[09:31:18.590]             `+` <- base::`+`
[09:31:18.590]             `<<-` <- base::`<<-`
[09:31:18.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.590]                   3L)]
[09:31:18.590]             }
[09:31:18.590]             function(cond) {
[09:31:18.590]                 is_error <- inherits(cond, "error")
[09:31:18.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.590]                   NULL)
[09:31:18.590]                 if (is_error) {
[09:31:18.590]                   sessionInformation <- function() {
[09:31:18.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.590]                       search = base::search(), system = base::Sys.info())
[09:31:18.590]                   }
[09:31:18.590]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.590]                     cond$call), session = sessionInformation(), 
[09:31:18.590]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.590]                   signalCondition(cond)
[09:31:18.590]                 }
[09:31:18.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.590]                 "immediateCondition"))) {
[09:31:18.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.590]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.590]                   if (TRUE && !signal) {
[09:31:18.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.590]                     {
[09:31:18.590]                       inherits <- base::inherits
[09:31:18.590]                       invokeRestart <- base::invokeRestart
[09:31:18.590]                       is.null <- base::is.null
[09:31:18.590]                       muffled <- FALSE
[09:31:18.590]                       if (inherits(cond, "message")) {
[09:31:18.590]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.590]                         if (muffled) 
[09:31:18.590]                           invokeRestart("muffleMessage")
[09:31:18.590]                       }
[09:31:18.590]                       else if (inherits(cond, "warning")) {
[09:31:18.590]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.590]                         if (muffled) 
[09:31:18.590]                           invokeRestart("muffleWarning")
[09:31:18.590]                       }
[09:31:18.590]                       else if (inherits(cond, "condition")) {
[09:31:18.590]                         if (!is.null(pattern)) {
[09:31:18.590]                           computeRestarts <- base::computeRestarts
[09:31:18.590]                           grepl <- base::grepl
[09:31:18.590]                           restarts <- computeRestarts(cond)
[09:31:18.590]                           for (restart in restarts) {
[09:31:18.590]                             name <- restart$name
[09:31:18.590]                             if (is.null(name)) 
[09:31:18.590]                               next
[09:31:18.590]                             if (!grepl(pattern, name)) 
[09:31:18.590]                               next
[09:31:18.590]                             invokeRestart(restart)
[09:31:18.590]                             muffled <- TRUE
[09:31:18.590]                             break
[09:31:18.590]                           }
[09:31:18.590]                         }
[09:31:18.590]                       }
[09:31:18.590]                       invisible(muffled)
[09:31:18.590]                     }
[09:31:18.590]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.590]                   }
[09:31:18.590]                 }
[09:31:18.590]                 else {
[09:31:18.590]                   if (TRUE) {
[09:31:18.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.590]                     {
[09:31:18.590]                       inherits <- base::inherits
[09:31:18.590]                       invokeRestart <- base::invokeRestart
[09:31:18.590]                       is.null <- base::is.null
[09:31:18.590]                       muffled <- FALSE
[09:31:18.590]                       if (inherits(cond, "message")) {
[09:31:18.590]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.590]                         if (muffled) 
[09:31:18.590]                           invokeRestart("muffleMessage")
[09:31:18.590]                       }
[09:31:18.590]                       else if (inherits(cond, "warning")) {
[09:31:18.590]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.590]                         if (muffled) 
[09:31:18.590]                           invokeRestart("muffleWarning")
[09:31:18.590]                       }
[09:31:18.590]                       else if (inherits(cond, "condition")) {
[09:31:18.590]                         if (!is.null(pattern)) {
[09:31:18.590]                           computeRestarts <- base::computeRestarts
[09:31:18.590]                           grepl <- base::grepl
[09:31:18.590]                           restarts <- computeRestarts(cond)
[09:31:18.590]                           for (restart in restarts) {
[09:31:18.590]                             name <- restart$name
[09:31:18.590]                             if (is.null(name)) 
[09:31:18.590]                               next
[09:31:18.590]                             if (!grepl(pattern, name)) 
[09:31:18.590]                               next
[09:31:18.590]                             invokeRestart(restart)
[09:31:18.590]                             muffled <- TRUE
[09:31:18.590]                             break
[09:31:18.590]                           }
[09:31:18.590]                         }
[09:31:18.590]                       }
[09:31:18.590]                       invisible(muffled)
[09:31:18.590]                     }
[09:31:18.590]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.590]                   }
[09:31:18.590]                 }
[09:31:18.590]             }
[09:31:18.590]         }))
[09:31:18.590]     }, error = function(ex) {
[09:31:18.590]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.590]                 ...future.rng), started = ...future.startTime, 
[09:31:18.590]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.590]             version = "1.8"), class = "FutureResult")
[09:31:18.590]     }, finally = {
[09:31:18.590]         if (!identical(...future.workdir, getwd())) 
[09:31:18.590]             setwd(...future.workdir)
[09:31:18.590]         {
[09:31:18.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.590]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.590]             }
[09:31:18.590]             base::options(...future.oldOptions)
[09:31:18.590]             if (.Platform$OS.type == "windows") {
[09:31:18.590]                 old_names <- names(...future.oldEnvVars)
[09:31:18.590]                 envs <- base::Sys.getenv()
[09:31:18.590]                 names <- names(envs)
[09:31:18.590]                 common <- intersect(names, old_names)
[09:31:18.590]                 added <- setdiff(names, old_names)
[09:31:18.590]                 removed <- setdiff(old_names, names)
[09:31:18.590]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.590]                   envs[common]]
[09:31:18.590]                 NAMES <- toupper(changed)
[09:31:18.590]                 args <- list()
[09:31:18.590]                 for (kk in seq_along(NAMES)) {
[09:31:18.590]                   name <- changed[[kk]]
[09:31:18.590]                   NAME <- NAMES[[kk]]
[09:31:18.590]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.590]                     next
[09:31:18.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.590]                 }
[09:31:18.590]                 NAMES <- toupper(added)
[09:31:18.590]                 for (kk in seq_along(NAMES)) {
[09:31:18.590]                   name <- added[[kk]]
[09:31:18.590]                   NAME <- NAMES[[kk]]
[09:31:18.590]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.590]                     next
[09:31:18.590]                   args[[name]] <- ""
[09:31:18.590]                 }
[09:31:18.590]                 NAMES <- toupper(removed)
[09:31:18.590]                 for (kk in seq_along(NAMES)) {
[09:31:18.590]                   name <- removed[[kk]]
[09:31:18.590]                   NAME <- NAMES[[kk]]
[09:31:18.590]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.590]                     next
[09:31:18.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.590]                 }
[09:31:18.590]                 if (length(args) > 0) 
[09:31:18.590]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.590]             }
[09:31:18.590]             else {
[09:31:18.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.590]             }
[09:31:18.590]             {
[09:31:18.590]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.590]                   0L) {
[09:31:18.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.590]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.590]                   base::options(opts)
[09:31:18.590]                 }
[09:31:18.590]                 {
[09:31:18.590]                   {
[09:31:18.590]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.590]                     NULL
[09:31:18.590]                   }
[09:31:18.590]                   options(future.plan = NULL)
[09:31:18.590]                   if (is.na(NA_character_)) 
[09:31:18.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.590]                     .init = FALSE)
[09:31:18.590]                 }
[09:31:18.590]             }
[09:31:18.590]         }
[09:31:18.590]     })
[09:31:18.590]     if (TRUE) {
[09:31:18.590]         base::sink(type = "output", split = FALSE)
[09:31:18.590]         if (TRUE) {
[09:31:18.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.590]         }
[09:31:18.590]         else {
[09:31:18.590]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.590]         }
[09:31:18.590]         base::close(...future.stdout)
[09:31:18.590]         ...future.stdout <- NULL
[09:31:18.590]     }
[09:31:18.590]     ...future.result$conditions <- ...future.conditions
[09:31:18.590]     ...future.result$finished <- base::Sys.time()
[09:31:18.590]     ...future.result
[09:31:18.590] }
[09:31:18.592] assign_globals() ...
[09:31:18.592] List of 2
[09:31:18.592]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.592]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.592]  - attr(*, "where")=List of 2
[09:31:18.592]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.592]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.592]  - attr(*, "resolved")= logi FALSE
[09:31:18.592]  - attr(*, "total_size")= num 896
[09:31:18.592]  - attr(*, "already-done")= logi TRUE
[09:31:18.596] - copied ‘weight’ to environment
[09:31:18.596] - copied ‘group’ to environment
[09:31:18.596] assign_globals() ... done
[09:31:18.596] requestCore(): workers = 2
[09:31:18.598] MulticoreFuture started
[09:31:18.598] - Launch lazy future ... done
[09:31:18.598] run() for ‘MulticoreFuture’ ... done
[09:31:18.599] result() for MulticoreFuture ...
[09:31:18.599] plan(): Setting new future strategy stack:
[09:31:18.599] List of future strategies:
[09:31:18.599] 1. sequential:
[09:31:18.599]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.599]    - tweaked: FALSE
[09:31:18.599]    - call: NULL
[09:31:18.600] plan(): nbrOfWorkers() = 1
[09:31:18.604] plan(): Setting new future strategy stack:
[09:31:18.604] List of future strategies:
[09:31:18.604] 1. multicore:
[09:31:18.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.604]    - tweaked: FALSE
[09:31:18.604]    - call: plan(strategy)
[09:31:18.609] plan(): nbrOfWorkers() = 2
[09:31:18.611] result() for MulticoreFuture ...
[09:31:18.611] result() for MulticoreFuture ... done
[09:31:18.611] result() for MulticoreFuture ... done
[09:31:18.611] result() for MulticoreFuture ...
[09:31:18.611] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.614] getGlobalsAndPackages() ...
[09:31:18.614] Searching for globals...
[09:31:18.616] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.616] Searching for globals ... DONE
[09:31:18.616] Resolving globals: FALSE
[09:31:18.617] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.617] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.617] - globals: [2] ‘weight’, ‘group’
[09:31:18.618] - packages: [1] ‘stats’
[09:31:18.618] getGlobalsAndPackages() ... DONE
[09:31:18.618] run() for ‘Future’ ...
[09:31:18.618] - state: ‘created’
[09:31:18.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.624] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.624]   - Field: ‘label’
[09:31:18.624]   - Field: ‘local’
[09:31:18.625]   - Field: ‘owner’
[09:31:18.625]   - Field: ‘envir’
[09:31:18.625]   - Field: ‘workers’
[09:31:18.625]   - Field: ‘packages’
[09:31:18.625]   - Field: ‘gc’
[09:31:18.625]   - Field: ‘job’
[09:31:18.625]   - Field: ‘conditions’
[09:31:18.625]   - Field: ‘expr’
[09:31:18.626]   - Field: ‘uuid’
[09:31:18.626]   - Field: ‘seed’
[09:31:18.626]   - Field: ‘version’
[09:31:18.626]   - Field: ‘result’
[09:31:18.626]   - Field: ‘asynchronous’
[09:31:18.626]   - Field: ‘calls’
[09:31:18.626]   - Field: ‘globals’
[09:31:18.626]   - Field: ‘stdout’
[09:31:18.627]   - Field: ‘earlySignal’
[09:31:18.627]   - Field: ‘lazy’
[09:31:18.627]   - Field: ‘state’
[09:31:18.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.627] - Launch lazy future ...
[09:31:18.627] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.627] Packages needed by future strategies (n = 0): <none>
[09:31:18.628] {
[09:31:18.628]     {
[09:31:18.628]         {
[09:31:18.628]             ...future.startTime <- base::Sys.time()
[09:31:18.628]             {
[09:31:18.628]                 {
[09:31:18.628]                   {
[09:31:18.628]                     {
[09:31:18.628]                       {
[09:31:18.628]                         base::local({
[09:31:18.628]                           has_future <- base::requireNamespace("future", 
[09:31:18.628]                             quietly = TRUE)
[09:31:18.628]                           if (has_future) {
[09:31:18.628]                             ns <- base::getNamespace("future")
[09:31:18.628]                             version <- ns[[".package"]][["version"]]
[09:31:18.628]                             if (is.null(version)) 
[09:31:18.628]                               version <- utils::packageVersion("future")
[09:31:18.628]                           }
[09:31:18.628]                           else {
[09:31:18.628]                             version <- NULL
[09:31:18.628]                           }
[09:31:18.628]                           if (!has_future || version < "1.8.0") {
[09:31:18.628]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.628]                               "", base::R.version$version.string), 
[09:31:18.628]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.628]                                 base::R.version$platform, 8 * 
[09:31:18.628]                                   base::.Machine$sizeof.pointer), 
[09:31:18.628]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.628]                                 "release", "version")], collapse = " "), 
[09:31:18.628]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.628]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.628]                               info)
[09:31:18.628]                             info <- base::paste(info, collapse = "; ")
[09:31:18.628]                             if (!has_future) {
[09:31:18.628]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.628]                                 info)
[09:31:18.628]                             }
[09:31:18.628]                             else {
[09:31:18.628]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.628]                                 info, version)
[09:31:18.628]                             }
[09:31:18.628]                             base::stop(msg)
[09:31:18.628]                           }
[09:31:18.628]                         })
[09:31:18.628]                       }
[09:31:18.628]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.628]                       base::options(mc.cores = 1L)
[09:31:18.628]                     }
[09:31:18.628]                     base::local({
[09:31:18.628]                       for (pkg in "stats") {
[09:31:18.628]                         base::loadNamespace(pkg)
[09:31:18.628]                         base::library(pkg, character.only = TRUE)
[09:31:18.628]                       }
[09:31:18.628]                     })
[09:31:18.628]                   }
[09:31:18.628]                   ...future.strategy.old <- future::plan("list")
[09:31:18.628]                   options(future.plan = NULL)
[09:31:18.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.628]                 }
[09:31:18.628]                 ...future.workdir <- getwd()
[09:31:18.628]             }
[09:31:18.628]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.628]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.628]         }
[09:31:18.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.628]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.628]             base::names(...future.oldOptions))
[09:31:18.628]     }
[09:31:18.628]     if (FALSE) {
[09:31:18.628]     }
[09:31:18.628]     else {
[09:31:18.628]         if (TRUE) {
[09:31:18.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.628]                 open = "w")
[09:31:18.628]         }
[09:31:18.628]         else {
[09:31:18.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.628]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.628]         }
[09:31:18.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.628]             base::sink(type = "output", split = FALSE)
[09:31:18.628]             base::close(...future.stdout)
[09:31:18.628]         }, add = TRUE)
[09:31:18.628]     }
[09:31:18.628]     ...future.frame <- base::sys.nframe()
[09:31:18.628]     ...future.conditions <- base::list()
[09:31:18.628]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.628]     if (FALSE) {
[09:31:18.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.628]     }
[09:31:18.628]     ...future.result <- base::tryCatch({
[09:31:18.628]         base::withCallingHandlers({
[09:31:18.628]             ...future.value <- base::withVisible(base::local({
[09:31:18.628]                 withCallingHandlers({
[09:31:18.628]                   {
[09:31:18.628]                     lm(weight ~ group - 1)
[09:31:18.628]                   }
[09:31:18.628]                 }, immediateCondition = function(cond) {
[09:31:18.628]                   save_rds <- function (object, pathname, ...) 
[09:31:18.628]                   {
[09:31:18.628]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.628]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.628]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.628]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.628]                         fi_tmp[["mtime"]])
[09:31:18.628]                     }
[09:31:18.628]                     tryCatch({
[09:31:18.628]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.628]                     }, error = function(ex) {
[09:31:18.628]                       msg <- conditionMessage(ex)
[09:31:18.628]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.628]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.628]                         fi_tmp[["mtime"]], msg)
[09:31:18.628]                       ex$message <- msg
[09:31:18.628]                       stop(ex)
[09:31:18.628]                     })
[09:31:18.628]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.628]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.628]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.628]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.628]                       fi <- file.info(pathname)
[09:31:18.628]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.628]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.628]                         fi[["size"]], fi[["mtime"]])
[09:31:18.628]                       stop(msg)
[09:31:18.628]                     }
[09:31:18.628]                     invisible(pathname)
[09:31:18.628]                   }
[09:31:18.628]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.628]                     rootPath = tempdir()) 
[09:31:18.628]                   {
[09:31:18.628]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.628]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.628]                       tmpdir = path, fileext = ".rds")
[09:31:18.628]                     save_rds(obj, file)
[09:31:18.628]                   }
[09:31:18.628]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.628]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.628]                   {
[09:31:18.628]                     inherits <- base::inherits
[09:31:18.628]                     invokeRestart <- base::invokeRestart
[09:31:18.628]                     is.null <- base::is.null
[09:31:18.628]                     muffled <- FALSE
[09:31:18.628]                     if (inherits(cond, "message")) {
[09:31:18.628]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.628]                       if (muffled) 
[09:31:18.628]                         invokeRestart("muffleMessage")
[09:31:18.628]                     }
[09:31:18.628]                     else if (inherits(cond, "warning")) {
[09:31:18.628]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.628]                       if (muffled) 
[09:31:18.628]                         invokeRestart("muffleWarning")
[09:31:18.628]                     }
[09:31:18.628]                     else if (inherits(cond, "condition")) {
[09:31:18.628]                       if (!is.null(pattern)) {
[09:31:18.628]                         computeRestarts <- base::computeRestarts
[09:31:18.628]                         grepl <- base::grepl
[09:31:18.628]                         restarts <- computeRestarts(cond)
[09:31:18.628]                         for (restart in restarts) {
[09:31:18.628]                           name <- restart$name
[09:31:18.628]                           if (is.null(name)) 
[09:31:18.628]                             next
[09:31:18.628]                           if (!grepl(pattern, name)) 
[09:31:18.628]                             next
[09:31:18.628]                           invokeRestart(restart)
[09:31:18.628]                           muffled <- TRUE
[09:31:18.628]                           break
[09:31:18.628]                         }
[09:31:18.628]                       }
[09:31:18.628]                     }
[09:31:18.628]                     invisible(muffled)
[09:31:18.628]                   }
[09:31:18.628]                   muffleCondition(cond)
[09:31:18.628]                 })
[09:31:18.628]             }))
[09:31:18.628]             future::FutureResult(value = ...future.value$value, 
[09:31:18.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.628]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.628]                     ...future.globalenv.names))
[09:31:18.628]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.628]         }, condition = base::local({
[09:31:18.628]             c <- base::c
[09:31:18.628]             inherits <- base::inherits
[09:31:18.628]             invokeRestart <- base::invokeRestart
[09:31:18.628]             length <- base::length
[09:31:18.628]             list <- base::list
[09:31:18.628]             seq.int <- base::seq.int
[09:31:18.628]             signalCondition <- base::signalCondition
[09:31:18.628]             sys.calls <- base::sys.calls
[09:31:18.628]             `[[` <- base::`[[`
[09:31:18.628]             `+` <- base::`+`
[09:31:18.628]             `<<-` <- base::`<<-`
[09:31:18.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.628]                   3L)]
[09:31:18.628]             }
[09:31:18.628]             function(cond) {
[09:31:18.628]                 is_error <- inherits(cond, "error")
[09:31:18.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.628]                   NULL)
[09:31:18.628]                 if (is_error) {
[09:31:18.628]                   sessionInformation <- function() {
[09:31:18.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.628]                       search = base::search(), system = base::Sys.info())
[09:31:18.628]                   }
[09:31:18.628]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.628]                     cond$call), session = sessionInformation(), 
[09:31:18.628]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.628]                   signalCondition(cond)
[09:31:18.628]                 }
[09:31:18.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.628]                 "immediateCondition"))) {
[09:31:18.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.628]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.628]                   if (TRUE && !signal) {
[09:31:18.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.628]                     {
[09:31:18.628]                       inherits <- base::inherits
[09:31:18.628]                       invokeRestart <- base::invokeRestart
[09:31:18.628]                       is.null <- base::is.null
[09:31:18.628]                       muffled <- FALSE
[09:31:18.628]                       if (inherits(cond, "message")) {
[09:31:18.628]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.628]                         if (muffled) 
[09:31:18.628]                           invokeRestart("muffleMessage")
[09:31:18.628]                       }
[09:31:18.628]                       else if (inherits(cond, "warning")) {
[09:31:18.628]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.628]                         if (muffled) 
[09:31:18.628]                           invokeRestart("muffleWarning")
[09:31:18.628]                       }
[09:31:18.628]                       else if (inherits(cond, "condition")) {
[09:31:18.628]                         if (!is.null(pattern)) {
[09:31:18.628]                           computeRestarts <- base::computeRestarts
[09:31:18.628]                           grepl <- base::grepl
[09:31:18.628]                           restarts <- computeRestarts(cond)
[09:31:18.628]                           for (restart in restarts) {
[09:31:18.628]                             name <- restart$name
[09:31:18.628]                             if (is.null(name)) 
[09:31:18.628]                               next
[09:31:18.628]                             if (!grepl(pattern, name)) 
[09:31:18.628]                               next
[09:31:18.628]                             invokeRestart(restart)
[09:31:18.628]                             muffled <- TRUE
[09:31:18.628]                             break
[09:31:18.628]                           }
[09:31:18.628]                         }
[09:31:18.628]                       }
[09:31:18.628]                       invisible(muffled)
[09:31:18.628]                     }
[09:31:18.628]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.628]                   }
[09:31:18.628]                 }
[09:31:18.628]                 else {
[09:31:18.628]                   if (TRUE) {
[09:31:18.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.628]                     {
[09:31:18.628]                       inherits <- base::inherits
[09:31:18.628]                       invokeRestart <- base::invokeRestart
[09:31:18.628]                       is.null <- base::is.null
[09:31:18.628]                       muffled <- FALSE
[09:31:18.628]                       if (inherits(cond, "message")) {
[09:31:18.628]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.628]                         if (muffled) 
[09:31:18.628]                           invokeRestart("muffleMessage")
[09:31:18.628]                       }
[09:31:18.628]                       else if (inherits(cond, "warning")) {
[09:31:18.628]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.628]                         if (muffled) 
[09:31:18.628]                           invokeRestart("muffleWarning")
[09:31:18.628]                       }
[09:31:18.628]                       else if (inherits(cond, "condition")) {
[09:31:18.628]                         if (!is.null(pattern)) {
[09:31:18.628]                           computeRestarts <- base::computeRestarts
[09:31:18.628]                           grepl <- base::grepl
[09:31:18.628]                           restarts <- computeRestarts(cond)
[09:31:18.628]                           for (restart in restarts) {
[09:31:18.628]                             name <- restart$name
[09:31:18.628]                             if (is.null(name)) 
[09:31:18.628]                               next
[09:31:18.628]                             if (!grepl(pattern, name)) 
[09:31:18.628]                               next
[09:31:18.628]                             invokeRestart(restart)
[09:31:18.628]                             muffled <- TRUE
[09:31:18.628]                             break
[09:31:18.628]                           }
[09:31:18.628]                         }
[09:31:18.628]                       }
[09:31:18.628]                       invisible(muffled)
[09:31:18.628]                     }
[09:31:18.628]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.628]                   }
[09:31:18.628]                 }
[09:31:18.628]             }
[09:31:18.628]         }))
[09:31:18.628]     }, error = function(ex) {
[09:31:18.628]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.628]                 ...future.rng), started = ...future.startTime, 
[09:31:18.628]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.628]             version = "1.8"), class = "FutureResult")
[09:31:18.628]     }, finally = {
[09:31:18.628]         if (!identical(...future.workdir, getwd())) 
[09:31:18.628]             setwd(...future.workdir)
[09:31:18.628]         {
[09:31:18.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.628]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.628]             }
[09:31:18.628]             base::options(...future.oldOptions)
[09:31:18.628]             if (.Platform$OS.type == "windows") {
[09:31:18.628]                 old_names <- names(...future.oldEnvVars)
[09:31:18.628]                 envs <- base::Sys.getenv()
[09:31:18.628]                 names <- names(envs)
[09:31:18.628]                 common <- intersect(names, old_names)
[09:31:18.628]                 added <- setdiff(names, old_names)
[09:31:18.628]                 removed <- setdiff(old_names, names)
[09:31:18.628]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.628]                   envs[common]]
[09:31:18.628]                 NAMES <- toupper(changed)
[09:31:18.628]                 args <- list()
[09:31:18.628]                 for (kk in seq_along(NAMES)) {
[09:31:18.628]                   name <- changed[[kk]]
[09:31:18.628]                   NAME <- NAMES[[kk]]
[09:31:18.628]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.628]                     next
[09:31:18.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.628]                 }
[09:31:18.628]                 NAMES <- toupper(added)
[09:31:18.628]                 for (kk in seq_along(NAMES)) {
[09:31:18.628]                   name <- added[[kk]]
[09:31:18.628]                   NAME <- NAMES[[kk]]
[09:31:18.628]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.628]                     next
[09:31:18.628]                   args[[name]] <- ""
[09:31:18.628]                 }
[09:31:18.628]                 NAMES <- toupper(removed)
[09:31:18.628]                 for (kk in seq_along(NAMES)) {
[09:31:18.628]                   name <- removed[[kk]]
[09:31:18.628]                   NAME <- NAMES[[kk]]
[09:31:18.628]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.628]                     next
[09:31:18.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.628]                 }
[09:31:18.628]                 if (length(args) > 0) 
[09:31:18.628]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.628]             }
[09:31:18.628]             else {
[09:31:18.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.628]             }
[09:31:18.628]             {
[09:31:18.628]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.628]                   0L) {
[09:31:18.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.628]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.628]                   base::options(opts)
[09:31:18.628]                 }
[09:31:18.628]                 {
[09:31:18.628]                   {
[09:31:18.628]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.628]                     NULL
[09:31:18.628]                   }
[09:31:18.628]                   options(future.plan = NULL)
[09:31:18.628]                   if (is.na(NA_character_)) 
[09:31:18.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.628]                     .init = FALSE)
[09:31:18.628]                 }
[09:31:18.628]             }
[09:31:18.628]         }
[09:31:18.628]     })
[09:31:18.628]     if (TRUE) {
[09:31:18.628]         base::sink(type = "output", split = FALSE)
[09:31:18.628]         if (TRUE) {
[09:31:18.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.628]         }
[09:31:18.628]         else {
[09:31:18.628]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.628]         }
[09:31:18.628]         base::close(...future.stdout)
[09:31:18.628]         ...future.stdout <- NULL
[09:31:18.628]     }
[09:31:18.628]     ...future.result$conditions <- ...future.conditions
[09:31:18.628]     ...future.result$finished <- base::Sys.time()
[09:31:18.628]     ...future.result
[09:31:18.628] }
[09:31:18.630] assign_globals() ...
[09:31:18.630] List of 2
[09:31:18.630]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.630]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.630]  - attr(*, "where")=List of 2
[09:31:18.630]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.630]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.630]  - attr(*, "resolved")= logi FALSE
[09:31:18.630]  - attr(*, "total_size")= num 896
[09:31:18.630]  - attr(*, "already-done")= logi TRUE
[09:31:18.634] - copied ‘weight’ to environment
[09:31:18.634] - copied ‘group’ to environment
[09:31:18.634] assign_globals() ... done
[09:31:18.634] requestCore(): workers = 2
[09:31:18.636] MulticoreFuture started
[09:31:18.636] - Launch lazy future ... done
[09:31:18.637] run() for ‘MulticoreFuture’ ... done
[09:31:18.637] result() for MulticoreFuture ...
[09:31:18.637] plan(): Setting new future strategy stack:
[09:31:18.638] List of future strategies:
[09:31:18.638] 1. sequential:
[09:31:18.638]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.638]    - tweaked: FALSE
[09:31:18.638]    - call: NULL
[09:31:18.639] plan(): nbrOfWorkers() = 1
[09:31:18.642] plan(): Setting new future strategy stack:
[09:31:18.642] List of future strategies:
[09:31:18.642] 1. multicore:
[09:31:18.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.642]    - tweaked: FALSE
[09:31:18.642]    - call: plan(strategy)
[09:31:18.647] plan(): nbrOfWorkers() = 2
[09:31:18.649] result() for MulticoreFuture ...
[09:31:18.649] result() for MulticoreFuture ... done
[09:31:18.649] result() for MulticoreFuture ... done
[09:31:18.650] result() for MulticoreFuture ...
[09:31:18.650] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:18.652] getGlobalsAndPackages() ...
[09:31:18.652] Searching for globals...
[09:31:18.654] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:18.654] Searching for globals ... DONE
[09:31:18.654] Resolving globals: FALSE
[09:31:18.655] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:18.656] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:18.656] - globals: [2] ‘weight’, ‘group’
[09:31:18.656] - packages: [1] ‘stats’
[09:31:18.656] getGlobalsAndPackages() ... DONE
[09:31:18.656] run() for ‘Future’ ...
[09:31:18.657] - state: ‘created’
[09:31:18.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.661]   - Field: ‘label’
[09:31:18.661]   - Field: ‘local’
[09:31:18.661]   - Field: ‘owner’
[09:31:18.661]   - Field: ‘envir’
[09:31:18.661]   - Field: ‘workers’
[09:31:18.661]   - Field: ‘packages’
[09:31:18.662]   - Field: ‘gc’
[09:31:18.662]   - Field: ‘job’
[09:31:18.662]   - Field: ‘conditions’
[09:31:18.662]   - Field: ‘expr’
[09:31:18.662]   - Field: ‘uuid’
[09:31:18.662]   - Field: ‘seed’
[09:31:18.662]   - Field: ‘version’
[09:31:18.662]   - Field: ‘result’
[09:31:18.662]   - Field: ‘asynchronous’
[09:31:18.663]   - Field: ‘calls’
[09:31:18.663]   - Field: ‘globals’
[09:31:18.663]   - Field: ‘stdout’
[09:31:18.663]   - Field: ‘earlySignal’
[09:31:18.663]   - Field: ‘lazy’
[09:31:18.663]   - Field: ‘state’
[09:31:18.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.664] - Launch lazy future ...
[09:31:18.664] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.664] Packages needed by future strategies (n = 0): <none>
[09:31:18.665] {
[09:31:18.665]     {
[09:31:18.665]         {
[09:31:18.665]             ...future.startTime <- base::Sys.time()
[09:31:18.665]             {
[09:31:18.665]                 {
[09:31:18.665]                   {
[09:31:18.665]                     {
[09:31:18.665]                       {
[09:31:18.665]                         base::local({
[09:31:18.665]                           has_future <- base::requireNamespace("future", 
[09:31:18.665]                             quietly = TRUE)
[09:31:18.665]                           if (has_future) {
[09:31:18.665]                             ns <- base::getNamespace("future")
[09:31:18.665]                             version <- ns[[".package"]][["version"]]
[09:31:18.665]                             if (is.null(version)) 
[09:31:18.665]                               version <- utils::packageVersion("future")
[09:31:18.665]                           }
[09:31:18.665]                           else {
[09:31:18.665]                             version <- NULL
[09:31:18.665]                           }
[09:31:18.665]                           if (!has_future || version < "1.8.0") {
[09:31:18.665]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.665]                               "", base::R.version$version.string), 
[09:31:18.665]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.665]                                 base::R.version$platform, 8 * 
[09:31:18.665]                                   base::.Machine$sizeof.pointer), 
[09:31:18.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.665]                                 "release", "version")], collapse = " "), 
[09:31:18.665]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.665]                               info)
[09:31:18.665]                             info <- base::paste(info, collapse = "; ")
[09:31:18.665]                             if (!has_future) {
[09:31:18.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.665]                                 info)
[09:31:18.665]                             }
[09:31:18.665]                             else {
[09:31:18.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.665]                                 info, version)
[09:31:18.665]                             }
[09:31:18.665]                             base::stop(msg)
[09:31:18.665]                           }
[09:31:18.665]                         })
[09:31:18.665]                       }
[09:31:18.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.665]                       base::options(mc.cores = 1L)
[09:31:18.665]                     }
[09:31:18.665]                     base::local({
[09:31:18.665]                       for (pkg in "stats") {
[09:31:18.665]                         base::loadNamespace(pkg)
[09:31:18.665]                         base::library(pkg, character.only = TRUE)
[09:31:18.665]                       }
[09:31:18.665]                     })
[09:31:18.665]                   }
[09:31:18.665]                   ...future.strategy.old <- future::plan("list")
[09:31:18.665]                   options(future.plan = NULL)
[09:31:18.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.665]                 }
[09:31:18.665]                 ...future.workdir <- getwd()
[09:31:18.665]             }
[09:31:18.665]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.665]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.665]         }
[09:31:18.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.665]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.665]             base::names(...future.oldOptions))
[09:31:18.665]     }
[09:31:18.665]     if (FALSE) {
[09:31:18.665]     }
[09:31:18.665]     else {
[09:31:18.665]         if (TRUE) {
[09:31:18.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.665]                 open = "w")
[09:31:18.665]         }
[09:31:18.665]         else {
[09:31:18.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.665]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.665]         }
[09:31:18.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.665]             base::sink(type = "output", split = FALSE)
[09:31:18.665]             base::close(...future.stdout)
[09:31:18.665]         }, add = TRUE)
[09:31:18.665]     }
[09:31:18.665]     ...future.frame <- base::sys.nframe()
[09:31:18.665]     ...future.conditions <- base::list()
[09:31:18.665]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.665]     if (FALSE) {
[09:31:18.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.665]     }
[09:31:18.665]     ...future.result <- base::tryCatch({
[09:31:18.665]         base::withCallingHandlers({
[09:31:18.665]             ...future.value <- base::withVisible(base::local({
[09:31:18.665]                 withCallingHandlers({
[09:31:18.665]                   {
[09:31:18.665]                     lm(weight ~ group - 1)
[09:31:18.665]                   }
[09:31:18.665]                 }, immediateCondition = function(cond) {
[09:31:18.665]                   save_rds <- function (object, pathname, ...) 
[09:31:18.665]                   {
[09:31:18.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.665]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.665]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.665]                         fi_tmp[["mtime"]])
[09:31:18.665]                     }
[09:31:18.665]                     tryCatch({
[09:31:18.665]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.665]                     }, error = function(ex) {
[09:31:18.665]                       msg <- conditionMessage(ex)
[09:31:18.665]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.665]                         fi_tmp[["mtime"]], msg)
[09:31:18.665]                       ex$message <- msg
[09:31:18.665]                       stop(ex)
[09:31:18.665]                     })
[09:31:18.665]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.665]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.665]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.665]                       fi <- file.info(pathname)
[09:31:18.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.665]                         fi[["size"]], fi[["mtime"]])
[09:31:18.665]                       stop(msg)
[09:31:18.665]                     }
[09:31:18.665]                     invisible(pathname)
[09:31:18.665]                   }
[09:31:18.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.665]                     rootPath = tempdir()) 
[09:31:18.665]                   {
[09:31:18.665]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.665]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.665]                       tmpdir = path, fileext = ".rds")
[09:31:18.665]                     save_rds(obj, file)
[09:31:18.665]                   }
[09:31:18.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.665]                   {
[09:31:18.665]                     inherits <- base::inherits
[09:31:18.665]                     invokeRestart <- base::invokeRestart
[09:31:18.665]                     is.null <- base::is.null
[09:31:18.665]                     muffled <- FALSE
[09:31:18.665]                     if (inherits(cond, "message")) {
[09:31:18.665]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.665]                       if (muffled) 
[09:31:18.665]                         invokeRestart("muffleMessage")
[09:31:18.665]                     }
[09:31:18.665]                     else if (inherits(cond, "warning")) {
[09:31:18.665]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.665]                       if (muffled) 
[09:31:18.665]                         invokeRestart("muffleWarning")
[09:31:18.665]                     }
[09:31:18.665]                     else if (inherits(cond, "condition")) {
[09:31:18.665]                       if (!is.null(pattern)) {
[09:31:18.665]                         computeRestarts <- base::computeRestarts
[09:31:18.665]                         grepl <- base::grepl
[09:31:18.665]                         restarts <- computeRestarts(cond)
[09:31:18.665]                         for (restart in restarts) {
[09:31:18.665]                           name <- restart$name
[09:31:18.665]                           if (is.null(name)) 
[09:31:18.665]                             next
[09:31:18.665]                           if (!grepl(pattern, name)) 
[09:31:18.665]                             next
[09:31:18.665]                           invokeRestart(restart)
[09:31:18.665]                           muffled <- TRUE
[09:31:18.665]                           break
[09:31:18.665]                         }
[09:31:18.665]                       }
[09:31:18.665]                     }
[09:31:18.665]                     invisible(muffled)
[09:31:18.665]                   }
[09:31:18.665]                   muffleCondition(cond)
[09:31:18.665]                 })
[09:31:18.665]             }))
[09:31:18.665]             future::FutureResult(value = ...future.value$value, 
[09:31:18.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.665]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.665]                     ...future.globalenv.names))
[09:31:18.665]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.665]         }, condition = base::local({
[09:31:18.665]             c <- base::c
[09:31:18.665]             inherits <- base::inherits
[09:31:18.665]             invokeRestart <- base::invokeRestart
[09:31:18.665]             length <- base::length
[09:31:18.665]             list <- base::list
[09:31:18.665]             seq.int <- base::seq.int
[09:31:18.665]             signalCondition <- base::signalCondition
[09:31:18.665]             sys.calls <- base::sys.calls
[09:31:18.665]             `[[` <- base::`[[`
[09:31:18.665]             `+` <- base::`+`
[09:31:18.665]             `<<-` <- base::`<<-`
[09:31:18.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.665]                   3L)]
[09:31:18.665]             }
[09:31:18.665]             function(cond) {
[09:31:18.665]                 is_error <- inherits(cond, "error")
[09:31:18.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.665]                   NULL)
[09:31:18.665]                 if (is_error) {
[09:31:18.665]                   sessionInformation <- function() {
[09:31:18.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.665]                       search = base::search(), system = base::Sys.info())
[09:31:18.665]                   }
[09:31:18.665]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.665]                     cond$call), session = sessionInformation(), 
[09:31:18.665]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.665]                   signalCondition(cond)
[09:31:18.665]                 }
[09:31:18.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.665]                 "immediateCondition"))) {
[09:31:18.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.665]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.665]                   if (TRUE && !signal) {
[09:31:18.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.665]                     {
[09:31:18.665]                       inherits <- base::inherits
[09:31:18.665]                       invokeRestart <- base::invokeRestart
[09:31:18.665]                       is.null <- base::is.null
[09:31:18.665]                       muffled <- FALSE
[09:31:18.665]                       if (inherits(cond, "message")) {
[09:31:18.665]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.665]                         if (muffled) 
[09:31:18.665]                           invokeRestart("muffleMessage")
[09:31:18.665]                       }
[09:31:18.665]                       else if (inherits(cond, "warning")) {
[09:31:18.665]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.665]                         if (muffled) 
[09:31:18.665]                           invokeRestart("muffleWarning")
[09:31:18.665]                       }
[09:31:18.665]                       else if (inherits(cond, "condition")) {
[09:31:18.665]                         if (!is.null(pattern)) {
[09:31:18.665]                           computeRestarts <- base::computeRestarts
[09:31:18.665]                           grepl <- base::grepl
[09:31:18.665]                           restarts <- computeRestarts(cond)
[09:31:18.665]                           for (restart in restarts) {
[09:31:18.665]                             name <- restart$name
[09:31:18.665]                             if (is.null(name)) 
[09:31:18.665]                               next
[09:31:18.665]                             if (!grepl(pattern, name)) 
[09:31:18.665]                               next
[09:31:18.665]                             invokeRestart(restart)
[09:31:18.665]                             muffled <- TRUE
[09:31:18.665]                             break
[09:31:18.665]                           }
[09:31:18.665]                         }
[09:31:18.665]                       }
[09:31:18.665]                       invisible(muffled)
[09:31:18.665]                     }
[09:31:18.665]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.665]                   }
[09:31:18.665]                 }
[09:31:18.665]                 else {
[09:31:18.665]                   if (TRUE) {
[09:31:18.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.665]                     {
[09:31:18.665]                       inherits <- base::inherits
[09:31:18.665]                       invokeRestart <- base::invokeRestart
[09:31:18.665]                       is.null <- base::is.null
[09:31:18.665]                       muffled <- FALSE
[09:31:18.665]                       if (inherits(cond, "message")) {
[09:31:18.665]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.665]                         if (muffled) 
[09:31:18.665]                           invokeRestart("muffleMessage")
[09:31:18.665]                       }
[09:31:18.665]                       else if (inherits(cond, "warning")) {
[09:31:18.665]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.665]                         if (muffled) 
[09:31:18.665]                           invokeRestart("muffleWarning")
[09:31:18.665]                       }
[09:31:18.665]                       else if (inherits(cond, "condition")) {
[09:31:18.665]                         if (!is.null(pattern)) {
[09:31:18.665]                           computeRestarts <- base::computeRestarts
[09:31:18.665]                           grepl <- base::grepl
[09:31:18.665]                           restarts <- computeRestarts(cond)
[09:31:18.665]                           for (restart in restarts) {
[09:31:18.665]                             name <- restart$name
[09:31:18.665]                             if (is.null(name)) 
[09:31:18.665]                               next
[09:31:18.665]                             if (!grepl(pattern, name)) 
[09:31:18.665]                               next
[09:31:18.665]                             invokeRestart(restart)
[09:31:18.665]                             muffled <- TRUE
[09:31:18.665]                             break
[09:31:18.665]                           }
[09:31:18.665]                         }
[09:31:18.665]                       }
[09:31:18.665]                       invisible(muffled)
[09:31:18.665]                     }
[09:31:18.665]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.665]                   }
[09:31:18.665]                 }
[09:31:18.665]             }
[09:31:18.665]         }))
[09:31:18.665]     }, error = function(ex) {
[09:31:18.665]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.665]                 ...future.rng), started = ...future.startTime, 
[09:31:18.665]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.665]             version = "1.8"), class = "FutureResult")
[09:31:18.665]     }, finally = {
[09:31:18.665]         if (!identical(...future.workdir, getwd())) 
[09:31:18.665]             setwd(...future.workdir)
[09:31:18.665]         {
[09:31:18.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.665]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.665]             }
[09:31:18.665]             base::options(...future.oldOptions)
[09:31:18.665]             if (.Platform$OS.type == "windows") {
[09:31:18.665]                 old_names <- names(...future.oldEnvVars)
[09:31:18.665]                 envs <- base::Sys.getenv()
[09:31:18.665]                 names <- names(envs)
[09:31:18.665]                 common <- intersect(names, old_names)
[09:31:18.665]                 added <- setdiff(names, old_names)
[09:31:18.665]                 removed <- setdiff(old_names, names)
[09:31:18.665]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.665]                   envs[common]]
[09:31:18.665]                 NAMES <- toupper(changed)
[09:31:18.665]                 args <- list()
[09:31:18.665]                 for (kk in seq_along(NAMES)) {
[09:31:18.665]                   name <- changed[[kk]]
[09:31:18.665]                   NAME <- NAMES[[kk]]
[09:31:18.665]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.665]                     next
[09:31:18.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.665]                 }
[09:31:18.665]                 NAMES <- toupper(added)
[09:31:18.665]                 for (kk in seq_along(NAMES)) {
[09:31:18.665]                   name <- added[[kk]]
[09:31:18.665]                   NAME <- NAMES[[kk]]
[09:31:18.665]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.665]                     next
[09:31:18.665]                   args[[name]] <- ""
[09:31:18.665]                 }
[09:31:18.665]                 NAMES <- toupper(removed)
[09:31:18.665]                 for (kk in seq_along(NAMES)) {
[09:31:18.665]                   name <- removed[[kk]]
[09:31:18.665]                   NAME <- NAMES[[kk]]
[09:31:18.665]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.665]                     next
[09:31:18.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.665]                 }
[09:31:18.665]                 if (length(args) > 0) 
[09:31:18.665]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.665]             }
[09:31:18.665]             else {
[09:31:18.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.665]             }
[09:31:18.665]             {
[09:31:18.665]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.665]                   0L) {
[09:31:18.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.665]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.665]                   base::options(opts)
[09:31:18.665]                 }
[09:31:18.665]                 {
[09:31:18.665]                   {
[09:31:18.665]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.665]                     NULL
[09:31:18.665]                   }
[09:31:18.665]                   options(future.plan = NULL)
[09:31:18.665]                   if (is.na(NA_character_)) 
[09:31:18.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.665]                     .init = FALSE)
[09:31:18.665]                 }
[09:31:18.665]             }
[09:31:18.665]         }
[09:31:18.665]     })
[09:31:18.665]     if (TRUE) {
[09:31:18.665]         base::sink(type = "output", split = FALSE)
[09:31:18.665]         if (TRUE) {
[09:31:18.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.665]         }
[09:31:18.665]         else {
[09:31:18.665]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.665]         }
[09:31:18.665]         base::close(...future.stdout)
[09:31:18.665]         ...future.stdout <- NULL
[09:31:18.665]     }
[09:31:18.665]     ...future.result$conditions <- ...future.conditions
[09:31:18.665]     ...future.result$finished <- base::Sys.time()
[09:31:18.665]     ...future.result
[09:31:18.665] }
[09:31:18.667] assign_globals() ...
[09:31:18.667] List of 2
[09:31:18.667]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[09:31:18.667]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[09:31:18.667]  - attr(*, "where")=List of 2
[09:31:18.667]   ..$ weight:<environment: R_EmptyEnv> 
[09:31:18.667]   ..$ group :<environment: R_EmptyEnv> 
[09:31:18.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.667]  - attr(*, "resolved")= logi FALSE
[09:31:18.667]  - attr(*, "total_size")= num 896
[09:31:18.667]  - attr(*, "already-done")= logi TRUE
[09:31:18.674] - copied ‘weight’ to environment
[09:31:18.674] - copied ‘group’ to environment
[09:31:18.674] assign_globals() ... done
[09:31:18.674] requestCore(): workers = 2
[09:31:18.676] MulticoreFuture started
[09:31:18.676] - Launch lazy future ... done
[09:31:18.677] run() for ‘MulticoreFuture’ ... done
[09:31:18.677] result() for MulticoreFuture ...
[09:31:18.677] plan(): Setting new future strategy stack:
[09:31:18.678] List of future strategies:
[09:31:18.678] 1. sequential:
[09:31:18.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.678]    - tweaked: FALSE
[09:31:18.678]    - call: NULL
[09:31:18.679] plan(): nbrOfWorkers() = 1
[09:31:18.682] plan(): Setting new future strategy stack:
[09:31:18.682] List of future strategies:
[09:31:18.682] 1. multicore:
[09:31:18.682]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.682]    - tweaked: FALSE
[09:31:18.682]    - call: plan(strategy)
[09:31:18.687] plan(): nbrOfWorkers() = 2
[09:31:18.689] result() for MulticoreFuture ...
[09:31:18.690] result() for MulticoreFuture ... done
[09:31:18.690] result() for MulticoreFuture ... done
[09:31:18.690] result() for MulticoreFuture ...
[09:31:18.690] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[09:31:18.692] getGlobalsAndPackages() ...
[09:31:18.692] Searching for globals...
[09:31:18.694] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[09:31:18.694] Searching for globals ... DONE
[09:31:18.694] Resolving globals: FALSE
[09:31:18.695] The total size of the 1 globals is 96 bytes (96 bytes)
[09:31:18.695] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[09:31:18.695] - globals: [1] ‘x’
[09:31:18.695] - packages: [1] ‘stats’
[09:31:18.696] getGlobalsAndPackages() ... DONE
[09:31:18.696] run() for ‘Future’ ...
[09:31:18.696] - state: ‘created’
[09:31:18.696] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.700]   - Field: ‘label’
[09:31:18.700]   - Field: ‘local’
[09:31:18.701]   - Field: ‘owner’
[09:31:18.701]   - Field: ‘envir’
[09:31:18.701]   - Field: ‘workers’
[09:31:18.701]   - Field: ‘packages’
[09:31:18.701]   - Field: ‘gc’
[09:31:18.701]   - Field: ‘job’
[09:31:18.701]   - Field: ‘conditions’
[09:31:18.701]   - Field: ‘expr’
[09:31:18.701]   - Field: ‘uuid’
[09:31:18.702]   - Field: ‘seed’
[09:31:18.702]   - Field: ‘version’
[09:31:18.702]   - Field: ‘result’
[09:31:18.702]   - Field: ‘asynchronous’
[09:31:18.702]   - Field: ‘calls’
[09:31:18.702]   - Field: ‘globals’
[09:31:18.702]   - Field: ‘stdout’
[09:31:18.702]   - Field: ‘earlySignal’
[09:31:18.703]   - Field: ‘lazy’
[09:31:18.703]   - Field: ‘state’
[09:31:18.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.703] - Launch lazy future ...
[09:31:18.703] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.703] Packages needed by future strategies (n = 0): <none>
[09:31:18.704] {
[09:31:18.704]     {
[09:31:18.704]         {
[09:31:18.704]             ...future.startTime <- base::Sys.time()
[09:31:18.704]             {
[09:31:18.704]                 {
[09:31:18.704]                   {
[09:31:18.704]                     {
[09:31:18.704]                       {
[09:31:18.704]                         base::local({
[09:31:18.704]                           has_future <- base::requireNamespace("future", 
[09:31:18.704]                             quietly = TRUE)
[09:31:18.704]                           if (has_future) {
[09:31:18.704]                             ns <- base::getNamespace("future")
[09:31:18.704]                             version <- ns[[".package"]][["version"]]
[09:31:18.704]                             if (is.null(version)) 
[09:31:18.704]                               version <- utils::packageVersion("future")
[09:31:18.704]                           }
[09:31:18.704]                           else {
[09:31:18.704]                             version <- NULL
[09:31:18.704]                           }
[09:31:18.704]                           if (!has_future || version < "1.8.0") {
[09:31:18.704]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.704]                               "", base::R.version$version.string), 
[09:31:18.704]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.704]                                 base::R.version$platform, 8 * 
[09:31:18.704]                                   base::.Machine$sizeof.pointer), 
[09:31:18.704]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.704]                                 "release", "version")], collapse = " "), 
[09:31:18.704]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.704]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.704]                               info)
[09:31:18.704]                             info <- base::paste(info, collapse = "; ")
[09:31:18.704]                             if (!has_future) {
[09:31:18.704]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.704]                                 info)
[09:31:18.704]                             }
[09:31:18.704]                             else {
[09:31:18.704]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.704]                                 info, version)
[09:31:18.704]                             }
[09:31:18.704]                             base::stop(msg)
[09:31:18.704]                           }
[09:31:18.704]                         })
[09:31:18.704]                       }
[09:31:18.704]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.704]                       base::options(mc.cores = 1L)
[09:31:18.704]                     }
[09:31:18.704]                     base::local({
[09:31:18.704]                       for (pkg in "stats") {
[09:31:18.704]                         base::loadNamespace(pkg)
[09:31:18.704]                         base::library(pkg, character.only = TRUE)
[09:31:18.704]                       }
[09:31:18.704]                     })
[09:31:18.704]                   }
[09:31:18.704]                   ...future.strategy.old <- future::plan("list")
[09:31:18.704]                   options(future.plan = NULL)
[09:31:18.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.704]                 }
[09:31:18.704]                 ...future.workdir <- getwd()
[09:31:18.704]             }
[09:31:18.704]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.704]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.704]         }
[09:31:18.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.704]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.704]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.704]             base::names(...future.oldOptions))
[09:31:18.704]     }
[09:31:18.704]     if (FALSE) {
[09:31:18.704]     }
[09:31:18.704]     else {
[09:31:18.704]         if (TRUE) {
[09:31:18.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.704]                 open = "w")
[09:31:18.704]         }
[09:31:18.704]         else {
[09:31:18.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.704]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.704]         }
[09:31:18.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.704]             base::sink(type = "output", split = FALSE)
[09:31:18.704]             base::close(...future.stdout)
[09:31:18.704]         }, add = TRUE)
[09:31:18.704]     }
[09:31:18.704]     ...future.frame <- base::sys.nframe()
[09:31:18.704]     ...future.conditions <- base::list()
[09:31:18.704]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.704]     if (FALSE) {
[09:31:18.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.704]     }
[09:31:18.704]     ...future.result <- base::tryCatch({
[09:31:18.704]         base::withCallingHandlers({
[09:31:18.704]             ...future.value <- base::withVisible(base::local({
[09:31:18.704]                 withCallingHandlers({
[09:31:18.704]                   {
[09:31:18.704]                     xtabs(~x)
[09:31:18.704]                   }
[09:31:18.704]                 }, immediateCondition = function(cond) {
[09:31:18.704]                   save_rds <- function (object, pathname, ...) 
[09:31:18.704]                   {
[09:31:18.704]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.704]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.704]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.704]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.704]                         fi_tmp[["mtime"]])
[09:31:18.704]                     }
[09:31:18.704]                     tryCatch({
[09:31:18.704]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.704]                     }, error = function(ex) {
[09:31:18.704]                       msg <- conditionMessage(ex)
[09:31:18.704]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.704]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.704]                         fi_tmp[["mtime"]], msg)
[09:31:18.704]                       ex$message <- msg
[09:31:18.704]                       stop(ex)
[09:31:18.704]                     })
[09:31:18.704]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.704]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.704]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.704]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.704]                       fi <- file.info(pathname)
[09:31:18.704]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.704]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.704]                         fi[["size"]], fi[["mtime"]])
[09:31:18.704]                       stop(msg)
[09:31:18.704]                     }
[09:31:18.704]                     invisible(pathname)
[09:31:18.704]                   }
[09:31:18.704]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.704]                     rootPath = tempdir()) 
[09:31:18.704]                   {
[09:31:18.704]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.704]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.704]                       tmpdir = path, fileext = ".rds")
[09:31:18.704]                     save_rds(obj, file)
[09:31:18.704]                   }
[09:31:18.704]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.704]                   {
[09:31:18.704]                     inherits <- base::inherits
[09:31:18.704]                     invokeRestart <- base::invokeRestart
[09:31:18.704]                     is.null <- base::is.null
[09:31:18.704]                     muffled <- FALSE
[09:31:18.704]                     if (inherits(cond, "message")) {
[09:31:18.704]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.704]                       if (muffled) 
[09:31:18.704]                         invokeRestart("muffleMessage")
[09:31:18.704]                     }
[09:31:18.704]                     else if (inherits(cond, "warning")) {
[09:31:18.704]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.704]                       if (muffled) 
[09:31:18.704]                         invokeRestart("muffleWarning")
[09:31:18.704]                     }
[09:31:18.704]                     else if (inherits(cond, "condition")) {
[09:31:18.704]                       if (!is.null(pattern)) {
[09:31:18.704]                         computeRestarts <- base::computeRestarts
[09:31:18.704]                         grepl <- base::grepl
[09:31:18.704]                         restarts <- computeRestarts(cond)
[09:31:18.704]                         for (restart in restarts) {
[09:31:18.704]                           name <- restart$name
[09:31:18.704]                           if (is.null(name)) 
[09:31:18.704]                             next
[09:31:18.704]                           if (!grepl(pattern, name)) 
[09:31:18.704]                             next
[09:31:18.704]                           invokeRestart(restart)
[09:31:18.704]                           muffled <- TRUE
[09:31:18.704]                           break
[09:31:18.704]                         }
[09:31:18.704]                       }
[09:31:18.704]                     }
[09:31:18.704]                     invisible(muffled)
[09:31:18.704]                   }
[09:31:18.704]                   muffleCondition(cond)
[09:31:18.704]                 })
[09:31:18.704]             }))
[09:31:18.704]             future::FutureResult(value = ...future.value$value, 
[09:31:18.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.704]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.704]                     ...future.globalenv.names))
[09:31:18.704]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.704]         }, condition = base::local({
[09:31:18.704]             c <- base::c
[09:31:18.704]             inherits <- base::inherits
[09:31:18.704]             invokeRestart <- base::invokeRestart
[09:31:18.704]             length <- base::length
[09:31:18.704]             list <- base::list
[09:31:18.704]             seq.int <- base::seq.int
[09:31:18.704]             signalCondition <- base::signalCondition
[09:31:18.704]             sys.calls <- base::sys.calls
[09:31:18.704]             `[[` <- base::`[[`
[09:31:18.704]             `+` <- base::`+`
[09:31:18.704]             `<<-` <- base::`<<-`
[09:31:18.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.704]                   3L)]
[09:31:18.704]             }
[09:31:18.704]             function(cond) {
[09:31:18.704]                 is_error <- inherits(cond, "error")
[09:31:18.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.704]                   NULL)
[09:31:18.704]                 if (is_error) {
[09:31:18.704]                   sessionInformation <- function() {
[09:31:18.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.704]                       search = base::search(), system = base::Sys.info())
[09:31:18.704]                   }
[09:31:18.704]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.704]                     cond$call), session = sessionInformation(), 
[09:31:18.704]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.704]                   signalCondition(cond)
[09:31:18.704]                 }
[09:31:18.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.704]                 "immediateCondition"))) {
[09:31:18.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.704]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.704]                   if (TRUE && !signal) {
[09:31:18.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.704]                     {
[09:31:18.704]                       inherits <- base::inherits
[09:31:18.704]                       invokeRestart <- base::invokeRestart
[09:31:18.704]                       is.null <- base::is.null
[09:31:18.704]                       muffled <- FALSE
[09:31:18.704]                       if (inherits(cond, "message")) {
[09:31:18.704]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.704]                         if (muffled) 
[09:31:18.704]                           invokeRestart("muffleMessage")
[09:31:18.704]                       }
[09:31:18.704]                       else if (inherits(cond, "warning")) {
[09:31:18.704]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.704]                         if (muffled) 
[09:31:18.704]                           invokeRestart("muffleWarning")
[09:31:18.704]                       }
[09:31:18.704]                       else if (inherits(cond, "condition")) {
[09:31:18.704]                         if (!is.null(pattern)) {
[09:31:18.704]                           computeRestarts <- base::computeRestarts
[09:31:18.704]                           grepl <- base::grepl
[09:31:18.704]                           restarts <- computeRestarts(cond)
[09:31:18.704]                           for (restart in restarts) {
[09:31:18.704]                             name <- restart$name
[09:31:18.704]                             if (is.null(name)) 
[09:31:18.704]                               next
[09:31:18.704]                             if (!grepl(pattern, name)) 
[09:31:18.704]                               next
[09:31:18.704]                             invokeRestart(restart)
[09:31:18.704]                             muffled <- TRUE
[09:31:18.704]                             break
[09:31:18.704]                           }
[09:31:18.704]                         }
[09:31:18.704]                       }
[09:31:18.704]                       invisible(muffled)
[09:31:18.704]                     }
[09:31:18.704]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.704]                   }
[09:31:18.704]                 }
[09:31:18.704]                 else {
[09:31:18.704]                   if (TRUE) {
[09:31:18.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.704]                     {
[09:31:18.704]                       inherits <- base::inherits
[09:31:18.704]                       invokeRestart <- base::invokeRestart
[09:31:18.704]                       is.null <- base::is.null
[09:31:18.704]                       muffled <- FALSE
[09:31:18.704]                       if (inherits(cond, "message")) {
[09:31:18.704]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.704]                         if (muffled) 
[09:31:18.704]                           invokeRestart("muffleMessage")
[09:31:18.704]                       }
[09:31:18.704]                       else if (inherits(cond, "warning")) {
[09:31:18.704]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.704]                         if (muffled) 
[09:31:18.704]                           invokeRestart("muffleWarning")
[09:31:18.704]                       }
[09:31:18.704]                       else if (inherits(cond, "condition")) {
[09:31:18.704]                         if (!is.null(pattern)) {
[09:31:18.704]                           computeRestarts <- base::computeRestarts
[09:31:18.704]                           grepl <- base::grepl
[09:31:18.704]                           restarts <- computeRestarts(cond)
[09:31:18.704]                           for (restart in restarts) {
[09:31:18.704]                             name <- restart$name
[09:31:18.704]                             if (is.null(name)) 
[09:31:18.704]                               next
[09:31:18.704]                             if (!grepl(pattern, name)) 
[09:31:18.704]                               next
[09:31:18.704]                             invokeRestart(restart)
[09:31:18.704]                             muffled <- TRUE
[09:31:18.704]                             break
[09:31:18.704]                           }
[09:31:18.704]                         }
[09:31:18.704]                       }
[09:31:18.704]                       invisible(muffled)
[09:31:18.704]                     }
[09:31:18.704]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.704]                   }
[09:31:18.704]                 }
[09:31:18.704]             }
[09:31:18.704]         }))
[09:31:18.704]     }, error = function(ex) {
[09:31:18.704]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.704]                 ...future.rng), started = ...future.startTime, 
[09:31:18.704]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.704]             version = "1.8"), class = "FutureResult")
[09:31:18.704]     }, finally = {
[09:31:18.704]         if (!identical(...future.workdir, getwd())) 
[09:31:18.704]             setwd(...future.workdir)
[09:31:18.704]         {
[09:31:18.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.704]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.704]             }
[09:31:18.704]             base::options(...future.oldOptions)
[09:31:18.704]             if (.Platform$OS.type == "windows") {
[09:31:18.704]                 old_names <- names(...future.oldEnvVars)
[09:31:18.704]                 envs <- base::Sys.getenv()
[09:31:18.704]                 names <- names(envs)
[09:31:18.704]                 common <- intersect(names, old_names)
[09:31:18.704]                 added <- setdiff(names, old_names)
[09:31:18.704]                 removed <- setdiff(old_names, names)
[09:31:18.704]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.704]                   envs[common]]
[09:31:18.704]                 NAMES <- toupper(changed)
[09:31:18.704]                 args <- list()
[09:31:18.704]                 for (kk in seq_along(NAMES)) {
[09:31:18.704]                   name <- changed[[kk]]
[09:31:18.704]                   NAME <- NAMES[[kk]]
[09:31:18.704]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.704]                     next
[09:31:18.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.704]                 }
[09:31:18.704]                 NAMES <- toupper(added)
[09:31:18.704]                 for (kk in seq_along(NAMES)) {
[09:31:18.704]                   name <- added[[kk]]
[09:31:18.704]                   NAME <- NAMES[[kk]]
[09:31:18.704]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.704]                     next
[09:31:18.704]                   args[[name]] <- ""
[09:31:18.704]                 }
[09:31:18.704]                 NAMES <- toupper(removed)
[09:31:18.704]                 for (kk in seq_along(NAMES)) {
[09:31:18.704]                   name <- removed[[kk]]
[09:31:18.704]                   NAME <- NAMES[[kk]]
[09:31:18.704]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.704]                     next
[09:31:18.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.704]                 }
[09:31:18.704]                 if (length(args) > 0) 
[09:31:18.704]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.704]             }
[09:31:18.704]             else {
[09:31:18.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.704]             }
[09:31:18.704]             {
[09:31:18.704]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.704]                   0L) {
[09:31:18.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.704]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.704]                   base::options(opts)
[09:31:18.704]                 }
[09:31:18.704]                 {
[09:31:18.704]                   {
[09:31:18.704]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.704]                     NULL
[09:31:18.704]                   }
[09:31:18.704]                   options(future.plan = NULL)
[09:31:18.704]                   if (is.na(NA_character_)) 
[09:31:18.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.704]                     .init = FALSE)
[09:31:18.704]                 }
[09:31:18.704]             }
[09:31:18.704]         }
[09:31:18.704]     })
[09:31:18.704]     if (TRUE) {
[09:31:18.704]         base::sink(type = "output", split = FALSE)
[09:31:18.704]         if (TRUE) {
[09:31:18.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.704]         }
[09:31:18.704]         else {
[09:31:18.704]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.704]         }
[09:31:18.704]         base::close(...future.stdout)
[09:31:18.704]         ...future.stdout <- NULL
[09:31:18.704]     }
[09:31:18.704]     ...future.result$conditions <- ...future.conditions
[09:31:18.704]     ...future.result$finished <- base::Sys.time()
[09:31:18.704]     ...future.result
[09:31:18.704] }
[09:31:18.706] assign_globals() ...
[09:31:18.707] List of 1
[09:31:18.707]  $ x: num [1:5] 1 1 2 2 2
[09:31:18.707]  - attr(*, "where")=List of 1
[09:31:18.707]   ..$ x:<environment: R_EmptyEnv> 
[09:31:18.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.707]  - attr(*, "resolved")= logi FALSE
[09:31:18.707]  - attr(*, "total_size")= num 96
[09:31:18.707]  - attr(*, "already-done")= logi TRUE
[09:31:18.709] - copied ‘x’ to environment
[09:31:18.710] assign_globals() ... done
[09:31:18.710] requestCore(): workers = 2
[09:31:18.711] MulticoreFuture started
[09:31:18.712] - Launch lazy future ... done
[09:31:18.712] run() for ‘MulticoreFuture’ ... done
[09:31:18.712] result() for MulticoreFuture ...
[09:31:18.713] plan(): Setting new future strategy stack:
[09:31:18.713] List of future strategies:
[09:31:18.713] 1. sequential:
[09:31:18.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.713]    - tweaked: FALSE
[09:31:18.713]    - call: NULL
[09:31:18.714] plan(): nbrOfWorkers() = 1
[09:31:18.717] plan(): Setting new future strategy stack:
[09:31:18.717] List of future strategies:
[09:31:18.717] 1. multicore:
[09:31:18.717]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.717]    - tweaked: FALSE
[09:31:18.717]    - call: plan(strategy)
[09:31:18.725] plan(): nbrOfWorkers() = 2
[09:31:18.726] result() for MulticoreFuture ...
[09:31:18.726] result() for MulticoreFuture ... done
[09:31:18.727] result() for MulticoreFuture ... done
[09:31:18.727] result() for MulticoreFuture ...
[09:31:18.727] result() for MulticoreFuture ... done
x
1 2 
2 3 
[09:31:18.728] getGlobalsAndPackages() ...
[09:31:18.728] Searching for globals...
[09:31:18.732] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[09:31:18.732] Searching for globals ... DONE
[09:31:18.732] Resolving globals: FALSE
[09:31:18.733] The total size of the 1 globals is 96 bytes (96 bytes)
[09:31:18.734] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[09:31:18.734] - globals: [1] ‘x’
[09:31:18.734] - packages: [1] ‘stats’
[09:31:18.734] getGlobalsAndPackages() ... DONE
[09:31:18.734] run() for ‘Future’ ...
[09:31:18.735] - state: ‘created’
[09:31:18.735] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.739]   - Field: ‘label’
[09:31:18.739]   - Field: ‘local’
[09:31:18.739]   - Field: ‘owner’
[09:31:18.739]   - Field: ‘envir’
[09:31:18.739]   - Field: ‘workers’
[09:31:18.739]   - Field: ‘packages’
[09:31:18.740]   - Field: ‘gc’
[09:31:18.740]   - Field: ‘job’
[09:31:18.740]   - Field: ‘conditions’
[09:31:18.740]   - Field: ‘expr’
[09:31:18.740]   - Field: ‘uuid’
[09:31:18.740]   - Field: ‘seed’
[09:31:18.740]   - Field: ‘version’
[09:31:18.740]   - Field: ‘result’
[09:31:18.740]   - Field: ‘asynchronous’
[09:31:18.741]   - Field: ‘calls’
[09:31:18.741]   - Field: ‘globals’
[09:31:18.741]   - Field: ‘stdout’
[09:31:18.741]   - Field: ‘earlySignal’
[09:31:18.741]   - Field: ‘lazy’
[09:31:18.741]   - Field: ‘state’
[09:31:18.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.741] - Launch lazy future ...
[09:31:18.742] Packages needed by the future expression (n = 1): ‘stats’
[09:31:18.742] Packages needed by future strategies (n = 0): <none>
[09:31:18.742] {
[09:31:18.742]     {
[09:31:18.742]         {
[09:31:18.742]             ...future.startTime <- base::Sys.time()
[09:31:18.742]             {
[09:31:18.742]                 {
[09:31:18.742]                   {
[09:31:18.742]                     {
[09:31:18.742]                       {
[09:31:18.742]                         base::local({
[09:31:18.742]                           has_future <- base::requireNamespace("future", 
[09:31:18.742]                             quietly = TRUE)
[09:31:18.742]                           if (has_future) {
[09:31:18.742]                             ns <- base::getNamespace("future")
[09:31:18.742]                             version <- ns[[".package"]][["version"]]
[09:31:18.742]                             if (is.null(version)) 
[09:31:18.742]                               version <- utils::packageVersion("future")
[09:31:18.742]                           }
[09:31:18.742]                           else {
[09:31:18.742]                             version <- NULL
[09:31:18.742]                           }
[09:31:18.742]                           if (!has_future || version < "1.8.0") {
[09:31:18.742]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.742]                               "", base::R.version$version.string), 
[09:31:18.742]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.742]                                 base::R.version$platform, 8 * 
[09:31:18.742]                                   base::.Machine$sizeof.pointer), 
[09:31:18.742]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.742]                                 "release", "version")], collapse = " "), 
[09:31:18.742]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.742]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.742]                               info)
[09:31:18.742]                             info <- base::paste(info, collapse = "; ")
[09:31:18.742]                             if (!has_future) {
[09:31:18.742]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.742]                                 info)
[09:31:18.742]                             }
[09:31:18.742]                             else {
[09:31:18.742]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.742]                                 info, version)
[09:31:18.742]                             }
[09:31:18.742]                             base::stop(msg)
[09:31:18.742]                           }
[09:31:18.742]                         })
[09:31:18.742]                       }
[09:31:18.742]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.742]                       base::options(mc.cores = 1L)
[09:31:18.742]                     }
[09:31:18.742]                     base::local({
[09:31:18.742]                       for (pkg in "stats") {
[09:31:18.742]                         base::loadNamespace(pkg)
[09:31:18.742]                         base::library(pkg, character.only = TRUE)
[09:31:18.742]                       }
[09:31:18.742]                     })
[09:31:18.742]                   }
[09:31:18.742]                   ...future.strategy.old <- future::plan("list")
[09:31:18.742]                   options(future.plan = NULL)
[09:31:18.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.742]                 }
[09:31:18.742]                 ...future.workdir <- getwd()
[09:31:18.742]             }
[09:31:18.742]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.742]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.742]         }
[09:31:18.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.742]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.742]             base::names(...future.oldOptions))
[09:31:18.742]     }
[09:31:18.742]     if (FALSE) {
[09:31:18.742]     }
[09:31:18.742]     else {
[09:31:18.742]         if (TRUE) {
[09:31:18.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.742]                 open = "w")
[09:31:18.742]         }
[09:31:18.742]         else {
[09:31:18.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.742]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.742]         }
[09:31:18.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.742]             base::sink(type = "output", split = FALSE)
[09:31:18.742]             base::close(...future.stdout)
[09:31:18.742]         }, add = TRUE)
[09:31:18.742]     }
[09:31:18.742]     ...future.frame <- base::sys.nframe()
[09:31:18.742]     ...future.conditions <- base::list()
[09:31:18.742]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.742]     if (FALSE) {
[09:31:18.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.742]     }
[09:31:18.742]     ...future.result <- base::tryCatch({
[09:31:18.742]         base::withCallingHandlers({
[09:31:18.742]             ...future.value <- base::withVisible(base::local({
[09:31:18.742]                 withCallingHandlers({
[09:31:18.742]                   {
[09:31:18.742]                     xtabs(~x)
[09:31:18.742]                   }
[09:31:18.742]                 }, immediateCondition = function(cond) {
[09:31:18.742]                   save_rds <- function (object, pathname, ...) 
[09:31:18.742]                   {
[09:31:18.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.742]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.742]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.742]                         fi_tmp[["mtime"]])
[09:31:18.742]                     }
[09:31:18.742]                     tryCatch({
[09:31:18.742]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.742]                     }, error = function(ex) {
[09:31:18.742]                       msg <- conditionMessage(ex)
[09:31:18.742]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.742]                         fi_tmp[["mtime"]], msg)
[09:31:18.742]                       ex$message <- msg
[09:31:18.742]                       stop(ex)
[09:31:18.742]                     })
[09:31:18.742]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.742]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.742]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.742]                       fi <- file.info(pathname)
[09:31:18.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.742]                         fi[["size"]], fi[["mtime"]])
[09:31:18.742]                       stop(msg)
[09:31:18.742]                     }
[09:31:18.742]                     invisible(pathname)
[09:31:18.742]                   }
[09:31:18.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.742]                     rootPath = tempdir()) 
[09:31:18.742]                   {
[09:31:18.742]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.742]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.742]                       tmpdir = path, fileext = ".rds")
[09:31:18.742]                     save_rds(obj, file)
[09:31:18.742]                   }
[09:31:18.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.742]                   {
[09:31:18.742]                     inherits <- base::inherits
[09:31:18.742]                     invokeRestart <- base::invokeRestart
[09:31:18.742]                     is.null <- base::is.null
[09:31:18.742]                     muffled <- FALSE
[09:31:18.742]                     if (inherits(cond, "message")) {
[09:31:18.742]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.742]                       if (muffled) 
[09:31:18.742]                         invokeRestart("muffleMessage")
[09:31:18.742]                     }
[09:31:18.742]                     else if (inherits(cond, "warning")) {
[09:31:18.742]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.742]                       if (muffled) 
[09:31:18.742]                         invokeRestart("muffleWarning")
[09:31:18.742]                     }
[09:31:18.742]                     else if (inherits(cond, "condition")) {
[09:31:18.742]                       if (!is.null(pattern)) {
[09:31:18.742]                         computeRestarts <- base::computeRestarts
[09:31:18.742]                         grepl <- base::grepl
[09:31:18.742]                         restarts <- computeRestarts(cond)
[09:31:18.742]                         for (restart in restarts) {
[09:31:18.742]                           name <- restart$name
[09:31:18.742]                           if (is.null(name)) 
[09:31:18.742]                             next
[09:31:18.742]                           if (!grepl(pattern, name)) 
[09:31:18.742]                             next
[09:31:18.742]                           invokeRestart(restart)
[09:31:18.742]                           muffled <- TRUE
[09:31:18.742]                           break
[09:31:18.742]                         }
[09:31:18.742]                       }
[09:31:18.742]                     }
[09:31:18.742]                     invisible(muffled)
[09:31:18.742]                   }
[09:31:18.742]                   muffleCondition(cond)
[09:31:18.742]                 })
[09:31:18.742]             }))
[09:31:18.742]             future::FutureResult(value = ...future.value$value, 
[09:31:18.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.742]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.742]                     ...future.globalenv.names))
[09:31:18.742]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.742]         }, condition = base::local({
[09:31:18.742]             c <- base::c
[09:31:18.742]             inherits <- base::inherits
[09:31:18.742]             invokeRestart <- base::invokeRestart
[09:31:18.742]             length <- base::length
[09:31:18.742]             list <- base::list
[09:31:18.742]             seq.int <- base::seq.int
[09:31:18.742]             signalCondition <- base::signalCondition
[09:31:18.742]             sys.calls <- base::sys.calls
[09:31:18.742]             `[[` <- base::`[[`
[09:31:18.742]             `+` <- base::`+`
[09:31:18.742]             `<<-` <- base::`<<-`
[09:31:18.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.742]                   3L)]
[09:31:18.742]             }
[09:31:18.742]             function(cond) {
[09:31:18.742]                 is_error <- inherits(cond, "error")
[09:31:18.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.742]                   NULL)
[09:31:18.742]                 if (is_error) {
[09:31:18.742]                   sessionInformation <- function() {
[09:31:18.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.742]                       search = base::search(), system = base::Sys.info())
[09:31:18.742]                   }
[09:31:18.742]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.742]                     cond$call), session = sessionInformation(), 
[09:31:18.742]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.742]                   signalCondition(cond)
[09:31:18.742]                 }
[09:31:18.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.742]                 "immediateCondition"))) {
[09:31:18.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.742]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.742]                   if (TRUE && !signal) {
[09:31:18.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.742]                     {
[09:31:18.742]                       inherits <- base::inherits
[09:31:18.742]                       invokeRestart <- base::invokeRestart
[09:31:18.742]                       is.null <- base::is.null
[09:31:18.742]                       muffled <- FALSE
[09:31:18.742]                       if (inherits(cond, "message")) {
[09:31:18.742]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.742]                         if (muffled) 
[09:31:18.742]                           invokeRestart("muffleMessage")
[09:31:18.742]                       }
[09:31:18.742]                       else if (inherits(cond, "warning")) {
[09:31:18.742]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.742]                         if (muffled) 
[09:31:18.742]                           invokeRestart("muffleWarning")
[09:31:18.742]                       }
[09:31:18.742]                       else if (inherits(cond, "condition")) {
[09:31:18.742]                         if (!is.null(pattern)) {
[09:31:18.742]                           computeRestarts <- base::computeRestarts
[09:31:18.742]                           grepl <- base::grepl
[09:31:18.742]                           restarts <- computeRestarts(cond)
[09:31:18.742]                           for (restart in restarts) {
[09:31:18.742]                             name <- restart$name
[09:31:18.742]                             if (is.null(name)) 
[09:31:18.742]                               next
[09:31:18.742]                             if (!grepl(pattern, name)) 
[09:31:18.742]                               next
[09:31:18.742]                             invokeRestart(restart)
[09:31:18.742]                             muffled <- TRUE
[09:31:18.742]                             break
[09:31:18.742]                           }
[09:31:18.742]                         }
[09:31:18.742]                       }
[09:31:18.742]                       invisible(muffled)
[09:31:18.742]                     }
[09:31:18.742]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.742]                   }
[09:31:18.742]                 }
[09:31:18.742]                 else {
[09:31:18.742]                   if (TRUE) {
[09:31:18.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.742]                     {
[09:31:18.742]                       inherits <- base::inherits
[09:31:18.742]                       invokeRestart <- base::invokeRestart
[09:31:18.742]                       is.null <- base::is.null
[09:31:18.742]                       muffled <- FALSE
[09:31:18.742]                       if (inherits(cond, "message")) {
[09:31:18.742]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.742]                         if (muffled) 
[09:31:18.742]                           invokeRestart("muffleMessage")
[09:31:18.742]                       }
[09:31:18.742]                       else if (inherits(cond, "warning")) {
[09:31:18.742]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.742]                         if (muffled) 
[09:31:18.742]                           invokeRestart("muffleWarning")
[09:31:18.742]                       }
[09:31:18.742]                       else if (inherits(cond, "condition")) {
[09:31:18.742]                         if (!is.null(pattern)) {
[09:31:18.742]                           computeRestarts <- base::computeRestarts
[09:31:18.742]                           grepl <- base::grepl
[09:31:18.742]                           restarts <- computeRestarts(cond)
[09:31:18.742]                           for (restart in restarts) {
[09:31:18.742]                             name <- restart$name
[09:31:18.742]                             if (is.null(name)) 
[09:31:18.742]                               next
[09:31:18.742]                             if (!grepl(pattern, name)) 
[09:31:18.742]                               next
[09:31:18.742]                             invokeRestart(restart)
[09:31:18.742]                             muffled <- TRUE
[09:31:18.742]                             break
[09:31:18.742]                           }
[09:31:18.742]                         }
[09:31:18.742]                       }
[09:31:18.742]                       invisible(muffled)
[09:31:18.742]                     }
[09:31:18.742]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.742]                   }
[09:31:18.742]                 }
[09:31:18.742]             }
[09:31:18.742]         }))
[09:31:18.742]     }, error = function(ex) {
[09:31:18.742]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.742]                 ...future.rng), started = ...future.startTime, 
[09:31:18.742]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.742]             version = "1.8"), class = "FutureResult")
[09:31:18.742]     }, finally = {
[09:31:18.742]         if (!identical(...future.workdir, getwd())) 
[09:31:18.742]             setwd(...future.workdir)
[09:31:18.742]         {
[09:31:18.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.742]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.742]             }
[09:31:18.742]             base::options(...future.oldOptions)
[09:31:18.742]             if (.Platform$OS.type == "windows") {
[09:31:18.742]                 old_names <- names(...future.oldEnvVars)
[09:31:18.742]                 envs <- base::Sys.getenv()
[09:31:18.742]                 names <- names(envs)
[09:31:18.742]                 common <- intersect(names, old_names)
[09:31:18.742]                 added <- setdiff(names, old_names)
[09:31:18.742]                 removed <- setdiff(old_names, names)
[09:31:18.742]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.742]                   envs[common]]
[09:31:18.742]                 NAMES <- toupper(changed)
[09:31:18.742]                 args <- list()
[09:31:18.742]                 for (kk in seq_along(NAMES)) {
[09:31:18.742]                   name <- changed[[kk]]
[09:31:18.742]                   NAME <- NAMES[[kk]]
[09:31:18.742]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.742]                     next
[09:31:18.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.742]                 }
[09:31:18.742]                 NAMES <- toupper(added)
[09:31:18.742]                 for (kk in seq_along(NAMES)) {
[09:31:18.742]                   name <- added[[kk]]
[09:31:18.742]                   NAME <- NAMES[[kk]]
[09:31:18.742]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.742]                     next
[09:31:18.742]                   args[[name]] <- ""
[09:31:18.742]                 }
[09:31:18.742]                 NAMES <- toupper(removed)
[09:31:18.742]                 for (kk in seq_along(NAMES)) {
[09:31:18.742]                   name <- removed[[kk]]
[09:31:18.742]                   NAME <- NAMES[[kk]]
[09:31:18.742]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.742]                     next
[09:31:18.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.742]                 }
[09:31:18.742]                 if (length(args) > 0) 
[09:31:18.742]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.742]             }
[09:31:18.742]             else {
[09:31:18.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.742]             }
[09:31:18.742]             {
[09:31:18.742]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.742]                   0L) {
[09:31:18.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.742]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.742]                   base::options(opts)
[09:31:18.742]                 }
[09:31:18.742]                 {
[09:31:18.742]                   {
[09:31:18.742]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.742]                     NULL
[09:31:18.742]                   }
[09:31:18.742]                   options(future.plan = NULL)
[09:31:18.742]                   if (is.na(NA_character_)) 
[09:31:18.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.742]                     .init = FALSE)
[09:31:18.742]                 }
[09:31:18.742]             }
[09:31:18.742]         }
[09:31:18.742]     })
[09:31:18.742]     if (TRUE) {
[09:31:18.742]         base::sink(type = "output", split = FALSE)
[09:31:18.742]         if (TRUE) {
[09:31:18.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.742]         }
[09:31:18.742]         else {
[09:31:18.742]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.742]         }
[09:31:18.742]         base::close(...future.stdout)
[09:31:18.742]         ...future.stdout <- NULL
[09:31:18.742]     }
[09:31:18.742]     ...future.result$conditions <- ...future.conditions
[09:31:18.742]     ...future.result$finished <- base::Sys.time()
[09:31:18.742]     ...future.result
[09:31:18.742] }
[09:31:18.745] assign_globals() ...
[09:31:18.745] List of 1
[09:31:18.745]  $ x: num [1:5] 1 1 2 2 2
[09:31:18.745]  - attr(*, "where")=List of 1
[09:31:18.745]   ..$ x:<environment: R_EmptyEnv> 
[09:31:18.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:18.745]  - attr(*, "resolved")= logi FALSE
[09:31:18.745]  - attr(*, "total_size")= num 96
[09:31:18.745]  - attr(*, "already-done")= logi TRUE
[09:31:18.748] - copied ‘x’ to environment
[09:31:18.748] assign_globals() ... done
[09:31:18.748] requestCore(): workers = 2
[09:31:18.750] MulticoreFuture started
[09:31:18.750] - Launch lazy future ... done
[09:31:18.750] run() for ‘MulticoreFuture’ ... done
[09:31:18.751] result() for MulticoreFuture ...
[09:31:18.751] plan(): Setting new future strategy stack:
[09:31:18.751] List of future strategies:
[09:31:18.751] 1. sequential:
[09:31:18.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.751]    - tweaked: FALSE
[09:31:18.751]    - call: NULL
[09:31:18.752] plan(): nbrOfWorkers() = 1
[09:31:18.755] plan(): Setting new future strategy stack:
[09:31:18.755] List of future strategies:
[09:31:18.755] 1. multicore:
[09:31:18.755]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.755]    - tweaked: FALSE
[09:31:18.755]    - call: plan(strategy)
[09:31:18.760] plan(): nbrOfWorkers() = 2
[09:31:18.761] result() for MulticoreFuture ...
[09:31:18.761] result() for MulticoreFuture ... done
[09:31:18.761] result() for MulticoreFuture ... done
[09:31:18.761] result() for MulticoreFuture ...
[09:31:18.761] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[09:31:18.764] getGlobalsAndPackages() ...
[09:31:18.764] Searching for globals...
[09:31:18.766] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[09:31:18.766] Searching for globals ... DONE
[09:31:18.766] Resolving globals: FALSE
[09:31:18.767] 
[09:31:18.767] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.767] getGlobalsAndPackages() ... DONE
[09:31:18.767] run() for ‘Future’ ...
[09:31:18.768] - state: ‘created’
[09:31:18.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.772] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.772]   - Field: ‘label’
[09:31:18.772]   - Field: ‘local’
[09:31:18.772]   - Field: ‘owner’
[09:31:18.772]   - Field: ‘envir’
[09:31:18.773]   - Field: ‘workers’
[09:31:18.773]   - Field: ‘packages’
[09:31:18.773]   - Field: ‘gc’
[09:31:18.773]   - Field: ‘job’
[09:31:18.773]   - Field: ‘conditions’
[09:31:18.773]   - Field: ‘expr’
[09:31:18.773]   - Field: ‘uuid’
[09:31:18.773]   - Field: ‘seed’
[09:31:18.773]   - Field: ‘version’
[09:31:18.774]   - Field: ‘result’
[09:31:18.774]   - Field: ‘asynchronous’
[09:31:18.774]   - Field: ‘calls’
[09:31:18.774]   - Field: ‘globals’
[09:31:18.774]   - Field: ‘stdout’
[09:31:18.774]   - Field: ‘earlySignal’
[09:31:18.774]   - Field: ‘lazy’
[09:31:18.774]   - Field: ‘state’
[09:31:18.774] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.775] - Launch lazy future ...
[09:31:18.775] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.775] Packages needed by future strategies (n = 0): <none>
[09:31:18.778] {
[09:31:18.778]     {
[09:31:18.778]         {
[09:31:18.778]             ...future.startTime <- base::Sys.time()
[09:31:18.778]             {
[09:31:18.778]                 {
[09:31:18.778]                   {
[09:31:18.778]                     {
[09:31:18.778]                       {
[09:31:18.778]                         base::local({
[09:31:18.778]                           has_future <- base::requireNamespace("future", 
[09:31:18.778]                             quietly = TRUE)
[09:31:18.778]                           if (has_future) {
[09:31:18.778]                             ns <- base::getNamespace("future")
[09:31:18.778]                             version <- ns[[".package"]][["version"]]
[09:31:18.778]                             if (is.null(version)) 
[09:31:18.778]                               version <- utils::packageVersion("future")
[09:31:18.778]                           }
[09:31:18.778]                           else {
[09:31:18.778]                             version <- NULL
[09:31:18.778]                           }
[09:31:18.778]                           if (!has_future || version < "1.8.0") {
[09:31:18.778]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.778]                               "", base::R.version$version.string), 
[09:31:18.778]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.778]                                 base::R.version$platform, 8 * 
[09:31:18.778]                                   base::.Machine$sizeof.pointer), 
[09:31:18.778]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.778]                                 "release", "version")], collapse = " "), 
[09:31:18.778]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.778]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.778]                               info)
[09:31:18.778]                             info <- base::paste(info, collapse = "; ")
[09:31:18.778]                             if (!has_future) {
[09:31:18.778]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.778]                                 info)
[09:31:18.778]                             }
[09:31:18.778]                             else {
[09:31:18.778]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.778]                                 info, version)
[09:31:18.778]                             }
[09:31:18.778]                             base::stop(msg)
[09:31:18.778]                           }
[09:31:18.778]                         })
[09:31:18.778]                       }
[09:31:18.778]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.778]                       base::options(mc.cores = 1L)
[09:31:18.778]                     }
[09:31:18.778]                     base::local({
[09:31:18.778]                       for (pkg in c("stats", "datasets")) {
[09:31:18.778]                         base::loadNamespace(pkg)
[09:31:18.778]                         base::library(pkg, character.only = TRUE)
[09:31:18.778]                       }
[09:31:18.778]                     })
[09:31:18.778]                   }
[09:31:18.778]                   ...future.strategy.old <- future::plan("list")
[09:31:18.778]                   options(future.plan = NULL)
[09:31:18.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.778]                 }
[09:31:18.778]                 ...future.workdir <- getwd()
[09:31:18.778]             }
[09:31:18.778]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.778]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.778]         }
[09:31:18.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.778]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.778]             base::names(...future.oldOptions))
[09:31:18.778]     }
[09:31:18.778]     if (FALSE) {
[09:31:18.778]     }
[09:31:18.778]     else {
[09:31:18.778]         if (TRUE) {
[09:31:18.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.778]                 open = "w")
[09:31:18.778]         }
[09:31:18.778]         else {
[09:31:18.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.778]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.778]         }
[09:31:18.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.778]             base::sink(type = "output", split = FALSE)
[09:31:18.778]             base::close(...future.stdout)
[09:31:18.778]         }, add = TRUE)
[09:31:18.778]     }
[09:31:18.778]     ...future.frame <- base::sys.nframe()
[09:31:18.778]     ...future.conditions <- base::list()
[09:31:18.778]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.778]     if (FALSE) {
[09:31:18.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.778]     }
[09:31:18.778]     ...future.result <- base::tryCatch({
[09:31:18.778]         base::withCallingHandlers({
[09:31:18.778]             ...future.value <- base::withVisible(base::local({
[09:31:18.778]                 withCallingHandlers({
[09:31:18.778]                   {
[09:31:18.778]                     lm(dist ~ . - 1, data = cars)
[09:31:18.778]                   }
[09:31:18.778]                 }, immediateCondition = function(cond) {
[09:31:18.778]                   save_rds <- function (object, pathname, ...) 
[09:31:18.778]                   {
[09:31:18.778]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.778]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.778]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.778]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.778]                         fi_tmp[["mtime"]])
[09:31:18.778]                     }
[09:31:18.778]                     tryCatch({
[09:31:18.778]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.778]                     }, error = function(ex) {
[09:31:18.778]                       msg <- conditionMessage(ex)
[09:31:18.778]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.778]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.778]                         fi_tmp[["mtime"]], msg)
[09:31:18.778]                       ex$message <- msg
[09:31:18.778]                       stop(ex)
[09:31:18.778]                     })
[09:31:18.778]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.778]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.778]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.778]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.778]                       fi <- file.info(pathname)
[09:31:18.778]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.778]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.778]                         fi[["size"]], fi[["mtime"]])
[09:31:18.778]                       stop(msg)
[09:31:18.778]                     }
[09:31:18.778]                     invisible(pathname)
[09:31:18.778]                   }
[09:31:18.778]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.778]                     rootPath = tempdir()) 
[09:31:18.778]                   {
[09:31:18.778]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.778]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.778]                       tmpdir = path, fileext = ".rds")
[09:31:18.778]                     save_rds(obj, file)
[09:31:18.778]                   }
[09:31:18.778]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.778]                   {
[09:31:18.778]                     inherits <- base::inherits
[09:31:18.778]                     invokeRestart <- base::invokeRestart
[09:31:18.778]                     is.null <- base::is.null
[09:31:18.778]                     muffled <- FALSE
[09:31:18.778]                     if (inherits(cond, "message")) {
[09:31:18.778]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.778]                       if (muffled) 
[09:31:18.778]                         invokeRestart("muffleMessage")
[09:31:18.778]                     }
[09:31:18.778]                     else if (inherits(cond, "warning")) {
[09:31:18.778]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.778]                       if (muffled) 
[09:31:18.778]                         invokeRestart("muffleWarning")
[09:31:18.778]                     }
[09:31:18.778]                     else if (inherits(cond, "condition")) {
[09:31:18.778]                       if (!is.null(pattern)) {
[09:31:18.778]                         computeRestarts <- base::computeRestarts
[09:31:18.778]                         grepl <- base::grepl
[09:31:18.778]                         restarts <- computeRestarts(cond)
[09:31:18.778]                         for (restart in restarts) {
[09:31:18.778]                           name <- restart$name
[09:31:18.778]                           if (is.null(name)) 
[09:31:18.778]                             next
[09:31:18.778]                           if (!grepl(pattern, name)) 
[09:31:18.778]                             next
[09:31:18.778]                           invokeRestart(restart)
[09:31:18.778]                           muffled <- TRUE
[09:31:18.778]                           break
[09:31:18.778]                         }
[09:31:18.778]                       }
[09:31:18.778]                     }
[09:31:18.778]                     invisible(muffled)
[09:31:18.778]                   }
[09:31:18.778]                   muffleCondition(cond)
[09:31:18.778]                 })
[09:31:18.778]             }))
[09:31:18.778]             future::FutureResult(value = ...future.value$value, 
[09:31:18.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.778]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.778]                     ...future.globalenv.names))
[09:31:18.778]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.778]         }, condition = base::local({
[09:31:18.778]             c <- base::c
[09:31:18.778]             inherits <- base::inherits
[09:31:18.778]             invokeRestart <- base::invokeRestart
[09:31:18.778]             length <- base::length
[09:31:18.778]             list <- base::list
[09:31:18.778]             seq.int <- base::seq.int
[09:31:18.778]             signalCondition <- base::signalCondition
[09:31:18.778]             sys.calls <- base::sys.calls
[09:31:18.778]             `[[` <- base::`[[`
[09:31:18.778]             `+` <- base::`+`
[09:31:18.778]             `<<-` <- base::`<<-`
[09:31:18.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.778]                   3L)]
[09:31:18.778]             }
[09:31:18.778]             function(cond) {
[09:31:18.778]                 is_error <- inherits(cond, "error")
[09:31:18.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.778]                   NULL)
[09:31:18.778]                 if (is_error) {
[09:31:18.778]                   sessionInformation <- function() {
[09:31:18.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.778]                       search = base::search(), system = base::Sys.info())
[09:31:18.778]                   }
[09:31:18.778]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.778]                     cond$call), session = sessionInformation(), 
[09:31:18.778]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.778]                   signalCondition(cond)
[09:31:18.778]                 }
[09:31:18.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.778]                 "immediateCondition"))) {
[09:31:18.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.778]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.778]                   if (TRUE && !signal) {
[09:31:18.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.778]                     {
[09:31:18.778]                       inherits <- base::inherits
[09:31:18.778]                       invokeRestart <- base::invokeRestart
[09:31:18.778]                       is.null <- base::is.null
[09:31:18.778]                       muffled <- FALSE
[09:31:18.778]                       if (inherits(cond, "message")) {
[09:31:18.778]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.778]                         if (muffled) 
[09:31:18.778]                           invokeRestart("muffleMessage")
[09:31:18.778]                       }
[09:31:18.778]                       else if (inherits(cond, "warning")) {
[09:31:18.778]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.778]                         if (muffled) 
[09:31:18.778]                           invokeRestart("muffleWarning")
[09:31:18.778]                       }
[09:31:18.778]                       else if (inherits(cond, "condition")) {
[09:31:18.778]                         if (!is.null(pattern)) {
[09:31:18.778]                           computeRestarts <- base::computeRestarts
[09:31:18.778]                           grepl <- base::grepl
[09:31:18.778]                           restarts <- computeRestarts(cond)
[09:31:18.778]                           for (restart in restarts) {
[09:31:18.778]                             name <- restart$name
[09:31:18.778]                             if (is.null(name)) 
[09:31:18.778]                               next
[09:31:18.778]                             if (!grepl(pattern, name)) 
[09:31:18.778]                               next
[09:31:18.778]                             invokeRestart(restart)
[09:31:18.778]                             muffled <- TRUE
[09:31:18.778]                             break
[09:31:18.778]                           }
[09:31:18.778]                         }
[09:31:18.778]                       }
[09:31:18.778]                       invisible(muffled)
[09:31:18.778]                     }
[09:31:18.778]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.778]                   }
[09:31:18.778]                 }
[09:31:18.778]                 else {
[09:31:18.778]                   if (TRUE) {
[09:31:18.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.778]                     {
[09:31:18.778]                       inherits <- base::inherits
[09:31:18.778]                       invokeRestart <- base::invokeRestart
[09:31:18.778]                       is.null <- base::is.null
[09:31:18.778]                       muffled <- FALSE
[09:31:18.778]                       if (inherits(cond, "message")) {
[09:31:18.778]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.778]                         if (muffled) 
[09:31:18.778]                           invokeRestart("muffleMessage")
[09:31:18.778]                       }
[09:31:18.778]                       else if (inherits(cond, "warning")) {
[09:31:18.778]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.778]                         if (muffled) 
[09:31:18.778]                           invokeRestart("muffleWarning")
[09:31:18.778]                       }
[09:31:18.778]                       else if (inherits(cond, "condition")) {
[09:31:18.778]                         if (!is.null(pattern)) {
[09:31:18.778]                           computeRestarts <- base::computeRestarts
[09:31:18.778]                           grepl <- base::grepl
[09:31:18.778]                           restarts <- computeRestarts(cond)
[09:31:18.778]                           for (restart in restarts) {
[09:31:18.778]                             name <- restart$name
[09:31:18.778]                             if (is.null(name)) 
[09:31:18.778]                               next
[09:31:18.778]                             if (!grepl(pattern, name)) 
[09:31:18.778]                               next
[09:31:18.778]                             invokeRestart(restart)
[09:31:18.778]                             muffled <- TRUE
[09:31:18.778]                             break
[09:31:18.778]                           }
[09:31:18.778]                         }
[09:31:18.778]                       }
[09:31:18.778]                       invisible(muffled)
[09:31:18.778]                     }
[09:31:18.778]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.778]                   }
[09:31:18.778]                 }
[09:31:18.778]             }
[09:31:18.778]         }))
[09:31:18.778]     }, error = function(ex) {
[09:31:18.778]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.778]                 ...future.rng), started = ...future.startTime, 
[09:31:18.778]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.778]             version = "1.8"), class = "FutureResult")
[09:31:18.778]     }, finally = {
[09:31:18.778]         if (!identical(...future.workdir, getwd())) 
[09:31:18.778]             setwd(...future.workdir)
[09:31:18.778]         {
[09:31:18.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.778]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.778]             }
[09:31:18.778]             base::options(...future.oldOptions)
[09:31:18.778]             if (.Platform$OS.type == "windows") {
[09:31:18.778]                 old_names <- names(...future.oldEnvVars)
[09:31:18.778]                 envs <- base::Sys.getenv()
[09:31:18.778]                 names <- names(envs)
[09:31:18.778]                 common <- intersect(names, old_names)
[09:31:18.778]                 added <- setdiff(names, old_names)
[09:31:18.778]                 removed <- setdiff(old_names, names)
[09:31:18.778]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.778]                   envs[common]]
[09:31:18.778]                 NAMES <- toupper(changed)
[09:31:18.778]                 args <- list()
[09:31:18.778]                 for (kk in seq_along(NAMES)) {
[09:31:18.778]                   name <- changed[[kk]]
[09:31:18.778]                   NAME <- NAMES[[kk]]
[09:31:18.778]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.778]                     next
[09:31:18.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.778]                 }
[09:31:18.778]                 NAMES <- toupper(added)
[09:31:18.778]                 for (kk in seq_along(NAMES)) {
[09:31:18.778]                   name <- added[[kk]]
[09:31:18.778]                   NAME <- NAMES[[kk]]
[09:31:18.778]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.778]                     next
[09:31:18.778]                   args[[name]] <- ""
[09:31:18.778]                 }
[09:31:18.778]                 NAMES <- toupper(removed)
[09:31:18.778]                 for (kk in seq_along(NAMES)) {
[09:31:18.778]                   name <- removed[[kk]]
[09:31:18.778]                   NAME <- NAMES[[kk]]
[09:31:18.778]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.778]                     next
[09:31:18.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.778]                 }
[09:31:18.778]                 if (length(args) > 0) 
[09:31:18.778]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.778]             }
[09:31:18.778]             else {
[09:31:18.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.778]             }
[09:31:18.778]             {
[09:31:18.778]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.778]                   0L) {
[09:31:18.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.778]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.778]                   base::options(opts)
[09:31:18.778]                 }
[09:31:18.778]                 {
[09:31:18.778]                   {
[09:31:18.778]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.778]                     NULL
[09:31:18.778]                   }
[09:31:18.778]                   options(future.plan = NULL)
[09:31:18.778]                   if (is.na(NA_character_)) 
[09:31:18.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.778]                     .init = FALSE)
[09:31:18.778]                 }
[09:31:18.778]             }
[09:31:18.778]         }
[09:31:18.778]     })
[09:31:18.778]     if (TRUE) {
[09:31:18.778]         base::sink(type = "output", split = FALSE)
[09:31:18.778]         if (TRUE) {
[09:31:18.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.778]         }
[09:31:18.778]         else {
[09:31:18.778]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.778]         }
[09:31:18.778]         base::close(...future.stdout)
[09:31:18.778]         ...future.stdout <- NULL
[09:31:18.778]     }
[09:31:18.778]     ...future.result$conditions <- ...future.conditions
[09:31:18.778]     ...future.result$finished <- base::Sys.time()
[09:31:18.778]     ...future.result
[09:31:18.778] }
[09:31:18.781] requestCore(): workers = 2
[09:31:18.783] MulticoreFuture started
[09:31:18.784] - Launch lazy future ... done
[09:31:18.784] run() for ‘MulticoreFuture’ ... done
[09:31:18.784] result() for MulticoreFuture ...
[09:31:18.785] plan(): Setting new future strategy stack:
[09:31:18.785] List of future strategies:
[09:31:18.785] 1. sequential:
[09:31:18.785]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.785]    - tweaked: FALSE
[09:31:18.785]    - call: NULL
[09:31:18.786] plan(): nbrOfWorkers() = 1
[09:31:18.790] plan(): Setting new future strategy stack:
[09:31:18.790] List of future strategies:
[09:31:18.790] 1. multicore:
[09:31:18.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.790]    - tweaked: FALSE
[09:31:18.790]    - call: plan(strategy)
[09:31:18.795] plan(): nbrOfWorkers() = 2
[09:31:18.798] result() for MulticoreFuture ...
[09:31:18.798] result() for MulticoreFuture ... done
[09:31:18.798] result() for MulticoreFuture ... done
[09:31:18.798] result() for MulticoreFuture ...
[09:31:18.798] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[09:31:18.802] getGlobalsAndPackages() ...
[09:31:18.803] Searching for globals...
[09:31:18.805] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[09:31:18.805] Searching for globals ... DONE
[09:31:18.805] Resolving globals: FALSE
[09:31:18.806] 
[09:31:18.806] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.806] getGlobalsAndPackages() ... DONE
[09:31:18.806] run() for ‘Future’ ...
[09:31:18.806] - state: ‘created’
[09:31:18.807] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.811] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.811] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.811]   - Field: ‘label’
[09:31:18.811]   - Field: ‘local’
[09:31:18.811]   - Field: ‘owner’
[09:31:18.811]   - Field: ‘envir’
[09:31:18.811]   - Field: ‘workers’
[09:31:18.811]   - Field: ‘packages’
[09:31:18.812]   - Field: ‘gc’
[09:31:18.812]   - Field: ‘job’
[09:31:18.812]   - Field: ‘conditions’
[09:31:18.812]   - Field: ‘expr’
[09:31:18.812]   - Field: ‘uuid’
[09:31:18.812]   - Field: ‘seed’
[09:31:18.812]   - Field: ‘version’
[09:31:18.812]   - Field: ‘result’
[09:31:18.813]   - Field: ‘asynchronous’
[09:31:18.813]   - Field: ‘calls’
[09:31:18.813]   - Field: ‘globals’
[09:31:18.813]   - Field: ‘stdout’
[09:31:18.813]   - Field: ‘earlySignal’
[09:31:18.813]   - Field: ‘lazy’
[09:31:18.813]   - Field: ‘state’
[09:31:18.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.813] - Launch lazy future ...
[09:31:18.814] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.814] Packages needed by future strategies (n = 0): <none>
[09:31:18.815] {
[09:31:18.815]     {
[09:31:18.815]         {
[09:31:18.815]             ...future.startTime <- base::Sys.time()
[09:31:18.815]             {
[09:31:18.815]                 {
[09:31:18.815]                   {
[09:31:18.815]                     {
[09:31:18.815]                       {
[09:31:18.815]                         base::local({
[09:31:18.815]                           has_future <- base::requireNamespace("future", 
[09:31:18.815]                             quietly = TRUE)
[09:31:18.815]                           if (has_future) {
[09:31:18.815]                             ns <- base::getNamespace("future")
[09:31:18.815]                             version <- ns[[".package"]][["version"]]
[09:31:18.815]                             if (is.null(version)) 
[09:31:18.815]                               version <- utils::packageVersion("future")
[09:31:18.815]                           }
[09:31:18.815]                           else {
[09:31:18.815]                             version <- NULL
[09:31:18.815]                           }
[09:31:18.815]                           if (!has_future || version < "1.8.0") {
[09:31:18.815]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.815]                               "", base::R.version$version.string), 
[09:31:18.815]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.815]                                 base::R.version$platform, 8 * 
[09:31:18.815]                                   base::.Machine$sizeof.pointer), 
[09:31:18.815]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.815]                                 "release", "version")], collapse = " "), 
[09:31:18.815]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.815]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.815]                               info)
[09:31:18.815]                             info <- base::paste(info, collapse = "; ")
[09:31:18.815]                             if (!has_future) {
[09:31:18.815]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.815]                                 info)
[09:31:18.815]                             }
[09:31:18.815]                             else {
[09:31:18.815]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.815]                                 info, version)
[09:31:18.815]                             }
[09:31:18.815]                             base::stop(msg)
[09:31:18.815]                           }
[09:31:18.815]                         })
[09:31:18.815]                       }
[09:31:18.815]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.815]                       base::options(mc.cores = 1L)
[09:31:18.815]                     }
[09:31:18.815]                     base::local({
[09:31:18.815]                       for (pkg in c("stats", "datasets")) {
[09:31:18.815]                         base::loadNamespace(pkg)
[09:31:18.815]                         base::library(pkg, character.only = TRUE)
[09:31:18.815]                       }
[09:31:18.815]                     })
[09:31:18.815]                   }
[09:31:18.815]                   ...future.strategy.old <- future::plan("list")
[09:31:18.815]                   options(future.plan = NULL)
[09:31:18.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.815]                 }
[09:31:18.815]                 ...future.workdir <- getwd()
[09:31:18.815]             }
[09:31:18.815]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.815]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.815]         }
[09:31:18.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.815]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.815]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.815]             base::names(...future.oldOptions))
[09:31:18.815]     }
[09:31:18.815]     if (FALSE) {
[09:31:18.815]     }
[09:31:18.815]     else {
[09:31:18.815]         if (TRUE) {
[09:31:18.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.815]                 open = "w")
[09:31:18.815]         }
[09:31:18.815]         else {
[09:31:18.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.815]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.815]         }
[09:31:18.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.815]             base::sink(type = "output", split = FALSE)
[09:31:18.815]             base::close(...future.stdout)
[09:31:18.815]         }, add = TRUE)
[09:31:18.815]     }
[09:31:18.815]     ...future.frame <- base::sys.nframe()
[09:31:18.815]     ...future.conditions <- base::list()
[09:31:18.815]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.815]     if (FALSE) {
[09:31:18.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.815]     }
[09:31:18.815]     ...future.result <- base::tryCatch({
[09:31:18.815]         base::withCallingHandlers({
[09:31:18.815]             ...future.value <- base::withVisible(base::local({
[09:31:18.815]                 withCallingHandlers({
[09:31:18.815]                   {
[09:31:18.815]                     lm(dist ~ . + 0, data = cars)
[09:31:18.815]                   }
[09:31:18.815]                 }, immediateCondition = function(cond) {
[09:31:18.815]                   save_rds <- function (object, pathname, ...) 
[09:31:18.815]                   {
[09:31:18.815]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.815]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.815]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.815]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.815]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.815]                         fi_tmp[["mtime"]])
[09:31:18.815]                     }
[09:31:18.815]                     tryCatch({
[09:31:18.815]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.815]                     }, error = function(ex) {
[09:31:18.815]                       msg <- conditionMessage(ex)
[09:31:18.815]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.815]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.815]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.815]                         fi_tmp[["mtime"]], msg)
[09:31:18.815]                       ex$message <- msg
[09:31:18.815]                       stop(ex)
[09:31:18.815]                     })
[09:31:18.815]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.815]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.815]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.815]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.815]                       fi <- file.info(pathname)
[09:31:18.815]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.815]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.815]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.815]                         fi[["size"]], fi[["mtime"]])
[09:31:18.815]                       stop(msg)
[09:31:18.815]                     }
[09:31:18.815]                     invisible(pathname)
[09:31:18.815]                   }
[09:31:18.815]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.815]                     rootPath = tempdir()) 
[09:31:18.815]                   {
[09:31:18.815]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.815]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.815]                       tmpdir = path, fileext = ".rds")
[09:31:18.815]                     save_rds(obj, file)
[09:31:18.815]                   }
[09:31:18.815]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.815]                   {
[09:31:18.815]                     inherits <- base::inherits
[09:31:18.815]                     invokeRestart <- base::invokeRestart
[09:31:18.815]                     is.null <- base::is.null
[09:31:18.815]                     muffled <- FALSE
[09:31:18.815]                     if (inherits(cond, "message")) {
[09:31:18.815]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.815]                       if (muffled) 
[09:31:18.815]                         invokeRestart("muffleMessage")
[09:31:18.815]                     }
[09:31:18.815]                     else if (inherits(cond, "warning")) {
[09:31:18.815]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.815]                       if (muffled) 
[09:31:18.815]                         invokeRestart("muffleWarning")
[09:31:18.815]                     }
[09:31:18.815]                     else if (inherits(cond, "condition")) {
[09:31:18.815]                       if (!is.null(pattern)) {
[09:31:18.815]                         computeRestarts <- base::computeRestarts
[09:31:18.815]                         grepl <- base::grepl
[09:31:18.815]                         restarts <- computeRestarts(cond)
[09:31:18.815]                         for (restart in restarts) {
[09:31:18.815]                           name <- restart$name
[09:31:18.815]                           if (is.null(name)) 
[09:31:18.815]                             next
[09:31:18.815]                           if (!grepl(pattern, name)) 
[09:31:18.815]                             next
[09:31:18.815]                           invokeRestart(restart)
[09:31:18.815]                           muffled <- TRUE
[09:31:18.815]                           break
[09:31:18.815]                         }
[09:31:18.815]                       }
[09:31:18.815]                     }
[09:31:18.815]                     invisible(muffled)
[09:31:18.815]                   }
[09:31:18.815]                   muffleCondition(cond)
[09:31:18.815]                 })
[09:31:18.815]             }))
[09:31:18.815]             future::FutureResult(value = ...future.value$value, 
[09:31:18.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.815]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.815]                     ...future.globalenv.names))
[09:31:18.815]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.815]         }, condition = base::local({
[09:31:18.815]             c <- base::c
[09:31:18.815]             inherits <- base::inherits
[09:31:18.815]             invokeRestart <- base::invokeRestart
[09:31:18.815]             length <- base::length
[09:31:18.815]             list <- base::list
[09:31:18.815]             seq.int <- base::seq.int
[09:31:18.815]             signalCondition <- base::signalCondition
[09:31:18.815]             sys.calls <- base::sys.calls
[09:31:18.815]             `[[` <- base::`[[`
[09:31:18.815]             `+` <- base::`+`
[09:31:18.815]             `<<-` <- base::`<<-`
[09:31:18.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.815]                   3L)]
[09:31:18.815]             }
[09:31:18.815]             function(cond) {
[09:31:18.815]                 is_error <- inherits(cond, "error")
[09:31:18.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.815]                   NULL)
[09:31:18.815]                 if (is_error) {
[09:31:18.815]                   sessionInformation <- function() {
[09:31:18.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.815]                       search = base::search(), system = base::Sys.info())
[09:31:18.815]                   }
[09:31:18.815]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.815]                     cond$call), session = sessionInformation(), 
[09:31:18.815]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.815]                   signalCondition(cond)
[09:31:18.815]                 }
[09:31:18.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.815]                 "immediateCondition"))) {
[09:31:18.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.815]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.815]                   if (TRUE && !signal) {
[09:31:18.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.815]                     {
[09:31:18.815]                       inherits <- base::inherits
[09:31:18.815]                       invokeRestart <- base::invokeRestart
[09:31:18.815]                       is.null <- base::is.null
[09:31:18.815]                       muffled <- FALSE
[09:31:18.815]                       if (inherits(cond, "message")) {
[09:31:18.815]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.815]                         if (muffled) 
[09:31:18.815]                           invokeRestart("muffleMessage")
[09:31:18.815]                       }
[09:31:18.815]                       else if (inherits(cond, "warning")) {
[09:31:18.815]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.815]                         if (muffled) 
[09:31:18.815]                           invokeRestart("muffleWarning")
[09:31:18.815]                       }
[09:31:18.815]                       else if (inherits(cond, "condition")) {
[09:31:18.815]                         if (!is.null(pattern)) {
[09:31:18.815]                           computeRestarts <- base::computeRestarts
[09:31:18.815]                           grepl <- base::grepl
[09:31:18.815]                           restarts <- computeRestarts(cond)
[09:31:18.815]                           for (restart in restarts) {
[09:31:18.815]                             name <- restart$name
[09:31:18.815]                             if (is.null(name)) 
[09:31:18.815]                               next
[09:31:18.815]                             if (!grepl(pattern, name)) 
[09:31:18.815]                               next
[09:31:18.815]                             invokeRestart(restart)
[09:31:18.815]                             muffled <- TRUE
[09:31:18.815]                             break
[09:31:18.815]                           }
[09:31:18.815]                         }
[09:31:18.815]                       }
[09:31:18.815]                       invisible(muffled)
[09:31:18.815]                     }
[09:31:18.815]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.815]                   }
[09:31:18.815]                 }
[09:31:18.815]                 else {
[09:31:18.815]                   if (TRUE) {
[09:31:18.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.815]                     {
[09:31:18.815]                       inherits <- base::inherits
[09:31:18.815]                       invokeRestart <- base::invokeRestart
[09:31:18.815]                       is.null <- base::is.null
[09:31:18.815]                       muffled <- FALSE
[09:31:18.815]                       if (inherits(cond, "message")) {
[09:31:18.815]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.815]                         if (muffled) 
[09:31:18.815]                           invokeRestart("muffleMessage")
[09:31:18.815]                       }
[09:31:18.815]                       else if (inherits(cond, "warning")) {
[09:31:18.815]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.815]                         if (muffled) 
[09:31:18.815]                           invokeRestart("muffleWarning")
[09:31:18.815]                       }
[09:31:18.815]                       else if (inherits(cond, "condition")) {
[09:31:18.815]                         if (!is.null(pattern)) {
[09:31:18.815]                           computeRestarts <- base::computeRestarts
[09:31:18.815]                           grepl <- base::grepl
[09:31:18.815]                           restarts <- computeRestarts(cond)
[09:31:18.815]                           for (restart in restarts) {
[09:31:18.815]                             name <- restart$name
[09:31:18.815]                             if (is.null(name)) 
[09:31:18.815]                               next
[09:31:18.815]                             if (!grepl(pattern, name)) 
[09:31:18.815]                               next
[09:31:18.815]                             invokeRestart(restart)
[09:31:18.815]                             muffled <- TRUE
[09:31:18.815]                             break
[09:31:18.815]                           }
[09:31:18.815]                         }
[09:31:18.815]                       }
[09:31:18.815]                       invisible(muffled)
[09:31:18.815]                     }
[09:31:18.815]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.815]                   }
[09:31:18.815]                 }
[09:31:18.815]             }
[09:31:18.815]         }))
[09:31:18.815]     }, error = function(ex) {
[09:31:18.815]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.815]                 ...future.rng), started = ...future.startTime, 
[09:31:18.815]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.815]             version = "1.8"), class = "FutureResult")
[09:31:18.815]     }, finally = {
[09:31:18.815]         if (!identical(...future.workdir, getwd())) 
[09:31:18.815]             setwd(...future.workdir)
[09:31:18.815]         {
[09:31:18.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.815]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.815]             }
[09:31:18.815]             base::options(...future.oldOptions)
[09:31:18.815]             if (.Platform$OS.type == "windows") {
[09:31:18.815]                 old_names <- names(...future.oldEnvVars)
[09:31:18.815]                 envs <- base::Sys.getenv()
[09:31:18.815]                 names <- names(envs)
[09:31:18.815]                 common <- intersect(names, old_names)
[09:31:18.815]                 added <- setdiff(names, old_names)
[09:31:18.815]                 removed <- setdiff(old_names, names)
[09:31:18.815]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.815]                   envs[common]]
[09:31:18.815]                 NAMES <- toupper(changed)
[09:31:18.815]                 args <- list()
[09:31:18.815]                 for (kk in seq_along(NAMES)) {
[09:31:18.815]                   name <- changed[[kk]]
[09:31:18.815]                   NAME <- NAMES[[kk]]
[09:31:18.815]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.815]                     next
[09:31:18.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.815]                 }
[09:31:18.815]                 NAMES <- toupper(added)
[09:31:18.815]                 for (kk in seq_along(NAMES)) {
[09:31:18.815]                   name <- added[[kk]]
[09:31:18.815]                   NAME <- NAMES[[kk]]
[09:31:18.815]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.815]                     next
[09:31:18.815]                   args[[name]] <- ""
[09:31:18.815]                 }
[09:31:18.815]                 NAMES <- toupper(removed)
[09:31:18.815]                 for (kk in seq_along(NAMES)) {
[09:31:18.815]                   name <- removed[[kk]]
[09:31:18.815]                   NAME <- NAMES[[kk]]
[09:31:18.815]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.815]                     next
[09:31:18.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.815]                 }
[09:31:18.815]                 if (length(args) > 0) 
[09:31:18.815]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.815]             }
[09:31:18.815]             else {
[09:31:18.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.815]             }
[09:31:18.815]             {
[09:31:18.815]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.815]                   0L) {
[09:31:18.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.815]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.815]                   base::options(opts)
[09:31:18.815]                 }
[09:31:18.815]                 {
[09:31:18.815]                   {
[09:31:18.815]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.815]                     NULL
[09:31:18.815]                   }
[09:31:18.815]                   options(future.plan = NULL)
[09:31:18.815]                   if (is.na(NA_character_)) 
[09:31:18.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.815]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.815]                     .init = FALSE)
[09:31:18.815]                 }
[09:31:18.815]             }
[09:31:18.815]         }
[09:31:18.815]     })
[09:31:18.815]     if (TRUE) {
[09:31:18.815]         base::sink(type = "output", split = FALSE)
[09:31:18.815]         if (TRUE) {
[09:31:18.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.815]         }
[09:31:18.815]         else {
[09:31:18.815]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.815]         }
[09:31:18.815]         base::close(...future.stdout)
[09:31:18.815]         ...future.stdout <- NULL
[09:31:18.815]     }
[09:31:18.815]     ...future.result$conditions <- ...future.conditions
[09:31:18.815]     ...future.result$finished <- base::Sys.time()
[09:31:18.815]     ...future.result
[09:31:18.815] }
[09:31:18.817] requestCore(): workers = 2
[09:31:18.819] MulticoreFuture started
[09:31:18.819] - Launch lazy future ... done
[09:31:18.820] run() for ‘MulticoreFuture’ ... done
[09:31:18.820] result() for MulticoreFuture ...
[09:31:18.821] plan(): Setting new future strategy stack:
[09:31:18.821] List of future strategies:
[09:31:18.821] 1. sequential:
[09:31:18.821]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.821]    - tweaked: FALSE
[09:31:18.821]    - call: NULL
[09:31:18.822] plan(): nbrOfWorkers() = 1
[09:31:18.825] plan(): Setting new future strategy stack:
[09:31:18.825] List of future strategies:
[09:31:18.825] 1. multicore:
[09:31:18.825]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.825]    - tweaked: FALSE
[09:31:18.825]    - call: plan(strategy)
[09:31:18.830] plan(): nbrOfWorkers() = 2
[09:31:18.832] result() for MulticoreFuture ...
[09:31:18.832] result() for MulticoreFuture ... done
[09:31:18.832] result() for MulticoreFuture ... done
[09:31:18.833] result() for MulticoreFuture ...
[09:31:18.833] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[09:31:18.836] getGlobalsAndPackages() ...
[09:31:18.836] Searching for globals...
[09:31:18.841] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[09:31:18.841] Searching for globals ... DONE
[09:31:18.842] Resolving globals: FALSE
[09:31:18.842] 
[09:31:18.842] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.843] getGlobalsAndPackages() ... DONE
[09:31:18.843] run() for ‘Future’ ...
[09:31:18.843] - state: ‘created’
[09:31:18.843] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.847]   - Field: ‘label’
[09:31:18.848]   - Field: ‘local’
[09:31:18.848]   - Field: ‘owner’
[09:31:18.848]   - Field: ‘envir’
[09:31:18.848]   - Field: ‘workers’
[09:31:18.848]   - Field: ‘packages’
[09:31:18.848]   - Field: ‘gc’
[09:31:18.848]   - Field: ‘job’
[09:31:18.848]   - Field: ‘conditions’
[09:31:18.849]   - Field: ‘expr’
[09:31:18.849]   - Field: ‘uuid’
[09:31:18.849]   - Field: ‘seed’
[09:31:18.849]   - Field: ‘version’
[09:31:18.849]   - Field: ‘result’
[09:31:18.849]   - Field: ‘asynchronous’
[09:31:18.849]   - Field: ‘calls’
[09:31:18.849]   - Field: ‘globals’
[09:31:18.849]   - Field: ‘stdout’
[09:31:18.850]   - Field: ‘earlySignal’
[09:31:18.850]   - Field: ‘lazy’
[09:31:18.850]   - Field: ‘state’
[09:31:18.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.850] - Launch lazy future ...
[09:31:18.850] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.850] Packages needed by future strategies (n = 0): <none>
[09:31:18.851] {
[09:31:18.851]     {
[09:31:18.851]         {
[09:31:18.851]             ...future.startTime <- base::Sys.time()
[09:31:18.851]             {
[09:31:18.851]                 {
[09:31:18.851]                   {
[09:31:18.851]                     {
[09:31:18.851]                       {
[09:31:18.851]                         base::local({
[09:31:18.851]                           has_future <- base::requireNamespace("future", 
[09:31:18.851]                             quietly = TRUE)
[09:31:18.851]                           if (has_future) {
[09:31:18.851]                             ns <- base::getNamespace("future")
[09:31:18.851]                             version <- ns[[".package"]][["version"]]
[09:31:18.851]                             if (is.null(version)) 
[09:31:18.851]                               version <- utils::packageVersion("future")
[09:31:18.851]                           }
[09:31:18.851]                           else {
[09:31:18.851]                             version <- NULL
[09:31:18.851]                           }
[09:31:18.851]                           if (!has_future || version < "1.8.0") {
[09:31:18.851]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.851]                               "", base::R.version$version.string), 
[09:31:18.851]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.851]                                 base::R.version$platform, 8 * 
[09:31:18.851]                                   base::.Machine$sizeof.pointer), 
[09:31:18.851]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.851]                                 "release", "version")], collapse = " "), 
[09:31:18.851]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.851]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.851]                               info)
[09:31:18.851]                             info <- base::paste(info, collapse = "; ")
[09:31:18.851]                             if (!has_future) {
[09:31:18.851]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.851]                                 info)
[09:31:18.851]                             }
[09:31:18.851]                             else {
[09:31:18.851]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.851]                                 info, version)
[09:31:18.851]                             }
[09:31:18.851]                             base::stop(msg)
[09:31:18.851]                           }
[09:31:18.851]                         })
[09:31:18.851]                       }
[09:31:18.851]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.851]                       base::options(mc.cores = 1L)
[09:31:18.851]                     }
[09:31:18.851]                     base::local({
[09:31:18.851]                       for (pkg in c("stats", "datasets")) {
[09:31:18.851]                         base::loadNamespace(pkg)
[09:31:18.851]                         base::library(pkg, character.only = TRUE)
[09:31:18.851]                       }
[09:31:18.851]                     })
[09:31:18.851]                   }
[09:31:18.851]                   ...future.strategy.old <- future::plan("list")
[09:31:18.851]                   options(future.plan = NULL)
[09:31:18.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.851]                 }
[09:31:18.851]                 ...future.workdir <- getwd()
[09:31:18.851]             }
[09:31:18.851]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.851]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.851]         }
[09:31:18.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.851]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.851]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.851]             base::names(...future.oldOptions))
[09:31:18.851]     }
[09:31:18.851]     if (FALSE) {
[09:31:18.851]     }
[09:31:18.851]     else {
[09:31:18.851]         if (TRUE) {
[09:31:18.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.851]                 open = "w")
[09:31:18.851]         }
[09:31:18.851]         else {
[09:31:18.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.851]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.851]         }
[09:31:18.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.851]             base::sink(type = "output", split = FALSE)
[09:31:18.851]             base::close(...future.stdout)
[09:31:18.851]         }, add = TRUE)
[09:31:18.851]     }
[09:31:18.851]     ...future.frame <- base::sys.nframe()
[09:31:18.851]     ...future.conditions <- base::list()
[09:31:18.851]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.851]     if (FALSE) {
[09:31:18.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.851]     }
[09:31:18.851]     ...future.result <- base::tryCatch({
[09:31:18.851]         base::withCallingHandlers({
[09:31:18.851]             ...future.value <- base::withVisible(base::local({
[09:31:18.851]                 withCallingHandlers({
[09:31:18.851]                   {
[09:31:18.851]                     lm(dist ~ speed + speed^2, data = cars)
[09:31:18.851]                   }
[09:31:18.851]                 }, immediateCondition = function(cond) {
[09:31:18.851]                   save_rds <- function (object, pathname, ...) 
[09:31:18.851]                   {
[09:31:18.851]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.851]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.851]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.851]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.851]                         fi_tmp[["mtime"]])
[09:31:18.851]                     }
[09:31:18.851]                     tryCatch({
[09:31:18.851]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.851]                     }, error = function(ex) {
[09:31:18.851]                       msg <- conditionMessage(ex)
[09:31:18.851]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.851]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.851]                         fi_tmp[["mtime"]], msg)
[09:31:18.851]                       ex$message <- msg
[09:31:18.851]                       stop(ex)
[09:31:18.851]                     })
[09:31:18.851]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.851]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.851]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.851]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.851]                       fi <- file.info(pathname)
[09:31:18.851]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.851]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.851]                         fi[["size"]], fi[["mtime"]])
[09:31:18.851]                       stop(msg)
[09:31:18.851]                     }
[09:31:18.851]                     invisible(pathname)
[09:31:18.851]                   }
[09:31:18.851]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.851]                     rootPath = tempdir()) 
[09:31:18.851]                   {
[09:31:18.851]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.851]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.851]                       tmpdir = path, fileext = ".rds")
[09:31:18.851]                     save_rds(obj, file)
[09:31:18.851]                   }
[09:31:18.851]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.851]                   {
[09:31:18.851]                     inherits <- base::inherits
[09:31:18.851]                     invokeRestart <- base::invokeRestart
[09:31:18.851]                     is.null <- base::is.null
[09:31:18.851]                     muffled <- FALSE
[09:31:18.851]                     if (inherits(cond, "message")) {
[09:31:18.851]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.851]                       if (muffled) 
[09:31:18.851]                         invokeRestart("muffleMessage")
[09:31:18.851]                     }
[09:31:18.851]                     else if (inherits(cond, "warning")) {
[09:31:18.851]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.851]                       if (muffled) 
[09:31:18.851]                         invokeRestart("muffleWarning")
[09:31:18.851]                     }
[09:31:18.851]                     else if (inherits(cond, "condition")) {
[09:31:18.851]                       if (!is.null(pattern)) {
[09:31:18.851]                         computeRestarts <- base::computeRestarts
[09:31:18.851]                         grepl <- base::grepl
[09:31:18.851]                         restarts <- computeRestarts(cond)
[09:31:18.851]                         for (restart in restarts) {
[09:31:18.851]                           name <- restart$name
[09:31:18.851]                           if (is.null(name)) 
[09:31:18.851]                             next
[09:31:18.851]                           if (!grepl(pattern, name)) 
[09:31:18.851]                             next
[09:31:18.851]                           invokeRestart(restart)
[09:31:18.851]                           muffled <- TRUE
[09:31:18.851]                           break
[09:31:18.851]                         }
[09:31:18.851]                       }
[09:31:18.851]                     }
[09:31:18.851]                     invisible(muffled)
[09:31:18.851]                   }
[09:31:18.851]                   muffleCondition(cond)
[09:31:18.851]                 })
[09:31:18.851]             }))
[09:31:18.851]             future::FutureResult(value = ...future.value$value, 
[09:31:18.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.851]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.851]                     ...future.globalenv.names))
[09:31:18.851]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.851]         }, condition = base::local({
[09:31:18.851]             c <- base::c
[09:31:18.851]             inherits <- base::inherits
[09:31:18.851]             invokeRestart <- base::invokeRestart
[09:31:18.851]             length <- base::length
[09:31:18.851]             list <- base::list
[09:31:18.851]             seq.int <- base::seq.int
[09:31:18.851]             signalCondition <- base::signalCondition
[09:31:18.851]             sys.calls <- base::sys.calls
[09:31:18.851]             `[[` <- base::`[[`
[09:31:18.851]             `+` <- base::`+`
[09:31:18.851]             `<<-` <- base::`<<-`
[09:31:18.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.851]                   3L)]
[09:31:18.851]             }
[09:31:18.851]             function(cond) {
[09:31:18.851]                 is_error <- inherits(cond, "error")
[09:31:18.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.851]                   NULL)
[09:31:18.851]                 if (is_error) {
[09:31:18.851]                   sessionInformation <- function() {
[09:31:18.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.851]                       search = base::search(), system = base::Sys.info())
[09:31:18.851]                   }
[09:31:18.851]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.851]                     cond$call), session = sessionInformation(), 
[09:31:18.851]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.851]                   signalCondition(cond)
[09:31:18.851]                 }
[09:31:18.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.851]                 "immediateCondition"))) {
[09:31:18.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.851]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.851]                   if (TRUE && !signal) {
[09:31:18.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.851]                     {
[09:31:18.851]                       inherits <- base::inherits
[09:31:18.851]                       invokeRestart <- base::invokeRestart
[09:31:18.851]                       is.null <- base::is.null
[09:31:18.851]                       muffled <- FALSE
[09:31:18.851]                       if (inherits(cond, "message")) {
[09:31:18.851]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.851]                         if (muffled) 
[09:31:18.851]                           invokeRestart("muffleMessage")
[09:31:18.851]                       }
[09:31:18.851]                       else if (inherits(cond, "warning")) {
[09:31:18.851]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.851]                         if (muffled) 
[09:31:18.851]                           invokeRestart("muffleWarning")
[09:31:18.851]                       }
[09:31:18.851]                       else if (inherits(cond, "condition")) {
[09:31:18.851]                         if (!is.null(pattern)) {
[09:31:18.851]                           computeRestarts <- base::computeRestarts
[09:31:18.851]                           grepl <- base::grepl
[09:31:18.851]                           restarts <- computeRestarts(cond)
[09:31:18.851]                           for (restart in restarts) {
[09:31:18.851]                             name <- restart$name
[09:31:18.851]                             if (is.null(name)) 
[09:31:18.851]                               next
[09:31:18.851]                             if (!grepl(pattern, name)) 
[09:31:18.851]                               next
[09:31:18.851]                             invokeRestart(restart)
[09:31:18.851]                             muffled <- TRUE
[09:31:18.851]                             break
[09:31:18.851]                           }
[09:31:18.851]                         }
[09:31:18.851]                       }
[09:31:18.851]                       invisible(muffled)
[09:31:18.851]                     }
[09:31:18.851]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.851]                   }
[09:31:18.851]                 }
[09:31:18.851]                 else {
[09:31:18.851]                   if (TRUE) {
[09:31:18.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.851]                     {
[09:31:18.851]                       inherits <- base::inherits
[09:31:18.851]                       invokeRestart <- base::invokeRestart
[09:31:18.851]                       is.null <- base::is.null
[09:31:18.851]                       muffled <- FALSE
[09:31:18.851]                       if (inherits(cond, "message")) {
[09:31:18.851]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.851]                         if (muffled) 
[09:31:18.851]                           invokeRestart("muffleMessage")
[09:31:18.851]                       }
[09:31:18.851]                       else if (inherits(cond, "warning")) {
[09:31:18.851]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.851]                         if (muffled) 
[09:31:18.851]                           invokeRestart("muffleWarning")
[09:31:18.851]                       }
[09:31:18.851]                       else if (inherits(cond, "condition")) {
[09:31:18.851]                         if (!is.null(pattern)) {
[09:31:18.851]                           computeRestarts <- base::computeRestarts
[09:31:18.851]                           grepl <- base::grepl
[09:31:18.851]                           restarts <- computeRestarts(cond)
[09:31:18.851]                           for (restart in restarts) {
[09:31:18.851]                             name <- restart$name
[09:31:18.851]                             if (is.null(name)) 
[09:31:18.851]                               next
[09:31:18.851]                             if (!grepl(pattern, name)) 
[09:31:18.851]                               next
[09:31:18.851]                             invokeRestart(restart)
[09:31:18.851]                             muffled <- TRUE
[09:31:18.851]                             break
[09:31:18.851]                           }
[09:31:18.851]                         }
[09:31:18.851]                       }
[09:31:18.851]                       invisible(muffled)
[09:31:18.851]                     }
[09:31:18.851]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.851]                   }
[09:31:18.851]                 }
[09:31:18.851]             }
[09:31:18.851]         }))
[09:31:18.851]     }, error = function(ex) {
[09:31:18.851]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.851]                 ...future.rng), started = ...future.startTime, 
[09:31:18.851]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.851]             version = "1.8"), class = "FutureResult")
[09:31:18.851]     }, finally = {
[09:31:18.851]         if (!identical(...future.workdir, getwd())) 
[09:31:18.851]             setwd(...future.workdir)
[09:31:18.851]         {
[09:31:18.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.851]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.851]             }
[09:31:18.851]             base::options(...future.oldOptions)
[09:31:18.851]             if (.Platform$OS.type == "windows") {
[09:31:18.851]                 old_names <- names(...future.oldEnvVars)
[09:31:18.851]                 envs <- base::Sys.getenv()
[09:31:18.851]                 names <- names(envs)
[09:31:18.851]                 common <- intersect(names, old_names)
[09:31:18.851]                 added <- setdiff(names, old_names)
[09:31:18.851]                 removed <- setdiff(old_names, names)
[09:31:18.851]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.851]                   envs[common]]
[09:31:18.851]                 NAMES <- toupper(changed)
[09:31:18.851]                 args <- list()
[09:31:18.851]                 for (kk in seq_along(NAMES)) {
[09:31:18.851]                   name <- changed[[kk]]
[09:31:18.851]                   NAME <- NAMES[[kk]]
[09:31:18.851]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.851]                     next
[09:31:18.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.851]                 }
[09:31:18.851]                 NAMES <- toupper(added)
[09:31:18.851]                 for (kk in seq_along(NAMES)) {
[09:31:18.851]                   name <- added[[kk]]
[09:31:18.851]                   NAME <- NAMES[[kk]]
[09:31:18.851]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.851]                     next
[09:31:18.851]                   args[[name]] <- ""
[09:31:18.851]                 }
[09:31:18.851]                 NAMES <- toupper(removed)
[09:31:18.851]                 for (kk in seq_along(NAMES)) {
[09:31:18.851]                   name <- removed[[kk]]
[09:31:18.851]                   NAME <- NAMES[[kk]]
[09:31:18.851]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.851]                     next
[09:31:18.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.851]                 }
[09:31:18.851]                 if (length(args) > 0) 
[09:31:18.851]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.851]             }
[09:31:18.851]             else {
[09:31:18.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.851]             }
[09:31:18.851]             {
[09:31:18.851]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.851]                   0L) {
[09:31:18.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.851]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.851]                   base::options(opts)
[09:31:18.851]                 }
[09:31:18.851]                 {
[09:31:18.851]                   {
[09:31:18.851]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.851]                     NULL
[09:31:18.851]                   }
[09:31:18.851]                   options(future.plan = NULL)
[09:31:18.851]                   if (is.na(NA_character_)) 
[09:31:18.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.851]                     .init = FALSE)
[09:31:18.851]                 }
[09:31:18.851]             }
[09:31:18.851]         }
[09:31:18.851]     })
[09:31:18.851]     if (TRUE) {
[09:31:18.851]         base::sink(type = "output", split = FALSE)
[09:31:18.851]         if (TRUE) {
[09:31:18.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.851]         }
[09:31:18.851]         else {
[09:31:18.851]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.851]         }
[09:31:18.851]         base::close(...future.stdout)
[09:31:18.851]         ...future.stdout <- NULL
[09:31:18.851]     }
[09:31:18.851]     ...future.result$conditions <- ...future.conditions
[09:31:18.851]     ...future.result$finished <- base::Sys.time()
[09:31:18.851]     ...future.result
[09:31:18.851] }
[09:31:18.853] requestCore(): workers = 2
[09:31:18.855] MulticoreFuture started
[09:31:18.855] - Launch lazy future ... done
[09:31:18.856] run() for ‘MulticoreFuture’ ... done
[09:31:18.856] result() for MulticoreFuture ...
[09:31:18.857] plan(): Setting new future strategy stack:
[09:31:18.857] List of future strategies:
[09:31:18.857] 1. sequential:
[09:31:18.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.857]    - tweaked: FALSE
[09:31:18.857]    - call: NULL
[09:31:18.858] plan(): nbrOfWorkers() = 1
[09:31:18.861] plan(): Setting new future strategy stack:
[09:31:18.861] List of future strategies:
[09:31:18.861] 1. multicore:
[09:31:18.861]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.861]    - tweaked: FALSE
[09:31:18.861]    - call: plan(strategy)
[09:31:18.866] plan(): nbrOfWorkers() = 2
[09:31:18.868] result() for MulticoreFuture ...
[09:31:18.868] result() for MulticoreFuture ... done
[09:31:18.868] result() for MulticoreFuture ... done
[09:31:18.869] result() for MulticoreFuture ...
[09:31:18.869] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[09:31:18.873] getGlobalsAndPackages() ...
[09:31:18.873] Searching for globals...
[09:31:18.875] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[09:31:18.875] Searching for globals ... DONE
[09:31:18.876] Resolving globals: FALSE
[09:31:18.876] 
[09:31:18.876] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.877] getGlobalsAndPackages() ... DONE
[09:31:18.877] run() for ‘Future’ ...
[09:31:18.877] - state: ‘created’
[09:31:18.877] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.881] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.881]   - Field: ‘label’
[09:31:18.881]   - Field: ‘local’
[09:31:18.881]   - Field: ‘owner’
[09:31:18.882]   - Field: ‘envir’
[09:31:18.882]   - Field: ‘workers’
[09:31:18.882]   - Field: ‘packages’
[09:31:18.882]   - Field: ‘gc’
[09:31:18.882]   - Field: ‘job’
[09:31:18.882]   - Field: ‘conditions’
[09:31:18.882]   - Field: ‘expr’
[09:31:18.882]   - Field: ‘uuid’
[09:31:18.882]   - Field: ‘seed’
[09:31:18.882]   - Field: ‘version’
[09:31:18.883]   - Field: ‘result’
[09:31:18.883]   - Field: ‘asynchronous’
[09:31:18.883]   - Field: ‘calls’
[09:31:18.883]   - Field: ‘globals’
[09:31:18.883]   - Field: ‘stdout’
[09:31:18.883]   - Field: ‘earlySignal’
[09:31:18.883]   - Field: ‘lazy’
[09:31:18.883]   - Field: ‘state’
[09:31:18.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.884] - Launch lazy future ...
[09:31:18.884] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.884] Packages needed by future strategies (n = 0): <none>
[09:31:18.920] {
[09:31:18.920]     {
[09:31:18.920]         {
[09:31:18.920]             ...future.startTime <- base::Sys.time()
[09:31:18.920]             {
[09:31:18.920]                 {
[09:31:18.920]                   {
[09:31:18.920]                     {
[09:31:18.920]                       {
[09:31:18.920]                         base::local({
[09:31:18.920]                           has_future <- base::requireNamespace("future", 
[09:31:18.920]                             quietly = TRUE)
[09:31:18.920]                           if (has_future) {
[09:31:18.920]                             ns <- base::getNamespace("future")
[09:31:18.920]                             version <- ns[[".package"]][["version"]]
[09:31:18.920]                             if (is.null(version)) 
[09:31:18.920]                               version <- utils::packageVersion("future")
[09:31:18.920]                           }
[09:31:18.920]                           else {
[09:31:18.920]                             version <- NULL
[09:31:18.920]                           }
[09:31:18.920]                           if (!has_future || version < "1.8.0") {
[09:31:18.920]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.920]                               "", base::R.version$version.string), 
[09:31:18.920]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.920]                                 base::R.version$platform, 8 * 
[09:31:18.920]                                   base::.Machine$sizeof.pointer), 
[09:31:18.920]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.920]                                 "release", "version")], collapse = " "), 
[09:31:18.920]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.920]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.920]                               info)
[09:31:18.920]                             info <- base::paste(info, collapse = "; ")
[09:31:18.920]                             if (!has_future) {
[09:31:18.920]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.920]                                 info)
[09:31:18.920]                             }
[09:31:18.920]                             else {
[09:31:18.920]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.920]                                 info, version)
[09:31:18.920]                             }
[09:31:18.920]                             base::stop(msg)
[09:31:18.920]                           }
[09:31:18.920]                         })
[09:31:18.920]                       }
[09:31:18.920]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.920]                       base::options(mc.cores = 1L)
[09:31:18.920]                     }
[09:31:18.920]                     base::local({
[09:31:18.920]                       for (pkg in c("stats", "datasets")) {
[09:31:18.920]                         base::loadNamespace(pkg)
[09:31:18.920]                         base::library(pkg, character.only = TRUE)
[09:31:18.920]                       }
[09:31:18.920]                     })
[09:31:18.920]                   }
[09:31:18.920]                   ...future.strategy.old <- future::plan("list")
[09:31:18.920]                   options(future.plan = NULL)
[09:31:18.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.920]                 }
[09:31:18.920]                 ...future.workdir <- getwd()
[09:31:18.920]             }
[09:31:18.920]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.920]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.920]         }
[09:31:18.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.920]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.920]             base::names(...future.oldOptions))
[09:31:18.920]     }
[09:31:18.920]     if (FALSE) {
[09:31:18.920]     }
[09:31:18.920]     else {
[09:31:18.920]         if (TRUE) {
[09:31:18.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.920]                 open = "w")
[09:31:18.920]         }
[09:31:18.920]         else {
[09:31:18.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.920]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.920]         }
[09:31:18.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.920]             base::sink(type = "output", split = FALSE)
[09:31:18.920]             base::close(...future.stdout)
[09:31:18.920]         }, add = TRUE)
[09:31:18.920]     }
[09:31:18.920]     ...future.frame <- base::sys.nframe()
[09:31:18.920]     ...future.conditions <- base::list()
[09:31:18.920]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.920]     if (FALSE) {
[09:31:18.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.920]     }
[09:31:18.920]     ...future.result <- base::tryCatch({
[09:31:18.920]         base::withCallingHandlers({
[09:31:18.920]             ...future.value <- base::withVisible(base::local({
[09:31:18.920]                 withCallingHandlers({
[09:31:18.920]                   {
[09:31:18.920]                     lm(dist ~ speed + I(speed^2), data = cars)
[09:31:18.920]                   }
[09:31:18.920]                 }, immediateCondition = function(cond) {
[09:31:18.920]                   save_rds <- function (object, pathname, ...) 
[09:31:18.920]                   {
[09:31:18.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.920]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.920]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.920]                         fi_tmp[["mtime"]])
[09:31:18.920]                     }
[09:31:18.920]                     tryCatch({
[09:31:18.920]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.920]                     }, error = function(ex) {
[09:31:18.920]                       msg <- conditionMessage(ex)
[09:31:18.920]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.920]                         fi_tmp[["mtime"]], msg)
[09:31:18.920]                       ex$message <- msg
[09:31:18.920]                       stop(ex)
[09:31:18.920]                     })
[09:31:18.920]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.920]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.920]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.920]                       fi <- file.info(pathname)
[09:31:18.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.920]                         fi[["size"]], fi[["mtime"]])
[09:31:18.920]                       stop(msg)
[09:31:18.920]                     }
[09:31:18.920]                     invisible(pathname)
[09:31:18.920]                   }
[09:31:18.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.920]                     rootPath = tempdir()) 
[09:31:18.920]                   {
[09:31:18.920]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.920]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.920]                       tmpdir = path, fileext = ".rds")
[09:31:18.920]                     save_rds(obj, file)
[09:31:18.920]                   }
[09:31:18.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.920]                   {
[09:31:18.920]                     inherits <- base::inherits
[09:31:18.920]                     invokeRestart <- base::invokeRestart
[09:31:18.920]                     is.null <- base::is.null
[09:31:18.920]                     muffled <- FALSE
[09:31:18.920]                     if (inherits(cond, "message")) {
[09:31:18.920]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.920]                       if (muffled) 
[09:31:18.920]                         invokeRestart("muffleMessage")
[09:31:18.920]                     }
[09:31:18.920]                     else if (inherits(cond, "warning")) {
[09:31:18.920]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.920]                       if (muffled) 
[09:31:18.920]                         invokeRestart("muffleWarning")
[09:31:18.920]                     }
[09:31:18.920]                     else if (inherits(cond, "condition")) {
[09:31:18.920]                       if (!is.null(pattern)) {
[09:31:18.920]                         computeRestarts <- base::computeRestarts
[09:31:18.920]                         grepl <- base::grepl
[09:31:18.920]                         restarts <- computeRestarts(cond)
[09:31:18.920]                         for (restart in restarts) {
[09:31:18.920]                           name <- restart$name
[09:31:18.920]                           if (is.null(name)) 
[09:31:18.920]                             next
[09:31:18.920]                           if (!grepl(pattern, name)) 
[09:31:18.920]                             next
[09:31:18.920]                           invokeRestart(restart)
[09:31:18.920]                           muffled <- TRUE
[09:31:18.920]                           break
[09:31:18.920]                         }
[09:31:18.920]                       }
[09:31:18.920]                     }
[09:31:18.920]                     invisible(muffled)
[09:31:18.920]                   }
[09:31:18.920]                   muffleCondition(cond)
[09:31:18.920]                 })
[09:31:18.920]             }))
[09:31:18.920]             future::FutureResult(value = ...future.value$value, 
[09:31:18.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.920]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.920]                     ...future.globalenv.names))
[09:31:18.920]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.920]         }, condition = base::local({
[09:31:18.920]             c <- base::c
[09:31:18.920]             inherits <- base::inherits
[09:31:18.920]             invokeRestart <- base::invokeRestart
[09:31:18.920]             length <- base::length
[09:31:18.920]             list <- base::list
[09:31:18.920]             seq.int <- base::seq.int
[09:31:18.920]             signalCondition <- base::signalCondition
[09:31:18.920]             sys.calls <- base::sys.calls
[09:31:18.920]             `[[` <- base::`[[`
[09:31:18.920]             `+` <- base::`+`
[09:31:18.920]             `<<-` <- base::`<<-`
[09:31:18.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.920]                   3L)]
[09:31:18.920]             }
[09:31:18.920]             function(cond) {
[09:31:18.920]                 is_error <- inherits(cond, "error")
[09:31:18.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.920]                   NULL)
[09:31:18.920]                 if (is_error) {
[09:31:18.920]                   sessionInformation <- function() {
[09:31:18.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.920]                       search = base::search(), system = base::Sys.info())
[09:31:18.920]                   }
[09:31:18.920]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.920]                     cond$call), session = sessionInformation(), 
[09:31:18.920]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.920]                   signalCondition(cond)
[09:31:18.920]                 }
[09:31:18.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.920]                 "immediateCondition"))) {
[09:31:18.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.920]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.920]                   if (TRUE && !signal) {
[09:31:18.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.920]                     {
[09:31:18.920]                       inherits <- base::inherits
[09:31:18.920]                       invokeRestart <- base::invokeRestart
[09:31:18.920]                       is.null <- base::is.null
[09:31:18.920]                       muffled <- FALSE
[09:31:18.920]                       if (inherits(cond, "message")) {
[09:31:18.920]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.920]                         if (muffled) 
[09:31:18.920]                           invokeRestart("muffleMessage")
[09:31:18.920]                       }
[09:31:18.920]                       else if (inherits(cond, "warning")) {
[09:31:18.920]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.920]                         if (muffled) 
[09:31:18.920]                           invokeRestart("muffleWarning")
[09:31:18.920]                       }
[09:31:18.920]                       else if (inherits(cond, "condition")) {
[09:31:18.920]                         if (!is.null(pattern)) {
[09:31:18.920]                           computeRestarts <- base::computeRestarts
[09:31:18.920]                           grepl <- base::grepl
[09:31:18.920]                           restarts <- computeRestarts(cond)
[09:31:18.920]                           for (restart in restarts) {
[09:31:18.920]                             name <- restart$name
[09:31:18.920]                             if (is.null(name)) 
[09:31:18.920]                               next
[09:31:18.920]                             if (!grepl(pattern, name)) 
[09:31:18.920]                               next
[09:31:18.920]                             invokeRestart(restart)
[09:31:18.920]                             muffled <- TRUE
[09:31:18.920]                             break
[09:31:18.920]                           }
[09:31:18.920]                         }
[09:31:18.920]                       }
[09:31:18.920]                       invisible(muffled)
[09:31:18.920]                     }
[09:31:18.920]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.920]                   }
[09:31:18.920]                 }
[09:31:18.920]                 else {
[09:31:18.920]                   if (TRUE) {
[09:31:18.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.920]                     {
[09:31:18.920]                       inherits <- base::inherits
[09:31:18.920]                       invokeRestart <- base::invokeRestart
[09:31:18.920]                       is.null <- base::is.null
[09:31:18.920]                       muffled <- FALSE
[09:31:18.920]                       if (inherits(cond, "message")) {
[09:31:18.920]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.920]                         if (muffled) 
[09:31:18.920]                           invokeRestart("muffleMessage")
[09:31:18.920]                       }
[09:31:18.920]                       else if (inherits(cond, "warning")) {
[09:31:18.920]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.920]                         if (muffled) 
[09:31:18.920]                           invokeRestart("muffleWarning")
[09:31:18.920]                       }
[09:31:18.920]                       else if (inherits(cond, "condition")) {
[09:31:18.920]                         if (!is.null(pattern)) {
[09:31:18.920]                           computeRestarts <- base::computeRestarts
[09:31:18.920]                           grepl <- base::grepl
[09:31:18.920]                           restarts <- computeRestarts(cond)
[09:31:18.920]                           for (restart in restarts) {
[09:31:18.920]                             name <- restart$name
[09:31:18.920]                             if (is.null(name)) 
[09:31:18.920]                               next
[09:31:18.920]                             if (!grepl(pattern, name)) 
[09:31:18.920]                               next
[09:31:18.920]                             invokeRestart(restart)
[09:31:18.920]                             muffled <- TRUE
[09:31:18.920]                             break
[09:31:18.920]                           }
[09:31:18.920]                         }
[09:31:18.920]                       }
[09:31:18.920]                       invisible(muffled)
[09:31:18.920]                     }
[09:31:18.920]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.920]                   }
[09:31:18.920]                 }
[09:31:18.920]             }
[09:31:18.920]         }))
[09:31:18.920]     }, error = function(ex) {
[09:31:18.920]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.920]                 ...future.rng), started = ...future.startTime, 
[09:31:18.920]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.920]             version = "1.8"), class = "FutureResult")
[09:31:18.920]     }, finally = {
[09:31:18.920]         if (!identical(...future.workdir, getwd())) 
[09:31:18.920]             setwd(...future.workdir)
[09:31:18.920]         {
[09:31:18.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.920]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.920]             }
[09:31:18.920]             base::options(...future.oldOptions)
[09:31:18.920]             if (.Platform$OS.type == "windows") {
[09:31:18.920]                 old_names <- names(...future.oldEnvVars)
[09:31:18.920]                 envs <- base::Sys.getenv()
[09:31:18.920]                 names <- names(envs)
[09:31:18.920]                 common <- intersect(names, old_names)
[09:31:18.920]                 added <- setdiff(names, old_names)
[09:31:18.920]                 removed <- setdiff(old_names, names)
[09:31:18.920]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.920]                   envs[common]]
[09:31:18.920]                 NAMES <- toupper(changed)
[09:31:18.920]                 args <- list()
[09:31:18.920]                 for (kk in seq_along(NAMES)) {
[09:31:18.920]                   name <- changed[[kk]]
[09:31:18.920]                   NAME <- NAMES[[kk]]
[09:31:18.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.920]                     next
[09:31:18.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.920]                 }
[09:31:18.920]                 NAMES <- toupper(added)
[09:31:18.920]                 for (kk in seq_along(NAMES)) {
[09:31:18.920]                   name <- added[[kk]]
[09:31:18.920]                   NAME <- NAMES[[kk]]
[09:31:18.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.920]                     next
[09:31:18.920]                   args[[name]] <- ""
[09:31:18.920]                 }
[09:31:18.920]                 NAMES <- toupper(removed)
[09:31:18.920]                 for (kk in seq_along(NAMES)) {
[09:31:18.920]                   name <- removed[[kk]]
[09:31:18.920]                   NAME <- NAMES[[kk]]
[09:31:18.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.920]                     next
[09:31:18.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.920]                 }
[09:31:18.920]                 if (length(args) > 0) 
[09:31:18.920]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.920]             }
[09:31:18.920]             else {
[09:31:18.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.920]             }
[09:31:18.920]             {
[09:31:18.920]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.920]                   0L) {
[09:31:18.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.920]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.920]                   base::options(opts)
[09:31:18.920]                 }
[09:31:18.920]                 {
[09:31:18.920]                   {
[09:31:18.920]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.920]                     NULL
[09:31:18.920]                   }
[09:31:18.920]                   options(future.plan = NULL)
[09:31:18.920]                   if (is.na(NA_character_)) 
[09:31:18.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.920]                     .init = FALSE)
[09:31:18.920]                 }
[09:31:18.920]             }
[09:31:18.920]         }
[09:31:18.920]     })
[09:31:18.920]     if (TRUE) {
[09:31:18.920]         base::sink(type = "output", split = FALSE)
[09:31:18.920]         if (TRUE) {
[09:31:18.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.920]         }
[09:31:18.920]         else {
[09:31:18.920]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.920]         }
[09:31:18.920]         base::close(...future.stdout)
[09:31:18.920]         ...future.stdout <- NULL
[09:31:18.920]     }
[09:31:18.920]     ...future.result$conditions <- ...future.conditions
[09:31:18.920]     ...future.result$finished <- base::Sys.time()
[09:31:18.920]     ...future.result
[09:31:18.920] }
[09:31:18.922] requestCore(): workers = 2
[09:31:18.924] MulticoreFuture started
[09:31:18.925] - Launch lazy future ... done
[09:31:18.926] run() for ‘MulticoreFuture’ ... done
[09:31:18.926] result() for MulticoreFuture ...
[09:31:18.927] plan(): Setting new future strategy stack:
[09:31:18.927] List of future strategies:
[09:31:18.927] 1. sequential:
[09:31:18.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.927]    - tweaked: FALSE
[09:31:18.927]    - call: NULL
[09:31:18.929] plan(): nbrOfWorkers() = 1
[09:31:18.933] plan(): Setting new future strategy stack:
[09:31:18.933] List of future strategies:
[09:31:18.933] 1. multicore:
[09:31:18.933]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.933]    - tweaked: FALSE
[09:31:18.933]    - call: plan(strategy)
[09:31:18.939] plan(): nbrOfWorkers() = 2
[09:31:18.941] result() for MulticoreFuture ...
[09:31:18.941] result() for MulticoreFuture ... done
[09:31:18.942] result() for MulticoreFuture ... done
[09:31:18.942] result() for MulticoreFuture ...
[09:31:18.942] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[09:31:18.946] getGlobalsAndPackages() ...
[09:31:18.946] Searching for globals...
[09:31:18.948] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[09:31:18.948] Searching for globals ... DONE
[09:31:18.949] Resolving globals: FALSE
[09:31:18.949] 
[09:31:18.949] - packages: [2] ‘stats’, ‘datasets’
[09:31:18.949] getGlobalsAndPackages() ... DONE
[09:31:18.950] run() for ‘Future’ ...
[09:31:18.950] - state: ‘created’
[09:31:18.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.954] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.954]   - Field: ‘label’
[09:31:18.954]   - Field: ‘local’
[09:31:18.955]   - Field: ‘owner’
[09:31:18.955]   - Field: ‘envir’
[09:31:18.955]   - Field: ‘workers’
[09:31:18.955]   - Field: ‘packages’
[09:31:18.955]   - Field: ‘gc’
[09:31:18.955]   - Field: ‘job’
[09:31:18.955]   - Field: ‘conditions’
[09:31:18.955]   - Field: ‘expr’
[09:31:18.955]   - Field: ‘uuid’
[09:31:18.956]   - Field: ‘seed’
[09:31:18.956]   - Field: ‘version’
[09:31:18.956]   - Field: ‘result’
[09:31:18.956]   - Field: ‘asynchronous’
[09:31:18.956]   - Field: ‘calls’
[09:31:18.956]   - Field: ‘globals’
[09:31:18.956]   - Field: ‘stdout’
[09:31:18.956]   - Field: ‘earlySignal’
[09:31:18.956]   - Field: ‘lazy’
[09:31:18.957]   - Field: ‘state’
[09:31:18.957] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.957] - Launch lazy future ...
[09:31:18.957] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:18.957] Packages needed by future strategies (n = 0): <none>
[09:31:18.958] {
[09:31:18.958]     {
[09:31:18.958]         {
[09:31:18.958]             ...future.startTime <- base::Sys.time()
[09:31:18.958]             {
[09:31:18.958]                 {
[09:31:18.958]                   {
[09:31:18.958]                     {
[09:31:18.958]                       {
[09:31:18.958]                         base::local({
[09:31:18.958]                           has_future <- base::requireNamespace("future", 
[09:31:18.958]                             quietly = TRUE)
[09:31:18.958]                           if (has_future) {
[09:31:18.958]                             ns <- base::getNamespace("future")
[09:31:18.958]                             version <- ns[[".package"]][["version"]]
[09:31:18.958]                             if (is.null(version)) 
[09:31:18.958]                               version <- utils::packageVersion("future")
[09:31:18.958]                           }
[09:31:18.958]                           else {
[09:31:18.958]                             version <- NULL
[09:31:18.958]                           }
[09:31:18.958]                           if (!has_future || version < "1.8.0") {
[09:31:18.958]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.958]                               "", base::R.version$version.string), 
[09:31:18.958]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:18.958]                                 base::R.version$platform, 8 * 
[09:31:18.958]                                   base::.Machine$sizeof.pointer), 
[09:31:18.958]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.958]                                 "release", "version")], collapse = " "), 
[09:31:18.958]                               hostname = base::Sys.info()[["nodename"]])
[09:31:18.958]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.958]                               info)
[09:31:18.958]                             info <- base::paste(info, collapse = "; ")
[09:31:18.958]                             if (!has_future) {
[09:31:18.958]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.958]                                 info)
[09:31:18.958]                             }
[09:31:18.958]                             else {
[09:31:18.958]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.958]                                 info, version)
[09:31:18.958]                             }
[09:31:18.958]                             base::stop(msg)
[09:31:18.958]                           }
[09:31:18.958]                         })
[09:31:18.958]                       }
[09:31:18.958]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.958]                       base::options(mc.cores = 1L)
[09:31:18.958]                     }
[09:31:18.958]                     base::local({
[09:31:18.958]                       for (pkg in c("stats", "datasets")) {
[09:31:18.958]                         base::loadNamespace(pkg)
[09:31:18.958]                         base::library(pkg, character.only = TRUE)
[09:31:18.958]                       }
[09:31:18.958]                     })
[09:31:18.958]                   }
[09:31:18.958]                   ...future.strategy.old <- future::plan("list")
[09:31:18.958]                   options(future.plan = NULL)
[09:31:18.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.958]                 }
[09:31:18.958]                 ...future.workdir <- getwd()
[09:31:18.958]             }
[09:31:18.958]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.958]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.958]         }
[09:31:18.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.958]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.958]             base::names(...future.oldOptions))
[09:31:18.958]     }
[09:31:18.958]     if (FALSE) {
[09:31:18.958]     }
[09:31:18.958]     else {
[09:31:18.958]         if (TRUE) {
[09:31:18.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.958]                 open = "w")
[09:31:18.958]         }
[09:31:18.958]         else {
[09:31:18.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.958]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.958]         }
[09:31:18.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.958]             base::sink(type = "output", split = FALSE)
[09:31:18.958]             base::close(...future.stdout)
[09:31:18.958]         }, add = TRUE)
[09:31:18.958]     }
[09:31:18.958]     ...future.frame <- base::sys.nframe()
[09:31:18.958]     ...future.conditions <- base::list()
[09:31:18.958]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.958]     if (FALSE) {
[09:31:18.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.958]     }
[09:31:18.958]     ...future.result <- base::tryCatch({
[09:31:18.958]         base::withCallingHandlers({
[09:31:18.958]             ...future.value <- base::withVisible(base::local({
[09:31:18.958]                 withCallingHandlers({
[09:31:18.958]                   {
[09:31:18.958]                     lm(dist ~ poly(speed, 2), data = cars)
[09:31:18.958]                   }
[09:31:18.958]                 }, immediateCondition = function(cond) {
[09:31:18.958]                   save_rds <- function (object, pathname, ...) 
[09:31:18.958]                   {
[09:31:18.958]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.958]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.958]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.958]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.958]                         fi_tmp[["mtime"]])
[09:31:18.958]                     }
[09:31:18.958]                     tryCatch({
[09:31:18.958]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.958]                     }, error = function(ex) {
[09:31:18.958]                       msg <- conditionMessage(ex)
[09:31:18.958]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.958]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.958]                         fi_tmp[["mtime"]], msg)
[09:31:18.958]                       ex$message <- msg
[09:31:18.958]                       stop(ex)
[09:31:18.958]                     })
[09:31:18.958]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.958]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.958]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.958]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.958]                       fi <- file.info(pathname)
[09:31:18.958]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.958]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.958]                         fi[["size"]], fi[["mtime"]])
[09:31:18.958]                       stop(msg)
[09:31:18.958]                     }
[09:31:18.958]                     invisible(pathname)
[09:31:18.958]                   }
[09:31:18.958]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.958]                     rootPath = tempdir()) 
[09:31:18.958]                   {
[09:31:18.958]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.958]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.958]                       tmpdir = path, fileext = ".rds")
[09:31:18.958]                     save_rds(obj, file)
[09:31:18.958]                   }
[09:31:18.958]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.958]                   {
[09:31:18.958]                     inherits <- base::inherits
[09:31:18.958]                     invokeRestart <- base::invokeRestart
[09:31:18.958]                     is.null <- base::is.null
[09:31:18.958]                     muffled <- FALSE
[09:31:18.958]                     if (inherits(cond, "message")) {
[09:31:18.958]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.958]                       if (muffled) 
[09:31:18.958]                         invokeRestart("muffleMessage")
[09:31:18.958]                     }
[09:31:18.958]                     else if (inherits(cond, "warning")) {
[09:31:18.958]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.958]                       if (muffled) 
[09:31:18.958]                         invokeRestart("muffleWarning")
[09:31:18.958]                     }
[09:31:18.958]                     else if (inherits(cond, "condition")) {
[09:31:18.958]                       if (!is.null(pattern)) {
[09:31:18.958]                         computeRestarts <- base::computeRestarts
[09:31:18.958]                         grepl <- base::grepl
[09:31:18.958]                         restarts <- computeRestarts(cond)
[09:31:18.958]                         for (restart in restarts) {
[09:31:18.958]                           name <- restart$name
[09:31:18.958]                           if (is.null(name)) 
[09:31:18.958]                             next
[09:31:18.958]                           if (!grepl(pattern, name)) 
[09:31:18.958]                             next
[09:31:18.958]                           invokeRestart(restart)
[09:31:18.958]                           muffled <- TRUE
[09:31:18.958]                           break
[09:31:18.958]                         }
[09:31:18.958]                       }
[09:31:18.958]                     }
[09:31:18.958]                     invisible(muffled)
[09:31:18.958]                   }
[09:31:18.958]                   muffleCondition(cond)
[09:31:18.958]                 })
[09:31:18.958]             }))
[09:31:18.958]             future::FutureResult(value = ...future.value$value, 
[09:31:18.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.958]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.958]                     ...future.globalenv.names))
[09:31:18.958]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.958]         }, condition = base::local({
[09:31:18.958]             c <- base::c
[09:31:18.958]             inherits <- base::inherits
[09:31:18.958]             invokeRestart <- base::invokeRestart
[09:31:18.958]             length <- base::length
[09:31:18.958]             list <- base::list
[09:31:18.958]             seq.int <- base::seq.int
[09:31:18.958]             signalCondition <- base::signalCondition
[09:31:18.958]             sys.calls <- base::sys.calls
[09:31:18.958]             `[[` <- base::`[[`
[09:31:18.958]             `+` <- base::`+`
[09:31:18.958]             `<<-` <- base::`<<-`
[09:31:18.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.958]                   3L)]
[09:31:18.958]             }
[09:31:18.958]             function(cond) {
[09:31:18.958]                 is_error <- inherits(cond, "error")
[09:31:18.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.958]                   NULL)
[09:31:18.958]                 if (is_error) {
[09:31:18.958]                   sessionInformation <- function() {
[09:31:18.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.958]                       search = base::search(), system = base::Sys.info())
[09:31:18.958]                   }
[09:31:18.958]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.958]                     cond$call), session = sessionInformation(), 
[09:31:18.958]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.958]                   signalCondition(cond)
[09:31:18.958]                 }
[09:31:18.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.958]                 "immediateCondition"))) {
[09:31:18.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.958]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.958]                   if (TRUE && !signal) {
[09:31:18.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.958]                     {
[09:31:18.958]                       inherits <- base::inherits
[09:31:18.958]                       invokeRestart <- base::invokeRestart
[09:31:18.958]                       is.null <- base::is.null
[09:31:18.958]                       muffled <- FALSE
[09:31:18.958]                       if (inherits(cond, "message")) {
[09:31:18.958]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.958]                         if (muffled) 
[09:31:18.958]                           invokeRestart("muffleMessage")
[09:31:18.958]                       }
[09:31:18.958]                       else if (inherits(cond, "warning")) {
[09:31:18.958]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.958]                         if (muffled) 
[09:31:18.958]                           invokeRestart("muffleWarning")
[09:31:18.958]                       }
[09:31:18.958]                       else if (inherits(cond, "condition")) {
[09:31:18.958]                         if (!is.null(pattern)) {
[09:31:18.958]                           computeRestarts <- base::computeRestarts
[09:31:18.958]                           grepl <- base::grepl
[09:31:18.958]                           restarts <- computeRestarts(cond)
[09:31:18.958]                           for (restart in restarts) {
[09:31:18.958]                             name <- restart$name
[09:31:18.958]                             if (is.null(name)) 
[09:31:18.958]                               next
[09:31:18.958]                             if (!grepl(pattern, name)) 
[09:31:18.958]                               next
[09:31:18.958]                             invokeRestart(restart)
[09:31:18.958]                             muffled <- TRUE
[09:31:18.958]                             break
[09:31:18.958]                           }
[09:31:18.958]                         }
[09:31:18.958]                       }
[09:31:18.958]                       invisible(muffled)
[09:31:18.958]                     }
[09:31:18.958]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.958]                   }
[09:31:18.958]                 }
[09:31:18.958]                 else {
[09:31:18.958]                   if (TRUE) {
[09:31:18.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.958]                     {
[09:31:18.958]                       inherits <- base::inherits
[09:31:18.958]                       invokeRestart <- base::invokeRestart
[09:31:18.958]                       is.null <- base::is.null
[09:31:18.958]                       muffled <- FALSE
[09:31:18.958]                       if (inherits(cond, "message")) {
[09:31:18.958]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.958]                         if (muffled) 
[09:31:18.958]                           invokeRestart("muffleMessage")
[09:31:18.958]                       }
[09:31:18.958]                       else if (inherits(cond, "warning")) {
[09:31:18.958]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.958]                         if (muffled) 
[09:31:18.958]                           invokeRestart("muffleWarning")
[09:31:18.958]                       }
[09:31:18.958]                       else if (inherits(cond, "condition")) {
[09:31:18.958]                         if (!is.null(pattern)) {
[09:31:18.958]                           computeRestarts <- base::computeRestarts
[09:31:18.958]                           grepl <- base::grepl
[09:31:18.958]                           restarts <- computeRestarts(cond)
[09:31:18.958]                           for (restart in restarts) {
[09:31:18.958]                             name <- restart$name
[09:31:18.958]                             if (is.null(name)) 
[09:31:18.958]                               next
[09:31:18.958]                             if (!grepl(pattern, name)) 
[09:31:18.958]                               next
[09:31:18.958]                             invokeRestart(restart)
[09:31:18.958]                             muffled <- TRUE
[09:31:18.958]                             break
[09:31:18.958]                           }
[09:31:18.958]                         }
[09:31:18.958]                       }
[09:31:18.958]                       invisible(muffled)
[09:31:18.958]                     }
[09:31:18.958]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.958]                   }
[09:31:18.958]                 }
[09:31:18.958]             }
[09:31:18.958]         }))
[09:31:18.958]     }, error = function(ex) {
[09:31:18.958]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.958]                 ...future.rng), started = ...future.startTime, 
[09:31:18.958]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.958]             version = "1.8"), class = "FutureResult")
[09:31:18.958]     }, finally = {
[09:31:18.958]         if (!identical(...future.workdir, getwd())) 
[09:31:18.958]             setwd(...future.workdir)
[09:31:18.958]         {
[09:31:18.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.958]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.958]             }
[09:31:18.958]             base::options(...future.oldOptions)
[09:31:18.958]             if (.Platform$OS.type == "windows") {
[09:31:18.958]                 old_names <- names(...future.oldEnvVars)
[09:31:18.958]                 envs <- base::Sys.getenv()
[09:31:18.958]                 names <- names(envs)
[09:31:18.958]                 common <- intersect(names, old_names)
[09:31:18.958]                 added <- setdiff(names, old_names)
[09:31:18.958]                 removed <- setdiff(old_names, names)
[09:31:18.958]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.958]                   envs[common]]
[09:31:18.958]                 NAMES <- toupper(changed)
[09:31:18.958]                 args <- list()
[09:31:18.958]                 for (kk in seq_along(NAMES)) {
[09:31:18.958]                   name <- changed[[kk]]
[09:31:18.958]                   NAME <- NAMES[[kk]]
[09:31:18.958]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.958]                     next
[09:31:18.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.958]                 }
[09:31:18.958]                 NAMES <- toupper(added)
[09:31:18.958]                 for (kk in seq_along(NAMES)) {
[09:31:18.958]                   name <- added[[kk]]
[09:31:18.958]                   NAME <- NAMES[[kk]]
[09:31:18.958]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.958]                     next
[09:31:18.958]                   args[[name]] <- ""
[09:31:18.958]                 }
[09:31:18.958]                 NAMES <- toupper(removed)
[09:31:18.958]                 for (kk in seq_along(NAMES)) {
[09:31:18.958]                   name <- removed[[kk]]
[09:31:18.958]                   NAME <- NAMES[[kk]]
[09:31:18.958]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.958]                     next
[09:31:18.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.958]                 }
[09:31:18.958]                 if (length(args) > 0) 
[09:31:18.958]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.958]             }
[09:31:18.958]             else {
[09:31:18.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.958]             }
[09:31:18.958]             {
[09:31:18.958]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.958]                   0L) {
[09:31:18.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.958]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.958]                   base::options(opts)
[09:31:18.958]                 }
[09:31:18.958]                 {
[09:31:18.958]                   {
[09:31:18.958]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.958]                     NULL
[09:31:18.958]                   }
[09:31:18.958]                   options(future.plan = NULL)
[09:31:18.958]                   if (is.na(NA_character_)) 
[09:31:18.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.958]                     .init = FALSE)
[09:31:18.958]                 }
[09:31:18.958]             }
[09:31:18.958]         }
[09:31:18.958]     })
[09:31:18.958]     if (TRUE) {
[09:31:18.958]         base::sink(type = "output", split = FALSE)
[09:31:18.958]         if (TRUE) {
[09:31:18.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.958]         }
[09:31:18.958]         else {
[09:31:18.958]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.958]         }
[09:31:18.958]         base::close(...future.stdout)
[09:31:18.958]         ...future.stdout <- NULL
[09:31:18.958]     }
[09:31:18.958]     ...future.result$conditions <- ...future.conditions
[09:31:18.958]     ...future.result$finished <- base::Sys.time()
[09:31:18.958]     ...future.result
[09:31:18.958] }
[09:31:18.960] requestCore(): workers = 2
[09:31:18.962] MulticoreFuture started
[09:31:18.963] - Launch lazy future ... done
[09:31:18.963] run() for ‘MulticoreFuture’ ... done
[09:31:18.963] result() for MulticoreFuture ...
[09:31:18.964] plan(): Setting new future strategy stack:
[09:31:18.964] List of future strategies:
[09:31:18.964] 1. sequential:
[09:31:18.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:18.964]    - tweaked: FALSE
[09:31:18.964]    - call: NULL
[09:31:18.965] plan(): nbrOfWorkers() = 1
[09:31:18.969] plan(): Setting new future strategy stack:
[09:31:18.969] List of future strategies:
[09:31:18.969] 1. multicore:
[09:31:18.969]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:18.969]    - tweaked: FALSE
[09:31:18.969]    - call: plan(strategy)
[09:31:18.974] plan(): nbrOfWorkers() = 2
[09:31:18.976] result() for MulticoreFuture ...
[09:31:18.976] result() for MulticoreFuture ... done
[09:31:18.976] result() for MulticoreFuture ... done
[09:31:18.977] result() for MulticoreFuture ...
[09:31:18.977] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[09:31:18.980] getGlobalsAndPackages() ...
[09:31:18.980] Searching for globals...
[09:31:18.985] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[09:31:18.986] Searching for globals ... DONE
[09:31:18.986] Resolving globals: FALSE
[09:31:18.987] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[09:31:18.989] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[09:31:18.990] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[09:31:18.990] 
[09:31:18.990] getGlobalsAndPackages() ... DONE
[09:31:18.990] run() for ‘Future’ ...
[09:31:18.991] - state: ‘created’
[09:31:18.991] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:18.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:18.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:18.995]   - Field: ‘label’
[09:31:18.995]   - Field: ‘local’
[09:31:18.995]   - Field: ‘owner’
[09:31:18.995]   - Field: ‘envir’
[09:31:18.996]   - Field: ‘workers’
[09:31:18.996]   - Field: ‘packages’
[09:31:18.996]   - Field: ‘gc’
[09:31:18.996]   - Field: ‘job’
[09:31:18.996]   - Field: ‘conditions’
[09:31:18.996]   - Field: ‘expr’
[09:31:18.996]   - Field: ‘uuid’
[09:31:18.996]   - Field: ‘seed’
[09:31:18.996]   - Field: ‘version’
[09:31:18.997]   - Field: ‘result’
[09:31:18.997]   - Field: ‘asynchronous’
[09:31:18.997]   - Field: ‘calls’
[09:31:18.997]   - Field: ‘globals’
[09:31:18.997]   - Field: ‘stdout’
[09:31:18.997]   - Field: ‘earlySignal’
[09:31:18.997]   - Field: ‘lazy’
[09:31:18.997]   - Field: ‘state’
[09:31:18.997] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:18.997] - Launch lazy future ...
[09:31:18.998] Packages needed by the future expression (n = 0): <none>
[09:31:18.998] Packages needed by future strategies (n = 0): <none>
[09:31:18.998] {
[09:31:18.998]     {
[09:31:18.998]         {
[09:31:18.998]             ...future.startTime <- base::Sys.time()
[09:31:18.998]             {
[09:31:18.998]                 {
[09:31:18.998]                   {
[09:31:18.998]                     {
[09:31:18.998]                       base::local({
[09:31:18.998]                         has_future <- base::requireNamespace("future", 
[09:31:18.998]                           quietly = TRUE)
[09:31:18.998]                         if (has_future) {
[09:31:18.998]                           ns <- base::getNamespace("future")
[09:31:18.998]                           version <- ns[[".package"]][["version"]]
[09:31:18.998]                           if (is.null(version)) 
[09:31:18.998]                             version <- utils::packageVersion("future")
[09:31:18.998]                         }
[09:31:18.998]                         else {
[09:31:18.998]                           version <- NULL
[09:31:18.998]                         }
[09:31:18.998]                         if (!has_future || version < "1.8.0") {
[09:31:18.998]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:18.998]                             "", base::R.version$version.string), 
[09:31:18.998]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:18.998]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:18.998]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:18.998]                               "release", "version")], collapse = " "), 
[09:31:18.998]                             hostname = base::Sys.info()[["nodename"]])
[09:31:18.998]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:18.998]                             info)
[09:31:18.998]                           info <- base::paste(info, collapse = "; ")
[09:31:18.998]                           if (!has_future) {
[09:31:18.998]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:18.998]                               info)
[09:31:18.998]                           }
[09:31:18.998]                           else {
[09:31:18.998]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:18.998]                               info, version)
[09:31:18.998]                           }
[09:31:18.998]                           base::stop(msg)
[09:31:18.998]                         }
[09:31:18.998]                       })
[09:31:18.998]                     }
[09:31:18.998]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:18.998]                     base::options(mc.cores = 1L)
[09:31:18.998]                   }
[09:31:18.998]                   ...future.strategy.old <- future::plan("list")
[09:31:18.998]                   options(future.plan = NULL)
[09:31:18.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:18.998]                 }
[09:31:18.998]                 ...future.workdir <- getwd()
[09:31:18.998]             }
[09:31:18.998]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:18.998]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:18.998]         }
[09:31:18.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:18.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:18.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:18.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:18.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:18.998]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:18.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:18.998]             base::names(...future.oldOptions))
[09:31:18.998]     }
[09:31:18.998]     if (FALSE) {
[09:31:18.998]     }
[09:31:18.998]     else {
[09:31:18.998]         if (TRUE) {
[09:31:18.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:18.998]                 open = "w")
[09:31:18.998]         }
[09:31:18.998]         else {
[09:31:18.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:18.998]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:18.998]         }
[09:31:18.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:18.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:18.998]             base::sink(type = "output", split = FALSE)
[09:31:18.998]             base::close(...future.stdout)
[09:31:18.998]         }, add = TRUE)
[09:31:18.998]     }
[09:31:18.998]     ...future.frame <- base::sys.nframe()
[09:31:18.998]     ...future.conditions <- base::list()
[09:31:18.998]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:18.998]     if (FALSE) {
[09:31:18.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:18.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:18.998]     }
[09:31:18.998]     ...future.result <- base::tryCatch({
[09:31:18.998]         base::withCallingHandlers({
[09:31:18.998]             ...future.value <- base::withVisible(base::local({
[09:31:18.998]                 withCallingHandlers({
[09:31:18.998]                   {
[09:31:18.998]                     outer_function(1L)
[09:31:18.998]                   }
[09:31:18.998]                 }, immediateCondition = function(cond) {
[09:31:18.998]                   save_rds <- function (object, pathname, ...) 
[09:31:18.998]                   {
[09:31:18.998]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:18.998]                     if (file_test("-f", pathname_tmp)) {
[09:31:18.998]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.998]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:18.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.998]                         fi_tmp[["mtime"]])
[09:31:18.998]                     }
[09:31:18.998]                     tryCatch({
[09:31:18.998]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:18.998]                     }, error = function(ex) {
[09:31:18.998]                       msg <- conditionMessage(ex)
[09:31:18.998]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.998]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:18.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.998]                         fi_tmp[["mtime"]], msg)
[09:31:18.998]                       ex$message <- msg
[09:31:18.998]                       stop(ex)
[09:31:18.998]                     })
[09:31:18.998]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:18.998]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:18.998]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:18.998]                       fi_tmp <- file.info(pathname_tmp)
[09:31:18.998]                       fi <- file.info(pathname)
[09:31:18.998]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:18.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:18.998]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:18.998]                         fi[["size"]], fi[["mtime"]])
[09:31:18.998]                       stop(msg)
[09:31:18.998]                     }
[09:31:18.998]                     invisible(pathname)
[09:31:18.998]                   }
[09:31:18.998]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:18.998]                     rootPath = tempdir()) 
[09:31:18.998]                   {
[09:31:18.998]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:18.998]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:18.998]                       tmpdir = path, fileext = ".rds")
[09:31:18.998]                     save_rds(obj, file)
[09:31:18.998]                   }
[09:31:18.998]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:18.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.998]                   {
[09:31:18.998]                     inherits <- base::inherits
[09:31:18.998]                     invokeRestart <- base::invokeRestart
[09:31:18.998]                     is.null <- base::is.null
[09:31:18.998]                     muffled <- FALSE
[09:31:18.998]                     if (inherits(cond, "message")) {
[09:31:18.998]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:18.998]                       if (muffled) 
[09:31:18.998]                         invokeRestart("muffleMessage")
[09:31:18.998]                     }
[09:31:18.998]                     else if (inherits(cond, "warning")) {
[09:31:18.998]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:18.998]                       if (muffled) 
[09:31:18.998]                         invokeRestart("muffleWarning")
[09:31:18.998]                     }
[09:31:18.998]                     else if (inherits(cond, "condition")) {
[09:31:18.998]                       if (!is.null(pattern)) {
[09:31:18.998]                         computeRestarts <- base::computeRestarts
[09:31:18.998]                         grepl <- base::grepl
[09:31:18.998]                         restarts <- computeRestarts(cond)
[09:31:18.998]                         for (restart in restarts) {
[09:31:18.998]                           name <- restart$name
[09:31:18.998]                           if (is.null(name)) 
[09:31:18.998]                             next
[09:31:18.998]                           if (!grepl(pattern, name)) 
[09:31:18.998]                             next
[09:31:18.998]                           invokeRestart(restart)
[09:31:18.998]                           muffled <- TRUE
[09:31:18.998]                           break
[09:31:18.998]                         }
[09:31:18.998]                       }
[09:31:18.998]                     }
[09:31:18.998]                     invisible(muffled)
[09:31:18.998]                   }
[09:31:18.998]                   muffleCondition(cond)
[09:31:18.998]                 })
[09:31:18.998]             }))
[09:31:18.998]             future::FutureResult(value = ...future.value$value, 
[09:31:18.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.998]                   ...future.rng), globalenv = if (FALSE) 
[09:31:18.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:18.998]                     ...future.globalenv.names))
[09:31:18.998]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:18.998]         }, condition = base::local({
[09:31:18.998]             c <- base::c
[09:31:18.998]             inherits <- base::inherits
[09:31:18.998]             invokeRestart <- base::invokeRestart
[09:31:18.998]             length <- base::length
[09:31:18.998]             list <- base::list
[09:31:18.998]             seq.int <- base::seq.int
[09:31:18.998]             signalCondition <- base::signalCondition
[09:31:18.998]             sys.calls <- base::sys.calls
[09:31:18.998]             `[[` <- base::`[[`
[09:31:18.998]             `+` <- base::`+`
[09:31:18.998]             `<<-` <- base::`<<-`
[09:31:18.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:18.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:18.998]                   3L)]
[09:31:18.998]             }
[09:31:18.998]             function(cond) {
[09:31:18.998]                 is_error <- inherits(cond, "error")
[09:31:18.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:18.998]                   NULL)
[09:31:18.998]                 if (is_error) {
[09:31:18.998]                   sessionInformation <- function() {
[09:31:18.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:18.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:18.998]                       search = base::search(), system = base::Sys.info())
[09:31:18.998]                   }
[09:31:18.998]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:18.998]                     cond$call), session = sessionInformation(), 
[09:31:18.998]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:18.998]                   signalCondition(cond)
[09:31:18.998]                 }
[09:31:18.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:18.998]                 "immediateCondition"))) {
[09:31:18.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:18.998]                   ...future.conditions[[length(...future.conditions) + 
[09:31:18.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:18.998]                   if (TRUE && !signal) {
[09:31:18.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.998]                     {
[09:31:18.998]                       inherits <- base::inherits
[09:31:18.998]                       invokeRestart <- base::invokeRestart
[09:31:18.998]                       is.null <- base::is.null
[09:31:18.998]                       muffled <- FALSE
[09:31:18.998]                       if (inherits(cond, "message")) {
[09:31:18.998]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.998]                         if (muffled) 
[09:31:18.998]                           invokeRestart("muffleMessage")
[09:31:18.998]                       }
[09:31:18.998]                       else if (inherits(cond, "warning")) {
[09:31:18.998]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.998]                         if (muffled) 
[09:31:18.998]                           invokeRestart("muffleWarning")
[09:31:18.998]                       }
[09:31:18.998]                       else if (inherits(cond, "condition")) {
[09:31:18.998]                         if (!is.null(pattern)) {
[09:31:18.998]                           computeRestarts <- base::computeRestarts
[09:31:18.998]                           grepl <- base::grepl
[09:31:18.998]                           restarts <- computeRestarts(cond)
[09:31:18.998]                           for (restart in restarts) {
[09:31:18.998]                             name <- restart$name
[09:31:18.998]                             if (is.null(name)) 
[09:31:18.998]                               next
[09:31:18.998]                             if (!grepl(pattern, name)) 
[09:31:18.998]                               next
[09:31:18.998]                             invokeRestart(restart)
[09:31:18.998]                             muffled <- TRUE
[09:31:18.998]                             break
[09:31:18.998]                           }
[09:31:18.998]                         }
[09:31:18.998]                       }
[09:31:18.998]                       invisible(muffled)
[09:31:18.998]                     }
[09:31:18.998]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.998]                   }
[09:31:18.998]                 }
[09:31:18.998]                 else {
[09:31:18.998]                   if (TRUE) {
[09:31:18.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:18.998]                     {
[09:31:18.998]                       inherits <- base::inherits
[09:31:18.998]                       invokeRestart <- base::invokeRestart
[09:31:18.998]                       is.null <- base::is.null
[09:31:18.998]                       muffled <- FALSE
[09:31:18.998]                       if (inherits(cond, "message")) {
[09:31:18.998]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:18.998]                         if (muffled) 
[09:31:18.998]                           invokeRestart("muffleMessage")
[09:31:18.998]                       }
[09:31:18.998]                       else if (inherits(cond, "warning")) {
[09:31:18.998]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:18.998]                         if (muffled) 
[09:31:18.998]                           invokeRestart("muffleWarning")
[09:31:18.998]                       }
[09:31:18.998]                       else if (inherits(cond, "condition")) {
[09:31:18.998]                         if (!is.null(pattern)) {
[09:31:18.998]                           computeRestarts <- base::computeRestarts
[09:31:18.998]                           grepl <- base::grepl
[09:31:18.998]                           restarts <- computeRestarts(cond)
[09:31:18.998]                           for (restart in restarts) {
[09:31:18.998]                             name <- restart$name
[09:31:18.998]                             if (is.null(name)) 
[09:31:18.998]                               next
[09:31:18.998]                             if (!grepl(pattern, name)) 
[09:31:18.998]                               next
[09:31:18.998]                             invokeRestart(restart)
[09:31:18.998]                             muffled <- TRUE
[09:31:18.998]                             break
[09:31:18.998]                           }
[09:31:18.998]                         }
[09:31:18.998]                       }
[09:31:18.998]                       invisible(muffled)
[09:31:18.998]                     }
[09:31:18.998]                     muffleCondition(cond, pattern = "^muffle")
[09:31:18.998]                   }
[09:31:18.998]                 }
[09:31:18.998]             }
[09:31:18.998]         }))
[09:31:18.998]     }, error = function(ex) {
[09:31:18.998]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:18.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:18.998]                 ...future.rng), started = ...future.startTime, 
[09:31:18.998]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:18.998]             version = "1.8"), class = "FutureResult")
[09:31:18.998]     }, finally = {
[09:31:18.998]         if (!identical(...future.workdir, getwd())) 
[09:31:18.998]             setwd(...future.workdir)
[09:31:18.998]         {
[09:31:18.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:18.998]                 ...future.oldOptions$nwarnings <- NULL
[09:31:18.998]             }
[09:31:18.998]             base::options(...future.oldOptions)
[09:31:18.998]             if (.Platform$OS.type == "windows") {
[09:31:18.998]                 old_names <- names(...future.oldEnvVars)
[09:31:18.998]                 envs <- base::Sys.getenv()
[09:31:18.998]                 names <- names(envs)
[09:31:18.998]                 common <- intersect(names, old_names)
[09:31:18.998]                 added <- setdiff(names, old_names)
[09:31:18.998]                 removed <- setdiff(old_names, names)
[09:31:18.998]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:18.998]                   envs[common]]
[09:31:18.998]                 NAMES <- toupper(changed)
[09:31:18.998]                 args <- list()
[09:31:18.998]                 for (kk in seq_along(NAMES)) {
[09:31:18.998]                   name <- changed[[kk]]
[09:31:18.998]                   NAME <- NAMES[[kk]]
[09:31:18.998]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.998]                     next
[09:31:18.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.998]                 }
[09:31:18.998]                 NAMES <- toupper(added)
[09:31:18.998]                 for (kk in seq_along(NAMES)) {
[09:31:18.998]                   name <- added[[kk]]
[09:31:18.998]                   NAME <- NAMES[[kk]]
[09:31:18.998]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.998]                     next
[09:31:18.998]                   args[[name]] <- ""
[09:31:18.998]                 }
[09:31:18.998]                 NAMES <- toupper(removed)
[09:31:18.998]                 for (kk in seq_along(NAMES)) {
[09:31:18.998]                   name <- removed[[kk]]
[09:31:18.998]                   NAME <- NAMES[[kk]]
[09:31:18.998]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:18.998]                     next
[09:31:18.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:18.998]                 }
[09:31:18.998]                 if (length(args) > 0) 
[09:31:18.998]                   base::do.call(base::Sys.setenv, args = args)
[09:31:18.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:18.998]             }
[09:31:18.998]             else {
[09:31:18.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:18.998]             }
[09:31:18.998]             {
[09:31:18.998]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:18.998]                   0L) {
[09:31:18.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:18.998]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:18.998]                   base::options(opts)
[09:31:18.998]                 }
[09:31:18.998]                 {
[09:31:18.998]                   {
[09:31:18.998]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:18.998]                     NULL
[09:31:18.998]                   }
[09:31:18.998]                   options(future.plan = NULL)
[09:31:18.998]                   if (is.na(NA_character_)) 
[09:31:18.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:18.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:18.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:18.998]                     .init = FALSE)
[09:31:18.998]                 }
[09:31:18.998]             }
[09:31:18.998]         }
[09:31:18.998]     })
[09:31:18.998]     if (TRUE) {
[09:31:18.998]         base::sink(type = "output", split = FALSE)
[09:31:18.998]         if (TRUE) {
[09:31:18.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:18.998]         }
[09:31:18.998]         else {
[09:31:18.998]             ...future.result["stdout"] <- base::list(NULL)
[09:31:18.998]         }
[09:31:18.998]         base::close(...future.stdout)
[09:31:18.998]         ...future.stdout <- NULL
[09:31:18.998]     }
[09:31:18.998]     ...future.result$conditions <- ...future.conditions
[09:31:18.998]     ...future.result$finished <- base::Sys.time()
[09:31:18.998]     ...future.result
[09:31:18.998] }
[09:31:19.001] assign_globals() ...
[09:31:19.001] List of 3
[09:31:19.001]  $ outer_function:function (x)  
[09:31:19.001]  $ map           :function (.x, .f, ...)  
[09:31:19.001]  $ inner_function:function (x)  
[09:31:19.001]  - attr(*, "where")=List of 3
[09:31:19.001]   ..$ outer_function:<environment: R_EmptyEnv> 
[09:31:19.001]   ..$ map           :<environment: R_EmptyEnv> 
[09:31:19.001]   ..$ inner_function:<environment: R_EmptyEnv> 
[09:31:19.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:19.001]  - attr(*, "resolved")= logi FALSE
[09:31:19.001]  - attr(*, "total_size")= num 7704
[09:31:19.001]  - attr(*, "already-done")= logi TRUE
[09:31:19.004] - reassign environment for ‘outer_function’
[09:31:19.004] - copied ‘outer_function’ to environment
[09:31:19.005] - reassign environment for ‘map’
[09:31:19.005] - copied ‘map’ to environment
[09:31:19.005] - reassign environment for ‘inner_function’
[09:31:19.005] - copied ‘inner_function’ to environment
[09:31:19.005] assign_globals() ... done
[09:31:19.005] requestCore(): workers = 2
[09:31:19.007] MulticoreFuture started
[09:31:19.007] - Launch lazy future ... done
[09:31:19.007] run() for ‘MulticoreFuture’ ... done
[09:31:19.008] result() for MulticoreFuture ...
[09:31:19.008] plan(): Setting new future strategy stack:
[09:31:19.008] List of future strategies:
[09:31:19.008] 1. sequential:
[09:31:19.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:19.008]    - tweaked: FALSE
[09:31:19.008]    - call: NULL
[09:31:19.009] plan(): nbrOfWorkers() = 1
[09:31:19.012] plan(): Setting new future strategy stack:
[09:31:19.012] List of future strategies:
[09:31:19.012] 1. multicore:
[09:31:19.012]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:19.012]    - tweaked: FALSE
[09:31:19.012]    - call: plan(strategy)
[09:31:19.017] plan(): nbrOfWorkers() = 2
[09:31:19.018] result() for MulticoreFuture ...
[09:31:19.018] result() for MulticoreFuture ... done
[09:31:19.018] result() for MulticoreFuture ... done
[09:31:19.018] result() for MulticoreFuture ...
[09:31:19.018] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[09:31:19.020] getGlobalsAndPackages() ...
[09:31:19.020] Searching for globals...
[09:31:19.025] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[09:31:19.026] Searching for globals ... DONE
[09:31:19.026] Resolving globals: FALSE
[09:31:19.027] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[09:31:19.027] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[09:31:19.027] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[09:31:19.027] 
[09:31:19.028] getGlobalsAndPackages() ... DONE
[09:31:19.028] run() for ‘Future’ ...
[09:31:19.028] - state: ‘created’
[09:31:19.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:19.032] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:19.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:19.032]   - Field: ‘label’
[09:31:19.032]   - Field: ‘local’
[09:31:19.032]   - Field: ‘owner’
[09:31:19.033]   - Field: ‘envir’
[09:31:19.033]   - Field: ‘workers’
[09:31:19.033]   - Field: ‘packages’
[09:31:19.033]   - Field: ‘gc’
[09:31:19.033]   - Field: ‘job’
[09:31:19.033]   - Field: ‘conditions’
[09:31:19.033]   - Field: ‘expr’
[09:31:19.033]   - Field: ‘uuid’
[09:31:19.033]   - Field: ‘seed’
[09:31:19.034]   - Field: ‘version’
[09:31:19.034]   - Field: ‘result’
[09:31:19.034]   - Field: ‘asynchronous’
[09:31:19.036]   - Field: ‘calls’
[09:31:19.036]   - Field: ‘globals’
[09:31:19.036]   - Field: ‘stdout’
[09:31:19.036]   - Field: ‘earlySignal’
[09:31:19.036]   - Field: ‘lazy’
[09:31:19.036]   - Field: ‘state’
[09:31:19.037] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:19.037] - Launch lazy future ...
[09:31:19.037] Packages needed by the future expression (n = 0): <none>
[09:31:19.037] Packages needed by future strategies (n = 0): <none>
[09:31:19.038] {
[09:31:19.038]     {
[09:31:19.038]         {
[09:31:19.038]             ...future.startTime <- base::Sys.time()
[09:31:19.038]             {
[09:31:19.038]                 {
[09:31:19.038]                   {
[09:31:19.038]                     {
[09:31:19.038]                       base::local({
[09:31:19.038]                         has_future <- base::requireNamespace("future", 
[09:31:19.038]                           quietly = TRUE)
[09:31:19.038]                         if (has_future) {
[09:31:19.038]                           ns <- base::getNamespace("future")
[09:31:19.038]                           version <- ns[[".package"]][["version"]]
[09:31:19.038]                           if (is.null(version)) 
[09:31:19.038]                             version <- utils::packageVersion("future")
[09:31:19.038]                         }
[09:31:19.038]                         else {
[09:31:19.038]                           version <- NULL
[09:31:19.038]                         }
[09:31:19.038]                         if (!has_future || version < "1.8.0") {
[09:31:19.038]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.038]                             "", base::R.version$version.string), 
[09:31:19.038]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:19.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:19.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.038]                               "release", "version")], collapse = " "), 
[09:31:19.038]                             hostname = base::Sys.info()[["nodename"]])
[09:31:19.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.038]                             info)
[09:31:19.038]                           info <- base::paste(info, collapse = "; ")
[09:31:19.038]                           if (!has_future) {
[09:31:19.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.038]                               info)
[09:31:19.038]                           }
[09:31:19.038]                           else {
[09:31:19.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.038]                               info, version)
[09:31:19.038]                           }
[09:31:19.038]                           base::stop(msg)
[09:31:19.038]                         }
[09:31:19.038]                       })
[09:31:19.038]                     }
[09:31:19.038]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.038]                     base::options(mc.cores = 1L)
[09:31:19.038]                   }
[09:31:19.038]                   ...future.strategy.old <- future::plan("list")
[09:31:19.038]                   options(future.plan = NULL)
[09:31:19.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.038]                 }
[09:31:19.038]                 ...future.workdir <- getwd()
[09:31:19.038]             }
[09:31:19.038]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.038]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.038]         }
[09:31:19.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.038]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.038]             base::names(...future.oldOptions))
[09:31:19.038]     }
[09:31:19.038]     if (FALSE) {
[09:31:19.038]     }
[09:31:19.038]     else {
[09:31:19.038]         if (TRUE) {
[09:31:19.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.038]                 open = "w")
[09:31:19.038]         }
[09:31:19.038]         else {
[09:31:19.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.038]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.038]         }
[09:31:19.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.038]             base::sink(type = "output", split = FALSE)
[09:31:19.038]             base::close(...future.stdout)
[09:31:19.038]         }, add = TRUE)
[09:31:19.038]     }
[09:31:19.038]     ...future.frame <- base::sys.nframe()
[09:31:19.038]     ...future.conditions <- base::list()
[09:31:19.038]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.038]     if (FALSE) {
[09:31:19.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.038]     }
[09:31:19.038]     ...future.result <- base::tryCatch({
[09:31:19.038]         base::withCallingHandlers({
[09:31:19.038]             ...future.value <- base::withVisible(base::local({
[09:31:19.038]                 withCallingHandlers({
[09:31:19.038]                   {
[09:31:19.038]                     outer_function(1L)
[09:31:19.038]                   }
[09:31:19.038]                 }, immediateCondition = function(cond) {
[09:31:19.038]                   save_rds <- function (object, pathname, ...) 
[09:31:19.038]                   {
[09:31:19.038]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:19.038]                     if (file_test("-f", pathname_tmp)) {
[09:31:19.038]                       fi_tmp <- file.info(pathname_tmp)
[09:31:19.038]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:19.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:19.038]                         fi_tmp[["mtime"]])
[09:31:19.038]                     }
[09:31:19.038]                     tryCatch({
[09:31:19.038]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:19.038]                     }, error = function(ex) {
[09:31:19.038]                       msg <- conditionMessage(ex)
[09:31:19.038]                       fi_tmp <- file.info(pathname_tmp)
[09:31:19.038]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:19.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:19.038]                         fi_tmp[["mtime"]], msg)
[09:31:19.038]                       ex$message <- msg
[09:31:19.038]                       stop(ex)
[09:31:19.038]                     })
[09:31:19.038]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:19.038]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:19.038]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:19.038]                       fi_tmp <- file.info(pathname_tmp)
[09:31:19.038]                       fi <- file.info(pathname)
[09:31:19.038]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:19.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:19.038]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:19.038]                         fi[["size"]], fi[["mtime"]])
[09:31:19.038]                       stop(msg)
[09:31:19.038]                     }
[09:31:19.038]                     invisible(pathname)
[09:31:19.038]                   }
[09:31:19.038]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:19.038]                     rootPath = tempdir()) 
[09:31:19.038]                   {
[09:31:19.038]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:19.038]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:19.038]                       tmpdir = path, fileext = ".rds")
[09:31:19.038]                     save_rds(obj, file)
[09:31:19.038]                   }
[09:31:19.038]                   saveImmediateCondition(cond, path = "/tmp/RtmpJD3Fwy/.future/immediateConditions")
[09:31:19.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.038]                   {
[09:31:19.038]                     inherits <- base::inherits
[09:31:19.038]                     invokeRestart <- base::invokeRestart
[09:31:19.038]                     is.null <- base::is.null
[09:31:19.038]                     muffled <- FALSE
[09:31:19.038]                     if (inherits(cond, "message")) {
[09:31:19.038]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.038]                       if (muffled) 
[09:31:19.038]                         invokeRestart("muffleMessage")
[09:31:19.038]                     }
[09:31:19.038]                     else if (inherits(cond, "warning")) {
[09:31:19.038]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.038]                       if (muffled) 
[09:31:19.038]                         invokeRestart("muffleWarning")
[09:31:19.038]                     }
[09:31:19.038]                     else if (inherits(cond, "condition")) {
[09:31:19.038]                       if (!is.null(pattern)) {
[09:31:19.038]                         computeRestarts <- base::computeRestarts
[09:31:19.038]                         grepl <- base::grepl
[09:31:19.038]                         restarts <- computeRestarts(cond)
[09:31:19.038]                         for (restart in restarts) {
[09:31:19.038]                           name <- restart$name
[09:31:19.038]                           if (is.null(name)) 
[09:31:19.038]                             next
[09:31:19.038]                           if (!grepl(pattern, name)) 
[09:31:19.038]                             next
[09:31:19.038]                           invokeRestart(restart)
[09:31:19.038]                           muffled <- TRUE
[09:31:19.038]                           break
[09:31:19.038]                         }
[09:31:19.038]                       }
[09:31:19.038]                     }
[09:31:19.038]                     invisible(muffled)
[09:31:19.038]                   }
[09:31:19.038]                   muffleCondition(cond)
[09:31:19.038]                 })
[09:31:19.038]             }))
[09:31:19.038]             future::FutureResult(value = ...future.value$value, 
[09:31:19.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.038]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.038]                     ...future.globalenv.names))
[09:31:19.038]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.038]         }, condition = base::local({
[09:31:19.038]             c <- base::c
[09:31:19.038]             inherits <- base::inherits
[09:31:19.038]             invokeRestart <- base::invokeRestart
[09:31:19.038]             length <- base::length
[09:31:19.038]             list <- base::list
[09:31:19.038]             seq.int <- base::seq.int
[09:31:19.038]             signalCondition <- base::signalCondition
[09:31:19.038]             sys.calls <- base::sys.calls
[09:31:19.038]             `[[` <- base::`[[`
[09:31:19.038]             `+` <- base::`+`
[09:31:19.038]             `<<-` <- base::`<<-`
[09:31:19.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.038]                   3L)]
[09:31:19.038]             }
[09:31:19.038]             function(cond) {
[09:31:19.038]                 is_error <- inherits(cond, "error")
[09:31:19.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.038]                   NULL)
[09:31:19.038]                 if (is_error) {
[09:31:19.038]                   sessionInformation <- function() {
[09:31:19.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.038]                       search = base::search(), system = base::Sys.info())
[09:31:19.038]                   }
[09:31:19.038]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.038]                     cond$call), session = sessionInformation(), 
[09:31:19.038]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.038]                   signalCondition(cond)
[09:31:19.038]                 }
[09:31:19.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.038]                 "immediateCondition"))) {
[09:31:19.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.038]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.038]                   if (TRUE && !signal) {
[09:31:19.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.038]                     {
[09:31:19.038]                       inherits <- base::inherits
[09:31:19.038]                       invokeRestart <- base::invokeRestart
[09:31:19.038]                       is.null <- base::is.null
[09:31:19.038]                       muffled <- FALSE
[09:31:19.038]                       if (inherits(cond, "message")) {
[09:31:19.038]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.038]                         if (muffled) 
[09:31:19.038]                           invokeRestart("muffleMessage")
[09:31:19.038]                       }
[09:31:19.038]                       else if (inherits(cond, "warning")) {
[09:31:19.038]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.038]                         if (muffled) 
[09:31:19.038]                           invokeRestart("muffleWarning")
[09:31:19.038]                       }
[09:31:19.038]                       else if (inherits(cond, "condition")) {
[09:31:19.038]                         if (!is.null(pattern)) {
[09:31:19.038]                           computeRestarts <- base::computeRestarts
[09:31:19.038]                           grepl <- base::grepl
[09:31:19.038]                           restarts <- computeRestarts(cond)
[09:31:19.038]                           for (restart in restarts) {
[09:31:19.038]                             name <- restart$name
[09:31:19.038]                             if (is.null(name)) 
[09:31:19.038]                               next
[09:31:19.038]                             if (!grepl(pattern, name)) 
[09:31:19.038]                               next
[09:31:19.038]                             invokeRestart(restart)
[09:31:19.038]                             muffled <- TRUE
[09:31:19.038]                             break
[09:31:19.038]                           }
[09:31:19.038]                         }
[09:31:19.038]                       }
[09:31:19.038]                       invisible(muffled)
[09:31:19.038]                     }
[09:31:19.038]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.038]                   }
[09:31:19.038]                 }
[09:31:19.038]                 else {
[09:31:19.038]                   if (TRUE) {
[09:31:19.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.038]                     {
[09:31:19.038]                       inherits <- base::inherits
[09:31:19.038]                       invokeRestart <- base::invokeRestart
[09:31:19.038]                       is.null <- base::is.null
[09:31:19.038]                       muffled <- FALSE
[09:31:19.038]                       if (inherits(cond, "message")) {
[09:31:19.038]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.038]                         if (muffled) 
[09:31:19.038]                           invokeRestart("muffleMessage")
[09:31:19.038]                       }
[09:31:19.038]                       else if (inherits(cond, "warning")) {
[09:31:19.038]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.038]                         if (muffled) 
[09:31:19.038]                           invokeRestart("muffleWarning")
[09:31:19.038]                       }
[09:31:19.038]                       else if (inherits(cond, "condition")) {
[09:31:19.038]                         if (!is.null(pattern)) {
[09:31:19.038]                           computeRestarts <- base::computeRestarts
[09:31:19.038]                           grepl <- base::grepl
[09:31:19.038]                           restarts <- computeRestarts(cond)
[09:31:19.038]                           for (restart in restarts) {
[09:31:19.038]                             name <- restart$name
[09:31:19.038]                             if (is.null(name)) 
[09:31:19.038]                               next
[09:31:19.038]                             if (!grepl(pattern, name)) 
[09:31:19.038]                               next
[09:31:19.038]                             invokeRestart(restart)
[09:31:19.038]                             muffled <- TRUE
[09:31:19.038]                             break
[09:31:19.038]                           }
[09:31:19.038]                         }
[09:31:19.038]                       }
[09:31:19.038]                       invisible(muffled)
[09:31:19.038]                     }
[09:31:19.038]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.038]                   }
[09:31:19.038]                 }
[09:31:19.038]             }
[09:31:19.038]         }))
[09:31:19.038]     }, error = function(ex) {
[09:31:19.038]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.038]                 ...future.rng), started = ...future.startTime, 
[09:31:19.038]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.038]             version = "1.8"), class = "FutureResult")
[09:31:19.038]     }, finally = {
[09:31:19.038]         if (!identical(...future.workdir, getwd())) 
[09:31:19.038]             setwd(...future.workdir)
[09:31:19.038]         {
[09:31:19.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.038]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.038]             }
[09:31:19.038]             base::options(...future.oldOptions)
[09:31:19.038]             if (.Platform$OS.type == "windows") {
[09:31:19.038]                 old_names <- names(...future.oldEnvVars)
[09:31:19.038]                 envs <- base::Sys.getenv()
[09:31:19.038]                 names <- names(envs)
[09:31:19.038]                 common <- intersect(names, old_names)
[09:31:19.038]                 added <- setdiff(names, old_names)
[09:31:19.038]                 removed <- setdiff(old_names, names)
[09:31:19.038]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.038]                   envs[common]]
[09:31:19.038]                 NAMES <- toupper(changed)
[09:31:19.038]                 args <- list()
[09:31:19.038]                 for (kk in seq_along(NAMES)) {
[09:31:19.038]                   name <- changed[[kk]]
[09:31:19.038]                   NAME <- NAMES[[kk]]
[09:31:19.038]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.038]                     next
[09:31:19.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.038]                 }
[09:31:19.038]                 NAMES <- toupper(added)
[09:31:19.038]                 for (kk in seq_along(NAMES)) {
[09:31:19.038]                   name <- added[[kk]]
[09:31:19.038]                   NAME <- NAMES[[kk]]
[09:31:19.038]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.038]                     next
[09:31:19.038]                   args[[name]] <- ""
[09:31:19.038]                 }
[09:31:19.038]                 NAMES <- toupper(removed)
[09:31:19.038]                 for (kk in seq_along(NAMES)) {
[09:31:19.038]                   name <- removed[[kk]]
[09:31:19.038]                   NAME <- NAMES[[kk]]
[09:31:19.038]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.038]                     next
[09:31:19.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.038]                 }
[09:31:19.038]                 if (length(args) > 0) 
[09:31:19.038]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.038]             }
[09:31:19.038]             else {
[09:31:19.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.038]             }
[09:31:19.038]             {
[09:31:19.038]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.038]                   0L) {
[09:31:19.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.038]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.038]                   base::options(opts)
[09:31:19.038]                 }
[09:31:19.038]                 {
[09:31:19.038]                   {
[09:31:19.038]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.038]                     NULL
[09:31:19.038]                   }
[09:31:19.038]                   options(future.plan = NULL)
[09:31:19.038]                   if (is.na(NA_character_)) 
[09:31:19.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.038]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.038]                     .init = FALSE)
[09:31:19.038]                 }
[09:31:19.038]             }
[09:31:19.038]         }
[09:31:19.038]     })
[09:31:19.038]     if (TRUE) {
[09:31:19.038]         base::sink(type = "output", split = FALSE)
[09:31:19.038]         if (TRUE) {
[09:31:19.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.038]         }
[09:31:19.038]         else {
[09:31:19.038]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.038]         }
[09:31:19.038]         base::close(...future.stdout)
[09:31:19.038]         ...future.stdout <- NULL
[09:31:19.038]     }
[09:31:19.038]     ...future.result$conditions <- ...future.conditions
[09:31:19.038]     ...future.result$finished <- base::Sys.time()
[09:31:19.038]     ...future.result
[09:31:19.038] }
[09:31:19.040] assign_globals() ...
[09:31:19.040] List of 3
[09:31:19.040]  $ outer_function:function (x)  
[09:31:19.040]  $ map           :function (.x, .f, ...)  
[09:31:19.040]  $ inner_function:function (x)  
[09:31:19.040]  - attr(*, "where")=List of 3
[09:31:19.040]   ..$ outer_function:<environment: R_EmptyEnv> 
[09:31:19.040]   ..$ map           :<environment: R_EmptyEnv> 
[09:31:19.040]   ..$ inner_function:<environment: R_EmptyEnv> 
[09:31:19.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:19.040]  - attr(*, "resolved")= logi FALSE
[09:31:19.040]  - attr(*, "total_size")= num 7704
[09:31:19.040]  - attr(*, "already-done")= logi TRUE
[09:31:19.044] - reassign environment for ‘outer_function’
[09:31:19.044] - copied ‘outer_function’ to environment
[09:31:19.044] - reassign environment for ‘map’
[09:31:19.044] - copied ‘map’ to environment
[09:31:19.044] - reassign environment for ‘inner_function’
[09:31:19.044] - copied ‘inner_function’ to environment
[09:31:19.044] assign_globals() ... done
[09:31:19.045] requestCore(): workers = 2
[09:31:19.046] MulticoreFuture started
[09:31:19.047] - Launch lazy future ... done
[09:31:19.047] run() for ‘MulticoreFuture’ ... done
[09:31:19.047] plan(): Setting new future strategy stack:
[09:31:19.047] result() for MulticoreFuture ...
[09:31:19.048] List of future strategies:
[09:31:19.048] 1. sequential:
[09:31:19.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:19.048]    - tweaked: FALSE
[09:31:19.048]    - call: NULL
[09:31:19.049] plan(): nbrOfWorkers() = 1
[09:31:19.051] plan(): Setting new future strategy stack:
[09:31:19.051] List of future strategies:
[09:31:19.051] 1. multicore:
[09:31:19.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:19.051]    - tweaked: FALSE
[09:31:19.051]    - call: plan(strategy)
[09:31:19.056] plan(): nbrOfWorkers() = 2
[09:31:19.057] result() for MulticoreFuture ...
[09:31:19.057] result() for MulticoreFuture ... done
[09:31:19.057] result() for MulticoreFuture ... done
[09:31:19.057] result() for MulticoreFuture ...
[09:31:19.057] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[09:31:19.059] plan(): Setting new future strategy stack:
[09:31:19.059] List of future strategies:
[09:31:19.059] 1. multisession:
[09:31:19.059]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:19.059]    - tweaked: FALSE
[09:31:19.059]    - call: plan(strategy)
[09:31:19.060] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:19.060] multisession:
[09:31:19.060] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:19.060] - tweaked: FALSE
[09:31:19.060] - call: plan(strategy)
[09:31:19.067] getGlobalsAndPackages() ...
[09:31:19.067] Not searching for globals
[09:31:19.067] - globals: [0] <none>
[09:31:19.067] getGlobalsAndPackages() ... DONE
[09:31:19.068] [local output] makeClusterPSOCK() ...
[09:31:19.111] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:19.112] [local output] Base port: 11456
[09:31:19.113] [local output] Getting setup options for 2 cluster nodes ...
[09:31:19.113] [local output]  - Node 1 of 2 ...
[09:31:19.113] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:19.114] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpJD3Fwy/worker.rank=1.parallelly.parent=42756.a7042953af0c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpJD3Fwy/worker.rank=1.parallelly.parent=42756.a7042953af0c.pid")'’
[09:31:19.300] - Possible to infer worker's PID: TRUE
[09:31:19.301] [local output] Rscript port: 11456

[09:31:19.301] [local output]  - Node 2 of 2 ...
[09:31:19.301] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:19.302] [local output] Rscript port: 11456

[09:31:19.302] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:19.302] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:19.303] [local output] Setting up PSOCK nodes in parallel
[09:31:19.303] List of 36
[09:31:19.303]  $ worker          : chr "localhost"
[09:31:19.303]   ..- attr(*, "localhost")= logi TRUE
[09:31:19.303]  $ master          : chr "localhost"
[09:31:19.303]  $ port            : int 11456
[09:31:19.303]  $ connectTimeout  : num 120
[09:31:19.303]  $ timeout         : num 2592000
[09:31:19.303]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:19.303]  $ homogeneous     : logi TRUE
[09:31:19.303]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:19.303]  $ rscript_envs    : NULL
[09:31:19.303]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:19.303]  $ rscript_startup : NULL
[09:31:19.303]  $ rscript_sh      : chr "sh"
[09:31:19.303]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:19.303]  $ methods         : logi TRUE
[09:31:19.303]  $ socketOptions   : chr "no-delay"
[09:31:19.303]  $ useXDR          : logi FALSE
[09:31:19.303]  $ outfile         : chr "/dev/null"
[09:31:19.303]  $ renice          : int NA
[09:31:19.303]  $ rshcmd          : NULL
[09:31:19.303]  $ user            : chr(0) 
[09:31:19.303]  $ revtunnel       : logi FALSE
[09:31:19.303]  $ rshlogfile      : NULL
[09:31:19.303]  $ rshopts         : chr(0) 
[09:31:19.303]  $ rank            : int 1
[09:31:19.303]  $ manual          : logi FALSE
[09:31:19.303]  $ dryrun          : logi FALSE
[09:31:19.303]  $ quiet           : logi FALSE
[09:31:19.303]  $ setup_strategy  : chr "parallel"
[09:31:19.303]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:19.303]  $ pidfile         : chr "/tmp/RtmpJD3Fwy/worker.rank=1.parallelly.parent=42756.a7042953af0c.pid"
[09:31:19.303]  $ rshcmd_label    : NULL
[09:31:19.303]  $ rsh_call        : NULL
[09:31:19.303]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:19.303]  $ localMachine    : logi TRUE
[09:31:19.303]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:19.303]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:19.303]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:19.303]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:19.303]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:19.303]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:19.303]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:19.303]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:19.303]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:19.303]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:19.303]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:19.303]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:19.303]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:19.303]  $ arguments       :List of 28
[09:31:19.303]   ..$ worker          : chr "localhost"
[09:31:19.303]   ..$ master          : NULL
[09:31:19.303]   ..$ port            : int 11456
[09:31:19.303]   ..$ connectTimeout  : num 120
[09:31:19.303]   ..$ timeout         : num 2592000
[09:31:19.303]   ..$ rscript         : NULL
[09:31:19.303]   ..$ homogeneous     : NULL
[09:31:19.303]   ..$ rscript_args    : NULL
[09:31:19.303]   ..$ rscript_envs    : NULL
[09:31:19.303]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:19.303]   ..$ rscript_startup : NULL
[09:31:19.303]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:19.303]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:19.303]   ..$ methods         : logi TRUE
[09:31:19.303]   ..$ socketOptions   : chr "no-delay"
[09:31:19.303]   ..$ useXDR          : logi FALSE
[09:31:19.303]   ..$ outfile         : chr "/dev/null"
[09:31:19.303]   ..$ renice          : int NA
[09:31:19.303]   ..$ rshcmd          : NULL
[09:31:19.303]   ..$ user            : NULL
[09:31:19.303]   ..$ revtunnel       : logi NA
[09:31:19.303]   ..$ rshlogfile      : NULL
[09:31:19.303]   ..$ rshopts         : NULL
[09:31:19.303]   ..$ rank            : int 1
[09:31:19.303]   ..$ manual          : logi FALSE
[09:31:19.303]   ..$ dryrun          : logi FALSE
[09:31:19.303]   ..$ quiet           : logi FALSE
[09:31:19.303]   ..$ setup_strategy  : chr "parallel"
[09:31:19.303]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:19.319] [local output] System call to launch all workers:
[09:31:19.319] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpJD3Fwy/worker.rank=1.parallelly.parent=42756.a7042953af0c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11456 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:19.319] [local output] Starting PSOCK main server
[09:31:19.325] [local output] Workers launched
[09:31:19.325] [local output] Waiting for workers to connect back
[09:31:19.325]  - [local output] 0 workers out of 2 ready
[09:31:19.571]  - [local output] 0 workers out of 2 ready
[09:31:19.572]  - [local output] 1 workers out of 2 ready
[09:31:19.572]  - [local output] 2 workers out of 2 ready
[09:31:19.572] [local output] Launching of workers completed
[09:31:19.572] [local output] Collecting session information from workers
[09:31:19.573] [local output]  - Worker #1 of 2
[09:31:19.574] [local output]  - Worker #2 of 2
[09:31:19.574] [local output] makeClusterPSOCK() ... done
[09:31:19.585] Packages needed by the future expression (n = 0): <none>
[09:31:19.585] Packages needed by future strategies (n = 0): <none>
[09:31:19.586] {
[09:31:19.586]     {
[09:31:19.586]         {
[09:31:19.586]             ...future.startTime <- base::Sys.time()
[09:31:19.586]             {
[09:31:19.586]                 {
[09:31:19.586]                   {
[09:31:19.586]                     {
[09:31:19.586]                       base::local({
[09:31:19.586]                         has_future <- base::requireNamespace("future", 
[09:31:19.586]                           quietly = TRUE)
[09:31:19.586]                         if (has_future) {
[09:31:19.586]                           ns <- base::getNamespace("future")
[09:31:19.586]                           version <- ns[[".package"]][["version"]]
[09:31:19.586]                           if (is.null(version)) 
[09:31:19.586]                             version <- utils::packageVersion("future")
[09:31:19.586]                         }
[09:31:19.586]                         else {
[09:31:19.586]                           version <- NULL
[09:31:19.586]                         }
[09:31:19.586]                         if (!has_future || version < "1.8.0") {
[09:31:19.586]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.586]                             "", base::R.version$version.string), 
[09:31:19.586]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:19.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:19.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.586]                               "release", "version")], collapse = " "), 
[09:31:19.586]                             hostname = base::Sys.info()[["nodename"]])
[09:31:19.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.586]                             info)
[09:31:19.586]                           info <- base::paste(info, collapse = "; ")
[09:31:19.586]                           if (!has_future) {
[09:31:19.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.586]                               info)
[09:31:19.586]                           }
[09:31:19.586]                           else {
[09:31:19.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.586]                               info, version)
[09:31:19.586]                           }
[09:31:19.586]                           base::stop(msg)
[09:31:19.586]                         }
[09:31:19.586]                       })
[09:31:19.586]                     }
[09:31:19.586]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.586]                     base::options(mc.cores = 1L)
[09:31:19.586]                   }
[09:31:19.586]                   ...future.strategy.old <- future::plan("list")
[09:31:19.586]                   options(future.plan = NULL)
[09:31:19.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.586]                 }
[09:31:19.586]                 ...future.workdir <- getwd()
[09:31:19.586]             }
[09:31:19.586]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.586]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.586]         }
[09:31:19.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.586]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.586]             base::names(...future.oldOptions))
[09:31:19.586]     }
[09:31:19.586]     if (FALSE) {
[09:31:19.586]     }
[09:31:19.586]     else {
[09:31:19.586]         if (TRUE) {
[09:31:19.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.586]                 open = "w")
[09:31:19.586]         }
[09:31:19.586]         else {
[09:31:19.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.586]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.586]         }
[09:31:19.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.586]             base::sink(type = "output", split = FALSE)
[09:31:19.586]             base::close(...future.stdout)
[09:31:19.586]         }, add = TRUE)
[09:31:19.586]     }
[09:31:19.586]     ...future.frame <- base::sys.nframe()
[09:31:19.586]     ...future.conditions <- base::list()
[09:31:19.586]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.586]     if (FALSE) {
[09:31:19.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.586]     }
[09:31:19.586]     ...future.result <- base::tryCatch({
[09:31:19.586]         base::withCallingHandlers({
[09:31:19.586]             ...future.value <- base::withVisible(base::local({
[09:31:19.586]                 ...future.makeSendCondition <- base::local({
[09:31:19.586]                   sendCondition <- NULL
[09:31:19.586]                   function(frame = 1L) {
[09:31:19.586]                     if (is.function(sendCondition)) 
[09:31:19.586]                       return(sendCondition)
[09:31:19.586]                     ns <- getNamespace("parallel")
[09:31:19.586]                     if (exists("sendData", mode = "function", 
[09:31:19.586]                       envir = ns)) {
[09:31:19.586]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:19.586]                         envir = ns)
[09:31:19.586]                       envir <- sys.frame(frame)
[09:31:19.586]                       master <- NULL
[09:31:19.586]                       while (!identical(envir, .GlobalEnv) && 
[09:31:19.586]                         !identical(envir, emptyenv())) {
[09:31:19.586]                         if (exists("master", mode = "list", envir = envir, 
[09:31:19.586]                           inherits = FALSE)) {
[09:31:19.586]                           master <- get("master", mode = "list", 
[09:31:19.586]                             envir = envir, inherits = FALSE)
[09:31:19.586]                           if (inherits(master, c("SOCKnode", 
[09:31:19.586]                             "SOCK0node"))) {
[09:31:19.586]                             sendCondition <<- function(cond) {
[09:31:19.586]                               data <- list(type = "VALUE", value = cond, 
[09:31:19.586]                                 success = TRUE)
[09:31:19.586]                               parallel_sendData(master, data)
[09:31:19.586]                             }
[09:31:19.586]                             return(sendCondition)
[09:31:19.586]                           }
[09:31:19.586]                         }
[09:31:19.586]                         frame <- frame + 1L
[09:31:19.586]                         envir <- sys.frame(frame)
[09:31:19.586]                       }
[09:31:19.586]                     }
[09:31:19.586]                     sendCondition <<- function(cond) NULL
[09:31:19.586]                   }
[09:31:19.586]                 })
[09:31:19.586]                 withCallingHandlers({
[09:31:19.586]                   NA
[09:31:19.586]                 }, immediateCondition = function(cond) {
[09:31:19.586]                   sendCondition <- ...future.makeSendCondition()
[09:31:19.586]                   sendCondition(cond)
[09:31:19.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.586]                   {
[09:31:19.586]                     inherits <- base::inherits
[09:31:19.586]                     invokeRestart <- base::invokeRestart
[09:31:19.586]                     is.null <- base::is.null
[09:31:19.586]                     muffled <- FALSE
[09:31:19.586]                     if (inherits(cond, "message")) {
[09:31:19.586]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.586]                       if (muffled) 
[09:31:19.586]                         invokeRestart("muffleMessage")
[09:31:19.586]                     }
[09:31:19.586]                     else if (inherits(cond, "warning")) {
[09:31:19.586]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.586]                       if (muffled) 
[09:31:19.586]                         invokeRestart("muffleWarning")
[09:31:19.586]                     }
[09:31:19.586]                     else if (inherits(cond, "condition")) {
[09:31:19.586]                       if (!is.null(pattern)) {
[09:31:19.586]                         computeRestarts <- base::computeRestarts
[09:31:19.586]                         grepl <- base::grepl
[09:31:19.586]                         restarts <- computeRestarts(cond)
[09:31:19.586]                         for (restart in restarts) {
[09:31:19.586]                           name <- restart$name
[09:31:19.586]                           if (is.null(name)) 
[09:31:19.586]                             next
[09:31:19.586]                           if (!grepl(pattern, name)) 
[09:31:19.586]                             next
[09:31:19.586]                           invokeRestart(restart)
[09:31:19.586]                           muffled <- TRUE
[09:31:19.586]                           break
[09:31:19.586]                         }
[09:31:19.586]                       }
[09:31:19.586]                     }
[09:31:19.586]                     invisible(muffled)
[09:31:19.586]                   }
[09:31:19.586]                   muffleCondition(cond)
[09:31:19.586]                 })
[09:31:19.586]             }))
[09:31:19.586]             future::FutureResult(value = ...future.value$value, 
[09:31:19.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.586]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.586]                     ...future.globalenv.names))
[09:31:19.586]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.586]         }, condition = base::local({
[09:31:19.586]             c <- base::c
[09:31:19.586]             inherits <- base::inherits
[09:31:19.586]             invokeRestart <- base::invokeRestart
[09:31:19.586]             length <- base::length
[09:31:19.586]             list <- base::list
[09:31:19.586]             seq.int <- base::seq.int
[09:31:19.586]             signalCondition <- base::signalCondition
[09:31:19.586]             sys.calls <- base::sys.calls
[09:31:19.586]             `[[` <- base::`[[`
[09:31:19.586]             `+` <- base::`+`
[09:31:19.586]             `<<-` <- base::`<<-`
[09:31:19.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.586]                   3L)]
[09:31:19.586]             }
[09:31:19.586]             function(cond) {
[09:31:19.586]                 is_error <- inherits(cond, "error")
[09:31:19.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.586]                   NULL)
[09:31:19.586]                 if (is_error) {
[09:31:19.586]                   sessionInformation <- function() {
[09:31:19.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.586]                       search = base::search(), system = base::Sys.info())
[09:31:19.586]                   }
[09:31:19.586]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.586]                     cond$call), session = sessionInformation(), 
[09:31:19.586]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.586]                   signalCondition(cond)
[09:31:19.586]                 }
[09:31:19.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.586]                 "immediateCondition"))) {
[09:31:19.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.586]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.586]                   if (TRUE && !signal) {
[09:31:19.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.586]                     {
[09:31:19.586]                       inherits <- base::inherits
[09:31:19.586]                       invokeRestart <- base::invokeRestart
[09:31:19.586]                       is.null <- base::is.null
[09:31:19.586]                       muffled <- FALSE
[09:31:19.586]                       if (inherits(cond, "message")) {
[09:31:19.586]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.586]                         if (muffled) 
[09:31:19.586]                           invokeRestart("muffleMessage")
[09:31:19.586]                       }
[09:31:19.586]                       else if (inherits(cond, "warning")) {
[09:31:19.586]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.586]                         if (muffled) 
[09:31:19.586]                           invokeRestart("muffleWarning")
[09:31:19.586]                       }
[09:31:19.586]                       else if (inherits(cond, "condition")) {
[09:31:19.586]                         if (!is.null(pattern)) {
[09:31:19.586]                           computeRestarts <- base::computeRestarts
[09:31:19.586]                           grepl <- base::grepl
[09:31:19.586]                           restarts <- computeRestarts(cond)
[09:31:19.586]                           for (restart in restarts) {
[09:31:19.586]                             name <- restart$name
[09:31:19.586]                             if (is.null(name)) 
[09:31:19.586]                               next
[09:31:19.586]                             if (!grepl(pattern, name)) 
[09:31:19.586]                               next
[09:31:19.586]                             invokeRestart(restart)
[09:31:19.586]                             muffled <- TRUE
[09:31:19.586]                             break
[09:31:19.586]                           }
[09:31:19.586]                         }
[09:31:19.586]                       }
[09:31:19.586]                       invisible(muffled)
[09:31:19.586]                     }
[09:31:19.586]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.586]                   }
[09:31:19.586]                 }
[09:31:19.586]                 else {
[09:31:19.586]                   if (TRUE) {
[09:31:19.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.586]                     {
[09:31:19.586]                       inherits <- base::inherits
[09:31:19.586]                       invokeRestart <- base::invokeRestart
[09:31:19.586]                       is.null <- base::is.null
[09:31:19.586]                       muffled <- FALSE
[09:31:19.586]                       if (inherits(cond, "message")) {
[09:31:19.586]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.586]                         if (muffled) 
[09:31:19.586]                           invokeRestart("muffleMessage")
[09:31:19.586]                       }
[09:31:19.586]                       else if (inherits(cond, "warning")) {
[09:31:19.586]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.586]                         if (muffled) 
[09:31:19.586]                           invokeRestart("muffleWarning")
[09:31:19.586]                       }
[09:31:19.586]                       else if (inherits(cond, "condition")) {
[09:31:19.586]                         if (!is.null(pattern)) {
[09:31:19.586]                           computeRestarts <- base::computeRestarts
[09:31:19.586]                           grepl <- base::grepl
[09:31:19.586]                           restarts <- computeRestarts(cond)
[09:31:19.586]                           for (restart in restarts) {
[09:31:19.586]                             name <- restart$name
[09:31:19.586]                             if (is.null(name)) 
[09:31:19.586]                               next
[09:31:19.586]                             if (!grepl(pattern, name)) 
[09:31:19.586]                               next
[09:31:19.586]                             invokeRestart(restart)
[09:31:19.586]                             muffled <- TRUE
[09:31:19.586]                             break
[09:31:19.586]                           }
[09:31:19.586]                         }
[09:31:19.586]                       }
[09:31:19.586]                       invisible(muffled)
[09:31:19.586]                     }
[09:31:19.586]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.586]                   }
[09:31:19.586]                 }
[09:31:19.586]             }
[09:31:19.586]         }))
[09:31:19.586]     }, error = function(ex) {
[09:31:19.586]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.586]                 ...future.rng), started = ...future.startTime, 
[09:31:19.586]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.586]             version = "1.8"), class = "FutureResult")
[09:31:19.586]     }, finally = {
[09:31:19.586]         if (!identical(...future.workdir, getwd())) 
[09:31:19.586]             setwd(...future.workdir)
[09:31:19.586]         {
[09:31:19.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.586]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.586]             }
[09:31:19.586]             base::options(...future.oldOptions)
[09:31:19.586]             if (.Platform$OS.type == "windows") {
[09:31:19.586]                 old_names <- names(...future.oldEnvVars)
[09:31:19.586]                 envs <- base::Sys.getenv()
[09:31:19.586]                 names <- names(envs)
[09:31:19.586]                 common <- intersect(names, old_names)
[09:31:19.586]                 added <- setdiff(names, old_names)
[09:31:19.586]                 removed <- setdiff(old_names, names)
[09:31:19.586]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.586]                   envs[common]]
[09:31:19.586]                 NAMES <- toupper(changed)
[09:31:19.586]                 args <- list()
[09:31:19.586]                 for (kk in seq_along(NAMES)) {
[09:31:19.586]                   name <- changed[[kk]]
[09:31:19.586]                   NAME <- NAMES[[kk]]
[09:31:19.586]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.586]                     next
[09:31:19.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.586]                 }
[09:31:19.586]                 NAMES <- toupper(added)
[09:31:19.586]                 for (kk in seq_along(NAMES)) {
[09:31:19.586]                   name <- added[[kk]]
[09:31:19.586]                   NAME <- NAMES[[kk]]
[09:31:19.586]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.586]                     next
[09:31:19.586]                   args[[name]] <- ""
[09:31:19.586]                 }
[09:31:19.586]                 NAMES <- toupper(removed)
[09:31:19.586]                 for (kk in seq_along(NAMES)) {
[09:31:19.586]                   name <- removed[[kk]]
[09:31:19.586]                   NAME <- NAMES[[kk]]
[09:31:19.586]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.586]                     next
[09:31:19.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.586]                 }
[09:31:19.586]                 if (length(args) > 0) 
[09:31:19.586]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.586]             }
[09:31:19.586]             else {
[09:31:19.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.586]             }
[09:31:19.586]             {
[09:31:19.586]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.586]                   0L) {
[09:31:19.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.586]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.586]                   base::options(opts)
[09:31:19.586]                 }
[09:31:19.586]                 {
[09:31:19.586]                   {
[09:31:19.586]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.586]                     NULL
[09:31:19.586]                   }
[09:31:19.586]                   options(future.plan = NULL)
[09:31:19.586]                   if (is.na(NA_character_)) 
[09:31:19.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.586]                     .init = FALSE)
[09:31:19.586]                 }
[09:31:19.586]             }
[09:31:19.586]         }
[09:31:19.586]     })
[09:31:19.586]     if (TRUE) {
[09:31:19.586]         base::sink(type = "output", split = FALSE)
[09:31:19.586]         if (TRUE) {
[09:31:19.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.586]         }
[09:31:19.586]         else {
[09:31:19.586]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.586]         }
[09:31:19.586]         base::close(...future.stdout)
[09:31:19.586]         ...future.stdout <- NULL
[09:31:19.586]     }
[09:31:19.586]     ...future.result$conditions <- ...future.conditions
[09:31:19.586]     ...future.result$finished <- base::Sys.time()
[09:31:19.586]     ...future.result
[09:31:19.586] }
[09:31:19.636] MultisessionFuture started
[09:31:19.636] result() for ClusterFuture ...
[09:31:19.637] receiveMessageFromWorker() for ClusterFuture ...
[09:31:19.637] - Validating connection of MultisessionFuture
[09:31:19.668] - received message: FutureResult
[09:31:19.668] - Received FutureResult
[09:31:19.668] - Erased future from FutureRegistry
[09:31:19.669] result() for ClusterFuture ...
[09:31:19.669] - result already collected: FutureResult
[09:31:19.669] result() for ClusterFuture ... done
[09:31:19.669] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:19.669] result() for ClusterFuture ... done
[09:31:19.669] result() for ClusterFuture ...
[09:31:19.669] - result already collected: FutureResult
[09:31:19.669] result() for ClusterFuture ... done
[09:31:19.670] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:19.673] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[09:31:19.674] getGlobalsAndPackages() ...
[09:31:19.674] Searching for globals...
[09:31:19.676] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:19.676] Searching for globals ... DONE
[09:31:19.676] Resolving globals: FALSE
[09:31:19.677] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:19.677] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:19.677] - globals: [2] ‘weight’, ‘group’
[09:31:19.677] - packages: [1] ‘stats’
[09:31:19.677] getGlobalsAndPackages() ... DONE
[09:31:19.678] run() for ‘Future’ ...
[09:31:19.678] - state: ‘created’
[09:31:19.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:19.692] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:19.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:19.692]   - Field: ‘node’
[09:31:19.693]   - Field: ‘label’
[09:31:19.693]   - Field: ‘local’
[09:31:19.693]   - Field: ‘owner’
[09:31:19.693]   - Field: ‘envir’
[09:31:19.693]   - Field: ‘workers’
[09:31:19.693]   - Field: ‘packages’
[09:31:19.693]   - Field: ‘gc’
[09:31:19.693]   - Field: ‘conditions’
[09:31:19.693]   - Field: ‘persistent’
[09:31:19.694]   - Field: ‘expr’
[09:31:19.694]   - Field: ‘uuid’
[09:31:19.694]   - Field: ‘seed’
[09:31:19.694]   - Field: ‘version’
[09:31:19.694]   - Field: ‘result’
[09:31:19.694]   - Field: ‘asynchronous’
[09:31:19.694]   - Field: ‘calls’
[09:31:19.694]   - Field: ‘globals’
[09:31:19.694]   - Field: ‘stdout’
[09:31:19.695]   - Field: ‘earlySignal’
[09:31:19.695]   - Field: ‘lazy’
[09:31:19.695]   - Field: ‘state’
[09:31:19.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:19.695] - Launch lazy future ...
[09:31:19.695] Packages needed by the future expression (n = 1): ‘stats’
[09:31:19.695] Packages needed by future strategies (n = 0): <none>
[09:31:19.696] {
[09:31:19.696]     {
[09:31:19.696]         {
[09:31:19.696]             ...future.startTime <- base::Sys.time()
[09:31:19.696]             {
[09:31:19.696]                 {
[09:31:19.696]                   {
[09:31:19.696]                     {
[09:31:19.696]                       {
[09:31:19.696]                         base::local({
[09:31:19.696]                           has_future <- base::requireNamespace("future", 
[09:31:19.696]                             quietly = TRUE)
[09:31:19.696]                           if (has_future) {
[09:31:19.696]                             ns <- base::getNamespace("future")
[09:31:19.696]                             version <- ns[[".package"]][["version"]]
[09:31:19.696]                             if (is.null(version)) 
[09:31:19.696]                               version <- utils::packageVersion("future")
[09:31:19.696]                           }
[09:31:19.696]                           else {
[09:31:19.696]                             version <- NULL
[09:31:19.696]                           }
[09:31:19.696]                           if (!has_future || version < "1.8.0") {
[09:31:19.696]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.696]                               "", base::R.version$version.string), 
[09:31:19.696]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:19.696]                                 base::R.version$platform, 8 * 
[09:31:19.696]                                   base::.Machine$sizeof.pointer), 
[09:31:19.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.696]                                 "release", "version")], collapse = " "), 
[09:31:19.696]                               hostname = base::Sys.info()[["nodename"]])
[09:31:19.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.696]                               info)
[09:31:19.696]                             info <- base::paste(info, collapse = "; ")
[09:31:19.696]                             if (!has_future) {
[09:31:19.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.696]                                 info)
[09:31:19.696]                             }
[09:31:19.696]                             else {
[09:31:19.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.696]                                 info, version)
[09:31:19.696]                             }
[09:31:19.696]                             base::stop(msg)
[09:31:19.696]                           }
[09:31:19.696]                         })
[09:31:19.696]                       }
[09:31:19.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.696]                       base::options(mc.cores = 1L)
[09:31:19.696]                     }
[09:31:19.696]                     base::local({
[09:31:19.696]                       for (pkg in "stats") {
[09:31:19.696]                         base::loadNamespace(pkg)
[09:31:19.696]                         base::library(pkg, character.only = TRUE)
[09:31:19.696]                       }
[09:31:19.696]                     })
[09:31:19.696]                   }
[09:31:19.696]                   ...future.strategy.old <- future::plan("list")
[09:31:19.696]                   options(future.plan = NULL)
[09:31:19.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.696]                 }
[09:31:19.696]                 ...future.workdir <- getwd()
[09:31:19.696]             }
[09:31:19.696]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.696]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.696]         }
[09:31:19.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.696]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.696]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.696]             base::names(...future.oldOptions))
[09:31:19.696]     }
[09:31:19.696]     if (FALSE) {
[09:31:19.696]     }
[09:31:19.696]     else {
[09:31:19.696]         if (TRUE) {
[09:31:19.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.696]                 open = "w")
[09:31:19.696]         }
[09:31:19.696]         else {
[09:31:19.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.696]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.696]         }
[09:31:19.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.696]             base::sink(type = "output", split = FALSE)
[09:31:19.696]             base::close(...future.stdout)
[09:31:19.696]         }, add = TRUE)
[09:31:19.696]     }
[09:31:19.696]     ...future.frame <- base::sys.nframe()
[09:31:19.696]     ...future.conditions <- base::list()
[09:31:19.696]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.696]     if (FALSE) {
[09:31:19.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.696]     }
[09:31:19.696]     ...future.result <- base::tryCatch({
[09:31:19.696]         base::withCallingHandlers({
[09:31:19.696]             ...future.value <- base::withVisible(base::local({
[09:31:19.696]                 ...future.makeSendCondition <- base::local({
[09:31:19.696]                   sendCondition <- NULL
[09:31:19.696]                   function(frame = 1L) {
[09:31:19.696]                     if (is.function(sendCondition)) 
[09:31:19.696]                       return(sendCondition)
[09:31:19.696]                     ns <- getNamespace("parallel")
[09:31:19.696]                     if (exists("sendData", mode = "function", 
[09:31:19.696]                       envir = ns)) {
[09:31:19.696]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:19.696]                         envir = ns)
[09:31:19.696]                       envir <- sys.frame(frame)
[09:31:19.696]                       master <- NULL
[09:31:19.696]                       while (!identical(envir, .GlobalEnv) && 
[09:31:19.696]                         !identical(envir, emptyenv())) {
[09:31:19.696]                         if (exists("master", mode = "list", envir = envir, 
[09:31:19.696]                           inherits = FALSE)) {
[09:31:19.696]                           master <- get("master", mode = "list", 
[09:31:19.696]                             envir = envir, inherits = FALSE)
[09:31:19.696]                           if (inherits(master, c("SOCKnode", 
[09:31:19.696]                             "SOCK0node"))) {
[09:31:19.696]                             sendCondition <<- function(cond) {
[09:31:19.696]                               data <- list(type = "VALUE", value = cond, 
[09:31:19.696]                                 success = TRUE)
[09:31:19.696]                               parallel_sendData(master, data)
[09:31:19.696]                             }
[09:31:19.696]                             return(sendCondition)
[09:31:19.696]                           }
[09:31:19.696]                         }
[09:31:19.696]                         frame <- frame + 1L
[09:31:19.696]                         envir <- sys.frame(frame)
[09:31:19.696]                       }
[09:31:19.696]                     }
[09:31:19.696]                     sendCondition <<- function(cond) NULL
[09:31:19.696]                   }
[09:31:19.696]                 })
[09:31:19.696]                 withCallingHandlers({
[09:31:19.696]                   {
[09:31:19.696]                     lm(weight ~ group - 1)
[09:31:19.696]                   }
[09:31:19.696]                 }, immediateCondition = function(cond) {
[09:31:19.696]                   sendCondition <- ...future.makeSendCondition()
[09:31:19.696]                   sendCondition(cond)
[09:31:19.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.696]                   {
[09:31:19.696]                     inherits <- base::inherits
[09:31:19.696]                     invokeRestart <- base::invokeRestart
[09:31:19.696]                     is.null <- base::is.null
[09:31:19.696]                     muffled <- FALSE
[09:31:19.696]                     if (inherits(cond, "message")) {
[09:31:19.696]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.696]                       if (muffled) 
[09:31:19.696]                         invokeRestart("muffleMessage")
[09:31:19.696]                     }
[09:31:19.696]                     else if (inherits(cond, "warning")) {
[09:31:19.696]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.696]                       if (muffled) 
[09:31:19.696]                         invokeRestart("muffleWarning")
[09:31:19.696]                     }
[09:31:19.696]                     else if (inherits(cond, "condition")) {
[09:31:19.696]                       if (!is.null(pattern)) {
[09:31:19.696]                         computeRestarts <- base::computeRestarts
[09:31:19.696]                         grepl <- base::grepl
[09:31:19.696]                         restarts <- computeRestarts(cond)
[09:31:19.696]                         for (restart in restarts) {
[09:31:19.696]                           name <- restart$name
[09:31:19.696]                           if (is.null(name)) 
[09:31:19.696]                             next
[09:31:19.696]                           if (!grepl(pattern, name)) 
[09:31:19.696]                             next
[09:31:19.696]                           invokeRestart(restart)
[09:31:19.696]                           muffled <- TRUE
[09:31:19.696]                           break
[09:31:19.696]                         }
[09:31:19.696]                       }
[09:31:19.696]                     }
[09:31:19.696]                     invisible(muffled)
[09:31:19.696]                   }
[09:31:19.696]                   muffleCondition(cond)
[09:31:19.696]                 })
[09:31:19.696]             }))
[09:31:19.696]             future::FutureResult(value = ...future.value$value, 
[09:31:19.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.696]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.696]                     ...future.globalenv.names))
[09:31:19.696]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.696]         }, condition = base::local({
[09:31:19.696]             c <- base::c
[09:31:19.696]             inherits <- base::inherits
[09:31:19.696]             invokeRestart <- base::invokeRestart
[09:31:19.696]             length <- base::length
[09:31:19.696]             list <- base::list
[09:31:19.696]             seq.int <- base::seq.int
[09:31:19.696]             signalCondition <- base::signalCondition
[09:31:19.696]             sys.calls <- base::sys.calls
[09:31:19.696]             `[[` <- base::`[[`
[09:31:19.696]             `+` <- base::`+`
[09:31:19.696]             `<<-` <- base::`<<-`
[09:31:19.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.696]                   3L)]
[09:31:19.696]             }
[09:31:19.696]             function(cond) {
[09:31:19.696]                 is_error <- inherits(cond, "error")
[09:31:19.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.696]                   NULL)
[09:31:19.696]                 if (is_error) {
[09:31:19.696]                   sessionInformation <- function() {
[09:31:19.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.696]                       search = base::search(), system = base::Sys.info())
[09:31:19.696]                   }
[09:31:19.696]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.696]                     cond$call), session = sessionInformation(), 
[09:31:19.696]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.696]                   signalCondition(cond)
[09:31:19.696]                 }
[09:31:19.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.696]                 "immediateCondition"))) {
[09:31:19.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.696]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.696]                   if (TRUE && !signal) {
[09:31:19.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.696]                     {
[09:31:19.696]                       inherits <- base::inherits
[09:31:19.696]                       invokeRestart <- base::invokeRestart
[09:31:19.696]                       is.null <- base::is.null
[09:31:19.696]                       muffled <- FALSE
[09:31:19.696]                       if (inherits(cond, "message")) {
[09:31:19.696]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.696]                         if (muffled) 
[09:31:19.696]                           invokeRestart("muffleMessage")
[09:31:19.696]                       }
[09:31:19.696]                       else if (inherits(cond, "warning")) {
[09:31:19.696]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.696]                         if (muffled) 
[09:31:19.696]                           invokeRestart("muffleWarning")
[09:31:19.696]                       }
[09:31:19.696]                       else if (inherits(cond, "condition")) {
[09:31:19.696]                         if (!is.null(pattern)) {
[09:31:19.696]                           computeRestarts <- base::computeRestarts
[09:31:19.696]                           grepl <- base::grepl
[09:31:19.696]                           restarts <- computeRestarts(cond)
[09:31:19.696]                           for (restart in restarts) {
[09:31:19.696]                             name <- restart$name
[09:31:19.696]                             if (is.null(name)) 
[09:31:19.696]                               next
[09:31:19.696]                             if (!grepl(pattern, name)) 
[09:31:19.696]                               next
[09:31:19.696]                             invokeRestart(restart)
[09:31:19.696]                             muffled <- TRUE
[09:31:19.696]                             break
[09:31:19.696]                           }
[09:31:19.696]                         }
[09:31:19.696]                       }
[09:31:19.696]                       invisible(muffled)
[09:31:19.696]                     }
[09:31:19.696]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.696]                   }
[09:31:19.696]                 }
[09:31:19.696]                 else {
[09:31:19.696]                   if (TRUE) {
[09:31:19.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.696]                     {
[09:31:19.696]                       inherits <- base::inherits
[09:31:19.696]                       invokeRestart <- base::invokeRestart
[09:31:19.696]                       is.null <- base::is.null
[09:31:19.696]                       muffled <- FALSE
[09:31:19.696]                       if (inherits(cond, "message")) {
[09:31:19.696]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.696]                         if (muffled) 
[09:31:19.696]                           invokeRestart("muffleMessage")
[09:31:19.696]                       }
[09:31:19.696]                       else if (inherits(cond, "warning")) {
[09:31:19.696]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.696]                         if (muffled) 
[09:31:19.696]                           invokeRestart("muffleWarning")
[09:31:19.696]                       }
[09:31:19.696]                       else if (inherits(cond, "condition")) {
[09:31:19.696]                         if (!is.null(pattern)) {
[09:31:19.696]                           computeRestarts <- base::computeRestarts
[09:31:19.696]                           grepl <- base::grepl
[09:31:19.696]                           restarts <- computeRestarts(cond)
[09:31:19.696]                           for (restart in restarts) {
[09:31:19.696]                             name <- restart$name
[09:31:19.696]                             if (is.null(name)) 
[09:31:19.696]                               next
[09:31:19.696]                             if (!grepl(pattern, name)) 
[09:31:19.696]                               next
[09:31:19.696]                             invokeRestart(restart)
[09:31:19.696]                             muffled <- TRUE
[09:31:19.696]                             break
[09:31:19.696]                           }
[09:31:19.696]                         }
[09:31:19.696]                       }
[09:31:19.696]                       invisible(muffled)
[09:31:19.696]                     }
[09:31:19.696]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.696]                   }
[09:31:19.696]                 }
[09:31:19.696]             }
[09:31:19.696]         }))
[09:31:19.696]     }, error = function(ex) {
[09:31:19.696]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.696]                 ...future.rng), started = ...future.startTime, 
[09:31:19.696]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.696]             version = "1.8"), class = "FutureResult")
[09:31:19.696]     }, finally = {
[09:31:19.696]         if (!identical(...future.workdir, getwd())) 
[09:31:19.696]             setwd(...future.workdir)
[09:31:19.696]         {
[09:31:19.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.696]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.696]             }
[09:31:19.696]             base::options(...future.oldOptions)
[09:31:19.696]             if (.Platform$OS.type == "windows") {
[09:31:19.696]                 old_names <- names(...future.oldEnvVars)
[09:31:19.696]                 envs <- base::Sys.getenv()
[09:31:19.696]                 names <- names(envs)
[09:31:19.696]                 common <- intersect(names, old_names)
[09:31:19.696]                 added <- setdiff(names, old_names)
[09:31:19.696]                 removed <- setdiff(old_names, names)
[09:31:19.696]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.696]                   envs[common]]
[09:31:19.696]                 NAMES <- toupper(changed)
[09:31:19.696]                 args <- list()
[09:31:19.696]                 for (kk in seq_along(NAMES)) {
[09:31:19.696]                   name <- changed[[kk]]
[09:31:19.696]                   NAME <- NAMES[[kk]]
[09:31:19.696]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.696]                     next
[09:31:19.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.696]                 }
[09:31:19.696]                 NAMES <- toupper(added)
[09:31:19.696]                 for (kk in seq_along(NAMES)) {
[09:31:19.696]                   name <- added[[kk]]
[09:31:19.696]                   NAME <- NAMES[[kk]]
[09:31:19.696]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.696]                     next
[09:31:19.696]                   args[[name]] <- ""
[09:31:19.696]                 }
[09:31:19.696]                 NAMES <- toupper(removed)
[09:31:19.696]                 for (kk in seq_along(NAMES)) {
[09:31:19.696]                   name <- removed[[kk]]
[09:31:19.696]                   NAME <- NAMES[[kk]]
[09:31:19.696]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.696]                     next
[09:31:19.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.696]                 }
[09:31:19.696]                 if (length(args) > 0) 
[09:31:19.696]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.696]             }
[09:31:19.696]             else {
[09:31:19.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.696]             }
[09:31:19.696]             {
[09:31:19.696]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.696]                   0L) {
[09:31:19.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.696]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.696]                   base::options(opts)
[09:31:19.696]                 }
[09:31:19.696]                 {
[09:31:19.696]                   {
[09:31:19.696]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.696]                     NULL
[09:31:19.696]                   }
[09:31:19.696]                   options(future.plan = NULL)
[09:31:19.696]                   if (is.na(NA_character_)) 
[09:31:19.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.696]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.696]                     .init = FALSE)
[09:31:19.696]                 }
[09:31:19.696]             }
[09:31:19.696]         }
[09:31:19.696]     })
[09:31:19.696]     if (TRUE) {
[09:31:19.696]         base::sink(type = "output", split = FALSE)
[09:31:19.696]         if (TRUE) {
[09:31:19.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.696]         }
[09:31:19.696]         else {
[09:31:19.696]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.696]         }
[09:31:19.696]         base::close(...future.stdout)
[09:31:19.696]         ...future.stdout <- NULL
[09:31:19.696]     }
[09:31:19.696]     ...future.result$conditions <- ...future.conditions
[09:31:19.696]     ...future.result$finished <- base::Sys.time()
[09:31:19.696]     ...future.result
[09:31:19.696] }
[09:31:19.699] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[09:31:19.699] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[09:31:19.700] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[09:31:19.700] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[09:31:19.700] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[09:31:19.700] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[09:31:19.701] MultisessionFuture started
[09:31:19.701] - Launch lazy future ... done
[09:31:19.701] run() for ‘MultisessionFuture’ ... done
[09:31:19.702] result() for ClusterFuture ...
[09:31:19.702] receiveMessageFromWorker() for ClusterFuture ...
[09:31:19.702] - Validating connection of MultisessionFuture
[09:31:19.752] - received message: FutureResult
[09:31:19.752] - Received FutureResult
[09:31:19.753] - Erased future from FutureRegistry
[09:31:19.753] result() for ClusterFuture ...
[09:31:19.753] - result already collected: FutureResult
[09:31:19.753] result() for ClusterFuture ... done
[09:31:19.753] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:19.753] result() for ClusterFuture ... done
[09:31:19.753] result() for ClusterFuture ...
[09:31:19.753] - result already collected: FutureResult
[09:31:19.754] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:19.756] getGlobalsAndPackages() ...
[09:31:19.756] Searching for globals...
[09:31:19.758] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:19.758] Searching for globals ... DONE
[09:31:19.758] Resolving globals: FALSE
[09:31:19.759] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:19.759] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:19.759] - globals: [2] ‘weight’, ‘group’
[09:31:19.759] - packages: [1] ‘stats’
[09:31:19.759] getGlobalsAndPackages() ... DONE
[09:31:19.760] run() for ‘Future’ ...
[09:31:19.760] - state: ‘created’
[09:31:19.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:19.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:19.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:19.775]   - Field: ‘node’
[09:31:19.775]   - Field: ‘label’
[09:31:19.775]   - Field: ‘local’
[09:31:19.775]   - Field: ‘owner’
[09:31:19.775]   - Field: ‘envir’
[09:31:19.775]   - Field: ‘workers’
[09:31:19.775]   - Field: ‘packages’
[09:31:19.776]   - Field: ‘gc’
[09:31:19.776]   - Field: ‘conditions’
[09:31:19.776]   - Field: ‘persistent’
[09:31:19.776]   - Field: ‘expr’
[09:31:19.776]   - Field: ‘uuid’
[09:31:19.776]   - Field: ‘seed’
[09:31:19.776]   - Field: ‘version’
[09:31:19.776]   - Field: ‘result’
[09:31:19.777]   - Field: ‘asynchronous’
[09:31:19.777]   - Field: ‘calls’
[09:31:19.777]   - Field: ‘globals’
[09:31:19.777]   - Field: ‘stdout’
[09:31:19.777]   - Field: ‘earlySignal’
[09:31:19.777]   - Field: ‘lazy’
[09:31:19.777]   - Field: ‘state’
[09:31:19.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:19.777] - Launch lazy future ...
[09:31:19.778] Packages needed by the future expression (n = 1): ‘stats’
[09:31:19.778] Packages needed by future strategies (n = 0): <none>
[09:31:19.779] {
[09:31:19.779]     {
[09:31:19.779]         {
[09:31:19.779]             ...future.startTime <- base::Sys.time()
[09:31:19.779]             {
[09:31:19.779]                 {
[09:31:19.779]                   {
[09:31:19.779]                     {
[09:31:19.779]                       {
[09:31:19.779]                         base::local({
[09:31:19.779]                           has_future <- base::requireNamespace("future", 
[09:31:19.779]                             quietly = TRUE)
[09:31:19.779]                           if (has_future) {
[09:31:19.779]                             ns <- base::getNamespace("future")
[09:31:19.779]                             version <- ns[[".package"]][["version"]]
[09:31:19.779]                             if (is.null(version)) 
[09:31:19.779]                               version <- utils::packageVersion("future")
[09:31:19.779]                           }
[09:31:19.779]                           else {
[09:31:19.779]                             version <- NULL
[09:31:19.779]                           }
[09:31:19.779]                           if (!has_future || version < "1.8.0") {
[09:31:19.779]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.779]                               "", base::R.version$version.string), 
[09:31:19.779]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:19.779]                                 base::R.version$platform, 8 * 
[09:31:19.779]                                   base::.Machine$sizeof.pointer), 
[09:31:19.779]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.779]                                 "release", "version")], collapse = " "), 
[09:31:19.779]                               hostname = base::Sys.info()[["nodename"]])
[09:31:19.779]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.779]                               info)
[09:31:19.779]                             info <- base::paste(info, collapse = "; ")
[09:31:19.779]                             if (!has_future) {
[09:31:19.779]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.779]                                 info)
[09:31:19.779]                             }
[09:31:19.779]                             else {
[09:31:19.779]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.779]                                 info, version)
[09:31:19.779]                             }
[09:31:19.779]                             base::stop(msg)
[09:31:19.779]                           }
[09:31:19.779]                         })
[09:31:19.779]                       }
[09:31:19.779]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.779]                       base::options(mc.cores = 1L)
[09:31:19.779]                     }
[09:31:19.779]                     base::local({
[09:31:19.779]                       for (pkg in "stats") {
[09:31:19.779]                         base::loadNamespace(pkg)
[09:31:19.779]                         base::library(pkg, character.only = TRUE)
[09:31:19.779]                       }
[09:31:19.779]                     })
[09:31:19.779]                   }
[09:31:19.779]                   ...future.strategy.old <- future::plan("list")
[09:31:19.779]                   options(future.plan = NULL)
[09:31:19.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.779]                 }
[09:31:19.779]                 ...future.workdir <- getwd()
[09:31:19.779]             }
[09:31:19.779]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.779]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.779]         }
[09:31:19.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.779]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.779]             base::names(...future.oldOptions))
[09:31:19.779]     }
[09:31:19.779]     if (FALSE) {
[09:31:19.779]     }
[09:31:19.779]     else {
[09:31:19.779]         if (TRUE) {
[09:31:19.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.779]                 open = "w")
[09:31:19.779]         }
[09:31:19.779]         else {
[09:31:19.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.779]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.779]         }
[09:31:19.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.779]             base::sink(type = "output", split = FALSE)
[09:31:19.779]             base::close(...future.stdout)
[09:31:19.779]         }, add = TRUE)
[09:31:19.779]     }
[09:31:19.779]     ...future.frame <- base::sys.nframe()
[09:31:19.779]     ...future.conditions <- base::list()
[09:31:19.779]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.779]     if (FALSE) {
[09:31:19.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.779]     }
[09:31:19.779]     ...future.result <- base::tryCatch({
[09:31:19.779]         base::withCallingHandlers({
[09:31:19.779]             ...future.value <- base::withVisible(base::local({
[09:31:19.779]                 ...future.makeSendCondition <- base::local({
[09:31:19.779]                   sendCondition <- NULL
[09:31:19.779]                   function(frame = 1L) {
[09:31:19.779]                     if (is.function(sendCondition)) 
[09:31:19.779]                       return(sendCondition)
[09:31:19.779]                     ns <- getNamespace("parallel")
[09:31:19.779]                     if (exists("sendData", mode = "function", 
[09:31:19.779]                       envir = ns)) {
[09:31:19.779]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:19.779]                         envir = ns)
[09:31:19.779]                       envir <- sys.frame(frame)
[09:31:19.779]                       master <- NULL
[09:31:19.779]                       while (!identical(envir, .GlobalEnv) && 
[09:31:19.779]                         !identical(envir, emptyenv())) {
[09:31:19.779]                         if (exists("master", mode = "list", envir = envir, 
[09:31:19.779]                           inherits = FALSE)) {
[09:31:19.779]                           master <- get("master", mode = "list", 
[09:31:19.779]                             envir = envir, inherits = FALSE)
[09:31:19.779]                           if (inherits(master, c("SOCKnode", 
[09:31:19.779]                             "SOCK0node"))) {
[09:31:19.779]                             sendCondition <<- function(cond) {
[09:31:19.779]                               data <- list(type = "VALUE", value = cond, 
[09:31:19.779]                                 success = TRUE)
[09:31:19.779]                               parallel_sendData(master, data)
[09:31:19.779]                             }
[09:31:19.779]                             return(sendCondition)
[09:31:19.779]                           }
[09:31:19.779]                         }
[09:31:19.779]                         frame <- frame + 1L
[09:31:19.779]                         envir <- sys.frame(frame)
[09:31:19.779]                       }
[09:31:19.779]                     }
[09:31:19.779]                     sendCondition <<- function(cond) NULL
[09:31:19.779]                   }
[09:31:19.779]                 })
[09:31:19.779]                 withCallingHandlers({
[09:31:19.779]                   {
[09:31:19.779]                     lm(weight ~ group - 1)
[09:31:19.779]                   }
[09:31:19.779]                 }, immediateCondition = function(cond) {
[09:31:19.779]                   sendCondition <- ...future.makeSendCondition()
[09:31:19.779]                   sendCondition(cond)
[09:31:19.779]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.779]                   {
[09:31:19.779]                     inherits <- base::inherits
[09:31:19.779]                     invokeRestart <- base::invokeRestart
[09:31:19.779]                     is.null <- base::is.null
[09:31:19.779]                     muffled <- FALSE
[09:31:19.779]                     if (inherits(cond, "message")) {
[09:31:19.779]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.779]                       if (muffled) 
[09:31:19.779]                         invokeRestart("muffleMessage")
[09:31:19.779]                     }
[09:31:19.779]                     else if (inherits(cond, "warning")) {
[09:31:19.779]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.779]                       if (muffled) 
[09:31:19.779]                         invokeRestart("muffleWarning")
[09:31:19.779]                     }
[09:31:19.779]                     else if (inherits(cond, "condition")) {
[09:31:19.779]                       if (!is.null(pattern)) {
[09:31:19.779]                         computeRestarts <- base::computeRestarts
[09:31:19.779]                         grepl <- base::grepl
[09:31:19.779]                         restarts <- computeRestarts(cond)
[09:31:19.779]                         for (restart in restarts) {
[09:31:19.779]                           name <- restart$name
[09:31:19.779]                           if (is.null(name)) 
[09:31:19.779]                             next
[09:31:19.779]                           if (!grepl(pattern, name)) 
[09:31:19.779]                             next
[09:31:19.779]                           invokeRestart(restart)
[09:31:19.779]                           muffled <- TRUE
[09:31:19.779]                           break
[09:31:19.779]                         }
[09:31:19.779]                       }
[09:31:19.779]                     }
[09:31:19.779]                     invisible(muffled)
[09:31:19.779]                   }
[09:31:19.779]                   muffleCondition(cond)
[09:31:19.779]                 })
[09:31:19.779]             }))
[09:31:19.779]             future::FutureResult(value = ...future.value$value, 
[09:31:19.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.779]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.779]                     ...future.globalenv.names))
[09:31:19.779]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.779]         }, condition = base::local({
[09:31:19.779]             c <- base::c
[09:31:19.779]             inherits <- base::inherits
[09:31:19.779]             invokeRestart <- base::invokeRestart
[09:31:19.779]             length <- base::length
[09:31:19.779]             list <- base::list
[09:31:19.779]             seq.int <- base::seq.int
[09:31:19.779]             signalCondition <- base::signalCondition
[09:31:19.779]             sys.calls <- base::sys.calls
[09:31:19.779]             `[[` <- base::`[[`
[09:31:19.779]             `+` <- base::`+`
[09:31:19.779]             `<<-` <- base::`<<-`
[09:31:19.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.779]                   3L)]
[09:31:19.779]             }
[09:31:19.779]             function(cond) {
[09:31:19.779]                 is_error <- inherits(cond, "error")
[09:31:19.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.779]                   NULL)
[09:31:19.779]                 if (is_error) {
[09:31:19.779]                   sessionInformation <- function() {
[09:31:19.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.779]                       search = base::search(), system = base::Sys.info())
[09:31:19.779]                   }
[09:31:19.779]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.779]                     cond$call), session = sessionInformation(), 
[09:31:19.779]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.779]                   signalCondition(cond)
[09:31:19.779]                 }
[09:31:19.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.779]                 "immediateCondition"))) {
[09:31:19.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.779]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.779]                   if (TRUE && !signal) {
[09:31:19.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.779]                     {
[09:31:19.779]                       inherits <- base::inherits
[09:31:19.779]                       invokeRestart <- base::invokeRestart
[09:31:19.779]                       is.null <- base::is.null
[09:31:19.779]                       muffled <- FALSE
[09:31:19.779]                       if (inherits(cond, "message")) {
[09:31:19.779]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.779]                         if (muffled) 
[09:31:19.779]                           invokeRestart("muffleMessage")
[09:31:19.779]                       }
[09:31:19.779]                       else if (inherits(cond, "warning")) {
[09:31:19.779]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.779]                         if (muffled) 
[09:31:19.779]                           invokeRestart("muffleWarning")
[09:31:19.779]                       }
[09:31:19.779]                       else if (inherits(cond, "condition")) {
[09:31:19.779]                         if (!is.null(pattern)) {
[09:31:19.779]                           computeRestarts <- base::computeRestarts
[09:31:19.779]                           grepl <- base::grepl
[09:31:19.779]                           restarts <- computeRestarts(cond)
[09:31:19.779]                           for (restart in restarts) {
[09:31:19.779]                             name <- restart$name
[09:31:19.779]                             if (is.null(name)) 
[09:31:19.779]                               next
[09:31:19.779]                             if (!grepl(pattern, name)) 
[09:31:19.779]                               next
[09:31:19.779]                             invokeRestart(restart)
[09:31:19.779]                             muffled <- TRUE
[09:31:19.779]                             break
[09:31:19.779]                           }
[09:31:19.779]                         }
[09:31:19.779]                       }
[09:31:19.779]                       invisible(muffled)
[09:31:19.779]                     }
[09:31:19.779]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.779]                   }
[09:31:19.779]                 }
[09:31:19.779]                 else {
[09:31:19.779]                   if (TRUE) {
[09:31:19.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.779]                     {
[09:31:19.779]                       inherits <- base::inherits
[09:31:19.779]                       invokeRestart <- base::invokeRestart
[09:31:19.779]                       is.null <- base::is.null
[09:31:19.779]                       muffled <- FALSE
[09:31:19.779]                       if (inherits(cond, "message")) {
[09:31:19.779]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.779]                         if (muffled) 
[09:31:19.779]                           invokeRestart("muffleMessage")
[09:31:19.779]                       }
[09:31:19.779]                       else if (inherits(cond, "warning")) {
[09:31:19.779]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.779]                         if (muffled) 
[09:31:19.779]                           invokeRestart("muffleWarning")
[09:31:19.779]                       }
[09:31:19.779]                       else if (inherits(cond, "condition")) {
[09:31:19.779]                         if (!is.null(pattern)) {
[09:31:19.779]                           computeRestarts <- base::computeRestarts
[09:31:19.779]                           grepl <- base::grepl
[09:31:19.779]                           restarts <- computeRestarts(cond)
[09:31:19.779]                           for (restart in restarts) {
[09:31:19.779]                             name <- restart$name
[09:31:19.779]                             if (is.null(name)) 
[09:31:19.779]                               next
[09:31:19.779]                             if (!grepl(pattern, name)) 
[09:31:19.779]                               next
[09:31:19.779]                             invokeRestart(restart)
[09:31:19.779]                             muffled <- TRUE
[09:31:19.779]                             break
[09:31:19.779]                           }
[09:31:19.779]                         }
[09:31:19.779]                       }
[09:31:19.779]                       invisible(muffled)
[09:31:19.779]                     }
[09:31:19.779]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.779]                   }
[09:31:19.779]                 }
[09:31:19.779]             }
[09:31:19.779]         }))
[09:31:19.779]     }, error = function(ex) {
[09:31:19.779]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.779]                 ...future.rng), started = ...future.startTime, 
[09:31:19.779]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.779]             version = "1.8"), class = "FutureResult")
[09:31:19.779]     }, finally = {
[09:31:19.779]         if (!identical(...future.workdir, getwd())) 
[09:31:19.779]             setwd(...future.workdir)
[09:31:19.779]         {
[09:31:19.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.779]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.779]             }
[09:31:19.779]             base::options(...future.oldOptions)
[09:31:19.779]             if (.Platform$OS.type == "windows") {
[09:31:19.779]                 old_names <- names(...future.oldEnvVars)
[09:31:19.779]                 envs <- base::Sys.getenv()
[09:31:19.779]                 names <- names(envs)
[09:31:19.779]                 common <- intersect(names, old_names)
[09:31:19.779]                 added <- setdiff(names, old_names)
[09:31:19.779]                 removed <- setdiff(old_names, names)
[09:31:19.779]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.779]                   envs[common]]
[09:31:19.779]                 NAMES <- toupper(changed)
[09:31:19.779]                 args <- list()
[09:31:19.779]                 for (kk in seq_along(NAMES)) {
[09:31:19.779]                   name <- changed[[kk]]
[09:31:19.779]                   NAME <- NAMES[[kk]]
[09:31:19.779]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.779]                     next
[09:31:19.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.779]                 }
[09:31:19.779]                 NAMES <- toupper(added)
[09:31:19.779]                 for (kk in seq_along(NAMES)) {
[09:31:19.779]                   name <- added[[kk]]
[09:31:19.779]                   NAME <- NAMES[[kk]]
[09:31:19.779]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.779]                     next
[09:31:19.779]                   args[[name]] <- ""
[09:31:19.779]                 }
[09:31:19.779]                 NAMES <- toupper(removed)
[09:31:19.779]                 for (kk in seq_along(NAMES)) {
[09:31:19.779]                   name <- removed[[kk]]
[09:31:19.779]                   NAME <- NAMES[[kk]]
[09:31:19.779]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.779]                     next
[09:31:19.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.779]                 }
[09:31:19.779]                 if (length(args) > 0) 
[09:31:19.779]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.779]             }
[09:31:19.779]             else {
[09:31:19.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.779]             }
[09:31:19.779]             {
[09:31:19.779]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.779]                   0L) {
[09:31:19.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.779]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.779]                   base::options(opts)
[09:31:19.779]                 }
[09:31:19.779]                 {
[09:31:19.779]                   {
[09:31:19.779]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.779]                     NULL
[09:31:19.779]                   }
[09:31:19.779]                   options(future.plan = NULL)
[09:31:19.779]                   if (is.na(NA_character_)) 
[09:31:19.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.779]                     .init = FALSE)
[09:31:19.779]                 }
[09:31:19.779]             }
[09:31:19.779]         }
[09:31:19.779]     })
[09:31:19.779]     if (TRUE) {
[09:31:19.779]         base::sink(type = "output", split = FALSE)
[09:31:19.779]         if (TRUE) {
[09:31:19.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.779]         }
[09:31:19.779]         else {
[09:31:19.779]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.779]         }
[09:31:19.779]         base::close(...future.stdout)
[09:31:19.779]         ...future.stdout <- NULL
[09:31:19.779]     }
[09:31:19.779]     ...future.result$conditions <- ...future.conditions
[09:31:19.779]     ...future.result$finished <- base::Sys.time()
[09:31:19.779]     ...future.result
[09:31:19.779] }
[09:31:19.782] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[09:31:19.782] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[09:31:19.782] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[09:31:19.782] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[09:31:19.783] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[09:31:19.783] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[09:31:19.783] MultisessionFuture started
[09:31:19.783] - Launch lazy future ... done
[09:31:19.784] run() for ‘MultisessionFuture’ ... done
[09:31:19.784] result() for ClusterFuture ...
[09:31:19.784] receiveMessageFromWorker() for ClusterFuture ...
[09:31:19.784] - Validating connection of MultisessionFuture
[09:31:19.827] - received message: FutureResult
[09:31:19.827] - Received FutureResult
[09:31:19.827] - Erased future from FutureRegistry
[09:31:19.827] result() for ClusterFuture ...
[09:31:19.827] - result already collected: FutureResult
[09:31:19.827] result() for ClusterFuture ... done
[09:31:19.827] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:19.828] result() for ClusterFuture ... done
[09:31:19.828] result() for ClusterFuture ...
[09:31:19.828] - result already collected: FutureResult
[09:31:19.828] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:19.830] getGlobalsAndPackages() ...
[09:31:19.830] Searching for globals...
[09:31:19.832] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:19.832] Searching for globals ... DONE
[09:31:19.833] Resolving globals: FALSE
[09:31:19.833] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:19.834] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:19.834] - globals: [2] ‘weight’, ‘group’
[09:31:19.834] - packages: [1] ‘stats’
[09:31:19.834] getGlobalsAndPackages() ... DONE
[09:31:19.834] run() for ‘Future’ ...
[09:31:19.834] - state: ‘created’
[09:31:19.835] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:19.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:19.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:19.850]   - Field: ‘node’
[09:31:19.850]   - Field: ‘label’
[09:31:19.850]   - Field: ‘local’
[09:31:19.850]   - Field: ‘owner’
[09:31:19.850]   - Field: ‘envir’
[09:31:19.851]   - Field: ‘workers’
[09:31:19.851]   - Field: ‘packages’
[09:31:19.851]   - Field: ‘gc’
[09:31:19.851]   - Field: ‘conditions’
[09:31:19.851]   - Field: ‘persistent’
[09:31:19.851]   - Field: ‘expr’
[09:31:19.851]   - Field: ‘uuid’
[09:31:19.851]   - Field: ‘seed’
[09:31:19.852]   - Field: ‘version’
[09:31:19.852]   - Field: ‘result’
[09:31:19.852]   - Field: ‘asynchronous’
[09:31:19.852]   - Field: ‘calls’
[09:31:19.852]   - Field: ‘globals’
[09:31:19.852]   - Field: ‘stdout’
[09:31:19.852]   - Field: ‘earlySignal’
[09:31:19.852]   - Field: ‘lazy’
[09:31:19.852]   - Field: ‘state’
[09:31:19.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:19.853] - Launch lazy future ...
[09:31:19.853] Packages needed by the future expression (n = 1): ‘stats’
[09:31:19.853] Packages needed by future strategies (n = 0): <none>
[09:31:19.854] {
[09:31:19.854]     {
[09:31:19.854]         {
[09:31:19.854]             ...future.startTime <- base::Sys.time()
[09:31:19.854]             {
[09:31:19.854]                 {
[09:31:19.854]                   {
[09:31:19.854]                     {
[09:31:19.854]                       {
[09:31:19.854]                         base::local({
[09:31:19.854]                           has_future <- base::requireNamespace("future", 
[09:31:19.854]                             quietly = TRUE)
[09:31:19.854]                           if (has_future) {
[09:31:19.854]                             ns <- base::getNamespace("future")
[09:31:19.854]                             version <- ns[[".package"]][["version"]]
[09:31:19.854]                             if (is.null(version)) 
[09:31:19.854]                               version <- utils::packageVersion("future")
[09:31:19.854]                           }
[09:31:19.854]                           else {
[09:31:19.854]                             version <- NULL
[09:31:19.854]                           }
[09:31:19.854]                           if (!has_future || version < "1.8.0") {
[09:31:19.854]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.854]                               "", base::R.version$version.string), 
[09:31:19.854]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:19.854]                                 base::R.version$platform, 8 * 
[09:31:19.854]                                   base::.Machine$sizeof.pointer), 
[09:31:19.854]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.854]                                 "release", "version")], collapse = " "), 
[09:31:19.854]                               hostname = base::Sys.info()[["nodename"]])
[09:31:19.854]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.854]                               info)
[09:31:19.854]                             info <- base::paste(info, collapse = "; ")
[09:31:19.854]                             if (!has_future) {
[09:31:19.854]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.854]                                 info)
[09:31:19.854]                             }
[09:31:19.854]                             else {
[09:31:19.854]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.854]                                 info, version)
[09:31:19.854]                             }
[09:31:19.854]                             base::stop(msg)
[09:31:19.854]                           }
[09:31:19.854]                         })
[09:31:19.854]                       }
[09:31:19.854]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.854]                       base::options(mc.cores = 1L)
[09:31:19.854]                     }
[09:31:19.854]                     base::local({
[09:31:19.854]                       for (pkg in "stats") {
[09:31:19.854]                         base::loadNamespace(pkg)
[09:31:19.854]                         base::library(pkg, character.only = TRUE)
[09:31:19.854]                       }
[09:31:19.854]                     })
[09:31:19.854]                   }
[09:31:19.854]                   ...future.strategy.old <- future::plan("list")
[09:31:19.854]                   options(future.plan = NULL)
[09:31:19.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.854]                 }
[09:31:19.854]                 ...future.workdir <- getwd()
[09:31:19.854]             }
[09:31:19.854]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.854]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.854]         }
[09:31:19.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.854]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.854]             base::names(...future.oldOptions))
[09:31:19.854]     }
[09:31:19.854]     if (FALSE) {
[09:31:19.854]     }
[09:31:19.854]     else {
[09:31:19.854]         if (TRUE) {
[09:31:19.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.854]                 open = "w")
[09:31:19.854]         }
[09:31:19.854]         else {
[09:31:19.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.854]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.854]         }
[09:31:19.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.854]             base::sink(type = "output", split = FALSE)
[09:31:19.854]             base::close(...future.stdout)
[09:31:19.854]         }, add = TRUE)
[09:31:19.854]     }
[09:31:19.854]     ...future.frame <- base::sys.nframe()
[09:31:19.854]     ...future.conditions <- base::list()
[09:31:19.854]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.854]     if (FALSE) {
[09:31:19.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.854]     }
[09:31:19.854]     ...future.result <- base::tryCatch({
[09:31:19.854]         base::withCallingHandlers({
[09:31:19.854]             ...future.value <- base::withVisible(base::local({
[09:31:19.854]                 ...future.makeSendCondition <- base::local({
[09:31:19.854]                   sendCondition <- NULL
[09:31:19.854]                   function(frame = 1L) {
[09:31:19.854]                     if (is.function(sendCondition)) 
[09:31:19.854]                       return(sendCondition)
[09:31:19.854]                     ns <- getNamespace("parallel")
[09:31:19.854]                     if (exists("sendData", mode = "function", 
[09:31:19.854]                       envir = ns)) {
[09:31:19.854]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:19.854]                         envir = ns)
[09:31:19.854]                       envir <- sys.frame(frame)
[09:31:19.854]                       master <- NULL
[09:31:19.854]                       while (!identical(envir, .GlobalEnv) && 
[09:31:19.854]                         !identical(envir, emptyenv())) {
[09:31:19.854]                         if (exists("master", mode = "list", envir = envir, 
[09:31:19.854]                           inherits = FALSE)) {
[09:31:19.854]                           master <- get("master", mode = "list", 
[09:31:19.854]                             envir = envir, inherits = FALSE)
[09:31:19.854]                           if (inherits(master, c("SOCKnode", 
[09:31:19.854]                             "SOCK0node"))) {
[09:31:19.854]                             sendCondition <<- function(cond) {
[09:31:19.854]                               data <- list(type = "VALUE", value = cond, 
[09:31:19.854]                                 success = TRUE)
[09:31:19.854]                               parallel_sendData(master, data)
[09:31:19.854]                             }
[09:31:19.854]                             return(sendCondition)
[09:31:19.854]                           }
[09:31:19.854]                         }
[09:31:19.854]                         frame <- frame + 1L
[09:31:19.854]                         envir <- sys.frame(frame)
[09:31:19.854]                       }
[09:31:19.854]                     }
[09:31:19.854]                     sendCondition <<- function(cond) NULL
[09:31:19.854]                   }
[09:31:19.854]                 })
[09:31:19.854]                 withCallingHandlers({
[09:31:19.854]                   {
[09:31:19.854]                     lm(weight ~ group - 1)
[09:31:19.854]                   }
[09:31:19.854]                 }, immediateCondition = function(cond) {
[09:31:19.854]                   sendCondition <- ...future.makeSendCondition()
[09:31:19.854]                   sendCondition(cond)
[09:31:19.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.854]                   {
[09:31:19.854]                     inherits <- base::inherits
[09:31:19.854]                     invokeRestart <- base::invokeRestart
[09:31:19.854]                     is.null <- base::is.null
[09:31:19.854]                     muffled <- FALSE
[09:31:19.854]                     if (inherits(cond, "message")) {
[09:31:19.854]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.854]                       if (muffled) 
[09:31:19.854]                         invokeRestart("muffleMessage")
[09:31:19.854]                     }
[09:31:19.854]                     else if (inherits(cond, "warning")) {
[09:31:19.854]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.854]                       if (muffled) 
[09:31:19.854]                         invokeRestart("muffleWarning")
[09:31:19.854]                     }
[09:31:19.854]                     else if (inherits(cond, "condition")) {
[09:31:19.854]                       if (!is.null(pattern)) {
[09:31:19.854]                         computeRestarts <- base::computeRestarts
[09:31:19.854]                         grepl <- base::grepl
[09:31:19.854]                         restarts <- computeRestarts(cond)
[09:31:19.854]                         for (restart in restarts) {
[09:31:19.854]                           name <- restart$name
[09:31:19.854]                           if (is.null(name)) 
[09:31:19.854]                             next
[09:31:19.854]                           if (!grepl(pattern, name)) 
[09:31:19.854]                             next
[09:31:19.854]                           invokeRestart(restart)
[09:31:19.854]                           muffled <- TRUE
[09:31:19.854]                           break
[09:31:19.854]                         }
[09:31:19.854]                       }
[09:31:19.854]                     }
[09:31:19.854]                     invisible(muffled)
[09:31:19.854]                   }
[09:31:19.854]                   muffleCondition(cond)
[09:31:19.854]                 })
[09:31:19.854]             }))
[09:31:19.854]             future::FutureResult(value = ...future.value$value, 
[09:31:19.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.854]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.854]                     ...future.globalenv.names))
[09:31:19.854]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.854]         }, condition = base::local({
[09:31:19.854]             c <- base::c
[09:31:19.854]             inherits <- base::inherits
[09:31:19.854]             invokeRestart <- base::invokeRestart
[09:31:19.854]             length <- base::length
[09:31:19.854]             list <- base::list
[09:31:19.854]             seq.int <- base::seq.int
[09:31:19.854]             signalCondition <- base::signalCondition
[09:31:19.854]             sys.calls <- base::sys.calls
[09:31:19.854]             `[[` <- base::`[[`
[09:31:19.854]             `+` <- base::`+`
[09:31:19.854]             `<<-` <- base::`<<-`
[09:31:19.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.854]                   3L)]
[09:31:19.854]             }
[09:31:19.854]             function(cond) {
[09:31:19.854]                 is_error <- inherits(cond, "error")
[09:31:19.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.854]                   NULL)
[09:31:19.854]                 if (is_error) {
[09:31:19.854]                   sessionInformation <- function() {
[09:31:19.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.854]                       search = base::search(), system = base::Sys.info())
[09:31:19.854]                   }
[09:31:19.854]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.854]                     cond$call), session = sessionInformation(), 
[09:31:19.854]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.854]                   signalCondition(cond)
[09:31:19.854]                 }
[09:31:19.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.854]                 "immediateCondition"))) {
[09:31:19.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.854]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.854]                   if (TRUE && !signal) {
[09:31:19.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.854]                     {
[09:31:19.854]                       inherits <- base::inherits
[09:31:19.854]                       invokeRestart <- base::invokeRestart
[09:31:19.854]                       is.null <- base::is.null
[09:31:19.854]                       muffled <- FALSE
[09:31:19.854]                       if (inherits(cond, "message")) {
[09:31:19.854]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.854]                         if (muffled) 
[09:31:19.854]                           invokeRestart("muffleMessage")
[09:31:19.854]                       }
[09:31:19.854]                       else if (inherits(cond, "warning")) {
[09:31:19.854]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.854]                         if (muffled) 
[09:31:19.854]                           invokeRestart("muffleWarning")
[09:31:19.854]                       }
[09:31:19.854]                       else if (inherits(cond, "condition")) {
[09:31:19.854]                         if (!is.null(pattern)) {
[09:31:19.854]                           computeRestarts <- base::computeRestarts
[09:31:19.854]                           grepl <- base::grepl
[09:31:19.854]                           restarts <- computeRestarts(cond)
[09:31:19.854]                           for (restart in restarts) {
[09:31:19.854]                             name <- restart$name
[09:31:19.854]                             if (is.null(name)) 
[09:31:19.854]                               next
[09:31:19.854]                             if (!grepl(pattern, name)) 
[09:31:19.854]                               next
[09:31:19.854]                             invokeRestart(restart)
[09:31:19.854]                             muffled <- TRUE
[09:31:19.854]                             break
[09:31:19.854]                           }
[09:31:19.854]                         }
[09:31:19.854]                       }
[09:31:19.854]                       invisible(muffled)
[09:31:19.854]                     }
[09:31:19.854]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.854]                   }
[09:31:19.854]                 }
[09:31:19.854]                 else {
[09:31:19.854]                   if (TRUE) {
[09:31:19.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.854]                     {
[09:31:19.854]                       inherits <- base::inherits
[09:31:19.854]                       invokeRestart <- base::invokeRestart
[09:31:19.854]                       is.null <- base::is.null
[09:31:19.854]                       muffled <- FALSE
[09:31:19.854]                       if (inherits(cond, "message")) {
[09:31:19.854]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.854]                         if (muffled) 
[09:31:19.854]                           invokeRestart("muffleMessage")
[09:31:19.854]                       }
[09:31:19.854]                       else if (inherits(cond, "warning")) {
[09:31:19.854]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.854]                         if (muffled) 
[09:31:19.854]                           invokeRestart("muffleWarning")
[09:31:19.854]                       }
[09:31:19.854]                       else if (inherits(cond, "condition")) {
[09:31:19.854]                         if (!is.null(pattern)) {
[09:31:19.854]                           computeRestarts <- base::computeRestarts
[09:31:19.854]                           grepl <- base::grepl
[09:31:19.854]                           restarts <- computeRestarts(cond)
[09:31:19.854]                           for (restart in restarts) {
[09:31:19.854]                             name <- restart$name
[09:31:19.854]                             if (is.null(name)) 
[09:31:19.854]                               next
[09:31:19.854]                             if (!grepl(pattern, name)) 
[09:31:19.854]                               next
[09:31:19.854]                             invokeRestart(restart)
[09:31:19.854]                             muffled <- TRUE
[09:31:19.854]                             break
[09:31:19.854]                           }
[09:31:19.854]                         }
[09:31:19.854]                       }
[09:31:19.854]                       invisible(muffled)
[09:31:19.854]                     }
[09:31:19.854]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.854]                   }
[09:31:19.854]                 }
[09:31:19.854]             }
[09:31:19.854]         }))
[09:31:19.854]     }, error = function(ex) {
[09:31:19.854]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.854]                 ...future.rng), started = ...future.startTime, 
[09:31:19.854]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.854]             version = "1.8"), class = "FutureResult")
[09:31:19.854]     }, finally = {
[09:31:19.854]         if (!identical(...future.workdir, getwd())) 
[09:31:19.854]             setwd(...future.workdir)
[09:31:19.854]         {
[09:31:19.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.854]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.854]             }
[09:31:19.854]             base::options(...future.oldOptions)
[09:31:19.854]             if (.Platform$OS.type == "windows") {
[09:31:19.854]                 old_names <- names(...future.oldEnvVars)
[09:31:19.854]                 envs <- base::Sys.getenv()
[09:31:19.854]                 names <- names(envs)
[09:31:19.854]                 common <- intersect(names, old_names)
[09:31:19.854]                 added <- setdiff(names, old_names)
[09:31:19.854]                 removed <- setdiff(old_names, names)
[09:31:19.854]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.854]                   envs[common]]
[09:31:19.854]                 NAMES <- toupper(changed)
[09:31:19.854]                 args <- list()
[09:31:19.854]                 for (kk in seq_along(NAMES)) {
[09:31:19.854]                   name <- changed[[kk]]
[09:31:19.854]                   NAME <- NAMES[[kk]]
[09:31:19.854]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.854]                     next
[09:31:19.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.854]                 }
[09:31:19.854]                 NAMES <- toupper(added)
[09:31:19.854]                 for (kk in seq_along(NAMES)) {
[09:31:19.854]                   name <- added[[kk]]
[09:31:19.854]                   NAME <- NAMES[[kk]]
[09:31:19.854]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.854]                     next
[09:31:19.854]                   args[[name]] <- ""
[09:31:19.854]                 }
[09:31:19.854]                 NAMES <- toupper(removed)
[09:31:19.854]                 for (kk in seq_along(NAMES)) {
[09:31:19.854]                   name <- removed[[kk]]
[09:31:19.854]                   NAME <- NAMES[[kk]]
[09:31:19.854]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.854]                     next
[09:31:19.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.854]                 }
[09:31:19.854]                 if (length(args) > 0) 
[09:31:19.854]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.854]             }
[09:31:19.854]             else {
[09:31:19.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.854]             }
[09:31:19.854]             {
[09:31:19.854]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.854]                   0L) {
[09:31:19.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.854]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.854]                   base::options(opts)
[09:31:19.854]                 }
[09:31:19.854]                 {
[09:31:19.854]                   {
[09:31:19.854]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.854]                     NULL
[09:31:19.854]                   }
[09:31:19.854]                   options(future.plan = NULL)
[09:31:19.854]                   if (is.na(NA_character_)) 
[09:31:19.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.854]                     .init = FALSE)
[09:31:19.854]                 }
[09:31:19.854]             }
[09:31:19.854]         }
[09:31:19.854]     })
[09:31:19.854]     if (TRUE) {
[09:31:19.854]         base::sink(type = "output", split = FALSE)
[09:31:19.854]         if (TRUE) {
[09:31:19.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.854]         }
[09:31:19.854]         else {
[09:31:19.854]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.854]         }
[09:31:19.854]         base::close(...future.stdout)
[09:31:19.854]         ...future.stdout <- NULL
[09:31:19.854]     }
[09:31:19.854]     ...future.result$conditions <- ...future.conditions
[09:31:19.854]     ...future.result$finished <- base::Sys.time()
[09:31:19.854]     ...future.result
[09:31:19.854] }
[09:31:19.857] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[09:31:19.857] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[09:31:19.857] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[09:31:19.858] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[09:31:19.858] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[09:31:19.858] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[09:31:19.859] MultisessionFuture started
[09:31:19.859] - Launch lazy future ... done
[09:31:19.859] run() for ‘MultisessionFuture’ ... done
[09:31:19.859] result() for ClusterFuture ...
[09:31:19.862] receiveMessageFromWorker() for ClusterFuture ...
[09:31:19.862] - Validating connection of MultisessionFuture
[09:31:19.902] - received message: FutureResult
[09:31:19.903] - Received FutureResult
[09:31:19.903] - Erased future from FutureRegistry
[09:31:19.903] result() for ClusterFuture ...
[09:31:19.903] - result already collected: FutureResult
[09:31:19.903] result() for ClusterFuture ... done
[09:31:19.903] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:19.903] result() for ClusterFuture ... done
[09:31:19.903] result() for ClusterFuture ...
[09:31:19.903] - result already collected: FutureResult
[09:31:19.903] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:19.905] getGlobalsAndPackages() ...
[09:31:19.905] Searching for globals...
[09:31:19.907] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:19.907] Searching for globals ... DONE
[09:31:19.907] Resolving globals: FALSE
[09:31:19.908] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:19.908] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:19.908] - globals: [2] ‘weight’, ‘group’
[09:31:19.908] - packages: [1] ‘stats’
[09:31:19.908] getGlobalsAndPackages() ... DONE
[09:31:19.909] run() for ‘Future’ ...
[09:31:19.909] - state: ‘created’
[09:31:19.909] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:19.923] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:19.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:19.923]   - Field: ‘node’
[09:31:19.923]   - Field: ‘label’
[09:31:19.923]   - Field: ‘local’
[09:31:19.923]   - Field: ‘owner’
[09:31:19.923]   - Field: ‘envir’
[09:31:19.923]   - Field: ‘workers’
[09:31:19.923]   - Field: ‘packages’
[09:31:19.924]   - Field: ‘gc’
[09:31:19.924]   - Field: ‘conditions’
[09:31:19.924]   - Field: ‘persistent’
[09:31:19.924]   - Field: ‘expr’
[09:31:19.924]   - Field: ‘uuid’
[09:31:19.924]   - Field: ‘seed’
[09:31:19.924]   - Field: ‘version’
[09:31:19.924]   - Field: ‘result’
[09:31:19.924]   - Field: ‘asynchronous’
[09:31:19.924]   - Field: ‘calls’
[09:31:19.925]   - Field: ‘globals’
[09:31:19.925]   - Field: ‘stdout’
[09:31:19.925]   - Field: ‘earlySignal’
[09:31:19.925]   - Field: ‘lazy’
[09:31:19.925]   - Field: ‘state’
[09:31:19.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:19.925] - Launch lazy future ...
[09:31:19.925] Packages needed by the future expression (n = 1): ‘stats’
[09:31:19.925] Packages needed by future strategies (n = 0): <none>
[09:31:19.926] {
[09:31:19.926]     {
[09:31:19.926]         {
[09:31:19.926]             ...future.startTime <- base::Sys.time()
[09:31:19.926]             {
[09:31:19.926]                 {
[09:31:19.926]                   {
[09:31:19.926]                     {
[09:31:19.926]                       {
[09:31:19.926]                         base::local({
[09:31:19.926]                           has_future <- base::requireNamespace("future", 
[09:31:19.926]                             quietly = TRUE)
[09:31:19.926]                           if (has_future) {
[09:31:19.926]                             ns <- base::getNamespace("future")
[09:31:19.926]                             version <- ns[[".package"]][["version"]]
[09:31:19.926]                             if (is.null(version)) 
[09:31:19.926]                               version <- utils::packageVersion("future")
[09:31:19.926]                           }
[09:31:19.926]                           else {
[09:31:19.926]                             version <- NULL
[09:31:19.926]                           }
[09:31:19.926]                           if (!has_future || version < "1.8.0") {
[09:31:19.926]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.926]                               "", base::R.version$version.string), 
[09:31:19.926]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:19.926]                                 base::R.version$platform, 8 * 
[09:31:19.926]                                   base::.Machine$sizeof.pointer), 
[09:31:19.926]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.926]                                 "release", "version")], collapse = " "), 
[09:31:19.926]                               hostname = base::Sys.info()[["nodename"]])
[09:31:19.926]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.926]                               info)
[09:31:19.926]                             info <- base::paste(info, collapse = "; ")
[09:31:19.926]                             if (!has_future) {
[09:31:19.926]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.926]                                 info)
[09:31:19.926]                             }
[09:31:19.926]                             else {
[09:31:19.926]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.926]                                 info, version)
[09:31:19.926]                             }
[09:31:19.926]                             base::stop(msg)
[09:31:19.926]                           }
[09:31:19.926]                         })
[09:31:19.926]                       }
[09:31:19.926]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.926]                       base::options(mc.cores = 1L)
[09:31:19.926]                     }
[09:31:19.926]                     base::local({
[09:31:19.926]                       for (pkg in "stats") {
[09:31:19.926]                         base::loadNamespace(pkg)
[09:31:19.926]                         base::library(pkg, character.only = TRUE)
[09:31:19.926]                       }
[09:31:19.926]                     })
[09:31:19.926]                   }
[09:31:19.926]                   ...future.strategy.old <- future::plan("list")
[09:31:19.926]                   options(future.plan = NULL)
[09:31:19.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.926]                 }
[09:31:19.926]                 ...future.workdir <- getwd()
[09:31:19.926]             }
[09:31:19.926]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.926]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.926]         }
[09:31:19.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.926]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.926]             base::names(...future.oldOptions))
[09:31:19.926]     }
[09:31:19.926]     if (FALSE) {
[09:31:19.926]     }
[09:31:19.926]     else {
[09:31:19.926]         if (TRUE) {
[09:31:19.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.926]                 open = "w")
[09:31:19.926]         }
[09:31:19.926]         else {
[09:31:19.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.926]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.926]         }
[09:31:19.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.926]             base::sink(type = "output", split = FALSE)
[09:31:19.926]             base::close(...future.stdout)
[09:31:19.926]         }, add = TRUE)
[09:31:19.926]     }
[09:31:19.926]     ...future.frame <- base::sys.nframe()
[09:31:19.926]     ...future.conditions <- base::list()
[09:31:19.926]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.926]     if (FALSE) {
[09:31:19.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.926]     }
[09:31:19.926]     ...future.result <- base::tryCatch({
[09:31:19.926]         base::withCallingHandlers({
[09:31:19.926]             ...future.value <- base::withVisible(base::local({
[09:31:19.926]                 ...future.makeSendCondition <- base::local({
[09:31:19.926]                   sendCondition <- NULL
[09:31:19.926]                   function(frame = 1L) {
[09:31:19.926]                     if (is.function(sendCondition)) 
[09:31:19.926]                       return(sendCondition)
[09:31:19.926]                     ns <- getNamespace("parallel")
[09:31:19.926]                     if (exists("sendData", mode = "function", 
[09:31:19.926]                       envir = ns)) {
[09:31:19.926]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:19.926]                         envir = ns)
[09:31:19.926]                       envir <- sys.frame(frame)
[09:31:19.926]                       master <- NULL
[09:31:19.926]                       while (!identical(envir, .GlobalEnv) && 
[09:31:19.926]                         !identical(envir, emptyenv())) {
[09:31:19.926]                         if (exists("master", mode = "list", envir = envir, 
[09:31:19.926]                           inherits = FALSE)) {
[09:31:19.926]                           master <- get("master", mode = "list", 
[09:31:19.926]                             envir = envir, inherits = FALSE)
[09:31:19.926]                           if (inherits(master, c("SOCKnode", 
[09:31:19.926]                             "SOCK0node"))) {
[09:31:19.926]                             sendCondition <<- function(cond) {
[09:31:19.926]                               data <- list(type = "VALUE", value = cond, 
[09:31:19.926]                                 success = TRUE)
[09:31:19.926]                               parallel_sendData(master, data)
[09:31:19.926]                             }
[09:31:19.926]                             return(sendCondition)
[09:31:19.926]                           }
[09:31:19.926]                         }
[09:31:19.926]                         frame <- frame + 1L
[09:31:19.926]                         envir <- sys.frame(frame)
[09:31:19.926]                       }
[09:31:19.926]                     }
[09:31:19.926]                     sendCondition <<- function(cond) NULL
[09:31:19.926]                   }
[09:31:19.926]                 })
[09:31:19.926]                 withCallingHandlers({
[09:31:19.926]                   {
[09:31:19.926]                     lm(weight ~ group - 1)
[09:31:19.926]                   }
[09:31:19.926]                 }, immediateCondition = function(cond) {
[09:31:19.926]                   sendCondition <- ...future.makeSendCondition()
[09:31:19.926]                   sendCondition(cond)
[09:31:19.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.926]                   {
[09:31:19.926]                     inherits <- base::inherits
[09:31:19.926]                     invokeRestart <- base::invokeRestart
[09:31:19.926]                     is.null <- base::is.null
[09:31:19.926]                     muffled <- FALSE
[09:31:19.926]                     if (inherits(cond, "message")) {
[09:31:19.926]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.926]                       if (muffled) 
[09:31:19.926]                         invokeRestart("muffleMessage")
[09:31:19.926]                     }
[09:31:19.926]                     else if (inherits(cond, "warning")) {
[09:31:19.926]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.926]                       if (muffled) 
[09:31:19.926]                         invokeRestart("muffleWarning")
[09:31:19.926]                     }
[09:31:19.926]                     else if (inherits(cond, "condition")) {
[09:31:19.926]                       if (!is.null(pattern)) {
[09:31:19.926]                         computeRestarts <- base::computeRestarts
[09:31:19.926]                         grepl <- base::grepl
[09:31:19.926]                         restarts <- computeRestarts(cond)
[09:31:19.926]                         for (restart in restarts) {
[09:31:19.926]                           name <- restart$name
[09:31:19.926]                           if (is.null(name)) 
[09:31:19.926]                             next
[09:31:19.926]                           if (!grepl(pattern, name)) 
[09:31:19.926]                             next
[09:31:19.926]                           invokeRestart(restart)
[09:31:19.926]                           muffled <- TRUE
[09:31:19.926]                           break
[09:31:19.926]                         }
[09:31:19.926]                       }
[09:31:19.926]                     }
[09:31:19.926]                     invisible(muffled)
[09:31:19.926]                   }
[09:31:19.926]                   muffleCondition(cond)
[09:31:19.926]                 })
[09:31:19.926]             }))
[09:31:19.926]             future::FutureResult(value = ...future.value$value, 
[09:31:19.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.926]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.926]                     ...future.globalenv.names))
[09:31:19.926]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.926]         }, condition = base::local({
[09:31:19.926]             c <- base::c
[09:31:19.926]             inherits <- base::inherits
[09:31:19.926]             invokeRestart <- base::invokeRestart
[09:31:19.926]             length <- base::length
[09:31:19.926]             list <- base::list
[09:31:19.926]             seq.int <- base::seq.int
[09:31:19.926]             signalCondition <- base::signalCondition
[09:31:19.926]             sys.calls <- base::sys.calls
[09:31:19.926]             `[[` <- base::`[[`
[09:31:19.926]             `+` <- base::`+`
[09:31:19.926]             `<<-` <- base::`<<-`
[09:31:19.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.926]                   3L)]
[09:31:19.926]             }
[09:31:19.926]             function(cond) {
[09:31:19.926]                 is_error <- inherits(cond, "error")
[09:31:19.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.926]                   NULL)
[09:31:19.926]                 if (is_error) {
[09:31:19.926]                   sessionInformation <- function() {
[09:31:19.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.926]                       search = base::search(), system = base::Sys.info())
[09:31:19.926]                   }
[09:31:19.926]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.926]                     cond$call), session = sessionInformation(), 
[09:31:19.926]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.926]                   signalCondition(cond)
[09:31:19.926]                 }
[09:31:19.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.926]                 "immediateCondition"))) {
[09:31:19.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.926]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.926]                   if (TRUE && !signal) {
[09:31:19.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.926]                     {
[09:31:19.926]                       inherits <- base::inherits
[09:31:19.926]                       invokeRestart <- base::invokeRestart
[09:31:19.926]                       is.null <- base::is.null
[09:31:19.926]                       muffled <- FALSE
[09:31:19.926]                       if (inherits(cond, "message")) {
[09:31:19.926]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.926]                         if (muffled) 
[09:31:19.926]                           invokeRestart("muffleMessage")
[09:31:19.926]                       }
[09:31:19.926]                       else if (inherits(cond, "warning")) {
[09:31:19.926]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.926]                         if (muffled) 
[09:31:19.926]                           invokeRestart("muffleWarning")
[09:31:19.926]                       }
[09:31:19.926]                       else if (inherits(cond, "condition")) {
[09:31:19.926]                         if (!is.null(pattern)) {
[09:31:19.926]                           computeRestarts <- base::computeRestarts
[09:31:19.926]                           grepl <- base::grepl
[09:31:19.926]                           restarts <- computeRestarts(cond)
[09:31:19.926]                           for (restart in restarts) {
[09:31:19.926]                             name <- restart$name
[09:31:19.926]                             if (is.null(name)) 
[09:31:19.926]                               next
[09:31:19.926]                             if (!grepl(pattern, name)) 
[09:31:19.926]                               next
[09:31:19.926]                             invokeRestart(restart)
[09:31:19.926]                             muffled <- TRUE
[09:31:19.926]                             break
[09:31:19.926]                           }
[09:31:19.926]                         }
[09:31:19.926]                       }
[09:31:19.926]                       invisible(muffled)
[09:31:19.926]                     }
[09:31:19.926]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.926]                   }
[09:31:19.926]                 }
[09:31:19.926]                 else {
[09:31:19.926]                   if (TRUE) {
[09:31:19.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.926]                     {
[09:31:19.926]                       inherits <- base::inherits
[09:31:19.926]                       invokeRestart <- base::invokeRestart
[09:31:19.926]                       is.null <- base::is.null
[09:31:19.926]                       muffled <- FALSE
[09:31:19.926]                       if (inherits(cond, "message")) {
[09:31:19.926]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.926]                         if (muffled) 
[09:31:19.926]                           invokeRestart("muffleMessage")
[09:31:19.926]                       }
[09:31:19.926]                       else if (inherits(cond, "warning")) {
[09:31:19.926]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.926]                         if (muffled) 
[09:31:19.926]                           invokeRestart("muffleWarning")
[09:31:19.926]                       }
[09:31:19.926]                       else if (inherits(cond, "condition")) {
[09:31:19.926]                         if (!is.null(pattern)) {
[09:31:19.926]                           computeRestarts <- base::computeRestarts
[09:31:19.926]                           grepl <- base::grepl
[09:31:19.926]                           restarts <- computeRestarts(cond)
[09:31:19.926]                           for (restart in restarts) {
[09:31:19.926]                             name <- restart$name
[09:31:19.926]                             if (is.null(name)) 
[09:31:19.926]                               next
[09:31:19.926]                             if (!grepl(pattern, name)) 
[09:31:19.926]                               next
[09:31:19.926]                             invokeRestart(restart)
[09:31:19.926]                             muffled <- TRUE
[09:31:19.926]                             break
[09:31:19.926]                           }
[09:31:19.926]                         }
[09:31:19.926]                       }
[09:31:19.926]                       invisible(muffled)
[09:31:19.926]                     }
[09:31:19.926]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.926]                   }
[09:31:19.926]                 }
[09:31:19.926]             }
[09:31:19.926]         }))
[09:31:19.926]     }, error = function(ex) {
[09:31:19.926]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.926]                 ...future.rng), started = ...future.startTime, 
[09:31:19.926]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.926]             version = "1.8"), class = "FutureResult")
[09:31:19.926]     }, finally = {
[09:31:19.926]         if (!identical(...future.workdir, getwd())) 
[09:31:19.926]             setwd(...future.workdir)
[09:31:19.926]         {
[09:31:19.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.926]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.926]             }
[09:31:19.926]             base::options(...future.oldOptions)
[09:31:19.926]             if (.Platform$OS.type == "windows") {
[09:31:19.926]                 old_names <- names(...future.oldEnvVars)
[09:31:19.926]                 envs <- base::Sys.getenv()
[09:31:19.926]                 names <- names(envs)
[09:31:19.926]                 common <- intersect(names, old_names)
[09:31:19.926]                 added <- setdiff(names, old_names)
[09:31:19.926]                 removed <- setdiff(old_names, names)
[09:31:19.926]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.926]                   envs[common]]
[09:31:19.926]                 NAMES <- toupper(changed)
[09:31:19.926]                 args <- list()
[09:31:19.926]                 for (kk in seq_along(NAMES)) {
[09:31:19.926]                   name <- changed[[kk]]
[09:31:19.926]                   NAME <- NAMES[[kk]]
[09:31:19.926]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.926]                     next
[09:31:19.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.926]                 }
[09:31:19.926]                 NAMES <- toupper(added)
[09:31:19.926]                 for (kk in seq_along(NAMES)) {
[09:31:19.926]                   name <- added[[kk]]
[09:31:19.926]                   NAME <- NAMES[[kk]]
[09:31:19.926]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.926]                     next
[09:31:19.926]                   args[[name]] <- ""
[09:31:19.926]                 }
[09:31:19.926]                 NAMES <- toupper(removed)
[09:31:19.926]                 for (kk in seq_along(NAMES)) {
[09:31:19.926]                   name <- removed[[kk]]
[09:31:19.926]                   NAME <- NAMES[[kk]]
[09:31:19.926]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.926]                     next
[09:31:19.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.926]                 }
[09:31:19.926]                 if (length(args) > 0) 
[09:31:19.926]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.926]             }
[09:31:19.926]             else {
[09:31:19.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.926]             }
[09:31:19.926]             {
[09:31:19.926]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.926]                   0L) {
[09:31:19.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.926]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.926]                   base::options(opts)
[09:31:19.926]                 }
[09:31:19.926]                 {
[09:31:19.926]                   {
[09:31:19.926]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.926]                     NULL
[09:31:19.926]                   }
[09:31:19.926]                   options(future.plan = NULL)
[09:31:19.926]                   if (is.na(NA_character_)) 
[09:31:19.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.926]                     .init = FALSE)
[09:31:19.926]                 }
[09:31:19.926]             }
[09:31:19.926]         }
[09:31:19.926]     })
[09:31:19.926]     if (TRUE) {
[09:31:19.926]         base::sink(type = "output", split = FALSE)
[09:31:19.926]         if (TRUE) {
[09:31:19.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.926]         }
[09:31:19.926]         else {
[09:31:19.926]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.926]         }
[09:31:19.926]         base::close(...future.stdout)
[09:31:19.926]         ...future.stdout <- NULL
[09:31:19.926]     }
[09:31:19.926]     ...future.result$conditions <- ...future.conditions
[09:31:19.926]     ...future.result$finished <- base::Sys.time()
[09:31:19.926]     ...future.result
[09:31:19.926] }
[09:31:19.928] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[09:31:19.928] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[09:31:19.929] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[09:31:19.929] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[09:31:19.929] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[09:31:19.929] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[09:31:19.930] MultisessionFuture started
[09:31:19.930] - Launch lazy future ... done
[09:31:19.930] run() for ‘MultisessionFuture’ ... done
[09:31:19.930] result() for ClusterFuture ...
[09:31:19.930] receiveMessageFromWorker() for ClusterFuture ...
[09:31:19.930] - Validating connection of MultisessionFuture
[09:31:19.974] - received message: FutureResult
[09:31:19.974] - Received FutureResult
[09:31:19.974] - Erased future from FutureRegistry
[09:31:19.974] result() for ClusterFuture ...
[09:31:19.975] - result already collected: FutureResult
[09:31:19.975] result() for ClusterFuture ... done
[09:31:19.975] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:19.975] result() for ClusterFuture ... done
[09:31:19.975] result() for ClusterFuture ...
[09:31:19.975] - result already collected: FutureResult
[09:31:19.975] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[09:31:19.977] getGlobalsAndPackages() ...
[09:31:19.977] Searching for globals...
[09:31:19.978] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[09:31:19.978] Searching for globals ... DONE
[09:31:19.979] Resolving globals: FALSE
[09:31:19.979] The total size of the 2 globals is 896 bytes (896 bytes)
[09:31:19.979] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[09:31:19.980] - globals: [2] ‘weight’, ‘group’
[09:31:19.980] - packages: [1] ‘stats’
[09:31:19.980] getGlobalsAndPackages() ... DONE
[09:31:19.980] run() for ‘Future’ ...
[09:31:19.980] - state: ‘created’
[09:31:19.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:19.995] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:19.995] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:19.995]   - Field: ‘node’
[09:31:19.995]   - Field: ‘label’
[09:31:19.995]   - Field: ‘local’
[09:31:19.995]   - Field: ‘owner’
[09:31:19.996]   - Field: ‘envir’
[09:31:19.996]   - Field: ‘workers’
[09:31:19.996]   - Field: ‘packages’
[09:31:19.996]   - Field: ‘gc’
[09:31:19.996]   - Field: ‘conditions’
[09:31:19.996]   - Field: ‘persistent’
[09:31:19.996]   - Field: ‘expr’
[09:31:19.996]   - Field: ‘uuid’
[09:31:19.996]   - Field: ‘seed’
[09:31:19.996]   - Field: ‘version’
[09:31:19.996]   - Field: ‘result’
[09:31:19.997]   - Field: ‘asynchronous’
[09:31:19.997]   - Field: ‘calls’
[09:31:19.997]   - Field: ‘globals’
[09:31:19.997]   - Field: ‘stdout’
[09:31:19.997]   - Field: ‘earlySignal’
[09:31:19.997]   - Field: ‘lazy’
[09:31:19.997]   - Field: ‘state’
[09:31:19.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:19.997] - Launch lazy future ...
[09:31:19.998] Packages needed by the future expression (n = 1): ‘stats’
[09:31:19.998] Packages needed by future strategies (n = 0): <none>
[09:31:19.998] {
[09:31:19.998]     {
[09:31:19.998]         {
[09:31:19.998]             ...future.startTime <- base::Sys.time()
[09:31:19.998]             {
[09:31:19.998]                 {
[09:31:19.998]                   {
[09:31:19.998]                     {
[09:31:19.998]                       {
[09:31:19.998]                         base::local({
[09:31:19.998]                           has_future <- base::requireNamespace("future", 
[09:31:19.998]                             quietly = TRUE)
[09:31:19.998]                           if (has_future) {
[09:31:19.998]                             ns <- base::getNamespace("future")
[09:31:19.998]                             version <- ns[[".package"]][["version"]]
[09:31:19.998]                             if (is.null(version)) 
[09:31:19.998]                               version <- utils::packageVersion("future")
[09:31:19.998]                           }
[09:31:19.998]                           else {
[09:31:19.998]                             version <- NULL
[09:31:19.998]                           }
[09:31:19.998]                           if (!has_future || version < "1.8.0") {
[09:31:19.998]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:19.998]                               "", base::R.version$version.string), 
[09:31:19.998]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:19.998]                                 base::R.version$platform, 8 * 
[09:31:19.998]                                   base::.Machine$sizeof.pointer), 
[09:31:19.998]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:19.998]                                 "release", "version")], collapse = " "), 
[09:31:19.998]                               hostname = base::Sys.info()[["nodename"]])
[09:31:19.998]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:19.998]                               info)
[09:31:19.998]                             info <- base::paste(info, collapse = "; ")
[09:31:19.998]                             if (!has_future) {
[09:31:19.998]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:19.998]                                 info)
[09:31:19.998]                             }
[09:31:19.998]                             else {
[09:31:19.998]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:19.998]                                 info, version)
[09:31:19.998]                             }
[09:31:19.998]                             base::stop(msg)
[09:31:19.998]                           }
[09:31:19.998]                         })
[09:31:19.998]                       }
[09:31:19.998]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:19.998]                       base::options(mc.cores = 1L)
[09:31:19.998]                     }
[09:31:19.998]                     base::local({
[09:31:19.998]                       for (pkg in "stats") {
[09:31:19.998]                         base::loadNamespace(pkg)
[09:31:19.998]                         base::library(pkg, character.only = TRUE)
[09:31:19.998]                       }
[09:31:19.998]                     })
[09:31:19.998]                   }
[09:31:19.998]                   ...future.strategy.old <- future::plan("list")
[09:31:19.998]                   options(future.plan = NULL)
[09:31:19.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:19.998]                 }
[09:31:19.998]                 ...future.workdir <- getwd()
[09:31:19.998]             }
[09:31:19.998]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:19.998]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:19.998]         }
[09:31:19.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:19.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:19.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:19.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:19.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:19.998]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:19.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:19.998]             base::names(...future.oldOptions))
[09:31:19.998]     }
[09:31:19.998]     if (FALSE) {
[09:31:19.998]     }
[09:31:19.998]     else {
[09:31:19.998]         if (TRUE) {
[09:31:19.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:19.998]                 open = "w")
[09:31:19.998]         }
[09:31:19.998]         else {
[09:31:19.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:19.998]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:19.998]         }
[09:31:19.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:19.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:19.998]             base::sink(type = "output", split = FALSE)
[09:31:19.998]             base::close(...future.stdout)
[09:31:19.998]         }, add = TRUE)
[09:31:19.998]     }
[09:31:19.998]     ...future.frame <- base::sys.nframe()
[09:31:19.998]     ...future.conditions <- base::list()
[09:31:19.998]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:19.998]     if (FALSE) {
[09:31:19.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:19.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:19.998]     }
[09:31:19.998]     ...future.result <- base::tryCatch({
[09:31:19.998]         base::withCallingHandlers({
[09:31:19.998]             ...future.value <- base::withVisible(base::local({
[09:31:19.998]                 ...future.makeSendCondition <- base::local({
[09:31:19.998]                   sendCondition <- NULL
[09:31:19.998]                   function(frame = 1L) {
[09:31:19.998]                     if (is.function(sendCondition)) 
[09:31:19.998]                       return(sendCondition)
[09:31:19.998]                     ns <- getNamespace("parallel")
[09:31:19.998]                     if (exists("sendData", mode = "function", 
[09:31:19.998]                       envir = ns)) {
[09:31:19.998]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:19.998]                         envir = ns)
[09:31:19.998]                       envir <- sys.frame(frame)
[09:31:19.998]                       master <- NULL
[09:31:19.998]                       while (!identical(envir, .GlobalEnv) && 
[09:31:19.998]                         !identical(envir, emptyenv())) {
[09:31:19.998]                         if (exists("master", mode = "list", envir = envir, 
[09:31:19.998]                           inherits = FALSE)) {
[09:31:19.998]                           master <- get("master", mode = "list", 
[09:31:19.998]                             envir = envir, inherits = FALSE)
[09:31:19.998]                           if (inherits(master, c("SOCKnode", 
[09:31:19.998]                             "SOCK0node"))) {
[09:31:19.998]                             sendCondition <<- function(cond) {
[09:31:19.998]                               data <- list(type = "VALUE", value = cond, 
[09:31:19.998]                                 success = TRUE)
[09:31:19.998]                               parallel_sendData(master, data)
[09:31:19.998]                             }
[09:31:19.998]                             return(sendCondition)
[09:31:19.998]                           }
[09:31:19.998]                         }
[09:31:19.998]                         frame <- frame + 1L
[09:31:19.998]                         envir <- sys.frame(frame)
[09:31:19.998]                       }
[09:31:19.998]                     }
[09:31:19.998]                     sendCondition <<- function(cond) NULL
[09:31:19.998]                   }
[09:31:19.998]                 })
[09:31:19.998]                 withCallingHandlers({
[09:31:19.998]                   {
[09:31:19.998]                     lm(weight ~ group - 1)
[09:31:19.998]                   }
[09:31:19.998]                 }, immediateCondition = function(cond) {
[09:31:19.998]                   sendCondition <- ...future.makeSendCondition()
[09:31:19.998]                   sendCondition(cond)
[09:31:19.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.998]                   {
[09:31:19.998]                     inherits <- base::inherits
[09:31:19.998]                     invokeRestart <- base::invokeRestart
[09:31:19.998]                     is.null <- base::is.null
[09:31:19.998]                     muffled <- FALSE
[09:31:19.998]                     if (inherits(cond, "message")) {
[09:31:19.998]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:19.998]                       if (muffled) 
[09:31:19.998]                         invokeRestart("muffleMessage")
[09:31:19.998]                     }
[09:31:19.998]                     else if (inherits(cond, "warning")) {
[09:31:19.998]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:19.998]                       if (muffled) 
[09:31:19.998]                         invokeRestart("muffleWarning")
[09:31:19.998]                     }
[09:31:19.998]                     else if (inherits(cond, "condition")) {
[09:31:19.998]                       if (!is.null(pattern)) {
[09:31:19.998]                         computeRestarts <- base::computeRestarts
[09:31:19.998]                         grepl <- base::grepl
[09:31:19.998]                         restarts <- computeRestarts(cond)
[09:31:19.998]                         for (restart in restarts) {
[09:31:19.998]                           name <- restart$name
[09:31:19.998]                           if (is.null(name)) 
[09:31:19.998]                             next
[09:31:19.998]                           if (!grepl(pattern, name)) 
[09:31:19.998]                             next
[09:31:19.998]                           invokeRestart(restart)
[09:31:19.998]                           muffled <- TRUE
[09:31:19.998]                           break
[09:31:19.998]                         }
[09:31:19.998]                       }
[09:31:19.998]                     }
[09:31:19.998]                     invisible(muffled)
[09:31:19.998]                   }
[09:31:19.998]                   muffleCondition(cond)
[09:31:19.998]                 })
[09:31:19.998]             }))
[09:31:19.998]             future::FutureResult(value = ...future.value$value, 
[09:31:19.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.998]                   ...future.rng), globalenv = if (FALSE) 
[09:31:19.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:19.998]                     ...future.globalenv.names))
[09:31:19.998]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:19.998]         }, condition = base::local({
[09:31:19.998]             c <- base::c
[09:31:19.998]             inherits <- base::inherits
[09:31:19.998]             invokeRestart <- base::invokeRestart
[09:31:19.998]             length <- base::length
[09:31:19.998]             list <- base::list
[09:31:19.998]             seq.int <- base::seq.int
[09:31:19.998]             signalCondition <- base::signalCondition
[09:31:19.998]             sys.calls <- base::sys.calls
[09:31:19.998]             `[[` <- base::`[[`
[09:31:19.998]             `+` <- base::`+`
[09:31:19.998]             `<<-` <- base::`<<-`
[09:31:19.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:19.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:19.998]                   3L)]
[09:31:19.998]             }
[09:31:19.998]             function(cond) {
[09:31:19.998]                 is_error <- inherits(cond, "error")
[09:31:19.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:19.998]                   NULL)
[09:31:19.998]                 if (is_error) {
[09:31:19.998]                   sessionInformation <- function() {
[09:31:19.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:19.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:19.998]                       search = base::search(), system = base::Sys.info())
[09:31:19.998]                   }
[09:31:19.998]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:19.998]                     cond$call), session = sessionInformation(), 
[09:31:19.998]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:19.998]                   signalCondition(cond)
[09:31:19.998]                 }
[09:31:19.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:19.998]                 "immediateCondition"))) {
[09:31:19.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:19.998]                   ...future.conditions[[length(...future.conditions) + 
[09:31:19.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:19.998]                   if (TRUE && !signal) {
[09:31:19.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.998]                     {
[09:31:19.998]                       inherits <- base::inherits
[09:31:19.998]                       invokeRestart <- base::invokeRestart
[09:31:19.998]                       is.null <- base::is.null
[09:31:19.998]                       muffled <- FALSE
[09:31:19.998]                       if (inherits(cond, "message")) {
[09:31:19.998]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.998]                         if (muffled) 
[09:31:19.998]                           invokeRestart("muffleMessage")
[09:31:19.998]                       }
[09:31:19.998]                       else if (inherits(cond, "warning")) {
[09:31:19.998]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.998]                         if (muffled) 
[09:31:19.998]                           invokeRestart("muffleWarning")
[09:31:19.998]                       }
[09:31:19.998]                       else if (inherits(cond, "condition")) {
[09:31:19.998]                         if (!is.null(pattern)) {
[09:31:19.998]                           computeRestarts <- base::computeRestarts
[09:31:19.998]                           grepl <- base::grepl
[09:31:19.998]                           restarts <- computeRestarts(cond)
[09:31:19.998]                           for (restart in restarts) {
[09:31:19.998]                             name <- restart$name
[09:31:19.998]                             if (is.null(name)) 
[09:31:19.998]                               next
[09:31:19.998]                             if (!grepl(pattern, name)) 
[09:31:19.998]                               next
[09:31:19.998]                             invokeRestart(restart)
[09:31:19.998]                             muffled <- TRUE
[09:31:19.998]                             break
[09:31:19.998]                           }
[09:31:19.998]                         }
[09:31:19.998]                       }
[09:31:19.998]                       invisible(muffled)
[09:31:19.998]                     }
[09:31:19.998]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.998]                   }
[09:31:19.998]                 }
[09:31:19.998]                 else {
[09:31:19.998]                   if (TRUE) {
[09:31:19.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:19.998]                     {
[09:31:19.998]                       inherits <- base::inherits
[09:31:19.998]                       invokeRestart <- base::invokeRestart
[09:31:19.998]                       is.null <- base::is.null
[09:31:19.998]                       muffled <- FALSE
[09:31:19.998]                       if (inherits(cond, "message")) {
[09:31:19.998]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:19.998]                         if (muffled) 
[09:31:19.998]                           invokeRestart("muffleMessage")
[09:31:19.998]                       }
[09:31:19.998]                       else if (inherits(cond, "warning")) {
[09:31:19.998]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:19.998]                         if (muffled) 
[09:31:19.998]                           invokeRestart("muffleWarning")
[09:31:19.998]                       }
[09:31:19.998]                       else if (inherits(cond, "condition")) {
[09:31:19.998]                         if (!is.null(pattern)) {
[09:31:19.998]                           computeRestarts <- base::computeRestarts
[09:31:19.998]                           grepl <- base::grepl
[09:31:19.998]                           restarts <- computeRestarts(cond)
[09:31:19.998]                           for (restart in restarts) {
[09:31:19.998]                             name <- restart$name
[09:31:19.998]                             if (is.null(name)) 
[09:31:19.998]                               next
[09:31:19.998]                             if (!grepl(pattern, name)) 
[09:31:19.998]                               next
[09:31:19.998]                             invokeRestart(restart)
[09:31:19.998]                             muffled <- TRUE
[09:31:19.998]                             break
[09:31:19.998]                           }
[09:31:19.998]                         }
[09:31:19.998]                       }
[09:31:19.998]                       invisible(muffled)
[09:31:19.998]                     }
[09:31:19.998]                     muffleCondition(cond, pattern = "^muffle")
[09:31:19.998]                   }
[09:31:19.998]                 }
[09:31:19.998]             }
[09:31:19.998]         }))
[09:31:19.998]     }, error = function(ex) {
[09:31:19.998]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:19.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:19.998]                 ...future.rng), started = ...future.startTime, 
[09:31:19.998]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:19.998]             version = "1.8"), class = "FutureResult")
[09:31:19.998]     }, finally = {
[09:31:19.998]         if (!identical(...future.workdir, getwd())) 
[09:31:19.998]             setwd(...future.workdir)
[09:31:19.998]         {
[09:31:19.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:19.998]                 ...future.oldOptions$nwarnings <- NULL
[09:31:19.998]             }
[09:31:19.998]             base::options(...future.oldOptions)
[09:31:19.998]             if (.Platform$OS.type == "windows") {
[09:31:19.998]                 old_names <- names(...future.oldEnvVars)
[09:31:19.998]                 envs <- base::Sys.getenv()
[09:31:19.998]                 names <- names(envs)
[09:31:19.998]                 common <- intersect(names, old_names)
[09:31:19.998]                 added <- setdiff(names, old_names)
[09:31:19.998]                 removed <- setdiff(old_names, names)
[09:31:19.998]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:19.998]                   envs[common]]
[09:31:19.998]                 NAMES <- toupper(changed)
[09:31:19.998]                 args <- list()
[09:31:19.998]                 for (kk in seq_along(NAMES)) {
[09:31:19.998]                   name <- changed[[kk]]
[09:31:19.998]                   NAME <- NAMES[[kk]]
[09:31:19.998]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.998]                     next
[09:31:19.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.998]                 }
[09:31:19.998]                 NAMES <- toupper(added)
[09:31:19.998]                 for (kk in seq_along(NAMES)) {
[09:31:19.998]                   name <- added[[kk]]
[09:31:19.998]                   NAME <- NAMES[[kk]]
[09:31:19.998]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.998]                     next
[09:31:19.998]                   args[[name]] <- ""
[09:31:19.998]                 }
[09:31:19.998]                 NAMES <- toupper(removed)
[09:31:19.998]                 for (kk in seq_along(NAMES)) {
[09:31:19.998]                   name <- removed[[kk]]
[09:31:19.998]                   NAME <- NAMES[[kk]]
[09:31:19.998]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:19.998]                     next
[09:31:19.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:19.998]                 }
[09:31:19.998]                 if (length(args) > 0) 
[09:31:19.998]                   base::do.call(base::Sys.setenv, args = args)
[09:31:19.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:19.998]             }
[09:31:19.998]             else {
[09:31:19.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:19.998]             }
[09:31:19.998]             {
[09:31:19.998]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:19.998]                   0L) {
[09:31:19.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:19.998]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:19.998]                   base::options(opts)
[09:31:19.998]                 }
[09:31:19.998]                 {
[09:31:19.998]                   {
[09:31:19.998]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:19.998]                     NULL
[09:31:19.998]                   }
[09:31:19.998]                   options(future.plan = NULL)
[09:31:19.998]                   if (is.na(NA_character_)) 
[09:31:19.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:19.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:19.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:19.998]                     .init = FALSE)
[09:31:19.998]                 }
[09:31:19.998]             }
[09:31:19.998]         }
[09:31:19.998]     })
[09:31:19.998]     if (TRUE) {
[09:31:19.998]         base::sink(type = "output", split = FALSE)
[09:31:19.998]         if (TRUE) {
[09:31:19.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:19.998]         }
[09:31:19.998]         else {
[09:31:19.998]             ...future.result["stdout"] <- base::list(NULL)
[09:31:19.998]         }
[09:31:19.998]         base::close(...future.stdout)
[09:31:19.998]         ...future.stdout <- NULL
[09:31:19.998]     }
[09:31:19.998]     ...future.result$conditions <- ...future.conditions
[09:31:19.998]     ...future.result$finished <- base::Sys.time()
[09:31:19.998]     ...future.result
[09:31:19.998] }
[09:31:20.001] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[09:31:20.001] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[09:31:20.001] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[09:31:20.001] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[09:31:20.002] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[09:31:20.002] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[09:31:20.002] MultisessionFuture started
[09:31:20.002] - Launch lazy future ... done
[09:31:20.002] run() for ‘MultisessionFuture’ ... done
[09:31:20.002] result() for ClusterFuture ...
[09:31:20.002] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.003] - Validating connection of MultisessionFuture
[09:31:20.046] - received message: FutureResult
[09:31:20.046] - Received FutureResult
[09:31:20.046] - Erased future from FutureRegistry
[09:31:20.046] result() for ClusterFuture ...
[09:31:20.046] - result already collected: FutureResult
[09:31:20.047] result() for ClusterFuture ... done
[09:31:20.047] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.047] result() for ClusterFuture ... done
[09:31:20.047] result() for ClusterFuture ...
[09:31:20.047] - result already collected: FutureResult
[09:31:20.047] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[09:31:20.049] getGlobalsAndPackages() ...
[09:31:20.049] Searching for globals...
[09:31:20.050] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[09:31:20.050] Searching for globals ... DONE
[09:31:20.050] Resolving globals: FALSE
[09:31:20.050] The total size of the 1 globals is 96 bytes (96 bytes)
[09:31:20.051] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[09:31:20.051] - globals: [1] ‘x’
[09:31:20.051] - packages: [1] ‘stats’
[09:31:20.051] getGlobalsAndPackages() ... DONE
[09:31:20.051] run() for ‘Future’ ...
[09:31:20.051] - state: ‘created’
[09:31:20.052] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.065]   - Field: ‘node’
[09:31:20.065]   - Field: ‘label’
[09:31:20.065]   - Field: ‘local’
[09:31:20.065]   - Field: ‘owner’
[09:31:20.065]   - Field: ‘envir’
[09:31:20.065]   - Field: ‘workers’
[09:31:20.066]   - Field: ‘packages’
[09:31:20.066]   - Field: ‘gc’
[09:31:20.066]   - Field: ‘conditions’
[09:31:20.066]   - Field: ‘persistent’
[09:31:20.066]   - Field: ‘expr’
[09:31:20.066]   - Field: ‘uuid’
[09:31:20.066]   - Field: ‘seed’
[09:31:20.066]   - Field: ‘version’
[09:31:20.066]   - Field: ‘result’
[09:31:20.066]   - Field: ‘asynchronous’
[09:31:20.067]   - Field: ‘calls’
[09:31:20.067]   - Field: ‘globals’
[09:31:20.067]   - Field: ‘stdout’
[09:31:20.067]   - Field: ‘earlySignal’
[09:31:20.067]   - Field: ‘lazy’
[09:31:20.067]   - Field: ‘state’
[09:31:20.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.067] - Launch lazy future ...
[09:31:20.067] Packages needed by the future expression (n = 1): ‘stats’
[09:31:20.068] Packages needed by future strategies (n = 0): <none>
[09:31:20.068] {
[09:31:20.068]     {
[09:31:20.068]         {
[09:31:20.068]             ...future.startTime <- base::Sys.time()
[09:31:20.068]             {
[09:31:20.068]                 {
[09:31:20.068]                   {
[09:31:20.068]                     {
[09:31:20.068]                       {
[09:31:20.068]                         base::local({
[09:31:20.068]                           has_future <- base::requireNamespace("future", 
[09:31:20.068]                             quietly = TRUE)
[09:31:20.068]                           if (has_future) {
[09:31:20.068]                             ns <- base::getNamespace("future")
[09:31:20.068]                             version <- ns[[".package"]][["version"]]
[09:31:20.068]                             if (is.null(version)) 
[09:31:20.068]                               version <- utils::packageVersion("future")
[09:31:20.068]                           }
[09:31:20.068]                           else {
[09:31:20.068]                             version <- NULL
[09:31:20.068]                           }
[09:31:20.068]                           if (!has_future || version < "1.8.0") {
[09:31:20.068]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.068]                               "", base::R.version$version.string), 
[09:31:20.068]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.068]                                 base::R.version$platform, 8 * 
[09:31:20.068]                                   base::.Machine$sizeof.pointer), 
[09:31:20.068]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.068]                                 "release", "version")], collapse = " "), 
[09:31:20.068]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.068]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.068]                               info)
[09:31:20.068]                             info <- base::paste(info, collapse = "; ")
[09:31:20.068]                             if (!has_future) {
[09:31:20.068]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.068]                                 info)
[09:31:20.068]                             }
[09:31:20.068]                             else {
[09:31:20.068]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.068]                                 info, version)
[09:31:20.068]                             }
[09:31:20.068]                             base::stop(msg)
[09:31:20.068]                           }
[09:31:20.068]                         })
[09:31:20.068]                       }
[09:31:20.068]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.068]                       base::options(mc.cores = 1L)
[09:31:20.068]                     }
[09:31:20.068]                     base::local({
[09:31:20.068]                       for (pkg in "stats") {
[09:31:20.068]                         base::loadNamespace(pkg)
[09:31:20.068]                         base::library(pkg, character.only = TRUE)
[09:31:20.068]                       }
[09:31:20.068]                     })
[09:31:20.068]                   }
[09:31:20.068]                   ...future.strategy.old <- future::plan("list")
[09:31:20.068]                   options(future.plan = NULL)
[09:31:20.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.068]                 }
[09:31:20.068]                 ...future.workdir <- getwd()
[09:31:20.068]             }
[09:31:20.068]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.068]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.068]         }
[09:31:20.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.068]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.068]             base::names(...future.oldOptions))
[09:31:20.068]     }
[09:31:20.068]     if (FALSE) {
[09:31:20.068]     }
[09:31:20.068]     else {
[09:31:20.068]         if (TRUE) {
[09:31:20.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.068]                 open = "w")
[09:31:20.068]         }
[09:31:20.068]         else {
[09:31:20.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.068]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.068]         }
[09:31:20.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.068]             base::sink(type = "output", split = FALSE)
[09:31:20.068]             base::close(...future.stdout)
[09:31:20.068]         }, add = TRUE)
[09:31:20.068]     }
[09:31:20.068]     ...future.frame <- base::sys.nframe()
[09:31:20.068]     ...future.conditions <- base::list()
[09:31:20.068]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.068]     if (FALSE) {
[09:31:20.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.068]     }
[09:31:20.068]     ...future.result <- base::tryCatch({
[09:31:20.068]         base::withCallingHandlers({
[09:31:20.068]             ...future.value <- base::withVisible(base::local({
[09:31:20.068]                 ...future.makeSendCondition <- base::local({
[09:31:20.068]                   sendCondition <- NULL
[09:31:20.068]                   function(frame = 1L) {
[09:31:20.068]                     if (is.function(sendCondition)) 
[09:31:20.068]                       return(sendCondition)
[09:31:20.068]                     ns <- getNamespace("parallel")
[09:31:20.068]                     if (exists("sendData", mode = "function", 
[09:31:20.068]                       envir = ns)) {
[09:31:20.068]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.068]                         envir = ns)
[09:31:20.068]                       envir <- sys.frame(frame)
[09:31:20.068]                       master <- NULL
[09:31:20.068]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.068]                         !identical(envir, emptyenv())) {
[09:31:20.068]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.068]                           inherits = FALSE)) {
[09:31:20.068]                           master <- get("master", mode = "list", 
[09:31:20.068]                             envir = envir, inherits = FALSE)
[09:31:20.068]                           if (inherits(master, c("SOCKnode", 
[09:31:20.068]                             "SOCK0node"))) {
[09:31:20.068]                             sendCondition <<- function(cond) {
[09:31:20.068]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.068]                                 success = TRUE)
[09:31:20.068]                               parallel_sendData(master, data)
[09:31:20.068]                             }
[09:31:20.068]                             return(sendCondition)
[09:31:20.068]                           }
[09:31:20.068]                         }
[09:31:20.068]                         frame <- frame + 1L
[09:31:20.068]                         envir <- sys.frame(frame)
[09:31:20.068]                       }
[09:31:20.068]                     }
[09:31:20.068]                     sendCondition <<- function(cond) NULL
[09:31:20.068]                   }
[09:31:20.068]                 })
[09:31:20.068]                 withCallingHandlers({
[09:31:20.068]                   {
[09:31:20.068]                     xtabs(~x)
[09:31:20.068]                   }
[09:31:20.068]                 }, immediateCondition = function(cond) {
[09:31:20.068]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.068]                   sendCondition(cond)
[09:31:20.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.068]                   {
[09:31:20.068]                     inherits <- base::inherits
[09:31:20.068]                     invokeRestart <- base::invokeRestart
[09:31:20.068]                     is.null <- base::is.null
[09:31:20.068]                     muffled <- FALSE
[09:31:20.068]                     if (inherits(cond, "message")) {
[09:31:20.068]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.068]                       if (muffled) 
[09:31:20.068]                         invokeRestart("muffleMessage")
[09:31:20.068]                     }
[09:31:20.068]                     else if (inherits(cond, "warning")) {
[09:31:20.068]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.068]                       if (muffled) 
[09:31:20.068]                         invokeRestart("muffleWarning")
[09:31:20.068]                     }
[09:31:20.068]                     else if (inherits(cond, "condition")) {
[09:31:20.068]                       if (!is.null(pattern)) {
[09:31:20.068]                         computeRestarts <- base::computeRestarts
[09:31:20.068]                         grepl <- base::grepl
[09:31:20.068]                         restarts <- computeRestarts(cond)
[09:31:20.068]                         for (restart in restarts) {
[09:31:20.068]                           name <- restart$name
[09:31:20.068]                           if (is.null(name)) 
[09:31:20.068]                             next
[09:31:20.068]                           if (!grepl(pattern, name)) 
[09:31:20.068]                             next
[09:31:20.068]                           invokeRestart(restart)
[09:31:20.068]                           muffled <- TRUE
[09:31:20.068]                           break
[09:31:20.068]                         }
[09:31:20.068]                       }
[09:31:20.068]                     }
[09:31:20.068]                     invisible(muffled)
[09:31:20.068]                   }
[09:31:20.068]                   muffleCondition(cond)
[09:31:20.068]                 })
[09:31:20.068]             }))
[09:31:20.068]             future::FutureResult(value = ...future.value$value, 
[09:31:20.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.068]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.068]                     ...future.globalenv.names))
[09:31:20.068]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.068]         }, condition = base::local({
[09:31:20.068]             c <- base::c
[09:31:20.068]             inherits <- base::inherits
[09:31:20.068]             invokeRestart <- base::invokeRestart
[09:31:20.068]             length <- base::length
[09:31:20.068]             list <- base::list
[09:31:20.068]             seq.int <- base::seq.int
[09:31:20.068]             signalCondition <- base::signalCondition
[09:31:20.068]             sys.calls <- base::sys.calls
[09:31:20.068]             `[[` <- base::`[[`
[09:31:20.068]             `+` <- base::`+`
[09:31:20.068]             `<<-` <- base::`<<-`
[09:31:20.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.068]                   3L)]
[09:31:20.068]             }
[09:31:20.068]             function(cond) {
[09:31:20.068]                 is_error <- inherits(cond, "error")
[09:31:20.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.068]                   NULL)
[09:31:20.068]                 if (is_error) {
[09:31:20.068]                   sessionInformation <- function() {
[09:31:20.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.068]                       search = base::search(), system = base::Sys.info())
[09:31:20.068]                   }
[09:31:20.068]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.068]                     cond$call), session = sessionInformation(), 
[09:31:20.068]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.068]                   signalCondition(cond)
[09:31:20.068]                 }
[09:31:20.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.068]                 "immediateCondition"))) {
[09:31:20.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.068]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.068]                   if (TRUE && !signal) {
[09:31:20.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.068]                     {
[09:31:20.068]                       inherits <- base::inherits
[09:31:20.068]                       invokeRestart <- base::invokeRestart
[09:31:20.068]                       is.null <- base::is.null
[09:31:20.068]                       muffled <- FALSE
[09:31:20.068]                       if (inherits(cond, "message")) {
[09:31:20.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.068]                         if (muffled) 
[09:31:20.068]                           invokeRestart("muffleMessage")
[09:31:20.068]                       }
[09:31:20.068]                       else if (inherits(cond, "warning")) {
[09:31:20.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.068]                         if (muffled) 
[09:31:20.068]                           invokeRestart("muffleWarning")
[09:31:20.068]                       }
[09:31:20.068]                       else if (inherits(cond, "condition")) {
[09:31:20.068]                         if (!is.null(pattern)) {
[09:31:20.068]                           computeRestarts <- base::computeRestarts
[09:31:20.068]                           grepl <- base::grepl
[09:31:20.068]                           restarts <- computeRestarts(cond)
[09:31:20.068]                           for (restart in restarts) {
[09:31:20.068]                             name <- restart$name
[09:31:20.068]                             if (is.null(name)) 
[09:31:20.068]                               next
[09:31:20.068]                             if (!grepl(pattern, name)) 
[09:31:20.068]                               next
[09:31:20.068]                             invokeRestart(restart)
[09:31:20.068]                             muffled <- TRUE
[09:31:20.068]                             break
[09:31:20.068]                           }
[09:31:20.068]                         }
[09:31:20.068]                       }
[09:31:20.068]                       invisible(muffled)
[09:31:20.068]                     }
[09:31:20.068]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.068]                   }
[09:31:20.068]                 }
[09:31:20.068]                 else {
[09:31:20.068]                   if (TRUE) {
[09:31:20.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.068]                     {
[09:31:20.068]                       inherits <- base::inherits
[09:31:20.068]                       invokeRestart <- base::invokeRestart
[09:31:20.068]                       is.null <- base::is.null
[09:31:20.068]                       muffled <- FALSE
[09:31:20.068]                       if (inherits(cond, "message")) {
[09:31:20.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.068]                         if (muffled) 
[09:31:20.068]                           invokeRestart("muffleMessage")
[09:31:20.068]                       }
[09:31:20.068]                       else if (inherits(cond, "warning")) {
[09:31:20.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.068]                         if (muffled) 
[09:31:20.068]                           invokeRestart("muffleWarning")
[09:31:20.068]                       }
[09:31:20.068]                       else if (inherits(cond, "condition")) {
[09:31:20.068]                         if (!is.null(pattern)) {
[09:31:20.068]                           computeRestarts <- base::computeRestarts
[09:31:20.068]                           grepl <- base::grepl
[09:31:20.068]                           restarts <- computeRestarts(cond)
[09:31:20.068]                           for (restart in restarts) {
[09:31:20.068]                             name <- restart$name
[09:31:20.068]                             if (is.null(name)) 
[09:31:20.068]                               next
[09:31:20.068]                             if (!grepl(pattern, name)) 
[09:31:20.068]                               next
[09:31:20.068]                             invokeRestart(restart)
[09:31:20.068]                             muffled <- TRUE
[09:31:20.068]                             break
[09:31:20.068]                           }
[09:31:20.068]                         }
[09:31:20.068]                       }
[09:31:20.068]                       invisible(muffled)
[09:31:20.068]                     }
[09:31:20.068]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.068]                   }
[09:31:20.068]                 }
[09:31:20.068]             }
[09:31:20.068]         }))
[09:31:20.068]     }, error = function(ex) {
[09:31:20.068]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.068]                 ...future.rng), started = ...future.startTime, 
[09:31:20.068]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.068]             version = "1.8"), class = "FutureResult")
[09:31:20.068]     }, finally = {
[09:31:20.068]         if (!identical(...future.workdir, getwd())) 
[09:31:20.068]             setwd(...future.workdir)
[09:31:20.068]         {
[09:31:20.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.068]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.068]             }
[09:31:20.068]             base::options(...future.oldOptions)
[09:31:20.068]             if (.Platform$OS.type == "windows") {
[09:31:20.068]                 old_names <- names(...future.oldEnvVars)
[09:31:20.068]                 envs <- base::Sys.getenv()
[09:31:20.068]                 names <- names(envs)
[09:31:20.068]                 common <- intersect(names, old_names)
[09:31:20.068]                 added <- setdiff(names, old_names)
[09:31:20.068]                 removed <- setdiff(old_names, names)
[09:31:20.068]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.068]                   envs[common]]
[09:31:20.068]                 NAMES <- toupper(changed)
[09:31:20.068]                 args <- list()
[09:31:20.068]                 for (kk in seq_along(NAMES)) {
[09:31:20.068]                   name <- changed[[kk]]
[09:31:20.068]                   NAME <- NAMES[[kk]]
[09:31:20.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.068]                     next
[09:31:20.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.068]                 }
[09:31:20.068]                 NAMES <- toupper(added)
[09:31:20.068]                 for (kk in seq_along(NAMES)) {
[09:31:20.068]                   name <- added[[kk]]
[09:31:20.068]                   NAME <- NAMES[[kk]]
[09:31:20.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.068]                     next
[09:31:20.068]                   args[[name]] <- ""
[09:31:20.068]                 }
[09:31:20.068]                 NAMES <- toupper(removed)
[09:31:20.068]                 for (kk in seq_along(NAMES)) {
[09:31:20.068]                   name <- removed[[kk]]
[09:31:20.068]                   NAME <- NAMES[[kk]]
[09:31:20.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.068]                     next
[09:31:20.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.068]                 }
[09:31:20.068]                 if (length(args) > 0) 
[09:31:20.068]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.068]             }
[09:31:20.068]             else {
[09:31:20.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.068]             }
[09:31:20.068]             {
[09:31:20.068]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.068]                   0L) {
[09:31:20.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.068]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.068]                   base::options(opts)
[09:31:20.068]                 }
[09:31:20.068]                 {
[09:31:20.068]                   {
[09:31:20.068]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.068]                     NULL
[09:31:20.068]                   }
[09:31:20.068]                   options(future.plan = NULL)
[09:31:20.068]                   if (is.na(NA_character_)) 
[09:31:20.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.068]                     .init = FALSE)
[09:31:20.068]                 }
[09:31:20.068]             }
[09:31:20.068]         }
[09:31:20.068]     })
[09:31:20.068]     if (TRUE) {
[09:31:20.068]         base::sink(type = "output", split = FALSE)
[09:31:20.068]         if (TRUE) {
[09:31:20.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.068]         }
[09:31:20.068]         else {
[09:31:20.068]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.068]         }
[09:31:20.068]         base::close(...future.stdout)
[09:31:20.068]         ...future.stdout <- NULL
[09:31:20.068]     }
[09:31:20.068]     ...future.result$conditions <- ...future.conditions
[09:31:20.068]     ...future.result$finished <- base::Sys.time()
[09:31:20.068]     ...future.result
[09:31:20.068] }
[09:31:20.070] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[09:31:20.071] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[09:31:20.071] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[09:31:20.071] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[09:31:20.071] MultisessionFuture started
[09:31:20.072] - Launch lazy future ... done
[09:31:20.072] run() for ‘MultisessionFuture’ ... done
[09:31:20.072] result() for ClusterFuture ...
[09:31:20.072] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.072] - Validating connection of MultisessionFuture
[09:31:20.114] - received message: FutureResult
[09:31:20.114] - Received FutureResult
[09:31:20.114] - Erased future from FutureRegistry
[09:31:20.114] result() for ClusterFuture ...
[09:31:20.115] - result already collected: FutureResult
[09:31:20.115] result() for ClusterFuture ... done
[09:31:20.115] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.115] result() for ClusterFuture ... done
[09:31:20.115] result() for ClusterFuture ...
[09:31:20.115] - result already collected: FutureResult
[09:31:20.115] result() for ClusterFuture ... done
x
1 2 
2 3 
[09:31:20.116] getGlobalsAndPackages() ...
[09:31:20.116] Searching for globals...
[09:31:20.117] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[09:31:20.117] Searching for globals ... DONE
[09:31:20.117] Resolving globals: FALSE
[09:31:20.117] The total size of the 1 globals is 96 bytes (96 bytes)
[09:31:20.118] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[09:31:20.118] - globals: [1] ‘x’
[09:31:20.118] - packages: [1] ‘stats’
[09:31:20.118] getGlobalsAndPackages() ... DONE
[09:31:20.118] run() for ‘Future’ ...
[09:31:20.118] - state: ‘created’
[09:31:20.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.132]   - Field: ‘node’
[09:31:20.132]   - Field: ‘label’
[09:31:20.132]   - Field: ‘local’
[09:31:20.132]   - Field: ‘owner’
[09:31:20.133]   - Field: ‘envir’
[09:31:20.133]   - Field: ‘workers’
[09:31:20.133]   - Field: ‘packages’
[09:31:20.133]   - Field: ‘gc’
[09:31:20.133]   - Field: ‘conditions’
[09:31:20.133]   - Field: ‘persistent’
[09:31:20.133]   - Field: ‘expr’
[09:31:20.133]   - Field: ‘uuid’
[09:31:20.133]   - Field: ‘seed’
[09:31:20.133]   - Field: ‘version’
[09:31:20.133]   - Field: ‘result’
[09:31:20.134]   - Field: ‘asynchronous’
[09:31:20.134]   - Field: ‘calls’
[09:31:20.134]   - Field: ‘globals’
[09:31:20.134]   - Field: ‘stdout’
[09:31:20.134]   - Field: ‘earlySignal’
[09:31:20.134]   - Field: ‘lazy’
[09:31:20.134]   - Field: ‘state’
[09:31:20.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.134] - Launch lazy future ...
[09:31:20.135] Packages needed by the future expression (n = 1): ‘stats’
[09:31:20.135] Packages needed by future strategies (n = 0): <none>
[09:31:20.135] {
[09:31:20.135]     {
[09:31:20.135]         {
[09:31:20.135]             ...future.startTime <- base::Sys.time()
[09:31:20.135]             {
[09:31:20.135]                 {
[09:31:20.135]                   {
[09:31:20.135]                     {
[09:31:20.135]                       {
[09:31:20.135]                         base::local({
[09:31:20.135]                           has_future <- base::requireNamespace("future", 
[09:31:20.135]                             quietly = TRUE)
[09:31:20.135]                           if (has_future) {
[09:31:20.135]                             ns <- base::getNamespace("future")
[09:31:20.135]                             version <- ns[[".package"]][["version"]]
[09:31:20.135]                             if (is.null(version)) 
[09:31:20.135]                               version <- utils::packageVersion("future")
[09:31:20.135]                           }
[09:31:20.135]                           else {
[09:31:20.135]                             version <- NULL
[09:31:20.135]                           }
[09:31:20.135]                           if (!has_future || version < "1.8.0") {
[09:31:20.135]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.135]                               "", base::R.version$version.string), 
[09:31:20.135]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.135]                                 base::R.version$platform, 8 * 
[09:31:20.135]                                   base::.Machine$sizeof.pointer), 
[09:31:20.135]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.135]                                 "release", "version")], collapse = " "), 
[09:31:20.135]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.135]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.135]                               info)
[09:31:20.135]                             info <- base::paste(info, collapse = "; ")
[09:31:20.135]                             if (!has_future) {
[09:31:20.135]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.135]                                 info)
[09:31:20.135]                             }
[09:31:20.135]                             else {
[09:31:20.135]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.135]                                 info, version)
[09:31:20.135]                             }
[09:31:20.135]                             base::stop(msg)
[09:31:20.135]                           }
[09:31:20.135]                         })
[09:31:20.135]                       }
[09:31:20.135]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.135]                       base::options(mc.cores = 1L)
[09:31:20.135]                     }
[09:31:20.135]                     base::local({
[09:31:20.135]                       for (pkg in "stats") {
[09:31:20.135]                         base::loadNamespace(pkg)
[09:31:20.135]                         base::library(pkg, character.only = TRUE)
[09:31:20.135]                       }
[09:31:20.135]                     })
[09:31:20.135]                   }
[09:31:20.135]                   ...future.strategy.old <- future::plan("list")
[09:31:20.135]                   options(future.plan = NULL)
[09:31:20.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.135]                 }
[09:31:20.135]                 ...future.workdir <- getwd()
[09:31:20.135]             }
[09:31:20.135]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.135]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.135]         }
[09:31:20.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.135]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.135]             base::names(...future.oldOptions))
[09:31:20.135]     }
[09:31:20.135]     if (FALSE) {
[09:31:20.135]     }
[09:31:20.135]     else {
[09:31:20.135]         if (TRUE) {
[09:31:20.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.135]                 open = "w")
[09:31:20.135]         }
[09:31:20.135]         else {
[09:31:20.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.135]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.135]         }
[09:31:20.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.135]             base::sink(type = "output", split = FALSE)
[09:31:20.135]             base::close(...future.stdout)
[09:31:20.135]         }, add = TRUE)
[09:31:20.135]     }
[09:31:20.135]     ...future.frame <- base::sys.nframe()
[09:31:20.135]     ...future.conditions <- base::list()
[09:31:20.135]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.135]     if (FALSE) {
[09:31:20.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.135]     }
[09:31:20.135]     ...future.result <- base::tryCatch({
[09:31:20.135]         base::withCallingHandlers({
[09:31:20.135]             ...future.value <- base::withVisible(base::local({
[09:31:20.135]                 ...future.makeSendCondition <- base::local({
[09:31:20.135]                   sendCondition <- NULL
[09:31:20.135]                   function(frame = 1L) {
[09:31:20.135]                     if (is.function(sendCondition)) 
[09:31:20.135]                       return(sendCondition)
[09:31:20.135]                     ns <- getNamespace("parallel")
[09:31:20.135]                     if (exists("sendData", mode = "function", 
[09:31:20.135]                       envir = ns)) {
[09:31:20.135]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.135]                         envir = ns)
[09:31:20.135]                       envir <- sys.frame(frame)
[09:31:20.135]                       master <- NULL
[09:31:20.135]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.135]                         !identical(envir, emptyenv())) {
[09:31:20.135]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.135]                           inherits = FALSE)) {
[09:31:20.135]                           master <- get("master", mode = "list", 
[09:31:20.135]                             envir = envir, inherits = FALSE)
[09:31:20.135]                           if (inherits(master, c("SOCKnode", 
[09:31:20.135]                             "SOCK0node"))) {
[09:31:20.135]                             sendCondition <<- function(cond) {
[09:31:20.135]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.135]                                 success = TRUE)
[09:31:20.135]                               parallel_sendData(master, data)
[09:31:20.135]                             }
[09:31:20.135]                             return(sendCondition)
[09:31:20.135]                           }
[09:31:20.135]                         }
[09:31:20.135]                         frame <- frame + 1L
[09:31:20.135]                         envir <- sys.frame(frame)
[09:31:20.135]                       }
[09:31:20.135]                     }
[09:31:20.135]                     sendCondition <<- function(cond) NULL
[09:31:20.135]                   }
[09:31:20.135]                 })
[09:31:20.135]                 withCallingHandlers({
[09:31:20.135]                   {
[09:31:20.135]                     xtabs(~x)
[09:31:20.135]                   }
[09:31:20.135]                 }, immediateCondition = function(cond) {
[09:31:20.135]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.135]                   sendCondition(cond)
[09:31:20.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.135]                   {
[09:31:20.135]                     inherits <- base::inherits
[09:31:20.135]                     invokeRestart <- base::invokeRestart
[09:31:20.135]                     is.null <- base::is.null
[09:31:20.135]                     muffled <- FALSE
[09:31:20.135]                     if (inherits(cond, "message")) {
[09:31:20.135]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.135]                       if (muffled) 
[09:31:20.135]                         invokeRestart("muffleMessage")
[09:31:20.135]                     }
[09:31:20.135]                     else if (inherits(cond, "warning")) {
[09:31:20.135]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.135]                       if (muffled) 
[09:31:20.135]                         invokeRestart("muffleWarning")
[09:31:20.135]                     }
[09:31:20.135]                     else if (inherits(cond, "condition")) {
[09:31:20.135]                       if (!is.null(pattern)) {
[09:31:20.135]                         computeRestarts <- base::computeRestarts
[09:31:20.135]                         grepl <- base::grepl
[09:31:20.135]                         restarts <- computeRestarts(cond)
[09:31:20.135]                         for (restart in restarts) {
[09:31:20.135]                           name <- restart$name
[09:31:20.135]                           if (is.null(name)) 
[09:31:20.135]                             next
[09:31:20.135]                           if (!grepl(pattern, name)) 
[09:31:20.135]                             next
[09:31:20.135]                           invokeRestart(restart)
[09:31:20.135]                           muffled <- TRUE
[09:31:20.135]                           break
[09:31:20.135]                         }
[09:31:20.135]                       }
[09:31:20.135]                     }
[09:31:20.135]                     invisible(muffled)
[09:31:20.135]                   }
[09:31:20.135]                   muffleCondition(cond)
[09:31:20.135]                 })
[09:31:20.135]             }))
[09:31:20.135]             future::FutureResult(value = ...future.value$value, 
[09:31:20.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.135]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.135]                     ...future.globalenv.names))
[09:31:20.135]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.135]         }, condition = base::local({
[09:31:20.135]             c <- base::c
[09:31:20.135]             inherits <- base::inherits
[09:31:20.135]             invokeRestart <- base::invokeRestart
[09:31:20.135]             length <- base::length
[09:31:20.135]             list <- base::list
[09:31:20.135]             seq.int <- base::seq.int
[09:31:20.135]             signalCondition <- base::signalCondition
[09:31:20.135]             sys.calls <- base::sys.calls
[09:31:20.135]             `[[` <- base::`[[`
[09:31:20.135]             `+` <- base::`+`
[09:31:20.135]             `<<-` <- base::`<<-`
[09:31:20.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.135]                   3L)]
[09:31:20.135]             }
[09:31:20.135]             function(cond) {
[09:31:20.135]                 is_error <- inherits(cond, "error")
[09:31:20.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.135]                   NULL)
[09:31:20.135]                 if (is_error) {
[09:31:20.135]                   sessionInformation <- function() {
[09:31:20.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.135]                       search = base::search(), system = base::Sys.info())
[09:31:20.135]                   }
[09:31:20.135]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.135]                     cond$call), session = sessionInformation(), 
[09:31:20.135]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.135]                   signalCondition(cond)
[09:31:20.135]                 }
[09:31:20.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.135]                 "immediateCondition"))) {
[09:31:20.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.135]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.135]                   if (TRUE && !signal) {
[09:31:20.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.135]                     {
[09:31:20.135]                       inherits <- base::inherits
[09:31:20.135]                       invokeRestart <- base::invokeRestart
[09:31:20.135]                       is.null <- base::is.null
[09:31:20.135]                       muffled <- FALSE
[09:31:20.135]                       if (inherits(cond, "message")) {
[09:31:20.135]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.135]                         if (muffled) 
[09:31:20.135]                           invokeRestart("muffleMessage")
[09:31:20.135]                       }
[09:31:20.135]                       else if (inherits(cond, "warning")) {
[09:31:20.135]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.135]                         if (muffled) 
[09:31:20.135]                           invokeRestart("muffleWarning")
[09:31:20.135]                       }
[09:31:20.135]                       else if (inherits(cond, "condition")) {
[09:31:20.135]                         if (!is.null(pattern)) {
[09:31:20.135]                           computeRestarts <- base::computeRestarts
[09:31:20.135]                           grepl <- base::grepl
[09:31:20.135]                           restarts <- computeRestarts(cond)
[09:31:20.135]                           for (restart in restarts) {
[09:31:20.135]                             name <- restart$name
[09:31:20.135]                             if (is.null(name)) 
[09:31:20.135]                               next
[09:31:20.135]                             if (!grepl(pattern, name)) 
[09:31:20.135]                               next
[09:31:20.135]                             invokeRestart(restart)
[09:31:20.135]                             muffled <- TRUE
[09:31:20.135]                             break
[09:31:20.135]                           }
[09:31:20.135]                         }
[09:31:20.135]                       }
[09:31:20.135]                       invisible(muffled)
[09:31:20.135]                     }
[09:31:20.135]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.135]                   }
[09:31:20.135]                 }
[09:31:20.135]                 else {
[09:31:20.135]                   if (TRUE) {
[09:31:20.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.135]                     {
[09:31:20.135]                       inherits <- base::inherits
[09:31:20.135]                       invokeRestart <- base::invokeRestart
[09:31:20.135]                       is.null <- base::is.null
[09:31:20.135]                       muffled <- FALSE
[09:31:20.135]                       if (inherits(cond, "message")) {
[09:31:20.135]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.135]                         if (muffled) 
[09:31:20.135]                           invokeRestart("muffleMessage")
[09:31:20.135]                       }
[09:31:20.135]                       else if (inherits(cond, "warning")) {
[09:31:20.135]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.135]                         if (muffled) 
[09:31:20.135]                           invokeRestart("muffleWarning")
[09:31:20.135]                       }
[09:31:20.135]                       else if (inherits(cond, "condition")) {
[09:31:20.135]                         if (!is.null(pattern)) {
[09:31:20.135]                           computeRestarts <- base::computeRestarts
[09:31:20.135]                           grepl <- base::grepl
[09:31:20.135]                           restarts <- computeRestarts(cond)
[09:31:20.135]                           for (restart in restarts) {
[09:31:20.135]                             name <- restart$name
[09:31:20.135]                             if (is.null(name)) 
[09:31:20.135]                               next
[09:31:20.135]                             if (!grepl(pattern, name)) 
[09:31:20.135]                               next
[09:31:20.135]                             invokeRestart(restart)
[09:31:20.135]                             muffled <- TRUE
[09:31:20.135]                             break
[09:31:20.135]                           }
[09:31:20.135]                         }
[09:31:20.135]                       }
[09:31:20.135]                       invisible(muffled)
[09:31:20.135]                     }
[09:31:20.135]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.135]                   }
[09:31:20.135]                 }
[09:31:20.135]             }
[09:31:20.135]         }))
[09:31:20.135]     }, error = function(ex) {
[09:31:20.135]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.135]                 ...future.rng), started = ...future.startTime, 
[09:31:20.135]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.135]             version = "1.8"), class = "FutureResult")
[09:31:20.135]     }, finally = {
[09:31:20.135]         if (!identical(...future.workdir, getwd())) 
[09:31:20.135]             setwd(...future.workdir)
[09:31:20.135]         {
[09:31:20.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.135]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.135]             }
[09:31:20.135]             base::options(...future.oldOptions)
[09:31:20.135]             if (.Platform$OS.type == "windows") {
[09:31:20.135]                 old_names <- names(...future.oldEnvVars)
[09:31:20.135]                 envs <- base::Sys.getenv()
[09:31:20.135]                 names <- names(envs)
[09:31:20.135]                 common <- intersect(names, old_names)
[09:31:20.135]                 added <- setdiff(names, old_names)
[09:31:20.135]                 removed <- setdiff(old_names, names)
[09:31:20.135]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.135]                   envs[common]]
[09:31:20.135]                 NAMES <- toupper(changed)
[09:31:20.135]                 args <- list()
[09:31:20.135]                 for (kk in seq_along(NAMES)) {
[09:31:20.135]                   name <- changed[[kk]]
[09:31:20.135]                   NAME <- NAMES[[kk]]
[09:31:20.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.135]                     next
[09:31:20.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.135]                 }
[09:31:20.135]                 NAMES <- toupper(added)
[09:31:20.135]                 for (kk in seq_along(NAMES)) {
[09:31:20.135]                   name <- added[[kk]]
[09:31:20.135]                   NAME <- NAMES[[kk]]
[09:31:20.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.135]                     next
[09:31:20.135]                   args[[name]] <- ""
[09:31:20.135]                 }
[09:31:20.135]                 NAMES <- toupper(removed)
[09:31:20.135]                 for (kk in seq_along(NAMES)) {
[09:31:20.135]                   name <- removed[[kk]]
[09:31:20.135]                   NAME <- NAMES[[kk]]
[09:31:20.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.135]                     next
[09:31:20.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.135]                 }
[09:31:20.135]                 if (length(args) > 0) 
[09:31:20.135]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.135]             }
[09:31:20.135]             else {
[09:31:20.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.135]             }
[09:31:20.135]             {
[09:31:20.135]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.135]                   0L) {
[09:31:20.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.135]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.135]                   base::options(opts)
[09:31:20.135]                 }
[09:31:20.135]                 {
[09:31:20.135]                   {
[09:31:20.135]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.135]                     NULL
[09:31:20.135]                   }
[09:31:20.135]                   options(future.plan = NULL)
[09:31:20.135]                   if (is.na(NA_character_)) 
[09:31:20.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.135]                     .init = FALSE)
[09:31:20.135]                 }
[09:31:20.135]             }
[09:31:20.135]         }
[09:31:20.135]     })
[09:31:20.135]     if (TRUE) {
[09:31:20.135]         base::sink(type = "output", split = FALSE)
[09:31:20.135]         if (TRUE) {
[09:31:20.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.135]         }
[09:31:20.135]         else {
[09:31:20.135]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.135]         }
[09:31:20.135]         base::close(...future.stdout)
[09:31:20.135]         ...future.stdout <- NULL
[09:31:20.135]     }
[09:31:20.135]     ...future.result$conditions <- ...future.conditions
[09:31:20.135]     ...future.result$finished <- base::Sys.time()
[09:31:20.135]     ...future.result
[09:31:20.135] }
[09:31:20.138] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[09:31:20.138] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[09:31:20.138] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[09:31:20.138] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[09:31:20.139] MultisessionFuture started
[09:31:20.139] - Launch lazy future ... done
[09:31:20.139] run() for ‘MultisessionFuture’ ... done
[09:31:20.139] result() for ClusterFuture ...
[09:31:20.139] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.139] - Validating connection of MultisessionFuture
[09:31:20.182] - received message: FutureResult
[09:31:20.182] - Received FutureResult
[09:31:20.182] - Erased future from FutureRegistry
[09:31:20.182] result() for ClusterFuture ...
[09:31:20.182] - result already collected: FutureResult
[09:31:20.182] result() for ClusterFuture ... done
[09:31:20.182] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.182] result() for ClusterFuture ... done
[09:31:20.182] result() for ClusterFuture ...
[09:31:20.183] - result already collected: FutureResult
[09:31:20.183] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[09:31:20.184] getGlobalsAndPackages() ...
[09:31:20.184] Searching for globals...
[09:31:20.186] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[09:31:20.186] Searching for globals ... DONE
[09:31:20.186] Resolving globals: FALSE
[09:31:20.186] 
[09:31:20.187] - packages: [2] ‘stats’, ‘datasets’
[09:31:20.187] getGlobalsAndPackages() ... DONE
[09:31:20.187] run() for ‘Future’ ...
[09:31:20.187] - state: ‘created’
[09:31:20.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.201]   - Field: ‘node’
[09:31:20.201]   - Field: ‘label’
[09:31:20.201]   - Field: ‘local’
[09:31:20.201]   - Field: ‘owner’
[09:31:20.201]   - Field: ‘envir’
[09:31:20.201]   - Field: ‘workers’
[09:31:20.202]   - Field: ‘packages’
[09:31:20.202]   - Field: ‘gc’
[09:31:20.202]   - Field: ‘conditions’
[09:31:20.202]   - Field: ‘persistent’
[09:31:20.202]   - Field: ‘expr’
[09:31:20.202]   - Field: ‘uuid’
[09:31:20.202]   - Field: ‘seed’
[09:31:20.202]   - Field: ‘version’
[09:31:20.202]   - Field: ‘result’
[09:31:20.202]   - Field: ‘asynchronous’
[09:31:20.202]   - Field: ‘calls’
[09:31:20.203]   - Field: ‘globals’
[09:31:20.203]   - Field: ‘stdout’
[09:31:20.203]   - Field: ‘earlySignal’
[09:31:20.203]   - Field: ‘lazy’
[09:31:20.203]   - Field: ‘state’
[09:31:20.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.203] - Launch lazy future ...
[09:31:20.203] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:20.203] Packages needed by future strategies (n = 0): <none>
[09:31:20.204] {
[09:31:20.204]     {
[09:31:20.204]         {
[09:31:20.204]             ...future.startTime <- base::Sys.time()
[09:31:20.204]             {
[09:31:20.204]                 {
[09:31:20.204]                   {
[09:31:20.204]                     {
[09:31:20.204]                       {
[09:31:20.204]                         base::local({
[09:31:20.204]                           has_future <- base::requireNamespace("future", 
[09:31:20.204]                             quietly = TRUE)
[09:31:20.204]                           if (has_future) {
[09:31:20.204]                             ns <- base::getNamespace("future")
[09:31:20.204]                             version <- ns[[".package"]][["version"]]
[09:31:20.204]                             if (is.null(version)) 
[09:31:20.204]                               version <- utils::packageVersion("future")
[09:31:20.204]                           }
[09:31:20.204]                           else {
[09:31:20.204]                             version <- NULL
[09:31:20.204]                           }
[09:31:20.204]                           if (!has_future || version < "1.8.0") {
[09:31:20.204]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.204]                               "", base::R.version$version.string), 
[09:31:20.204]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.204]                                 base::R.version$platform, 8 * 
[09:31:20.204]                                   base::.Machine$sizeof.pointer), 
[09:31:20.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.204]                                 "release", "version")], collapse = " "), 
[09:31:20.204]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.204]                               info)
[09:31:20.204]                             info <- base::paste(info, collapse = "; ")
[09:31:20.204]                             if (!has_future) {
[09:31:20.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.204]                                 info)
[09:31:20.204]                             }
[09:31:20.204]                             else {
[09:31:20.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.204]                                 info, version)
[09:31:20.204]                             }
[09:31:20.204]                             base::stop(msg)
[09:31:20.204]                           }
[09:31:20.204]                         })
[09:31:20.204]                       }
[09:31:20.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.204]                       base::options(mc.cores = 1L)
[09:31:20.204]                     }
[09:31:20.204]                     base::local({
[09:31:20.204]                       for (pkg in c("stats", "datasets")) {
[09:31:20.204]                         base::loadNamespace(pkg)
[09:31:20.204]                         base::library(pkg, character.only = TRUE)
[09:31:20.204]                       }
[09:31:20.204]                     })
[09:31:20.204]                   }
[09:31:20.204]                   ...future.strategy.old <- future::plan("list")
[09:31:20.204]                   options(future.plan = NULL)
[09:31:20.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.204]                 }
[09:31:20.204]                 ...future.workdir <- getwd()
[09:31:20.204]             }
[09:31:20.204]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.204]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.204]         }
[09:31:20.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.204]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.204]             base::names(...future.oldOptions))
[09:31:20.204]     }
[09:31:20.204]     if (FALSE) {
[09:31:20.204]     }
[09:31:20.204]     else {
[09:31:20.204]         if (TRUE) {
[09:31:20.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.204]                 open = "w")
[09:31:20.204]         }
[09:31:20.204]         else {
[09:31:20.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.204]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.204]         }
[09:31:20.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.204]             base::sink(type = "output", split = FALSE)
[09:31:20.204]             base::close(...future.stdout)
[09:31:20.204]         }, add = TRUE)
[09:31:20.204]     }
[09:31:20.204]     ...future.frame <- base::sys.nframe()
[09:31:20.204]     ...future.conditions <- base::list()
[09:31:20.204]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.204]     if (FALSE) {
[09:31:20.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.204]     }
[09:31:20.204]     ...future.result <- base::tryCatch({
[09:31:20.204]         base::withCallingHandlers({
[09:31:20.204]             ...future.value <- base::withVisible(base::local({
[09:31:20.204]                 ...future.makeSendCondition <- base::local({
[09:31:20.204]                   sendCondition <- NULL
[09:31:20.204]                   function(frame = 1L) {
[09:31:20.204]                     if (is.function(sendCondition)) 
[09:31:20.204]                       return(sendCondition)
[09:31:20.204]                     ns <- getNamespace("parallel")
[09:31:20.204]                     if (exists("sendData", mode = "function", 
[09:31:20.204]                       envir = ns)) {
[09:31:20.204]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.204]                         envir = ns)
[09:31:20.204]                       envir <- sys.frame(frame)
[09:31:20.204]                       master <- NULL
[09:31:20.204]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.204]                         !identical(envir, emptyenv())) {
[09:31:20.204]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.204]                           inherits = FALSE)) {
[09:31:20.204]                           master <- get("master", mode = "list", 
[09:31:20.204]                             envir = envir, inherits = FALSE)
[09:31:20.204]                           if (inherits(master, c("SOCKnode", 
[09:31:20.204]                             "SOCK0node"))) {
[09:31:20.204]                             sendCondition <<- function(cond) {
[09:31:20.204]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.204]                                 success = TRUE)
[09:31:20.204]                               parallel_sendData(master, data)
[09:31:20.204]                             }
[09:31:20.204]                             return(sendCondition)
[09:31:20.204]                           }
[09:31:20.204]                         }
[09:31:20.204]                         frame <- frame + 1L
[09:31:20.204]                         envir <- sys.frame(frame)
[09:31:20.204]                       }
[09:31:20.204]                     }
[09:31:20.204]                     sendCondition <<- function(cond) NULL
[09:31:20.204]                   }
[09:31:20.204]                 })
[09:31:20.204]                 withCallingHandlers({
[09:31:20.204]                   {
[09:31:20.204]                     lm(dist ~ . - 1, data = cars)
[09:31:20.204]                   }
[09:31:20.204]                 }, immediateCondition = function(cond) {
[09:31:20.204]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.204]                   sendCondition(cond)
[09:31:20.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.204]                   {
[09:31:20.204]                     inherits <- base::inherits
[09:31:20.204]                     invokeRestart <- base::invokeRestart
[09:31:20.204]                     is.null <- base::is.null
[09:31:20.204]                     muffled <- FALSE
[09:31:20.204]                     if (inherits(cond, "message")) {
[09:31:20.204]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.204]                       if (muffled) 
[09:31:20.204]                         invokeRestart("muffleMessage")
[09:31:20.204]                     }
[09:31:20.204]                     else if (inherits(cond, "warning")) {
[09:31:20.204]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.204]                       if (muffled) 
[09:31:20.204]                         invokeRestart("muffleWarning")
[09:31:20.204]                     }
[09:31:20.204]                     else if (inherits(cond, "condition")) {
[09:31:20.204]                       if (!is.null(pattern)) {
[09:31:20.204]                         computeRestarts <- base::computeRestarts
[09:31:20.204]                         grepl <- base::grepl
[09:31:20.204]                         restarts <- computeRestarts(cond)
[09:31:20.204]                         for (restart in restarts) {
[09:31:20.204]                           name <- restart$name
[09:31:20.204]                           if (is.null(name)) 
[09:31:20.204]                             next
[09:31:20.204]                           if (!grepl(pattern, name)) 
[09:31:20.204]                             next
[09:31:20.204]                           invokeRestart(restart)
[09:31:20.204]                           muffled <- TRUE
[09:31:20.204]                           break
[09:31:20.204]                         }
[09:31:20.204]                       }
[09:31:20.204]                     }
[09:31:20.204]                     invisible(muffled)
[09:31:20.204]                   }
[09:31:20.204]                   muffleCondition(cond)
[09:31:20.204]                 })
[09:31:20.204]             }))
[09:31:20.204]             future::FutureResult(value = ...future.value$value, 
[09:31:20.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.204]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.204]                     ...future.globalenv.names))
[09:31:20.204]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.204]         }, condition = base::local({
[09:31:20.204]             c <- base::c
[09:31:20.204]             inherits <- base::inherits
[09:31:20.204]             invokeRestart <- base::invokeRestart
[09:31:20.204]             length <- base::length
[09:31:20.204]             list <- base::list
[09:31:20.204]             seq.int <- base::seq.int
[09:31:20.204]             signalCondition <- base::signalCondition
[09:31:20.204]             sys.calls <- base::sys.calls
[09:31:20.204]             `[[` <- base::`[[`
[09:31:20.204]             `+` <- base::`+`
[09:31:20.204]             `<<-` <- base::`<<-`
[09:31:20.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.204]                   3L)]
[09:31:20.204]             }
[09:31:20.204]             function(cond) {
[09:31:20.204]                 is_error <- inherits(cond, "error")
[09:31:20.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.204]                   NULL)
[09:31:20.204]                 if (is_error) {
[09:31:20.204]                   sessionInformation <- function() {
[09:31:20.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.204]                       search = base::search(), system = base::Sys.info())
[09:31:20.204]                   }
[09:31:20.204]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.204]                     cond$call), session = sessionInformation(), 
[09:31:20.204]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.204]                   signalCondition(cond)
[09:31:20.204]                 }
[09:31:20.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.204]                 "immediateCondition"))) {
[09:31:20.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.204]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.204]                   if (TRUE && !signal) {
[09:31:20.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.204]                     {
[09:31:20.204]                       inherits <- base::inherits
[09:31:20.204]                       invokeRestart <- base::invokeRestart
[09:31:20.204]                       is.null <- base::is.null
[09:31:20.204]                       muffled <- FALSE
[09:31:20.204]                       if (inherits(cond, "message")) {
[09:31:20.204]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.204]                         if (muffled) 
[09:31:20.204]                           invokeRestart("muffleMessage")
[09:31:20.204]                       }
[09:31:20.204]                       else if (inherits(cond, "warning")) {
[09:31:20.204]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.204]                         if (muffled) 
[09:31:20.204]                           invokeRestart("muffleWarning")
[09:31:20.204]                       }
[09:31:20.204]                       else if (inherits(cond, "condition")) {
[09:31:20.204]                         if (!is.null(pattern)) {
[09:31:20.204]                           computeRestarts <- base::computeRestarts
[09:31:20.204]                           grepl <- base::grepl
[09:31:20.204]                           restarts <- computeRestarts(cond)
[09:31:20.204]                           for (restart in restarts) {
[09:31:20.204]                             name <- restart$name
[09:31:20.204]                             if (is.null(name)) 
[09:31:20.204]                               next
[09:31:20.204]                             if (!grepl(pattern, name)) 
[09:31:20.204]                               next
[09:31:20.204]                             invokeRestart(restart)
[09:31:20.204]                             muffled <- TRUE
[09:31:20.204]                             break
[09:31:20.204]                           }
[09:31:20.204]                         }
[09:31:20.204]                       }
[09:31:20.204]                       invisible(muffled)
[09:31:20.204]                     }
[09:31:20.204]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.204]                   }
[09:31:20.204]                 }
[09:31:20.204]                 else {
[09:31:20.204]                   if (TRUE) {
[09:31:20.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.204]                     {
[09:31:20.204]                       inherits <- base::inherits
[09:31:20.204]                       invokeRestart <- base::invokeRestart
[09:31:20.204]                       is.null <- base::is.null
[09:31:20.204]                       muffled <- FALSE
[09:31:20.204]                       if (inherits(cond, "message")) {
[09:31:20.204]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.204]                         if (muffled) 
[09:31:20.204]                           invokeRestart("muffleMessage")
[09:31:20.204]                       }
[09:31:20.204]                       else if (inherits(cond, "warning")) {
[09:31:20.204]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.204]                         if (muffled) 
[09:31:20.204]                           invokeRestart("muffleWarning")
[09:31:20.204]                       }
[09:31:20.204]                       else if (inherits(cond, "condition")) {
[09:31:20.204]                         if (!is.null(pattern)) {
[09:31:20.204]                           computeRestarts <- base::computeRestarts
[09:31:20.204]                           grepl <- base::grepl
[09:31:20.204]                           restarts <- computeRestarts(cond)
[09:31:20.204]                           for (restart in restarts) {
[09:31:20.204]                             name <- restart$name
[09:31:20.204]                             if (is.null(name)) 
[09:31:20.204]                               next
[09:31:20.204]                             if (!grepl(pattern, name)) 
[09:31:20.204]                               next
[09:31:20.204]                             invokeRestart(restart)
[09:31:20.204]                             muffled <- TRUE
[09:31:20.204]                             break
[09:31:20.204]                           }
[09:31:20.204]                         }
[09:31:20.204]                       }
[09:31:20.204]                       invisible(muffled)
[09:31:20.204]                     }
[09:31:20.204]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.204]                   }
[09:31:20.204]                 }
[09:31:20.204]             }
[09:31:20.204]         }))
[09:31:20.204]     }, error = function(ex) {
[09:31:20.204]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.204]                 ...future.rng), started = ...future.startTime, 
[09:31:20.204]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.204]             version = "1.8"), class = "FutureResult")
[09:31:20.204]     }, finally = {
[09:31:20.204]         if (!identical(...future.workdir, getwd())) 
[09:31:20.204]             setwd(...future.workdir)
[09:31:20.204]         {
[09:31:20.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.204]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.204]             }
[09:31:20.204]             base::options(...future.oldOptions)
[09:31:20.204]             if (.Platform$OS.type == "windows") {
[09:31:20.204]                 old_names <- names(...future.oldEnvVars)
[09:31:20.204]                 envs <- base::Sys.getenv()
[09:31:20.204]                 names <- names(envs)
[09:31:20.204]                 common <- intersect(names, old_names)
[09:31:20.204]                 added <- setdiff(names, old_names)
[09:31:20.204]                 removed <- setdiff(old_names, names)
[09:31:20.204]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.204]                   envs[common]]
[09:31:20.204]                 NAMES <- toupper(changed)
[09:31:20.204]                 args <- list()
[09:31:20.204]                 for (kk in seq_along(NAMES)) {
[09:31:20.204]                   name <- changed[[kk]]
[09:31:20.204]                   NAME <- NAMES[[kk]]
[09:31:20.204]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.204]                     next
[09:31:20.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.204]                 }
[09:31:20.204]                 NAMES <- toupper(added)
[09:31:20.204]                 for (kk in seq_along(NAMES)) {
[09:31:20.204]                   name <- added[[kk]]
[09:31:20.204]                   NAME <- NAMES[[kk]]
[09:31:20.204]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.204]                     next
[09:31:20.204]                   args[[name]] <- ""
[09:31:20.204]                 }
[09:31:20.204]                 NAMES <- toupper(removed)
[09:31:20.204]                 for (kk in seq_along(NAMES)) {
[09:31:20.204]                   name <- removed[[kk]]
[09:31:20.204]                   NAME <- NAMES[[kk]]
[09:31:20.204]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.204]                     next
[09:31:20.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.204]                 }
[09:31:20.204]                 if (length(args) > 0) 
[09:31:20.204]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.204]             }
[09:31:20.204]             else {
[09:31:20.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.204]             }
[09:31:20.204]             {
[09:31:20.204]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.204]                   0L) {
[09:31:20.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.204]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.204]                   base::options(opts)
[09:31:20.204]                 }
[09:31:20.204]                 {
[09:31:20.204]                   {
[09:31:20.204]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.204]                     NULL
[09:31:20.204]                   }
[09:31:20.204]                   options(future.plan = NULL)
[09:31:20.204]                   if (is.na(NA_character_)) 
[09:31:20.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.204]                     .init = FALSE)
[09:31:20.204]                 }
[09:31:20.204]             }
[09:31:20.204]         }
[09:31:20.204]     })
[09:31:20.204]     if (TRUE) {
[09:31:20.204]         base::sink(type = "output", split = FALSE)
[09:31:20.204]         if (TRUE) {
[09:31:20.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.204]         }
[09:31:20.204]         else {
[09:31:20.204]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.204]         }
[09:31:20.204]         base::close(...future.stdout)
[09:31:20.204]         ...future.stdout <- NULL
[09:31:20.204]     }
[09:31:20.204]     ...future.result$conditions <- ...future.conditions
[09:31:20.204]     ...future.result$finished <- base::Sys.time()
[09:31:20.204]     ...future.result
[09:31:20.204] }
[09:31:20.207] MultisessionFuture started
[09:31:20.207] - Launch lazy future ... done
[09:31:20.207] run() for ‘MultisessionFuture’ ... done
[09:31:20.207] result() for ClusterFuture ...
[09:31:20.207] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.207] - Validating connection of MultisessionFuture
[09:31:20.250] - received message: FutureResult
[09:31:20.250] - Received FutureResult
[09:31:20.250] - Erased future from FutureRegistry
[09:31:20.251] result() for ClusterFuture ...
[09:31:20.251] - result already collected: FutureResult
[09:31:20.251] result() for ClusterFuture ... done
[09:31:20.251] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.251] result() for ClusterFuture ... done
[09:31:20.251] result() for ClusterFuture ...
[09:31:20.251] - result already collected: FutureResult
[09:31:20.251] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[09:31:20.256] getGlobalsAndPackages() ...
[09:31:20.256] Searching for globals...
[09:31:20.257] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[09:31:20.257] Searching for globals ... DONE
[09:31:20.258] Resolving globals: FALSE
[09:31:20.258] 
[09:31:20.258] - packages: [2] ‘stats’, ‘datasets’
[09:31:20.258] getGlobalsAndPackages() ... DONE
[09:31:20.258] run() for ‘Future’ ...
[09:31:20.259] - state: ‘created’
[09:31:20.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.272] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.272]   - Field: ‘node’
[09:31:20.272]   - Field: ‘label’
[09:31:20.273]   - Field: ‘local’
[09:31:20.273]   - Field: ‘owner’
[09:31:20.273]   - Field: ‘envir’
[09:31:20.273]   - Field: ‘workers’
[09:31:20.273]   - Field: ‘packages’
[09:31:20.273]   - Field: ‘gc’
[09:31:20.273]   - Field: ‘conditions’
[09:31:20.273]   - Field: ‘persistent’
[09:31:20.273]   - Field: ‘expr’
[09:31:20.273]   - Field: ‘uuid’
[09:31:20.273]   - Field: ‘seed’
[09:31:20.274]   - Field: ‘version’
[09:31:20.274]   - Field: ‘result’
[09:31:20.274]   - Field: ‘asynchronous’
[09:31:20.274]   - Field: ‘calls’
[09:31:20.274]   - Field: ‘globals’
[09:31:20.274]   - Field: ‘stdout’
[09:31:20.274]   - Field: ‘earlySignal’
[09:31:20.274]   - Field: ‘lazy’
[09:31:20.274]   - Field: ‘state’
[09:31:20.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.274] - Launch lazy future ...
[09:31:20.275] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:20.275] Packages needed by future strategies (n = 0): <none>
[09:31:20.275] {
[09:31:20.275]     {
[09:31:20.275]         {
[09:31:20.275]             ...future.startTime <- base::Sys.time()
[09:31:20.275]             {
[09:31:20.275]                 {
[09:31:20.275]                   {
[09:31:20.275]                     {
[09:31:20.275]                       {
[09:31:20.275]                         base::local({
[09:31:20.275]                           has_future <- base::requireNamespace("future", 
[09:31:20.275]                             quietly = TRUE)
[09:31:20.275]                           if (has_future) {
[09:31:20.275]                             ns <- base::getNamespace("future")
[09:31:20.275]                             version <- ns[[".package"]][["version"]]
[09:31:20.275]                             if (is.null(version)) 
[09:31:20.275]                               version <- utils::packageVersion("future")
[09:31:20.275]                           }
[09:31:20.275]                           else {
[09:31:20.275]                             version <- NULL
[09:31:20.275]                           }
[09:31:20.275]                           if (!has_future || version < "1.8.0") {
[09:31:20.275]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.275]                               "", base::R.version$version.string), 
[09:31:20.275]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.275]                                 base::R.version$platform, 8 * 
[09:31:20.275]                                   base::.Machine$sizeof.pointer), 
[09:31:20.275]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.275]                                 "release", "version")], collapse = " "), 
[09:31:20.275]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.275]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.275]                               info)
[09:31:20.275]                             info <- base::paste(info, collapse = "; ")
[09:31:20.275]                             if (!has_future) {
[09:31:20.275]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.275]                                 info)
[09:31:20.275]                             }
[09:31:20.275]                             else {
[09:31:20.275]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.275]                                 info, version)
[09:31:20.275]                             }
[09:31:20.275]                             base::stop(msg)
[09:31:20.275]                           }
[09:31:20.275]                         })
[09:31:20.275]                       }
[09:31:20.275]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.275]                       base::options(mc.cores = 1L)
[09:31:20.275]                     }
[09:31:20.275]                     base::local({
[09:31:20.275]                       for (pkg in c("stats", "datasets")) {
[09:31:20.275]                         base::loadNamespace(pkg)
[09:31:20.275]                         base::library(pkg, character.only = TRUE)
[09:31:20.275]                       }
[09:31:20.275]                     })
[09:31:20.275]                   }
[09:31:20.275]                   ...future.strategy.old <- future::plan("list")
[09:31:20.275]                   options(future.plan = NULL)
[09:31:20.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.275]                 }
[09:31:20.275]                 ...future.workdir <- getwd()
[09:31:20.275]             }
[09:31:20.275]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.275]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.275]         }
[09:31:20.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.275]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.275]             base::names(...future.oldOptions))
[09:31:20.275]     }
[09:31:20.275]     if (FALSE) {
[09:31:20.275]     }
[09:31:20.275]     else {
[09:31:20.275]         if (TRUE) {
[09:31:20.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.275]                 open = "w")
[09:31:20.275]         }
[09:31:20.275]         else {
[09:31:20.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.275]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.275]         }
[09:31:20.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.275]             base::sink(type = "output", split = FALSE)
[09:31:20.275]             base::close(...future.stdout)
[09:31:20.275]         }, add = TRUE)
[09:31:20.275]     }
[09:31:20.275]     ...future.frame <- base::sys.nframe()
[09:31:20.275]     ...future.conditions <- base::list()
[09:31:20.275]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.275]     if (FALSE) {
[09:31:20.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.275]     }
[09:31:20.275]     ...future.result <- base::tryCatch({
[09:31:20.275]         base::withCallingHandlers({
[09:31:20.275]             ...future.value <- base::withVisible(base::local({
[09:31:20.275]                 ...future.makeSendCondition <- base::local({
[09:31:20.275]                   sendCondition <- NULL
[09:31:20.275]                   function(frame = 1L) {
[09:31:20.275]                     if (is.function(sendCondition)) 
[09:31:20.275]                       return(sendCondition)
[09:31:20.275]                     ns <- getNamespace("parallel")
[09:31:20.275]                     if (exists("sendData", mode = "function", 
[09:31:20.275]                       envir = ns)) {
[09:31:20.275]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.275]                         envir = ns)
[09:31:20.275]                       envir <- sys.frame(frame)
[09:31:20.275]                       master <- NULL
[09:31:20.275]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.275]                         !identical(envir, emptyenv())) {
[09:31:20.275]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.275]                           inherits = FALSE)) {
[09:31:20.275]                           master <- get("master", mode = "list", 
[09:31:20.275]                             envir = envir, inherits = FALSE)
[09:31:20.275]                           if (inherits(master, c("SOCKnode", 
[09:31:20.275]                             "SOCK0node"))) {
[09:31:20.275]                             sendCondition <<- function(cond) {
[09:31:20.275]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.275]                                 success = TRUE)
[09:31:20.275]                               parallel_sendData(master, data)
[09:31:20.275]                             }
[09:31:20.275]                             return(sendCondition)
[09:31:20.275]                           }
[09:31:20.275]                         }
[09:31:20.275]                         frame <- frame + 1L
[09:31:20.275]                         envir <- sys.frame(frame)
[09:31:20.275]                       }
[09:31:20.275]                     }
[09:31:20.275]                     sendCondition <<- function(cond) NULL
[09:31:20.275]                   }
[09:31:20.275]                 })
[09:31:20.275]                 withCallingHandlers({
[09:31:20.275]                   {
[09:31:20.275]                     lm(dist ~ . + 0, data = cars)
[09:31:20.275]                   }
[09:31:20.275]                 }, immediateCondition = function(cond) {
[09:31:20.275]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.275]                   sendCondition(cond)
[09:31:20.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.275]                   {
[09:31:20.275]                     inherits <- base::inherits
[09:31:20.275]                     invokeRestart <- base::invokeRestart
[09:31:20.275]                     is.null <- base::is.null
[09:31:20.275]                     muffled <- FALSE
[09:31:20.275]                     if (inherits(cond, "message")) {
[09:31:20.275]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.275]                       if (muffled) 
[09:31:20.275]                         invokeRestart("muffleMessage")
[09:31:20.275]                     }
[09:31:20.275]                     else if (inherits(cond, "warning")) {
[09:31:20.275]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.275]                       if (muffled) 
[09:31:20.275]                         invokeRestart("muffleWarning")
[09:31:20.275]                     }
[09:31:20.275]                     else if (inherits(cond, "condition")) {
[09:31:20.275]                       if (!is.null(pattern)) {
[09:31:20.275]                         computeRestarts <- base::computeRestarts
[09:31:20.275]                         grepl <- base::grepl
[09:31:20.275]                         restarts <- computeRestarts(cond)
[09:31:20.275]                         for (restart in restarts) {
[09:31:20.275]                           name <- restart$name
[09:31:20.275]                           if (is.null(name)) 
[09:31:20.275]                             next
[09:31:20.275]                           if (!grepl(pattern, name)) 
[09:31:20.275]                             next
[09:31:20.275]                           invokeRestart(restart)
[09:31:20.275]                           muffled <- TRUE
[09:31:20.275]                           break
[09:31:20.275]                         }
[09:31:20.275]                       }
[09:31:20.275]                     }
[09:31:20.275]                     invisible(muffled)
[09:31:20.275]                   }
[09:31:20.275]                   muffleCondition(cond)
[09:31:20.275]                 })
[09:31:20.275]             }))
[09:31:20.275]             future::FutureResult(value = ...future.value$value, 
[09:31:20.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.275]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.275]                     ...future.globalenv.names))
[09:31:20.275]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.275]         }, condition = base::local({
[09:31:20.275]             c <- base::c
[09:31:20.275]             inherits <- base::inherits
[09:31:20.275]             invokeRestart <- base::invokeRestart
[09:31:20.275]             length <- base::length
[09:31:20.275]             list <- base::list
[09:31:20.275]             seq.int <- base::seq.int
[09:31:20.275]             signalCondition <- base::signalCondition
[09:31:20.275]             sys.calls <- base::sys.calls
[09:31:20.275]             `[[` <- base::`[[`
[09:31:20.275]             `+` <- base::`+`
[09:31:20.275]             `<<-` <- base::`<<-`
[09:31:20.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.275]                   3L)]
[09:31:20.275]             }
[09:31:20.275]             function(cond) {
[09:31:20.275]                 is_error <- inherits(cond, "error")
[09:31:20.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.275]                   NULL)
[09:31:20.275]                 if (is_error) {
[09:31:20.275]                   sessionInformation <- function() {
[09:31:20.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.275]                       search = base::search(), system = base::Sys.info())
[09:31:20.275]                   }
[09:31:20.275]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.275]                     cond$call), session = sessionInformation(), 
[09:31:20.275]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.275]                   signalCondition(cond)
[09:31:20.275]                 }
[09:31:20.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.275]                 "immediateCondition"))) {
[09:31:20.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.275]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.275]                   if (TRUE && !signal) {
[09:31:20.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.275]                     {
[09:31:20.275]                       inherits <- base::inherits
[09:31:20.275]                       invokeRestart <- base::invokeRestart
[09:31:20.275]                       is.null <- base::is.null
[09:31:20.275]                       muffled <- FALSE
[09:31:20.275]                       if (inherits(cond, "message")) {
[09:31:20.275]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.275]                         if (muffled) 
[09:31:20.275]                           invokeRestart("muffleMessage")
[09:31:20.275]                       }
[09:31:20.275]                       else if (inherits(cond, "warning")) {
[09:31:20.275]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.275]                         if (muffled) 
[09:31:20.275]                           invokeRestart("muffleWarning")
[09:31:20.275]                       }
[09:31:20.275]                       else if (inherits(cond, "condition")) {
[09:31:20.275]                         if (!is.null(pattern)) {
[09:31:20.275]                           computeRestarts <- base::computeRestarts
[09:31:20.275]                           grepl <- base::grepl
[09:31:20.275]                           restarts <- computeRestarts(cond)
[09:31:20.275]                           for (restart in restarts) {
[09:31:20.275]                             name <- restart$name
[09:31:20.275]                             if (is.null(name)) 
[09:31:20.275]                               next
[09:31:20.275]                             if (!grepl(pattern, name)) 
[09:31:20.275]                               next
[09:31:20.275]                             invokeRestart(restart)
[09:31:20.275]                             muffled <- TRUE
[09:31:20.275]                             break
[09:31:20.275]                           }
[09:31:20.275]                         }
[09:31:20.275]                       }
[09:31:20.275]                       invisible(muffled)
[09:31:20.275]                     }
[09:31:20.275]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.275]                   }
[09:31:20.275]                 }
[09:31:20.275]                 else {
[09:31:20.275]                   if (TRUE) {
[09:31:20.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.275]                     {
[09:31:20.275]                       inherits <- base::inherits
[09:31:20.275]                       invokeRestart <- base::invokeRestart
[09:31:20.275]                       is.null <- base::is.null
[09:31:20.275]                       muffled <- FALSE
[09:31:20.275]                       if (inherits(cond, "message")) {
[09:31:20.275]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.275]                         if (muffled) 
[09:31:20.275]                           invokeRestart("muffleMessage")
[09:31:20.275]                       }
[09:31:20.275]                       else if (inherits(cond, "warning")) {
[09:31:20.275]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.275]                         if (muffled) 
[09:31:20.275]                           invokeRestart("muffleWarning")
[09:31:20.275]                       }
[09:31:20.275]                       else if (inherits(cond, "condition")) {
[09:31:20.275]                         if (!is.null(pattern)) {
[09:31:20.275]                           computeRestarts <- base::computeRestarts
[09:31:20.275]                           grepl <- base::grepl
[09:31:20.275]                           restarts <- computeRestarts(cond)
[09:31:20.275]                           for (restart in restarts) {
[09:31:20.275]                             name <- restart$name
[09:31:20.275]                             if (is.null(name)) 
[09:31:20.275]                               next
[09:31:20.275]                             if (!grepl(pattern, name)) 
[09:31:20.275]                               next
[09:31:20.275]                             invokeRestart(restart)
[09:31:20.275]                             muffled <- TRUE
[09:31:20.275]                             break
[09:31:20.275]                           }
[09:31:20.275]                         }
[09:31:20.275]                       }
[09:31:20.275]                       invisible(muffled)
[09:31:20.275]                     }
[09:31:20.275]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.275]                   }
[09:31:20.275]                 }
[09:31:20.275]             }
[09:31:20.275]         }))
[09:31:20.275]     }, error = function(ex) {
[09:31:20.275]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.275]                 ...future.rng), started = ...future.startTime, 
[09:31:20.275]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.275]             version = "1.8"), class = "FutureResult")
[09:31:20.275]     }, finally = {
[09:31:20.275]         if (!identical(...future.workdir, getwd())) 
[09:31:20.275]             setwd(...future.workdir)
[09:31:20.275]         {
[09:31:20.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.275]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.275]             }
[09:31:20.275]             base::options(...future.oldOptions)
[09:31:20.275]             if (.Platform$OS.type == "windows") {
[09:31:20.275]                 old_names <- names(...future.oldEnvVars)
[09:31:20.275]                 envs <- base::Sys.getenv()
[09:31:20.275]                 names <- names(envs)
[09:31:20.275]                 common <- intersect(names, old_names)
[09:31:20.275]                 added <- setdiff(names, old_names)
[09:31:20.275]                 removed <- setdiff(old_names, names)
[09:31:20.275]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.275]                   envs[common]]
[09:31:20.275]                 NAMES <- toupper(changed)
[09:31:20.275]                 args <- list()
[09:31:20.275]                 for (kk in seq_along(NAMES)) {
[09:31:20.275]                   name <- changed[[kk]]
[09:31:20.275]                   NAME <- NAMES[[kk]]
[09:31:20.275]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.275]                     next
[09:31:20.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.275]                 }
[09:31:20.275]                 NAMES <- toupper(added)
[09:31:20.275]                 for (kk in seq_along(NAMES)) {
[09:31:20.275]                   name <- added[[kk]]
[09:31:20.275]                   NAME <- NAMES[[kk]]
[09:31:20.275]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.275]                     next
[09:31:20.275]                   args[[name]] <- ""
[09:31:20.275]                 }
[09:31:20.275]                 NAMES <- toupper(removed)
[09:31:20.275]                 for (kk in seq_along(NAMES)) {
[09:31:20.275]                   name <- removed[[kk]]
[09:31:20.275]                   NAME <- NAMES[[kk]]
[09:31:20.275]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.275]                     next
[09:31:20.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.275]                 }
[09:31:20.275]                 if (length(args) > 0) 
[09:31:20.275]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.275]             }
[09:31:20.275]             else {
[09:31:20.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.275]             }
[09:31:20.275]             {
[09:31:20.275]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.275]                   0L) {
[09:31:20.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.275]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.275]                   base::options(opts)
[09:31:20.275]                 }
[09:31:20.275]                 {
[09:31:20.275]                   {
[09:31:20.275]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.275]                     NULL
[09:31:20.275]                   }
[09:31:20.275]                   options(future.plan = NULL)
[09:31:20.275]                   if (is.na(NA_character_)) 
[09:31:20.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.275]                     .init = FALSE)
[09:31:20.275]                 }
[09:31:20.275]             }
[09:31:20.275]         }
[09:31:20.275]     })
[09:31:20.275]     if (TRUE) {
[09:31:20.275]         base::sink(type = "output", split = FALSE)
[09:31:20.275]         if (TRUE) {
[09:31:20.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.275]         }
[09:31:20.275]         else {
[09:31:20.275]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.275]         }
[09:31:20.275]         base::close(...future.stdout)
[09:31:20.275]         ...future.stdout <- NULL
[09:31:20.275]     }
[09:31:20.275]     ...future.result$conditions <- ...future.conditions
[09:31:20.275]     ...future.result$finished <- base::Sys.time()
[09:31:20.275]     ...future.result
[09:31:20.275] }
[09:31:20.278] MultisessionFuture started
[09:31:20.278] - Launch lazy future ... done
[09:31:20.278] run() for ‘MultisessionFuture’ ... done
[09:31:20.278] result() for ClusterFuture ...
[09:31:20.278] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.279] - Validating connection of MultisessionFuture
[09:31:20.280] - received message: FutureResult
[09:31:20.280] - Received FutureResult
[09:31:20.280] - Erased future from FutureRegistry
[09:31:20.281] result() for ClusterFuture ...
[09:31:20.281] - result already collected: FutureResult
[09:31:20.281] result() for ClusterFuture ... done
[09:31:20.281] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.281] result() for ClusterFuture ... done
[09:31:20.281] result() for ClusterFuture ...
[09:31:20.281] - result already collected: FutureResult
[09:31:20.281] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[09:31:20.283] getGlobalsAndPackages() ...
[09:31:20.283] Searching for globals...
[09:31:20.285] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[09:31:20.285] Searching for globals ... DONE
[09:31:20.285] Resolving globals: FALSE
[09:31:20.286] 
[09:31:20.286] - packages: [2] ‘stats’, ‘datasets’
[09:31:20.286] getGlobalsAndPackages() ... DONE
[09:31:20.286] run() for ‘Future’ ...
[09:31:20.286] - state: ‘created’
[09:31:20.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.300]   - Field: ‘node’
[09:31:20.300]   - Field: ‘label’
[09:31:20.300]   - Field: ‘local’
[09:31:20.301]   - Field: ‘owner’
[09:31:20.301]   - Field: ‘envir’
[09:31:20.301]   - Field: ‘workers’
[09:31:20.301]   - Field: ‘packages’
[09:31:20.301]   - Field: ‘gc’
[09:31:20.301]   - Field: ‘conditions’
[09:31:20.301]   - Field: ‘persistent’
[09:31:20.301]   - Field: ‘expr’
[09:31:20.301]   - Field: ‘uuid’
[09:31:20.301]   - Field: ‘seed’
[09:31:20.301]   - Field: ‘version’
[09:31:20.302]   - Field: ‘result’
[09:31:20.302]   - Field: ‘asynchronous’
[09:31:20.302]   - Field: ‘calls’
[09:31:20.302]   - Field: ‘globals’
[09:31:20.302]   - Field: ‘stdout’
[09:31:20.302]   - Field: ‘earlySignal’
[09:31:20.302]   - Field: ‘lazy’
[09:31:20.302]   - Field: ‘state’
[09:31:20.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.302] - Launch lazy future ...
[09:31:20.303] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:20.303] Packages needed by future strategies (n = 0): <none>
[09:31:20.303] {
[09:31:20.303]     {
[09:31:20.303]         {
[09:31:20.303]             ...future.startTime <- base::Sys.time()
[09:31:20.303]             {
[09:31:20.303]                 {
[09:31:20.303]                   {
[09:31:20.303]                     {
[09:31:20.303]                       {
[09:31:20.303]                         base::local({
[09:31:20.303]                           has_future <- base::requireNamespace("future", 
[09:31:20.303]                             quietly = TRUE)
[09:31:20.303]                           if (has_future) {
[09:31:20.303]                             ns <- base::getNamespace("future")
[09:31:20.303]                             version <- ns[[".package"]][["version"]]
[09:31:20.303]                             if (is.null(version)) 
[09:31:20.303]                               version <- utils::packageVersion("future")
[09:31:20.303]                           }
[09:31:20.303]                           else {
[09:31:20.303]                             version <- NULL
[09:31:20.303]                           }
[09:31:20.303]                           if (!has_future || version < "1.8.0") {
[09:31:20.303]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.303]                               "", base::R.version$version.string), 
[09:31:20.303]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.303]                                 base::R.version$platform, 8 * 
[09:31:20.303]                                   base::.Machine$sizeof.pointer), 
[09:31:20.303]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.303]                                 "release", "version")], collapse = " "), 
[09:31:20.303]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.303]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.303]                               info)
[09:31:20.303]                             info <- base::paste(info, collapse = "; ")
[09:31:20.303]                             if (!has_future) {
[09:31:20.303]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.303]                                 info)
[09:31:20.303]                             }
[09:31:20.303]                             else {
[09:31:20.303]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.303]                                 info, version)
[09:31:20.303]                             }
[09:31:20.303]                             base::stop(msg)
[09:31:20.303]                           }
[09:31:20.303]                         })
[09:31:20.303]                       }
[09:31:20.303]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.303]                       base::options(mc.cores = 1L)
[09:31:20.303]                     }
[09:31:20.303]                     base::local({
[09:31:20.303]                       for (pkg in c("stats", "datasets")) {
[09:31:20.303]                         base::loadNamespace(pkg)
[09:31:20.303]                         base::library(pkg, character.only = TRUE)
[09:31:20.303]                       }
[09:31:20.303]                     })
[09:31:20.303]                   }
[09:31:20.303]                   ...future.strategy.old <- future::plan("list")
[09:31:20.303]                   options(future.plan = NULL)
[09:31:20.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.303]                 }
[09:31:20.303]                 ...future.workdir <- getwd()
[09:31:20.303]             }
[09:31:20.303]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.303]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.303]         }
[09:31:20.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.303]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.303]             base::names(...future.oldOptions))
[09:31:20.303]     }
[09:31:20.303]     if (FALSE) {
[09:31:20.303]     }
[09:31:20.303]     else {
[09:31:20.303]         if (TRUE) {
[09:31:20.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.303]                 open = "w")
[09:31:20.303]         }
[09:31:20.303]         else {
[09:31:20.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.303]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.303]         }
[09:31:20.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.303]             base::sink(type = "output", split = FALSE)
[09:31:20.303]             base::close(...future.stdout)
[09:31:20.303]         }, add = TRUE)
[09:31:20.303]     }
[09:31:20.303]     ...future.frame <- base::sys.nframe()
[09:31:20.303]     ...future.conditions <- base::list()
[09:31:20.303]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.303]     if (FALSE) {
[09:31:20.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.303]     }
[09:31:20.303]     ...future.result <- base::tryCatch({
[09:31:20.303]         base::withCallingHandlers({
[09:31:20.303]             ...future.value <- base::withVisible(base::local({
[09:31:20.303]                 ...future.makeSendCondition <- base::local({
[09:31:20.303]                   sendCondition <- NULL
[09:31:20.303]                   function(frame = 1L) {
[09:31:20.303]                     if (is.function(sendCondition)) 
[09:31:20.303]                       return(sendCondition)
[09:31:20.303]                     ns <- getNamespace("parallel")
[09:31:20.303]                     if (exists("sendData", mode = "function", 
[09:31:20.303]                       envir = ns)) {
[09:31:20.303]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.303]                         envir = ns)
[09:31:20.303]                       envir <- sys.frame(frame)
[09:31:20.303]                       master <- NULL
[09:31:20.303]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.303]                         !identical(envir, emptyenv())) {
[09:31:20.303]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.303]                           inherits = FALSE)) {
[09:31:20.303]                           master <- get("master", mode = "list", 
[09:31:20.303]                             envir = envir, inherits = FALSE)
[09:31:20.303]                           if (inherits(master, c("SOCKnode", 
[09:31:20.303]                             "SOCK0node"))) {
[09:31:20.303]                             sendCondition <<- function(cond) {
[09:31:20.303]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.303]                                 success = TRUE)
[09:31:20.303]                               parallel_sendData(master, data)
[09:31:20.303]                             }
[09:31:20.303]                             return(sendCondition)
[09:31:20.303]                           }
[09:31:20.303]                         }
[09:31:20.303]                         frame <- frame + 1L
[09:31:20.303]                         envir <- sys.frame(frame)
[09:31:20.303]                       }
[09:31:20.303]                     }
[09:31:20.303]                     sendCondition <<- function(cond) NULL
[09:31:20.303]                   }
[09:31:20.303]                 })
[09:31:20.303]                 withCallingHandlers({
[09:31:20.303]                   {
[09:31:20.303]                     lm(dist ~ speed + speed^2, data = cars)
[09:31:20.303]                   }
[09:31:20.303]                 }, immediateCondition = function(cond) {
[09:31:20.303]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.303]                   sendCondition(cond)
[09:31:20.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.303]                   {
[09:31:20.303]                     inherits <- base::inherits
[09:31:20.303]                     invokeRestart <- base::invokeRestart
[09:31:20.303]                     is.null <- base::is.null
[09:31:20.303]                     muffled <- FALSE
[09:31:20.303]                     if (inherits(cond, "message")) {
[09:31:20.303]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.303]                       if (muffled) 
[09:31:20.303]                         invokeRestart("muffleMessage")
[09:31:20.303]                     }
[09:31:20.303]                     else if (inherits(cond, "warning")) {
[09:31:20.303]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.303]                       if (muffled) 
[09:31:20.303]                         invokeRestart("muffleWarning")
[09:31:20.303]                     }
[09:31:20.303]                     else if (inherits(cond, "condition")) {
[09:31:20.303]                       if (!is.null(pattern)) {
[09:31:20.303]                         computeRestarts <- base::computeRestarts
[09:31:20.303]                         grepl <- base::grepl
[09:31:20.303]                         restarts <- computeRestarts(cond)
[09:31:20.303]                         for (restart in restarts) {
[09:31:20.303]                           name <- restart$name
[09:31:20.303]                           if (is.null(name)) 
[09:31:20.303]                             next
[09:31:20.303]                           if (!grepl(pattern, name)) 
[09:31:20.303]                             next
[09:31:20.303]                           invokeRestart(restart)
[09:31:20.303]                           muffled <- TRUE
[09:31:20.303]                           break
[09:31:20.303]                         }
[09:31:20.303]                       }
[09:31:20.303]                     }
[09:31:20.303]                     invisible(muffled)
[09:31:20.303]                   }
[09:31:20.303]                   muffleCondition(cond)
[09:31:20.303]                 })
[09:31:20.303]             }))
[09:31:20.303]             future::FutureResult(value = ...future.value$value, 
[09:31:20.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.303]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.303]                     ...future.globalenv.names))
[09:31:20.303]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.303]         }, condition = base::local({
[09:31:20.303]             c <- base::c
[09:31:20.303]             inherits <- base::inherits
[09:31:20.303]             invokeRestart <- base::invokeRestart
[09:31:20.303]             length <- base::length
[09:31:20.303]             list <- base::list
[09:31:20.303]             seq.int <- base::seq.int
[09:31:20.303]             signalCondition <- base::signalCondition
[09:31:20.303]             sys.calls <- base::sys.calls
[09:31:20.303]             `[[` <- base::`[[`
[09:31:20.303]             `+` <- base::`+`
[09:31:20.303]             `<<-` <- base::`<<-`
[09:31:20.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.303]                   3L)]
[09:31:20.303]             }
[09:31:20.303]             function(cond) {
[09:31:20.303]                 is_error <- inherits(cond, "error")
[09:31:20.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.303]                   NULL)
[09:31:20.303]                 if (is_error) {
[09:31:20.303]                   sessionInformation <- function() {
[09:31:20.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.303]                       search = base::search(), system = base::Sys.info())
[09:31:20.303]                   }
[09:31:20.303]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.303]                     cond$call), session = sessionInformation(), 
[09:31:20.303]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.303]                   signalCondition(cond)
[09:31:20.303]                 }
[09:31:20.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.303]                 "immediateCondition"))) {
[09:31:20.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.303]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.303]                   if (TRUE && !signal) {
[09:31:20.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.303]                     {
[09:31:20.303]                       inherits <- base::inherits
[09:31:20.303]                       invokeRestart <- base::invokeRestart
[09:31:20.303]                       is.null <- base::is.null
[09:31:20.303]                       muffled <- FALSE
[09:31:20.303]                       if (inherits(cond, "message")) {
[09:31:20.303]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.303]                         if (muffled) 
[09:31:20.303]                           invokeRestart("muffleMessage")
[09:31:20.303]                       }
[09:31:20.303]                       else if (inherits(cond, "warning")) {
[09:31:20.303]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.303]                         if (muffled) 
[09:31:20.303]                           invokeRestart("muffleWarning")
[09:31:20.303]                       }
[09:31:20.303]                       else if (inherits(cond, "condition")) {
[09:31:20.303]                         if (!is.null(pattern)) {
[09:31:20.303]                           computeRestarts <- base::computeRestarts
[09:31:20.303]                           grepl <- base::grepl
[09:31:20.303]                           restarts <- computeRestarts(cond)
[09:31:20.303]                           for (restart in restarts) {
[09:31:20.303]                             name <- restart$name
[09:31:20.303]                             if (is.null(name)) 
[09:31:20.303]                               next
[09:31:20.303]                             if (!grepl(pattern, name)) 
[09:31:20.303]                               next
[09:31:20.303]                             invokeRestart(restart)
[09:31:20.303]                             muffled <- TRUE
[09:31:20.303]                             break
[09:31:20.303]                           }
[09:31:20.303]                         }
[09:31:20.303]                       }
[09:31:20.303]                       invisible(muffled)
[09:31:20.303]                     }
[09:31:20.303]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.303]                   }
[09:31:20.303]                 }
[09:31:20.303]                 else {
[09:31:20.303]                   if (TRUE) {
[09:31:20.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.303]                     {
[09:31:20.303]                       inherits <- base::inherits
[09:31:20.303]                       invokeRestart <- base::invokeRestart
[09:31:20.303]                       is.null <- base::is.null
[09:31:20.303]                       muffled <- FALSE
[09:31:20.303]                       if (inherits(cond, "message")) {
[09:31:20.303]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.303]                         if (muffled) 
[09:31:20.303]                           invokeRestart("muffleMessage")
[09:31:20.303]                       }
[09:31:20.303]                       else if (inherits(cond, "warning")) {
[09:31:20.303]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.303]                         if (muffled) 
[09:31:20.303]                           invokeRestart("muffleWarning")
[09:31:20.303]                       }
[09:31:20.303]                       else if (inherits(cond, "condition")) {
[09:31:20.303]                         if (!is.null(pattern)) {
[09:31:20.303]                           computeRestarts <- base::computeRestarts
[09:31:20.303]                           grepl <- base::grepl
[09:31:20.303]                           restarts <- computeRestarts(cond)
[09:31:20.303]                           for (restart in restarts) {
[09:31:20.303]                             name <- restart$name
[09:31:20.303]                             if (is.null(name)) 
[09:31:20.303]                               next
[09:31:20.303]                             if (!grepl(pattern, name)) 
[09:31:20.303]                               next
[09:31:20.303]                             invokeRestart(restart)
[09:31:20.303]                             muffled <- TRUE
[09:31:20.303]                             break
[09:31:20.303]                           }
[09:31:20.303]                         }
[09:31:20.303]                       }
[09:31:20.303]                       invisible(muffled)
[09:31:20.303]                     }
[09:31:20.303]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.303]                   }
[09:31:20.303]                 }
[09:31:20.303]             }
[09:31:20.303]         }))
[09:31:20.303]     }, error = function(ex) {
[09:31:20.303]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.303]                 ...future.rng), started = ...future.startTime, 
[09:31:20.303]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.303]             version = "1.8"), class = "FutureResult")
[09:31:20.303]     }, finally = {
[09:31:20.303]         if (!identical(...future.workdir, getwd())) 
[09:31:20.303]             setwd(...future.workdir)
[09:31:20.303]         {
[09:31:20.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.303]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.303]             }
[09:31:20.303]             base::options(...future.oldOptions)
[09:31:20.303]             if (.Platform$OS.type == "windows") {
[09:31:20.303]                 old_names <- names(...future.oldEnvVars)
[09:31:20.303]                 envs <- base::Sys.getenv()
[09:31:20.303]                 names <- names(envs)
[09:31:20.303]                 common <- intersect(names, old_names)
[09:31:20.303]                 added <- setdiff(names, old_names)
[09:31:20.303]                 removed <- setdiff(old_names, names)
[09:31:20.303]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.303]                   envs[common]]
[09:31:20.303]                 NAMES <- toupper(changed)
[09:31:20.303]                 args <- list()
[09:31:20.303]                 for (kk in seq_along(NAMES)) {
[09:31:20.303]                   name <- changed[[kk]]
[09:31:20.303]                   NAME <- NAMES[[kk]]
[09:31:20.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.303]                     next
[09:31:20.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.303]                 }
[09:31:20.303]                 NAMES <- toupper(added)
[09:31:20.303]                 for (kk in seq_along(NAMES)) {
[09:31:20.303]                   name <- added[[kk]]
[09:31:20.303]                   NAME <- NAMES[[kk]]
[09:31:20.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.303]                     next
[09:31:20.303]                   args[[name]] <- ""
[09:31:20.303]                 }
[09:31:20.303]                 NAMES <- toupper(removed)
[09:31:20.303]                 for (kk in seq_along(NAMES)) {
[09:31:20.303]                   name <- removed[[kk]]
[09:31:20.303]                   NAME <- NAMES[[kk]]
[09:31:20.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.303]                     next
[09:31:20.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.303]                 }
[09:31:20.303]                 if (length(args) > 0) 
[09:31:20.303]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.303]             }
[09:31:20.303]             else {
[09:31:20.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.303]             }
[09:31:20.303]             {
[09:31:20.303]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.303]                   0L) {
[09:31:20.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.303]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.303]                   base::options(opts)
[09:31:20.303]                 }
[09:31:20.303]                 {
[09:31:20.303]                   {
[09:31:20.303]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.303]                     NULL
[09:31:20.303]                   }
[09:31:20.303]                   options(future.plan = NULL)
[09:31:20.303]                   if (is.na(NA_character_)) 
[09:31:20.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.303]                     .init = FALSE)
[09:31:20.303]                 }
[09:31:20.303]             }
[09:31:20.303]         }
[09:31:20.303]     })
[09:31:20.303]     if (TRUE) {
[09:31:20.303]         base::sink(type = "output", split = FALSE)
[09:31:20.303]         if (TRUE) {
[09:31:20.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.303]         }
[09:31:20.303]         else {
[09:31:20.303]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.303]         }
[09:31:20.303]         base::close(...future.stdout)
[09:31:20.303]         ...future.stdout <- NULL
[09:31:20.303]     }
[09:31:20.303]     ...future.result$conditions <- ...future.conditions
[09:31:20.303]     ...future.result$finished <- base::Sys.time()
[09:31:20.303]     ...future.result
[09:31:20.303] }
[09:31:20.306] MultisessionFuture started
[09:31:20.306] - Launch lazy future ... done
[09:31:20.306] run() for ‘MultisessionFuture’ ... done
[09:31:20.306] result() for ClusterFuture ...
[09:31:20.306] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.307] - Validating connection of MultisessionFuture
[09:31:20.350] - received message: FutureResult
[09:31:20.351] - Received FutureResult
[09:31:20.351] - Erased future from FutureRegistry
[09:31:20.351] result() for ClusterFuture ...
[09:31:20.351] - result already collected: FutureResult
[09:31:20.351] result() for ClusterFuture ... done
[09:31:20.351] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.351] result() for ClusterFuture ... done
[09:31:20.351] result() for ClusterFuture ...
[09:31:20.352] - result already collected: FutureResult
[09:31:20.352] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[09:31:20.354] getGlobalsAndPackages() ...
[09:31:20.354] Searching for globals...
[09:31:20.356] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[09:31:20.357] Searching for globals ... DONE
[09:31:20.357] Resolving globals: FALSE
[09:31:20.357] 
[09:31:20.357] - packages: [2] ‘stats’, ‘datasets’
[09:31:20.357] getGlobalsAndPackages() ... DONE
[09:31:20.358] run() for ‘Future’ ...
[09:31:20.358] - state: ‘created’
[09:31:20.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.372]   - Field: ‘node’
[09:31:20.372]   - Field: ‘label’
[09:31:20.372]   - Field: ‘local’
[09:31:20.372]   - Field: ‘owner’
[09:31:20.372]   - Field: ‘envir’
[09:31:20.373]   - Field: ‘workers’
[09:31:20.373]   - Field: ‘packages’
[09:31:20.373]   - Field: ‘gc’
[09:31:20.373]   - Field: ‘conditions’
[09:31:20.373]   - Field: ‘persistent’
[09:31:20.373]   - Field: ‘expr’
[09:31:20.373]   - Field: ‘uuid’
[09:31:20.373]   - Field: ‘seed’
[09:31:20.373]   - Field: ‘version’
[09:31:20.373]   - Field: ‘result’
[09:31:20.373]   - Field: ‘asynchronous’
[09:31:20.373]   - Field: ‘calls’
[09:31:20.374]   - Field: ‘globals’
[09:31:20.374]   - Field: ‘stdout’
[09:31:20.374]   - Field: ‘earlySignal’
[09:31:20.374]   - Field: ‘lazy’
[09:31:20.374]   - Field: ‘state’
[09:31:20.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.374] - Launch lazy future ...
[09:31:20.374] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:20.375] Packages needed by future strategies (n = 0): <none>
[09:31:20.375] {
[09:31:20.375]     {
[09:31:20.375]         {
[09:31:20.375]             ...future.startTime <- base::Sys.time()
[09:31:20.375]             {
[09:31:20.375]                 {
[09:31:20.375]                   {
[09:31:20.375]                     {
[09:31:20.375]                       {
[09:31:20.375]                         base::local({
[09:31:20.375]                           has_future <- base::requireNamespace("future", 
[09:31:20.375]                             quietly = TRUE)
[09:31:20.375]                           if (has_future) {
[09:31:20.375]                             ns <- base::getNamespace("future")
[09:31:20.375]                             version <- ns[[".package"]][["version"]]
[09:31:20.375]                             if (is.null(version)) 
[09:31:20.375]                               version <- utils::packageVersion("future")
[09:31:20.375]                           }
[09:31:20.375]                           else {
[09:31:20.375]                             version <- NULL
[09:31:20.375]                           }
[09:31:20.375]                           if (!has_future || version < "1.8.0") {
[09:31:20.375]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.375]                               "", base::R.version$version.string), 
[09:31:20.375]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.375]                                 base::R.version$platform, 8 * 
[09:31:20.375]                                   base::.Machine$sizeof.pointer), 
[09:31:20.375]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.375]                                 "release", "version")], collapse = " "), 
[09:31:20.375]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.375]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.375]                               info)
[09:31:20.375]                             info <- base::paste(info, collapse = "; ")
[09:31:20.375]                             if (!has_future) {
[09:31:20.375]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.375]                                 info)
[09:31:20.375]                             }
[09:31:20.375]                             else {
[09:31:20.375]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.375]                                 info, version)
[09:31:20.375]                             }
[09:31:20.375]                             base::stop(msg)
[09:31:20.375]                           }
[09:31:20.375]                         })
[09:31:20.375]                       }
[09:31:20.375]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.375]                       base::options(mc.cores = 1L)
[09:31:20.375]                     }
[09:31:20.375]                     base::local({
[09:31:20.375]                       for (pkg in c("stats", "datasets")) {
[09:31:20.375]                         base::loadNamespace(pkg)
[09:31:20.375]                         base::library(pkg, character.only = TRUE)
[09:31:20.375]                       }
[09:31:20.375]                     })
[09:31:20.375]                   }
[09:31:20.375]                   ...future.strategy.old <- future::plan("list")
[09:31:20.375]                   options(future.plan = NULL)
[09:31:20.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.375]                 }
[09:31:20.375]                 ...future.workdir <- getwd()
[09:31:20.375]             }
[09:31:20.375]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.375]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.375]         }
[09:31:20.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.375]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.375]             base::names(...future.oldOptions))
[09:31:20.375]     }
[09:31:20.375]     if (FALSE) {
[09:31:20.375]     }
[09:31:20.375]     else {
[09:31:20.375]         if (TRUE) {
[09:31:20.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.375]                 open = "w")
[09:31:20.375]         }
[09:31:20.375]         else {
[09:31:20.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.375]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.375]         }
[09:31:20.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.375]             base::sink(type = "output", split = FALSE)
[09:31:20.375]             base::close(...future.stdout)
[09:31:20.375]         }, add = TRUE)
[09:31:20.375]     }
[09:31:20.375]     ...future.frame <- base::sys.nframe()
[09:31:20.375]     ...future.conditions <- base::list()
[09:31:20.375]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.375]     if (FALSE) {
[09:31:20.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.375]     }
[09:31:20.375]     ...future.result <- base::tryCatch({
[09:31:20.375]         base::withCallingHandlers({
[09:31:20.375]             ...future.value <- base::withVisible(base::local({
[09:31:20.375]                 ...future.makeSendCondition <- base::local({
[09:31:20.375]                   sendCondition <- NULL
[09:31:20.375]                   function(frame = 1L) {
[09:31:20.375]                     if (is.function(sendCondition)) 
[09:31:20.375]                       return(sendCondition)
[09:31:20.375]                     ns <- getNamespace("parallel")
[09:31:20.375]                     if (exists("sendData", mode = "function", 
[09:31:20.375]                       envir = ns)) {
[09:31:20.375]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.375]                         envir = ns)
[09:31:20.375]                       envir <- sys.frame(frame)
[09:31:20.375]                       master <- NULL
[09:31:20.375]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.375]                         !identical(envir, emptyenv())) {
[09:31:20.375]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.375]                           inherits = FALSE)) {
[09:31:20.375]                           master <- get("master", mode = "list", 
[09:31:20.375]                             envir = envir, inherits = FALSE)
[09:31:20.375]                           if (inherits(master, c("SOCKnode", 
[09:31:20.375]                             "SOCK0node"))) {
[09:31:20.375]                             sendCondition <<- function(cond) {
[09:31:20.375]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.375]                                 success = TRUE)
[09:31:20.375]                               parallel_sendData(master, data)
[09:31:20.375]                             }
[09:31:20.375]                             return(sendCondition)
[09:31:20.375]                           }
[09:31:20.375]                         }
[09:31:20.375]                         frame <- frame + 1L
[09:31:20.375]                         envir <- sys.frame(frame)
[09:31:20.375]                       }
[09:31:20.375]                     }
[09:31:20.375]                     sendCondition <<- function(cond) NULL
[09:31:20.375]                   }
[09:31:20.375]                 })
[09:31:20.375]                 withCallingHandlers({
[09:31:20.375]                   {
[09:31:20.375]                     lm(dist ~ speed + I(speed^2), data = cars)
[09:31:20.375]                   }
[09:31:20.375]                 }, immediateCondition = function(cond) {
[09:31:20.375]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.375]                   sendCondition(cond)
[09:31:20.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.375]                   {
[09:31:20.375]                     inherits <- base::inherits
[09:31:20.375]                     invokeRestart <- base::invokeRestart
[09:31:20.375]                     is.null <- base::is.null
[09:31:20.375]                     muffled <- FALSE
[09:31:20.375]                     if (inherits(cond, "message")) {
[09:31:20.375]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.375]                       if (muffled) 
[09:31:20.375]                         invokeRestart("muffleMessage")
[09:31:20.375]                     }
[09:31:20.375]                     else if (inherits(cond, "warning")) {
[09:31:20.375]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.375]                       if (muffled) 
[09:31:20.375]                         invokeRestart("muffleWarning")
[09:31:20.375]                     }
[09:31:20.375]                     else if (inherits(cond, "condition")) {
[09:31:20.375]                       if (!is.null(pattern)) {
[09:31:20.375]                         computeRestarts <- base::computeRestarts
[09:31:20.375]                         grepl <- base::grepl
[09:31:20.375]                         restarts <- computeRestarts(cond)
[09:31:20.375]                         for (restart in restarts) {
[09:31:20.375]                           name <- restart$name
[09:31:20.375]                           if (is.null(name)) 
[09:31:20.375]                             next
[09:31:20.375]                           if (!grepl(pattern, name)) 
[09:31:20.375]                             next
[09:31:20.375]                           invokeRestart(restart)
[09:31:20.375]                           muffled <- TRUE
[09:31:20.375]                           break
[09:31:20.375]                         }
[09:31:20.375]                       }
[09:31:20.375]                     }
[09:31:20.375]                     invisible(muffled)
[09:31:20.375]                   }
[09:31:20.375]                   muffleCondition(cond)
[09:31:20.375]                 })
[09:31:20.375]             }))
[09:31:20.375]             future::FutureResult(value = ...future.value$value, 
[09:31:20.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.375]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.375]                     ...future.globalenv.names))
[09:31:20.375]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.375]         }, condition = base::local({
[09:31:20.375]             c <- base::c
[09:31:20.375]             inherits <- base::inherits
[09:31:20.375]             invokeRestart <- base::invokeRestart
[09:31:20.375]             length <- base::length
[09:31:20.375]             list <- base::list
[09:31:20.375]             seq.int <- base::seq.int
[09:31:20.375]             signalCondition <- base::signalCondition
[09:31:20.375]             sys.calls <- base::sys.calls
[09:31:20.375]             `[[` <- base::`[[`
[09:31:20.375]             `+` <- base::`+`
[09:31:20.375]             `<<-` <- base::`<<-`
[09:31:20.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.375]                   3L)]
[09:31:20.375]             }
[09:31:20.375]             function(cond) {
[09:31:20.375]                 is_error <- inherits(cond, "error")
[09:31:20.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.375]                   NULL)
[09:31:20.375]                 if (is_error) {
[09:31:20.375]                   sessionInformation <- function() {
[09:31:20.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.375]                       search = base::search(), system = base::Sys.info())
[09:31:20.375]                   }
[09:31:20.375]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.375]                     cond$call), session = sessionInformation(), 
[09:31:20.375]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.375]                   signalCondition(cond)
[09:31:20.375]                 }
[09:31:20.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.375]                 "immediateCondition"))) {
[09:31:20.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.375]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.375]                   if (TRUE && !signal) {
[09:31:20.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.375]                     {
[09:31:20.375]                       inherits <- base::inherits
[09:31:20.375]                       invokeRestart <- base::invokeRestart
[09:31:20.375]                       is.null <- base::is.null
[09:31:20.375]                       muffled <- FALSE
[09:31:20.375]                       if (inherits(cond, "message")) {
[09:31:20.375]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.375]                         if (muffled) 
[09:31:20.375]                           invokeRestart("muffleMessage")
[09:31:20.375]                       }
[09:31:20.375]                       else if (inherits(cond, "warning")) {
[09:31:20.375]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.375]                         if (muffled) 
[09:31:20.375]                           invokeRestart("muffleWarning")
[09:31:20.375]                       }
[09:31:20.375]                       else if (inherits(cond, "condition")) {
[09:31:20.375]                         if (!is.null(pattern)) {
[09:31:20.375]                           computeRestarts <- base::computeRestarts
[09:31:20.375]                           grepl <- base::grepl
[09:31:20.375]                           restarts <- computeRestarts(cond)
[09:31:20.375]                           for (restart in restarts) {
[09:31:20.375]                             name <- restart$name
[09:31:20.375]                             if (is.null(name)) 
[09:31:20.375]                               next
[09:31:20.375]                             if (!grepl(pattern, name)) 
[09:31:20.375]                               next
[09:31:20.375]                             invokeRestart(restart)
[09:31:20.375]                             muffled <- TRUE
[09:31:20.375]                             break
[09:31:20.375]                           }
[09:31:20.375]                         }
[09:31:20.375]                       }
[09:31:20.375]                       invisible(muffled)
[09:31:20.375]                     }
[09:31:20.375]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.375]                   }
[09:31:20.375]                 }
[09:31:20.375]                 else {
[09:31:20.375]                   if (TRUE) {
[09:31:20.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.375]                     {
[09:31:20.375]                       inherits <- base::inherits
[09:31:20.375]                       invokeRestart <- base::invokeRestart
[09:31:20.375]                       is.null <- base::is.null
[09:31:20.375]                       muffled <- FALSE
[09:31:20.375]                       if (inherits(cond, "message")) {
[09:31:20.375]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.375]                         if (muffled) 
[09:31:20.375]                           invokeRestart("muffleMessage")
[09:31:20.375]                       }
[09:31:20.375]                       else if (inherits(cond, "warning")) {
[09:31:20.375]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.375]                         if (muffled) 
[09:31:20.375]                           invokeRestart("muffleWarning")
[09:31:20.375]                       }
[09:31:20.375]                       else if (inherits(cond, "condition")) {
[09:31:20.375]                         if (!is.null(pattern)) {
[09:31:20.375]                           computeRestarts <- base::computeRestarts
[09:31:20.375]                           grepl <- base::grepl
[09:31:20.375]                           restarts <- computeRestarts(cond)
[09:31:20.375]                           for (restart in restarts) {
[09:31:20.375]                             name <- restart$name
[09:31:20.375]                             if (is.null(name)) 
[09:31:20.375]                               next
[09:31:20.375]                             if (!grepl(pattern, name)) 
[09:31:20.375]                               next
[09:31:20.375]                             invokeRestart(restart)
[09:31:20.375]                             muffled <- TRUE
[09:31:20.375]                             break
[09:31:20.375]                           }
[09:31:20.375]                         }
[09:31:20.375]                       }
[09:31:20.375]                       invisible(muffled)
[09:31:20.375]                     }
[09:31:20.375]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.375]                   }
[09:31:20.375]                 }
[09:31:20.375]             }
[09:31:20.375]         }))
[09:31:20.375]     }, error = function(ex) {
[09:31:20.375]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.375]                 ...future.rng), started = ...future.startTime, 
[09:31:20.375]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.375]             version = "1.8"), class = "FutureResult")
[09:31:20.375]     }, finally = {
[09:31:20.375]         if (!identical(...future.workdir, getwd())) 
[09:31:20.375]             setwd(...future.workdir)
[09:31:20.375]         {
[09:31:20.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.375]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.375]             }
[09:31:20.375]             base::options(...future.oldOptions)
[09:31:20.375]             if (.Platform$OS.type == "windows") {
[09:31:20.375]                 old_names <- names(...future.oldEnvVars)
[09:31:20.375]                 envs <- base::Sys.getenv()
[09:31:20.375]                 names <- names(envs)
[09:31:20.375]                 common <- intersect(names, old_names)
[09:31:20.375]                 added <- setdiff(names, old_names)
[09:31:20.375]                 removed <- setdiff(old_names, names)
[09:31:20.375]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.375]                   envs[common]]
[09:31:20.375]                 NAMES <- toupper(changed)
[09:31:20.375]                 args <- list()
[09:31:20.375]                 for (kk in seq_along(NAMES)) {
[09:31:20.375]                   name <- changed[[kk]]
[09:31:20.375]                   NAME <- NAMES[[kk]]
[09:31:20.375]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.375]                     next
[09:31:20.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.375]                 }
[09:31:20.375]                 NAMES <- toupper(added)
[09:31:20.375]                 for (kk in seq_along(NAMES)) {
[09:31:20.375]                   name <- added[[kk]]
[09:31:20.375]                   NAME <- NAMES[[kk]]
[09:31:20.375]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.375]                     next
[09:31:20.375]                   args[[name]] <- ""
[09:31:20.375]                 }
[09:31:20.375]                 NAMES <- toupper(removed)
[09:31:20.375]                 for (kk in seq_along(NAMES)) {
[09:31:20.375]                   name <- removed[[kk]]
[09:31:20.375]                   NAME <- NAMES[[kk]]
[09:31:20.375]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.375]                     next
[09:31:20.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.375]                 }
[09:31:20.375]                 if (length(args) > 0) 
[09:31:20.375]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.375]             }
[09:31:20.375]             else {
[09:31:20.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.375]             }
[09:31:20.375]             {
[09:31:20.375]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.375]                   0L) {
[09:31:20.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.375]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.375]                   base::options(opts)
[09:31:20.375]                 }
[09:31:20.375]                 {
[09:31:20.375]                   {
[09:31:20.375]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.375]                     NULL
[09:31:20.375]                   }
[09:31:20.375]                   options(future.plan = NULL)
[09:31:20.375]                   if (is.na(NA_character_)) 
[09:31:20.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.375]                     .init = FALSE)
[09:31:20.375]                 }
[09:31:20.375]             }
[09:31:20.375]         }
[09:31:20.375]     })
[09:31:20.375]     if (TRUE) {
[09:31:20.375]         base::sink(type = "output", split = FALSE)
[09:31:20.375]         if (TRUE) {
[09:31:20.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.375]         }
[09:31:20.375]         else {
[09:31:20.375]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.375]         }
[09:31:20.375]         base::close(...future.stdout)
[09:31:20.375]         ...future.stdout <- NULL
[09:31:20.375]     }
[09:31:20.375]     ...future.result$conditions <- ...future.conditions
[09:31:20.375]     ...future.result$finished <- base::Sys.time()
[09:31:20.375]     ...future.result
[09:31:20.375] }
[09:31:20.378] MultisessionFuture started
[09:31:20.378] - Launch lazy future ... done
[09:31:20.378] run() for ‘MultisessionFuture’ ... done
[09:31:20.378] result() for ClusterFuture ...
[09:31:20.378] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.379] - Validating connection of MultisessionFuture
[09:31:20.422] - received message: FutureResult
[09:31:20.422] - Received FutureResult
[09:31:20.423] - Erased future from FutureRegistry
[09:31:20.423] result() for ClusterFuture ...
[09:31:20.423] - result already collected: FutureResult
[09:31:20.423] result() for ClusterFuture ... done
[09:31:20.423] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.423] result() for ClusterFuture ... done
[09:31:20.423] result() for ClusterFuture ...
[09:31:20.423] - result already collected: FutureResult
[09:31:20.423] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[09:31:20.426] getGlobalsAndPackages() ...
[09:31:20.426] Searching for globals...
[09:31:20.428] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[09:31:20.428] Searching for globals ... DONE
[09:31:20.428] Resolving globals: FALSE
[09:31:20.428] 
[09:31:20.428] - packages: [2] ‘stats’, ‘datasets’
[09:31:20.428] getGlobalsAndPackages() ... DONE
[09:31:20.429] run() for ‘Future’ ...
[09:31:20.429] - state: ‘created’
[09:31:20.429] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.442] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.443]   - Field: ‘node’
[09:31:20.443]   - Field: ‘label’
[09:31:20.443]   - Field: ‘local’
[09:31:20.443]   - Field: ‘owner’
[09:31:20.443]   - Field: ‘envir’
[09:31:20.443]   - Field: ‘workers’
[09:31:20.443]   - Field: ‘packages’
[09:31:20.443]   - Field: ‘gc’
[09:31:20.443]   - Field: ‘conditions’
[09:31:20.443]   - Field: ‘persistent’
[09:31:20.443]   - Field: ‘expr’
[09:31:20.444]   - Field: ‘uuid’
[09:31:20.444]   - Field: ‘seed’
[09:31:20.444]   - Field: ‘version’
[09:31:20.444]   - Field: ‘result’
[09:31:20.444]   - Field: ‘asynchronous’
[09:31:20.444]   - Field: ‘calls’
[09:31:20.444]   - Field: ‘globals’
[09:31:20.444]   - Field: ‘stdout’
[09:31:20.444]   - Field: ‘earlySignal’
[09:31:20.444]   - Field: ‘lazy’
[09:31:20.444]   - Field: ‘state’
[09:31:20.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.445] - Launch lazy future ...
[09:31:20.445] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[09:31:20.445] Packages needed by future strategies (n = 0): <none>
[09:31:20.446] {
[09:31:20.446]     {
[09:31:20.446]         {
[09:31:20.446]             ...future.startTime <- base::Sys.time()
[09:31:20.446]             {
[09:31:20.446]                 {
[09:31:20.446]                   {
[09:31:20.446]                     {
[09:31:20.446]                       {
[09:31:20.446]                         base::local({
[09:31:20.446]                           has_future <- base::requireNamespace("future", 
[09:31:20.446]                             quietly = TRUE)
[09:31:20.446]                           if (has_future) {
[09:31:20.446]                             ns <- base::getNamespace("future")
[09:31:20.446]                             version <- ns[[".package"]][["version"]]
[09:31:20.446]                             if (is.null(version)) 
[09:31:20.446]                               version <- utils::packageVersion("future")
[09:31:20.446]                           }
[09:31:20.446]                           else {
[09:31:20.446]                             version <- NULL
[09:31:20.446]                           }
[09:31:20.446]                           if (!has_future || version < "1.8.0") {
[09:31:20.446]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.446]                               "", base::R.version$version.string), 
[09:31:20.446]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:20.446]                                 base::R.version$platform, 8 * 
[09:31:20.446]                                   base::.Machine$sizeof.pointer), 
[09:31:20.446]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.446]                                 "release", "version")], collapse = " "), 
[09:31:20.446]                               hostname = base::Sys.info()[["nodename"]])
[09:31:20.446]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.446]                               info)
[09:31:20.446]                             info <- base::paste(info, collapse = "; ")
[09:31:20.446]                             if (!has_future) {
[09:31:20.446]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.446]                                 info)
[09:31:20.446]                             }
[09:31:20.446]                             else {
[09:31:20.446]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.446]                                 info, version)
[09:31:20.446]                             }
[09:31:20.446]                             base::stop(msg)
[09:31:20.446]                           }
[09:31:20.446]                         })
[09:31:20.446]                       }
[09:31:20.446]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.446]                       base::options(mc.cores = 1L)
[09:31:20.446]                     }
[09:31:20.446]                     base::local({
[09:31:20.446]                       for (pkg in c("stats", "datasets")) {
[09:31:20.446]                         base::loadNamespace(pkg)
[09:31:20.446]                         base::library(pkg, character.only = TRUE)
[09:31:20.446]                       }
[09:31:20.446]                     })
[09:31:20.446]                   }
[09:31:20.446]                   ...future.strategy.old <- future::plan("list")
[09:31:20.446]                   options(future.plan = NULL)
[09:31:20.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.446]                 }
[09:31:20.446]                 ...future.workdir <- getwd()
[09:31:20.446]             }
[09:31:20.446]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.446]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.446]         }
[09:31:20.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.446]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.446]             base::names(...future.oldOptions))
[09:31:20.446]     }
[09:31:20.446]     if (FALSE) {
[09:31:20.446]     }
[09:31:20.446]     else {
[09:31:20.446]         if (TRUE) {
[09:31:20.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.446]                 open = "w")
[09:31:20.446]         }
[09:31:20.446]         else {
[09:31:20.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.446]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.446]         }
[09:31:20.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.446]             base::sink(type = "output", split = FALSE)
[09:31:20.446]             base::close(...future.stdout)
[09:31:20.446]         }, add = TRUE)
[09:31:20.446]     }
[09:31:20.446]     ...future.frame <- base::sys.nframe()
[09:31:20.446]     ...future.conditions <- base::list()
[09:31:20.446]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.446]     if (FALSE) {
[09:31:20.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.446]     }
[09:31:20.446]     ...future.result <- base::tryCatch({
[09:31:20.446]         base::withCallingHandlers({
[09:31:20.446]             ...future.value <- base::withVisible(base::local({
[09:31:20.446]                 ...future.makeSendCondition <- base::local({
[09:31:20.446]                   sendCondition <- NULL
[09:31:20.446]                   function(frame = 1L) {
[09:31:20.446]                     if (is.function(sendCondition)) 
[09:31:20.446]                       return(sendCondition)
[09:31:20.446]                     ns <- getNamespace("parallel")
[09:31:20.446]                     if (exists("sendData", mode = "function", 
[09:31:20.446]                       envir = ns)) {
[09:31:20.446]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.446]                         envir = ns)
[09:31:20.446]                       envir <- sys.frame(frame)
[09:31:20.446]                       master <- NULL
[09:31:20.446]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.446]                         !identical(envir, emptyenv())) {
[09:31:20.446]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.446]                           inherits = FALSE)) {
[09:31:20.446]                           master <- get("master", mode = "list", 
[09:31:20.446]                             envir = envir, inherits = FALSE)
[09:31:20.446]                           if (inherits(master, c("SOCKnode", 
[09:31:20.446]                             "SOCK0node"))) {
[09:31:20.446]                             sendCondition <<- function(cond) {
[09:31:20.446]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.446]                                 success = TRUE)
[09:31:20.446]                               parallel_sendData(master, data)
[09:31:20.446]                             }
[09:31:20.446]                             return(sendCondition)
[09:31:20.446]                           }
[09:31:20.446]                         }
[09:31:20.446]                         frame <- frame + 1L
[09:31:20.446]                         envir <- sys.frame(frame)
[09:31:20.446]                       }
[09:31:20.446]                     }
[09:31:20.446]                     sendCondition <<- function(cond) NULL
[09:31:20.446]                   }
[09:31:20.446]                 })
[09:31:20.446]                 withCallingHandlers({
[09:31:20.446]                   {
[09:31:20.446]                     lm(dist ~ poly(speed, 2), data = cars)
[09:31:20.446]                   }
[09:31:20.446]                 }, immediateCondition = function(cond) {
[09:31:20.446]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.446]                   sendCondition(cond)
[09:31:20.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.446]                   {
[09:31:20.446]                     inherits <- base::inherits
[09:31:20.446]                     invokeRestart <- base::invokeRestart
[09:31:20.446]                     is.null <- base::is.null
[09:31:20.446]                     muffled <- FALSE
[09:31:20.446]                     if (inherits(cond, "message")) {
[09:31:20.446]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.446]                       if (muffled) 
[09:31:20.446]                         invokeRestart("muffleMessage")
[09:31:20.446]                     }
[09:31:20.446]                     else if (inherits(cond, "warning")) {
[09:31:20.446]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.446]                       if (muffled) 
[09:31:20.446]                         invokeRestart("muffleWarning")
[09:31:20.446]                     }
[09:31:20.446]                     else if (inherits(cond, "condition")) {
[09:31:20.446]                       if (!is.null(pattern)) {
[09:31:20.446]                         computeRestarts <- base::computeRestarts
[09:31:20.446]                         grepl <- base::grepl
[09:31:20.446]                         restarts <- computeRestarts(cond)
[09:31:20.446]                         for (restart in restarts) {
[09:31:20.446]                           name <- restart$name
[09:31:20.446]                           if (is.null(name)) 
[09:31:20.446]                             next
[09:31:20.446]                           if (!grepl(pattern, name)) 
[09:31:20.446]                             next
[09:31:20.446]                           invokeRestart(restart)
[09:31:20.446]                           muffled <- TRUE
[09:31:20.446]                           break
[09:31:20.446]                         }
[09:31:20.446]                       }
[09:31:20.446]                     }
[09:31:20.446]                     invisible(muffled)
[09:31:20.446]                   }
[09:31:20.446]                   muffleCondition(cond)
[09:31:20.446]                 })
[09:31:20.446]             }))
[09:31:20.446]             future::FutureResult(value = ...future.value$value, 
[09:31:20.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.446]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.446]                     ...future.globalenv.names))
[09:31:20.446]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.446]         }, condition = base::local({
[09:31:20.446]             c <- base::c
[09:31:20.446]             inherits <- base::inherits
[09:31:20.446]             invokeRestart <- base::invokeRestart
[09:31:20.446]             length <- base::length
[09:31:20.446]             list <- base::list
[09:31:20.446]             seq.int <- base::seq.int
[09:31:20.446]             signalCondition <- base::signalCondition
[09:31:20.446]             sys.calls <- base::sys.calls
[09:31:20.446]             `[[` <- base::`[[`
[09:31:20.446]             `+` <- base::`+`
[09:31:20.446]             `<<-` <- base::`<<-`
[09:31:20.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.446]                   3L)]
[09:31:20.446]             }
[09:31:20.446]             function(cond) {
[09:31:20.446]                 is_error <- inherits(cond, "error")
[09:31:20.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.446]                   NULL)
[09:31:20.446]                 if (is_error) {
[09:31:20.446]                   sessionInformation <- function() {
[09:31:20.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.446]                       search = base::search(), system = base::Sys.info())
[09:31:20.446]                   }
[09:31:20.446]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.446]                     cond$call), session = sessionInformation(), 
[09:31:20.446]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.446]                   signalCondition(cond)
[09:31:20.446]                 }
[09:31:20.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.446]                 "immediateCondition"))) {
[09:31:20.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.446]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.446]                   if (TRUE && !signal) {
[09:31:20.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.446]                     {
[09:31:20.446]                       inherits <- base::inherits
[09:31:20.446]                       invokeRestart <- base::invokeRestart
[09:31:20.446]                       is.null <- base::is.null
[09:31:20.446]                       muffled <- FALSE
[09:31:20.446]                       if (inherits(cond, "message")) {
[09:31:20.446]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.446]                         if (muffled) 
[09:31:20.446]                           invokeRestart("muffleMessage")
[09:31:20.446]                       }
[09:31:20.446]                       else if (inherits(cond, "warning")) {
[09:31:20.446]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.446]                         if (muffled) 
[09:31:20.446]                           invokeRestart("muffleWarning")
[09:31:20.446]                       }
[09:31:20.446]                       else if (inherits(cond, "condition")) {
[09:31:20.446]                         if (!is.null(pattern)) {
[09:31:20.446]                           computeRestarts <- base::computeRestarts
[09:31:20.446]                           grepl <- base::grepl
[09:31:20.446]                           restarts <- computeRestarts(cond)
[09:31:20.446]                           for (restart in restarts) {
[09:31:20.446]                             name <- restart$name
[09:31:20.446]                             if (is.null(name)) 
[09:31:20.446]                               next
[09:31:20.446]                             if (!grepl(pattern, name)) 
[09:31:20.446]                               next
[09:31:20.446]                             invokeRestart(restart)
[09:31:20.446]                             muffled <- TRUE
[09:31:20.446]                             break
[09:31:20.446]                           }
[09:31:20.446]                         }
[09:31:20.446]                       }
[09:31:20.446]                       invisible(muffled)
[09:31:20.446]                     }
[09:31:20.446]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.446]                   }
[09:31:20.446]                 }
[09:31:20.446]                 else {
[09:31:20.446]                   if (TRUE) {
[09:31:20.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.446]                     {
[09:31:20.446]                       inherits <- base::inherits
[09:31:20.446]                       invokeRestart <- base::invokeRestart
[09:31:20.446]                       is.null <- base::is.null
[09:31:20.446]                       muffled <- FALSE
[09:31:20.446]                       if (inherits(cond, "message")) {
[09:31:20.446]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.446]                         if (muffled) 
[09:31:20.446]                           invokeRestart("muffleMessage")
[09:31:20.446]                       }
[09:31:20.446]                       else if (inherits(cond, "warning")) {
[09:31:20.446]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.446]                         if (muffled) 
[09:31:20.446]                           invokeRestart("muffleWarning")
[09:31:20.446]                       }
[09:31:20.446]                       else if (inherits(cond, "condition")) {
[09:31:20.446]                         if (!is.null(pattern)) {
[09:31:20.446]                           computeRestarts <- base::computeRestarts
[09:31:20.446]                           grepl <- base::grepl
[09:31:20.446]                           restarts <- computeRestarts(cond)
[09:31:20.446]                           for (restart in restarts) {
[09:31:20.446]                             name <- restart$name
[09:31:20.446]                             if (is.null(name)) 
[09:31:20.446]                               next
[09:31:20.446]                             if (!grepl(pattern, name)) 
[09:31:20.446]                               next
[09:31:20.446]                             invokeRestart(restart)
[09:31:20.446]                             muffled <- TRUE
[09:31:20.446]                             break
[09:31:20.446]                           }
[09:31:20.446]                         }
[09:31:20.446]                       }
[09:31:20.446]                       invisible(muffled)
[09:31:20.446]                     }
[09:31:20.446]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.446]                   }
[09:31:20.446]                 }
[09:31:20.446]             }
[09:31:20.446]         }))
[09:31:20.446]     }, error = function(ex) {
[09:31:20.446]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.446]                 ...future.rng), started = ...future.startTime, 
[09:31:20.446]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.446]             version = "1.8"), class = "FutureResult")
[09:31:20.446]     }, finally = {
[09:31:20.446]         if (!identical(...future.workdir, getwd())) 
[09:31:20.446]             setwd(...future.workdir)
[09:31:20.446]         {
[09:31:20.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.446]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.446]             }
[09:31:20.446]             base::options(...future.oldOptions)
[09:31:20.446]             if (.Platform$OS.type == "windows") {
[09:31:20.446]                 old_names <- names(...future.oldEnvVars)
[09:31:20.446]                 envs <- base::Sys.getenv()
[09:31:20.446]                 names <- names(envs)
[09:31:20.446]                 common <- intersect(names, old_names)
[09:31:20.446]                 added <- setdiff(names, old_names)
[09:31:20.446]                 removed <- setdiff(old_names, names)
[09:31:20.446]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.446]                   envs[common]]
[09:31:20.446]                 NAMES <- toupper(changed)
[09:31:20.446]                 args <- list()
[09:31:20.446]                 for (kk in seq_along(NAMES)) {
[09:31:20.446]                   name <- changed[[kk]]
[09:31:20.446]                   NAME <- NAMES[[kk]]
[09:31:20.446]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.446]                     next
[09:31:20.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.446]                 }
[09:31:20.446]                 NAMES <- toupper(added)
[09:31:20.446]                 for (kk in seq_along(NAMES)) {
[09:31:20.446]                   name <- added[[kk]]
[09:31:20.446]                   NAME <- NAMES[[kk]]
[09:31:20.446]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.446]                     next
[09:31:20.446]                   args[[name]] <- ""
[09:31:20.446]                 }
[09:31:20.446]                 NAMES <- toupper(removed)
[09:31:20.446]                 for (kk in seq_along(NAMES)) {
[09:31:20.446]                   name <- removed[[kk]]
[09:31:20.446]                   NAME <- NAMES[[kk]]
[09:31:20.446]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.446]                     next
[09:31:20.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.446]                 }
[09:31:20.446]                 if (length(args) > 0) 
[09:31:20.446]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.446]             }
[09:31:20.446]             else {
[09:31:20.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.446]             }
[09:31:20.446]             {
[09:31:20.446]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.446]                   0L) {
[09:31:20.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.446]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.446]                   base::options(opts)
[09:31:20.446]                 }
[09:31:20.446]                 {
[09:31:20.446]                   {
[09:31:20.446]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.446]                     NULL
[09:31:20.446]                   }
[09:31:20.446]                   options(future.plan = NULL)
[09:31:20.446]                   if (is.na(NA_character_)) 
[09:31:20.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.446]                     .init = FALSE)
[09:31:20.446]                 }
[09:31:20.446]             }
[09:31:20.446]         }
[09:31:20.446]     })
[09:31:20.446]     if (TRUE) {
[09:31:20.446]         base::sink(type = "output", split = FALSE)
[09:31:20.446]         if (TRUE) {
[09:31:20.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.446]         }
[09:31:20.446]         else {
[09:31:20.446]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.446]         }
[09:31:20.446]         base::close(...future.stdout)
[09:31:20.446]         ...future.stdout <- NULL
[09:31:20.446]     }
[09:31:20.446]     ...future.result$conditions <- ...future.conditions
[09:31:20.446]     ...future.result$finished <- base::Sys.time()
[09:31:20.446]     ...future.result
[09:31:20.446] }
[09:31:20.448] MultisessionFuture started
[09:31:20.449] - Launch lazy future ... done
[09:31:20.449] run() for ‘MultisessionFuture’ ... done
[09:31:20.449] result() for ClusterFuture ...
[09:31:20.449] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.449] - Validating connection of MultisessionFuture
[09:31:20.452] - received message: FutureResult
[09:31:20.452] - Received FutureResult
[09:31:20.452] - Erased future from FutureRegistry
[09:31:20.452] result() for ClusterFuture ...
[09:31:20.452] - result already collected: FutureResult
[09:31:20.452] result() for ClusterFuture ... done
[09:31:20.452] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.452] result() for ClusterFuture ... done
[09:31:20.452] result() for ClusterFuture ...
[09:31:20.453] - result already collected: FutureResult
[09:31:20.453] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[09:31:20.454] getGlobalsAndPackages() ...
[09:31:20.454] Searching for globals...
[09:31:20.458] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[09:31:20.459] Searching for globals ... DONE
[09:31:20.459] Resolving globals: FALSE
[09:31:20.459] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[09:31:20.460] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[09:31:20.460] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[09:31:20.460] 
[09:31:20.460] getGlobalsAndPackages() ... DONE
[09:31:20.460] run() for ‘Future’ ...
[09:31:20.460] - state: ‘created’
[09:31:20.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.474]   - Field: ‘node’
[09:31:20.474]   - Field: ‘label’
[09:31:20.474]   - Field: ‘local’
[09:31:20.474]   - Field: ‘owner’
[09:31:20.474]   - Field: ‘envir’
[09:31:20.474]   - Field: ‘workers’
[09:31:20.475]   - Field: ‘packages’
[09:31:20.475]   - Field: ‘gc’
[09:31:20.475]   - Field: ‘conditions’
[09:31:20.475]   - Field: ‘persistent’
[09:31:20.475]   - Field: ‘expr’
[09:31:20.475]   - Field: ‘uuid’
[09:31:20.475]   - Field: ‘seed’
[09:31:20.475]   - Field: ‘version’
[09:31:20.475]   - Field: ‘result’
[09:31:20.475]   - Field: ‘asynchronous’
[09:31:20.475]   - Field: ‘calls’
[09:31:20.476]   - Field: ‘globals’
[09:31:20.476]   - Field: ‘stdout’
[09:31:20.476]   - Field: ‘earlySignal’
[09:31:20.476]   - Field: ‘lazy’
[09:31:20.476]   - Field: ‘state’
[09:31:20.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.476] - Launch lazy future ...
[09:31:20.476] Packages needed by the future expression (n = 0): <none>
[09:31:20.477] Packages needed by future strategies (n = 0): <none>
[09:31:20.477] {
[09:31:20.477]     {
[09:31:20.477]         {
[09:31:20.477]             ...future.startTime <- base::Sys.time()
[09:31:20.477]             {
[09:31:20.477]                 {
[09:31:20.477]                   {
[09:31:20.477]                     {
[09:31:20.477]                       base::local({
[09:31:20.477]                         has_future <- base::requireNamespace("future", 
[09:31:20.477]                           quietly = TRUE)
[09:31:20.477]                         if (has_future) {
[09:31:20.477]                           ns <- base::getNamespace("future")
[09:31:20.477]                           version <- ns[[".package"]][["version"]]
[09:31:20.477]                           if (is.null(version)) 
[09:31:20.477]                             version <- utils::packageVersion("future")
[09:31:20.477]                         }
[09:31:20.477]                         else {
[09:31:20.477]                           version <- NULL
[09:31:20.477]                         }
[09:31:20.477]                         if (!has_future || version < "1.8.0") {
[09:31:20.477]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.477]                             "", base::R.version$version.string), 
[09:31:20.477]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:20.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:20.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.477]                               "release", "version")], collapse = " "), 
[09:31:20.477]                             hostname = base::Sys.info()[["nodename"]])
[09:31:20.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.477]                             info)
[09:31:20.477]                           info <- base::paste(info, collapse = "; ")
[09:31:20.477]                           if (!has_future) {
[09:31:20.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.477]                               info)
[09:31:20.477]                           }
[09:31:20.477]                           else {
[09:31:20.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.477]                               info, version)
[09:31:20.477]                           }
[09:31:20.477]                           base::stop(msg)
[09:31:20.477]                         }
[09:31:20.477]                       })
[09:31:20.477]                     }
[09:31:20.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.477]                     base::options(mc.cores = 1L)
[09:31:20.477]                   }
[09:31:20.477]                   ...future.strategy.old <- future::plan("list")
[09:31:20.477]                   options(future.plan = NULL)
[09:31:20.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.477]                 }
[09:31:20.477]                 ...future.workdir <- getwd()
[09:31:20.477]             }
[09:31:20.477]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.477]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.477]         }
[09:31:20.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.477]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.477]             base::names(...future.oldOptions))
[09:31:20.477]     }
[09:31:20.477]     if (FALSE) {
[09:31:20.477]     }
[09:31:20.477]     else {
[09:31:20.477]         if (TRUE) {
[09:31:20.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.477]                 open = "w")
[09:31:20.477]         }
[09:31:20.477]         else {
[09:31:20.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.477]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.477]         }
[09:31:20.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.477]             base::sink(type = "output", split = FALSE)
[09:31:20.477]             base::close(...future.stdout)
[09:31:20.477]         }, add = TRUE)
[09:31:20.477]     }
[09:31:20.477]     ...future.frame <- base::sys.nframe()
[09:31:20.477]     ...future.conditions <- base::list()
[09:31:20.477]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.477]     if (FALSE) {
[09:31:20.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.477]     }
[09:31:20.477]     ...future.result <- base::tryCatch({
[09:31:20.477]         base::withCallingHandlers({
[09:31:20.477]             ...future.value <- base::withVisible(base::local({
[09:31:20.477]                 ...future.makeSendCondition <- base::local({
[09:31:20.477]                   sendCondition <- NULL
[09:31:20.477]                   function(frame = 1L) {
[09:31:20.477]                     if (is.function(sendCondition)) 
[09:31:20.477]                       return(sendCondition)
[09:31:20.477]                     ns <- getNamespace("parallel")
[09:31:20.477]                     if (exists("sendData", mode = "function", 
[09:31:20.477]                       envir = ns)) {
[09:31:20.477]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.477]                         envir = ns)
[09:31:20.477]                       envir <- sys.frame(frame)
[09:31:20.477]                       master <- NULL
[09:31:20.477]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.477]                         !identical(envir, emptyenv())) {
[09:31:20.477]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.477]                           inherits = FALSE)) {
[09:31:20.477]                           master <- get("master", mode = "list", 
[09:31:20.477]                             envir = envir, inherits = FALSE)
[09:31:20.477]                           if (inherits(master, c("SOCKnode", 
[09:31:20.477]                             "SOCK0node"))) {
[09:31:20.477]                             sendCondition <<- function(cond) {
[09:31:20.477]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.477]                                 success = TRUE)
[09:31:20.477]                               parallel_sendData(master, data)
[09:31:20.477]                             }
[09:31:20.477]                             return(sendCondition)
[09:31:20.477]                           }
[09:31:20.477]                         }
[09:31:20.477]                         frame <- frame + 1L
[09:31:20.477]                         envir <- sys.frame(frame)
[09:31:20.477]                       }
[09:31:20.477]                     }
[09:31:20.477]                     sendCondition <<- function(cond) NULL
[09:31:20.477]                   }
[09:31:20.477]                 })
[09:31:20.477]                 withCallingHandlers({
[09:31:20.477]                   {
[09:31:20.477]                     outer_function(1L)
[09:31:20.477]                   }
[09:31:20.477]                 }, immediateCondition = function(cond) {
[09:31:20.477]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.477]                   sendCondition(cond)
[09:31:20.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.477]                   {
[09:31:20.477]                     inherits <- base::inherits
[09:31:20.477]                     invokeRestart <- base::invokeRestart
[09:31:20.477]                     is.null <- base::is.null
[09:31:20.477]                     muffled <- FALSE
[09:31:20.477]                     if (inherits(cond, "message")) {
[09:31:20.477]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.477]                       if (muffled) 
[09:31:20.477]                         invokeRestart("muffleMessage")
[09:31:20.477]                     }
[09:31:20.477]                     else if (inherits(cond, "warning")) {
[09:31:20.477]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.477]                       if (muffled) 
[09:31:20.477]                         invokeRestart("muffleWarning")
[09:31:20.477]                     }
[09:31:20.477]                     else if (inherits(cond, "condition")) {
[09:31:20.477]                       if (!is.null(pattern)) {
[09:31:20.477]                         computeRestarts <- base::computeRestarts
[09:31:20.477]                         grepl <- base::grepl
[09:31:20.477]                         restarts <- computeRestarts(cond)
[09:31:20.477]                         for (restart in restarts) {
[09:31:20.477]                           name <- restart$name
[09:31:20.477]                           if (is.null(name)) 
[09:31:20.477]                             next
[09:31:20.477]                           if (!grepl(pattern, name)) 
[09:31:20.477]                             next
[09:31:20.477]                           invokeRestart(restart)
[09:31:20.477]                           muffled <- TRUE
[09:31:20.477]                           break
[09:31:20.477]                         }
[09:31:20.477]                       }
[09:31:20.477]                     }
[09:31:20.477]                     invisible(muffled)
[09:31:20.477]                   }
[09:31:20.477]                   muffleCondition(cond)
[09:31:20.477]                 })
[09:31:20.477]             }))
[09:31:20.477]             future::FutureResult(value = ...future.value$value, 
[09:31:20.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.477]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.477]                     ...future.globalenv.names))
[09:31:20.477]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.477]         }, condition = base::local({
[09:31:20.477]             c <- base::c
[09:31:20.477]             inherits <- base::inherits
[09:31:20.477]             invokeRestart <- base::invokeRestart
[09:31:20.477]             length <- base::length
[09:31:20.477]             list <- base::list
[09:31:20.477]             seq.int <- base::seq.int
[09:31:20.477]             signalCondition <- base::signalCondition
[09:31:20.477]             sys.calls <- base::sys.calls
[09:31:20.477]             `[[` <- base::`[[`
[09:31:20.477]             `+` <- base::`+`
[09:31:20.477]             `<<-` <- base::`<<-`
[09:31:20.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.477]                   3L)]
[09:31:20.477]             }
[09:31:20.477]             function(cond) {
[09:31:20.477]                 is_error <- inherits(cond, "error")
[09:31:20.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.477]                   NULL)
[09:31:20.477]                 if (is_error) {
[09:31:20.477]                   sessionInformation <- function() {
[09:31:20.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.477]                       search = base::search(), system = base::Sys.info())
[09:31:20.477]                   }
[09:31:20.477]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.477]                     cond$call), session = sessionInformation(), 
[09:31:20.477]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.477]                   signalCondition(cond)
[09:31:20.477]                 }
[09:31:20.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.477]                 "immediateCondition"))) {
[09:31:20.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.477]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.477]                   if (TRUE && !signal) {
[09:31:20.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.477]                     {
[09:31:20.477]                       inherits <- base::inherits
[09:31:20.477]                       invokeRestart <- base::invokeRestart
[09:31:20.477]                       is.null <- base::is.null
[09:31:20.477]                       muffled <- FALSE
[09:31:20.477]                       if (inherits(cond, "message")) {
[09:31:20.477]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.477]                         if (muffled) 
[09:31:20.477]                           invokeRestart("muffleMessage")
[09:31:20.477]                       }
[09:31:20.477]                       else if (inherits(cond, "warning")) {
[09:31:20.477]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.477]                         if (muffled) 
[09:31:20.477]                           invokeRestart("muffleWarning")
[09:31:20.477]                       }
[09:31:20.477]                       else if (inherits(cond, "condition")) {
[09:31:20.477]                         if (!is.null(pattern)) {
[09:31:20.477]                           computeRestarts <- base::computeRestarts
[09:31:20.477]                           grepl <- base::grepl
[09:31:20.477]                           restarts <- computeRestarts(cond)
[09:31:20.477]                           for (restart in restarts) {
[09:31:20.477]                             name <- restart$name
[09:31:20.477]                             if (is.null(name)) 
[09:31:20.477]                               next
[09:31:20.477]                             if (!grepl(pattern, name)) 
[09:31:20.477]                               next
[09:31:20.477]                             invokeRestart(restart)
[09:31:20.477]                             muffled <- TRUE
[09:31:20.477]                             break
[09:31:20.477]                           }
[09:31:20.477]                         }
[09:31:20.477]                       }
[09:31:20.477]                       invisible(muffled)
[09:31:20.477]                     }
[09:31:20.477]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.477]                   }
[09:31:20.477]                 }
[09:31:20.477]                 else {
[09:31:20.477]                   if (TRUE) {
[09:31:20.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.477]                     {
[09:31:20.477]                       inherits <- base::inherits
[09:31:20.477]                       invokeRestart <- base::invokeRestart
[09:31:20.477]                       is.null <- base::is.null
[09:31:20.477]                       muffled <- FALSE
[09:31:20.477]                       if (inherits(cond, "message")) {
[09:31:20.477]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.477]                         if (muffled) 
[09:31:20.477]                           invokeRestart("muffleMessage")
[09:31:20.477]                       }
[09:31:20.477]                       else if (inherits(cond, "warning")) {
[09:31:20.477]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.477]                         if (muffled) 
[09:31:20.477]                           invokeRestart("muffleWarning")
[09:31:20.477]                       }
[09:31:20.477]                       else if (inherits(cond, "condition")) {
[09:31:20.477]                         if (!is.null(pattern)) {
[09:31:20.477]                           computeRestarts <- base::computeRestarts
[09:31:20.477]                           grepl <- base::grepl
[09:31:20.477]                           restarts <- computeRestarts(cond)
[09:31:20.477]                           for (restart in restarts) {
[09:31:20.477]                             name <- restart$name
[09:31:20.477]                             if (is.null(name)) 
[09:31:20.477]                               next
[09:31:20.477]                             if (!grepl(pattern, name)) 
[09:31:20.477]                               next
[09:31:20.477]                             invokeRestart(restart)
[09:31:20.477]                             muffled <- TRUE
[09:31:20.477]                             break
[09:31:20.477]                           }
[09:31:20.477]                         }
[09:31:20.477]                       }
[09:31:20.477]                       invisible(muffled)
[09:31:20.477]                     }
[09:31:20.477]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.477]                   }
[09:31:20.477]                 }
[09:31:20.477]             }
[09:31:20.477]         }))
[09:31:20.477]     }, error = function(ex) {
[09:31:20.477]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.477]                 ...future.rng), started = ...future.startTime, 
[09:31:20.477]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.477]             version = "1.8"), class = "FutureResult")
[09:31:20.477]     }, finally = {
[09:31:20.477]         if (!identical(...future.workdir, getwd())) 
[09:31:20.477]             setwd(...future.workdir)
[09:31:20.477]         {
[09:31:20.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.477]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.477]             }
[09:31:20.477]             base::options(...future.oldOptions)
[09:31:20.477]             if (.Platform$OS.type == "windows") {
[09:31:20.477]                 old_names <- names(...future.oldEnvVars)
[09:31:20.477]                 envs <- base::Sys.getenv()
[09:31:20.477]                 names <- names(envs)
[09:31:20.477]                 common <- intersect(names, old_names)
[09:31:20.477]                 added <- setdiff(names, old_names)
[09:31:20.477]                 removed <- setdiff(old_names, names)
[09:31:20.477]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.477]                   envs[common]]
[09:31:20.477]                 NAMES <- toupper(changed)
[09:31:20.477]                 args <- list()
[09:31:20.477]                 for (kk in seq_along(NAMES)) {
[09:31:20.477]                   name <- changed[[kk]]
[09:31:20.477]                   NAME <- NAMES[[kk]]
[09:31:20.477]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.477]                     next
[09:31:20.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.477]                 }
[09:31:20.477]                 NAMES <- toupper(added)
[09:31:20.477]                 for (kk in seq_along(NAMES)) {
[09:31:20.477]                   name <- added[[kk]]
[09:31:20.477]                   NAME <- NAMES[[kk]]
[09:31:20.477]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.477]                     next
[09:31:20.477]                   args[[name]] <- ""
[09:31:20.477]                 }
[09:31:20.477]                 NAMES <- toupper(removed)
[09:31:20.477]                 for (kk in seq_along(NAMES)) {
[09:31:20.477]                   name <- removed[[kk]]
[09:31:20.477]                   NAME <- NAMES[[kk]]
[09:31:20.477]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.477]                     next
[09:31:20.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.477]                 }
[09:31:20.477]                 if (length(args) > 0) 
[09:31:20.477]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.477]             }
[09:31:20.477]             else {
[09:31:20.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.477]             }
[09:31:20.477]             {
[09:31:20.477]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.477]                   0L) {
[09:31:20.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.477]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.477]                   base::options(opts)
[09:31:20.477]                 }
[09:31:20.477]                 {
[09:31:20.477]                   {
[09:31:20.477]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.477]                     NULL
[09:31:20.477]                   }
[09:31:20.477]                   options(future.plan = NULL)
[09:31:20.477]                   if (is.na(NA_character_)) 
[09:31:20.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.477]                     .init = FALSE)
[09:31:20.477]                 }
[09:31:20.477]             }
[09:31:20.477]         }
[09:31:20.477]     })
[09:31:20.477]     if (TRUE) {
[09:31:20.477]         base::sink(type = "output", split = FALSE)
[09:31:20.477]         if (TRUE) {
[09:31:20.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.477]         }
[09:31:20.477]         else {
[09:31:20.477]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.477]         }
[09:31:20.477]         base::close(...future.stdout)
[09:31:20.477]         ...future.stdout <- NULL
[09:31:20.477]     }
[09:31:20.477]     ...future.result$conditions <- ...future.conditions
[09:31:20.477]     ...future.result$finished <- base::Sys.time()
[09:31:20.477]     ...future.result
[09:31:20.477] }
[09:31:20.482] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[09:31:20.482] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[09:31:20.482] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[09:31:20.482] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[09:31:20.483] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[09:31:20.483] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[09:31:20.483] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[09:31:20.483] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[09:31:20.484] MultisessionFuture started
[09:31:20.484] - Launch lazy future ... done
[09:31:20.484] run() for ‘MultisessionFuture’ ... done
[09:31:20.484] result() for ClusterFuture ...
[09:31:20.484] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.484] - Validating connection of MultisessionFuture
[09:31:20.489] - received message: FutureResult
[09:31:20.489] - Received FutureResult
[09:31:20.489] - Erased future from FutureRegistry
[09:31:20.490] result() for ClusterFuture ...
[09:31:20.490] - result already collected: FutureResult
[09:31:20.490] result() for ClusterFuture ... done
[09:31:20.490] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.490] result() for ClusterFuture ... done
[09:31:20.490] result() for ClusterFuture ...
[09:31:20.490] - result already collected: FutureResult
[09:31:20.490] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[09:31:20.491] getGlobalsAndPackages() ...
[09:31:20.492] Searching for globals...
[09:31:20.495] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[09:31:20.496] Searching for globals ... DONE
[09:31:20.496] Resolving globals: FALSE
[09:31:20.496] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[09:31:20.497] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[09:31:20.497] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[09:31:20.497] 
[09:31:20.497] getGlobalsAndPackages() ... DONE
[09:31:20.497] run() for ‘Future’ ...
[09:31:20.497] - state: ‘created’
[09:31:20.498] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:20.512] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:20.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:20.512]   - Field: ‘node’
[09:31:20.512]   - Field: ‘label’
[09:31:20.512]   - Field: ‘local’
[09:31:20.512]   - Field: ‘owner’
[09:31:20.512]   - Field: ‘envir’
[09:31:20.512]   - Field: ‘workers’
[09:31:20.512]   - Field: ‘packages’
[09:31:20.513]   - Field: ‘gc’
[09:31:20.513]   - Field: ‘conditions’
[09:31:20.513]   - Field: ‘persistent’
[09:31:20.513]   - Field: ‘expr’
[09:31:20.513]   - Field: ‘uuid’
[09:31:20.513]   - Field: ‘seed’
[09:31:20.513]   - Field: ‘version’
[09:31:20.513]   - Field: ‘result’
[09:31:20.513]   - Field: ‘asynchronous’
[09:31:20.513]   - Field: ‘calls’
[09:31:20.513]   - Field: ‘globals’
[09:31:20.513]   - Field: ‘stdout’
[09:31:20.514]   - Field: ‘earlySignal’
[09:31:20.514]   - Field: ‘lazy’
[09:31:20.514]   - Field: ‘state’
[09:31:20.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:20.514] - Launch lazy future ...
[09:31:20.514] Packages needed by the future expression (n = 0): <none>
[09:31:20.514] Packages needed by future strategies (n = 0): <none>
[09:31:20.515] {
[09:31:20.515]     {
[09:31:20.515]         {
[09:31:20.515]             ...future.startTime <- base::Sys.time()
[09:31:20.515]             {
[09:31:20.515]                 {
[09:31:20.515]                   {
[09:31:20.515]                     {
[09:31:20.515]                       base::local({
[09:31:20.515]                         has_future <- base::requireNamespace("future", 
[09:31:20.515]                           quietly = TRUE)
[09:31:20.515]                         if (has_future) {
[09:31:20.515]                           ns <- base::getNamespace("future")
[09:31:20.515]                           version <- ns[[".package"]][["version"]]
[09:31:20.515]                           if (is.null(version)) 
[09:31:20.515]                             version <- utils::packageVersion("future")
[09:31:20.515]                         }
[09:31:20.515]                         else {
[09:31:20.515]                           version <- NULL
[09:31:20.515]                         }
[09:31:20.515]                         if (!has_future || version < "1.8.0") {
[09:31:20.515]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:20.515]                             "", base::R.version$version.string), 
[09:31:20.515]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:20.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:20.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:20.515]                               "release", "version")], collapse = " "), 
[09:31:20.515]                             hostname = base::Sys.info()[["nodename"]])
[09:31:20.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:20.515]                             info)
[09:31:20.515]                           info <- base::paste(info, collapse = "; ")
[09:31:20.515]                           if (!has_future) {
[09:31:20.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:20.515]                               info)
[09:31:20.515]                           }
[09:31:20.515]                           else {
[09:31:20.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:20.515]                               info, version)
[09:31:20.515]                           }
[09:31:20.515]                           base::stop(msg)
[09:31:20.515]                         }
[09:31:20.515]                       })
[09:31:20.515]                     }
[09:31:20.515]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:20.515]                     base::options(mc.cores = 1L)
[09:31:20.515]                   }
[09:31:20.515]                   ...future.strategy.old <- future::plan("list")
[09:31:20.515]                   options(future.plan = NULL)
[09:31:20.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:20.515]                 }
[09:31:20.515]                 ...future.workdir <- getwd()
[09:31:20.515]             }
[09:31:20.515]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:20.515]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:20.515]         }
[09:31:20.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:20.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:20.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:20.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:20.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:20.515]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:20.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:20.515]             base::names(...future.oldOptions))
[09:31:20.515]     }
[09:31:20.515]     if (FALSE) {
[09:31:20.515]     }
[09:31:20.515]     else {
[09:31:20.515]         if (TRUE) {
[09:31:20.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:20.515]                 open = "w")
[09:31:20.515]         }
[09:31:20.515]         else {
[09:31:20.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:20.515]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:20.515]         }
[09:31:20.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:20.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:20.515]             base::sink(type = "output", split = FALSE)
[09:31:20.515]             base::close(...future.stdout)
[09:31:20.515]         }, add = TRUE)
[09:31:20.515]     }
[09:31:20.515]     ...future.frame <- base::sys.nframe()
[09:31:20.515]     ...future.conditions <- base::list()
[09:31:20.515]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:20.515]     if (FALSE) {
[09:31:20.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:20.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:20.515]     }
[09:31:20.515]     ...future.result <- base::tryCatch({
[09:31:20.515]         base::withCallingHandlers({
[09:31:20.515]             ...future.value <- base::withVisible(base::local({
[09:31:20.515]                 ...future.makeSendCondition <- base::local({
[09:31:20.515]                   sendCondition <- NULL
[09:31:20.515]                   function(frame = 1L) {
[09:31:20.515]                     if (is.function(sendCondition)) 
[09:31:20.515]                       return(sendCondition)
[09:31:20.515]                     ns <- getNamespace("parallel")
[09:31:20.515]                     if (exists("sendData", mode = "function", 
[09:31:20.515]                       envir = ns)) {
[09:31:20.515]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:20.515]                         envir = ns)
[09:31:20.515]                       envir <- sys.frame(frame)
[09:31:20.515]                       master <- NULL
[09:31:20.515]                       while (!identical(envir, .GlobalEnv) && 
[09:31:20.515]                         !identical(envir, emptyenv())) {
[09:31:20.515]                         if (exists("master", mode = "list", envir = envir, 
[09:31:20.515]                           inherits = FALSE)) {
[09:31:20.515]                           master <- get("master", mode = "list", 
[09:31:20.515]                             envir = envir, inherits = FALSE)
[09:31:20.515]                           if (inherits(master, c("SOCKnode", 
[09:31:20.515]                             "SOCK0node"))) {
[09:31:20.515]                             sendCondition <<- function(cond) {
[09:31:20.515]                               data <- list(type = "VALUE", value = cond, 
[09:31:20.515]                                 success = TRUE)
[09:31:20.515]                               parallel_sendData(master, data)
[09:31:20.515]                             }
[09:31:20.515]                             return(sendCondition)
[09:31:20.515]                           }
[09:31:20.515]                         }
[09:31:20.515]                         frame <- frame + 1L
[09:31:20.515]                         envir <- sys.frame(frame)
[09:31:20.515]                       }
[09:31:20.515]                     }
[09:31:20.515]                     sendCondition <<- function(cond) NULL
[09:31:20.515]                   }
[09:31:20.515]                 })
[09:31:20.515]                 withCallingHandlers({
[09:31:20.515]                   {
[09:31:20.515]                     outer_function(1L)
[09:31:20.515]                   }
[09:31:20.515]                 }, immediateCondition = function(cond) {
[09:31:20.515]                   sendCondition <- ...future.makeSendCondition()
[09:31:20.515]                   sendCondition(cond)
[09:31:20.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.515]                   {
[09:31:20.515]                     inherits <- base::inherits
[09:31:20.515]                     invokeRestart <- base::invokeRestart
[09:31:20.515]                     is.null <- base::is.null
[09:31:20.515]                     muffled <- FALSE
[09:31:20.515]                     if (inherits(cond, "message")) {
[09:31:20.515]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:20.515]                       if (muffled) 
[09:31:20.515]                         invokeRestart("muffleMessage")
[09:31:20.515]                     }
[09:31:20.515]                     else if (inherits(cond, "warning")) {
[09:31:20.515]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:20.515]                       if (muffled) 
[09:31:20.515]                         invokeRestart("muffleWarning")
[09:31:20.515]                     }
[09:31:20.515]                     else if (inherits(cond, "condition")) {
[09:31:20.515]                       if (!is.null(pattern)) {
[09:31:20.515]                         computeRestarts <- base::computeRestarts
[09:31:20.515]                         grepl <- base::grepl
[09:31:20.515]                         restarts <- computeRestarts(cond)
[09:31:20.515]                         for (restart in restarts) {
[09:31:20.515]                           name <- restart$name
[09:31:20.515]                           if (is.null(name)) 
[09:31:20.515]                             next
[09:31:20.515]                           if (!grepl(pattern, name)) 
[09:31:20.515]                             next
[09:31:20.515]                           invokeRestart(restart)
[09:31:20.515]                           muffled <- TRUE
[09:31:20.515]                           break
[09:31:20.515]                         }
[09:31:20.515]                       }
[09:31:20.515]                     }
[09:31:20.515]                     invisible(muffled)
[09:31:20.515]                   }
[09:31:20.515]                   muffleCondition(cond)
[09:31:20.515]                 })
[09:31:20.515]             }))
[09:31:20.515]             future::FutureResult(value = ...future.value$value, 
[09:31:20.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.515]                   ...future.rng), globalenv = if (FALSE) 
[09:31:20.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:20.515]                     ...future.globalenv.names))
[09:31:20.515]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:20.515]         }, condition = base::local({
[09:31:20.515]             c <- base::c
[09:31:20.515]             inherits <- base::inherits
[09:31:20.515]             invokeRestart <- base::invokeRestart
[09:31:20.515]             length <- base::length
[09:31:20.515]             list <- base::list
[09:31:20.515]             seq.int <- base::seq.int
[09:31:20.515]             signalCondition <- base::signalCondition
[09:31:20.515]             sys.calls <- base::sys.calls
[09:31:20.515]             `[[` <- base::`[[`
[09:31:20.515]             `+` <- base::`+`
[09:31:20.515]             `<<-` <- base::`<<-`
[09:31:20.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:20.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:20.515]                   3L)]
[09:31:20.515]             }
[09:31:20.515]             function(cond) {
[09:31:20.515]                 is_error <- inherits(cond, "error")
[09:31:20.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:20.515]                   NULL)
[09:31:20.515]                 if (is_error) {
[09:31:20.515]                   sessionInformation <- function() {
[09:31:20.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:20.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:20.515]                       search = base::search(), system = base::Sys.info())
[09:31:20.515]                   }
[09:31:20.515]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:20.515]                     cond$call), session = sessionInformation(), 
[09:31:20.515]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:20.515]                   signalCondition(cond)
[09:31:20.515]                 }
[09:31:20.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:20.515]                 "immediateCondition"))) {
[09:31:20.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:20.515]                   ...future.conditions[[length(...future.conditions) + 
[09:31:20.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:20.515]                   if (TRUE && !signal) {
[09:31:20.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.515]                     {
[09:31:20.515]                       inherits <- base::inherits
[09:31:20.515]                       invokeRestart <- base::invokeRestart
[09:31:20.515]                       is.null <- base::is.null
[09:31:20.515]                       muffled <- FALSE
[09:31:20.515]                       if (inherits(cond, "message")) {
[09:31:20.515]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.515]                         if (muffled) 
[09:31:20.515]                           invokeRestart("muffleMessage")
[09:31:20.515]                       }
[09:31:20.515]                       else if (inherits(cond, "warning")) {
[09:31:20.515]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.515]                         if (muffled) 
[09:31:20.515]                           invokeRestart("muffleWarning")
[09:31:20.515]                       }
[09:31:20.515]                       else if (inherits(cond, "condition")) {
[09:31:20.515]                         if (!is.null(pattern)) {
[09:31:20.515]                           computeRestarts <- base::computeRestarts
[09:31:20.515]                           grepl <- base::grepl
[09:31:20.515]                           restarts <- computeRestarts(cond)
[09:31:20.515]                           for (restart in restarts) {
[09:31:20.515]                             name <- restart$name
[09:31:20.515]                             if (is.null(name)) 
[09:31:20.515]                               next
[09:31:20.515]                             if (!grepl(pattern, name)) 
[09:31:20.515]                               next
[09:31:20.515]                             invokeRestart(restart)
[09:31:20.515]                             muffled <- TRUE
[09:31:20.515]                             break
[09:31:20.515]                           }
[09:31:20.515]                         }
[09:31:20.515]                       }
[09:31:20.515]                       invisible(muffled)
[09:31:20.515]                     }
[09:31:20.515]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.515]                   }
[09:31:20.515]                 }
[09:31:20.515]                 else {
[09:31:20.515]                   if (TRUE) {
[09:31:20.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:20.515]                     {
[09:31:20.515]                       inherits <- base::inherits
[09:31:20.515]                       invokeRestart <- base::invokeRestart
[09:31:20.515]                       is.null <- base::is.null
[09:31:20.515]                       muffled <- FALSE
[09:31:20.515]                       if (inherits(cond, "message")) {
[09:31:20.515]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:20.515]                         if (muffled) 
[09:31:20.515]                           invokeRestart("muffleMessage")
[09:31:20.515]                       }
[09:31:20.515]                       else if (inherits(cond, "warning")) {
[09:31:20.515]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:20.515]                         if (muffled) 
[09:31:20.515]                           invokeRestart("muffleWarning")
[09:31:20.515]                       }
[09:31:20.515]                       else if (inherits(cond, "condition")) {
[09:31:20.515]                         if (!is.null(pattern)) {
[09:31:20.515]                           computeRestarts <- base::computeRestarts
[09:31:20.515]                           grepl <- base::grepl
[09:31:20.515]                           restarts <- computeRestarts(cond)
[09:31:20.515]                           for (restart in restarts) {
[09:31:20.515]                             name <- restart$name
[09:31:20.515]                             if (is.null(name)) 
[09:31:20.515]                               next
[09:31:20.515]                             if (!grepl(pattern, name)) 
[09:31:20.515]                               next
[09:31:20.515]                             invokeRestart(restart)
[09:31:20.515]                             muffled <- TRUE
[09:31:20.515]                             break
[09:31:20.515]                           }
[09:31:20.515]                         }
[09:31:20.515]                       }
[09:31:20.515]                       invisible(muffled)
[09:31:20.515]                     }
[09:31:20.515]                     muffleCondition(cond, pattern = "^muffle")
[09:31:20.515]                   }
[09:31:20.515]                 }
[09:31:20.515]             }
[09:31:20.515]         }))
[09:31:20.515]     }, error = function(ex) {
[09:31:20.515]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:20.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:20.515]                 ...future.rng), started = ...future.startTime, 
[09:31:20.515]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:20.515]             version = "1.8"), class = "FutureResult")
[09:31:20.515]     }, finally = {
[09:31:20.515]         if (!identical(...future.workdir, getwd())) 
[09:31:20.515]             setwd(...future.workdir)
[09:31:20.515]         {
[09:31:20.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:20.515]                 ...future.oldOptions$nwarnings <- NULL
[09:31:20.515]             }
[09:31:20.515]             base::options(...future.oldOptions)
[09:31:20.515]             if (.Platform$OS.type == "windows") {
[09:31:20.515]                 old_names <- names(...future.oldEnvVars)
[09:31:20.515]                 envs <- base::Sys.getenv()
[09:31:20.515]                 names <- names(envs)
[09:31:20.515]                 common <- intersect(names, old_names)
[09:31:20.515]                 added <- setdiff(names, old_names)
[09:31:20.515]                 removed <- setdiff(old_names, names)
[09:31:20.515]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:20.515]                   envs[common]]
[09:31:20.515]                 NAMES <- toupper(changed)
[09:31:20.515]                 args <- list()
[09:31:20.515]                 for (kk in seq_along(NAMES)) {
[09:31:20.515]                   name <- changed[[kk]]
[09:31:20.515]                   NAME <- NAMES[[kk]]
[09:31:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.515]                     next
[09:31:20.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.515]                 }
[09:31:20.515]                 NAMES <- toupper(added)
[09:31:20.515]                 for (kk in seq_along(NAMES)) {
[09:31:20.515]                   name <- added[[kk]]
[09:31:20.515]                   NAME <- NAMES[[kk]]
[09:31:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.515]                     next
[09:31:20.515]                   args[[name]] <- ""
[09:31:20.515]                 }
[09:31:20.515]                 NAMES <- toupper(removed)
[09:31:20.515]                 for (kk in seq_along(NAMES)) {
[09:31:20.515]                   name <- removed[[kk]]
[09:31:20.515]                   NAME <- NAMES[[kk]]
[09:31:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:20.515]                     next
[09:31:20.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:20.515]                 }
[09:31:20.515]                 if (length(args) > 0) 
[09:31:20.515]                   base::do.call(base::Sys.setenv, args = args)
[09:31:20.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:20.515]             }
[09:31:20.515]             else {
[09:31:20.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:20.515]             }
[09:31:20.515]             {
[09:31:20.515]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:20.515]                   0L) {
[09:31:20.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:20.515]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:20.515]                   base::options(opts)
[09:31:20.515]                 }
[09:31:20.515]                 {
[09:31:20.515]                   {
[09:31:20.515]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:20.515]                     NULL
[09:31:20.515]                   }
[09:31:20.515]                   options(future.plan = NULL)
[09:31:20.515]                   if (is.na(NA_character_)) 
[09:31:20.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:20.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:20.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:20.515]                     .init = FALSE)
[09:31:20.515]                 }
[09:31:20.515]             }
[09:31:20.515]         }
[09:31:20.515]     })
[09:31:20.515]     if (TRUE) {
[09:31:20.515]         base::sink(type = "output", split = FALSE)
[09:31:20.515]         if (TRUE) {
[09:31:20.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:20.515]         }
[09:31:20.515]         else {
[09:31:20.515]             ...future.result["stdout"] <- base::list(NULL)
[09:31:20.515]         }
[09:31:20.515]         base::close(...future.stdout)
[09:31:20.515]         ...future.stdout <- NULL
[09:31:20.515]     }
[09:31:20.515]     ...future.result$conditions <- ...future.conditions
[09:31:20.515]     ...future.result$finished <- base::Sys.time()
[09:31:20.515]     ...future.result
[09:31:20.515] }
[09:31:20.517] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[09:31:20.517] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[09:31:20.517] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[09:31:20.518] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[09:31:20.518] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[09:31:20.518] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[09:31:20.518] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[09:31:20.518] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[09:31:20.519] MultisessionFuture started
[09:31:20.519] - Launch lazy future ... done
[09:31:20.519] run() for ‘MultisessionFuture’ ... done
[09:31:20.519] result() for ClusterFuture ...
[09:31:20.519] receiveMessageFromWorker() for ClusterFuture ...
[09:31:20.519] - Validating connection of MultisessionFuture
[09:31:20.520] - received message: FutureResult
[09:31:20.520] - Received FutureResult
[09:31:20.520] - Erased future from FutureRegistry
[09:31:20.521] result() for ClusterFuture ...
[09:31:20.521] - result already collected: FutureResult
[09:31:20.521] result() for ClusterFuture ... done
[09:31:20.521] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:20.521] result() for ClusterFuture ... done
[09:31:20.521] result() for ClusterFuture ...
[09:31:20.521] - result already collected: FutureResult
[09:31:20.521] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[09:31:20.523] plan(): Setting new future strategy stack:
[09:31:20.523] List of future strategies:
[09:31:20.523] 1. FutureStrategy:
[09:31:20.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:20.523]    - tweaked: FALSE
[09:31:20.523]    - call: future::plan(oplan)
[09:31:20.524] plan(): nbrOfWorkers() = 1
> 
