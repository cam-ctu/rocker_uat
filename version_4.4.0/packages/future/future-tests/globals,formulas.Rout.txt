
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:39:40.351] plan(): Setting new future strategy stack:
[17:39:40.351] List of future strategies:
[17:39:40.351] 1. sequential:
[17:39:40.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.351]    - tweaked: FALSE
[17:39:40.351]    - call: future::plan("sequential")
[17:39:40.362] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:39:40.422] plan(): Setting new future strategy stack:
[17:39:40.422] List of future strategies:
[17:39:40.422] 1. sequential:
[17:39:40.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.422]    - tweaked: FALSE
[17:39:40.422]    - call: plan(strategy)
[17:39:40.434] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[17:39:40.435] getGlobalsAndPackages() ...
[17:39:40.435] Searching for globals...
[17:39:40.441] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.442] Searching for globals ... DONE
[17:39:40.442] Resolving globals: FALSE
[17:39:40.443] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.443] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.443] - globals: [2] ‘weight’, ‘group’
[17:39:40.444] - packages: [1] ‘stats’
[17:39:40.444] getGlobalsAndPackages() ... DONE
[17:39:40.444] run() for ‘Future’ ...
[17:39:40.444] - state: ‘created’
[17:39:40.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.445] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.445]   - Field: ‘label’
[17:39:40.445]   - Field: ‘local’
[17:39:40.445]   - Field: ‘owner’
[17:39:40.445]   - Field: ‘envir’
[17:39:40.446]   - Field: ‘packages’
[17:39:40.446]   - Field: ‘gc’
[17:39:40.446]   - Field: ‘conditions’
[17:39:40.446]   - Field: ‘expr’
[17:39:40.446]   - Field: ‘uuid’
[17:39:40.446]   - Field: ‘seed’
[17:39:40.446]   - Field: ‘version’
[17:39:40.446]   - Field: ‘result’
[17:39:40.446]   - Field: ‘asynchronous’
[17:39:40.446]   - Field: ‘calls’
[17:39:40.446]   - Field: ‘globals’
[17:39:40.446]   - Field: ‘stdout’
[17:39:40.447]   - Field: ‘earlySignal’
[17:39:40.447]   - Field: ‘lazy’
[17:39:40.447]   - Field: ‘state’
[17:39:40.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.447] - Launch lazy future ...
[17:39:40.448] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.448] Packages needed by future strategies (n = 0): <none>
[17:39:40.449] {
[17:39:40.449]     {
[17:39:40.449]         {
[17:39:40.449]             ...future.startTime <- base::Sys.time()
[17:39:40.449]             {
[17:39:40.449]                 {
[17:39:40.449]                   {
[17:39:40.449]                     {
[17:39:40.449]                       base::local({
[17:39:40.449]                         has_future <- base::requireNamespace("future", 
[17:39:40.449]                           quietly = TRUE)
[17:39:40.449]                         if (has_future) {
[17:39:40.449]                           ns <- base::getNamespace("future")
[17:39:40.449]                           version <- ns[[".package"]][["version"]]
[17:39:40.449]                           if (is.null(version)) 
[17:39:40.449]                             version <- utils::packageVersion("future")
[17:39:40.449]                         }
[17:39:40.449]                         else {
[17:39:40.449]                           version <- NULL
[17:39:40.449]                         }
[17:39:40.449]                         if (!has_future || version < "1.8.0") {
[17:39:40.449]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.449]                             "", base::R.version$version.string), 
[17:39:40.449]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.449]                               "release", "version")], collapse = " "), 
[17:39:40.449]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.449]                             info)
[17:39:40.449]                           info <- base::paste(info, collapse = "; ")
[17:39:40.449]                           if (!has_future) {
[17:39:40.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.449]                               info)
[17:39:40.449]                           }
[17:39:40.449]                           else {
[17:39:40.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.449]                               info, version)
[17:39:40.449]                           }
[17:39:40.449]                           base::stop(msg)
[17:39:40.449]                         }
[17:39:40.449]                       })
[17:39:40.449]                     }
[17:39:40.449]                     base::local({
[17:39:40.449]                       for (pkg in "stats") {
[17:39:40.449]                         base::loadNamespace(pkg)
[17:39:40.449]                         base::library(pkg, character.only = TRUE)
[17:39:40.449]                       }
[17:39:40.449]                     })
[17:39:40.449]                   }
[17:39:40.449]                   ...future.strategy.old <- future::plan("list")
[17:39:40.449]                   options(future.plan = NULL)
[17:39:40.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.449]                 }
[17:39:40.449]                 ...future.workdir <- getwd()
[17:39:40.449]             }
[17:39:40.449]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.449]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.449]         }
[17:39:40.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.449]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.449]             base::names(...future.oldOptions))
[17:39:40.449]     }
[17:39:40.449]     if (FALSE) {
[17:39:40.449]     }
[17:39:40.449]     else {
[17:39:40.449]         if (TRUE) {
[17:39:40.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.449]                 open = "w")
[17:39:40.449]         }
[17:39:40.449]         else {
[17:39:40.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.449]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.449]         }
[17:39:40.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.449]             base::sink(type = "output", split = FALSE)
[17:39:40.449]             base::close(...future.stdout)
[17:39:40.449]         }, add = TRUE)
[17:39:40.449]     }
[17:39:40.449]     ...future.frame <- base::sys.nframe()
[17:39:40.449]     ...future.conditions <- base::list()
[17:39:40.449]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.449]     if (FALSE) {
[17:39:40.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.449]     }
[17:39:40.449]     ...future.result <- base::tryCatch({
[17:39:40.449]         base::withCallingHandlers({
[17:39:40.449]             ...future.value <- base::withVisible(base::local({
[17:39:40.449]                 lm(weight ~ group - 1)
[17:39:40.449]             }))
[17:39:40.449]             future::FutureResult(value = ...future.value$value, 
[17:39:40.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.449]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.449]                     ...future.globalenv.names))
[17:39:40.449]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.449]         }, condition = base::local({
[17:39:40.449]             c <- base::c
[17:39:40.449]             inherits <- base::inherits
[17:39:40.449]             invokeRestart <- base::invokeRestart
[17:39:40.449]             length <- base::length
[17:39:40.449]             list <- base::list
[17:39:40.449]             seq.int <- base::seq.int
[17:39:40.449]             signalCondition <- base::signalCondition
[17:39:40.449]             sys.calls <- base::sys.calls
[17:39:40.449]             `[[` <- base::`[[`
[17:39:40.449]             `+` <- base::`+`
[17:39:40.449]             `<<-` <- base::`<<-`
[17:39:40.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.449]                   3L)]
[17:39:40.449]             }
[17:39:40.449]             function(cond) {
[17:39:40.449]                 is_error <- inherits(cond, "error")
[17:39:40.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.449]                   NULL)
[17:39:40.449]                 if (is_error) {
[17:39:40.449]                   sessionInformation <- function() {
[17:39:40.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.449]                       search = base::search(), system = base::Sys.info())
[17:39:40.449]                   }
[17:39:40.449]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.449]                     cond$call), session = sessionInformation(), 
[17:39:40.449]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.449]                   signalCondition(cond)
[17:39:40.449]                 }
[17:39:40.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.449]                 "immediateCondition"))) {
[17:39:40.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.449]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.449]                   if (TRUE && !signal) {
[17:39:40.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.449]                     {
[17:39:40.449]                       inherits <- base::inherits
[17:39:40.449]                       invokeRestart <- base::invokeRestart
[17:39:40.449]                       is.null <- base::is.null
[17:39:40.449]                       muffled <- FALSE
[17:39:40.449]                       if (inherits(cond, "message")) {
[17:39:40.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.449]                         if (muffled) 
[17:39:40.449]                           invokeRestart("muffleMessage")
[17:39:40.449]                       }
[17:39:40.449]                       else if (inherits(cond, "warning")) {
[17:39:40.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.449]                         if (muffled) 
[17:39:40.449]                           invokeRestart("muffleWarning")
[17:39:40.449]                       }
[17:39:40.449]                       else if (inherits(cond, "condition")) {
[17:39:40.449]                         if (!is.null(pattern)) {
[17:39:40.449]                           computeRestarts <- base::computeRestarts
[17:39:40.449]                           grepl <- base::grepl
[17:39:40.449]                           restarts <- computeRestarts(cond)
[17:39:40.449]                           for (restart in restarts) {
[17:39:40.449]                             name <- restart$name
[17:39:40.449]                             if (is.null(name)) 
[17:39:40.449]                               next
[17:39:40.449]                             if (!grepl(pattern, name)) 
[17:39:40.449]                               next
[17:39:40.449]                             invokeRestart(restart)
[17:39:40.449]                             muffled <- TRUE
[17:39:40.449]                             break
[17:39:40.449]                           }
[17:39:40.449]                         }
[17:39:40.449]                       }
[17:39:40.449]                       invisible(muffled)
[17:39:40.449]                     }
[17:39:40.449]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.449]                   }
[17:39:40.449]                 }
[17:39:40.449]                 else {
[17:39:40.449]                   if (TRUE) {
[17:39:40.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.449]                     {
[17:39:40.449]                       inherits <- base::inherits
[17:39:40.449]                       invokeRestart <- base::invokeRestart
[17:39:40.449]                       is.null <- base::is.null
[17:39:40.449]                       muffled <- FALSE
[17:39:40.449]                       if (inherits(cond, "message")) {
[17:39:40.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.449]                         if (muffled) 
[17:39:40.449]                           invokeRestart("muffleMessage")
[17:39:40.449]                       }
[17:39:40.449]                       else if (inherits(cond, "warning")) {
[17:39:40.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.449]                         if (muffled) 
[17:39:40.449]                           invokeRestart("muffleWarning")
[17:39:40.449]                       }
[17:39:40.449]                       else if (inherits(cond, "condition")) {
[17:39:40.449]                         if (!is.null(pattern)) {
[17:39:40.449]                           computeRestarts <- base::computeRestarts
[17:39:40.449]                           grepl <- base::grepl
[17:39:40.449]                           restarts <- computeRestarts(cond)
[17:39:40.449]                           for (restart in restarts) {
[17:39:40.449]                             name <- restart$name
[17:39:40.449]                             if (is.null(name)) 
[17:39:40.449]                               next
[17:39:40.449]                             if (!grepl(pattern, name)) 
[17:39:40.449]                               next
[17:39:40.449]                             invokeRestart(restart)
[17:39:40.449]                             muffled <- TRUE
[17:39:40.449]                             break
[17:39:40.449]                           }
[17:39:40.449]                         }
[17:39:40.449]                       }
[17:39:40.449]                       invisible(muffled)
[17:39:40.449]                     }
[17:39:40.449]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.449]                   }
[17:39:40.449]                 }
[17:39:40.449]             }
[17:39:40.449]         }))
[17:39:40.449]     }, error = function(ex) {
[17:39:40.449]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.449]                 ...future.rng), started = ...future.startTime, 
[17:39:40.449]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.449]             version = "1.8"), class = "FutureResult")
[17:39:40.449]     }, finally = {
[17:39:40.449]         if (!identical(...future.workdir, getwd())) 
[17:39:40.449]             setwd(...future.workdir)
[17:39:40.449]         {
[17:39:40.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.449]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.449]             }
[17:39:40.449]             base::options(...future.oldOptions)
[17:39:40.449]             if (.Platform$OS.type == "windows") {
[17:39:40.449]                 old_names <- names(...future.oldEnvVars)
[17:39:40.449]                 envs <- base::Sys.getenv()
[17:39:40.449]                 names <- names(envs)
[17:39:40.449]                 common <- intersect(names, old_names)
[17:39:40.449]                 added <- setdiff(names, old_names)
[17:39:40.449]                 removed <- setdiff(old_names, names)
[17:39:40.449]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.449]                   envs[common]]
[17:39:40.449]                 NAMES <- toupper(changed)
[17:39:40.449]                 args <- list()
[17:39:40.449]                 for (kk in seq_along(NAMES)) {
[17:39:40.449]                   name <- changed[[kk]]
[17:39:40.449]                   NAME <- NAMES[[kk]]
[17:39:40.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.449]                     next
[17:39:40.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.449]                 }
[17:39:40.449]                 NAMES <- toupper(added)
[17:39:40.449]                 for (kk in seq_along(NAMES)) {
[17:39:40.449]                   name <- added[[kk]]
[17:39:40.449]                   NAME <- NAMES[[kk]]
[17:39:40.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.449]                     next
[17:39:40.449]                   args[[name]] <- ""
[17:39:40.449]                 }
[17:39:40.449]                 NAMES <- toupper(removed)
[17:39:40.449]                 for (kk in seq_along(NAMES)) {
[17:39:40.449]                   name <- removed[[kk]]
[17:39:40.449]                   NAME <- NAMES[[kk]]
[17:39:40.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.449]                     next
[17:39:40.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.449]                 }
[17:39:40.449]                 if (length(args) > 0) 
[17:39:40.449]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.449]             }
[17:39:40.449]             else {
[17:39:40.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.449]             }
[17:39:40.449]             {
[17:39:40.449]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.449]                   0L) {
[17:39:40.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.449]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.449]                   base::options(opts)
[17:39:40.449]                 }
[17:39:40.449]                 {
[17:39:40.449]                   {
[17:39:40.449]                     NULL
[17:39:40.449]                     RNGkind("Mersenne-Twister")
[17:39:40.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.449]                       inherits = FALSE)
[17:39:40.449]                   }
[17:39:40.449]                   options(future.plan = NULL)
[17:39:40.449]                   if (is.na(NA_character_)) 
[17:39:40.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.449]                     .init = FALSE)
[17:39:40.449]                 }
[17:39:40.449]             }
[17:39:40.449]         }
[17:39:40.449]     })
[17:39:40.449]     if (TRUE) {
[17:39:40.449]         base::sink(type = "output", split = FALSE)
[17:39:40.449]         if (TRUE) {
[17:39:40.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.449]         }
[17:39:40.449]         else {
[17:39:40.449]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.449]         }
[17:39:40.449]         base::close(...future.stdout)
[17:39:40.449]         ...future.stdout <- NULL
[17:39:40.449]     }
[17:39:40.449]     ...future.result$conditions <- ...future.conditions
[17:39:40.449]     ...future.result$finished <- base::Sys.time()
[17:39:40.449]     ...future.result
[17:39:40.449] }
[17:39:40.450] assign_globals() ...
[17:39:40.451] List of 2
[17:39:40.451]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.451]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.451]  - attr(*, "where")=List of 2
[17:39:40.451]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.451]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.451]  - attr(*, "resolved")= logi FALSE
[17:39:40.451]  - attr(*, "total_size")= num 896
[17:39:40.451]  - attr(*, "already-done")= logi TRUE
[17:39:40.454] - copied ‘weight’ to environment
[17:39:40.454] - copied ‘group’ to environment
[17:39:40.454] assign_globals() ... done
[17:39:40.454] plan(): Setting new future strategy stack:
[17:39:40.454] List of future strategies:
[17:39:40.454] 1. sequential:
[17:39:40.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.454]    - tweaked: FALSE
[17:39:40.454]    - call: NULL
[17:39:40.455] plan(): nbrOfWorkers() = 1
[17:39:40.457] plan(): Setting new future strategy stack:
[17:39:40.457] List of future strategies:
[17:39:40.457] 1. sequential:
[17:39:40.457]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.457]    - tweaked: FALSE
[17:39:40.457]    - call: plan(strategy)
[17:39:40.457] plan(): nbrOfWorkers() = 1
[17:39:40.458] SequentialFuture started (and completed)
[17:39:40.458] - Launch lazy future ... done
[17:39:40.458] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.461] getGlobalsAndPackages() ...
[17:39:40.461] Searching for globals...
[17:39:40.462] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.463] Searching for globals ... DONE
[17:39:40.463] Resolving globals: FALSE
[17:39:40.463] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.463] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.464] - globals: [2] ‘weight’, ‘group’
[17:39:40.464] - packages: [1] ‘stats’
[17:39:40.464] getGlobalsAndPackages() ... DONE
[17:39:40.464] run() for ‘Future’ ...
[17:39:40.464] - state: ‘created’
[17:39:40.464] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.465]   - Field: ‘label’
[17:39:40.465]   - Field: ‘local’
[17:39:40.465]   - Field: ‘owner’
[17:39:40.465]   - Field: ‘envir’
[17:39:40.465]   - Field: ‘packages’
[17:39:40.465]   - Field: ‘gc’
[17:39:40.465]   - Field: ‘conditions’
[17:39:40.465]   - Field: ‘expr’
[17:39:40.466]   - Field: ‘uuid’
[17:39:40.466]   - Field: ‘seed’
[17:39:40.466]   - Field: ‘version’
[17:39:40.466]   - Field: ‘result’
[17:39:40.466]   - Field: ‘asynchronous’
[17:39:40.469]   - Field: ‘calls’
[17:39:40.469]   - Field: ‘globals’
[17:39:40.469]   - Field: ‘stdout’
[17:39:40.469]   - Field: ‘earlySignal’
[17:39:40.469]   - Field: ‘lazy’
[17:39:40.469]   - Field: ‘state’
[17:39:40.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.469] - Launch lazy future ...
[17:39:40.470] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.470] Packages needed by future strategies (n = 0): <none>
[17:39:40.470] {
[17:39:40.470]     {
[17:39:40.470]         {
[17:39:40.470]             ...future.startTime <- base::Sys.time()
[17:39:40.470]             {
[17:39:40.470]                 {
[17:39:40.470]                   {
[17:39:40.470]                     {
[17:39:40.470]                       base::local({
[17:39:40.470]                         has_future <- base::requireNamespace("future", 
[17:39:40.470]                           quietly = TRUE)
[17:39:40.470]                         if (has_future) {
[17:39:40.470]                           ns <- base::getNamespace("future")
[17:39:40.470]                           version <- ns[[".package"]][["version"]]
[17:39:40.470]                           if (is.null(version)) 
[17:39:40.470]                             version <- utils::packageVersion("future")
[17:39:40.470]                         }
[17:39:40.470]                         else {
[17:39:40.470]                           version <- NULL
[17:39:40.470]                         }
[17:39:40.470]                         if (!has_future || version < "1.8.0") {
[17:39:40.470]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.470]                             "", base::R.version$version.string), 
[17:39:40.470]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.470]                               "release", "version")], collapse = " "), 
[17:39:40.470]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.470]                             info)
[17:39:40.470]                           info <- base::paste(info, collapse = "; ")
[17:39:40.470]                           if (!has_future) {
[17:39:40.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.470]                               info)
[17:39:40.470]                           }
[17:39:40.470]                           else {
[17:39:40.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.470]                               info, version)
[17:39:40.470]                           }
[17:39:40.470]                           base::stop(msg)
[17:39:40.470]                         }
[17:39:40.470]                       })
[17:39:40.470]                     }
[17:39:40.470]                     base::local({
[17:39:40.470]                       for (pkg in "stats") {
[17:39:40.470]                         base::loadNamespace(pkg)
[17:39:40.470]                         base::library(pkg, character.only = TRUE)
[17:39:40.470]                       }
[17:39:40.470]                     })
[17:39:40.470]                   }
[17:39:40.470]                   ...future.strategy.old <- future::plan("list")
[17:39:40.470]                   options(future.plan = NULL)
[17:39:40.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.470]                 }
[17:39:40.470]                 ...future.workdir <- getwd()
[17:39:40.470]             }
[17:39:40.470]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.470]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.470]         }
[17:39:40.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.470]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.470]             base::names(...future.oldOptions))
[17:39:40.470]     }
[17:39:40.470]     if (FALSE) {
[17:39:40.470]     }
[17:39:40.470]     else {
[17:39:40.470]         if (TRUE) {
[17:39:40.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.470]                 open = "w")
[17:39:40.470]         }
[17:39:40.470]         else {
[17:39:40.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.470]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.470]         }
[17:39:40.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.470]             base::sink(type = "output", split = FALSE)
[17:39:40.470]             base::close(...future.stdout)
[17:39:40.470]         }, add = TRUE)
[17:39:40.470]     }
[17:39:40.470]     ...future.frame <- base::sys.nframe()
[17:39:40.470]     ...future.conditions <- base::list()
[17:39:40.470]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.470]     if (FALSE) {
[17:39:40.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.470]     }
[17:39:40.470]     ...future.result <- base::tryCatch({
[17:39:40.470]         base::withCallingHandlers({
[17:39:40.470]             ...future.value <- base::withVisible(base::local({
[17:39:40.470]                 lm(weight ~ group - 1)
[17:39:40.470]             }))
[17:39:40.470]             future::FutureResult(value = ...future.value$value, 
[17:39:40.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.470]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.470]                     ...future.globalenv.names))
[17:39:40.470]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.470]         }, condition = base::local({
[17:39:40.470]             c <- base::c
[17:39:40.470]             inherits <- base::inherits
[17:39:40.470]             invokeRestart <- base::invokeRestart
[17:39:40.470]             length <- base::length
[17:39:40.470]             list <- base::list
[17:39:40.470]             seq.int <- base::seq.int
[17:39:40.470]             signalCondition <- base::signalCondition
[17:39:40.470]             sys.calls <- base::sys.calls
[17:39:40.470]             `[[` <- base::`[[`
[17:39:40.470]             `+` <- base::`+`
[17:39:40.470]             `<<-` <- base::`<<-`
[17:39:40.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.470]                   3L)]
[17:39:40.470]             }
[17:39:40.470]             function(cond) {
[17:39:40.470]                 is_error <- inherits(cond, "error")
[17:39:40.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.470]                   NULL)
[17:39:40.470]                 if (is_error) {
[17:39:40.470]                   sessionInformation <- function() {
[17:39:40.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.470]                       search = base::search(), system = base::Sys.info())
[17:39:40.470]                   }
[17:39:40.470]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.470]                     cond$call), session = sessionInformation(), 
[17:39:40.470]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.470]                   signalCondition(cond)
[17:39:40.470]                 }
[17:39:40.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.470]                 "immediateCondition"))) {
[17:39:40.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.470]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.470]                   if (TRUE && !signal) {
[17:39:40.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.470]                     {
[17:39:40.470]                       inherits <- base::inherits
[17:39:40.470]                       invokeRestart <- base::invokeRestart
[17:39:40.470]                       is.null <- base::is.null
[17:39:40.470]                       muffled <- FALSE
[17:39:40.470]                       if (inherits(cond, "message")) {
[17:39:40.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.470]                         if (muffled) 
[17:39:40.470]                           invokeRestart("muffleMessage")
[17:39:40.470]                       }
[17:39:40.470]                       else if (inherits(cond, "warning")) {
[17:39:40.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.470]                         if (muffled) 
[17:39:40.470]                           invokeRestart("muffleWarning")
[17:39:40.470]                       }
[17:39:40.470]                       else if (inherits(cond, "condition")) {
[17:39:40.470]                         if (!is.null(pattern)) {
[17:39:40.470]                           computeRestarts <- base::computeRestarts
[17:39:40.470]                           grepl <- base::grepl
[17:39:40.470]                           restarts <- computeRestarts(cond)
[17:39:40.470]                           for (restart in restarts) {
[17:39:40.470]                             name <- restart$name
[17:39:40.470]                             if (is.null(name)) 
[17:39:40.470]                               next
[17:39:40.470]                             if (!grepl(pattern, name)) 
[17:39:40.470]                               next
[17:39:40.470]                             invokeRestart(restart)
[17:39:40.470]                             muffled <- TRUE
[17:39:40.470]                             break
[17:39:40.470]                           }
[17:39:40.470]                         }
[17:39:40.470]                       }
[17:39:40.470]                       invisible(muffled)
[17:39:40.470]                     }
[17:39:40.470]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.470]                   }
[17:39:40.470]                 }
[17:39:40.470]                 else {
[17:39:40.470]                   if (TRUE) {
[17:39:40.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.470]                     {
[17:39:40.470]                       inherits <- base::inherits
[17:39:40.470]                       invokeRestart <- base::invokeRestart
[17:39:40.470]                       is.null <- base::is.null
[17:39:40.470]                       muffled <- FALSE
[17:39:40.470]                       if (inherits(cond, "message")) {
[17:39:40.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.470]                         if (muffled) 
[17:39:40.470]                           invokeRestart("muffleMessage")
[17:39:40.470]                       }
[17:39:40.470]                       else if (inherits(cond, "warning")) {
[17:39:40.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.470]                         if (muffled) 
[17:39:40.470]                           invokeRestart("muffleWarning")
[17:39:40.470]                       }
[17:39:40.470]                       else if (inherits(cond, "condition")) {
[17:39:40.470]                         if (!is.null(pattern)) {
[17:39:40.470]                           computeRestarts <- base::computeRestarts
[17:39:40.470]                           grepl <- base::grepl
[17:39:40.470]                           restarts <- computeRestarts(cond)
[17:39:40.470]                           for (restart in restarts) {
[17:39:40.470]                             name <- restart$name
[17:39:40.470]                             if (is.null(name)) 
[17:39:40.470]                               next
[17:39:40.470]                             if (!grepl(pattern, name)) 
[17:39:40.470]                               next
[17:39:40.470]                             invokeRestart(restart)
[17:39:40.470]                             muffled <- TRUE
[17:39:40.470]                             break
[17:39:40.470]                           }
[17:39:40.470]                         }
[17:39:40.470]                       }
[17:39:40.470]                       invisible(muffled)
[17:39:40.470]                     }
[17:39:40.470]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.470]                   }
[17:39:40.470]                 }
[17:39:40.470]             }
[17:39:40.470]         }))
[17:39:40.470]     }, error = function(ex) {
[17:39:40.470]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.470]                 ...future.rng), started = ...future.startTime, 
[17:39:40.470]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.470]             version = "1.8"), class = "FutureResult")
[17:39:40.470]     }, finally = {
[17:39:40.470]         if (!identical(...future.workdir, getwd())) 
[17:39:40.470]             setwd(...future.workdir)
[17:39:40.470]         {
[17:39:40.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.470]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.470]             }
[17:39:40.470]             base::options(...future.oldOptions)
[17:39:40.470]             if (.Platform$OS.type == "windows") {
[17:39:40.470]                 old_names <- names(...future.oldEnvVars)
[17:39:40.470]                 envs <- base::Sys.getenv()
[17:39:40.470]                 names <- names(envs)
[17:39:40.470]                 common <- intersect(names, old_names)
[17:39:40.470]                 added <- setdiff(names, old_names)
[17:39:40.470]                 removed <- setdiff(old_names, names)
[17:39:40.470]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.470]                   envs[common]]
[17:39:40.470]                 NAMES <- toupper(changed)
[17:39:40.470]                 args <- list()
[17:39:40.470]                 for (kk in seq_along(NAMES)) {
[17:39:40.470]                   name <- changed[[kk]]
[17:39:40.470]                   NAME <- NAMES[[kk]]
[17:39:40.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.470]                     next
[17:39:40.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.470]                 }
[17:39:40.470]                 NAMES <- toupper(added)
[17:39:40.470]                 for (kk in seq_along(NAMES)) {
[17:39:40.470]                   name <- added[[kk]]
[17:39:40.470]                   NAME <- NAMES[[kk]]
[17:39:40.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.470]                     next
[17:39:40.470]                   args[[name]] <- ""
[17:39:40.470]                 }
[17:39:40.470]                 NAMES <- toupper(removed)
[17:39:40.470]                 for (kk in seq_along(NAMES)) {
[17:39:40.470]                   name <- removed[[kk]]
[17:39:40.470]                   NAME <- NAMES[[kk]]
[17:39:40.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.470]                     next
[17:39:40.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.470]                 }
[17:39:40.470]                 if (length(args) > 0) 
[17:39:40.470]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.470]             }
[17:39:40.470]             else {
[17:39:40.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.470]             }
[17:39:40.470]             {
[17:39:40.470]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.470]                   0L) {
[17:39:40.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.470]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.470]                   base::options(opts)
[17:39:40.470]                 }
[17:39:40.470]                 {
[17:39:40.470]                   {
[17:39:40.470]                     NULL
[17:39:40.470]                     RNGkind("Mersenne-Twister")
[17:39:40.470]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.470]                       inherits = FALSE)
[17:39:40.470]                   }
[17:39:40.470]                   options(future.plan = NULL)
[17:39:40.470]                   if (is.na(NA_character_)) 
[17:39:40.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.470]                     .init = FALSE)
[17:39:40.470]                 }
[17:39:40.470]             }
[17:39:40.470]         }
[17:39:40.470]     })
[17:39:40.470]     if (TRUE) {
[17:39:40.470]         base::sink(type = "output", split = FALSE)
[17:39:40.470]         if (TRUE) {
[17:39:40.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.470]         }
[17:39:40.470]         else {
[17:39:40.470]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.470]         }
[17:39:40.470]         base::close(...future.stdout)
[17:39:40.470]         ...future.stdout <- NULL
[17:39:40.470]     }
[17:39:40.470]     ...future.result$conditions <- ...future.conditions
[17:39:40.470]     ...future.result$finished <- base::Sys.time()
[17:39:40.470]     ...future.result
[17:39:40.470] }
[17:39:40.472] assign_globals() ...
[17:39:40.472] List of 2
[17:39:40.472]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.472]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.472]  - attr(*, "where")=List of 2
[17:39:40.472]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.472]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.472]  - attr(*, "resolved")= logi FALSE
[17:39:40.472]  - attr(*, "total_size")= num 896
[17:39:40.472]  - attr(*, "already-done")= logi TRUE
[17:39:40.475] - copied ‘weight’ to environment
[17:39:40.475] - copied ‘group’ to environment
[17:39:40.475] assign_globals() ... done
[17:39:40.476] plan(): Setting new future strategy stack:
[17:39:40.476] List of future strategies:
[17:39:40.476] 1. sequential:
[17:39:40.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.476]    - tweaked: FALSE
[17:39:40.476]    - call: NULL
[17:39:40.476] plan(): nbrOfWorkers() = 1
[17:39:40.478] plan(): Setting new future strategy stack:
[17:39:40.478] List of future strategies:
[17:39:40.478] 1. sequential:
[17:39:40.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.478]    - tweaked: FALSE
[17:39:40.478]    - call: plan(strategy)
[17:39:40.478] plan(): nbrOfWorkers() = 1
[17:39:40.478] SequentialFuture started (and completed)
[17:39:40.479] - Launch lazy future ... done
[17:39:40.479] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.481] getGlobalsAndPackages() ...
[17:39:40.481] Searching for globals...
[17:39:40.483] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.483] Searching for globals ... DONE
[17:39:40.483] Resolving globals: FALSE
[17:39:40.483] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.484] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.484] - globals: [2] ‘weight’, ‘group’
[17:39:40.484] - packages: [1] ‘stats’
[17:39:40.484] getGlobalsAndPackages() ... DONE
[17:39:40.484] run() for ‘Future’ ...
[17:39:40.484] - state: ‘created’
[17:39:40.485] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.485] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.485]   - Field: ‘label’
[17:39:40.485]   - Field: ‘local’
[17:39:40.485]   - Field: ‘owner’
[17:39:40.485]   - Field: ‘envir’
[17:39:40.485]   - Field: ‘packages’
[17:39:40.485]   - Field: ‘gc’
[17:39:40.486]   - Field: ‘conditions’
[17:39:40.486]   - Field: ‘expr’
[17:39:40.486]   - Field: ‘uuid’
[17:39:40.486]   - Field: ‘seed’
[17:39:40.486]   - Field: ‘version’
[17:39:40.486]   - Field: ‘result’
[17:39:40.486]   - Field: ‘asynchronous’
[17:39:40.486]   - Field: ‘calls’
[17:39:40.486]   - Field: ‘globals’
[17:39:40.486]   - Field: ‘stdout’
[17:39:40.486]   - Field: ‘earlySignal’
[17:39:40.487]   - Field: ‘lazy’
[17:39:40.487]   - Field: ‘state’
[17:39:40.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.487] - Launch lazy future ...
[17:39:40.487] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.487] Packages needed by future strategies (n = 0): <none>
[17:39:40.488] {
[17:39:40.488]     {
[17:39:40.488]         {
[17:39:40.488]             ...future.startTime <- base::Sys.time()
[17:39:40.488]             {
[17:39:40.488]                 {
[17:39:40.488]                   {
[17:39:40.488]                     {
[17:39:40.488]                       base::local({
[17:39:40.488]                         has_future <- base::requireNamespace("future", 
[17:39:40.488]                           quietly = TRUE)
[17:39:40.488]                         if (has_future) {
[17:39:40.488]                           ns <- base::getNamespace("future")
[17:39:40.488]                           version <- ns[[".package"]][["version"]]
[17:39:40.488]                           if (is.null(version)) 
[17:39:40.488]                             version <- utils::packageVersion("future")
[17:39:40.488]                         }
[17:39:40.488]                         else {
[17:39:40.488]                           version <- NULL
[17:39:40.488]                         }
[17:39:40.488]                         if (!has_future || version < "1.8.0") {
[17:39:40.488]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.488]                             "", base::R.version$version.string), 
[17:39:40.488]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.488]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.488]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.488]                               "release", "version")], collapse = " "), 
[17:39:40.488]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.488]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.488]                             info)
[17:39:40.488]                           info <- base::paste(info, collapse = "; ")
[17:39:40.488]                           if (!has_future) {
[17:39:40.488]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.488]                               info)
[17:39:40.488]                           }
[17:39:40.488]                           else {
[17:39:40.488]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.488]                               info, version)
[17:39:40.488]                           }
[17:39:40.488]                           base::stop(msg)
[17:39:40.488]                         }
[17:39:40.488]                       })
[17:39:40.488]                     }
[17:39:40.488]                     base::local({
[17:39:40.488]                       for (pkg in "stats") {
[17:39:40.488]                         base::loadNamespace(pkg)
[17:39:40.488]                         base::library(pkg, character.only = TRUE)
[17:39:40.488]                       }
[17:39:40.488]                     })
[17:39:40.488]                   }
[17:39:40.488]                   ...future.strategy.old <- future::plan("list")
[17:39:40.488]                   options(future.plan = NULL)
[17:39:40.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.488]                 }
[17:39:40.488]                 ...future.workdir <- getwd()
[17:39:40.488]             }
[17:39:40.488]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.488]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.488]         }
[17:39:40.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.488]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.488]             base::names(...future.oldOptions))
[17:39:40.488]     }
[17:39:40.488]     if (FALSE) {
[17:39:40.488]     }
[17:39:40.488]     else {
[17:39:40.488]         if (TRUE) {
[17:39:40.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.488]                 open = "w")
[17:39:40.488]         }
[17:39:40.488]         else {
[17:39:40.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.488]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.488]         }
[17:39:40.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.488]             base::sink(type = "output", split = FALSE)
[17:39:40.488]             base::close(...future.stdout)
[17:39:40.488]         }, add = TRUE)
[17:39:40.488]     }
[17:39:40.488]     ...future.frame <- base::sys.nframe()
[17:39:40.488]     ...future.conditions <- base::list()
[17:39:40.488]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.488]     if (FALSE) {
[17:39:40.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.488]     }
[17:39:40.488]     ...future.result <- base::tryCatch({
[17:39:40.488]         base::withCallingHandlers({
[17:39:40.488]             ...future.value <- base::withVisible(base::local({
[17:39:40.488]                 lm(weight ~ group - 1)
[17:39:40.488]             }))
[17:39:40.488]             future::FutureResult(value = ...future.value$value, 
[17:39:40.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.488]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.488]                     ...future.globalenv.names))
[17:39:40.488]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.488]         }, condition = base::local({
[17:39:40.488]             c <- base::c
[17:39:40.488]             inherits <- base::inherits
[17:39:40.488]             invokeRestart <- base::invokeRestart
[17:39:40.488]             length <- base::length
[17:39:40.488]             list <- base::list
[17:39:40.488]             seq.int <- base::seq.int
[17:39:40.488]             signalCondition <- base::signalCondition
[17:39:40.488]             sys.calls <- base::sys.calls
[17:39:40.488]             `[[` <- base::`[[`
[17:39:40.488]             `+` <- base::`+`
[17:39:40.488]             `<<-` <- base::`<<-`
[17:39:40.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.488]                   3L)]
[17:39:40.488]             }
[17:39:40.488]             function(cond) {
[17:39:40.488]                 is_error <- inherits(cond, "error")
[17:39:40.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.488]                   NULL)
[17:39:40.488]                 if (is_error) {
[17:39:40.488]                   sessionInformation <- function() {
[17:39:40.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.488]                       search = base::search(), system = base::Sys.info())
[17:39:40.488]                   }
[17:39:40.488]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.488]                     cond$call), session = sessionInformation(), 
[17:39:40.488]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.488]                   signalCondition(cond)
[17:39:40.488]                 }
[17:39:40.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.488]                 "immediateCondition"))) {
[17:39:40.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.488]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.488]                   if (TRUE && !signal) {
[17:39:40.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.488]                     {
[17:39:40.488]                       inherits <- base::inherits
[17:39:40.488]                       invokeRestart <- base::invokeRestart
[17:39:40.488]                       is.null <- base::is.null
[17:39:40.488]                       muffled <- FALSE
[17:39:40.488]                       if (inherits(cond, "message")) {
[17:39:40.488]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.488]                         if (muffled) 
[17:39:40.488]                           invokeRestart("muffleMessage")
[17:39:40.488]                       }
[17:39:40.488]                       else if (inherits(cond, "warning")) {
[17:39:40.488]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.488]                         if (muffled) 
[17:39:40.488]                           invokeRestart("muffleWarning")
[17:39:40.488]                       }
[17:39:40.488]                       else if (inherits(cond, "condition")) {
[17:39:40.488]                         if (!is.null(pattern)) {
[17:39:40.488]                           computeRestarts <- base::computeRestarts
[17:39:40.488]                           grepl <- base::grepl
[17:39:40.488]                           restarts <- computeRestarts(cond)
[17:39:40.488]                           for (restart in restarts) {
[17:39:40.488]                             name <- restart$name
[17:39:40.488]                             if (is.null(name)) 
[17:39:40.488]                               next
[17:39:40.488]                             if (!grepl(pattern, name)) 
[17:39:40.488]                               next
[17:39:40.488]                             invokeRestart(restart)
[17:39:40.488]                             muffled <- TRUE
[17:39:40.488]                             break
[17:39:40.488]                           }
[17:39:40.488]                         }
[17:39:40.488]                       }
[17:39:40.488]                       invisible(muffled)
[17:39:40.488]                     }
[17:39:40.488]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.488]                   }
[17:39:40.488]                 }
[17:39:40.488]                 else {
[17:39:40.488]                   if (TRUE) {
[17:39:40.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.488]                     {
[17:39:40.488]                       inherits <- base::inherits
[17:39:40.488]                       invokeRestart <- base::invokeRestart
[17:39:40.488]                       is.null <- base::is.null
[17:39:40.488]                       muffled <- FALSE
[17:39:40.488]                       if (inherits(cond, "message")) {
[17:39:40.488]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.488]                         if (muffled) 
[17:39:40.488]                           invokeRestart("muffleMessage")
[17:39:40.488]                       }
[17:39:40.488]                       else if (inherits(cond, "warning")) {
[17:39:40.488]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.488]                         if (muffled) 
[17:39:40.488]                           invokeRestart("muffleWarning")
[17:39:40.488]                       }
[17:39:40.488]                       else if (inherits(cond, "condition")) {
[17:39:40.488]                         if (!is.null(pattern)) {
[17:39:40.488]                           computeRestarts <- base::computeRestarts
[17:39:40.488]                           grepl <- base::grepl
[17:39:40.488]                           restarts <- computeRestarts(cond)
[17:39:40.488]                           for (restart in restarts) {
[17:39:40.488]                             name <- restart$name
[17:39:40.488]                             if (is.null(name)) 
[17:39:40.488]                               next
[17:39:40.488]                             if (!grepl(pattern, name)) 
[17:39:40.488]                               next
[17:39:40.488]                             invokeRestart(restart)
[17:39:40.488]                             muffled <- TRUE
[17:39:40.488]                             break
[17:39:40.488]                           }
[17:39:40.488]                         }
[17:39:40.488]                       }
[17:39:40.488]                       invisible(muffled)
[17:39:40.488]                     }
[17:39:40.488]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.488]                   }
[17:39:40.488]                 }
[17:39:40.488]             }
[17:39:40.488]         }))
[17:39:40.488]     }, error = function(ex) {
[17:39:40.488]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.488]                 ...future.rng), started = ...future.startTime, 
[17:39:40.488]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.488]             version = "1.8"), class = "FutureResult")
[17:39:40.488]     }, finally = {
[17:39:40.488]         if (!identical(...future.workdir, getwd())) 
[17:39:40.488]             setwd(...future.workdir)
[17:39:40.488]         {
[17:39:40.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.488]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.488]             }
[17:39:40.488]             base::options(...future.oldOptions)
[17:39:40.488]             if (.Platform$OS.type == "windows") {
[17:39:40.488]                 old_names <- names(...future.oldEnvVars)
[17:39:40.488]                 envs <- base::Sys.getenv()
[17:39:40.488]                 names <- names(envs)
[17:39:40.488]                 common <- intersect(names, old_names)
[17:39:40.488]                 added <- setdiff(names, old_names)
[17:39:40.488]                 removed <- setdiff(old_names, names)
[17:39:40.488]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.488]                   envs[common]]
[17:39:40.488]                 NAMES <- toupper(changed)
[17:39:40.488]                 args <- list()
[17:39:40.488]                 for (kk in seq_along(NAMES)) {
[17:39:40.488]                   name <- changed[[kk]]
[17:39:40.488]                   NAME <- NAMES[[kk]]
[17:39:40.488]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.488]                     next
[17:39:40.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.488]                 }
[17:39:40.488]                 NAMES <- toupper(added)
[17:39:40.488]                 for (kk in seq_along(NAMES)) {
[17:39:40.488]                   name <- added[[kk]]
[17:39:40.488]                   NAME <- NAMES[[kk]]
[17:39:40.488]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.488]                     next
[17:39:40.488]                   args[[name]] <- ""
[17:39:40.488]                 }
[17:39:40.488]                 NAMES <- toupper(removed)
[17:39:40.488]                 for (kk in seq_along(NAMES)) {
[17:39:40.488]                   name <- removed[[kk]]
[17:39:40.488]                   NAME <- NAMES[[kk]]
[17:39:40.488]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.488]                     next
[17:39:40.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.488]                 }
[17:39:40.488]                 if (length(args) > 0) 
[17:39:40.488]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.488]             }
[17:39:40.488]             else {
[17:39:40.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.488]             }
[17:39:40.488]             {
[17:39:40.488]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.488]                   0L) {
[17:39:40.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.488]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.488]                   base::options(opts)
[17:39:40.488]                 }
[17:39:40.488]                 {
[17:39:40.488]                   {
[17:39:40.488]                     NULL
[17:39:40.488]                     RNGkind("Mersenne-Twister")
[17:39:40.488]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.488]                       inherits = FALSE)
[17:39:40.488]                   }
[17:39:40.488]                   options(future.plan = NULL)
[17:39:40.488]                   if (is.na(NA_character_)) 
[17:39:40.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.488]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.488]                     .init = FALSE)
[17:39:40.488]                 }
[17:39:40.488]             }
[17:39:40.488]         }
[17:39:40.488]     })
[17:39:40.488]     if (TRUE) {
[17:39:40.488]         base::sink(type = "output", split = FALSE)
[17:39:40.488]         if (TRUE) {
[17:39:40.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.488]         }
[17:39:40.488]         else {
[17:39:40.488]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.488]         }
[17:39:40.488]         base::close(...future.stdout)
[17:39:40.488]         ...future.stdout <- NULL
[17:39:40.488]     }
[17:39:40.488]     ...future.result$conditions <- ...future.conditions
[17:39:40.488]     ...future.result$finished <- base::Sys.time()
[17:39:40.488]     ...future.result
[17:39:40.488] }
[17:39:40.489] assign_globals() ...
[17:39:40.489] List of 2
[17:39:40.489]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.489]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.489]  - attr(*, "where")=List of 2
[17:39:40.489]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.489]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.489]  - attr(*, "resolved")= logi FALSE
[17:39:40.489]  - attr(*, "total_size")= num 896
[17:39:40.489]  - attr(*, "already-done")= logi TRUE
[17:39:40.492] - copied ‘weight’ to environment
[17:39:40.492] - copied ‘group’ to environment
[17:39:40.493] assign_globals() ... done
[17:39:40.493] plan(): Setting new future strategy stack:
[17:39:40.493] List of future strategies:
[17:39:40.493] 1. sequential:
[17:39:40.493]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.493]    - tweaked: FALSE
[17:39:40.493]    - call: NULL
[17:39:40.493] plan(): nbrOfWorkers() = 1
[17:39:40.495] plan(): Setting new future strategy stack:
[17:39:40.495] List of future strategies:
[17:39:40.495] 1. sequential:
[17:39:40.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.495]    - tweaked: FALSE
[17:39:40.495]    - call: plan(strategy)
[17:39:40.495] plan(): nbrOfWorkers() = 1
[17:39:40.496] SequentialFuture started (and completed)
[17:39:40.496] - Launch lazy future ... done
[17:39:40.496] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.499] getGlobalsAndPackages() ...
[17:39:40.499] Searching for globals...
[17:39:40.501] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.501] Searching for globals ... DONE
[17:39:40.501] Resolving globals: FALSE
[17:39:40.502] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.502] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.502] - globals: [2] ‘weight’, ‘group’
[17:39:40.502] - packages: [1] ‘stats’
[17:39:40.502] getGlobalsAndPackages() ... DONE
[17:39:40.503] run() for ‘Future’ ...
[17:39:40.503] - state: ‘created’
[17:39:40.503] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.503] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.503]   - Field: ‘label’
[17:39:40.503]   - Field: ‘local’
[17:39:40.503]   - Field: ‘owner’
[17:39:40.504]   - Field: ‘envir’
[17:39:40.504]   - Field: ‘packages’
[17:39:40.504]   - Field: ‘gc’
[17:39:40.504]   - Field: ‘conditions’
[17:39:40.504]   - Field: ‘expr’
[17:39:40.504]   - Field: ‘uuid’
[17:39:40.504]   - Field: ‘seed’
[17:39:40.504]   - Field: ‘version’
[17:39:40.504]   - Field: ‘result’
[17:39:40.504]   - Field: ‘asynchronous’
[17:39:40.504]   - Field: ‘calls’
[17:39:40.505]   - Field: ‘globals’
[17:39:40.505]   - Field: ‘stdout’
[17:39:40.505]   - Field: ‘earlySignal’
[17:39:40.505]   - Field: ‘lazy’
[17:39:40.505]   - Field: ‘state’
[17:39:40.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.505] - Launch lazy future ...
[17:39:40.505] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.505] Packages needed by future strategies (n = 0): <none>
[17:39:40.506] {
[17:39:40.506]     {
[17:39:40.506]         {
[17:39:40.506]             ...future.startTime <- base::Sys.time()
[17:39:40.506]             {
[17:39:40.506]                 {
[17:39:40.506]                   {
[17:39:40.506]                     {
[17:39:40.506]                       base::local({
[17:39:40.506]                         has_future <- base::requireNamespace("future", 
[17:39:40.506]                           quietly = TRUE)
[17:39:40.506]                         if (has_future) {
[17:39:40.506]                           ns <- base::getNamespace("future")
[17:39:40.506]                           version <- ns[[".package"]][["version"]]
[17:39:40.506]                           if (is.null(version)) 
[17:39:40.506]                             version <- utils::packageVersion("future")
[17:39:40.506]                         }
[17:39:40.506]                         else {
[17:39:40.506]                           version <- NULL
[17:39:40.506]                         }
[17:39:40.506]                         if (!has_future || version < "1.8.0") {
[17:39:40.506]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.506]                             "", base::R.version$version.string), 
[17:39:40.506]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.506]                               "release", "version")], collapse = " "), 
[17:39:40.506]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.506]                             info)
[17:39:40.506]                           info <- base::paste(info, collapse = "; ")
[17:39:40.506]                           if (!has_future) {
[17:39:40.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.506]                               info)
[17:39:40.506]                           }
[17:39:40.506]                           else {
[17:39:40.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.506]                               info, version)
[17:39:40.506]                           }
[17:39:40.506]                           base::stop(msg)
[17:39:40.506]                         }
[17:39:40.506]                       })
[17:39:40.506]                     }
[17:39:40.506]                     base::local({
[17:39:40.506]                       for (pkg in "stats") {
[17:39:40.506]                         base::loadNamespace(pkg)
[17:39:40.506]                         base::library(pkg, character.only = TRUE)
[17:39:40.506]                       }
[17:39:40.506]                     })
[17:39:40.506]                   }
[17:39:40.506]                   ...future.strategy.old <- future::plan("list")
[17:39:40.506]                   options(future.plan = NULL)
[17:39:40.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.506]                 }
[17:39:40.506]                 ...future.workdir <- getwd()
[17:39:40.506]             }
[17:39:40.506]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.506]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.506]         }
[17:39:40.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.506]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.506]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.506]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.506]             base::names(...future.oldOptions))
[17:39:40.506]     }
[17:39:40.506]     if (FALSE) {
[17:39:40.506]     }
[17:39:40.506]     else {
[17:39:40.506]         if (TRUE) {
[17:39:40.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.506]                 open = "w")
[17:39:40.506]         }
[17:39:40.506]         else {
[17:39:40.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.506]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.506]         }
[17:39:40.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.506]             base::sink(type = "output", split = FALSE)
[17:39:40.506]             base::close(...future.stdout)
[17:39:40.506]         }, add = TRUE)
[17:39:40.506]     }
[17:39:40.506]     ...future.frame <- base::sys.nframe()
[17:39:40.506]     ...future.conditions <- base::list()
[17:39:40.506]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.506]     if (FALSE) {
[17:39:40.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.506]     }
[17:39:40.506]     ...future.result <- base::tryCatch({
[17:39:40.506]         base::withCallingHandlers({
[17:39:40.506]             ...future.value <- base::withVisible(base::local({
[17:39:40.506]                 lm(weight ~ group - 1)
[17:39:40.506]             }))
[17:39:40.506]             future::FutureResult(value = ...future.value$value, 
[17:39:40.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.506]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.506]                     ...future.globalenv.names))
[17:39:40.506]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.506]         }, condition = base::local({
[17:39:40.506]             c <- base::c
[17:39:40.506]             inherits <- base::inherits
[17:39:40.506]             invokeRestart <- base::invokeRestart
[17:39:40.506]             length <- base::length
[17:39:40.506]             list <- base::list
[17:39:40.506]             seq.int <- base::seq.int
[17:39:40.506]             signalCondition <- base::signalCondition
[17:39:40.506]             sys.calls <- base::sys.calls
[17:39:40.506]             `[[` <- base::`[[`
[17:39:40.506]             `+` <- base::`+`
[17:39:40.506]             `<<-` <- base::`<<-`
[17:39:40.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.506]                   3L)]
[17:39:40.506]             }
[17:39:40.506]             function(cond) {
[17:39:40.506]                 is_error <- inherits(cond, "error")
[17:39:40.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.506]                   NULL)
[17:39:40.506]                 if (is_error) {
[17:39:40.506]                   sessionInformation <- function() {
[17:39:40.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.506]                       search = base::search(), system = base::Sys.info())
[17:39:40.506]                   }
[17:39:40.506]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.506]                     cond$call), session = sessionInformation(), 
[17:39:40.506]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.506]                   signalCondition(cond)
[17:39:40.506]                 }
[17:39:40.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.506]                 "immediateCondition"))) {
[17:39:40.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.506]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.506]                   if (TRUE && !signal) {
[17:39:40.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.506]                     {
[17:39:40.506]                       inherits <- base::inherits
[17:39:40.506]                       invokeRestart <- base::invokeRestart
[17:39:40.506]                       is.null <- base::is.null
[17:39:40.506]                       muffled <- FALSE
[17:39:40.506]                       if (inherits(cond, "message")) {
[17:39:40.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.506]                         if (muffled) 
[17:39:40.506]                           invokeRestart("muffleMessage")
[17:39:40.506]                       }
[17:39:40.506]                       else if (inherits(cond, "warning")) {
[17:39:40.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.506]                         if (muffled) 
[17:39:40.506]                           invokeRestart("muffleWarning")
[17:39:40.506]                       }
[17:39:40.506]                       else if (inherits(cond, "condition")) {
[17:39:40.506]                         if (!is.null(pattern)) {
[17:39:40.506]                           computeRestarts <- base::computeRestarts
[17:39:40.506]                           grepl <- base::grepl
[17:39:40.506]                           restarts <- computeRestarts(cond)
[17:39:40.506]                           for (restart in restarts) {
[17:39:40.506]                             name <- restart$name
[17:39:40.506]                             if (is.null(name)) 
[17:39:40.506]                               next
[17:39:40.506]                             if (!grepl(pattern, name)) 
[17:39:40.506]                               next
[17:39:40.506]                             invokeRestart(restart)
[17:39:40.506]                             muffled <- TRUE
[17:39:40.506]                             break
[17:39:40.506]                           }
[17:39:40.506]                         }
[17:39:40.506]                       }
[17:39:40.506]                       invisible(muffled)
[17:39:40.506]                     }
[17:39:40.506]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.506]                   }
[17:39:40.506]                 }
[17:39:40.506]                 else {
[17:39:40.506]                   if (TRUE) {
[17:39:40.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.506]                     {
[17:39:40.506]                       inherits <- base::inherits
[17:39:40.506]                       invokeRestart <- base::invokeRestart
[17:39:40.506]                       is.null <- base::is.null
[17:39:40.506]                       muffled <- FALSE
[17:39:40.506]                       if (inherits(cond, "message")) {
[17:39:40.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.506]                         if (muffled) 
[17:39:40.506]                           invokeRestart("muffleMessage")
[17:39:40.506]                       }
[17:39:40.506]                       else if (inherits(cond, "warning")) {
[17:39:40.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.506]                         if (muffled) 
[17:39:40.506]                           invokeRestart("muffleWarning")
[17:39:40.506]                       }
[17:39:40.506]                       else if (inherits(cond, "condition")) {
[17:39:40.506]                         if (!is.null(pattern)) {
[17:39:40.506]                           computeRestarts <- base::computeRestarts
[17:39:40.506]                           grepl <- base::grepl
[17:39:40.506]                           restarts <- computeRestarts(cond)
[17:39:40.506]                           for (restart in restarts) {
[17:39:40.506]                             name <- restart$name
[17:39:40.506]                             if (is.null(name)) 
[17:39:40.506]                               next
[17:39:40.506]                             if (!grepl(pattern, name)) 
[17:39:40.506]                               next
[17:39:40.506]                             invokeRestart(restart)
[17:39:40.506]                             muffled <- TRUE
[17:39:40.506]                             break
[17:39:40.506]                           }
[17:39:40.506]                         }
[17:39:40.506]                       }
[17:39:40.506]                       invisible(muffled)
[17:39:40.506]                     }
[17:39:40.506]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.506]                   }
[17:39:40.506]                 }
[17:39:40.506]             }
[17:39:40.506]         }))
[17:39:40.506]     }, error = function(ex) {
[17:39:40.506]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.506]                 ...future.rng), started = ...future.startTime, 
[17:39:40.506]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.506]             version = "1.8"), class = "FutureResult")
[17:39:40.506]     }, finally = {
[17:39:40.506]         if (!identical(...future.workdir, getwd())) 
[17:39:40.506]             setwd(...future.workdir)
[17:39:40.506]         {
[17:39:40.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.506]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.506]             }
[17:39:40.506]             base::options(...future.oldOptions)
[17:39:40.506]             if (.Platform$OS.type == "windows") {
[17:39:40.506]                 old_names <- names(...future.oldEnvVars)
[17:39:40.506]                 envs <- base::Sys.getenv()
[17:39:40.506]                 names <- names(envs)
[17:39:40.506]                 common <- intersect(names, old_names)
[17:39:40.506]                 added <- setdiff(names, old_names)
[17:39:40.506]                 removed <- setdiff(old_names, names)
[17:39:40.506]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.506]                   envs[common]]
[17:39:40.506]                 NAMES <- toupper(changed)
[17:39:40.506]                 args <- list()
[17:39:40.506]                 for (kk in seq_along(NAMES)) {
[17:39:40.506]                   name <- changed[[kk]]
[17:39:40.506]                   NAME <- NAMES[[kk]]
[17:39:40.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.506]                     next
[17:39:40.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.506]                 }
[17:39:40.506]                 NAMES <- toupper(added)
[17:39:40.506]                 for (kk in seq_along(NAMES)) {
[17:39:40.506]                   name <- added[[kk]]
[17:39:40.506]                   NAME <- NAMES[[kk]]
[17:39:40.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.506]                     next
[17:39:40.506]                   args[[name]] <- ""
[17:39:40.506]                 }
[17:39:40.506]                 NAMES <- toupper(removed)
[17:39:40.506]                 for (kk in seq_along(NAMES)) {
[17:39:40.506]                   name <- removed[[kk]]
[17:39:40.506]                   NAME <- NAMES[[kk]]
[17:39:40.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.506]                     next
[17:39:40.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.506]                 }
[17:39:40.506]                 if (length(args) > 0) 
[17:39:40.506]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.506]             }
[17:39:40.506]             else {
[17:39:40.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.506]             }
[17:39:40.506]             {
[17:39:40.506]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.506]                   0L) {
[17:39:40.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.506]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.506]                   base::options(opts)
[17:39:40.506]                 }
[17:39:40.506]                 {
[17:39:40.506]                   {
[17:39:40.506]                     NULL
[17:39:40.506]                     RNGkind("Mersenne-Twister")
[17:39:40.506]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.506]                       inherits = FALSE)
[17:39:40.506]                   }
[17:39:40.506]                   options(future.plan = NULL)
[17:39:40.506]                   if (is.na(NA_character_)) 
[17:39:40.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.506]                     .init = FALSE)
[17:39:40.506]                 }
[17:39:40.506]             }
[17:39:40.506]         }
[17:39:40.506]     })
[17:39:40.506]     if (TRUE) {
[17:39:40.506]         base::sink(type = "output", split = FALSE)
[17:39:40.506]         if (TRUE) {
[17:39:40.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.506]         }
[17:39:40.506]         else {
[17:39:40.506]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.506]         }
[17:39:40.506]         base::close(...future.stdout)
[17:39:40.506]         ...future.stdout <- NULL
[17:39:40.506]     }
[17:39:40.506]     ...future.result$conditions <- ...future.conditions
[17:39:40.506]     ...future.result$finished <- base::Sys.time()
[17:39:40.506]     ...future.result
[17:39:40.506] }
[17:39:40.507] assign_globals() ...
[17:39:40.508] List of 2
[17:39:40.508]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.508]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.508]  - attr(*, "where")=List of 2
[17:39:40.508]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.508]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.508]  - attr(*, "resolved")= logi FALSE
[17:39:40.508]  - attr(*, "total_size")= num 896
[17:39:40.508]  - attr(*, "already-done")= logi TRUE
[17:39:40.510] - copied ‘weight’ to environment
[17:39:40.511] - copied ‘group’ to environment
[17:39:40.511] assign_globals() ... done
[17:39:40.511] plan(): Setting new future strategy stack:
[17:39:40.511] List of future strategies:
[17:39:40.511] 1. sequential:
[17:39:40.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.511]    - tweaked: FALSE
[17:39:40.511]    - call: NULL
[17:39:40.512] plan(): nbrOfWorkers() = 1
[17:39:40.513] plan(): Setting new future strategy stack:
[17:39:40.513] List of future strategies:
[17:39:40.513] 1. sequential:
[17:39:40.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.513]    - tweaked: FALSE
[17:39:40.513]    - call: plan(strategy)
[17:39:40.514] plan(): nbrOfWorkers() = 1
[17:39:40.514] SequentialFuture started (and completed)
[17:39:40.514] - Launch lazy future ... done
[17:39:40.514] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.516] getGlobalsAndPackages() ...
[17:39:40.516] Searching for globals...
[17:39:40.517] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.517] Searching for globals ... DONE
[17:39:40.517] Resolving globals: FALSE
[17:39:40.518] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.518] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.518] - globals: [2] ‘weight’, ‘group’
[17:39:40.518] - packages: [1] ‘stats’
[17:39:40.519] getGlobalsAndPackages() ... DONE
[17:39:40.519] run() for ‘Future’ ...
[17:39:40.519] - state: ‘created’
[17:39:40.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.520]   - Field: ‘label’
[17:39:40.520]   - Field: ‘local’
[17:39:40.520]   - Field: ‘owner’
[17:39:40.520]   - Field: ‘envir’
[17:39:40.520]   - Field: ‘packages’
[17:39:40.520]   - Field: ‘gc’
[17:39:40.520]   - Field: ‘conditions’
[17:39:40.520]   - Field: ‘expr’
[17:39:40.520]   - Field: ‘uuid’
[17:39:40.520]   - Field: ‘seed’
[17:39:40.520]   - Field: ‘version’
[17:39:40.521]   - Field: ‘result’
[17:39:40.521]   - Field: ‘asynchronous’
[17:39:40.521]   - Field: ‘calls’
[17:39:40.521]   - Field: ‘globals’
[17:39:40.521]   - Field: ‘stdout’
[17:39:40.521]   - Field: ‘earlySignal’
[17:39:40.521]   - Field: ‘lazy’
[17:39:40.521]   - Field: ‘state’
[17:39:40.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.521] - Launch lazy future ...
[17:39:40.521] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.522] Packages needed by future strategies (n = 0): <none>
[17:39:40.524] {
[17:39:40.524]     {
[17:39:40.524]         {
[17:39:40.524]             ...future.startTime <- base::Sys.time()
[17:39:40.524]             {
[17:39:40.524]                 {
[17:39:40.524]                   {
[17:39:40.524]                     {
[17:39:40.524]                       base::local({
[17:39:40.524]                         has_future <- base::requireNamespace("future", 
[17:39:40.524]                           quietly = TRUE)
[17:39:40.524]                         if (has_future) {
[17:39:40.524]                           ns <- base::getNamespace("future")
[17:39:40.524]                           version <- ns[[".package"]][["version"]]
[17:39:40.524]                           if (is.null(version)) 
[17:39:40.524]                             version <- utils::packageVersion("future")
[17:39:40.524]                         }
[17:39:40.524]                         else {
[17:39:40.524]                           version <- NULL
[17:39:40.524]                         }
[17:39:40.524]                         if (!has_future || version < "1.8.0") {
[17:39:40.524]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.524]                             "", base::R.version$version.string), 
[17:39:40.524]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.524]                               "release", "version")], collapse = " "), 
[17:39:40.524]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.524]                             info)
[17:39:40.524]                           info <- base::paste(info, collapse = "; ")
[17:39:40.524]                           if (!has_future) {
[17:39:40.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.524]                               info)
[17:39:40.524]                           }
[17:39:40.524]                           else {
[17:39:40.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.524]                               info, version)
[17:39:40.524]                           }
[17:39:40.524]                           base::stop(msg)
[17:39:40.524]                         }
[17:39:40.524]                       })
[17:39:40.524]                     }
[17:39:40.524]                     base::local({
[17:39:40.524]                       for (pkg in "stats") {
[17:39:40.524]                         base::loadNamespace(pkg)
[17:39:40.524]                         base::library(pkg, character.only = TRUE)
[17:39:40.524]                       }
[17:39:40.524]                     })
[17:39:40.524]                   }
[17:39:40.524]                   ...future.strategy.old <- future::plan("list")
[17:39:40.524]                   options(future.plan = NULL)
[17:39:40.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.524]                 }
[17:39:40.524]                 ...future.workdir <- getwd()
[17:39:40.524]             }
[17:39:40.524]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.524]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.524]         }
[17:39:40.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.524]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.524]             base::names(...future.oldOptions))
[17:39:40.524]     }
[17:39:40.524]     if (FALSE) {
[17:39:40.524]     }
[17:39:40.524]     else {
[17:39:40.524]         if (TRUE) {
[17:39:40.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.524]                 open = "w")
[17:39:40.524]         }
[17:39:40.524]         else {
[17:39:40.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.524]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.524]         }
[17:39:40.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.524]             base::sink(type = "output", split = FALSE)
[17:39:40.524]             base::close(...future.stdout)
[17:39:40.524]         }, add = TRUE)
[17:39:40.524]     }
[17:39:40.524]     ...future.frame <- base::sys.nframe()
[17:39:40.524]     ...future.conditions <- base::list()
[17:39:40.524]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.524]     if (FALSE) {
[17:39:40.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.524]     }
[17:39:40.524]     ...future.result <- base::tryCatch({
[17:39:40.524]         base::withCallingHandlers({
[17:39:40.524]             ...future.value <- base::withVisible(base::local({
[17:39:40.524]                 lm(weight ~ group - 1)
[17:39:40.524]             }))
[17:39:40.524]             future::FutureResult(value = ...future.value$value, 
[17:39:40.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.524]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.524]                     ...future.globalenv.names))
[17:39:40.524]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.524]         }, condition = base::local({
[17:39:40.524]             c <- base::c
[17:39:40.524]             inherits <- base::inherits
[17:39:40.524]             invokeRestart <- base::invokeRestart
[17:39:40.524]             length <- base::length
[17:39:40.524]             list <- base::list
[17:39:40.524]             seq.int <- base::seq.int
[17:39:40.524]             signalCondition <- base::signalCondition
[17:39:40.524]             sys.calls <- base::sys.calls
[17:39:40.524]             `[[` <- base::`[[`
[17:39:40.524]             `+` <- base::`+`
[17:39:40.524]             `<<-` <- base::`<<-`
[17:39:40.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.524]                   3L)]
[17:39:40.524]             }
[17:39:40.524]             function(cond) {
[17:39:40.524]                 is_error <- inherits(cond, "error")
[17:39:40.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.524]                   NULL)
[17:39:40.524]                 if (is_error) {
[17:39:40.524]                   sessionInformation <- function() {
[17:39:40.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.524]                       search = base::search(), system = base::Sys.info())
[17:39:40.524]                   }
[17:39:40.524]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.524]                     cond$call), session = sessionInformation(), 
[17:39:40.524]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.524]                   signalCondition(cond)
[17:39:40.524]                 }
[17:39:40.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.524]                 "immediateCondition"))) {
[17:39:40.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.524]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.524]                   if (TRUE && !signal) {
[17:39:40.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.524]                     {
[17:39:40.524]                       inherits <- base::inherits
[17:39:40.524]                       invokeRestart <- base::invokeRestart
[17:39:40.524]                       is.null <- base::is.null
[17:39:40.524]                       muffled <- FALSE
[17:39:40.524]                       if (inherits(cond, "message")) {
[17:39:40.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.524]                         if (muffled) 
[17:39:40.524]                           invokeRestart("muffleMessage")
[17:39:40.524]                       }
[17:39:40.524]                       else if (inherits(cond, "warning")) {
[17:39:40.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.524]                         if (muffled) 
[17:39:40.524]                           invokeRestart("muffleWarning")
[17:39:40.524]                       }
[17:39:40.524]                       else if (inherits(cond, "condition")) {
[17:39:40.524]                         if (!is.null(pattern)) {
[17:39:40.524]                           computeRestarts <- base::computeRestarts
[17:39:40.524]                           grepl <- base::grepl
[17:39:40.524]                           restarts <- computeRestarts(cond)
[17:39:40.524]                           for (restart in restarts) {
[17:39:40.524]                             name <- restart$name
[17:39:40.524]                             if (is.null(name)) 
[17:39:40.524]                               next
[17:39:40.524]                             if (!grepl(pattern, name)) 
[17:39:40.524]                               next
[17:39:40.524]                             invokeRestart(restart)
[17:39:40.524]                             muffled <- TRUE
[17:39:40.524]                             break
[17:39:40.524]                           }
[17:39:40.524]                         }
[17:39:40.524]                       }
[17:39:40.524]                       invisible(muffled)
[17:39:40.524]                     }
[17:39:40.524]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.524]                   }
[17:39:40.524]                 }
[17:39:40.524]                 else {
[17:39:40.524]                   if (TRUE) {
[17:39:40.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.524]                     {
[17:39:40.524]                       inherits <- base::inherits
[17:39:40.524]                       invokeRestart <- base::invokeRestart
[17:39:40.524]                       is.null <- base::is.null
[17:39:40.524]                       muffled <- FALSE
[17:39:40.524]                       if (inherits(cond, "message")) {
[17:39:40.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.524]                         if (muffled) 
[17:39:40.524]                           invokeRestart("muffleMessage")
[17:39:40.524]                       }
[17:39:40.524]                       else if (inherits(cond, "warning")) {
[17:39:40.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.524]                         if (muffled) 
[17:39:40.524]                           invokeRestart("muffleWarning")
[17:39:40.524]                       }
[17:39:40.524]                       else if (inherits(cond, "condition")) {
[17:39:40.524]                         if (!is.null(pattern)) {
[17:39:40.524]                           computeRestarts <- base::computeRestarts
[17:39:40.524]                           grepl <- base::grepl
[17:39:40.524]                           restarts <- computeRestarts(cond)
[17:39:40.524]                           for (restart in restarts) {
[17:39:40.524]                             name <- restart$name
[17:39:40.524]                             if (is.null(name)) 
[17:39:40.524]                               next
[17:39:40.524]                             if (!grepl(pattern, name)) 
[17:39:40.524]                               next
[17:39:40.524]                             invokeRestart(restart)
[17:39:40.524]                             muffled <- TRUE
[17:39:40.524]                             break
[17:39:40.524]                           }
[17:39:40.524]                         }
[17:39:40.524]                       }
[17:39:40.524]                       invisible(muffled)
[17:39:40.524]                     }
[17:39:40.524]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.524]                   }
[17:39:40.524]                 }
[17:39:40.524]             }
[17:39:40.524]         }))
[17:39:40.524]     }, error = function(ex) {
[17:39:40.524]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.524]                 ...future.rng), started = ...future.startTime, 
[17:39:40.524]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.524]             version = "1.8"), class = "FutureResult")
[17:39:40.524]     }, finally = {
[17:39:40.524]         if (!identical(...future.workdir, getwd())) 
[17:39:40.524]             setwd(...future.workdir)
[17:39:40.524]         {
[17:39:40.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.524]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.524]             }
[17:39:40.524]             base::options(...future.oldOptions)
[17:39:40.524]             if (.Platform$OS.type == "windows") {
[17:39:40.524]                 old_names <- names(...future.oldEnvVars)
[17:39:40.524]                 envs <- base::Sys.getenv()
[17:39:40.524]                 names <- names(envs)
[17:39:40.524]                 common <- intersect(names, old_names)
[17:39:40.524]                 added <- setdiff(names, old_names)
[17:39:40.524]                 removed <- setdiff(old_names, names)
[17:39:40.524]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.524]                   envs[common]]
[17:39:40.524]                 NAMES <- toupper(changed)
[17:39:40.524]                 args <- list()
[17:39:40.524]                 for (kk in seq_along(NAMES)) {
[17:39:40.524]                   name <- changed[[kk]]
[17:39:40.524]                   NAME <- NAMES[[kk]]
[17:39:40.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.524]                     next
[17:39:40.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.524]                 }
[17:39:40.524]                 NAMES <- toupper(added)
[17:39:40.524]                 for (kk in seq_along(NAMES)) {
[17:39:40.524]                   name <- added[[kk]]
[17:39:40.524]                   NAME <- NAMES[[kk]]
[17:39:40.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.524]                     next
[17:39:40.524]                   args[[name]] <- ""
[17:39:40.524]                 }
[17:39:40.524]                 NAMES <- toupper(removed)
[17:39:40.524]                 for (kk in seq_along(NAMES)) {
[17:39:40.524]                   name <- removed[[kk]]
[17:39:40.524]                   NAME <- NAMES[[kk]]
[17:39:40.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.524]                     next
[17:39:40.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.524]                 }
[17:39:40.524]                 if (length(args) > 0) 
[17:39:40.524]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.524]             }
[17:39:40.524]             else {
[17:39:40.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.524]             }
[17:39:40.524]             {
[17:39:40.524]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.524]                   0L) {
[17:39:40.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.524]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.524]                   base::options(opts)
[17:39:40.524]                 }
[17:39:40.524]                 {
[17:39:40.524]                   {
[17:39:40.524]                     NULL
[17:39:40.524]                     RNGkind("Mersenne-Twister")
[17:39:40.524]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.524]                       inherits = FALSE)
[17:39:40.524]                   }
[17:39:40.524]                   options(future.plan = NULL)
[17:39:40.524]                   if (is.na(NA_character_)) 
[17:39:40.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.524]                     .init = FALSE)
[17:39:40.524]                 }
[17:39:40.524]             }
[17:39:40.524]         }
[17:39:40.524]     })
[17:39:40.524]     if (TRUE) {
[17:39:40.524]         base::sink(type = "output", split = FALSE)
[17:39:40.524]         if (TRUE) {
[17:39:40.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.524]         }
[17:39:40.524]         else {
[17:39:40.524]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.524]         }
[17:39:40.524]         base::close(...future.stdout)
[17:39:40.524]         ...future.stdout <- NULL
[17:39:40.524]     }
[17:39:40.524]     ...future.result$conditions <- ...future.conditions
[17:39:40.524]     ...future.result$finished <- base::Sys.time()
[17:39:40.524]     ...future.result
[17:39:40.524] }
[17:39:40.525] assign_globals() ...
[17:39:40.525] List of 2
[17:39:40.525]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.525]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.525]  - attr(*, "where")=List of 2
[17:39:40.525]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.525]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.525]  - attr(*, "resolved")= logi FALSE
[17:39:40.525]  - attr(*, "total_size")= num 896
[17:39:40.525]  - attr(*, "already-done")= logi TRUE
[17:39:40.528] - copied ‘weight’ to environment
[17:39:40.529] - copied ‘group’ to environment
[17:39:40.529] assign_globals() ... done
[17:39:40.529] plan(): Setting new future strategy stack:
[17:39:40.529] List of future strategies:
[17:39:40.529] 1. sequential:
[17:39:40.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.529]    - tweaked: FALSE
[17:39:40.529]    - call: NULL
[17:39:40.530] plan(): nbrOfWorkers() = 1
[17:39:40.531] plan(): Setting new future strategy stack:
[17:39:40.531] List of future strategies:
[17:39:40.531] 1. sequential:
[17:39:40.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.531]    - tweaked: FALSE
[17:39:40.531]    - call: plan(strategy)
[17:39:40.532] plan(): nbrOfWorkers() = 1
[17:39:40.532] SequentialFuture started (and completed)
[17:39:40.532] - Launch lazy future ... done
[17:39:40.532] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:39:40.534] getGlobalsAndPackages() ...
[17:39:40.534] Searching for globals...
[17:39:40.535] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:39:40.535] Searching for globals ... DONE
[17:39:40.535] Resolving globals: FALSE
[17:39:40.535] The total size of the 1 globals is 96 bytes (96 bytes)
[17:39:40.536] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:39:40.536] - globals: [1] ‘x’
[17:39:40.536] - packages: [1] ‘stats’
[17:39:40.536] getGlobalsAndPackages() ... DONE
[17:39:40.536] run() for ‘Future’ ...
[17:39:40.536] - state: ‘created’
[17:39:40.536] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.537] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.537]   - Field: ‘label’
[17:39:40.537]   - Field: ‘local’
[17:39:40.537]   - Field: ‘owner’
[17:39:40.537]   - Field: ‘envir’
[17:39:40.537]   - Field: ‘packages’
[17:39:40.537]   - Field: ‘gc’
[17:39:40.537]   - Field: ‘conditions’
[17:39:40.538]   - Field: ‘expr’
[17:39:40.538]   - Field: ‘uuid’
[17:39:40.538]   - Field: ‘seed’
[17:39:40.538]   - Field: ‘version’
[17:39:40.538]   - Field: ‘result’
[17:39:40.538]   - Field: ‘asynchronous’
[17:39:40.538]   - Field: ‘calls’
[17:39:40.538]   - Field: ‘globals’
[17:39:40.538]   - Field: ‘stdout’
[17:39:40.538]   - Field: ‘earlySignal’
[17:39:40.538]   - Field: ‘lazy’
[17:39:40.539]   - Field: ‘state’
[17:39:40.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.539] - Launch lazy future ...
[17:39:40.539] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.539] Packages needed by future strategies (n = 0): <none>
[17:39:40.539] {
[17:39:40.539]     {
[17:39:40.539]         {
[17:39:40.539]             ...future.startTime <- base::Sys.time()
[17:39:40.539]             {
[17:39:40.539]                 {
[17:39:40.539]                   {
[17:39:40.539]                     {
[17:39:40.539]                       base::local({
[17:39:40.539]                         has_future <- base::requireNamespace("future", 
[17:39:40.539]                           quietly = TRUE)
[17:39:40.539]                         if (has_future) {
[17:39:40.539]                           ns <- base::getNamespace("future")
[17:39:40.539]                           version <- ns[[".package"]][["version"]]
[17:39:40.539]                           if (is.null(version)) 
[17:39:40.539]                             version <- utils::packageVersion("future")
[17:39:40.539]                         }
[17:39:40.539]                         else {
[17:39:40.539]                           version <- NULL
[17:39:40.539]                         }
[17:39:40.539]                         if (!has_future || version < "1.8.0") {
[17:39:40.539]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.539]                             "", base::R.version$version.string), 
[17:39:40.539]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.539]                               "release", "version")], collapse = " "), 
[17:39:40.539]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.539]                             info)
[17:39:40.539]                           info <- base::paste(info, collapse = "; ")
[17:39:40.539]                           if (!has_future) {
[17:39:40.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.539]                               info)
[17:39:40.539]                           }
[17:39:40.539]                           else {
[17:39:40.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.539]                               info, version)
[17:39:40.539]                           }
[17:39:40.539]                           base::stop(msg)
[17:39:40.539]                         }
[17:39:40.539]                       })
[17:39:40.539]                     }
[17:39:40.539]                     base::local({
[17:39:40.539]                       for (pkg in "stats") {
[17:39:40.539]                         base::loadNamespace(pkg)
[17:39:40.539]                         base::library(pkg, character.only = TRUE)
[17:39:40.539]                       }
[17:39:40.539]                     })
[17:39:40.539]                   }
[17:39:40.539]                   ...future.strategy.old <- future::plan("list")
[17:39:40.539]                   options(future.plan = NULL)
[17:39:40.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.539]                 }
[17:39:40.539]                 ...future.workdir <- getwd()
[17:39:40.539]             }
[17:39:40.539]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.539]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.539]         }
[17:39:40.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.539]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.539]             base::names(...future.oldOptions))
[17:39:40.539]     }
[17:39:40.539]     if (FALSE) {
[17:39:40.539]     }
[17:39:40.539]     else {
[17:39:40.539]         if (TRUE) {
[17:39:40.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.539]                 open = "w")
[17:39:40.539]         }
[17:39:40.539]         else {
[17:39:40.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.539]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.539]         }
[17:39:40.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.539]             base::sink(type = "output", split = FALSE)
[17:39:40.539]             base::close(...future.stdout)
[17:39:40.539]         }, add = TRUE)
[17:39:40.539]     }
[17:39:40.539]     ...future.frame <- base::sys.nframe()
[17:39:40.539]     ...future.conditions <- base::list()
[17:39:40.539]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.539]     if (FALSE) {
[17:39:40.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.539]     }
[17:39:40.539]     ...future.result <- base::tryCatch({
[17:39:40.539]         base::withCallingHandlers({
[17:39:40.539]             ...future.value <- base::withVisible(base::local({
[17:39:40.539]                 xtabs(~x)
[17:39:40.539]             }))
[17:39:40.539]             future::FutureResult(value = ...future.value$value, 
[17:39:40.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.539]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.539]                     ...future.globalenv.names))
[17:39:40.539]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.539]         }, condition = base::local({
[17:39:40.539]             c <- base::c
[17:39:40.539]             inherits <- base::inherits
[17:39:40.539]             invokeRestart <- base::invokeRestart
[17:39:40.539]             length <- base::length
[17:39:40.539]             list <- base::list
[17:39:40.539]             seq.int <- base::seq.int
[17:39:40.539]             signalCondition <- base::signalCondition
[17:39:40.539]             sys.calls <- base::sys.calls
[17:39:40.539]             `[[` <- base::`[[`
[17:39:40.539]             `+` <- base::`+`
[17:39:40.539]             `<<-` <- base::`<<-`
[17:39:40.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.539]                   3L)]
[17:39:40.539]             }
[17:39:40.539]             function(cond) {
[17:39:40.539]                 is_error <- inherits(cond, "error")
[17:39:40.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.539]                   NULL)
[17:39:40.539]                 if (is_error) {
[17:39:40.539]                   sessionInformation <- function() {
[17:39:40.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.539]                       search = base::search(), system = base::Sys.info())
[17:39:40.539]                   }
[17:39:40.539]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.539]                     cond$call), session = sessionInformation(), 
[17:39:40.539]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.539]                   signalCondition(cond)
[17:39:40.539]                 }
[17:39:40.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.539]                 "immediateCondition"))) {
[17:39:40.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.539]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.539]                   if (TRUE && !signal) {
[17:39:40.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.539]                     {
[17:39:40.539]                       inherits <- base::inherits
[17:39:40.539]                       invokeRestart <- base::invokeRestart
[17:39:40.539]                       is.null <- base::is.null
[17:39:40.539]                       muffled <- FALSE
[17:39:40.539]                       if (inherits(cond, "message")) {
[17:39:40.539]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.539]                         if (muffled) 
[17:39:40.539]                           invokeRestart("muffleMessage")
[17:39:40.539]                       }
[17:39:40.539]                       else if (inherits(cond, "warning")) {
[17:39:40.539]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.539]                         if (muffled) 
[17:39:40.539]                           invokeRestart("muffleWarning")
[17:39:40.539]                       }
[17:39:40.539]                       else if (inherits(cond, "condition")) {
[17:39:40.539]                         if (!is.null(pattern)) {
[17:39:40.539]                           computeRestarts <- base::computeRestarts
[17:39:40.539]                           grepl <- base::grepl
[17:39:40.539]                           restarts <- computeRestarts(cond)
[17:39:40.539]                           for (restart in restarts) {
[17:39:40.539]                             name <- restart$name
[17:39:40.539]                             if (is.null(name)) 
[17:39:40.539]                               next
[17:39:40.539]                             if (!grepl(pattern, name)) 
[17:39:40.539]                               next
[17:39:40.539]                             invokeRestart(restart)
[17:39:40.539]                             muffled <- TRUE
[17:39:40.539]                             break
[17:39:40.539]                           }
[17:39:40.539]                         }
[17:39:40.539]                       }
[17:39:40.539]                       invisible(muffled)
[17:39:40.539]                     }
[17:39:40.539]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.539]                   }
[17:39:40.539]                 }
[17:39:40.539]                 else {
[17:39:40.539]                   if (TRUE) {
[17:39:40.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.539]                     {
[17:39:40.539]                       inherits <- base::inherits
[17:39:40.539]                       invokeRestart <- base::invokeRestart
[17:39:40.539]                       is.null <- base::is.null
[17:39:40.539]                       muffled <- FALSE
[17:39:40.539]                       if (inherits(cond, "message")) {
[17:39:40.539]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.539]                         if (muffled) 
[17:39:40.539]                           invokeRestart("muffleMessage")
[17:39:40.539]                       }
[17:39:40.539]                       else if (inherits(cond, "warning")) {
[17:39:40.539]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.539]                         if (muffled) 
[17:39:40.539]                           invokeRestart("muffleWarning")
[17:39:40.539]                       }
[17:39:40.539]                       else if (inherits(cond, "condition")) {
[17:39:40.539]                         if (!is.null(pattern)) {
[17:39:40.539]                           computeRestarts <- base::computeRestarts
[17:39:40.539]                           grepl <- base::grepl
[17:39:40.539]                           restarts <- computeRestarts(cond)
[17:39:40.539]                           for (restart in restarts) {
[17:39:40.539]                             name <- restart$name
[17:39:40.539]                             if (is.null(name)) 
[17:39:40.539]                               next
[17:39:40.539]                             if (!grepl(pattern, name)) 
[17:39:40.539]                               next
[17:39:40.539]                             invokeRestart(restart)
[17:39:40.539]                             muffled <- TRUE
[17:39:40.539]                             break
[17:39:40.539]                           }
[17:39:40.539]                         }
[17:39:40.539]                       }
[17:39:40.539]                       invisible(muffled)
[17:39:40.539]                     }
[17:39:40.539]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.539]                   }
[17:39:40.539]                 }
[17:39:40.539]             }
[17:39:40.539]         }))
[17:39:40.539]     }, error = function(ex) {
[17:39:40.539]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.539]                 ...future.rng), started = ...future.startTime, 
[17:39:40.539]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.539]             version = "1.8"), class = "FutureResult")
[17:39:40.539]     }, finally = {
[17:39:40.539]         if (!identical(...future.workdir, getwd())) 
[17:39:40.539]             setwd(...future.workdir)
[17:39:40.539]         {
[17:39:40.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.539]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.539]             }
[17:39:40.539]             base::options(...future.oldOptions)
[17:39:40.539]             if (.Platform$OS.type == "windows") {
[17:39:40.539]                 old_names <- names(...future.oldEnvVars)
[17:39:40.539]                 envs <- base::Sys.getenv()
[17:39:40.539]                 names <- names(envs)
[17:39:40.539]                 common <- intersect(names, old_names)
[17:39:40.539]                 added <- setdiff(names, old_names)
[17:39:40.539]                 removed <- setdiff(old_names, names)
[17:39:40.539]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.539]                   envs[common]]
[17:39:40.539]                 NAMES <- toupper(changed)
[17:39:40.539]                 args <- list()
[17:39:40.539]                 for (kk in seq_along(NAMES)) {
[17:39:40.539]                   name <- changed[[kk]]
[17:39:40.539]                   NAME <- NAMES[[kk]]
[17:39:40.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.539]                     next
[17:39:40.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.539]                 }
[17:39:40.539]                 NAMES <- toupper(added)
[17:39:40.539]                 for (kk in seq_along(NAMES)) {
[17:39:40.539]                   name <- added[[kk]]
[17:39:40.539]                   NAME <- NAMES[[kk]]
[17:39:40.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.539]                     next
[17:39:40.539]                   args[[name]] <- ""
[17:39:40.539]                 }
[17:39:40.539]                 NAMES <- toupper(removed)
[17:39:40.539]                 for (kk in seq_along(NAMES)) {
[17:39:40.539]                   name <- removed[[kk]]
[17:39:40.539]                   NAME <- NAMES[[kk]]
[17:39:40.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.539]                     next
[17:39:40.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.539]                 }
[17:39:40.539]                 if (length(args) > 0) 
[17:39:40.539]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.539]             }
[17:39:40.539]             else {
[17:39:40.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.539]             }
[17:39:40.539]             {
[17:39:40.539]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.539]                   0L) {
[17:39:40.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.539]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.539]                   base::options(opts)
[17:39:40.539]                 }
[17:39:40.539]                 {
[17:39:40.539]                   {
[17:39:40.539]                     NULL
[17:39:40.539]                     RNGkind("Mersenne-Twister")
[17:39:40.539]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.539]                       inherits = FALSE)
[17:39:40.539]                   }
[17:39:40.539]                   options(future.plan = NULL)
[17:39:40.539]                   if (is.na(NA_character_)) 
[17:39:40.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.539]                     .init = FALSE)
[17:39:40.539]                 }
[17:39:40.539]             }
[17:39:40.539]         }
[17:39:40.539]     })
[17:39:40.539]     if (TRUE) {
[17:39:40.539]         base::sink(type = "output", split = FALSE)
[17:39:40.539]         if (TRUE) {
[17:39:40.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.539]         }
[17:39:40.539]         else {
[17:39:40.539]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.539]         }
[17:39:40.539]         base::close(...future.stdout)
[17:39:40.539]         ...future.stdout <- NULL
[17:39:40.539]     }
[17:39:40.539]     ...future.result$conditions <- ...future.conditions
[17:39:40.539]     ...future.result$finished <- base::Sys.time()
[17:39:40.539]     ...future.result
[17:39:40.539] }
[17:39:40.541] assign_globals() ...
[17:39:40.541] List of 1
[17:39:40.541]  $ x: num [1:5] 1 1 2 2 2
[17:39:40.541]  - attr(*, "where")=List of 1
[17:39:40.541]   ..$ x:<environment: R_EmptyEnv> 
[17:39:40.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.541]  - attr(*, "resolved")= logi FALSE
[17:39:40.541]  - attr(*, "total_size")= num 96
[17:39:40.541]  - attr(*, "already-done")= logi TRUE
[17:39:40.544] - copied ‘x’ to environment
[17:39:40.544] assign_globals() ... done
[17:39:40.544] plan(): Setting new future strategy stack:
[17:39:40.544] List of future strategies:
[17:39:40.544] 1. sequential:
[17:39:40.544]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.544]    - tweaked: FALSE
[17:39:40.544]    - call: NULL
[17:39:40.545] plan(): nbrOfWorkers() = 1
[17:39:40.546] plan(): Setting new future strategy stack:
[17:39:40.546] List of future strategies:
[17:39:40.546] 1. sequential:
[17:39:40.546]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.546]    - tweaked: FALSE
[17:39:40.546]    - call: plan(strategy)
[17:39:40.546] plan(): nbrOfWorkers() = 1
[17:39:40.546] SequentialFuture started (and completed)
[17:39:40.547] - Launch lazy future ... done
[17:39:40.547] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[17:39:40.547] getGlobalsAndPackages() ...
[17:39:40.548] Searching for globals...
[17:39:40.549] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:39:40.549] Searching for globals ... DONE
[17:39:40.549] Resolving globals: FALSE
[17:39:40.549] The total size of the 1 globals is 96 bytes (96 bytes)
[17:39:40.550] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:39:40.551] - globals: [1] ‘x’
[17:39:40.552] - packages: [1] ‘stats’
[17:39:40.552] getGlobalsAndPackages() ... DONE
[17:39:40.552] run() for ‘Future’ ...
[17:39:40.552] - state: ‘created’
[17:39:40.552] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.553] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.553]   - Field: ‘label’
[17:39:40.553]   - Field: ‘local’
[17:39:40.553]   - Field: ‘owner’
[17:39:40.553]   - Field: ‘envir’
[17:39:40.553]   - Field: ‘packages’
[17:39:40.553]   - Field: ‘gc’
[17:39:40.553]   - Field: ‘conditions’
[17:39:40.553]   - Field: ‘expr’
[17:39:40.553]   - Field: ‘uuid’
[17:39:40.554]   - Field: ‘seed’
[17:39:40.554]   - Field: ‘version’
[17:39:40.554]   - Field: ‘result’
[17:39:40.554]   - Field: ‘asynchronous’
[17:39:40.554]   - Field: ‘calls’
[17:39:40.554]   - Field: ‘globals’
[17:39:40.554]   - Field: ‘stdout’
[17:39:40.554]   - Field: ‘earlySignal’
[17:39:40.554]   - Field: ‘lazy’
[17:39:40.554]   - Field: ‘state’
[17:39:40.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.555] - Launch lazy future ...
[17:39:40.555] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.555] Packages needed by future strategies (n = 0): <none>
[17:39:40.555] {
[17:39:40.555]     {
[17:39:40.555]         {
[17:39:40.555]             ...future.startTime <- base::Sys.time()
[17:39:40.555]             {
[17:39:40.555]                 {
[17:39:40.555]                   {
[17:39:40.555]                     {
[17:39:40.555]                       base::local({
[17:39:40.555]                         has_future <- base::requireNamespace("future", 
[17:39:40.555]                           quietly = TRUE)
[17:39:40.555]                         if (has_future) {
[17:39:40.555]                           ns <- base::getNamespace("future")
[17:39:40.555]                           version <- ns[[".package"]][["version"]]
[17:39:40.555]                           if (is.null(version)) 
[17:39:40.555]                             version <- utils::packageVersion("future")
[17:39:40.555]                         }
[17:39:40.555]                         else {
[17:39:40.555]                           version <- NULL
[17:39:40.555]                         }
[17:39:40.555]                         if (!has_future || version < "1.8.0") {
[17:39:40.555]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.555]                             "", base::R.version$version.string), 
[17:39:40.555]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.555]                               "release", "version")], collapse = " "), 
[17:39:40.555]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.555]                             info)
[17:39:40.555]                           info <- base::paste(info, collapse = "; ")
[17:39:40.555]                           if (!has_future) {
[17:39:40.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.555]                               info)
[17:39:40.555]                           }
[17:39:40.555]                           else {
[17:39:40.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.555]                               info, version)
[17:39:40.555]                           }
[17:39:40.555]                           base::stop(msg)
[17:39:40.555]                         }
[17:39:40.555]                       })
[17:39:40.555]                     }
[17:39:40.555]                     base::local({
[17:39:40.555]                       for (pkg in "stats") {
[17:39:40.555]                         base::loadNamespace(pkg)
[17:39:40.555]                         base::library(pkg, character.only = TRUE)
[17:39:40.555]                       }
[17:39:40.555]                     })
[17:39:40.555]                   }
[17:39:40.555]                   ...future.strategy.old <- future::plan("list")
[17:39:40.555]                   options(future.plan = NULL)
[17:39:40.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.555]                 }
[17:39:40.555]                 ...future.workdir <- getwd()
[17:39:40.555]             }
[17:39:40.555]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.555]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.555]         }
[17:39:40.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.555]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.555]             base::names(...future.oldOptions))
[17:39:40.555]     }
[17:39:40.555]     if (FALSE) {
[17:39:40.555]     }
[17:39:40.555]     else {
[17:39:40.555]         if (TRUE) {
[17:39:40.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.555]                 open = "w")
[17:39:40.555]         }
[17:39:40.555]         else {
[17:39:40.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.555]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.555]         }
[17:39:40.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.555]             base::sink(type = "output", split = FALSE)
[17:39:40.555]             base::close(...future.stdout)
[17:39:40.555]         }, add = TRUE)
[17:39:40.555]     }
[17:39:40.555]     ...future.frame <- base::sys.nframe()
[17:39:40.555]     ...future.conditions <- base::list()
[17:39:40.555]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.555]     if (FALSE) {
[17:39:40.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.555]     }
[17:39:40.555]     ...future.result <- base::tryCatch({
[17:39:40.555]         base::withCallingHandlers({
[17:39:40.555]             ...future.value <- base::withVisible(base::local({
[17:39:40.555]                 xtabs(~x)
[17:39:40.555]             }))
[17:39:40.555]             future::FutureResult(value = ...future.value$value, 
[17:39:40.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.555]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.555]                     ...future.globalenv.names))
[17:39:40.555]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.555]         }, condition = base::local({
[17:39:40.555]             c <- base::c
[17:39:40.555]             inherits <- base::inherits
[17:39:40.555]             invokeRestart <- base::invokeRestart
[17:39:40.555]             length <- base::length
[17:39:40.555]             list <- base::list
[17:39:40.555]             seq.int <- base::seq.int
[17:39:40.555]             signalCondition <- base::signalCondition
[17:39:40.555]             sys.calls <- base::sys.calls
[17:39:40.555]             `[[` <- base::`[[`
[17:39:40.555]             `+` <- base::`+`
[17:39:40.555]             `<<-` <- base::`<<-`
[17:39:40.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.555]                   3L)]
[17:39:40.555]             }
[17:39:40.555]             function(cond) {
[17:39:40.555]                 is_error <- inherits(cond, "error")
[17:39:40.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.555]                   NULL)
[17:39:40.555]                 if (is_error) {
[17:39:40.555]                   sessionInformation <- function() {
[17:39:40.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.555]                       search = base::search(), system = base::Sys.info())
[17:39:40.555]                   }
[17:39:40.555]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.555]                     cond$call), session = sessionInformation(), 
[17:39:40.555]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.555]                   signalCondition(cond)
[17:39:40.555]                 }
[17:39:40.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.555]                 "immediateCondition"))) {
[17:39:40.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.555]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.555]                   if (TRUE && !signal) {
[17:39:40.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.555]                     {
[17:39:40.555]                       inherits <- base::inherits
[17:39:40.555]                       invokeRestart <- base::invokeRestart
[17:39:40.555]                       is.null <- base::is.null
[17:39:40.555]                       muffled <- FALSE
[17:39:40.555]                       if (inherits(cond, "message")) {
[17:39:40.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.555]                         if (muffled) 
[17:39:40.555]                           invokeRestart("muffleMessage")
[17:39:40.555]                       }
[17:39:40.555]                       else if (inherits(cond, "warning")) {
[17:39:40.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.555]                         if (muffled) 
[17:39:40.555]                           invokeRestart("muffleWarning")
[17:39:40.555]                       }
[17:39:40.555]                       else if (inherits(cond, "condition")) {
[17:39:40.555]                         if (!is.null(pattern)) {
[17:39:40.555]                           computeRestarts <- base::computeRestarts
[17:39:40.555]                           grepl <- base::grepl
[17:39:40.555]                           restarts <- computeRestarts(cond)
[17:39:40.555]                           for (restart in restarts) {
[17:39:40.555]                             name <- restart$name
[17:39:40.555]                             if (is.null(name)) 
[17:39:40.555]                               next
[17:39:40.555]                             if (!grepl(pattern, name)) 
[17:39:40.555]                               next
[17:39:40.555]                             invokeRestart(restart)
[17:39:40.555]                             muffled <- TRUE
[17:39:40.555]                             break
[17:39:40.555]                           }
[17:39:40.555]                         }
[17:39:40.555]                       }
[17:39:40.555]                       invisible(muffled)
[17:39:40.555]                     }
[17:39:40.555]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.555]                   }
[17:39:40.555]                 }
[17:39:40.555]                 else {
[17:39:40.555]                   if (TRUE) {
[17:39:40.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.555]                     {
[17:39:40.555]                       inherits <- base::inherits
[17:39:40.555]                       invokeRestart <- base::invokeRestart
[17:39:40.555]                       is.null <- base::is.null
[17:39:40.555]                       muffled <- FALSE
[17:39:40.555]                       if (inherits(cond, "message")) {
[17:39:40.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.555]                         if (muffled) 
[17:39:40.555]                           invokeRestart("muffleMessage")
[17:39:40.555]                       }
[17:39:40.555]                       else if (inherits(cond, "warning")) {
[17:39:40.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.555]                         if (muffled) 
[17:39:40.555]                           invokeRestart("muffleWarning")
[17:39:40.555]                       }
[17:39:40.555]                       else if (inherits(cond, "condition")) {
[17:39:40.555]                         if (!is.null(pattern)) {
[17:39:40.555]                           computeRestarts <- base::computeRestarts
[17:39:40.555]                           grepl <- base::grepl
[17:39:40.555]                           restarts <- computeRestarts(cond)
[17:39:40.555]                           for (restart in restarts) {
[17:39:40.555]                             name <- restart$name
[17:39:40.555]                             if (is.null(name)) 
[17:39:40.555]                               next
[17:39:40.555]                             if (!grepl(pattern, name)) 
[17:39:40.555]                               next
[17:39:40.555]                             invokeRestart(restart)
[17:39:40.555]                             muffled <- TRUE
[17:39:40.555]                             break
[17:39:40.555]                           }
[17:39:40.555]                         }
[17:39:40.555]                       }
[17:39:40.555]                       invisible(muffled)
[17:39:40.555]                     }
[17:39:40.555]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.555]                   }
[17:39:40.555]                 }
[17:39:40.555]             }
[17:39:40.555]         }))
[17:39:40.555]     }, error = function(ex) {
[17:39:40.555]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.555]                 ...future.rng), started = ...future.startTime, 
[17:39:40.555]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.555]             version = "1.8"), class = "FutureResult")
[17:39:40.555]     }, finally = {
[17:39:40.555]         if (!identical(...future.workdir, getwd())) 
[17:39:40.555]             setwd(...future.workdir)
[17:39:40.555]         {
[17:39:40.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.555]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.555]             }
[17:39:40.555]             base::options(...future.oldOptions)
[17:39:40.555]             if (.Platform$OS.type == "windows") {
[17:39:40.555]                 old_names <- names(...future.oldEnvVars)
[17:39:40.555]                 envs <- base::Sys.getenv()
[17:39:40.555]                 names <- names(envs)
[17:39:40.555]                 common <- intersect(names, old_names)
[17:39:40.555]                 added <- setdiff(names, old_names)
[17:39:40.555]                 removed <- setdiff(old_names, names)
[17:39:40.555]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.555]                   envs[common]]
[17:39:40.555]                 NAMES <- toupper(changed)
[17:39:40.555]                 args <- list()
[17:39:40.555]                 for (kk in seq_along(NAMES)) {
[17:39:40.555]                   name <- changed[[kk]]
[17:39:40.555]                   NAME <- NAMES[[kk]]
[17:39:40.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.555]                     next
[17:39:40.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.555]                 }
[17:39:40.555]                 NAMES <- toupper(added)
[17:39:40.555]                 for (kk in seq_along(NAMES)) {
[17:39:40.555]                   name <- added[[kk]]
[17:39:40.555]                   NAME <- NAMES[[kk]]
[17:39:40.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.555]                     next
[17:39:40.555]                   args[[name]] <- ""
[17:39:40.555]                 }
[17:39:40.555]                 NAMES <- toupper(removed)
[17:39:40.555]                 for (kk in seq_along(NAMES)) {
[17:39:40.555]                   name <- removed[[kk]]
[17:39:40.555]                   NAME <- NAMES[[kk]]
[17:39:40.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.555]                     next
[17:39:40.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.555]                 }
[17:39:40.555]                 if (length(args) > 0) 
[17:39:40.555]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.555]             }
[17:39:40.555]             else {
[17:39:40.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.555]             }
[17:39:40.555]             {
[17:39:40.555]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.555]                   0L) {
[17:39:40.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.555]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.555]                   base::options(opts)
[17:39:40.555]                 }
[17:39:40.555]                 {
[17:39:40.555]                   {
[17:39:40.555]                     NULL
[17:39:40.555]                     RNGkind("Mersenne-Twister")
[17:39:40.555]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.555]                       inherits = FALSE)
[17:39:40.555]                   }
[17:39:40.555]                   options(future.plan = NULL)
[17:39:40.555]                   if (is.na(NA_character_)) 
[17:39:40.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.555]                     .init = FALSE)
[17:39:40.555]                 }
[17:39:40.555]             }
[17:39:40.555]         }
[17:39:40.555]     })
[17:39:40.555]     if (TRUE) {
[17:39:40.555]         base::sink(type = "output", split = FALSE)
[17:39:40.555]         if (TRUE) {
[17:39:40.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.555]         }
[17:39:40.555]         else {
[17:39:40.555]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.555]         }
[17:39:40.555]         base::close(...future.stdout)
[17:39:40.555]         ...future.stdout <- NULL
[17:39:40.555]     }
[17:39:40.555]     ...future.result$conditions <- ...future.conditions
[17:39:40.555]     ...future.result$finished <- base::Sys.time()
[17:39:40.555]     ...future.result
[17:39:40.555] }
[17:39:40.557] assign_globals() ...
[17:39:40.557] List of 1
[17:39:40.557]  $ x: num [1:5] 1 1 2 2 2
[17:39:40.557]  - attr(*, "where")=List of 1
[17:39:40.557]   ..$ x:<environment: R_EmptyEnv> 
[17:39:40.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.557]  - attr(*, "resolved")= logi FALSE
[17:39:40.557]  - attr(*, "total_size")= num 96
[17:39:40.557]  - attr(*, "already-done")= logi TRUE
[17:39:40.559] - copied ‘x’ to environment
[17:39:40.559] assign_globals() ... done
[17:39:40.560] plan(): Setting new future strategy stack:
[17:39:40.560] List of future strategies:
[17:39:40.560] 1. sequential:
[17:39:40.560]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.560]    - tweaked: FALSE
[17:39:40.560]    - call: NULL
[17:39:40.560] plan(): nbrOfWorkers() = 1
[17:39:40.561] plan(): Setting new future strategy stack:
[17:39:40.561] List of future strategies:
[17:39:40.561] 1. sequential:
[17:39:40.561]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.561]    - tweaked: FALSE
[17:39:40.561]    - call: plan(strategy)
[17:39:40.562] plan(): nbrOfWorkers() = 1
[17:39:40.562] SequentialFuture started (and completed)
[17:39:40.562] - Launch lazy future ... done
[17:39:40.562] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:39:40.564] getGlobalsAndPackages() ...
[17:39:40.564] Searching for globals...
[17:39:40.566] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:39:40.566] Searching for globals ... DONE
[17:39:40.566] Resolving globals: FALSE
[17:39:40.566] 
[17:39:40.566] - packages: [2] ‘stats’, ‘datasets’
[17:39:40.567] getGlobalsAndPackages() ... DONE
[17:39:40.567] run() for ‘Future’ ...
[17:39:40.567] - state: ‘created’
[17:39:40.567] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.567] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.568]   - Field: ‘label’
[17:39:40.568]   - Field: ‘local’
[17:39:40.568]   - Field: ‘owner’
[17:39:40.568]   - Field: ‘envir’
[17:39:40.568]   - Field: ‘packages’
[17:39:40.568]   - Field: ‘gc’
[17:39:40.568]   - Field: ‘conditions’
[17:39:40.568]   - Field: ‘expr’
[17:39:40.568]   - Field: ‘uuid’
[17:39:40.568]   - Field: ‘seed’
[17:39:40.568]   - Field: ‘version’
[17:39:40.569]   - Field: ‘result’
[17:39:40.569]   - Field: ‘asynchronous’
[17:39:40.569]   - Field: ‘calls’
[17:39:40.569]   - Field: ‘globals’
[17:39:40.569]   - Field: ‘stdout’
[17:39:40.569]   - Field: ‘earlySignal’
[17:39:40.569]   - Field: ‘lazy’
[17:39:40.569]   - Field: ‘state’
[17:39:40.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.569] - Launch lazy future ...
[17:39:40.569] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:40.570] Packages needed by future strategies (n = 0): <none>
[17:39:40.570] {
[17:39:40.570]     {
[17:39:40.570]         {
[17:39:40.570]             ...future.startTime <- base::Sys.time()
[17:39:40.570]             {
[17:39:40.570]                 {
[17:39:40.570]                   {
[17:39:40.570]                     {
[17:39:40.570]                       base::local({
[17:39:40.570]                         has_future <- base::requireNamespace("future", 
[17:39:40.570]                           quietly = TRUE)
[17:39:40.570]                         if (has_future) {
[17:39:40.570]                           ns <- base::getNamespace("future")
[17:39:40.570]                           version <- ns[[".package"]][["version"]]
[17:39:40.570]                           if (is.null(version)) 
[17:39:40.570]                             version <- utils::packageVersion("future")
[17:39:40.570]                         }
[17:39:40.570]                         else {
[17:39:40.570]                           version <- NULL
[17:39:40.570]                         }
[17:39:40.570]                         if (!has_future || version < "1.8.0") {
[17:39:40.570]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.570]                             "", base::R.version$version.string), 
[17:39:40.570]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.570]                               "release", "version")], collapse = " "), 
[17:39:40.570]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.570]                             info)
[17:39:40.570]                           info <- base::paste(info, collapse = "; ")
[17:39:40.570]                           if (!has_future) {
[17:39:40.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.570]                               info)
[17:39:40.570]                           }
[17:39:40.570]                           else {
[17:39:40.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.570]                               info, version)
[17:39:40.570]                           }
[17:39:40.570]                           base::stop(msg)
[17:39:40.570]                         }
[17:39:40.570]                       })
[17:39:40.570]                     }
[17:39:40.570]                     base::local({
[17:39:40.570]                       for (pkg in c("stats", "datasets")) {
[17:39:40.570]                         base::loadNamespace(pkg)
[17:39:40.570]                         base::library(pkg, character.only = TRUE)
[17:39:40.570]                       }
[17:39:40.570]                     })
[17:39:40.570]                   }
[17:39:40.570]                   ...future.strategy.old <- future::plan("list")
[17:39:40.570]                   options(future.plan = NULL)
[17:39:40.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.570]                 }
[17:39:40.570]                 ...future.workdir <- getwd()
[17:39:40.570]             }
[17:39:40.570]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.570]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.570]         }
[17:39:40.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.570]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.570]             base::names(...future.oldOptions))
[17:39:40.570]     }
[17:39:40.570]     if (FALSE) {
[17:39:40.570]     }
[17:39:40.570]     else {
[17:39:40.570]         if (TRUE) {
[17:39:40.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.570]                 open = "w")
[17:39:40.570]         }
[17:39:40.570]         else {
[17:39:40.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.570]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.570]         }
[17:39:40.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.570]             base::sink(type = "output", split = FALSE)
[17:39:40.570]             base::close(...future.stdout)
[17:39:40.570]         }, add = TRUE)
[17:39:40.570]     }
[17:39:40.570]     ...future.frame <- base::sys.nframe()
[17:39:40.570]     ...future.conditions <- base::list()
[17:39:40.570]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.570]     if (FALSE) {
[17:39:40.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.570]     }
[17:39:40.570]     ...future.result <- base::tryCatch({
[17:39:40.570]         base::withCallingHandlers({
[17:39:40.570]             ...future.value <- base::withVisible(base::local({
[17:39:40.570]                 lm(dist ~ . - 1, data = cars)
[17:39:40.570]             }))
[17:39:40.570]             future::FutureResult(value = ...future.value$value, 
[17:39:40.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.570]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.570]                     ...future.globalenv.names))
[17:39:40.570]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.570]         }, condition = base::local({
[17:39:40.570]             c <- base::c
[17:39:40.570]             inherits <- base::inherits
[17:39:40.570]             invokeRestart <- base::invokeRestart
[17:39:40.570]             length <- base::length
[17:39:40.570]             list <- base::list
[17:39:40.570]             seq.int <- base::seq.int
[17:39:40.570]             signalCondition <- base::signalCondition
[17:39:40.570]             sys.calls <- base::sys.calls
[17:39:40.570]             `[[` <- base::`[[`
[17:39:40.570]             `+` <- base::`+`
[17:39:40.570]             `<<-` <- base::`<<-`
[17:39:40.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.570]                   3L)]
[17:39:40.570]             }
[17:39:40.570]             function(cond) {
[17:39:40.570]                 is_error <- inherits(cond, "error")
[17:39:40.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.570]                   NULL)
[17:39:40.570]                 if (is_error) {
[17:39:40.570]                   sessionInformation <- function() {
[17:39:40.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.570]                       search = base::search(), system = base::Sys.info())
[17:39:40.570]                   }
[17:39:40.570]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.570]                     cond$call), session = sessionInformation(), 
[17:39:40.570]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.570]                   signalCondition(cond)
[17:39:40.570]                 }
[17:39:40.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.570]                 "immediateCondition"))) {
[17:39:40.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.570]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.570]                   if (TRUE && !signal) {
[17:39:40.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.570]                     {
[17:39:40.570]                       inherits <- base::inherits
[17:39:40.570]                       invokeRestart <- base::invokeRestart
[17:39:40.570]                       is.null <- base::is.null
[17:39:40.570]                       muffled <- FALSE
[17:39:40.570]                       if (inherits(cond, "message")) {
[17:39:40.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.570]                         if (muffled) 
[17:39:40.570]                           invokeRestart("muffleMessage")
[17:39:40.570]                       }
[17:39:40.570]                       else if (inherits(cond, "warning")) {
[17:39:40.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.570]                         if (muffled) 
[17:39:40.570]                           invokeRestart("muffleWarning")
[17:39:40.570]                       }
[17:39:40.570]                       else if (inherits(cond, "condition")) {
[17:39:40.570]                         if (!is.null(pattern)) {
[17:39:40.570]                           computeRestarts <- base::computeRestarts
[17:39:40.570]                           grepl <- base::grepl
[17:39:40.570]                           restarts <- computeRestarts(cond)
[17:39:40.570]                           for (restart in restarts) {
[17:39:40.570]                             name <- restart$name
[17:39:40.570]                             if (is.null(name)) 
[17:39:40.570]                               next
[17:39:40.570]                             if (!grepl(pattern, name)) 
[17:39:40.570]                               next
[17:39:40.570]                             invokeRestart(restart)
[17:39:40.570]                             muffled <- TRUE
[17:39:40.570]                             break
[17:39:40.570]                           }
[17:39:40.570]                         }
[17:39:40.570]                       }
[17:39:40.570]                       invisible(muffled)
[17:39:40.570]                     }
[17:39:40.570]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.570]                   }
[17:39:40.570]                 }
[17:39:40.570]                 else {
[17:39:40.570]                   if (TRUE) {
[17:39:40.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.570]                     {
[17:39:40.570]                       inherits <- base::inherits
[17:39:40.570]                       invokeRestart <- base::invokeRestart
[17:39:40.570]                       is.null <- base::is.null
[17:39:40.570]                       muffled <- FALSE
[17:39:40.570]                       if (inherits(cond, "message")) {
[17:39:40.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.570]                         if (muffled) 
[17:39:40.570]                           invokeRestart("muffleMessage")
[17:39:40.570]                       }
[17:39:40.570]                       else if (inherits(cond, "warning")) {
[17:39:40.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.570]                         if (muffled) 
[17:39:40.570]                           invokeRestart("muffleWarning")
[17:39:40.570]                       }
[17:39:40.570]                       else if (inherits(cond, "condition")) {
[17:39:40.570]                         if (!is.null(pattern)) {
[17:39:40.570]                           computeRestarts <- base::computeRestarts
[17:39:40.570]                           grepl <- base::grepl
[17:39:40.570]                           restarts <- computeRestarts(cond)
[17:39:40.570]                           for (restart in restarts) {
[17:39:40.570]                             name <- restart$name
[17:39:40.570]                             if (is.null(name)) 
[17:39:40.570]                               next
[17:39:40.570]                             if (!grepl(pattern, name)) 
[17:39:40.570]                               next
[17:39:40.570]                             invokeRestart(restart)
[17:39:40.570]                             muffled <- TRUE
[17:39:40.570]                             break
[17:39:40.570]                           }
[17:39:40.570]                         }
[17:39:40.570]                       }
[17:39:40.570]                       invisible(muffled)
[17:39:40.570]                     }
[17:39:40.570]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.570]                   }
[17:39:40.570]                 }
[17:39:40.570]             }
[17:39:40.570]         }))
[17:39:40.570]     }, error = function(ex) {
[17:39:40.570]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.570]                 ...future.rng), started = ...future.startTime, 
[17:39:40.570]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.570]             version = "1.8"), class = "FutureResult")
[17:39:40.570]     }, finally = {
[17:39:40.570]         if (!identical(...future.workdir, getwd())) 
[17:39:40.570]             setwd(...future.workdir)
[17:39:40.570]         {
[17:39:40.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.570]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.570]             }
[17:39:40.570]             base::options(...future.oldOptions)
[17:39:40.570]             if (.Platform$OS.type == "windows") {
[17:39:40.570]                 old_names <- names(...future.oldEnvVars)
[17:39:40.570]                 envs <- base::Sys.getenv()
[17:39:40.570]                 names <- names(envs)
[17:39:40.570]                 common <- intersect(names, old_names)
[17:39:40.570]                 added <- setdiff(names, old_names)
[17:39:40.570]                 removed <- setdiff(old_names, names)
[17:39:40.570]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.570]                   envs[common]]
[17:39:40.570]                 NAMES <- toupper(changed)
[17:39:40.570]                 args <- list()
[17:39:40.570]                 for (kk in seq_along(NAMES)) {
[17:39:40.570]                   name <- changed[[kk]]
[17:39:40.570]                   NAME <- NAMES[[kk]]
[17:39:40.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.570]                     next
[17:39:40.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.570]                 }
[17:39:40.570]                 NAMES <- toupper(added)
[17:39:40.570]                 for (kk in seq_along(NAMES)) {
[17:39:40.570]                   name <- added[[kk]]
[17:39:40.570]                   NAME <- NAMES[[kk]]
[17:39:40.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.570]                     next
[17:39:40.570]                   args[[name]] <- ""
[17:39:40.570]                 }
[17:39:40.570]                 NAMES <- toupper(removed)
[17:39:40.570]                 for (kk in seq_along(NAMES)) {
[17:39:40.570]                   name <- removed[[kk]]
[17:39:40.570]                   NAME <- NAMES[[kk]]
[17:39:40.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.570]                     next
[17:39:40.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.570]                 }
[17:39:40.570]                 if (length(args) > 0) 
[17:39:40.570]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.570]             }
[17:39:40.570]             else {
[17:39:40.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.570]             }
[17:39:40.570]             {
[17:39:40.570]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.570]                   0L) {
[17:39:40.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.570]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.570]                   base::options(opts)
[17:39:40.570]                 }
[17:39:40.570]                 {
[17:39:40.570]                   {
[17:39:40.570]                     NULL
[17:39:40.570]                     RNGkind("Mersenne-Twister")
[17:39:40.570]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.570]                       inherits = FALSE)
[17:39:40.570]                   }
[17:39:40.570]                   options(future.plan = NULL)
[17:39:40.570]                   if (is.na(NA_character_)) 
[17:39:40.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.570]                     .init = FALSE)
[17:39:40.570]                 }
[17:39:40.570]             }
[17:39:40.570]         }
[17:39:40.570]     })
[17:39:40.570]     if (TRUE) {
[17:39:40.570]         base::sink(type = "output", split = FALSE)
[17:39:40.570]         if (TRUE) {
[17:39:40.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.570]         }
[17:39:40.570]         else {
[17:39:40.570]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.570]         }
[17:39:40.570]         base::close(...future.stdout)
[17:39:40.570]         ...future.stdout <- NULL
[17:39:40.570]     }
[17:39:40.570]     ...future.result$conditions <- ...future.conditions
[17:39:40.570]     ...future.result$finished <- base::Sys.time()
[17:39:40.570]     ...future.result
[17:39:40.570] }
[17:39:40.572] plan(): Setting new future strategy stack:
[17:39:40.572] List of future strategies:
[17:39:40.572] 1. sequential:
[17:39:40.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.572]    - tweaked: FALSE
[17:39:40.572]    - call: NULL
[17:39:40.573] plan(): nbrOfWorkers() = 1
[17:39:40.574] plan(): Setting new future strategy stack:
[17:39:40.574] List of future strategies:
[17:39:40.574] 1. sequential:
[17:39:40.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.574]    - tweaked: FALSE
[17:39:40.574]    - call: plan(strategy)
[17:39:40.574] plan(): nbrOfWorkers() = 1
[17:39:40.574] SequentialFuture started (and completed)
[17:39:40.575] - Launch lazy future ... done
[17:39:40.575] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:39:40.577] getGlobalsAndPackages() ...
[17:39:40.577] Searching for globals...
[17:39:40.580] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:39:40.580] Searching for globals ... DONE
[17:39:40.580] Resolving globals: FALSE
[17:39:40.581] 
[17:39:40.581] - packages: [2] ‘stats’, ‘datasets’
[17:39:40.581] getGlobalsAndPackages() ... DONE
[17:39:40.581] run() for ‘Future’ ...
[17:39:40.581] - state: ‘created’
[17:39:40.581] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.582] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.582]   - Field: ‘label’
[17:39:40.582]   - Field: ‘local’
[17:39:40.582]   - Field: ‘owner’
[17:39:40.582]   - Field: ‘envir’
[17:39:40.582]   - Field: ‘packages’
[17:39:40.582]   - Field: ‘gc’
[17:39:40.582]   - Field: ‘conditions’
[17:39:40.582]   - Field: ‘expr’
[17:39:40.583]   - Field: ‘uuid’
[17:39:40.583]   - Field: ‘seed’
[17:39:40.583]   - Field: ‘version’
[17:39:40.583]   - Field: ‘result’
[17:39:40.583]   - Field: ‘asynchronous’
[17:39:40.583]   - Field: ‘calls’
[17:39:40.583]   - Field: ‘globals’
[17:39:40.583]   - Field: ‘stdout’
[17:39:40.583]   - Field: ‘earlySignal’
[17:39:40.583]   - Field: ‘lazy’
[17:39:40.583]   - Field: ‘state’
[17:39:40.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.584] - Launch lazy future ...
[17:39:40.584] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:40.584] Packages needed by future strategies (n = 0): <none>
[17:39:40.584] {
[17:39:40.584]     {
[17:39:40.584]         {
[17:39:40.584]             ...future.startTime <- base::Sys.time()
[17:39:40.584]             {
[17:39:40.584]                 {
[17:39:40.584]                   {
[17:39:40.584]                     {
[17:39:40.584]                       base::local({
[17:39:40.584]                         has_future <- base::requireNamespace("future", 
[17:39:40.584]                           quietly = TRUE)
[17:39:40.584]                         if (has_future) {
[17:39:40.584]                           ns <- base::getNamespace("future")
[17:39:40.584]                           version <- ns[[".package"]][["version"]]
[17:39:40.584]                           if (is.null(version)) 
[17:39:40.584]                             version <- utils::packageVersion("future")
[17:39:40.584]                         }
[17:39:40.584]                         else {
[17:39:40.584]                           version <- NULL
[17:39:40.584]                         }
[17:39:40.584]                         if (!has_future || version < "1.8.0") {
[17:39:40.584]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.584]                             "", base::R.version$version.string), 
[17:39:40.584]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.584]                               "release", "version")], collapse = " "), 
[17:39:40.584]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.584]                             info)
[17:39:40.584]                           info <- base::paste(info, collapse = "; ")
[17:39:40.584]                           if (!has_future) {
[17:39:40.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.584]                               info)
[17:39:40.584]                           }
[17:39:40.584]                           else {
[17:39:40.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.584]                               info, version)
[17:39:40.584]                           }
[17:39:40.584]                           base::stop(msg)
[17:39:40.584]                         }
[17:39:40.584]                       })
[17:39:40.584]                     }
[17:39:40.584]                     base::local({
[17:39:40.584]                       for (pkg in c("stats", "datasets")) {
[17:39:40.584]                         base::loadNamespace(pkg)
[17:39:40.584]                         base::library(pkg, character.only = TRUE)
[17:39:40.584]                       }
[17:39:40.584]                     })
[17:39:40.584]                   }
[17:39:40.584]                   ...future.strategy.old <- future::plan("list")
[17:39:40.584]                   options(future.plan = NULL)
[17:39:40.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.584]                 }
[17:39:40.584]                 ...future.workdir <- getwd()
[17:39:40.584]             }
[17:39:40.584]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.584]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.584]         }
[17:39:40.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.584]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.584]             base::names(...future.oldOptions))
[17:39:40.584]     }
[17:39:40.584]     if (FALSE) {
[17:39:40.584]     }
[17:39:40.584]     else {
[17:39:40.584]         if (TRUE) {
[17:39:40.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.584]                 open = "w")
[17:39:40.584]         }
[17:39:40.584]         else {
[17:39:40.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.584]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.584]         }
[17:39:40.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.584]             base::sink(type = "output", split = FALSE)
[17:39:40.584]             base::close(...future.stdout)
[17:39:40.584]         }, add = TRUE)
[17:39:40.584]     }
[17:39:40.584]     ...future.frame <- base::sys.nframe()
[17:39:40.584]     ...future.conditions <- base::list()
[17:39:40.584]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.584]     if (FALSE) {
[17:39:40.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.584]     }
[17:39:40.584]     ...future.result <- base::tryCatch({
[17:39:40.584]         base::withCallingHandlers({
[17:39:40.584]             ...future.value <- base::withVisible(base::local({
[17:39:40.584]                 lm(dist ~ . + 0, data = cars)
[17:39:40.584]             }))
[17:39:40.584]             future::FutureResult(value = ...future.value$value, 
[17:39:40.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.584]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.584]                     ...future.globalenv.names))
[17:39:40.584]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.584]         }, condition = base::local({
[17:39:40.584]             c <- base::c
[17:39:40.584]             inherits <- base::inherits
[17:39:40.584]             invokeRestart <- base::invokeRestart
[17:39:40.584]             length <- base::length
[17:39:40.584]             list <- base::list
[17:39:40.584]             seq.int <- base::seq.int
[17:39:40.584]             signalCondition <- base::signalCondition
[17:39:40.584]             sys.calls <- base::sys.calls
[17:39:40.584]             `[[` <- base::`[[`
[17:39:40.584]             `+` <- base::`+`
[17:39:40.584]             `<<-` <- base::`<<-`
[17:39:40.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.584]                   3L)]
[17:39:40.584]             }
[17:39:40.584]             function(cond) {
[17:39:40.584]                 is_error <- inherits(cond, "error")
[17:39:40.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.584]                   NULL)
[17:39:40.584]                 if (is_error) {
[17:39:40.584]                   sessionInformation <- function() {
[17:39:40.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.584]                       search = base::search(), system = base::Sys.info())
[17:39:40.584]                   }
[17:39:40.584]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.584]                     cond$call), session = sessionInformation(), 
[17:39:40.584]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.584]                   signalCondition(cond)
[17:39:40.584]                 }
[17:39:40.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.584]                 "immediateCondition"))) {
[17:39:40.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.584]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.584]                   if (TRUE && !signal) {
[17:39:40.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.584]                     {
[17:39:40.584]                       inherits <- base::inherits
[17:39:40.584]                       invokeRestart <- base::invokeRestart
[17:39:40.584]                       is.null <- base::is.null
[17:39:40.584]                       muffled <- FALSE
[17:39:40.584]                       if (inherits(cond, "message")) {
[17:39:40.584]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.584]                         if (muffled) 
[17:39:40.584]                           invokeRestart("muffleMessage")
[17:39:40.584]                       }
[17:39:40.584]                       else if (inherits(cond, "warning")) {
[17:39:40.584]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.584]                         if (muffled) 
[17:39:40.584]                           invokeRestart("muffleWarning")
[17:39:40.584]                       }
[17:39:40.584]                       else if (inherits(cond, "condition")) {
[17:39:40.584]                         if (!is.null(pattern)) {
[17:39:40.584]                           computeRestarts <- base::computeRestarts
[17:39:40.584]                           grepl <- base::grepl
[17:39:40.584]                           restarts <- computeRestarts(cond)
[17:39:40.584]                           for (restart in restarts) {
[17:39:40.584]                             name <- restart$name
[17:39:40.584]                             if (is.null(name)) 
[17:39:40.584]                               next
[17:39:40.584]                             if (!grepl(pattern, name)) 
[17:39:40.584]                               next
[17:39:40.584]                             invokeRestart(restart)
[17:39:40.584]                             muffled <- TRUE
[17:39:40.584]                             break
[17:39:40.584]                           }
[17:39:40.584]                         }
[17:39:40.584]                       }
[17:39:40.584]                       invisible(muffled)
[17:39:40.584]                     }
[17:39:40.584]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.584]                   }
[17:39:40.584]                 }
[17:39:40.584]                 else {
[17:39:40.584]                   if (TRUE) {
[17:39:40.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.584]                     {
[17:39:40.584]                       inherits <- base::inherits
[17:39:40.584]                       invokeRestart <- base::invokeRestart
[17:39:40.584]                       is.null <- base::is.null
[17:39:40.584]                       muffled <- FALSE
[17:39:40.584]                       if (inherits(cond, "message")) {
[17:39:40.584]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.584]                         if (muffled) 
[17:39:40.584]                           invokeRestart("muffleMessage")
[17:39:40.584]                       }
[17:39:40.584]                       else if (inherits(cond, "warning")) {
[17:39:40.584]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.584]                         if (muffled) 
[17:39:40.584]                           invokeRestart("muffleWarning")
[17:39:40.584]                       }
[17:39:40.584]                       else if (inherits(cond, "condition")) {
[17:39:40.584]                         if (!is.null(pattern)) {
[17:39:40.584]                           computeRestarts <- base::computeRestarts
[17:39:40.584]                           grepl <- base::grepl
[17:39:40.584]                           restarts <- computeRestarts(cond)
[17:39:40.584]                           for (restart in restarts) {
[17:39:40.584]                             name <- restart$name
[17:39:40.584]                             if (is.null(name)) 
[17:39:40.584]                               next
[17:39:40.584]                             if (!grepl(pattern, name)) 
[17:39:40.584]                               next
[17:39:40.584]                             invokeRestart(restart)
[17:39:40.584]                             muffled <- TRUE
[17:39:40.584]                             break
[17:39:40.584]                           }
[17:39:40.584]                         }
[17:39:40.584]                       }
[17:39:40.584]                       invisible(muffled)
[17:39:40.584]                     }
[17:39:40.584]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.584]                   }
[17:39:40.584]                 }
[17:39:40.584]             }
[17:39:40.584]         }))
[17:39:40.584]     }, error = function(ex) {
[17:39:40.584]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.584]                 ...future.rng), started = ...future.startTime, 
[17:39:40.584]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.584]             version = "1.8"), class = "FutureResult")
[17:39:40.584]     }, finally = {
[17:39:40.584]         if (!identical(...future.workdir, getwd())) 
[17:39:40.584]             setwd(...future.workdir)
[17:39:40.584]         {
[17:39:40.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.584]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.584]             }
[17:39:40.584]             base::options(...future.oldOptions)
[17:39:40.584]             if (.Platform$OS.type == "windows") {
[17:39:40.584]                 old_names <- names(...future.oldEnvVars)
[17:39:40.584]                 envs <- base::Sys.getenv()
[17:39:40.584]                 names <- names(envs)
[17:39:40.584]                 common <- intersect(names, old_names)
[17:39:40.584]                 added <- setdiff(names, old_names)
[17:39:40.584]                 removed <- setdiff(old_names, names)
[17:39:40.584]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.584]                   envs[common]]
[17:39:40.584]                 NAMES <- toupper(changed)
[17:39:40.584]                 args <- list()
[17:39:40.584]                 for (kk in seq_along(NAMES)) {
[17:39:40.584]                   name <- changed[[kk]]
[17:39:40.584]                   NAME <- NAMES[[kk]]
[17:39:40.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.584]                     next
[17:39:40.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.584]                 }
[17:39:40.584]                 NAMES <- toupper(added)
[17:39:40.584]                 for (kk in seq_along(NAMES)) {
[17:39:40.584]                   name <- added[[kk]]
[17:39:40.584]                   NAME <- NAMES[[kk]]
[17:39:40.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.584]                     next
[17:39:40.584]                   args[[name]] <- ""
[17:39:40.584]                 }
[17:39:40.584]                 NAMES <- toupper(removed)
[17:39:40.584]                 for (kk in seq_along(NAMES)) {
[17:39:40.584]                   name <- removed[[kk]]
[17:39:40.584]                   NAME <- NAMES[[kk]]
[17:39:40.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.584]                     next
[17:39:40.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.584]                 }
[17:39:40.584]                 if (length(args) > 0) 
[17:39:40.584]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.584]             }
[17:39:40.584]             else {
[17:39:40.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.584]             }
[17:39:40.584]             {
[17:39:40.584]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.584]                   0L) {
[17:39:40.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.584]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.584]                   base::options(opts)
[17:39:40.584]                 }
[17:39:40.584]                 {
[17:39:40.584]                   {
[17:39:40.584]                     NULL
[17:39:40.584]                     RNGkind("Mersenne-Twister")
[17:39:40.584]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.584]                       inherits = FALSE)
[17:39:40.584]                   }
[17:39:40.584]                   options(future.plan = NULL)
[17:39:40.584]                   if (is.na(NA_character_)) 
[17:39:40.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.584]                     .init = FALSE)
[17:39:40.584]                 }
[17:39:40.584]             }
[17:39:40.584]         }
[17:39:40.584]     })
[17:39:40.584]     if (TRUE) {
[17:39:40.584]         base::sink(type = "output", split = FALSE)
[17:39:40.584]         if (TRUE) {
[17:39:40.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.584]         }
[17:39:40.584]         else {
[17:39:40.584]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.584]         }
[17:39:40.584]         base::close(...future.stdout)
[17:39:40.584]         ...future.stdout <- NULL
[17:39:40.584]     }
[17:39:40.584]     ...future.result$conditions <- ...future.conditions
[17:39:40.584]     ...future.result$finished <- base::Sys.time()
[17:39:40.584]     ...future.result
[17:39:40.584] }
[17:39:40.586] plan(): Setting new future strategy stack:
[17:39:40.586] List of future strategies:
[17:39:40.586] 1. sequential:
[17:39:40.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.586]    - tweaked: FALSE
[17:39:40.586]    - call: NULL
[17:39:40.587] plan(): nbrOfWorkers() = 1
[17:39:40.588] plan(): Setting new future strategy stack:
[17:39:40.588] List of future strategies:
[17:39:40.588] 1. sequential:
[17:39:40.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.588]    - tweaked: FALSE
[17:39:40.588]    - call: plan(strategy)
[17:39:40.588] plan(): nbrOfWorkers() = 1
[17:39:40.589] SequentialFuture started (and completed)
[17:39:40.589] - Launch lazy future ... done
[17:39:40.589] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:39:40.591] getGlobalsAndPackages() ...
[17:39:40.591] Searching for globals...
[17:39:40.593] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:39:40.593] Searching for globals ... DONE
[17:39:40.593] Resolving globals: FALSE
[17:39:40.593] 
[17:39:40.594] - packages: [2] ‘stats’, ‘datasets’
[17:39:40.594] getGlobalsAndPackages() ... DONE
[17:39:40.594] run() for ‘Future’ ...
[17:39:40.594] - state: ‘created’
[17:39:40.594] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.594] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.594]   - Field: ‘label’
[17:39:40.595]   - Field: ‘local’
[17:39:40.595]   - Field: ‘owner’
[17:39:40.595]   - Field: ‘envir’
[17:39:40.595]   - Field: ‘packages’
[17:39:40.595]   - Field: ‘gc’
[17:39:40.595]   - Field: ‘conditions’
[17:39:40.595]   - Field: ‘expr’
[17:39:40.595]   - Field: ‘uuid’
[17:39:40.595]   - Field: ‘seed’
[17:39:40.595]   - Field: ‘version’
[17:39:40.595]   - Field: ‘result’
[17:39:40.596]   - Field: ‘asynchronous’
[17:39:40.596]   - Field: ‘calls’
[17:39:40.596]   - Field: ‘globals’
[17:39:40.596]   - Field: ‘stdout’
[17:39:40.596]   - Field: ‘earlySignal’
[17:39:40.596]   - Field: ‘lazy’
[17:39:40.596]   - Field: ‘state’
[17:39:40.596] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.596] - Launch lazy future ...
[17:39:40.596] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:40.597] Packages needed by future strategies (n = 0): <none>
[17:39:40.597] {
[17:39:40.597]     {
[17:39:40.597]         {
[17:39:40.597]             ...future.startTime <- base::Sys.time()
[17:39:40.597]             {
[17:39:40.597]                 {
[17:39:40.597]                   {
[17:39:40.597]                     {
[17:39:40.597]                       base::local({
[17:39:40.597]                         has_future <- base::requireNamespace("future", 
[17:39:40.597]                           quietly = TRUE)
[17:39:40.597]                         if (has_future) {
[17:39:40.597]                           ns <- base::getNamespace("future")
[17:39:40.597]                           version <- ns[[".package"]][["version"]]
[17:39:40.597]                           if (is.null(version)) 
[17:39:40.597]                             version <- utils::packageVersion("future")
[17:39:40.597]                         }
[17:39:40.597]                         else {
[17:39:40.597]                           version <- NULL
[17:39:40.597]                         }
[17:39:40.597]                         if (!has_future || version < "1.8.0") {
[17:39:40.597]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.597]                             "", base::R.version$version.string), 
[17:39:40.597]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.597]                               "release", "version")], collapse = " "), 
[17:39:40.597]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.597]                             info)
[17:39:40.597]                           info <- base::paste(info, collapse = "; ")
[17:39:40.597]                           if (!has_future) {
[17:39:40.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.597]                               info)
[17:39:40.597]                           }
[17:39:40.597]                           else {
[17:39:40.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.597]                               info, version)
[17:39:40.597]                           }
[17:39:40.597]                           base::stop(msg)
[17:39:40.597]                         }
[17:39:40.597]                       })
[17:39:40.597]                     }
[17:39:40.597]                     base::local({
[17:39:40.597]                       for (pkg in c("stats", "datasets")) {
[17:39:40.597]                         base::loadNamespace(pkg)
[17:39:40.597]                         base::library(pkg, character.only = TRUE)
[17:39:40.597]                       }
[17:39:40.597]                     })
[17:39:40.597]                   }
[17:39:40.597]                   ...future.strategy.old <- future::plan("list")
[17:39:40.597]                   options(future.plan = NULL)
[17:39:40.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.597]                 }
[17:39:40.597]                 ...future.workdir <- getwd()
[17:39:40.597]             }
[17:39:40.597]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.597]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.597]         }
[17:39:40.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.597]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.597]             base::names(...future.oldOptions))
[17:39:40.597]     }
[17:39:40.597]     if (FALSE) {
[17:39:40.597]     }
[17:39:40.597]     else {
[17:39:40.597]         if (TRUE) {
[17:39:40.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.597]                 open = "w")
[17:39:40.597]         }
[17:39:40.597]         else {
[17:39:40.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.597]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.597]         }
[17:39:40.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.597]             base::sink(type = "output", split = FALSE)
[17:39:40.597]             base::close(...future.stdout)
[17:39:40.597]         }, add = TRUE)
[17:39:40.597]     }
[17:39:40.597]     ...future.frame <- base::sys.nframe()
[17:39:40.597]     ...future.conditions <- base::list()
[17:39:40.597]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.597]     if (FALSE) {
[17:39:40.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.597]     }
[17:39:40.597]     ...future.result <- base::tryCatch({
[17:39:40.597]         base::withCallingHandlers({
[17:39:40.597]             ...future.value <- base::withVisible(base::local({
[17:39:40.597]                 lm(dist ~ speed + speed^2, data = cars)
[17:39:40.597]             }))
[17:39:40.597]             future::FutureResult(value = ...future.value$value, 
[17:39:40.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.597]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.597]                     ...future.globalenv.names))
[17:39:40.597]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.597]         }, condition = base::local({
[17:39:40.597]             c <- base::c
[17:39:40.597]             inherits <- base::inherits
[17:39:40.597]             invokeRestart <- base::invokeRestart
[17:39:40.597]             length <- base::length
[17:39:40.597]             list <- base::list
[17:39:40.597]             seq.int <- base::seq.int
[17:39:40.597]             signalCondition <- base::signalCondition
[17:39:40.597]             sys.calls <- base::sys.calls
[17:39:40.597]             `[[` <- base::`[[`
[17:39:40.597]             `+` <- base::`+`
[17:39:40.597]             `<<-` <- base::`<<-`
[17:39:40.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.597]                   3L)]
[17:39:40.597]             }
[17:39:40.597]             function(cond) {
[17:39:40.597]                 is_error <- inherits(cond, "error")
[17:39:40.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.597]                   NULL)
[17:39:40.597]                 if (is_error) {
[17:39:40.597]                   sessionInformation <- function() {
[17:39:40.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.597]                       search = base::search(), system = base::Sys.info())
[17:39:40.597]                   }
[17:39:40.597]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.597]                     cond$call), session = sessionInformation(), 
[17:39:40.597]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.597]                   signalCondition(cond)
[17:39:40.597]                 }
[17:39:40.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.597]                 "immediateCondition"))) {
[17:39:40.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.597]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.597]                   if (TRUE && !signal) {
[17:39:40.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.597]                     {
[17:39:40.597]                       inherits <- base::inherits
[17:39:40.597]                       invokeRestart <- base::invokeRestart
[17:39:40.597]                       is.null <- base::is.null
[17:39:40.597]                       muffled <- FALSE
[17:39:40.597]                       if (inherits(cond, "message")) {
[17:39:40.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.597]                         if (muffled) 
[17:39:40.597]                           invokeRestart("muffleMessage")
[17:39:40.597]                       }
[17:39:40.597]                       else if (inherits(cond, "warning")) {
[17:39:40.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.597]                         if (muffled) 
[17:39:40.597]                           invokeRestart("muffleWarning")
[17:39:40.597]                       }
[17:39:40.597]                       else if (inherits(cond, "condition")) {
[17:39:40.597]                         if (!is.null(pattern)) {
[17:39:40.597]                           computeRestarts <- base::computeRestarts
[17:39:40.597]                           grepl <- base::grepl
[17:39:40.597]                           restarts <- computeRestarts(cond)
[17:39:40.597]                           for (restart in restarts) {
[17:39:40.597]                             name <- restart$name
[17:39:40.597]                             if (is.null(name)) 
[17:39:40.597]                               next
[17:39:40.597]                             if (!grepl(pattern, name)) 
[17:39:40.597]                               next
[17:39:40.597]                             invokeRestart(restart)
[17:39:40.597]                             muffled <- TRUE
[17:39:40.597]                             break
[17:39:40.597]                           }
[17:39:40.597]                         }
[17:39:40.597]                       }
[17:39:40.597]                       invisible(muffled)
[17:39:40.597]                     }
[17:39:40.597]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.597]                   }
[17:39:40.597]                 }
[17:39:40.597]                 else {
[17:39:40.597]                   if (TRUE) {
[17:39:40.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.597]                     {
[17:39:40.597]                       inherits <- base::inherits
[17:39:40.597]                       invokeRestart <- base::invokeRestart
[17:39:40.597]                       is.null <- base::is.null
[17:39:40.597]                       muffled <- FALSE
[17:39:40.597]                       if (inherits(cond, "message")) {
[17:39:40.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.597]                         if (muffled) 
[17:39:40.597]                           invokeRestart("muffleMessage")
[17:39:40.597]                       }
[17:39:40.597]                       else if (inherits(cond, "warning")) {
[17:39:40.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.597]                         if (muffled) 
[17:39:40.597]                           invokeRestart("muffleWarning")
[17:39:40.597]                       }
[17:39:40.597]                       else if (inherits(cond, "condition")) {
[17:39:40.597]                         if (!is.null(pattern)) {
[17:39:40.597]                           computeRestarts <- base::computeRestarts
[17:39:40.597]                           grepl <- base::grepl
[17:39:40.597]                           restarts <- computeRestarts(cond)
[17:39:40.597]                           for (restart in restarts) {
[17:39:40.597]                             name <- restart$name
[17:39:40.597]                             if (is.null(name)) 
[17:39:40.597]                               next
[17:39:40.597]                             if (!grepl(pattern, name)) 
[17:39:40.597]                               next
[17:39:40.597]                             invokeRestart(restart)
[17:39:40.597]                             muffled <- TRUE
[17:39:40.597]                             break
[17:39:40.597]                           }
[17:39:40.597]                         }
[17:39:40.597]                       }
[17:39:40.597]                       invisible(muffled)
[17:39:40.597]                     }
[17:39:40.597]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.597]                   }
[17:39:40.597]                 }
[17:39:40.597]             }
[17:39:40.597]         }))
[17:39:40.597]     }, error = function(ex) {
[17:39:40.597]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.597]                 ...future.rng), started = ...future.startTime, 
[17:39:40.597]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.597]             version = "1.8"), class = "FutureResult")
[17:39:40.597]     }, finally = {
[17:39:40.597]         if (!identical(...future.workdir, getwd())) 
[17:39:40.597]             setwd(...future.workdir)
[17:39:40.597]         {
[17:39:40.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.597]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.597]             }
[17:39:40.597]             base::options(...future.oldOptions)
[17:39:40.597]             if (.Platform$OS.type == "windows") {
[17:39:40.597]                 old_names <- names(...future.oldEnvVars)
[17:39:40.597]                 envs <- base::Sys.getenv()
[17:39:40.597]                 names <- names(envs)
[17:39:40.597]                 common <- intersect(names, old_names)
[17:39:40.597]                 added <- setdiff(names, old_names)
[17:39:40.597]                 removed <- setdiff(old_names, names)
[17:39:40.597]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.597]                   envs[common]]
[17:39:40.597]                 NAMES <- toupper(changed)
[17:39:40.597]                 args <- list()
[17:39:40.597]                 for (kk in seq_along(NAMES)) {
[17:39:40.597]                   name <- changed[[kk]]
[17:39:40.597]                   NAME <- NAMES[[kk]]
[17:39:40.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.597]                     next
[17:39:40.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.597]                 }
[17:39:40.597]                 NAMES <- toupper(added)
[17:39:40.597]                 for (kk in seq_along(NAMES)) {
[17:39:40.597]                   name <- added[[kk]]
[17:39:40.597]                   NAME <- NAMES[[kk]]
[17:39:40.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.597]                     next
[17:39:40.597]                   args[[name]] <- ""
[17:39:40.597]                 }
[17:39:40.597]                 NAMES <- toupper(removed)
[17:39:40.597]                 for (kk in seq_along(NAMES)) {
[17:39:40.597]                   name <- removed[[kk]]
[17:39:40.597]                   NAME <- NAMES[[kk]]
[17:39:40.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.597]                     next
[17:39:40.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.597]                 }
[17:39:40.597]                 if (length(args) > 0) 
[17:39:40.597]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.597]             }
[17:39:40.597]             else {
[17:39:40.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.597]             }
[17:39:40.597]             {
[17:39:40.597]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.597]                   0L) {
[17:39:40.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.597]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.597]                   base::options(opts)
[17:39:40.597]                 }
[17:39:40.597]                 {
[17:39:40.597]                   {
[17:39:40.597]                     NULL
[17:39:40.597]                     RNGkind("Mersenne-Twister")
[17:39:40.597]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.597]                       inherits = FALSE)
[17:39:40.597]                   }
[17:39:40.597]                   options(future.plan = NULL)
[17:39:40.597]                   if (is.na(NA_character_)) 
[17:39:40.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.597]                     .init = FALSE)
[17:39:40.597]                 }
[17:39:40.597]             }
[17:39:40.597]         }
[17:39:40.597]     })
[17:39:40.597]     if (TRUE) {
[17:39:40.597]         base::sink(type = "output", split = FALSE)
[17:39:40.597]         if (TRUE) {
[17:39:40.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.597]         }
[17:39:40.597]         else {
[17:39:40.597]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.597]         }
[17:39:40.597]         base::close(...future.stdout)
[17:39:40.597]         ...future.stdout <- NULL
[17:39:40.597]     }
[17:39:40.597]     ...future.result$conditions <- ...future.conditions
[17:39:40.597]     ...future.result$finished <- base::Sys.time()
[17:39:40.597]     ...future.result
[17:39:40.597] }
[17:39:40.599] plan(): Setting new future strategy stack:
[17:39:40.599] List of future strategies:
[17:39:40.599] 1. sequential:
[17:39:40.599]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.599]    - tweaked: FALSE
[17:39:40.599]    - call: NULL
[17:39:40.599] plan(): nbrOfWorkers() = 1
[17:39:40.601] plan(): Setting new future strategy stack:
[17:39:40.601] List of future strategies:
[17:39:40.601] 1. sequential:
[17:39:40.601]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.601]    - tweaked: FALSE
[17:39:40.601]    - call: plan(strategy)
[17:39:40.601] plan(): nbrOfWorkers() = 1
[17:39:40.601] SequentialFuture started (and completed)
[17:39:40.601] - Launch lazy future ... done
[17:39:40.601] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:39:40.605] getGlobalsAndPackages() ...
[17:39:40.606] Searching for globals...
[17:39:40.607] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:39:40.608] Searching for globals ... DONE
[17:39:40.608] Resolving globals: FALSE
[17:39:40.608] 
[17:39:40.608] - packages: [2] ‘stats’, ‘datasets’
[17:39:40.609] getGlobalsAndPackages() ... DONE
[17:39:40.609] run() for ‘Future’ ...
[17:39:40.609] - state: ‘created’
[17:39:40.609] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.609] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.609]   - Field: ‘label’
[17:39:40.610]   - Field: ‘local’
[17:39:40.610]   - Field: ‘owner’
[17:39:40.610]   - Field: ‘envir’
[17:39:40.610]   - Field: ‘packages’
[17:39:40.610]   - Field: ‘gc’
[17:39:40.610]   - Field: ‘conditions’
[17:39:40.610]   - Field: ‘expr’
[17:39:40.610]   - Field: ‘uuid’
[17:39:40.610]   - Field: ‘seed’
[17:39:40.610]   - Field: ‘version’
[17:39:40.610]   - Field: ‘result’
[17:39:40.611]   - Field: ‘asynchronous’
[17:39:40.611]   - Field: ‘calls’
[17:39:40.611]   - Field: ‘globals’
[17:39:40.611]   - Field: ‘stdout’
[17:39:40.611]   - Field: ‘earlySignal’
[17:39:40.611]   - Field: ‘lazy’
[17:39:40.611]   - Field: ‘state’
[17:39:40.611] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.611] - Launch lazy future ...
[17:39:40.611] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:40.612] Packages needed by future strategies (n = 0): <none>
[17:39:40.612] {
[17:39:40.612]     {
[17:39:40.612]         {
[17:39:40.612]             ...future.startTime <- base::Sys.time()
[17:39:40.612]             {
[17:39:40.612]                 {
[17:39:40.612]                   {
[17:39:40.612]                     {
[17:39:40.612]                       base::local({
[17:39:40.612]                         has_future <- base::requireNamespace("future", 
[17:39:40.612]                           quietly = TRUE)
[17:39:40.612]                         if (has_future) {
[17:39:40.612]                           ns <- base::getNamespace("future")
[17:39:40.612]                           version <- ns[[".package"]][["version"]]
[17:39:40.612]                           if (is.null(version)) 
[17:39:40.612]                             version <- utils::packageVersion("future")
[17:39:40.612]                         }
[17:39:40.612]                         else {
[17:39:40.612]                           version <- NULL
[17:39:40.612]                         }
[17:39:40.612]                         if (!has_future || version < "1.8.0") {
[17:39:40.612]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.612]                             "", base::R.version$version.string), 
[17:39:40.612]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.612]                               "release", "version")], collapse = " "), 
[17:39:40.612]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.612]                             info)
[17:39:40.612]                           info <- base::paste(info, collapse = "; ")
[17:39:40.612]                           if (!has_future) {
[17:39:40.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.612]                               info)
[17:39:40.612]                           }
[17:39:40.612]                           else {
[17:39:40.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.612]                               info, version)
[17:39:40.612]                           }
[17:39:40.612]                           base::stop(msg)
[17:39:40.612]                         }
[17:39:40.612]                       })
[17:39:40.612]                     }
[17:39:40.612]                     base::local({
[17:39:40.612]                       for (pkg in c("stats", "datasets")) {
[17:39:40.612]                         base::loadNamespace(pkg)
[17:39:40.612]                         base::library(pkg, character.only = TRUE)
[17:39:40.612]                       }
[17:39:40.612]                     })
[17:39:40.612]                   }
[17:39:40.612]                   ...future.strategy.old <- future::plan("list")
[17:39:40.612]                   options(future.plan = NULL)
[17:39:40.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.612]                 }
[17:39:40.612]                 ...future.workdir <- getwd()
[17:39:40.612]             }
[17:39:40.612]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.612]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.612]         }
[17:39:40.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.612]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.612]             base::names(...future.oldOptions))
[17:39:40.612]     }
[17:39:40.612]     if (FALSE) {
[17:39:40.612]     }
[17:39:40.612]     else {
[17:39:40.612]         if (TRUE) {
[17:39:40.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.612]                 open = "w")
[17:39:40.612]         }
[17:39:40.612]         else {
[17:39:40.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.612]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.612]         }
[17:39:40.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.612]             base::sink(type = "output", split = FALSE)
[17:39:40.612]             base::close(...future.stdout)
[17:39:40.612]         }, add = TRUE)
[17:39:40.612]     }
[17:39:40.612]     ...future.frame <- base::sys.nframe()
[17:39:40.612]     ...future.conditions <- base::list()
[17:39:40.612]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.612]     if (FALSE) {
[17:39:40.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.612]     }
[17:39:40.612]     ...future.result <- base::tryCatch({
[17:39:40.612]         base::withCallingHandlers({
[17:39:40.612]             ...future.value <- base::withVisible(base::local({
[17:39:40.612]                 lm(dist ~ speed + I(speed^2), data = cars)
[17:39:40.612]             }))
[17:39:40.612]             future::FutureResult(value = ...future.value$value, 
[17:39:40.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.612]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.612]                     ...future.globalenv.names))
[17:39:40.612]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.612]         }, condition = base::local({
[17:39:40.612]             c <- base::c
[17:39:40.612]             inherits <- base::inherits
[17:39:40.612]             invokeRestart <- base::invokeRestart
[17:39:40.612]             length <- base::length
[17:39:40.612]             list <- base::list
[17:39:40.612]             seq.int <- base::seq.int
[17:39:40.612]             signalCondition <- base::signalCondition
[17:39:40.612]             sys.calls <- base::sys.calls
[17:39:40.612]             `[[` <- base::`[[`
[17:39:40.612]             `+` <- base::`+`
[17:39:40.612]             `<<-` <- base::`<<-`
[17:39:40.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.612]                   3L)]
[17:39:40.612]             }
[17:39:40.612]             function(cond) {
[17:39:40.612]                 is_error <- inherits(cond, "error")
[17:39:40.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.612]                   NULL)
[17:39:40.612]                 if (is_error) {
[17:39:40.612]                   sessionInformation <- function() {
[17:39:40.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.612]                       search = base::search(), system = base::Sys.info())
[17:39:40.612]                   }
[17:39:40.612]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.612]                     cond$call), session = sessionInformation(), 
[17:39:40.612]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.612]                   signalCondition(cond)
[17:39:40.612]                 }
[17:39:40.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.612]                 "immediateCondition"))) {
[17:39:40.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.612]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.612]                   if (TRUE && !signal) {
[17:39:40.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.612]                     {
[17:39:40.612]                       inherits <- base::inherits
[17:39:40.612]                       invokeRestart <- base::invokeRestart
[17:39:40.612]                       is.null <- base::is.null
[17:39:40.612]                       muffled <- FALSE
[17:39:40.612]                       if (inherits(cond, "message")) {
[17:39:40.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.612]                         if (muffled) 
[17:39:40.612]                           invokeRestart("muffleMessage")
[17:39:40.612]                       }
[17:39:40.612]                       else if (inherits(cond, "warning")) {
[17:39:40.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.612]                         if (muffled) 
[17:39:40.612]                           invokeRestart("muffleWarning")
[17:39:40.612]                       }
[17:39:40.612]                       else if (inherits(cond, "condition")) {
[17:39:40.612]                         if (!is.null(pattern)) {
[17:39:40.612]                           computeRestarts <- base::computeRestarts
[17:39:40.612]                           grepl <- base::grepl
[17:39:40.612]                           restarts <- computeRestarts(cond)
[17:39:40.612]                           for (restart in restarts) {
[17:39:40.612]                             name <- restart$name
[17:39:40.612]                             if (is.null(name)) 
[17:39:40.612]                               next
[17:39:40.612]                             if (!grepl(pattern, name)) 
[17:39:40.612]                               next
[17:39:40.612]                             invokeRestart(restart)
[17:39:40.612]                             muffled <- TRUE
[17:39:40.612]                             break
[17:39:40.612]                           }
[17:39:40.612]                         }
[17:39:40.612]                       }
[17:39:40.612]                       invisible(muffled)
[17:39:40.612]                     }
[17:39:40.612]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.612]                   }
[17:39:40.612]                 }
[17:39:40.612]                 else {
[17:39:40.612]                   if (TRUE) {
[17:39:40.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.612]                     {
[17:39:40.612]                       inherits <- base::inherits
[17:39:40.612]                       invokeRestart <- base::invokeRestart
[17:39:40.612]                       is.null <- base::is.null
[17:39:40.612]                       muffled <- FALSE
[17:39:40.612]                       if (inherits(cond, "message")) {
[17:39:40.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.612]                         if (muffled) 
[17:39:40.612]                           invokeRestart("muffleMessage")
[17:39:40.612]                       }
[17:39:40.612]                       else if (inherits(cond, "warning")) {
[17:39:40.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.612]                         if (muffled) 
[17:39:40.612]                           invokeRestart("muffleWarning")
[17:39:40.612]                       }
[17:39:40.612]                       else if (inherits(cond, "condition")) {
[17:39:40.612]                         if (!is.null(pattern)) {
[17:39:40.612]                           computeRestarts <- base::computeRestarts
[17:39:40.612]                           grepl <- base::grepl
[17:39:40.612]                           restarts <- computeRestarts(cond)
[17:39:40.612]                           for (restart in restarts) {
[17:39:40.612]                             name <- restart$name
[17:39:40.612]                             if (is.null(name)) 
[17:39:40.612]                               next
[17:39:40.612]                             if (!grepl(pattern, name)) 
[17:39:40.612]                               next
[17:39:40.612]                             invokeRestart(restart)
[17:39:40.612]                             muffled <- TRUE
[17:39:40.612]                             break
[17:39:40.612]                           }
[17:39:40.612]                         }
[17:39:40.612]                       }
[17:39:40.612]                       invisible(muffled)
[17:39:40.612]                     }
[17:39:40.612]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.612]                   }
[17:39:40.612]                 }
[17:39:40.612]             }
[17:39:40.612]         }))
[17:39:40.612]     }, error = function(ex) {
[17:39:40.612]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.612]                 ...future.rng), started = ...future.startTime, 
[17:39:40.612]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.612]             version = "1.8"), class = "FutureResult")
[17:39:40.612]     }, finally = {
[17:39:40.612]         if (!identical(...future.workdir, getwd())) 
[17:39:40.612]             setwd(...future.workdir)
[17:39:40.612]         {
[17:39:40.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.612]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.612]             }
[17:39:40.612]             base::options(...future.oldOptions)
[17:39:40.612]             if (.Platform$OS.type == "windows") {
[17:39:40.612]                 old_names <- names(...future.oldEnvVars)
[17:39:40.612]                 envs <- base::Sys.getenv()
[17:39:40.612]                 names <- names(envs)
[17:39:40.612]                 common <- intersect(names, old_names)
[17:39:40.612]                 added <- setdiff(names, old_names)
[17:39:40.612]                 removed <- setdiff(old_names, names)
[17:39:40.612]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.612]                   envs[common]]
[17:39:40.612]                 NAMES <- toupper(changed)
[17:39:40.612]                 args <- list()
[17:39:40.612]                 for (kk in seq_along(NAMES)) {
[17:39:40.612]                   name <- changed[[kk]]
[17:39:40.612]                   NAME <- NAMES[[kk]]
[17:39:40.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.612]                     next
[17:39:40.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.612]                 }
[17:39:40.612]                 NAMES <- toupper(added)
[17:39:40.612]                 for (kk in seq_along(NAMES)) {
[17:39:40.612]                   name <- added[[kk]]
[17:39:40.612]                   NAME <- NAMES[[kk]]
[17:39:40.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.612]                     next
[17:39:40.612]                   args[[name]] <- ""
[17:39:40.612]                 }
[17:39:40.612]                 NAMES <- toupper(removed)
[17:39:40.612]                 for (kk in seq_along(NAMES)) {
[17:39:40.612]                   name <- removed[[kk]]
[17:39:40.612]                   NAME <- NAMES[[kk]]
[17:39:40.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.612]                     next
[17:39:40.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.612]                 }
[17:39:40.612]                 if (length(args) > 0) 
[17:39:40.612]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.612]             }
[17:39:40.612]             else {
[17:39:40.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.612]             }
[17:39:40.612]             {
[17:39:40.612]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.612]                   0L) {
[17:39:40.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.612]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.612]                   base::options(opts)
[17:39:40.612]                 }
[17:39:40.612]                 {
[17:39:40.612]                   {
[17:39:40.612]                     NULL
[17:39:40.612]                     RNGkind("Mersenne-Twister")
[17:39:40.612]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.612]                       inherits = FALSE)
[17:39:40.612]                   }
[17:39:40.612]                   options(future.plan = NULL)
[17:39:40.612]                   if (is.na(NA_character_)) 
[17:39:40.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.612]                     .init = FALSE)
[17:39:40.612]                 }
[17:39:40.612]             }
[17:39:40.612]         }
[17:39:40.612]     })
[17:39:40.612]     if (TRUE) {
[17:39:40.612]         base::sink(type = "output", split = FALSE)
[17:39:40.612]         if (TRUE) {
[17:39:40.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.612]         }
[17:39:40.612]         else {
[17:39:40.612]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.612]         }
[17:39:40.612]         base::close(...future.stdout)
[17:39:40.612]         ...future.stdout <- NULL
[17:39:40.612]     }
[17:39:40.612]     ...future.result$conditions <- ...future.conditions
[17:39:40.612]     ...future.result$finished <- base::Sys.time()
[17:39:40.612]     ...future.result
[17:39:40.612] }
[17:39:40.614] plan(): Setting new future strategy stack:
[17:39:40.614] List of future strategies:
[17:39:40.614] 1. sequential:
[17:39:40.614]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.614]    - tweaked: FALSE
[17:39:40.614]    - call: NULL
[17:39:40.614] plan(): nbrOfWorkers() = 1
[17:39:40.616] plan(): Setting new future strategy stack:
[17:39:40.616] List of future strategies:
[17:39:40.616] 1. sequential:
[17:39:40.616]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.616]    - tweaked: FALSE
[17:39:40.616]    - call: plan(strategy)
[17:39:40.616] plan(): nbrOfWorkers() = 1
[17:39:40.617] SequentialFuture started (and completed)
[17:39:40.617] - Launch lazy future ... done
[17:39:40.617] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:39:40.620] getGlobalsAndPackages() ...
[17:39:40.620] Searching for globals...
[17:39:40.622] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:39:40.622] Searching for globals ... DONE
[17:39:40.622] Resolving globals: FALSE
[17:39:40.622] 
[17:39:40.622] - packages: [2] ‘stats’, ‘datasets’
[17:39:40.622] getGlobalsAndPackages() ... DONE
[17:39:40.623] run() for ‘Future’ ...
[17:39:40.623] - state: ‘created’
[17:39:40.623] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.623] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.623]   - Field: ‘label’
[17:39:40.623]   - Field: ‘local’
[17:39:40.624]   - Field: ‘owner’
[17:39:40.624]   - Field: ‘envir’
[17:39:40.624]   - Field: ‘packages’
[17:39:40.624]   - Field: ‘gc’
[17:39:40.624]   - Field: ‘conditions’
[17:39:40.624]   - Field: ‘expr’
[17:39:40.624]   - Field: ‘uuid’
[17:39:40.624]   - Field: ‘seed’
[17:39:40.624]   - Field: ‘version’
[17:39:40.624]   - Field: ‘result’
[17:39:40.624]   - Field: ‘asynchronous’
[17:39:40.624]   - Field: ‘calls’
[17:39:40.625]   - Field: ‘globals’
[17:39:40.625]   - Field: ‘stdout’
[17:39:40.625]   - Field: ‘earlySignal’
[17:39:40.625]   - Field: ‘lazy’
[17:39:40.625]   - Field: ‘state’
[17:39:40.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.625] - Launch lazy future ...
[17:39:40.625] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:40.625] Packages needed by future strategies (n = 0): <none>
[17:39:40.626] {
[17:39:40.626]     {
[17:39:40.626]         {
[17:39:40.626]             ...future.startTime <- base::Sys.time()
[17:39:40.626]             {
[17:39:40.626]                 {
[17:39:40.626]                   {
[17:39:40.626]                     {
[17:39:40.626]                       base::local({
[17:39:40.626]                         has_future <- base::requireNamespace("future", 
[17:39:40.626]                           quietly = TRUE)
[17:39:40.626]                         if (has_future) {
[17:39:40.626]                           ns <- base::getNamespace("future")
[17:39:40.626]                           version <- ns[[".package"]][["version"]]
[17:39:40.626]                           if (is.null(version)) 
[17:39:40.626]                             version <- utils::packageVersion("future")
[17:39:40.626]                         }
[17:39:40.626]                         else {
[17:39:40.626]                           version <- NULL
[17:39:40.626]                         }
[17:39:40.626]                         if (!has_future || version < "1.8.0") {
[17:39:40.626]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.626]                             "", base::R.version$version.string), 
[17:39:40.626]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:40.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.626]                               "release", "version")], collapse = " "), 
[17:39:40.626]                             hostname = base::Sys.info()[["nodename"]])
[17:39:40.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.626]                             info)
[17:39:40.626]                           info <- base::paste(info, collapse = "; ")
[17:39:40.626]                           if (!has_future) {
[17:39:40.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.626]                               info)
[17:39:40.626]                           }
[17:39:40.626]                           else {
[17:39:40.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.626]                               info, version)
[17:39:40.626]                           }
[17:39:40.626]                           base::stop(msg)
[17:39:40.626]                         }
[17:39:40.626]                       })
[17:39:40.626]                     }
[17:39:40.626]                     base::local({
[17:39:40.626]                       for (pkg in c("stats", "datasets")) {
[17:39:40.626]                         base::loadNamespace(pkg)
[17:39:40.626]                         base::library(pkg, character.only = TRUE)
[17:39:40.626]                       }
[17:39:40.626]                     })
[17:39:40.626]                   }
[17:39:40.626]                   ...future.strategy.old <- future::plan("list")
[17:39:40.626]                   options(future.plan = NULL)
[17:39:40.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.626]                 }
[17:39:40.626]                 ...future.workdir <- getwd()
[17:39:40.626]             }
[17:39:40.626]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.626]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.626]         }
[17:39:40.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.626]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.626]             base::names(...future.oldOptions))
[17:39:40.626]     }
[17:39:40.626]     if (FALSE) {
[17:39:40.626]     }
[17:39:40.626]     else {
[17:39:40.626]         if (TRUE) {
[17:39:40.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.626]                 open = "w")
[17:39:40.626]         }
[17:39:40.626]         else {
[17:39:40.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.626]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.626]         }
[17:39:40.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.626]             base::sink(type = "output", split = FALSE)
[17:39:40.626]             base::close(...future.stdout)
[17:39:40.626]         }, add = TRUE)
[17:39:40.626]     }
[17:39:40.626]     ...future.frame <- base::sys.nframe()
[17:39:40.626]     ...future.conditions <- base::list()
[17:39:40.626]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.626]     if (FALSE) {
[17:39:40.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.626]     }
[17:39:40.626]     ...future.result <- base::tryCatch({
[17:39:40.626]         base::withCallingHandlers({
[17:39:40.626]             ...future.value <- base::withVisible(base::local({
[17:39:40.626]                 lm(dist ~ poly(speed, 2), data = cars)
[17:39:40.626]             }))
[17:39:40.626]             future::FutureResult(value = ...future.value$value, 
[17:39:40.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.626]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.626]                     ...future.globalenv.names))
[17:39:40.626]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.626]         }, condition = base::local({
[17:39:40.626]             c <- base::c
[17:39:40.626]             inherits <- base::inherits
[17:39:40.626]             invokeRestart <- base::invokeRestart
[17:39:40.626]             length <- base::length
[17:39:40.626]             list <- base::list
[17:39:40.626]             seq.int <- base::seq.int
[17:39:40.626]             signalCondition <- base::signalCondition
[17:39:40.626]             sys.calls <- base::sys.calls
[17:39:40.626]             `[[` <- base::`[[`
[17:39:40.626]             `+` <- base::`+`
[17:39:40.626]             `<<-` <- base::`<<-`
[17:39:40.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.626]                   3L)]
[17:39:40.626]             }
[17:39:40.626]             function(cond) {
[17:39:40.626]                 is_error <- inherits(cond, "error")
[17:39:40.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.626]                   NULL)
[17:39:40.626]                 if (is_error) {
[17:39:40.626]                   sessionInformation <- function() {
[17:39:40.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.626]                       search = base::search(), system = base::Sys.info())
[17:39:40.626]                   }
[17:39:40.626]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.626]                     cond$call), session = sessionInformation(), 
[17:39:40.626]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.626]                   signalCondition(cond)
[17:39:40.626]                 }
[17:39:40.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.626]                 "immediateCondition"))) {
[17:39:40.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.626]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.626]                   if (TRUE && !signal) {
[17:39:40.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.626]                     {
[17:39:40.626]                       inherits <- base::inherits
[17:39:40.626]                       invokeRestart <- base::invokeRestart
[17:39:40.626]                       is.null <- base::is.null
[17:39:40.626]                       muffled <- FALSE
[17:39:40.626]                       if (inherits(cond, "message")) {
[17:39:40.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.626]                         if (muffled) 
[17:39:40.626]                           invokeRestart("muffleMessage")
[17:39:40.626]                       }
[17:39:40.626]                       else if (inherits(cond, "warning")) {
[17:39:40.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.626]                         if (muffled) 
[17:39:40.626]                           invokeRestart("muffleWarning")
[17:39:40.626]                       }
[17:39:40.626]                       else if (inherits(cond, "condition")) {
[17:39:40.626]                         if (!is.null(pattern)) {
[17:39:40.626]                           computeRestarts <- base::computeRestarts
[17:39:40.626]                           grepl <- base::grepl
[17:39:40.626]                           restarts <- computeRestarts(cond)
[17:39:40.626]                           for (restart in restarts) {
[17:39:40.626]                             name <- restart$name
[17:39:40.626]                             if (is.null(name)) 
[17:39:40.626]                               next
[17:39:40.626]                             if (!grepl(pattern, name)) 
[17:39:40.626]                               next
[17:39:40.626]                             invokeRestart(restart)
[17:39:40.626]                             muffled <- TRUE
[17:39:40.626]                             break
[17:39:40.626]                           }
[17:39:40.626]                         }
[17:39:40.626]                       }
[17:39:40.626]                       invisible(muffled)
[17:39:40.626]                     }
[17:39:40.626]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.626]                   }
[17:39:40.626]                 }
[17:39:40.626]                 else {
[17:39:40.626]                   if (TRUE) {
[17:39:40.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.626]                     {
[17:39:40.626]                       inherits <- base::inherits
[17:39:40.626]                       invokeRestart <- base::invokeRestart
[17:39:40.626]                       is.null <- base::is.null
[17:39:40.626]                       muffled <- FALSE
[17:39:40.626]                       if (inherits(cond, "message")) {
[17:39:40.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.626]                         if (muffled) 
[17:39:40.626]                           invokeRestart("muffleMessage")
[17:39:40.626]                       }
[17:39:40.626]                       else if (inherits(cond, "warning")) {
[17:39:40.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.626]                         if (muffled) 
[17:39:40.626]                           invokeRestart("muffleWarning")
[17:39:40.626]                       }
[17:39:40.626]                       else if (inherits(cond, "condition")) {
[17:39:40.626]                         if (!is.null(pattern)) {
[17:39:40.626]                           computeRestarts <- base::computeRestarts
[17:39:40.626]                           grepl <- base::grepl
[17:39:40.626]                           restarts <- computeRestarts(cond)
[17:39:40.626]                           for (restart in restarts) {
[17:39:40.626]                             name <- restart$name
[17:39:40.626]                             if (is.null(name)) 
[17:39:40.626]                               next
[17:39:40.626]                             if (!grepl(pattern, name)) 
[17:39:40.626]                               next
[17:39:40.626]                             invokeRestart(restart)
[17:39:40.626]                             muffled <- TRUE
[17:39:40.626]                             break
[17:39:40.626]                           }
[17:39:40.626]                         }
[17:39:40.626]                       }
[17:39:40.626]                       invisible(muffled)
[17:39:40.626]                     }
[17:39:40.626]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.626]                   }
[17:39:40.626]                 }
[17:39:40.626]             }
[17:39:40.626]         }))
[17:39:40.626]     }, error = function(ex) {
[17:39:40.626]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.626]                 ...future.rng), started = ...future.startTime, 
[17:39:40.626]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.626]             version = "1.8"), class = "FutureResult")
[17:39:40.626]     }, finally = {
[17:39:40.626]         if (!identical(...future.workdir, getwd())) 
[17:39:40.626]             setwd(...future.workdir)
[17:39:40.626]         {
[17:39:40.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.626]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.626]             }
[17:39:40.626]             base::options(...future.oldOptions)
[17:39:40.626]             if (.Platform$OS.type == "windows") {
[17:39:40.626]                 old_names <- names(...future.oldEnvVars)
[17:39:40.626]                 envs <- base::Sys.getenv()
[17:39:40.626]                 names <- names(envs)
[17:39:40.626]                 common <- intersect(names, old_names)
[17:39:40.626]                 added <- setdiff(names, old_names)
[17:39:40.626]                 removed <- setdiff(old_names, names)
[17:39:40.626]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.626]                   envs[common]]
[17:39:40.626]                 NAMES <- toupper(changed)
[17:39:40.626]                 args <- list()
[17:39:40.626]                 for (kk in seq_along(NAMES)) {
[17:39:40.626]                   name <- changed[[kk]]
[17:39:40.626]                   NAME <- NAMES[[kk]]
[17:39:40.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.626]                     next
[17:39:40.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.626]                 }
[17:39:40.626]                 NAMES <- toupper(added)
[17:39:40.626]                 for (kk in seq_along(NAMES)) {
[17:39:40.626]                   name <- added[[kk]]
[17:39:40.626]                   NAME <- NAMES[[kk]]
[17:39:40.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.626]                     next
[17:39:40.626]                   args[[name]] <- ""
[17:39:40.626]                 }
[17:39:40.626]                 NAMES <- toupper(removed)
[17:39:40.626]                 for (kk in seq_along(NAMES)) {
[17:39:40.626]                   name <- removed[[kk]]
[17:39:40.626]                   NAME <- NAMES[[kk]]
[17:39:40.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.626]                     next
[17:39:40.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.626]                 }
[17:39:40.626]                 if (length(args) > 0) 
[17:39:40.626]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.626]             }
[17:39:40.626]             else {
[17:39:40.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.626]             }
[17:39:40.626]             {
[17:39:40.626]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.626]                   0L) {
[17:39:40.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.626]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.626]                   base::options(opts)
[17:39:40.626]                 }
[17:39:40.626]                 {
[17:39:40.626]                   {
[17:39:40.626]                     NULL
[17:39:40.626]                     RNGkind("Mersenne-Twister")
[17:39:40.626]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.626]                       inherits = FALSE)
[17:39:40.626]                   }
[17:39:40.626]                   options(future.plan = NULL)
[17:39:40.626]                   if (is.na(NA_character_)) 
[17:39:40.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.626]                     .init = FALSE)
[17:39:40.626]                 }
[17:39:40.626]             }
[17:39:40.626]         }
[17:39:40.626]     })
[17:39:40.626]     if (TRUE) {
[17:39:40.626]         base::sink(type = "output", split = FALSE)
[17:39:40.626]         if (TRUE) {
[17:39:40.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.626]         }
[17:39:40.626]         else {
[17:39:40.626]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.626]         }
[17:39:40.626]         base::close(...future.stdout)
[17:39:40.626]         ...future.stdout <- NULL
[17:39:40.626]     }
[17:39:40.626]     ...future.result$conditions <- ...future.conditions
[17:39:40.626]     ...future.result$finished <- base::Sys.time()
[17:39:40.626]     ...future.result
[17:39:40.626] }
[17:39:40.628] plan(): Setting new future strategy stack:
[17:39:40.628] List of future strategies:
[17:39:40.628] 1. sequential:
[17:39:40.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.628]    - tweaked: FALSE
[17:39:40.628]    - call: NULL
[17:39:40.628] plan(): nbrOfWorkers() = 1
[17:39:40.632] plan(): Setting new future strategy stack:
[17:39:40.632] List of future strategies:
[17:39:40.632] 1. sequential:
[17:39:40.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.632]    - tweaked: FALSE
[17:39:40.632]    - call: plan(strategy)
[17:39:40.632] plan(): nbrOfWorkers() = 1
[17:39:40.632] SequentialFuture started (and completed)
[17:39:40.632] - Launch lazy future ... done
[17:39:40.633] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:39:40.634] getGlobalsAndPackages() ...
[17:39:40.634] Searching for globals...
[17:39:40.639] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:39:40.639] Searching for globals ... DONE
[17:39:40.639] Resolving globals: FALSE
[17:39:40.640] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:39:40.640] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:39:40.640] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:39:40.641] 
[17:39:40.641] getGlobalsAndPackages() ... DONE
[17:39:40.641] run() for ‘Future’ ...
[17:39:40.641] - state: ‘created’
[17:39:40.641] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.642]   - Field: ‘label’
[17:39:40.642]   - Field: ‘local’
[17:39:40.642]   - Field: ‘owner’
[17:39:40.642]   - Field: ‘envir’
[17:39:40.642]   - Field: ‘packages’
[17:39:40.642]   - Field: ‘gc’
[17:39:40.642]   - Field: ‘conditions’
[17:39:40.642]   - Field: ‘expr’
[17:39:40.642]   - Field: ‘uuid’
[17:39:40.642]   - Field: ‘seed’
[17:39:40.642]   - Field: ‘version’
[17:39:40.643]   - Field: ‘result’
[17:39:40.643]   - Field: ‘asynchronous’
[17:39:40.643]   - Field: ‘calls’
[17:39:40.643]   - Field: ‘globals’
[17:39:40.643]   - Field: ‘stdout’
[17:39:40.643]   - Field: ‘earlySignal’
[17:39:40.643]   - Field: ‘lazy’
[17:39:40.643]   - Field: ‘state’
[17:39:40.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.643] - Launch lazy future ...
[17:39:40.644] Packages needed by the future expression (n = 0): <none>
[17:39:40.644] Packages needed by future strategies (n = 0): <none>
[17:39:40.644] {
[17:39:40.644]     {
[17:39:40.644]         {
[17:39:40.644]             ...future.startTime <- base::Sys.time()
[17:39:40.644]             {
[17:39:40.644]                 {
[17:39:40.644]                   {
[17:39:40.644]                     base::local({
[17:39:40.644]                       has_future <- base::requireNamespace("future", 
[17:39:40.644]                         quietly = TRUE)
[17:39:40.644]                       if (has_future) {
[17:39:40.644]                         ns <- base::getNamespace("future")
[17:39:40.644]                         version <- ns[[".package"]][["version"]]
[17:39:40.644]                         if (is.null(version)) 
[17:39:40.644]                           version <- utils::packageVersion("future")
[17:39:40.644]                       }
[17:39:40.644]                       else {
[17:39:40.644]                         version <- NULL
[17:39:40.644]                       }
[17:39:40.644]                       if (!has_future || version < "1.8.0") {
[17:39:40.644]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.644]                           "", base::R.version$version.string), 
[17:39:40.644]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:40.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.644]                             "release", "version")], collapse = " "), 
[17:39:40.644]                           hostname = base::Sys.info()[["nodename"]])
[17:39:40.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.644]                           info)
[17:39:40.644]                         info <- base::paste(info, collapse = "; ")
[17:39:40.644]                         if (!has_future) {
[17:39:40.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.644]                             info)
[17:39:40.644]                         }
[17:39:40.644]                         else {
[17:39:40.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.644]                             info, version)
[17:39:40.644]                         }
[17:39:40.644]                         base::stop(msg)
[17:39:40.644]                       }
[17:39:40.644]                     })
[17:39:40.644]                   }
[17:39:40.644]                   ...future.strategy.old <- future::plan("list")
[17:39:40.644]                   options(future.plan = NULL)
[17:39:40.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.644]                 }
[17:39:40.644]                 ...future.workdir <- getwd()
[17:39:40.644]             }
[17:39:40.644]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.644]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.644]         }
[17:39:40.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.644]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.644]             base::names(...future.oldOptions))
[17:39:40.644]     }
[17:39:40.644]     if (FALSE) {
[17:39:40.644]     }
[17:39:40.644]     else {
[17:39:40.644]         if (TRUE) {
[17:39:40.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.644]                 open = "w")
[17:39:40.644]         }
[17:39:40.644]         else {
[17:39:40.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.644]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.644]         }
[17:39:40.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.644]             base::sink(type = "output", split = FALSE)
[17:39:40.644]             base::close(...future.stdout)
[17:39:40.644]         }, add = TRUE)
[17:39:40.644]     }
[17:39:40.644]     ...future.frame <- base::sys.nframe()
[17:39:40.644]     ...future.conditions <- base::list()
[17:39:40.644]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.644]     if (FALSE) {
[17:39:40.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.644]     }
[17:39:40.644]     ...future.result <- base::tryCatch({
[17:39:40.644]         base::withCallingHandlers({
[17:39:40.644]             ...future.value <- base::withVisible(base::local({
[17:39:40.644]                 outer_function(1L)
[17:39:40.644]             }))
[17:39:40.644]             future::FutureResult(value = ...future.value$value, 
[17:39:40.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.644]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.644]                     ...future.globalenv.names))
[17:39:40.644]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.644]         }, condition = base::local({
[17:39:40.644]             c <- base::c
[17:39:40.644]             inherits <- base::inherits
[17:39:40.644]             invokeRestart <- base::invokeRestart
[17:39:40.644]             length <- base::length
[17:39:40.644]             list <- base::list
[17:39:40.644]             seq.int <- base::seq.int
[17:39:40.644]             signalCondition <- base::signalCondition
[17:39:40.644]             sys.calls <- base::sys.calls
[17:39:40.644]             `[[` <- base::`[[`
[17:39:40.644]             `+` <- base::`+`
[17:39:40.644]             `<<-` <- base::`<<-`
[17:39:40.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.644]                   3L)]
[17:39:40.644]             }
[17:39:40.644]             function(cond) {
[17:39:40.644]                 is_error <- inherits(cond, "error")
[17:39:40.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.644]                   NULL)
[17:39:40.644]                 if (is_error) {
[17:39:40.644]                   sessionInformation <- function() {
[17:39:40.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.644]                       search = base::search(), system = base::Sys.info())
[17:39:40.644]                   }
[17:39:40.644]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.644]                     cond$call), session = sessionInformation(), 
[17:39:40.644]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.644]                   signalCondition(cond)
[17:39:40.644]                 }
[17:39:40.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.644]                 "immediateCondition"))) {
[17:39:40.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.644]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.644]                   if (TRUE && !signal) {
[17:39:40.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.644]                     {
[17:39:40.644]                       inherits <- base::inherits
[17:39:40.644]                       invokeRestart <- base::invokeRestart
[17:39:40.644]                       is.null <- base::is.null
[17:39:40.644]                       muffled <- FALSE
[17:39:40.644]                       if (inherits(cond, "message")) {
[17:39:40.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.644]                         if (muffled) 
[17:39:40.644]                           invokeRestart("muffleMessage")
[17:39:40.644]                       }
[17:39:40.644]                       else if (inherits(cond, "warning")) {
[17:39:40.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.644]                         if (muffled) 
[17:39:40.644]                           invokeRestart("muffleWarning")
[17:39:40.644]                       }
[17:39:40.644]                       else if (inherits(cond, "condition")) {
[17:39:40.644]                         if (!is.null(pattern)) {
[17:39:40.644]                           computeRestarts <- base::computeRestarts
[17:39:40.644]                           grepl <- base::grepl
[17:39:40.644]                           restarts <- computeRestarts(cond)
[17:39:40.644]                           for (restart in restarts) {
[17:39:40.644]                             name <- restart$name
[17:39:40.644]                             if (is.null(name)) 
[17:39:40.644]                               next
[17:39:40.644]                             if (!grepl(pattern, name)) 
[17:39:40.644]                               next
[17:39:40.644]                             invokeRestart(restart)
[17:39:40.644]                             muffled <- TRUE
[17:39:40.644]                             break
[17:39:40.644]                           }
[17:39:40.644]                         }
[17:39:40.644]                       }
[17:39:40.644]                       invisible(muffled)
[17:39:40.644]                     }
[17:39:40.644]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.644]                   }
[17:39:40.644]                 }
[17:39:40.644]                 else {
[17:39:40.644]                   if (TRUE) {
[17:39:40.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.644]                     {
[17:39:40.644]                       inherits <- base::inherits
[17:39:40.644]                       invokeRestart <- base::invokeRestart
[17:39:40.644]                       is.null <- base::is.null
[17:39:40.644]                       muffled <- FALSE
[17:39:40.644]                       if (inherits(cond, "message")) {
[17:39:40.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.644]                         if (muffled) 
[17:39:40.644]                           invokeRestart("muffleMessage")
[17:39:40.644]                       }
[17:39:40.644]                       else if (inherits(cond, "warning")) {
[17:39:40.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.644]                         if (muffled) 
[17:39:40.644]                           invokeRestart("muffleWarning")
[17:39:40.644]                       }
[17:39:40.644]                       else if (inherits(cond, "condition")) {
[17:39:40.644]                         if (!is.null(pattern)) {
[17:39:40.644]                           computeRestarts <- base::computeRestarts
[17:39:40.644]                           grepl <- base::grepl
[17:39:40.644]                           restarts <- computeRestarts(cond)
[17:39:40.644]                           for (restart in restarts) {
[17:39:40.644]                             name <- restart$name
[17:39:40.644]                             if (is.null(name)) 
[17:39:40.644]                               next
[17:39:40.644]                             if (!grepl(pattern, name)) 
[17:39:40.644]                               next
[17:39:40.644]                             invokeRestart(restart)
[17:39:40.644]                             muffled <- TRUE
[17:39:40.644]                             break
[17:39:40.644]                           }
[17:39:40.644]                         }
[17:39:40.644]                       }
[17:39:40.644]                       invisible(muffled)
[17:39:40.644]                     }
[17:39:40.644]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.644]                   }
[17:39:40.644]                 }
[17:39:40.644]             }
[17:39:40.644]         }))
[17:39:40.644]     }, error = function(ex) {
[17:39:40.644]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.644]                 ...future.rng), started = ...future.startTime, 
[17:39:40.644]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.644]             version = "1.8"), class = "FutureResult")
[17:39:40.644]     }, finally = {
[17:39:40.644]         if (!identical(...future.workdir, getwd())) 
[17:39:40.644]             setwd(...future.workdir)
[17:39:40.644]         {
[17:39:40.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.644]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.644]             }
[17:39:40.644]             base::options(...future.oldOptions)
[17:39:40.644]             if (.Platform$OS.type == "windows") {
[17:39:40.644]                 old_names <- names(...future.oldEnvVars)
[17:39:40.644]                 envs <- base::Sys.getenv()
[17:39:40.644]                 names <- names(envs)
[17:39:40.644]                 common <- intersect(names, old_names)
[17:39:40.644]                 added <- setdiff(names, old_names)
[17:39:40.644]                 removed <- setdiff(old_names, names)
[17:39:40.644]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.644]                   envs[common]]
[17:39:40.644]                 NAMES <- toupper(changed)
[17:39:40.644]                 args <- list()
[17:39:40.644]                 for (kk in seq_along(NAMES)) {
[17:39:40.644]                   name <- changed[[kk]]
[17:39:40.644]                   NAME <- NAMES[[kk]]
[17:39:40.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.644]                     next
[17:39:40.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.644]                 }
[17:39:40.644]                 NAMES <- toupper(added)
[17:39:40.644]                 for (kk in seq_along(NAMES)) {
[17:39:40.644]                   name <- added[[kk]]
[17:39:40.644]                   NAME <- NAMES[[kk]]
[17:39:40.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.644]                     next
[17:39:40.644]                   args[[name]] <- ""
[17:39:40.644]                 }
[17:39:40.644]                 NAMES <- toupper(removed)
[17:39:40.644]                 for (kk in seq_along(NAMES)) {
[17:39:40.644]                   name <- removed[[kk]]
[17:39:40.644]                   NAME <- NAMES[[kk]]
[17:39:40.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.644]                     next
[17:39:40.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.644]                 }
[17:39:40.644]                 if (length(args) > 0) 
[17:39:40.644]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.644]             }
[17:39:40.644]             else {
[17:39:40.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.644]             }
[17:39:40.644]             {
[17:39:40.644]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.644]                   0L) {
[17:39:40.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.644]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.644]                   base::options(opts)
[17:39:40.644]                 }
[17:39:40.644]                 {
[17:39:40.644]                   {
[17:39:40.644]                     NULL
[17:39:40.644]                     RNGkind("Mersenne-Twister")
[17:39:40.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.644]                       inherits = FALSE)
[17:39:40.644]                   }
[17:39:40.644]                   options(future.plan = NULL)
[17:39:40.644]                   if (is.na(NA_character_)) 
[17:39:40.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.644]                     .init = FALSE)
[17:39:40.644]                 }
[17:39:40.644]             }
[17:39:40.644]         }
[17:39:40.644]     })
[17:39:40.644]     if (TRUE) {
[17:39:40.644]         base::sink(type = "output", split = FALSE)
[17:39:40.644]         if (TRUE) {
[17:39:40.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.644]         }
[17:39:40.644]         else {
[17:39:40.644]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.644]         }
[17:39:40.644]         base::close(...future.stdout)
[17:39:40.644]         ...future.stdout <- NULL
[17:39:40.644]     }
[17:39:40.644]     ...future.result$conditions <- ...future.conditions
[17:39:40.644]     ...future.result$finished <- base::Sys.time()
[17:39:40.644]     ...future.result
[17:39:40.644] }
[17:39:40.646] assign_globals() ...
[17:39:40.646] List of 3
[17:39:40.646]  $ outer_function:function (x)  
[17:39:40.646]  $ map           :function (.x, .f, ...)  
[17:39:40.646]  $ inner_function:function (x)  
[17:39:40.646]  - attr(*, "where")=List of 3
[17:39:40.646]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:39:40.646]   ..$ map           :<environment: R_EmptyEnv> 
[17:39:40.646]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:39:40.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.646]  - attr(*, "resolved")= logi FALSE
[17:39:40.646]  - attr(*, "total_size")= num 7704
[17:39:40.646]  - attr(*, "already-done")= logi TRUE
[17:39:40.649] - reassign environment for ‘outer_function’
[17:39:40.649] - copied ‘outer_function’ to environment
[17:39:40.649] - reassign environment for ‘map’
[17:39:40.649] - copied ‘map’ to environment
[17:39:40.649] - reassign environment for ‘inner_function’
[17:39:40.650] - copied ‘inner_function’ to environment
[17:39:40.650] assign_globals() ... done
[17:39:40.650] plan(): Setting new future strategy stack:
[17:39:40.650] List of future strategies:
[17:39:40.650] 1. sequential:
[17:39:40.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.650]    - tweaked: FALSE
[17:39:40.650]    - call: NULL
[17:39:40.650] plan(): nbrOfWorkers() = 1
[17:39:40.657] plan(): Setting new future strategy stack:
[17:39:40.658] List of future strategies:
[17:39:40.658] 1. sequential:
[17:39:40.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.658]    - tweaked: FALSE
[17:39:40.658]    - call: plan(strategy)
[17:39:40.658] plan(): nbrOfWorkers() = 1
[17:39:40.658] SequentialFuture started (and completed)
[17:39:40.658] - Launch lazy future ... done
[17:39:40.658] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:39:40.660] getGlobalsAndPackages() ...
[17:39:40.660] Searching for globals...
[17:39:40.664] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:39:40.664] Searching for globals ... DONE
[17:39:40.664] Resolving globals: FALSE
[17:39:40.665] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:39:40.665] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:39:40.665] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:39:40.665] 
[17:39:40.665] getGlobalsAndPackages() ... DONE
[17:39:40.665] run() for ‘Future’ ...
[17:39:40.666] - state: ‘created’
[17:39:40.666] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:40.666] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:40.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:40.666]   - Field: ‘label’
[17:39:40.666]   - Field: ‘local’
[17:39:40.666]   - Field: ‘owner’
[17:39:40.666]   - Field: ‘envir’
[17:39:40.667]   - Field: ‘packages’
[17:39:40.667]   - Field: ‘gc’
[17:39:40.667]   - Field: ‘conditions’
[17:39:40.667]   - Field: ‘expr’
[17:39:40.667]   - Field: ‘uuid’
[17:39:40.667]   - Field: ‘seed’
[17:39:40.667]   - Field: ‘version’
[17:39:40.667]   - Field: ‘result’
[17:39:40.667]   - Field: ‘asynchronous’
[17:39:40.667]   - Field: ‘calls’
[17:39:40.667]   - Field: ‘globals’
[17:39:40.668]   - Field: ‘stdout’
[17:39:40.668]   - Field: ‘earlySignal’
[17:39:40.668]   - Field: ‘lazy’
[17:39:40.668]   - Field: ‘state’
[17:39:40.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:40.668] - Launch lazy future ...
[17:39:40.668] Packages needed by the future expression (n = 0): <none>
[17:39:40.668] Packages needed by future strategies (n = 0): <none>
[17:39:40.669] {
[17:39:40.669]     {
[17:39:40.669]         {
[17:39:40.669]             ...future.startTime <- base::Sys.time()
[17:39:40.669]             {
[17:39:40.669]                 {
[17:39:40.669]                   {
[17:39:40.669]                     base::local({
[17:39:40.669]                       has_future <- base::requireNamespace("future", 
[17:39:40.669]                         quietly = TRUE)
[17:39:40.669]                       if (has_future) {
[17:39:40.669]                         ns <- base::getNamespace("future")
[17:39:40.669]                         version <- ns[[".package"]][["version"]]
[17:39:40.669]                         if (is.null(version)) 
[17:39:40.669]                           version <- utils::packageVersion("future")
[17:39:40.669]                       }
[17:39:40.669]                       else {
[17:39:40.669]                         version <- NULL
[17:39:40.669]                       }
[17:39:40.669]                       if (!has_future || version < "1.8.0") {
[17:39:40.669]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.669]                           "", base::R.version$version.string), 
[17:39:40.669]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:40.669]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:40.669]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.669]                             "release", "version")], collapse = " "), 
[17:39:40.669]                           hostname = base::Sys.info()[["nodename"]])
[17:39:40.669]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.669]                           info)
[17:39:40.669]                         info <- base::paste(info, collapse = "; ")
[17:39:40.669]                         if (!has_future) {
[17:39:40.669]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.669]                             info)
[17:39:40.669]                         }
[17:39:40.669]                         else {
[17:39:40.669]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.669]                             info, version)
[17:39:40.669]                         }
[17:39:40.669]                         base::stop(msg)
[17:39:40.669]                       }
[17:39:40.669]                     })
[17:39:40.669]                   }
[17:39:40.669]                   ...future.strategy.old <- future::plan("list")
[17:39:40.669]                   options(future.plan = NULL)
[17:39:40.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.669]                 }
[17:39:40.669]                 ...future.workdir <- getwd()
[17:39:40.669]             }
[17:39:40.669]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.669]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.669]         }
[17:39:40.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.669]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.669]             base::names(...future.oldOptions))
[17:39:40.669]     }
[17:39:40.669]     if (FALSE) {
[17:39:40.669]     }
[17:39:40.669]     else {
[17:39:40.669]         if (TRUE) {
[17:39:40.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.669]                 open = "w")
[17:39:40.669]         }
[17:39:40.669]         else {
[17:39:40.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.669]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.669]         }
[17:39:40.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.669]             base::sink(type = "output", split = FALSE)
[17:39:40.669]             base::close(...future.stdout)
[17:39:40.669]         }, add = TRUE)
[17:39:40.669]     }
[17:39:40.669]     ...future.frame <- base::sys.nframe()
[17:39:40.669]     ...future.conditions <- base::list()
[17:39:40.669]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.669]     if (FALSE) {
[17:39:40.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.669]     }
[17:39:40.669]     ...future.result <- base::tryCatch({
[17:39:40.669]         base::withCallingHandlers({
[17:39:40.669]             ...future.value <- base::withVisible(base::local({
[17:39:40.669]                 outer_function(1L)
[17:39:40.669]             }))
[17:39:40.669]             future::FutureResult(value = ...future.value$value, 
[17:39:40.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.669]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.669]                     ...future.globalenv.names))
[17:39:40.669]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.669]         }, condition = base::local({
[17:39:40.669]             c <- base::c
[17:39:40.669]             inherits <- base::inherits
[17:39:40.669]             invokeRestart <- base::invokeRestart
[17:39:40.669]             length <- base::length
[17:39:40.669]             list <- base::list
[17:39:40.669]             seq.int <- base::seq.int
[17:39:40.669]             signalCondition <- base::signalCondition
[17:39:40.669]             sys.calls <- base::sys.calls
[17:39:40.669]             `[[` <- base::`[[`
[17:39:40.669]             `+` <- base::`+`
[17:39:40.669]             `<<-` <- base::`<<-`
[17:39:40.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.669]                   3L)]
[17:39:40.669]             }
[17:39:40.669]             function(cond) {
[17:39:40.669]                 is_error <- inherits(cond, "error")
[17:39:40.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.669]                   NULL)
[17:39:40.669]                 if (is_error) {
[17:39:40.669]                   sessionInformation <- function() {
[17:39:40.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.669]                       search = base::search(), system = base::Sys.info())
[17:39:40.669]                   }
[17:39:40.669]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.669]                     cond$call), session = sessionInformation(), 
[17:39:40.669]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.669]                   signalCondition(cond)
[17:39:40.669]                 }
[17:39:40.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.669]                 "immediateCondition"))) {
[17:39:40.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.669]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.669]                   if (TRUE && !signal) {
[17:39:40.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.669]                     {
[17:39:40.669]                       inherits <- base::inherits
[17:39:40.669]                       invokeRestart <- base::invokeRestart
[17:39:40.669]                       is.null <- base::is.null
[17:39:40.669]                       muffled <- FALSE
[17:39:40.669]                       if (inherits(cond, "message")) {
[17:39:40.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.669]                         if (muffled) 
[17:39:40.669]                           invokeRestart("muffleMessage")
[17:39:40.669]                       }
[17:39:40.669]                       else if (inherits(cond, "warning")) {
[17:39:40.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.669]                         if (muffled) 
[17:39:40.669]                           invokeRestart("muffleWarning")
[17:39:40.669]                       }
[17:39:40.669]                       else if (inherits(cond, "condition")) {
[17:39:40.669]                         if (!is.null(pattern)) {
[17:39:40.669]                           computeRestarts <- base::computeRestarts
[17:39:40.669]                           grepl <- base::grepl
[17:39:40.669]                           restarts <- computeRestarts(cond)
[17:39:40.669]                           for (restart in restarts) {
[17:39:40.669]                             name <- restart$name
[17:39:40.669]                             if (is.null(name)) 
[17:39:40.669]                               next
[17:39:40.669]                             if (!grepl(pattern, name)) 
[17:39:40.669]                               next
[17:39:40.669]                             invokeRestart(restart)
[17:39:40.669]                             muffled <- TRUE
[17:39:40.669]                             break
[17:39:40.669]                           }
[17:39:40.669]                         }
[17:39:40.669]                       }
[17:39:40.669]                       invisible(muffled)
[17:39:40.669]                     }
[17:39:40.669]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.669]                   }
[17:39:40.669]                 }
[17:39:40.669]                 else {
[17:39:40.669]                   if (TRUE) {
[17:39:40.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.669]                     {
[17:39:40.669]                       inherits <- base::inherits
[17:39:40.669]                       invokeRestart <- base::invokeRestart
[17:39:40.669]                       is.null <- base::is.null
[17:39:40.669]                       muffled <- FALSE
[17:39:40.669]                       if (inherits(cond, "message")) {
[17:39:40.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.669]                         if (muffled) 
[17:39:40.669]                           invokeRestart("muffleMessage")
[17:39:40.669]                       }
[17:39:40.669]                       else if (inherits(cond, "warning")) {
[17:39:40.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.669]                         if (muffled) 
[17:39:40.669]                           invokeRestart("muffleWarning")
[17:39:40.669]                       }
[17:39:40.669]                       else if (inherits(cond, "condition")) {
[17:39:40.669]                         if (!is.null(pattern)) {
[17:39:40.669]                           computeRestarts <- base::computeRestarts
[17:39:40.669]                           grepl <- base::grepl
[17:39:40.669]                           restarts <- computeRestarts(cond)
[17:39:40.669]                           for (restart in restarts) {
[17:39:40.669]                             name <- restart$name
[17:39:40.669]                             if (is.null(name)) 
[17:39:40.669]                               next
[17:39:40.669]                             if (!grepl(pattern, name)) 
[17:39:40.669]                               next
[17:39:40.669]                             invokeRestart(restart)
[17:39:40.669]                             muffled <- TRUE
[17:39:40.669]                             break
[17:39:40.669]                           }
[17:39:40.669]                         }
[17:39:40.669]                       }
[17:39:40.669]                       invisible(muffled)
[17:39:40.669]                     }
[17:39:40.669]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.669]                   }
[17:39:40.669]                 }
[17:39:40.669]             }
[17:39:40.669]         }))
[17:39:40.669]     }, error = function(ex) {
[17:39:40.669]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.669]                 ...future.rng), started = ...future.startTime, 
[17:39:40.669]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.669]             version = "1.8"), class = "FutureResult")
[17:39:40.669]     }, finally = {
[17:39:40.669]         if (!identical(...future.workdir, getwd())) 
[17:39:40.669]             setwd(...future.workdir)
[17:39:40.669]         {
[17:39:40.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.669]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.669]             }
[17:39:40.669]             base::options(...future.oldOptions)
[17:39:40.669]             if (.Platform$OS.type == "windows") {
[17:39:40.669]                 old_names <- names(...future.oldEnvVars)
[17:39:40.669]                 envs <- base::Sys.getenv()
[17:39:40.669]                 names <- names(envs)
[17:39:40.669]                 common <- intersect(names, old_names)
[17:39:40.669]                 added <- setdiff(names, old_names)
[17:39:40.669]                 removed <- setdiff(old_names, names)
[17:39:40.669]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.669]                   envs[common]]
[17:39:40.669]                 NAMES <- toupper(changed)
[17:39:40.669]                 args <- list()
[17:39:40.669]                 for (kk in seq_along(NAMES)) {
[17:39:40.669]                   name <- changed[[kk]]
[17:39:40.669]                   NAME <- NAMES[[kk]]
[17:39:40.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.669]                     next
[17:39:40.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.669]                 }
[17:39:40.669]                 NAMES <- toupper(added)
[17:39:40.669]                 for (kk in seq_along(NAMES)) {
[17:39:40.669]                   name <- added[[kk]]
[17:39:40.669]                   NAME <- NAMES[[kk]]
[17:39:40.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.669]                     next
[17:39:40.669]                   args[[name]] <- ""
[17:39:40.669]                 }
[17:39:40.669]                 NAMES <- toupper(removed)
[17:39:40.669]                 for (kk in seq_along(NAMES)) {
[17:39:40.669]                   name <- removed[[kk]]
[17:39:40.669]                   NAME <- NAMES[[kk]]
[17:39:40.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.669]                     next
[17:39:40.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.669]                 }
[17:39:40.669]                 if (length(args) > 0) 
[17:39:40.669]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.669]             }
[17:39:40.669]             else {
[17:39:40.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.669]             }
[17:39:40.669]             {
[17:39:40.669]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.669]                   0L) {
[17:39:40.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.669]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.669]                   base::options(opts)
[17:39:40.669]                 }
[17:39:40.669]                 {
[17:39:40.669]                   {
[17:39:40.669]                     NULL
[17:39:40.669]                     RNGkind("Mersenne-Twister")
[17:39:40.669]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:40.669]                       inherits = FALSE)
[17:39:40.669]                   }
[17:39:40.669]                   options(future.plan = NULL)
[17:39:40.669]                   if (is.na(NA_character_)) 
[17:39:40.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.669]                     .init = FALSE)
[17:39:40.669]                 }
[17:39:40.669]             }
[17:39:40.669]         }
[17:39:40.669]     })
[17:39:40.669]     if (TRUE) {
[17:39:40.669]         base::sink(type = "output", split = FALSE)
[17:39:40.669]         if (TRUE) {
[17:39:40.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.669]         }
[17:39:40.669]         else {
[17:39:40.669]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.669]         }
[17:39:40.669]         base::close(...future.stdout)
[17:39:40.669]         ...future.stdout <- NULL
[17:39:40.669]     }
[17:39:40.669]     ...future.result$conditions <- ...future.conditions
[17:39:40.669]     ...future.result$finished <- base::Sys.time()
[17:39:40.669]     ...future.result
[17:39:40.669] }
[17:39:40.670] assign_globals() ...
[17:39:40.670] List of 3
[17:39:40.670]  $ outer_function:function (x)  
[17:39:40.670]  $ map           :function (.x, .f, ...)  
[17:39:40.670]  $ inner_function:function (x)  
[17:39:40.670]  - attr(*, "where")=List of 3
[17:39:40.670]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:39:40.670]   ..$ map           :<environment: R_EmptyEnv> 
[17:39:40.670]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:39:40.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.670]  - attr(*, "resolved")= logi FALSE
[17:39:40.670]  - attr(*, "total_size")= num 7704
[17:39:40.670]  - attr(*, "already-done")= logi TRUE
[17:39:40.673] - reassign environment for ‘outer_function’
[17:39:40.673] - copied ‘outer_function’ to environment
[17:39:40.674] - reassign environment for ‘map’
[17:39:40.674] - copied ‘map’ to environment
[17:39:40.674] - reassign environment for ‘inner_function’
[17:39:40.674] - copied ‘inner_function’ to environment
[17:39:40.674] assign_globals() ... done
[17:39:40.674] plan(): Setting new future strategy stack:
[17:39:40.674] List of future strategies:
[17:39:40.674] 1. sequential:
[17:39:40.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.674]    - tweaked: FALSE
[17:39:40.674]    - call: NULL
[17:39:40.675] plan(): nbrOfWorkers() = 1
[17:39:40.675] plan(): Setting new future strategy stack:
[17:39:40.676] List of future strategies:
[17:39:40.676] 1. sequential:
[17:39:40.676]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.676]    - tweaked: FALSE
[17:39:40.676]    - call: plan(strategy)
[17:39:40.676] plan(): nbrOfWorkers() = 1
[17:39:40.676] SequentialFuture started (and completed)
[17:39:40.676] - Launch lazy future ... done
[17:39:40.676] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:39:40.688] plan(): Setting new future strategy stack:
[17:39:40.688] List of future strategies:
[17:39:40.688] 1. multicore:
[17:39:40.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.688]    - tweaked: FALSE
[17:39:40.688]    - call: plan(strategy)
[17:39:40.691] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[17:39:40.692] getGlobalsAndPackages() ...
[17:39:40.692] Searching for globals...
[17:39:40.693] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.693] Searching for globals ... DONE
[17:39:40.693] Resolving globals: FALSE
[17:39:40.694] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.694] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.694] - globals: [2] ‘weight’, ‘group’
[17:39:40.694] - packages: [1] ‘stats’
[17:39:40.695] getGlobalsAndPackages() ... DONE
[17:39:40.695] run() for ‘Future’ ...
[17:39:40.695] - state: ‘created’
[17:39:40.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.698] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.699]   - Field: ‘label’
[17:39:40.699]   - Field: ‘local’
[17:39:40.699]   - Field: ‘owner’
[17:39:40.699]   - Field: ‘envir’
[17:39:40.699]   - Field: ‘workers’
[17:39:40.699]   - Field: ‘packages’
[17:39:40.699]   - Field: ‘gc’
[17:39:40.699]   - Field: ‘job’
[17:39:40.699]   - Field: ‘conditions’
[17:39:40.700]   - Field: ‘expr’
[17:39:40.700]   - Field: ‘uuid’
[17:39:40.700]   - Field: ‘seed’
[17:39:40.700]   - Field: ‘version’
[17:39:40.700]   - Field: ‘result’
[17:39:40.700]   - Field: ‘asynchronous’
[17:39:40.700]   - Field: ‘calls’
[17:39:40.700]   - Field: ‘globals’
[17:39:40.700]   - Field: ‘stdout’
[17:39:40.700]   - Field: ‘earlySignal’
[17:39:40.700]   - Field: ‘lazy’
[17:39:40.701]   - Field: ‘state’
[17:39:40.701] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.701] - Launch lazy future ...
[17:39:40.702] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.702] Packages needed by future strategies (n = 0): <none>
[17:39:40.702] {
[17:39:40.702]     {
[17:39:40.702]         {
[17:39:40.702]             ...future.startTime <- base::Sys.time()
[17:39:40.702]             {
[17:39:40.702]                 {
[17:39:40.702]                   {
[17:39:40.702]                     {
[17:39:40.702]                       {
[17:39:40.702]                         base::local({
[17:39:40.702]                           has_future <- base::requireNamespace("future", 
[17:39:40.702]                             quietly = TRUE)
[17:39:40.702]                           if (has_future) {
[17:39:40.702]                             ns <- base::getNamespace("future")
[17:39:40.702]                             version <- ns[[".package"]][["version"]]
[17:39:40.702]                             if (is.null(version)) 
[17:39:40.702]                               version <- utils::packageVersion("future")
[17:39:40.702]                           }
[17:39:40.702]                           else {
[17:39:40.702]                             version <- NULL
[17:39:40.702]                           }
[17:39:40.702]                           if (!has_future || version < "1.8.0") {
[17:39:40.702]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.702]                               "", base::R.version$version.string), 
[17:39:40.702]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.702]                                 base::R.version$platform, 8 * 
[17:39:40.702]                                   base::.Machine$sizeof.pointer), 
[17:39:40.702]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.702]                                 "release", "version")], collapse = " "), 
[17:39:40.702]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.702]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.702]                               info)
[17:39:40.702]                             info <- base::paste(info, collapse = "; ")
[17:39:40.702]                             if (!has_future) {
[17:39:40.702]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.702]                                 info)
[17:39:40.702]                             }
[17:39:40.702]                             else {
[17:39:40.702]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.702]                                 info, version)
[17:39:40.702]                             }
[17:39:40.702]                             base::stop(msg)
[17:39:40.702]                           }
[17:39:40.702]                         })
[17:39:40.702]                       }
[17:39:40.702]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.702]                       base::options(mc.cores = 1L)
[17:39:40.702]                     }
[17:39:40.702]                     base::local({
[17:39:40.702]                       for (pkg in "stats") {
[17:39:40.702]                         base::loadNamespace(pkg)
[17:39:40.702]                         base::library(pkg, character.only = TRUE)
[17:39:40.702]                       }
[17:39:40.702]                     })
[17:39:40.702]                   }
[17:39:40.702]                   ...future.strategy.old <- future::plan("list")
[17:39:40.702]                   options(future.plan = NULL)
[17:39:40.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.702]                 }
[17:39:40.702]                 ...future.workdir <- getwd()
[17:39:40.702]             }
[17:39:40.702]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.702]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.702]         }
[17:39:40.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.702]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.702]             base::names(...future.oldOptions))
[17:39:40.702]     }
[17:39:40.702]     if (FALSE) {
[17:39:40.702]     }
[17:39:40.702]     else {
[17:39:40.702]         if (TRUE) {
[17:39:40.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.702]                 open = "w")
[17:39:40.702]         }
[17:39:40.702]         else {
[17:39:40.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.702]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.702]         }
[17:39:40.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.702]             base::sink(type = "output", split = FALSE)
[17:39:40.702]             base::close(...future.stdout)
[17:39:40.702]         }, add = TRUE)
[17:39:40.702]     }
[17:39:40.702]     ...future.frame <- base::sys.nframe()
[17:39:40.702]     ...future.conditions <- base::list()
[17:39:40.702]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.702]     if (FALSE) {
[17:39:40.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.702]     }
[17:39:40.702]     ...future.result <- base::tryCatch({
[17:39:40.702]         base::withCallingHandlers({
[17:39:40.702]             ...future.value <- base::withVisible(base::local({
[17:39:40.702]                 withCallingHandlers({
[17:39:40.702]                   {
[17:39:40.702]                     lm(weight ~ group - 1)
[17:39:40.702]                   }
[17:39:40.702]                 }, immediateCondition = function(cond) {
[17:39:40.702]                   save_rds <- function (object, pathname, ...) 
[17:39:40.702]                   {
[17:39:40.702]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.702]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.702]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.702]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.702]                         fi_tmp[["mtime"]])
[17:39:40.702]                     }
[17:39:40.702]                     tryCatch({
[17:39:40.702]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.702]                     }, error = function(ex) {
[17:39:40.702]                       msg <- conditionMessage(ex)
[17:39:40.702]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.702]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.702]                         fi_tmp[["mtime"]], msg)
[17:39:40.702]                       ex$message <- msg
[17:39:40.702]                       stop(ex)
[17:39:40.702]                     })
[17:39:40.702]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.702]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.702]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.702]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.702]                       fi <- file.info(pathname)
[17:39:40.702]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.702]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.702]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.702]                         fi[["size"]], fi[["mtime"]])
[17:39:40.702]                       stop(msg)
[17:39:40.702]                     }
[17:39:40.702]                     invisible(pathname)
[17:39:40.702]                   }
[17:39:40.702]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.702]                     rootPath = tempdir()) 
[17:39:40.702]                   {
[17:39:40.702]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.702]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.702]                       tmpdir = path, fileext = ".rds")
[17:39:40.702]                     save_rds(obj, file)
[17:39:40.702]                   }
[17:39:40.702]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.702]                   {
[17:39:40.702]                     inherits <- base::inherits
[17:39:40.702]                     invokeRestart <- base::invokeRestart
[17:39:40.702]                     is.null <- base::is.null
[17:39:40.702]                     muffled <- FALSE
[17:39:40.702]                     if (inherits(cond, "message")) {
[17:39:40.702]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.702]                       if (muffled) 
[17:39:40.702]                         invokeRestart("muffleMessage")
[17:39:40.702]                     }
[17:39:40.702]                     else if (inherits(cond, "warning")) {
[17:39:40.702]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.702]                       if (muffled) 
[17:39:40.702]                         invokeRestart("muffleWarning")
[17:39:40.702]                     }
[17:39:40.702]                     else if (inherits(cond, "condition")) {
[17:39:40.702]                       if (!is.null(pattern)) {
[17:39:40.702]                         computeRestarts <- base::computeRestarts
[17:39:40.702]                         grepl <- base::grepl
[17:39:40.702]                         restarts <- computeRestarts(cond)
[17:39:40.702]                         for (restart in restarts) {
[17:39:40.702]                           name <- restart$name
[17:39:40.702]                           if (is.null(name)) 
[17:39:40.702]                             next
[17:39:40.702]                           if (!grepl(pattern, name)) 
[17:39:40.702]                             next
[17:39:40.702]                           invokeRestart(restart)
[17:39:40.702]                           muffled <- TRUE
[17:39:40.702]                           break
[17:39:40.702]                         }
[17:39:40.702]                       }
[17:39:40.702]                     }
[17:39:40.702]                     invisible(muffled)
[17:39:40.702]                   }
[17:39:40.702]                   muffleCondition(cond)
[17:39:40.702]                 })
[17:39:40.702]             }))
[17:39:40.702]             future::FutureResult(value = ...future.value$value, 
[17:39:40.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.702]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.702]                     ...future.globalenv.names))
[17:39:40.702]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.702]         }, condition = base::local({
[17:39:40.702]             c <- base::c
[17:39:40.702]             inherits <- base::inherits
[17:39:40.702]             invokeRestart <- base::invokeRestart
[17:39:40.702]             length <- base::length
[17:39:40.702]             list <- base::list
[17:39:40.702]             seq.int <- base::seq.int
[17:39:40.702]             signalCondition <- base::signalCondition
[17:39:40.702]             sys.calls <- base::sys.calls
[17:39:40.702]             `[[` <- base::`[[`
[17:39:40.702]             `+` <- base::`+`
[17:39:40.702]             `<<-` <- base::`<<-`
[17:39:40.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.702]                   3L)]
[17:39:40.702]             }
[17:39:40.702]             function(cond) {
[17:39:40.702]                 is_error <- inherits(cond, "error")
[17:39:40.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.702]                   NULL)
[17:39:40.702]                 if (is_error) {
[17:39:40.702]                   sessionInformation <- function() {
[17:39:40.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.702]                       search = base::search(), system = base::Sys.info())
[17:39:40.702]                   }
[17:39:40.702]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.702]                     cond$call), session = sessionInformation(), 
[17:39:40.702]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.702]                   signalCondition(cond)
[17:39:40.702]                 }
[17:39:40.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.702]                 "immediateCondition"))) {
[17:39:40.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.702]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.702]                   if (TRUE && !signal) {
[17:39:40.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.702]                     {
[17:39:40.702]                       inherits <- base::inherits
[17:39:40.702]                       invokeRestart <- base::invokeRestart
[17:39:40.702]                       is.null <- base::is.null
[17:39:40.702]                       muffled <- FALSE
[17:39:40.702]                       if (inherits(cond, "message")) {
[17:39:40.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.702]                         if (muffled) 
[17:39:40.702]                           invokeRestart("muffleMessage")
[17:39:40.702]                       }
[17:39:40.702]                       else if (inherits(cond, "warning")) {
[17:39:40.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.702]                         if (muffled) 
[17:39:40.702]                           invokeRestart("muffleWarning")
[17:39:40.702]                       }
[17:39:40.702]                       else if (inherits(cond, "condition")) {
[17:39:40.702]                         if (!is.null(pattern)) {
[17:39:40.702]                           computeRestarts <- base::computeRestarts
[17:39:40.702]                           grepl <- base::grepl
[17:39:40.702]                           restarts <- computeRestarts(cond)
[17:39:40.702]                           for (restart in restarts) {
[17:39:40.702]                             name <- restart$name
[17:39:40.702]                             if (is.null(name)) 
[17:39:40.702]                               next
[17:39:40.702]                             if (!grepl(pattern, name)) 
[17:39:40.702]                               next
[17:39:40.702]                             invokeRestart(restart)
[17:39:40.702]                             muffled <- TRUE
[17:39:40.702]                             break
[17:39:40.702]                           }
[17:39:40.702]                         }
[17:39:40.702]                       }
[17:39:40.702]                       invisible(muffled)
[17:39:40.702]                     }
[17:39:40.702]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.702]                   }
[17:39:40.702]                 }
[17:39:40.702]                 else {
[17:39:40.702]                   if (TRUE) {
[17:39:40.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.702]                     {
[17:39:40.702]                       inherits <- base::inherits
[17:39:40.702]                       invokeRestart <- base::invokeRestart
[17:39:40.702]                       is.null <- base::is.null
[17:39:40.702]                       muffled <- FALSE
[17:39:40.702]                       if (inherits(cond, "message")) {
[17:39:40.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.702]                         if (muffled) 
[17:39:40.702]                           invokeRestart("muffleMessage")
[17:39:40.702]                       }
[17:39:40.702]                       else if (inherits(cond, "warning")) {
[17:39:40.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.702]                         if (muffled) 
[17:39:40.702]                           invokeRestart("muffleWarning")
[17:39:40.702]                       }
[17:39:40.702]                       else if (inherits(cond, "condition")) {
[17:39:40.702]                         if (!is.null(pattern)) {
[17:39:40.702]                           computeRestarts <- base::computeRestarts
[17:39:40.702]                           grepl <- base::grepl
[17:39:40.702]                           restarts <- computeRestarts(cond)
[17:39:40.702]                           for (restart in restarts) {
[17:39:40.702]                             name <- restart$name
[17:39:40.702]                             if (is.null(name)) 
[17:39:40.702]                               next
[17:39:40.702]                             if (!grepl(pattern, name)) 
[17:39:40.702]                               next
[17:39:40.702]                             invokeRestart(restart)
[17:39:40.702]                             muffled <- TRUE
[17:39:40.702]                             break
[17:39:40.702]                           }
[17:39:40.702]                         }
[17:39:40.702]                       }
[17:39:40.702]                       invisible(muffled)
[17:39:40.702]                     }
[17:39:40.702]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.702]                   }
[17:39:40.702]                 }
[17:39:40.702]             }
[17:39:40.702]         }))
[17:39:40.702]     }, error = function(ex) {
[17:39:40.702]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.702]                 ...future.rng), started = ...future.startTime, 
[17:39:40.702]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.702]             version = "1.8"), class = "FutureResult")
[17:39:40.702]     }, finally = {
[17:39:40.702]         if (!identical(...future.workdir, getwd())) 
[17:39:40.702]             setwd(...future.workdir)
[17:39:40.702]         {
[17:39:40.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.702]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.702]             }
[17:39:40.702]             base::options(...future.oldOptions)
[17:39:40.702]             if (.Platform$OS.type == "windows") {
[17:39:40.702]                 old_names <- names(...future.oldEnvVars)
[17:39:40.702]                 envs <- base::Sys.getenv()
[17:39:40.702]                 names <- names(envs)
[17:39:40.702]                 common <- intersect(names, old_names)
[17:39:40.702]                 added <- setdiff(names, old_names)
[17:39:40.702]                 removed <- setdiff(old_names, names)
[17:39:40.702]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.702]                   envs[common]]
[17:39:40.702]                 NAMES <- toupper(changed)
[17:39:40.702]                 args <- list()
[17:39:40.702]                 for (kk in seq_along(NAMES)) {
[17:39:40.702]                   name <- changed[[kk]]
[17:39:40.702]                   NAME <- NAMES[[kk]]
[17:39:40.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.702]                     next
[17:39:40.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.702]                 }
[17:39:40.702]                 NAMES <- toupper(added)
[17:39:40.702]                 for (kk in seq_along(NAMES)) {
[17:39:40.702]                   name <- added[[kk]]
[17:39:40.702]                   NAME <- NAMES[[kk]]
[17:39:40.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.702]                     next
[17:39:40.702]                   args[[name]] <- ""
[17:39:40.702]                 }
[17:39:40.702]                 NAMES <- toupper(removed)
[17:39:40.702]                 for (kk in seq_along(NAMES)) {
[17:39:40.702]                   name <- removed[[kk]]
[17:39:40.702]                   NAME <- NAMES[[kk]]
[17:39:40.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.702]                     next
[17:39:40.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.702]                 }
[17:39:40.702]                 if (length(args) > 0) 
[17:39:40.702]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.702]             }
[17:39:40.702]             else {
[17:39:40.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.702]             }
[17:39:40.702]             {
[17:39:40.702]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.702]                   0L) {
[17:39:40.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.702]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.702]                   base::options(opts)
[17:39:40.702]                 }
[17:39:40.702]                 {
[17:39:40.702]                   {
[17:39:40.702]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.702]                     NULL
[17:39:40.702]                   }
[17:39:40.702]                   options(future.plan = NULL)
[17:39:40.702]                   if (is.na(NA_character_)) 
[17:39:40.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.702]                     .init = FALSE)
[17:39:40.702]                 }
[17:39:40.702]             }
[17:39:40.702]         }
[17:39:40.702]     })
[17:39:40.702]     if (TRUE) {
[17:39:40.702]         base::sink(type = "output", split = FALSE)
[17:39:40.702]         if (TRUE) {
[17:39:40.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.702]         }
[17:39:40.702]         else {
[17:39:40.702]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.702]         }
[17:39:40.702]         base::close(...future.stdout)
[17:39:40.702]         ...future.stdout <- NULL
[17:39:40.702]     }
[17:39:40.702]     ...future.result$conditions <- ...future.conditions
[17:39:40.702]     ...future.result$finished <- base::Sys.time()
[17:39:40.702]     ...future.result
[17:39:40.702] }
[17:39:40.705] assign_globals() ...
[17:39:40.705] List of 2
[17:39:40.705]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.705]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.705]  - attr(*, "where")=List of 2
[17:39:40.705]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.705]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.705]  - attr(*, "resolved")= logi FALSE
[17:39:40.705]  - attr(*, "total_size")= num 896
[17:39:40.705]  - attr(*, "already-done")= logi TRUE
[17:39:40.708] - copied ‘weight’ to environment
[17:39:40.708] - copied ‘group’ to environment
[17:39:40.708] assign_globals() ... done
[17:39:40.708] requestCore(): workers = 2
[17:39:40.715] MulticoreFuture started
[17:39:40.715] - Launch lazy future ... done
[17:39:40.716] run() for ‘MulticoreFuture’ ... done
[17:39:40.716] plan(): Setting new future strategy stack:
[17:39:40.717] result() for MulticoreFuture ...
[17:39:40.716] List of future strategies:
[17:39:40.716] 1. sequential:
[17:39:40.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.716]    - tweaked: FALSE
[17:39:40.716]    - call: NULL
[17:39:40.717] plan(): nbrOfWorkers() = 1
[17:39:40.721] plan(): Setting new future strategy stack:
[17:39:40.721] List of future strategies:
[17:39:40.721] 1. multicore:
[17:39:40.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.721]    - tweaked: FALSE
[17:39:40.721]    - call: plan(strategy)
[17:39:40.726] plan(): nbrOfWorkers() = 2
[17:39:40.733] result() for MulticoreFuture ...
[17:39:40.733] result() for MulticoreFuture ... done
[17:39:40.733] result() for MulticoreFuture ... done
[17:39:40.733] result() for MulticoreFuture ...
[17:39:40.733] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.735] getGlobalsAndPackages() ...
[17:39:40.735] Searching for globals...
[17:39:40.737] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.737] Searching for globals ... DONE
[17:39:40.737] Resolving globals: FALSE
[17:39:40.738] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.738] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.739] - globals: [2] ‘weight’, ‘group’
[17:39:40.739] - packages: [1] ‘stats’
[17:39:40.739] getGlobalsAndPackages() ... DONE
[17:39:40.739] run() for ‘Future’ ...
[17:39:40.739] - state: ‘created’
[17:39:40.739] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.744] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.744] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.744]   - Field: ‘label’
[17:39:40.744]   - Field: ‘local’
[17:39:40.745]   - Field: ‘owner’
[17:39:40.745]   - Field: ‘envir’
[17:39:40.745]   - Field: ‘workers’
[17:39:40.745]   - Field: ‘packages’
[17:39:40.745]   - Field: ‘gc’
[17:39:40.745]   - Field: ‘job’
[17:39:40.745]   - Field: ‘conditions’
[17:39:40.745]   - Field: ‘expr’
[17:39:40.745]   - Field: ‘uuid’
[17:39:40.746]   - Field: ‘seed’
[17:39:40.746]   - Field: ‘version’
[17:39:40.746]   - Field: ‘result’
[17:39:40.746]   - Field: ‘asynchronous’
[17:39:40.746]   - Field: ‘calls’
[17:39:40.746]   - Field: ‘globals’
[17:39:40.746]   - Field: ‘stdout’
[17:39:40.746]   - Field: ‘earlySignal’
[17:39:40.746]   - Field: ‘lazy’
[17:39:40.747]   - Field: ‘state’
[17:39:40.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.747] - Launch lazy future ...
[17:39:40.747] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.747] Packages needed by future strategies (n = 0): <none>
[17:39:40.748] {
[17:39:40.748]     {
[17:39:40.748]         {
[17:39:40.748]             ...future.startTime <- base::Sys.time()
[17:39:40.748]             {
[17:39:40.748]                 {
[17:39:40.748]                   {
[17:39:40.748]                     {
[17:39:40.748]                       {
[17:39:40.748]                         base::local({
[17:39:40.748]                           has_future <- base::requireNamespace("future", 
[17:39:40.748]                             quietly = TRUE)
[17:39:40.748]                           if (has_future) {
[17:39:40.748]                             ns <- base::getNamespace("future")
[17:39:40.748]                             version <- ns[[".package"]][["version"]]
[17:39:40.748]                             if (is.null(version)) 
[17:39:40.748]                               version <- utils::packageVersion("future")
[17:39:40.748]                           }
[17:39:40.748]                           else {
[17:39:40.748]                             version <- NULL
[17:39:40.748]                           }
[17:39:40.748]                           if (!has_future || version < "1.8.0") {
[17:39:40.748]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.748]                               "", base::R.version$version.string), 
[17:39:40.748]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.748]                                 base::R.version$platform, 8 * 
[17:39:40.748]                                   base::.Machine$sizeof.pointer), 
[17:39:40.748]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.748]                                 "release", "version")], collapse = " "), 
[17:39:40.748]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.748]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.748]                               info)
[17:39:40.748]                             info <- base::paste(info, collapse = "; ")
[17:39:40.748]                             if (!has_future) {
[17:39:40.748]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.748]                                 info)
[17:39:40.748]                             }
[17:39:40.748]                             else {
[17:39:40.748]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.748]                                 info, version)
[17:39:40.748]                             }
[17:39:40.748]                             base::stop(msg)
[17:39:40.748]                           }
[17:39:40.748]                         })
[17:39:40.748]                       }
[17:39:40.748]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.748]                       base::options(mc.cores = 1L)
[17:39:40.748]                     }
[17:39:40.748]                     base::local({
[17:39:40.748]                       for (pkg in "stats") {
[17:39:40.748]                         base::loadNamespace(pkg)
[17:39:40.748]                         base::library(pkg, character.only = TRUE)
[17:39:40.748]                       }
[17:39:40.748]                     })
[17:39:40.748]                   }
[17:39:40.748]                   ...future.strategy.old <- future::plan("list")
[17:39:40.748]                   options(future.plan = NULL)
[17:39:40.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.748]                 }
[17:39:40.748]                 ...future.workdir <- getwd()
[17:39:40.748]             }
[17:39:40.748]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.748]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.748]         }
[17:39:40.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.748]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.748]             base::names(...future.oldOptions))
[17:39:40.748]     }
[17:39:40.748]     if (FALSE) {
[17:39:40.748]     }
[17:39:40.748]     else {
[17:39:40.748]         if (TRUE) {
[17:39:40.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.748]                 open = "w")
[17:39:40.748]         }
[17:39:40.748]         else {
[17:39:40.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.748]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.748]         }
[17:39:40.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.748]             base::sink(type = "output", split = FALSE)
[17:39:40.748]             base::close(...future.stdout)
[17:39:40.748]         }, add = TRUE)
[17:39:40.748]     }
[17:39:40.748]     ...future.frame <- base::sys.nframe()
[17:39:40.748]     ...future.conditions <- base::list()
[17:39:40.748]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.748]     if (FALSE) {
[17:39:40.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.748]     }
[17:39:40.748]     ...future.result <- base::tryCatch({
[17:39:40.748]         base::withCallingHandlers({
[17:39:40.748]             ...future.value <- base::withVisible(base::local({
[17:39:40.748]                 withCallingHandlers({
[17:39:40.748]                   {
[17:39:40.748]                     lm(weight ~ group - 1)
[17:39:40.748]                   }
[17:39:40.748]                 }, immediateCondition = function(cond) {
[17:39:40.748]                   save_rds <- function (object, pathname, ...) 
[17:39:40.748]                   {
[17:39:40.748]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.748]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.748]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.748]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.748]                         fi_tmp[["mtime"]])
[17:39:40.748]                     }
[17:39:40.748]                     tryCatch({
[17:39:40.748]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.748]                     }, error = function(ex) {
[17:39:40.748]                       msg <- conditionMessage(ex)
[17:39:40.748]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.748]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.748]                         fi_tmp[["mtime"]], msg)
[17:39:40.748]                       ex$message <- msg
[17:39:40.748]                       stop(ex)
[17:39:40.748]                     })
[17:39:40.748]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.748]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.748]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.748]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.748]                       fi <- file.info(pathname)
[17:39:40.748]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.748]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.748]                         fi[["size"]], fi[["mtime"]])
[17:39:40.748]                       stop(msg)
[17:39:40.748]                     }
[17:39:40.748]                     invisible(pathname)
[17:39:40.748]                   }
[17:39:40.748]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.748]                     rootPath = tempdir()) 
[17:39:40.748]                   {
[17:39:40.748]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.748]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.748]                       tmpdir = path, fileext = ".rds")
[17:39:40.748]                     save_rds(obj, file)
[17:39:40.748]                   }
[17:39:40.748]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.748]                   {
[17:39:40.748]                     inherits <- base::inherits
[17:39:40.748]                     invokeRestart <- base::invokeRestart
[17:39:40.748]                     is.null <- base::is.null
[17:39:40.748]                     muffled <- FALSE
[17:39:40.748]                     if (inherits(cond, "message")) {
[17:39:40.748]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.748]                       if (muffled) 
[17:39:40.748]                         invokeRestart("muffleMessage")
[17:39:40.748]                     }
[17:39:40.748]                     else if (inherits(cond, "warning")) {
[17:39:40.748]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.748]                       if (muffled) 
[17:39:40.748]                         invokeRestart("muffleWarning")
[17:39:40.748]                     }
[17:39:40.748]                     else if (inherits(cond, "condition")) {
[17:39:40.748]                       if (!is.null(pattern)) {
[17:39:40.748]                         computeRestarts <- base::computeRestarts
[17:39:40.748]                         grepl <- base::grepl
[17:39:40.748]                         restarts <- computeRestarts(cond)
[17:39:40.748]                         for (restart in restarts) {
[17:39:40.748]                           name <- restart$name
[17:39:40.748]                           if (is.null(name)) 
[17:39:40.748]                             next
[17:39:40.748]                           if (!grepl(pattern, name)) 
[17:39:40.748]                             next
[17:39:40.748]                           invokeRestart(restart)
[17:39:40.748]                           muffled <- TRUE
[17:39:40.748]                           break
[17:39:40.748]                         }
[17:39:40.748]                       }
[17:39:40.748]                     }
[17:39:40.748]                     invisible(muffled)
[17:39:40.748]                   }
[17:39:40.748]                   muffleCondition(cond)
[17:39:40.748]                 })
[17:39:40.748]             }))
[17:39:40.748]             future::FutureResult(value = ...future.value$value, 
[17:39:40.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.748]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.748]                     ...future.globalenv.names))
[17:39:40.748]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.748]         }, condition = base::local({
[17:39:40.748]             c <- base::c
[17:39:40.748]             inherits <- base::inherits
[17:39:40.748]             invokeRestart <- base::invokeRestart
[17:39:40.748]             length <- base::length
[17:39:40.748]             list <- base::list
[17:39:40.748]             seq.int <- base::seq.int
[17:39:40.748]             signalCondition <- base::signalCondition
[17:39:40.748]             sys.calls <- base::sys.calls
[17:39:40.748]             `[[` <- base::`[[`
[17:39:40.748]             `+` <- base::`+`
[17:39:40.748]             `<<-` <- base::`<<-`
[17:39:40.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.748]                   3L)]
[17:39:40.748]             }
[17:39:40.748]             function(cond) {
[17:39:40.748]                 is_error <- inherits(cond, "error")
[17:39:40.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.748]                   NULL)
[17:39:40.748]                 if (is_error) {
[17:39:40.748]                   sessionInformation <- function() {
[17:39:40.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.748]                       search = base::search(), system = base::Sys.info())
[17:39:40.748]                   }
[17:39:40.748]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.748]                     cond$call), session = sessionInformation(), 
[17:39:40.748]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.748]                   signalCondition(cond)
[17:39:40.748]                 }
[17:39:40.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.748]                 "immediateCondition"))) {
[17:39:40.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.748]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.748]                   if (TRUE && !signal) {
[17:39:40.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.748]                     {
[17:39:40.748]                       inherits <- base::inherits
[17:39:40.748]                       invokeRestart <- base::invokeRestart
[17:39:40.748]                       is.null <- base::is.null
[17:39:40.748]                       muffled <- FALSE
[17:39:40.748]                       if (inherits(cond, "message")) {
[17:39:40.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.748]                         if (muffled) 
[17:39:40.748]                           invokeRestart("muffleMessage")
[17:39:40.748]                       }
[17:39:40.748]                       else if (inherits(cond, "warning")) {
[17:39:40.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.748]                         if (muffled) 
[17:39:40.748]                           invokeRestart("muffleWarning")
[17:39:40.748]                       }
[17:39:40.748]                       else if (inherits(cond, "condition")) {
[17:39:40.748]                         if (!is.null(pattern)) {
[17:39:40.748]                           computeRestarts <- base::computeRestarts
[17:39:40.748]                           grepl <- base::grepl
[17:39:40.748]                           restarts <- computeRestarts(cond)
[17:39:40.748]                           for (restart in restarts) {
[17:39:40.748]                             name <- restart$name
[17:39:40.748]                             if (is.null(name)) 
[17:39:40.748]                               next
[17:39:40.748]                             if (!grepl(pattern, name)) 
[17:39:40.748]                               next
[17:39:40.748]                             invokeRestart(restart)
[17:39:40.748]                             muffled <- TRUE
[17:39:40.748]                             break
[17:39:40.748]                           }
[17:39:40.748]                         }
[17:39:40.748]                       }
[17:39:40.748]                       invisible(muffled)
[17:39:40.748]                     }
[17:39:40.748]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.748]                   }
[17:39:40.748]                 }
[17:39:40.748]                 else {
[17:39:40.748]                   if (TRUE) {
[17:39:40.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.748]                     {
[17:39:40.748]                       inherits <- base::inherits
[17:39:40.748]                       invokeRestart <- base::invokeRestart
[17:39:40.748]                       is.null <- base::is.null
[17:39:40.748]                       muffled <- FALSE
[17:39:40.748]                       if (inherits(cond, "message")) {
[17:39:40.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.748]                         if (muffled) 
[17:39:40.748]                           invokeRestart("muffleMessage")
[17:39:40.748]                       }
[17:39:40.748]                       else if (inherits(cond, "warning")) {
[17:39:40.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.748]                         if (muffled) 
[17:39:40.748]                           invokeRestart("muffleWarning")
[17:39:40.748]                       }
[17:39:40.748]                       else if (inherits(cond, "condition")) {
[17:39:40.748]                         if (!is.null(pattern)) {
[17:39:40.748]                           computeRestarts <- base::computeRestarts
[17:39:40.748]                           grepl <- base::grepl
[17:39:40.748]                           restarts <- computeRestarts(cond)
[17:39:40.748]                           for (restart in restarts) {
[17:39:40.748]                             name <- restart$name
[17:39:40.748]                             if (is.null(name)) 
[17:39:40.748]                               next
[17:39:40.748]                             if (!grepl(pattern, name)) 
[17:39:40.748]                               next
[17:39:40.748]                             invokeRestart(restart)
[17:39:40.748]                             muffled <- TRUE
[17:39:40.748]                             break
[17:39:40.748]                           }
[17:39:40.748]                         }
[17:39:40.748]                       }
[17:39:40.748]                       invisible(muffled)
[17:39:40.748]                     }
[17:39:40.748]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.748]                   }
[17:39:40.748]                 }
[17:39:40.748]             }
[17:39:40.748]         }))
[17:39:40.748]     }, error = function(ex) {
[17:39:40.748]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.748]                 ...future.rng), started = ...future.startTime, 
[17:39:40.748]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.748]             version = "1.8"), class = "FutureResult")
[17:39:40.748]     }, finally = {
[17:39:40.748]         if (!identical(...future.workdir, getwd())) 
[17:39:40.748]             setwd(...future.workdir)
[17:39:40.748]         {
[17:39:40.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.748]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.748]             }
[17:39:40.748]             base::options(...future.oldOptions)
[17:39:40.748]             if (.Platform$OS.type == "windows") {
[17:39:40.748]                 old_names <- names(...future.oldEnvVars)
[17:39:40.748]                 envs <- base::Sys.getenv()
[17:39:40.748]                 names <- names(envs)
[17:39:40.748]                 common <- intersect(names, old_names)
[17:39:40.748]                 added <- setdiff(names, old_names)
[17:39:40.748]                 removed <- setdiff(old_names, names)
[17:39:40.748]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.748]                   envs[common]]
[17:39:40.748]                 NAMES <- toupper(changed)
[17:39:40.748]                 args <- list()
[17:39:40.748]                 for (kk in seq_along(NAMES)) {
[17:39:40.748]                   name <- changed[[kk]]
[17:39:40.748]                   NAME <- NAMES[[kk]]
[17:39:40.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.748]                     next
[17:39:40.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.748]                 }
[17:39:40.748]                 NAMES <- toupper(added)
[17:39:40.748]                 for (kk in seq_along(NAMES)) {
[17:39:40.748]                   name <- added[[kk]]
[17:39:40.748]                   NAME <- NAMES[[kk]]
[17:39:40.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.748]                     next
[17:39:40.748]                   args[[name]] <- ""
[17:39:40.748]                 }
[17:39:40.748]                 NAMES <- toupper(removed)
[17:39:40.748]                 for (kk in seq_along(NAMES)) {
[17:39:40.748]                   name <- removed[[kk]]
[17:39:40.748]                   NAME <- NAMES[[kk]]
[17:39:40.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.748]                     next
[17:39:40.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.748]                 }
[17:39:40.748]                 if (length(args) > 0) 
[17:39:40.748]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.748]             }
[17:39:40.748]             else {
[17:39:40.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.748]             }
[17:39:40.748]             {
[17:39:40.748]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.748]                   0L) {
[17:39:40.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.748]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.748]                   base::options(opts)
[17:39:40.748]                 }
[17:39:40.748]                 {
[17:39:40.748]                   {
[17:39:40.748]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.748]                     NULL
[17:39:40.748]                   }
[17:39:40.748]                   options(future.plan = NULL)
[17:39:40.748]                   if (is.na(NA_character_)) 
[17:39:40.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.748]                     .init = FALSE)
[17:39:40.748]                 }
[17:39:40.748]             }
[17:39:40.748]         }
[17:39:40.748]     })
[17:39:40.748]     if (TRUE) {
[17:39:40.748]         base::sink(type = "output", split = FALSE)
[17:39:40.748]         if (TRUE) {
[17:39:40.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.748]         }
[17:39:40.748]         else {
[17:39:40.748]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.748]         }
[17:39:40.748]         base::close(...future.stdout)
[17:39:40.748]         ...future.stdout <- NULL
[17:39:40.748]     }
[17:39:40.748]     ...future.result$conditions <- ...future.conditions
[17:39:40.748]     ...future.result$finished <- base::Sys.time()
[17:39:40.748]     ...future.result
[17:39:40.748] }
[17:39:40.750] assign_globals() ...
[17:39:40.750] List of 2
[17:39:40.750]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.750]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.750]  - attr(*, "where")=List of 2
[17:39:40.750]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.750]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.750]  - attr(*, "resolved")= logi FALSE
[17:39:40.750]  - attr(*, "total_size")= num 896
[17:39:40.750]  - attr(*, "already-done")= logi TRUE
[17:39:40.754] - copied ‘weight’ to environment
[17:39:40.754] - copied ‘group’ to environment
[17:39:40.754] assign_globals() ... done
[17:39:40.754] requestCore(): workers = 2
[17:39:40.757] MulticoreFuture started
[17:39:40.757] - Launch lazy future ... done
[17:39:40.757] run() for ‘MulticoreFuture’ ... done
[17:39:40.757] result() for MulticoreFuture ...
[17:39:40.758] plan(): Setting new future strategy stack:
[17:39:40.758] List of future strategies:
[17:39:40.758] 1. sequential:
[17:39:40.758]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.758]    - tweaked: FALSE
[17:39:40.758]    - call: NULL
[17:39:40.759] plan(): nbrOfWorkers() = 1
[17:39:40.763] plan(): Setting new future strategy stack:
[17:39:40.763] List of future strategies:
[17:39:40.763] 1. multicore:
[17:39:40.763]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.763]    - tweaked: FALSE
[17:39:40.763]    - call: plan(strategy)
[17:39:40.772] plan(): nbrOfWorkers() = 2
[17:39:40.775] result() for MulticoreFuture ...
[17:39:40.775] result() for MulticoreFuture ... done
[17:39:40.775] result() for MulticoreFuture ... done
[17:39:40.775] result() for MulticoreFuture ...
[17:39:40.776] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.781] getGlobalsAndPackages() ...
[17:39:40.781] Searching for globals...
[17:39:40.783] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.784] Searching for globals ... DONE
[17:39:40.784] Resolving globals: FALSE
[17:39:40.784] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.785] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.785] - globals: [2] ‘weight’, ‘group’
[17:39:40.785] - packages: [1] ‘stats’
[17:39:40.785] getGlobalsAndPackages() ... DONE
[17:39:40.786] run() for ‘Future’ ...
[17:39:40.786] - state: ‘created’
[17:39:40.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.790] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.790]   - Field: ‘label’
[17:39:40.790]   - Field: ‘local’
[17:39:40.791]   - Field: ‘owner’
[17:39:40.791]   - Field: ‘envir’
[17:39:40.791]   - Field: ‘workers’
[17:39:40.791]   - Field: ‘packages’
[17:39:40.791]   - Field: ‘gc’
[17:39:40.791]   - Field: ‘job’
[17:39:40.791]   - Field: ‘conditions’
[17:39:40.791]   - Field: ‘expr’
[17:39:40.791]   - Field: ‘uuid’
[17:39:40.792]   - Field: ‘seed’
[17:39:40.792]   - Field: ‘version’
[17:39:40.792]   - Field: ‘result’
[17:39:40.792]   - Field: ‘asynchronous’
[17:39:40.792]   - Field: ‘calls’
[17:39:40.792]   - Field: ‘globals’
[17:39:40.792]   - Field: ‘stdout’
[17:39:40.792]   - Field: ‘earlySignal’
[17:39:40.793]   - Field: ‘lazy’
[17:39:40.793]   - Field: ‘state’
[17:39:40.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.793] - Launch lazy future ...
[17:39:40.793] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.793] Packages needed by future strategies (n = 0): <none>
[17:39:40.794] {
[17:39:40.794]     {
[17:39:40.794]         {
[17:39:40.794]             ...future.startTime <- base::Sys.time()
[17:39:40.794]             {
[17:39:40.794]                 {
[17:39:40.794]                   {
[17:39:40.794]                     {
[17:39:40.794]                       {
[17:39:40.794]                         base::local({
[17:39:40.794]                           has_future <- base::requireNamespace("future", 
[17:39:40.794]                             quietly = TRUE)
[17:39:40.794]                           if (has_future) {
[17:39:40.794]                             ns <- base::getNamespace("future")
[17:39:40.794]                             version <- ns[[".package"]][["version"]]
[17:39:40.794]                             if (is.null(version)) 
[17:39:40.794]                               version <- utils::packageVersion("future")
[17:39:40.794]                           }
[17:39:40.794]                           else {
[17:39:40.794]                             version <- NULL
[17:39:40.794]                           }
[17:39:40.794]                           if (!has_future || version < "1.8.0") {
[17:39:40.794]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.794]                               "", base::R.version$version.string), 
[17:39:40.794]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.794]                                 base::R.version$platform, 8 * 
[17:39:40.794]                                   base::.Machine$sizeof.pointer), 
[17:39:40.794]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.794]                                 "release", "version")], collapse = " "), 
[17:39:40.794]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.794]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.794]                               info)
[17:39:40.794]                             info <- base::paste(info, collapse = "; ")
[17:39:40.794]                             if (!has_future) {
[17:39:40.794]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.794]                                 info)
[17:39:40.794]                             }
[17:39:40.794]                             else {
[17:39:40.794]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.794]                                 info, version)
[17:39:40.794]                             }
[17:39:40.794]                             base::stop(msg)
[17:39:40.794]                           }
[17:39:40.794]                         })
[17:39:40.794]                       }
[17:39:40.794]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.794]                       base::options(mc.cores = 1L)
[17:39:40.794]                     }
[17:39:40.794]                     base::local({
[17:39:40.794]                       for (pkg in "stats") {
[17:39:40.794]                         base::loadNamespace(pkg)
[17:39:40.794]                         base::library(pkg, character.only = TRUE)
[17:39:40.794]                       }
[17:39:40.794]                     })
[17:39:40.794]                   }
[17:39:40.794]                   ...future.strategy.old <- future::plan("list")
[17:39:40.794]                   options(future.plan = NULL)
[17:39:40.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.794]                 }
[17:39:40.794]                 ...future.workdir <- getwd()
[17:39:40.794]             }
[17:39:40.794]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.794]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.794]         }
[17:39:40.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.794]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.794]             base::names(...future.oldOptions))
[17:39:40.794]     }
[17:39:40.794]     if (FALSE) {
[17:39:40.794]     }
[17:39:40.794]     else {
[17:39:40.794]         if (TRUE) {
[17:39:40.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.794]                 open = "w")
[17:39:40.794]         }
[17:39:40.794]         else {
[17:39:40.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.794]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.794]         }
[17:39:40.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.794]             base::sink(type = "output", split = FALSE)
[17:39:40.794]             base::close(...future.stdout)
[17:39:40.794]         }, add = TRUE)
[17:39:40.794]     }
[17:39:40.794]     ...future.frame <- base::sys.nframe()
[17:39:40.794]     ...future.conditions <- base::list()
[17:39:40.794]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.794]     if (FALSE) {
[17:39:40.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.794]     }
[17:39:40.794]     ...future.result <- base::tryCatch({
[17:39:40.794]         base::withCallingHandlers({
[17:39:40.794]             ...future.value <- base::withVisible(base::local({
[17:39:40.794]                 withCallingHandlers({
[17:39:40.794]                   {
[17:39:40.794]                     lm(weight ~ group - 1)
[17:39:40.794]                   }
[17:39:40.794]                 }, immediateCondition = function(cond) {
[17:39:40.794]                   save_rds <- function (object, pathname, ...) 
[17:39:40.794]                   {
[17:39:40.794]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.794]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.794]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.794]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.794]                         fi_tmp[["mtime"]])
[17:39:40.794]                     }
[17:39:40.794]                     tryCatch({
[17:39:40.794]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.794]                     }, error = function(ex) {
[17:39:40.794]                       msg <- conditionMessage(ex)
[17:39:40.794]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.794]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.794]                         fi_tmp[["mtime"]], msg)
[17:39:40.794]                       ex$message <- msg
[17:39:40.794]                       stop(ex)
[17:39:40.794]                     })
[17:39:40.794]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.794]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.794]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.794]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.794]                       fi <- file.info(pathname)
[17:39:40.794]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.794]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.794]                         fi[["size"]], fi[["mtime"]])
[17:39:40.794]                       stop(msg)
[17:39:40.794]                     }
[17:39:40.794]                     invisible(pathname)
[17:39:40.794]                   }
[17:39:40.794]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.794]                     rootPath = tempdir()) 
[17:39:40.794]                   {
[17:39:40.794]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.794]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.794]                       tmpdir = path, fileext = ".rds")
[17:39:40.794]                     save_rds(obj, file)
[17:39:40.794]                   }
[17:39:40.794]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.794]                   {
[17:39:40.794]                     inherits <- base::inherits
[17:39:40.794]                     invokeRestart <- base::invokeRestart
[17:39:40.794]                     is.null <- base::is.null
[17:39:40.794]                     muffled <- FALSE
[17:39:40.794]                     if (inherits(cond, "message")) {
[17:39:40.794]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.794]                       if (muffled) 
[17:39:40.794]                         invokeRestart("muffleMessage")
[17:39:40.794]                     }
[17:39:40.794]                     else if (inherits(cond, "warning")) {
[17:39:40.794]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.794]                       if (muffled) 
[17:39:40.794]                         invokeRestart("muffleWarning")
[17:39:40.794]                     }
[17:39:40.794]                     else if (inherits(cond, "condition")) {
[17:39:40.794]                       if (!is.null(pattern)) {
[17:39:40.794]                         computeRestarts <- base::computeRestarts
[17:39:40.794]                         grepl <- base::grepl
[17:39:40.794]                         restarts <- computeRestarts(cond)
[17:39:40.794]                         for (restart in restarts) {
[17:39:40.794]                           name <- restart$name
[17:39:40.794]                           if (is.null(name)) 
[17:39:40.794]                             next
[17:39:40.794]                           if (!grepl(pattern, name)) 
[17:39:40.794]                             next
[17:39:40.794]                           invokeRestart(restart)
[17:39:40.794]                           muffled <- TRUE
[17:39:40.794]                           break
[17:39:40.794]                         }
[17:39:40.794]                       }
[17:39:40.794]                     }
[17:39:40.794]                     invisible(muffled)
[17:39:40.794]                   }
[17:39:40.794]                   muffleCondition(cond)
[17:39:40.794]                 })
[17:39:40.794]             }))
[17:39:40.794]             future::FutureResult(value = ...future.value$value, 
[17:39:40.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.794]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.794]                     ...future.globalenv.names))
[17:39:40.794]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.794]         }, condition = base::local({
[17:39:40.794]             c <- base::c
[17:39:40.794]             inherits <- base::inherits
[17:39:40.794]             invokeRestart <- base::invokeRestart
[17:39:40.794]             length <- base::length
[17:39:40.794]             list <- base::list
[17:39:40.794]             seq.int <- base::seq.int
[17:39:40.794]             signalCondition <- base::signalCondition
[17:39:40.794]             sys.calls <- base::sys.calls
[17:39:40.794]             `[[` <- base::`[[`
[17:39:40.794]             `+` <- base::`+`
[17:39:40.794]             `<<-` <- base::`<<-`
[17:39:40.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.794]                   3L)]
[17:39:40.794]             }
[17:39:40.794]             function(cond) {
[17:39:40.794]                 is_error <- inherits(cond, "error")
[17:39:40.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.794]                   NULL)
[17:39:40.794]                 if (is_error) {
[17:39:40.794]                   sessionInformation <- function() {
[17:39:40.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.794]                       search = base::search(), system = base::Sys.info())
[17:39:40.794]                   }
[17:39:40.794]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.794]                     cond$call), session = sessionInformation(), 
[17:39:40.794]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.794]                   signalCondition(cond)
[17:39:40.794]                 }
[17:39:40.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.794]                 "immediateCondition"))) {
[17:39:40.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.794]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.794]                   if (TRUE && !signal) {
[17:39:40.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.794]                     {
[17:39:40.794]                       inherits <- base::inherits
[17:39:40.794]                       invokeRestart <- base::invokeRestart
[17:39:40.794]                       is.null <- base::is.null
[17:39:40.794]                       muffled <- FALSE
[17:39:40.794]                       if (inherits(cond, "message")) {
[17:39:40.794]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.794]                         if (muffled) 
[17:39:40.794]                           invokeRestart("muffleMessage")
[17:39:40.794]                       }
[17:39:40.794]                       else if (inherits(cond, "warning")) {
[17:39:40.794]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.794]                         if (muffled) 
[17:39:40.794]                           invokeRestart("muffleWarning")
[17:39:40.794]                       }
[17:39:40.794]                       else if (inherits(cond, "condition")) {
[17:39:40.794]                         if (!is.null(pattern)) {
[17:39:40.794]                           computeRestarts <- base::computeRestarts
[17:39:40.794]                           grepl <- base::grepl
[17:39:40.794]                           restarts <- computeRestarts(cond)
[17:39:40.794]                           for (restart in restarts) {
[17:39:40.794]                             name <- restart$name
[17:39:40.794]                             if (is.null(name)) 
[17:39:40.794]                               next
[17:39:40.794]                             if (!grepl(pattern, name)) 
[17:39:40.794]                               next
[17:39:40.794]                             invokeRestart(restart)
[17:39:40.794]                             muffled <- TRUE
[17:39:40.794]                             break
[17:39:40.794]                           }
[17:39:40.794]                         }
[17:39:40.794]                       }
[17:39:40.794]                       invisible(muffled)
[17:39:40.794]                     }
[17:39:40.794]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.794]                   }
[17:39:40.794]                 }
[17:39:40.794]                 else {
[17:39:40.794]                   if (TRUE) {
[17:39:40.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.794]                     {
[17:39:40.794]                       inherits <- base::inherits
[17:39:40.794]                       invokeRestart <- base::invokeRestart
[17:39:40.794]                       is.null <- base::is.null
[17:39:40.794]                       muffled <- FALSE
[17:39:40.794]                       if (inherits(cond, "message")) {
[17:39:40.794]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.794]                         if (muffled) 
[17:39:40.794]                           invokeRestart("muffleMessage")
[17:39:40.794]                       }
[17:39:40.794]                       else if (inherits(cond, "warning")) {
[17:39:40.794]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.794]                         if (muffled) 
[17:39:40.794]                           invokeRestart("muffleWarning")
[17:39:40.794]                       }
[17:39:40.794]                       else if (inherits(cond, "condition")) {
[17:39:40.794]                         if (!is.null(pattern)) {
[17:39:40.794]                           computeRestarts <- base::computeRestarts
[17:39:40.794]                           grepl <- base::grepl
[17:39:40.794]                           restarts <- computeRestarts(cond)
[17:39:40.794]                           for (restart in restarts) {
[17:39:40.794]                             name <- restart$name
[17:39:40.794]                             if (is.null(name)) 
[17:39:40.794]                               next
[17:39:40.794]                             if (!grepl(pattern, name)) 
[17:39:40.794]                               next
[17:39:40.794]                             invokeRestart(restart)
[17:39:40.794]                             muffled <- TRUE
[17:39:40.794]                             break
[17:39:40.794]                           }
[17:39:40.794]                         }
[17:39:40.794]                       }
[17:39:40.794]                       invisible(muffled)
[17:39:40.794]                     }
[17:39:40.794]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.794]                   }
[17:39:40.794]                 }
[17:39:40.794]             }
[17:39:40.794]         }))
[17:39:40.794]     }, error = function(ex) {
[17:39:40.794]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.794]                 ...future.rng), started = ...future.startTime, 
[17:39:40.794]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.794]             version = "1.8"), class = "FutureResult")
[17:39:40.794]     }, finally = {
[17:39:40.794]         if (!identical(...future.workdir, getwd())) 
[17:39:40.794]             setwd(...future.workdir)
[17:39:40.794]         {
[17:39:40.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.794]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.794]             }
[17:39:40.794]             base::options(...future.oldOptions)
[17:39:40.794]             if (.Platform$OS.type == "windows") {
[17:39:40.794]                 old_names <- names(...future.oldEnvVars)
[17:39:40.794]                 envs <- base::Sys.getenv()
[17:39:40.794]                 names <- names(envs)
[17:39:40.794]                 common <- intersect(names, old_names)
[17:39:40.794]                 added <- setdiff(names, old_names)
[17:39:40.794]                 removed <- setdiff(old_names, names)
[17:39:40.794]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.794]                   envs[common]]
[17:39:40.794]                 NAMES <- toupper(changed)
[17:39:40.794]                 args <- list()
[17:39:40.794]                 for (kk in seq_along(NAMES)) {
[17:39:40.794]                   name <- changed[[kk]]
[17:39:40.794]                   NAME <- NAMES[[kk]]
[17:39:40.794]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.794]                     next
[17:39:40.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.794]                 }
[17:39:40.794]                 NAMES <- toupper(added)
[17:39:40.794]                 for (kk in seq_along(NAMES)) {
[17:39:40.794]                   name <- added[[kk]]
[17:39:40.794]                   NAME <- NAMES[[kk]]
[17:39:40.794]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.794]                     next
[17:39:40.794]                   args[[name]] <- ""
[17:39:40.794]                 }
[17:39:40.794]                 NAMES <- toupper(removed)
[17:39:40.794]                 for (kk in seq_along(NAMES)) {
[17:39:40.794]                   name <- removed[[kk]]
[17:39:40.794]                   NAME <- NAMES[[kk]]
[17:39:40.794]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.794]                     next
[17:39:40.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.794]                 }
[17:39:40.794]                 if (length(args) > 0) 
[17:39:40.794]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.794]             }
[17:39:40.794]             else {
[17:39:40.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.794]             }
[17:39:40.794]             {
[17:39:40.794]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.794]                   0L) {
[17:39:40.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.794]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.794]                   base::options(opts)
[17:39:40.794]                 }
[17:39:40.794]                 {
[17:39:40.794]                   {
[17:39:40.794]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.794]                     NULL
[17:39:40.794]                   }
[17:39:40.794]                   options(future.plan = NULL)
[17:39:40.794]                   if (is.na(NA_character_)) 
[17:39:40.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.794]                     .init = FALSE)
[17:39:40.794]                 }
[17:39:40.794]             }
[17:39:40.794]         }
[17:39:40.794]     })
[17:39:40.794]     if (TRUE) {
[17:39:40.794]         base::sink(type = "output", split = FALSE)
[17:39:40.794]         if (TRUE) {
[17:39:40.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.794]         }
[17:39:40.794]         else {
[17:39:40.794]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.794]         }
[17:39:40.794]         base::close(...future.stdout)
[17:39:40.794]         ...future.stdout <- NULL
[17:39:40.794]     }
[17:39:40.794]     ...future.result$conditions <- ...future.conditions
[17:39:40.794]     ...future.result$finished <- base::Sys.time()
[17:39:40.794]     ...future.result
[17:39:40.794] }
[17:39:40.796] assign_globals() ...
[17:39:40.796] List of 2
[17:39:40.796]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.796]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.796]  - attr(*, "where")=List of 2
[17:39:40.796]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.796]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.796]  - attr(*, "resolved")= logi FALSE
[17:39:40.796]  - attr(*, "total_size")= num 896
[17:39:40.796]  - attr(*, "already-done")= logi TRUE
[17:39:40.800] - copied ‘weight’ to environment
[17:39:40.800] - copied ‘group’ to environment
[17:39:40.800] assign_globals() ... done
[17:39:40.800] requestCore(): workers = 2
[17:39:40.802] MulticoreFuture started
[17:39:40.803] - Launch lazy future ... done
[17:39:40.803] run() for ‘MulticoreFuture’ ... done
[17:39:40.803] result() for MulticoreFuture ...
[17:39:40.804] plan(): Setting new future strategy stack:
[17:39:40.804] List of future strategies:
[17:39:40.804] 1. sequential:
[17:39:40.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.804]    - tweaked: FALSE
[17:39:40.804]    - call: NULL
[17:39:40.805] plan(): nbrOfWorkers() = 1
[17:39:40.808] plan(): Setting new future strategy stack:
[17:39:40.809] List of future strategies:
[17:39:40.809] 1. multicore:
[17:39:40.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.809]    - tweaked: FALSE
[17:39:40.809]    - call: plan(strategy)
[17:39:40.814] plan(): nbrOfWorkers() = 2
[17:39:40.816] result() for MulticoreFuture ...
[17:39:40.816] result() for MulticoreFuture ... done
[17:39:40.816] result() for MulticoreFuture ... done
[17:39:40.816] result() for MulticoreFuture ...
[17:39:40.816] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.819] getGlobalsAndPackages() ...
[17:39:40.820] Searching for globals...
[17:39:40.822] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.822] Searching for globals ... DONE
[17:39:40.822] Resolving globals: FALSE
[17:39:40.822] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.823] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.823] - globals: [2] ‘weight’, ‘group’
[17:39:40.823] - packages: [1] ‘stats’
[17:39:40.823] getGlobalsAndPackages() ... DONE
[17:39:40.824] run() for ‘Future’ ...
[17:39:40.824] - state: ‘created’
[17:39:40.824] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.831]   - Field: ‘label’
[17:39:40.831]   - Field: ‘local’
[17:39:40.831]   - Field: ‘owner’
[17:39:40.831]   - Field: ‘envir’
[17:39:40.831]   - Field: ‘workers’
[17:39:40.831]   - Field: ‘packages’
[17:39:40.832]   - Field: ‘gc’
[17:39:40.832]   - Field: ‘job’
[17:39:40.832]   - Field: ‘conditions’
[17:39:40.832]   - Field: ‘expr’
[17:39:40.832]   - Field: ‘uuid’
[17:39:40.832]   - Field: ‘seed’
[17:39:40.832]   - Field: ‘version’
[17:39:40.832]   - Field: ‘result’
[17:39:40.833]   - Field: ‘asynchronous’
[17:39:40.833]   - Field: ‘calls’
[17:39:40.833]   - Field: ‘globals’
[17:39:40.833]   - Field: ‘stdout’
[17:39:40.833]   - Field: ‘earlySignal’
[17:39:40.833]   - Field: ‘lazy’
[17:39:40.833]   - Field: ‘state’
[17:39:40.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.834] - Launch lazy future ...
[17:39:40.834] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.834] Packages needed by future strategies (n = 0): <none>
[17:39:40.835] {
[17:39:40.835]     {
[17:39:40.835]         {
[17:39:40.835]             ...future.startTime <- base::Sys.time()
[17:39:40.835]             {
[17:39:40.835]                 {
[17:39:40.835]                   {
[17:39:40.835]                     {
[17:39:40.835]                       {
[17:39:40.835]                         base::local({
[17:39:40.835]                           has_future <- base::requireNamespace("future", 
[17:39:40.835]                             quietly = TRUE)
[17:39:40.835]                           if (has_future) {
[17:39:40.835]                             ns <- base::getNamespace("future")
[17:39:40.835]                             version <- ns[[".package"]][["version"]]
[17:39:40.835]                             if (is.null(version)) 
[17:39:40.835]                               version <- utils::packageVersion("future")
[17:39:40.835]                           }
[17:39:40.835]                           else {
[17:39:40.835]                             version <- NULL
[17:39:40.835]                           }
[17:39:40.835]                           if (!has_future || version < "1.8.0") {
[17:39:40.835]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.835]                               "", base::R.version$version.string), 
[17:39:40.835]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.835]                                 base::R.version$platform, 8 * 
[17:39:40.835]                                   base::.Machine$sizeof.pointer), 
[17:39:40.835]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.835]                                 "release", "version")], collapse = " "), 
[17:39:40.835]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.835]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.835]                               info)
[17:39:40.835]                             info <- base::paste(info, collapse = "; ")
[17:39:40.835]                             if (!has_future) {
[17:39:40.835]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.835]                                 info)
[17:39:40.835]                             }
[17:39:40.835]                             else {
[17:39:40.835]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.835]                                 info, version)
[17:39:40.835]                             }
[17:39:40.835]                             base::stop(msg)
[17:39:40.835]                           }
[17:39:40.835]                         })
[17:39:40.835]                       }
[17:39:40.835]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.835]                       base::options(mc.cores = 1L)
[17:39:40.835]                     }
[17:39:40.835]                     base::local({
[17:39:40.835]                       for (pkg in "stats") {
[17:39:40.835]                         base::loadNamespace(pkg)
[17:39:40.835]                         base::library(pkg, character.only = TRUE)
[17:39:40.835]                       }
[17:39:40.835]                     })
[17:39:40.835]                   }
[17:39:40.835]                   ...future.strategy.old <- future::plan("list")
[17:39:40.835]                   options(future.plan = NULL)
[17:39:40.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.835]                 }
[17:39:40.835]                 ...future.workdir <- getwd()
[17:39:40.835]             }
[17:39:40.835]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.835]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.835]         }
[17:39:40.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.835]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.835]             base::names(...future.oldOptions))
[17:39:40.835]     }
[17:39:40.835]     if (FALSE) {
[17:39:40.835]     }
[17:39:40.835]     else {
[17:39:40.835]         if (TRUE) {
[17:39:40.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.835]                 open = "w")
[17:39:40.835]         }
[17:39:40.835]         else {
[17:39:40.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.835]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.835]         }
[17:39:40.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.835]             base::sink(type = "output", split = FALSE)
[17:39:40.835]             base::close(...future.stdout)
[17:39:40.835]         }, add = TRUE)
[17:39:40.835]     }
[17:39:40.835]     ...future.frame <- base::sys.nframe()
[17:39:40.835]     ...future.conditions <- base::list()
[17:39:40.835]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.835]     if (FALSE) {
[17:39:40.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.835]     }
[17:39:40.835]     ...future.result <- base::tryCatch({
[17:39:40.835]         base::withCallingHandlers({
[17:39:40.835]             ...future.value <- base::withVisible(base::local({
[17:39:40.835]                 withCallingHandlers({
[17:39:40.835]                   {
[17:39:40.835]                     lm(weight ~ group - 1)
[17:39:40.835]                   }
[17:39:40.835]                 }, immediateCondition = function(cond) {
[17:39:40.835]                   save_rds <- function (object, pathname, ...) 
[17:39:40.835]                   {
[17:39:40.835]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.835]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.835]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.835]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.835]                         fi_tmp[["mtime"]])
[17:39:40.835]                     }
[17:39:40.835]                     tryCatch({
[17:39:40.835]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.835]                     }, error = function(ex) {
[17:39:40.835]                       msg <- conditionMessage(ex)
[17:39:40.835]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.835]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.835]                         fi_tmp[["mtime"]], msg)
[17:39:40.835]                       ex$message <- msg
[17:39:40.835]                       stop(ex)
[17:39:40.835]                     })
[17:39:40.835]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.835]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.835]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.835]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.835]                       fi <- file.info(pathname)
[17:39:40.835]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.835]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.835]                         fi[["size"]], fi[["mtime"]])
[17:39:40.835]                       stop(msg)
[17:39:40.835]                     }
[17:39:40.835]                     invisible(pathname)
[17:39:40.835]                   }
[17:39:40.835]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.835]                     rootPath = tempdir()) 
[17:39:40.835]                   {
[17:39:40.835]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.835]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.835]                       tmpdir = path, fileext = ".rds")
[17:39:40.835]                     save_rds(obj, file)
[17:39:40.835]                   }
[17:39:40.835]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.835]                   {
[17:39:40.835]                     inherits <- base::inherits
[17:39:40.835]                     invokeRestart <- base::invokeRestart
[17:39:40.835]                     is.null <- base::is.null
[17:39:40.835]                     muffled <- FALSE
[17:39:40.835]                     if (inherits(cond, "message")) {
[17:39:40.835]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.835]                       if (muffled) 
[17:39:40.835]                         invokeRestart("muffleMessage")
[17:39:40.835]                     }
[17:39:40.835]                     else if (inherits(cond, "warning")) {
[17:39:40.835]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.835]                       if (muffled) 
[17:39:40.835]                         invokeRestart("muffleWarning")
[17:39:40.835]                     }
[17:39:40.835]                     else if (inherits(cond, "condition")) {
[17:39:40.835]                       if (!is.null(pattern)) {
[17:39:40.835]                         computeRestarts <- base::computeRestarts
[17:39:40.835]                         grepl <- base::grepl
[17:39:40.835]                         restarts <- computeRestarts(cond)
[17:39:40.835]                         for (restart in restarts) {
[17:39:40.835]                           name <- restart$name
[17:39:40.835]                           if (is.null(name)) 
[17:39:40.835]                             next
[17:39:40.835]                           if (!grepl(pattern, name)) 
[17:39:40.835]                             next
[17:39:40.835]                           invokeRestart(restart)
[17:39:40.835]                           muffled <- TRUE
[17:39:40.835]                           break
[17:39:40.835]                         }
[17:39:40.835]                       }
[17:39:40.835]                     }
[17:39:40.835]                     invisible(muffled)
[17:39:40.835]                   }
[17:39:40.835]                   muffleCondition(cond)
[17:39:40.835]                 })
[17:39:40.835]             }))
[17:39:40.835]             future::FutureResult(value = ...future.value$value, 
[17:39:40.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.835]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.835]                     ...future.globalenv.names))
[17:39:40.835]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.835]         }, condition = base::local({
[17:39:40.835]             c <- base::c
[17:39:40.835]             inherits <- base::inherits
[17:39:40.835]             invokeRestart <- base::invokeRestart
[17:39:40.835]             length <- base::length
[17:39:40.835]             list <- base::list
[17:39:40.835]             seq.int <- base::seq.int
[17:39:40.835]             signalCondition <- base::signalCondition
[17:39:40.835]             sys.calls <- base::sys.calls
[17:39:40.835]             `[[` <- base::`[[`
[17:39:40.835]             `+` <- base::`+`
[17:39:40.835]             `<<-` <- base::`<<-`
[17:39:40.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.835]                   3L)]
[17:39:40.835]             }
[17:39:40.835]             function(cond) {
[17:39:40.835]                 is_error <- inherits(cond, "error")
[17:39:40.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.835]                   NULL)
[17:39:40.835]                 if (is_error) {
[17:39:40.835]                   sessionInformation <- function() {
[17:39:40.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.835]                       search = base::search(), system = base::Sys.info())
[17:39:40.835]                   }
[17:39:40.835]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.835]                     cond$call), session = sessionInformation(), 
[17:39:40.835]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.835]                   signalCondition(cond)
[17:39:40.835]                 }
[17:39:40.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.835]                 "immediateCondition"))) {
[17:39:40.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.835]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.835]                   if (TRUE && !signal) {
[17:39:40.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.835]                     {
[17:39:40.835]                       inherits <- base::inherits
[17:39:40.835]                       invokeRestart <- base::invokeRestart
[17:39:40.835]                       is.null <- base::is.null
[17:39:40.835]                       muffled <- FALSE
[17:39:40.835]                       if (inherits(cond, "message")) {
[17:39:40.835]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.835]                         if (muffled) 
[17:39:40.835]                           invokeRestart("muffleMessage")
[17:39:40.835]                       }
[17:39:40.835]                       else if (inherits(cond, "warning")) {
[17:39:40.835]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.835]                         if (muffled) 
[17:39:40.835]                           invokeRestart("muffleWarning")
[17:39:40.835]                       }
[17:39:40.835]                       else if (inherits(cond, "condition")) {
[17:39:40.835]                         if (!is.null(pattern)) {
[17:39:40.835]                           computeRestarts <- base::computeRestarts
[17:39:40.835]                           grepl <- base::grepl
[17:39:40.835]                           restarts <- computeRestarts(cond)
[17:39:40.835]                           for (restart in restarts) {
[17:39:40.835]                             name <- restart$name
[17:39:40.835]                             if (is.null(name)) 
[17:39:40.835]                               next
[17:39:40.835]                             if (!grepl(pattern, name)) 
[17:39:40.835]                               next
[17:39:40.835]                             invokeRestart(restart)
[17:39:40.835]                             muffled <- TRUE
[17:39:40.835]                             break
[17:39:40.835]                           }
[17:39:40.835]                         }
[17:39:40.835]                       }
[17:39:40.835]                       invisible(muffled)
[17:39:40.835]                     }
[17:39:40.835]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.835]                   }
[17:39:40.835]                 }
[17:39:40.835]                 else {
[17:39:40.835]                   if (TRUE) {
[17:39:40.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.835]                     {
[17:39:40.835]                       inherits <- base::inherits
[17:39:40.835]                       invokeRestart <- base::invokeRestart
[17:39:40.835]                       is.null <- base::is.null
[17:39:40.835]                       muffled <- FALSE
[17:39:40.835]                       if (inherits(cond, "message")) {
[17:39:40.835]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.835]                         if (muffled) 
[17:39:40.835]                           invokeRestart("muffleMessage")
[17:39:40.835]                       }
[17:39:40.835]                       else if (inherits(cond, "warning")) {
[17:39:40.835]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.835]                         if (muffled) 
[17:39:40.835]                           invokeRestart("muffleWarning")
[17:39:40.835]                       }
[17:39:40.835]                       else if (inherits(cond, "condition")) {
[17:39:40.835]                         if (!is.null(pattern)) {
[17:39:40.835]                           computeRestarts <- base::computeRestarts
[17:39:40.835]                           grepl <- base::grepl
[17:39:40.835]                           restarts <- computeRestarts(cond)
[17:39:40.835]                           for (restart in restarts) {
[17:39:40.835]                             name <- restart$name
[17:39:40.835]                             if (is.null(name)) 
[17:39:40.835]                               next
[17:39:40.835]                             if (!grepl(pattern, name)) 
[17:39:40.835]                               next
[17:39:40.835]                             invokeRestart(restart)
[17:39:40.835]                             muffled <- TRUE
[17:39:40.835]                             break
[17:39:40.835]                           }
[17:39:40.835]                         }
[17:39:40.835]                       }
[17:39:40.835]                       invisible(muffled)
[17:39:40.835]                     }
[17:39:40.835]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.835]                   }
[17:39:40.835]                 }
[17:39:40.835]             }
[17:39:40.835]         }))
[17:39:40.835]     }, error = function(ex) {
[17:39:40.835]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.835]                 ...future.rng), started = ...future.startTime, 
[17:39:40.835]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.835]             version = "1.8"), class = "FutureResult")
[17:39:40.835]     }, finally = {
[17:39:40.835]         if (!identical(...future.workdir, getwd())) 
[17:39:40.835]             setwd(...future.workdir)
[17:39:40.835]         {
[17:39:40.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.835]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.835]             }
[17:39:40.835]             base::options(...future.oldOptions)
[17:39:40.835]             if (.Platform$OS.type == "windows") {
[17:39:40.835]                 old_names <- names(...future.oldEnvVars)
[17:39:40.835]                 envs <- base::Sys.getenv()
[17:39:40.835]                 names <- names(envs)
[17:39:40.835]                 common <- intersect(names, old_names)
[17:39:40.835]                 added <- setdiff(names, old_names)
[17:39:40.835]                 removed <- setdiff(old_names, names)
[17:39:40.835]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.835]                   envs[common]]
[17:39:40.835]                 NAMES <- toupper(changed)
[17:39:40.835]                 args <- list()
[17:39:40.835]                 for (kk in seq_along(NAMES)) {
[17:39:40.835]                   name <- changed[[kk]]
[17:39:40.835]                   NAME <- NAMES[[kk]]
[17:39:40.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.835]                     next
[17:39:40.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.835]                 }
[17:39:40.835]                 NAMES <- toupper(added)
[17:39:40.835]                 for (kk in seq_along(NAMES)) {
[17:39:40.835]                   name <- added[[kk]]
[17:39:40.835]                   NAME <- NAMES[[kk]]
[17:39:40.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.835]                     next
[17:39:40.835]                   args[[name]] <- ""
[17:39:40.835]                 }
[17:39:40.835]                 NAMES <- toupper(removed)
[17:39:40.835]                 for (kk in seq_along(NAMES)) {
[17:39:40.835]                   name <- removed[[kk]]
[17:39:40.835]                   NAME <- NAMES[[kk]]
[17:39:40.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.835]                     next
[17:39:40.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.835]                 }
[17:39:40.835]                 if (length(args) > 0) 
[17:39:40.835]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.835]             }
[17:39:40.835]             else {
[17:39:40.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.835]             }
[17:39:40.835]             {
[17:39:40.835]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.835]                   0L) {
[17:39:40.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.835]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.835]                   base::options(opts)
[17:39:40.835]                 }
[17:39:40.835]                 {
[17:39:40.835]                   {
[17:39:40.835]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.835]                     NULL
[17:39:40.835]                   }
[17:39:40.835]                   options(future.plan = NULL)
[17:39:40.835]                   if (is.na(NA_character_)) 
[17:39:40.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.835]                     .init = FALSE)
[17:39:40.835]                 }
[17:39:40.835]             }
[17:39:40.835]         }
[17:39:40.835]     })
[17:39:40.835]     if (TRUE) {
[17:39:40.835]         base::sink(type = "output", split = FALSE)
[17:39:40.835]         if (TRUE) {
[17:39:40.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.835]         }
[17:39:40.835]         else {
[17:39:40.835]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.835]         }
[17:39:40.835]         base::close(...future.stdout)
[17:39:40.835]         ...future.stdout <- NULL
[17:39:40.835]     }
[17:39:40.835]     ...future.result$conditions <- ...future.conditions
[17:39:40.835]     ...future.result$finished <- base::Sys.time()
[17:39:40.835]     ...future.result
[17:39:40.835] }
[17:39:40.837] assign_globals() ...
[17:39:40.837] List of 2
[17:39:40.837]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.837]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.837]  - attr(*, "where")=List of 2
[17:39:40.837]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.837]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.837]  - attr(*, "resolved")= logi FALSE
[17:39:40.837]  - attr(*, "total_size")= num 896
[17:39:40.837]  - attr(*, "already-done")= logi TRUE
[17:39:40.841] - copied ‘weight’ to environment
[17:39:40.841] - copied ‘group’ to environment
[17:39:40.841] assign_globals() ... done
[17:39:40.841] requestCore(): workers = 2
[17:39:40.843] MulticoreFuture started
[17:39:40.844] - Launch lazy future ... done
[17:39:40.844] run() for ‘MulticoreFuture’ ... done
[17:39:40.844] result() for MulticoreFuture ...
[17:39:40.845] plan(): Setting new future strategy stack:
[17:39:40.845] List of future strategies:
[17:39:40.845] 1. sequential:
[17:39:40.845]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.845]    - tweaked: FALSE
[17:39:40.845]    - call: NULL
[17:39:40.846] plan(): nbrOfWorkers() = 1
[17:39:40.850] plan(): Setting new future strategy stack:
[17:39:40.850] List of future strategies:
[17:39:40.850] 1. multicore:
[17:39:40.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.850]    - tweaked: FALSE
[17:39:40.850]    - call: plan(strategy)
[17:39:40.855] plan(): nbrOfWorkers() = 2
[17:39:40.858] result() for MulticoreFuture ...
[17:39:40.858] result() for MulticoreFuture ... done
[17:39:40.858] result() for MulticoreFuture ... done
[17:39:40.858] result() for MulticoreFuture ...
[17:39:40.858] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:40.861] getGlobalsAndPackages() ...
[17:39:40.861] Searching for globals...
[17:39:40.863] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:40.864] Searching for globals ... DONE
[17:39:40.864] Resolving globals: FALSE
[17:39:40.864] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:40.865] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:40.865] - globals: [2] ‘weight’, ‘group’
[17:39:40.865] - packages: [1] ‘stats’
[17:39:40.865] getGlobalsAndPackages() ... DONE
[17:39:40.866] run() for ‘Future’ ...
[17:39:40.866] - state: ‘created’
[17:39:40.866] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.870] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.870]   - Field: ‘label’
[17:39:40.870]   - Field: ‘local’
[17:39:40.870]   - Field: ‘owner’
[17:39:40.871]   - Field: ‘envir’
[17:39:40.871]   - Field: ‘workers’
[17:39:40.871]   - Field: ‘packages’
[17:39:40.871]   - Field: ‘gc’
[17:39:40.871]   - Field: ‘job’
[17:39:40.871]   - Field: ‘conditions’
[17:39:40.871]   - Field: ‘expr’
[17:39:40.871]   - Field: ‘uuid’
[17:39:40.871]   - Field: ‘seed’
[17:39:40.872]   - Field: ‘version’
[17:39:40.872]   - Field: ‘result’
[17:39:40.872]   - Field: ‘asynchronous’
[17:39:40.872]   - Field: ‘calls’
[17:39:40.872]   - Field: ‘globals’
[17:39:40.872]   - Field: ‘stdout’
[17:39:40.872]   - Field: ‘earlySignal’
[17:39:40.872]   - Field: ‘lazy’
[17:39:40.872]   - Field: ‘state’
[17:39:40.873] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.873] - Launch lazy future ...
[17:39:40.873] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.873] Packages needed by future strategies (n = 0): <none>
[17:39:40.874] {
[17:39:40.874]     {
[17:39:40.874]         {
[17:39:40.874]             ...future.startTime <- base::Sys.time()
[17:39:40.874]             {
[17:39:40.874]                 {
[17:39:40.874]                   {
[17:39:40.874]                     {
[17:39:40.874]                       {
[17:39:40.874]                         base::local({
[17:39:40.874]                           has_future <- base::requireNamespace("future", 
[17:39:40.874]                             quietly = TRUE)
[17:39:40.874]                           if (has_future) {
[17:39:40.874]                             ns <- base::getNamespace("future")
[17:39:40.874]                             version <- ns[[".package"]][["version"]]
[17:39:40.874]                             if (is.null(version)) 
[17:39:40.874]                               version <- utils::packageVersion("future")
[17:39:40.874]                           }
[17:39:40.874]                           else {
[17:39:40.874]                             version <- NULL
[17:39:40.874]                           }
[17:39:40.874]                           if (!has_future || version < "1.8.0") {
[17:39:40.874]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.874]                               "", base::R.version$version.string), 
[17:39:40.874]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.874]                                 base::R.version$platform, 8 * 
[17:39:40.874]                                   base::.Machine$sizeof.pointer), 
[17:39:40.874]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.874]                                 "release", "version")], collapse = " "), 
[17:39:40.874]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.874]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.874]                               info)
[17:39:40.874]                             info <- base::paste(info, collapse = "; ")
[17:39:40.874]                             if (!has_future) {
[17:39:40.874]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.874]                                 info)
[17:39:40.874]                             }
[17:39:40.874]                             else {
[17:39:40.874]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.874]                                 info, version)
[17:39:40.874]                             }
[17:39:40.874]                             base::stop(msg)
[17:39:40.874]                           }
[17:39:40.874]                         })
[17:39:40.874]                       }
[17:39:40.874]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.874]                       base::options(mc.cores = 1L)
[17:39:40.874]                     }
[17:39:40.874]                     base::local({
[17:39:40.874]                       for (pkg in "stats") {
[17:39:40.874]                         base::loadNamespace(pkg)
[17:39:40.874]                         base::library(pkg, character.only = TRUE)
[17:39:40.874]                       }
[17:39:40.874]                     })
[17:39:40.874]                   }
[17:39:40.874]                   ...future.strategy.old <- future::plan("list")
[17:39:40.874]                   options(future.plan = NULL)
[17:39:40.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.874]                 }
[17:39:40.874]                 ...future.workdir <- getwd()
[17:39:40.874]             }
[17:39:40.874]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.874]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.874]         }
[17:39:40.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.874]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.874]             base::names(...future.oldOptions))
[17:39:40.874]     }
[17:39:40.874]     if (FALSE) {
[17:39:40.874]     }
[17:39:40.874]     else {
[17:39:40.874]         if (TRUE) {
[17:39:40.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.874]                 open = "w")
[17:39:40.874]         }
[17:39:40.874]         else {
[17:39:40.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.874]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.874]         }
[17:39:40.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.874]             base::sink(type = "output", split = FALSE)
[17:39:40.874]             base::close(...future.stdout)
[17:39:40.874]         }, add = TRUE)
[17:39:40.874]     }
[17:39:40.874]     ...future.frame <- base::sys.nframe()
[17:39:40.874]     ...future.conditions <- base::list()
[17:39:40.874]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.874]     if (FALSE) {
[17:39:40.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.874]     }
[17:39:40.874]     ...future.result <- base::tryCatch({
[17:39:40.874]         base::withCallingHandlers({
[17:39:40.874]             ...future.value <- base::withVisible(base::local({
[17:39:40.874]                 withCallingHandlers({
[17:39:40.874]                   {
[17:39:40.874]                     lm(weight ~ group - 1)
[17:39:40.874]                   }
[17:39:40.874]                 }, immediateCondition = function(cond) {
[17:39:40.874]                   save_rds <- function (object, pathname, ...) 
[17:39:40.874]                   {
[17:39:40.874]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.874]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.874]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.874]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.874]                         fi_tmp[["mtime"]])
[17:39:40.874]                     }
[17:39:40.874]                     tryCatch({
[17:39:40.874]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.874]                     }, error = function(ex) {
[17:39:40.874]                       msg <- conditionMessage(ex)
[17:39:40.874]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.874]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.874]                         fi_tmp[["mtime"]], msg)
[17:39:40.874]                       ex$message <- msg
[17:39:40.874]                       stop(ex)
[17:39:40.874]                     })
[17:39:40.874]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.874]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.874]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.874]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.874]                       fi <- file.info(pathname)
[17:39:40.874]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.874]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.874]                         fi[["size"]], fi[["mtime"]])
[17:39:40.874]                       stop(msg)
[17:39:40.874]                     }
[17:39:40.874]                     invisible(pathname)
[17:39:40.874]                   }
[17:39:40.874]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.874]                     rootPath = tempdir()) 
[17:39:40.874]                   {
[17:39:40.874]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.874]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.874]                       tmpdir = path, fileext = ".rds")
[17:39:40.874]                     save_rds(obj, file)
[17:39:40.874]                   }
[17:39:40.874]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.874]                   {
[17:39:40.874]                     inherits <- base::inherits
[17:39:40.874]                     invokeRestart <- base::invokeRestart
[17:39:40.874]                     is.null <- base::is.null
[17:39:40.874]                     muffled <- FALSE
[17:39:40.874]                     if (inherits(cond, "message")) {
[17:39:40.874]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.874]                       if (muffled) 
[17:39:40.874]                         invokeRestart("muffleMessage")
[17:39:40.874]                     }
[17:39:40.874]                     else if (inherits(cond, "warning")) {
[17:39:40.874]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.874]                       if (muffled) 
[17:39:40.874]                         invokeRestart("muffleWarning")
[17:39:40.874]                     }
[17:39:40.874]                     else if (inherits(cond, "condition")) {
[17:39:40.874]                       if (!is.null(pattern)) {
[17:39:40.874]                         computeRestarts <- base::computeRestarts
[17:39:40.874]                         grepl <- base::grepl
[17:39:40.874]                         restarts <- computeRestarts(cond)
[17:39:40.874]                         for (restart in restarts) {
[17:39:40.874]                           name <- restart$name
[17:39:40.874]                           if (is.null(name)) 
[17:39:40.874]                             next
[17:39:40.874]                           if (!grepl(pattern, name)) 
[17:39:40.874]                             next
[17:39:40.874]                           invokeRestart(restart)
[17:39:40.874]                           muffled <- TRUE
[17:39:40.874]                           break
[17:39:40.874]                         }
[17:39:40.874]                       }
[17:39:40.874]                     }
[17:39:40.874]                     invisible(muffled)
[17:39:40.874]                   }
[17:39:40.874]                   muffleCondition(cond)
[17:39:40.874]                 })
[17:39:40.874]             }))
[17:39:40.874]             future::FutureResult(value = ...future.value$value, 
[17:39:40.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.874]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.874]                     ...future.globalenv.names))
[17:39:40.874]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.874]         }, condition = base::local({
[17:39:40.874]             c <- base::c
[17:39:40.874]             inherits <- base::inherits
[17:39:40.874]             invokeRestart <- base::invokeRestart
[17:39:40.874]             length <- base::length
[17:39:40.874]             list <- base::list
[17:39:40.874]             seq.int <- base::seq.int
[17:39:40.874]             signalCondition <- base::signalCondition
[17:39:40.874]             sys.calls <- base::sys.calls
[17:39:40.874]             `[[` <- base::`[[`
[17:39:40.874]             `+` <- base::`+`
[17:39:40.874]             `<<-` <- base::`<<-`
[17:39:40.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.874]                   3L)]
[17:39:40.874]             }
[17:39:40.874]             function(cond) {
[17:39:40.874]                 is_error <- inherits(cond, "error")
[17:39:40.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.874]                   NULL)
[17:39:40.874]                 if (is_error) {
[17:39:40.874]                   sessionInformation <- function() {
[17:39:40.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.874]                       search = base::search(), system = base::Sys.info())
[17:39:40.874]                   }
[17:39:40.874]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.874]                     cond$call), session = sessionInformation(), 
[17:39:40.874]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.874]                   signalCondition(cond)
[17:39:40.874]                 }
[17:39:40.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.874]                 "immediateCondition"))) {
[17:39:40.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.874]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.874]                   if (TRUE && !signal) {
[17:39:40.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.874]                     {
[17:39:40.874]                       inherits <- base::inherits
[17:39:40.874]                       invokeRestart <- base::invokeRestart
[17:39:40.874]                       is.null <- base::is.null
[17:39:40.874]                       muffled <- FALSE
[17:39:40.874]                       if (inherits(cond, "message")) {
[17:39:40.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.874]                         if (muffled) 
[17:39:40.874]                           invokeRestart("muffleMessage")
[17:39:40.874]                       }
[17:39:40.874]                       else if (inherits(cond, "warning")) {
[17:39:40.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.874]                         if (muffled) 
[17:39:40.874]                           invokeRestart("muffleWarning")
[17:39:40.874]                       }
[17:39:40.874]                       else if (inherits(cond, "condition")) {
[17:39:40.874]                         if (!is.null(pattern)) {
[17:39:40.874]                           computeRestarts <- base::computeRestarts
[17:39:40.874]                           grepl <- base::grepl
[17:39:40.874]                           restarts <- computeRestarts(cond)
[17:39:40.874]                           for (restart in restarts) {
[17:39:40.874]                             name <- restart$name
[17:39:40.874]                             if (is.null(name)) 
[17:39:40.874]                               next
[17:39:40.874]                             if (!grepl(pattern, name)) 
[17:39:40.874]                               next
[17:39:40.874]                             invokeRestart(restart)
[17:39:40.874]                             muffled <- TRUE
[17:39:40.874]                             break
[17:39:40.874]                           }
[17:39:40.874]                         }
[17:39:40.874]                       }
[17:39:40.874]                       invisible(muffled)
[17:39:40.874]                     }
[17:39:40.874]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.874]                   }
[17:39:40.874]                 }
[17:39:40.874]                 else {
[17:39:40.874]                   if (TRUE) {
[17:39:40.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.874]                     {
[17:39:40.874]                       inherits <- base::inherits
[17:39:40.874]                       invokeRestart <- base::invokeRestart
[17:39:40.874]                       is.null <- base::is.null
[17:39:40.874]                       muffled <- FALSE
[17:39:40.874]                       if (inherits(cond, "message")) {
[17:39:40.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.874]                         if (muffled) 
[17:39:40.874]                           invokeRestart("muffleMessage")
[17:39:40.874]                       }
[17:39:40.874]                       else if (inherits(cond, "warning")) {
[17:39:40.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.874]                         if (muffled) 
[17:39:40.874]                           invokeRestart("muffleWarning")
[17:39:40.874]                       }
[17:39:40.874]                       else if (inherits(cond, "condition")) {
[17:39:40.874]                         if (!is.null(pattern)) {
[17:39:40.874]                           computeRestarts <- base::computeRestarts
[17:39:40.874]                           grepl <- base::grepl
[17:39:40.874]                           restarts <- computeRestarts(cond)
[17:39:40.874]                           for (restart in restarts) {
[17:39:40.874]                             name <- restart$name
[17:39:40.874]                             if (is.null(name)) 
[17:39:40.874]                               next
[17:39:40.874]                             if (!grepl(pattern, name)) 
[17:39:40.874]                               next
[17:39:40.874]                             invokeRestart(restart)
[17:39:40.874]                             muffled <- TRUE
[17:39:40.874]                             break
[17:39:40.874]                           }
[17:39:40.874]                         }
[17:39:40.874]                       }
[17:39:40.874]                       invisible(muffled)
[17:39:40.874]                     }
[17:39:40.874]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.874]                   }
[17:39:40.874]                 }
[17:39:40.874]             }
[17:39:40.874]         }))
[17:39:40.874]     }, error = function(ex) {
[17:39:40.874]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.874]                 ...future.rng), started = ...future.startTime, 
[17:39:40.874]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.874]             version = "1.8"), class = "FutureResult")
[17:39:40.874]     }, finally = {
[17:39:40.874]         if (!identical(...future.workdir, getwd())) 
[17:39:40.874]             setwd(...future.workdir)
[17:39:40.874]         {
[17:39:40.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.874]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.874]             }
[17:39:40.874]             base::options(...future.oldOptions)
[17:39:40.874]             if (.Platform$OS.type == "windows") {
[17:39:40.874]                 old_names <- names(...future.oldEnvVars)
[17:39:40.874]                 envs <- base::Sys.getenv()
[17:39:40.874]                 names <- names(envs)
[17:39:40.874]                 common <- intersect(names, old_names)
[17:39:40.874]                 added <- setdiff(names, old_names)
[17:39:40.874]                 removed <- setdiff(old_names, names)
[17:39:40.874]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.874]                   envs[common]]
[17:39:40.874]                 NAMES <- toupper(changed)
[17:39:40.874]                 args <- list()
[17:39:40.874]                 for (kk in seq_along(NAMES)) {
[17:39:40.874]                   name <- changed[[kk]]
[17:39:40.874]                   NAME <- NAMES[[kk]]
[17:39:40.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.874]                     next
[17:39:40.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.874]                 }
[17:39:40.874]                 NAMES <- toupper(added)
[17:39:40.874]                 for (kk in seq_along(NAMES)) {
[17:39:40.874]                   name <- added[[kk]]
[17:39:40.874]                   NAME <- NAMES[[kk]]
[17:39:40.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.874]                     next
[17:39:40.874]                   args[[name]] <- ""
[17:39:40.874]                 }
[17:39:40.874]                 NAMES <- toupper(removed)
[17:39:40.874]                 for (kk in seq_along(NAMES)) {
[17:39:40.874]                   name <- removed[[kk]]
[17:39:40.874]                   NAME <- NAMES[[kk]]
[17:39:40.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.874]                     next
[17:39:40.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.874]                 }
[17:39:40.874]                 if (length(args) > 0) 
[17:39:40.874]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.874]             }
[17:39:40.874]             else {
[17:39:40.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.874]             }
[17:39:40.874]             {
[17:39:40.874]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.874]                   0L) {
[17:39:40.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.874]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.874]                   base::options(opts)
[17:39:40.874]                 }
[17:39:40.874]                 {
[17:39:40.874]                   {
[17:39:40.874]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.874]                     NULL
[17:39:40.874]                   }
[17:39:40.874]                   options(future.plan = NULL)
[17:39:40.874]                   if (is.na(NA_character_)) 
[17:39:40.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.874]                     .init = FALSE)
[17:39:40.874]                 }
[17:39:40.874]             }
[17:39:40.874]         }
[17:39:40.874]     })
[17:39:40.874]     if (TRUE) {
[17:39:40.874]         base::sink(type = "output", split = FALSE)
[17:39:40.874]         if (TRUE) {
[17:39:40.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.874]         }
[17:39:40.874]         else {
[17:39:40.874]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.874]         }
[17:39:40.874]         base::close(...future.stdout)
[17:39:40.874]         ...future.stdout <- NULL
[17:39:40.874]     }
[17:39:40.874]     ...future.result$conditions <- ...future.conditions
[17:39:40.874]     ...future.result$finished <- base::Sys.time()
[17:39:40.874]     ...future.result
[17:39:40.874] }
[17:39:40.876] assign_globals() ...
[17:39:40.877] List of 2
[17:39:40.877]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[17:39:40.877]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:40.877]  - attr(*, "where")=List of 2
[17:39:40.877]   ..$ weight:<environment: R_EmptyEnv> 
[17:39:40.877]   ..$ group :<environment: R_EmptyEnv> 
[17:39:40.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.877]  - attr(*, "resolved")= logi FALSE
[17:39:40.877]  - attr(*, "total_size")= num 896
[17:39:40.877]  - attr(*, "already-done")= logi TRUE
[17:39:40.883] - copied ‘weight’ to environment
[17:39:40.883] - copied ‘group’ to environment
[17:39:40.883] assign_globals() ... done
[17:39:40.883] requestCore(): workers = 2
[17:39:40.885] MulticoreFuture started
[17:39:40.885] - Launch lazy future ... done
[17:39:40.886] run() for ‘MulticoreFuture’ ... done
[17:39:40.886] result() for MulticoreFuture ...
[17:39:40.886] plan(): Setting new future strategy stack:
[17:39:40.887] List of future strategies:
[17:39:40.887] 1. sequential:
[17:39:40.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.887]    - tweaked: FALSE
[17:39:40.887]    - call: NULL
[17:39:40.888] plan(): nbrOfWorkers() = 1
[17:39:40.891] plan(): Setting new future strategy stack:
[17:39:40.891] List of future strategies:
[17:39:40.891] 1. multicore:
[17:39:40.891]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.891]    - tweaked: FALSE
[17:39:40.891]    - call: plan(strategy)
[17:39:40.897] plan(): nbrOfWorkers() = 2
[17:39:40.899] result() for MulticoreFuture ...
[17:39:40.899] result() for MulticoreFuture ... done
[17:39:40.899] result() for MulticoreFuture ... done
[17:39:40.899] result() for MulticoreFuture ...
[17:39:40.899] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:39:40.903] getGlobalsAndPackages() ...
[17:39:40.903] Searching for globals...
[17:39:40.904] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:39:40.904] Searching for globals ... DONE
[17:39:40.905] Resolving globals: FALSE
[17:39:40.905] The total size of the 1 globals is 96 bytes (96 bytes)
[17:39:40.906] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:39:40.906] - globals: [1] ‘x’
[17:39:40.906] - packages: [1] ‘stats’
[17:39:40.906] getGlobalsAndPackages() ... DONE
[17:39:40.906] run() for ‘Future’ ...
[17:39:40.906] - state: ‘created’
[17:39:40.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.911] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.911] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.911]   - Field: ‘label’
[17:39:40.911]   - Field: ‘local’
[17:39:40.911]   - Field: ‘owner’
[17:39:40.911]   - Field: ‘envir’
[17:39:40.912]   - Field: ‘workers’
[17:39:40.912]   - Field: ‘packages’
[17:39:40.912]   - Field: ‘gc’
[17:39:40.912]   - Field: ‘job’
[17:39:40.912]   - Field: ‘conditions’
[17:39:40.912]   - Field: ‘expr’
[17:39:40.912]   - Field: ‘uuid’
[17:39:40.912]   - Field: ‘seed’
[17:39:40.912]   - Field: ‘version’
[17:39:40.913]   - Field: ‘result’
[17:39:40.913]   - Field: ‘asynchronous’
[17:39:40.913]   - Field: ‘calls’
[17:39:40.913]   - Field: ‘globals’
[17:39:40.913]   - Field: ‘stdout’
[17:39:40.913]   - Field: ‘earlySignal’
[17:39:40.913]   - Field: ‘lazy’
[17:39:40.913]   - Field: ‘state’
[17:39:40.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.914] - Launch lazy future ...
[17:39:40.914] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.914] Packages needed by future strategies (n = 0): <none>
[17:39:40.915] {
[17:39:40.915]     {
[17:39:40.915]         {
[17:39:40.915]             ...future.startTime <- base::Sys.time()
[17:39:40.915]             {
[17:39:40.915]                 {
[17:39:40.915]                   {
[17:39:40.915]                     {
[17:39:40.915]                       {
[17:39:40.915]                         base::local({
[17:39:40.915]                           has_future <- base::requireNamespace("future", 
[17:39:40.915]                             quietly = TRUE)
[17:39:40.915]                           if (has_future) {
[17:39:40.915]                             ns <- base::getNamespace("future")
[17:39:40.915]                             version <- ns[[".package"]][["version"]]
[17:39:40.915]                             if (is.null(version)) 
[17:39:40.915]                               version <- utils::packageVersion("future")
[17:39:40.915]                           }
[17:39:40.915]                           else {
[17:39:40.915]                             version <- NULL
[17:39:40.915]                           }
[17:39:40.915]                           if (!has_future || version < "1.8.0") {
[17:39:40.915]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.915]                               "", base::R.version$version.string), 
[17:39:40.915]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.915]                                 base::R.version$platform, 8 * 
[17:39:40.915]                                   base::.Machine$sizeof.pointer), 
[17:39:40.915]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.915]                                 "release", "version")], collapse = " "), 
[17:39:40.915]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.915]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.915]                               info)
[17:39:40.915]                             info <- base::paste(info, collapse = "; ")
[17:39:40.915]                             if (!has_future) {
[17:39:40.915]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.915]                                 info)
[17:39:40.915]                             }
[17:39:40.915]                             else {
[17:39:40.915]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.915]                                 info, version)
[17:39:40.915]                             }
[17:39:40.915]                             base::stop(msg)
[17:39:40.915]                           }
[17:39:40.915]                         })
[17:39:40.915]                       }
[17:39:40.915]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.915]                       base::options(mc.cores = 1L)
[17:39:40.915]                     }
[17:39:40.915]                     base::local({
[17:39:40.915]                       for (pkg in "stats") {
[17:39:40.915]                         base::loadNamespace(pkg)
[17:39:40.915]                         base::library(pkg, character.only = TRUE)
[17:39:40.915]                       }
[17:39:40.915]                     })
[17:39:40.915]                   }
[17:39:40.915]                   ...future.strategy.old <- future::plan("list")
[17:39:40.915]                   options(future.plan = NULL)
[17:39:40.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.915]                 }
[17:39:40.915]                 ...future.workdir <- getwd()
[17:39:40.915]             }
[17:39:40.915]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.915]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.915]         }
[17:39:40.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.915]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.915]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.915]             base::names(...future.oldOptions))
[17:39:40.915]     }
[17:39:40.915]     if (FALSE) {
[17:39:40.915]     }
[17:39:40.915]     else {
[17:39:40.915]         if (TRUE) {
[17:39:40.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.915]                 open = "w")
[17:39:40.915]         }
[17:39:40.915]         else {
[17:39:40.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.915]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.915]         }
[17:39:40.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.915]             base::sink(type = "output", split = FALSE)
[17:39:40.915]             base::close(...future.stdout)
[17:39:40.915]         }, add = TRUE)
[17:39:40.915]     }
[17:39:40.915]     ...future.frame <- base::sys.nframe()
[17:39:40.915]     ...future.conditions <- base::list()
[17:39:40.915]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.915]     if (FALSE) {
[17:39:40.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.915]     }
[17:39:40.915]     ...future.result <- base::tryCatch({
[17:39:40.915]         base::withCallingHandlers({
[17:39:40.915]             ...future.value <- base::withVisible(base::local({
[17:39:40.915]                 withCallingHandlers({
[17:39:40.915]                   {
[17:39:40.915]                     xtabs(~x)
[17:39:40.915]                   }
[17:39:40.915]                 }, immediateCondition = function(cond) {
[17:39:40.915]                   save_rds <- function (object, pathname, ...) 
[17:39:40.915]                   {
[17:39:40.915]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.915]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.915]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.915]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.915]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.915]                         fi_tmp[["mtime"]])
[17:39:40.915]                     }
[17:39:40.915]                     tryCatch({
[17:39:40.915]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.915]                     }, error = function(ex) {
[17:39:40.915]                       msg <- conditionMessage(ex)
[17:39:40.915]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.915]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.915]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.915]                         fi_tmp[["mtime"]], msg)
[17:39:40.915]                       ex$message <- msg
[17:39:40.915]                       stop(ex)
[17:39:40.915]                     })
[17:39:40.915]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.915]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.915]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.915]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.915]                       fi <- file.info(pathname)
[17:39:40.915]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.915]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.915]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.915]                         fi[["size"]], fi[["mtime"]])
[17:39:40.915]                       stop(msg)
[17:39:40.915]                     }
[17:39:40.915]                     invisible(pathname)
[17:39:40.915]                   }
[17:39:40.915]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.915]                     rootPath = tempdir()) 
[17:39:40.915]                   {
[17:39:40.915]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.915]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.915]                       tmpdir = path, fileext = ".rds")
[17:39:40.915]                     save_rds(obj, file)
[17:39:40.915]                   }
[17:39:40.915]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.915]                   {
[17:39:40.915]                     inherits <- base::inherits
[17:39:40.915]                     invokeRestart <- base::invokeRestart
[17:39:40.915]                     is.null <- base::is.null
[17:39:40.915]                     muffled <- FALSE
[17:39:40.915]                     if (inherits(cond, "message")) {
[17:39:40.915]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.915]                       if (muffled) 
[17:39:40.915]                         invokeRestart("muffleMessage")
[17:39:40.915]                     }
[17:39:40.915]                     else if (inherits(cond, "warning")) {
[17:39:40.915]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.915]                       if (muffled) 
[17:39:40.915]                         invokeRestart("muffleWarning")
[17:39:40.915]                     }
[17:39:40.915]                     else if (inherits(cond, "condition")) {
[17:39:40.915]                       if (!is.null(pattern)) {
[17:39:40.915]                         computeRestarts <- base::computeRestarts
[17:39:40.915]                         grepl <- base::grepl
[17:39:40.915]                         restarts <- computeRestarts(cond)
[17:39:40.915]                         for (restart in restarts) {
[17:39:40.915]                           name <- restart$name
[17:39:40.915]                           if (is.null(name)) 
[17:39:40.915]                             next
[17:39:40.915]                           if (!grepl(pattern, name)) 
[17:39:40.915]                             next
[17:39:40.915]                           invokeRestart(restart)
[17:39:40.915]                           muffled <- TRUE
[17:39:40.915]                           break
[17:39:40.915]                         }
[17:39:40.915]                       }
[17:39:40.915]                     }
[17:39:40.915]                     invisible(muffled)
[17:39:40.915]                   }
[17:39:40.915]                   muffleCondition(cond)
[17:39:40.915]                 })
[17:39:40.915]             }))
[17:39:40.915]             future::FutureResult(value = ...future.value$value, 
[17:39:40.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.915]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.915]                     ...future.globalenv.names))
[17:39:40.915]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.915]         }, condition = base::local({
[17:39:40.915]             c <- base::c
[17:39:40.915]             inherits <- base::inherits
[17:39:40.915]             invokeRestart <- base::invokeRestart
[17:39:40.915]             length <- base::length
[17:39:40.915]             list <- base::list
[17:39:40.915]             seq.int <- base::seq.int
[17:39:40.915]             signalCondition <- base::signalCondition
[17:39:40.915]             sys.calls <- base::sys.calls
[17:39:40.915]             `[[` <- base::`[[`
[17:39:40.915]             `+` <- base::`+`
[17:39:40.915]             `<<-` <- base::`<<-`
[17:39:40.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.915]                   3L)]
[17:39:40.915]             }
[17:39:40.915]             function(cond) {
[17:39:40.915]                 is_error <- inherits(cond, "error")
[17:39:40.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.915]                   NULL)
[17:39:40.915]                 if (is_error) {
[17:39:40.915]                   sessionInformation <- function() {
[17:39:40.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.915]                       search = base::search(), system = base::Sys.info())
[17:39:40.915]                   }
[17:39:40.915]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.915]                     cond$call), session = sessionInformation(), 
[17:39:40.915]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.915]                   signalCondition(cond)
[17:39:40.915]                 }
[17:39:40.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.915]                 "immediateCondition"))) {
[17:39:40.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.915]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.915]                   if (TRUE && !signal) {
[17:39:40.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.915]                     {
[17:39:40.915]                       inherits <- base::inherits
[17:39:40.915]                       invokeRestart <- base::invokeRestart
[17:39:40.915]                       is.null <- base::is.null
[17:39:40.915]                       muffled <- FALSE
[17:39:40.915]                       if (inherits(cond, "message")) {
[17:39:40.915]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.915]                         if (muffled) 
[17:39:40.915]                           invokeRestart("muffleMessage")
[17:39:40.915]                       }
[17:39:40.915]                       else if (inherits(cond, "warning")) {
[17:39:40.915]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.915]                         if (muffled) 
[17:39:40.915]                           invokeRestart("muffleWarning")
[17:39:40.915]                       }
[17:39:40.915]                       else if (inherits(cond, "condition")) {
[17:39:40.915]                         if (!is.null(pattern)) {
[17:39:40.915]                           computeRestarts <- base::computeRestarts
[17:39:40.915]                           grepl <- base::grepl
[17:39:40.915]                           restarts <- computeRestarts(cond)
[17:39:40.915]                           for (restart in restarts) {
[17:39:40.915]                             name <- restart$name
[17:39:40.915]                             if (is.null(name)) 
[17:39:40.915]                               next
[17:39:40.915]                             if (!grepl(pattern, name)) 
[17:39:40.915]                               next
[17:39:40.915]                             invokeRestart(restart)
[17:39:40.915]                             muffled <- TRUE
[17:39:40.915]                             break
[17:39:40.915]                           }
[17:39:40.915]                         }
[17:39:40.915]                       }
[17:39:40.915]                       invisible(muffled)
[17:39:40.915]                     }
[17:39:40.915]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.915]                   }
[17:39:40.915]                 }
[17:39:40.915]                 else {
[17:39:40.915]                   if (TRUE) {
[17:39:40.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.915]                     {
[17:39:40.915]                       inherits <- base::inherits
[17:39:40.915]                       invokeRestart <- base::invokeRestart
[17:39:40.915]                       is.null <- base::is.null
[17:39:40.915]                       muffled <- FALSE
[17:39:40.915]                       if (inherits(cond, "message")) {
[17:39:40.915]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.915]                         if (muffled) 
[17:39:40.915]                           invokeRestart("muffleMessage")
[17:39:40.915]                       }
[17:39:40.915]                       else if (inherits(cond, "warning")) {
[17:39:40.915]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.915]                         if (muffled) 
[17:39:40.915]                           invokeRestart("muffleWarning")
[17:39:40.915]                       }
[17:39:40.915]                       else if (inherits(cond, "condition")) {
[17:39:40.915]                         if (!is.null(pattern)) {
[17:39:40.915]                           computeRestarts <- base::computeRestarts
[17:39:40.915]                           grepl <- base::grepl
[17:39:40.915]                           restarts <- computeRestarts(cond)
[17:39:40.915]                           for (restart in restarts) {
[17:39:40.915]                             name <- restart$name
[17:39:40.915]                             if (is.null(name)) 
[17:39:40.915]                               next
[17:39:40.915]                             if (!grepl(pattern, name)) 
[17:39:40.915]                               next
[17:39:40.915]                             invokeRestart(restart)
[17:39:40.915]                             muffled <- TRUE
[17:39:40.915]                             break
[17:39:40.915]                           }
[17:39:40.915]                         }
[17:39:40.915]                       }
[17:39:40.915]                       invisible(muffled)
[17:39:40.915]                     }
[17:39:40.915]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.915]                   }
[17:39:40.915]                 }
[17:39:40.915]             }
[17:39:40.915]         }))
[17:39:40.915]     }, error = function(ex) {
[17:39:40.915]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.915]                 ...future.rng), started = ...future.startTime, 
[17:39:40.915]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.915]             version = "1.8"), class = "FutureResult")
[17:39:40.915]     }, finally = {
[17:39:40.915]         if (!identical(...future.workdir, getwd())) 
[17:39:40.915]             setwd(...future.workdir)
[17:39:40.915]         {
[17:39:40.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.915]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.915]             }
[17:39:40.915]             base::options(...future.oldOptions)
[17:39:40.915]             if (.Platform$OS.type == "windows") {
[17:39:40.915]                 old_names <- names(...future.oldEnvVars)
[17:39:40.915]                 envs <- base::Sys.getenv()
[17:39:40.915]                 names <- names(envs)
[17:39:40.915]                 common <- intersect(names, old_names)
[17:39:40.915]                 added <- setdiff(names, old_names)
[17:39:40.915]                 removed <- setdiff(old_names, names)
[17:39:40.915]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.915]                   envs[common]]
[17:39:40.915]                 NAMES <- toupper(changed)
[17:39:40.915]                 args <- list()
[17:39:40.915]                 for (kk in seq_along(NAMES)) {
[17:39:40.915]                   name <- changed[[kk]]
[17:39:40.915]                   NAME <- NAMES[[kk]]
[17:39:40.915]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.915]                     next
[17:39:40.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.915]                 }
[17:39:40.915]                 NAMES <- toupper(added)
[17:39:40.915]                 for (kk in seq_along(NAMES)) {
[17:39:40.915]                   name <- added[[kk]]
[17:39:40.915]                   NAME <- NAMES[[kk]]
[17:39:40.915]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.915]                     next
[17:39:40.915]                   args[[name]] <- ""
[17:39:40.915]                 }
[17:39:40.915]                 NAMES <- toupper(removed)
[17:39:40.915]                 for (kk in seq_along(NAMES)) {
[17:39:40.915]                   name <- removed[[kk]]
[17:39:40.915]                   NAME <- NAMES[[kk]]
[17:39:40.915]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.915]                     next
[17:39:40.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.915]                 }
[17:39:40.915]                 if (length(args) > 0) 
[17:39:40.915]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.915]             }
[17:39:40.915]             else {
[17:39:40.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.915]             }
[17:39:40.915]             {
[17:39:40.915]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.915]                   0L) {
[17:39:40.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.915]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.915]                   base::options(opts)
[17:39:40.915]                 }
[17:39:40.915]                 {
[17:39:40.915]                   {
[17:39:40.915]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.915]                     NULL
[17:39:40.915]                   }
[17:39:40.915]                   options(future.plan = NULL)
[17:39:40.915]                   if (is.na(NA_character_)) 
[17:39:40.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.915]                     .init = FALSE)
[17:39:40.915]                 }
[17:39:40.915]             }
[17:39:40.915]         }
[17:39:40.915]     })
[17:39:40.915]     if (TRUE) {
[17:39:40.915]         base::sink(type = "output", split = FALSE)
[17:39:40.915]         if (TRUE) {
[17:39:40.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.915]         }
[17:39:40.915]         else {
[17:39:40.915]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.915]         }
[17:39:40.915]         base::close(...future.stdout)
[17:39:40.915]         ...future.stdout <- NULL
[17:39:40.915]     }
[17:39:40.915]     ...future.result$conditions <- ...future.conditions
[17:39:40.915]     ...future.result$finished <- base::Sys.time()
[17:39:40.915]     ...future.result
[17:39:40.915] }
[17:39:40.917] assign_globals() ...
[17:39:40.917] List of 1
[17:39:40.917]  $ x: num [1:5] 1 1 2 2 2
[17:39:40.917]  - attr(*, "where")=List of 1
[17:39:40.917]   ..$ x:<environment: R_EmptyEnv> 
[17:39:40.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.917]  - attr(*, "resolved")= logi FALSE
[17:39:40.917]  - attr(*, "total_size")= num 96
[17:39:40.917]  - attr(*, "already-done")= logi TRUE
[17:39:40.920] - copied ‘x’ to environment
[17:39:40.920] assign_globals() ... done
[17:39:40.921] requestCore(): workers = 2
[17:39:40.922] MulticoreFuture started
[17:39:40.923] - Launch lazy future ... done
[17:39:40.923] run() for ‘MulticoreFuture’ ... done
[17:39:40.923] result() for MulticoreFuture ...
[17:39:40.924] plan(): Setting new future strategy stack:
[17:39:40.924] List of future strategies:
[17:39:40.924] 1. sequential:
[17:39:40.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.924]    - tweaked: FALSE
[17:39:40.924]    - call: NULL
[17:39:40.925] plan(): nbrOfWorkers() = 1
[17:39:40.928] plan(): Setting new future strategy stack:
[17:39:40.928] List of future strategies:
[17:39:40.928] 1. multicore:
[17:39:40.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.928]    - tweaked: FALSE
[17:39:40.928]    - call: plan(strategy)
[17:39:40.937] plan(): nbrOfWorkers() = 2
[17:39:40.938] result() for MulticoreFuture ...
[17:39:40.938] result() for MulticoreFuture ... done
[17:39:40.938] result() for MulticoreFuture ... done
[17:39:40.938] result() for MulticoreFuture ...
[17:39:40.939] result() for MulticoreFuture ... done
x
1 2 
2 3 
[17:39:40.940] getGlobalsAndPackages() ...
[17:39:40.940] Searching for globals...
[17:39:40.944] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:39:40.944] Searching for globals ... DONE
[17:39:40.944] Resolving globals: FALSE
[17:39:40.945] The total size of the 1 globals is 96 bytes (96 bytes)
[17:39:40.945] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:39:40.946] - globals: [1] ‘x’
[17:39:40.946] - packages: [1] ‘stats’
[17:39:40.946] getGlobalsAndPackages() ... DONE
[17:39:40.946] run() for ‘Future’ ...
[17:39:40.946] - state: ‘created’
[17:39:40.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.951] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.951]   - Field: ‘label’
[17:39:40.951]   - Field: ‘local’
[17:39:40.951]   - Field: ‘owner’
[17:39:40.951]   - Field: ‘envir’
[17:39:40.952]   - Field: ‘workers’
[17:39:40.952]   - Field: ‘packages’
[17:39:40.952]   - Field: ‘gc’
[17:39:40.952]   - Field: ‘job’
[17:39:40.952]   - Field: ‘conditions’
[17:39:40.952]   - Field: ‘expr’
[17:39:40.952]   - Field: ‘uuid’
[17:39:40.952]   - Field: ‘seed’
[17:39:40.952]   - Field: ‘version’
[17:39:40.953]   - Field: ‘result’
[17:39:40.953]   - Field: ‘asynchronous’
[17:39:40.953]   - Field: ‘calls’
[17:39:40.953]   - Field: ‘globals’
[17:39:40.953]   - Field: ‘stdout’
[17:39:40.953]   - Field: ‘earlySignal’
[17:39:40.953]   - Field: ‘lazy’
[17:39:40.953]   - Field: ‘state’
[17:39:40.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.954] - Launch lazy future ...
[17:39:40.954] Packages needed by the future expression (n = 1): ‘stats’
[17:39:40.954] Packages needed by future strategies (n = 0): <none>
[17:39:40.955] {
[17:39:40.955]     {
[17:39:40.955]         {
[17:39:40.955]             ...future.startTime <- base::Sys.time()
[17:39:40.955]             {
[17:39:40.955]                 {
[17:39:40.955]                   {
[17:39:40.955]                     {
[17:39:40.955]                       {
[17:39:40.955]                         base::local({
[17:39:40.955]                           has_future <- base::requireNamespace("future", 
[17:39:40.955]                             quietly = TRUE)
[17:39:40.955]                           if (has_future) {
[17:39:40.955]                             ns <- base::getNamespace("future")
[17:39:40.955]                             version <- ns[[".package"]][["version"]]
[17:39:40.955]                             if (is.null(version)) 
[17:39:40.955]                               version <- utils::packageVersion("future")
[17:39:40.955]                           }
[17:39:40.955]                           else {
[17:39:40.955]                             version <- NULL
[17:39:40.955]                           }
[17:39:40.955]                           if (!has_future || version < "1.8.0") {
[17:39:40.955]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.955]                               "", base::R.version$version.string), 
[17:39:40.955]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.955]                                 base::R.version$platform, 8 * 
[17:39:40.955]                                   base::.Machine$sizeof.pointer), 
[17:39:40.955]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.955]                                 "release", "version")], collapse = " "), 
[17:39:40.955]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.955]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.955]                               info)
[17:39:40.955]                             info <- base::paste(info, collapse = "; ")
[17:39:40.955]                             if (!has_future) {
[17:39:40.955]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.955]                                 info)
[17:39:40.955]                             }
[17:39:40.955]                             else {
[17:39:40.955]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.955]                                 info, version)
[17:39:40.955]                             }
[17:39:40.955]                             base::stop(msg)
[17:39:40.955]                           }
[17:39:40.955]                         })
[17:39:40.955]                       }
[17:39:40.955]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.955]                       base::options(mc.cores = 1L)
[17:39:40.955]                     }
[17:39:40.955]                     base::local({
[17:39:40.955]                       for (pkg in "stats") {
[17:39:40.955]                         base::loadNamespace(pkg)
[17:39:40.955]                         base::library(pkg, character.only = TRUE)
[17:39:40.955]                       }
[17:39:40.955]                     })
[17:39:40.955]                   }
[17:39:40.955]                   ...future.strategy.old <- future::plan("list")
[17:39:40.955]                   options(future.plan = NULL)
[17:39:40.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.955]                 }
[17:39:40.955]                 ...future.workdir <- getwd()
[17:39:40.955]             }
[17:39:40.955]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.955]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.955]         }
[17:39:40.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.955]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.955]             base::names(...future.oldOptions))
[17:39:40.955]     }
[17:39:40.955]     if (FALSE) {
[17:39:40.955]     }
[17:39:40.955]     else {
[17:39:40.955]         if (TRUE) {
[17:39:40.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.955]                 open = "w")
[17:39:40.955]         }
[17:39:40.955]         else {
[17:39:40.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.955]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.955]         }
[17:39:40.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.955]             base::sink(type = "output", split = FALSE)
[17:39:40.955]             base::close(...future.stdout)
[17:39:40.955]         }, add = TRUE)
[17:39:40.955]     }
[17:39:40.955]     ...future.frame <- base::sys.nframe()
[17:39:40.955]     ...future.conditions <- base::list()
[17:39:40.955]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.955]     if (FALSE) {
[17:39:40.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.955]     }
[17:39:40.955]     ...future.result <- base::tryCatch({
[17:39:40.955]         base::withCallingHandlers({
[17:39:40.955]             ...future.value <- base::withVisible(base::local({
[17:39:40.955]                 withCallingHandlers({
[17:39:40.955]                   {
[17:39:40.955]                     xtabs(~x)
[17:39:40.955]                   }
[17:39:40.955]                 }, immediateCondition = function(cond) {
[17:39:40.955]                   save_rds <- function (object, pathname, ...) 
[17:39:40.955]                   {
[17:39:40.955]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.955]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.955]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.955]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.955]                         fi_tmp[["mtime"]])
[17:39:40.955]                     }
[17:39:40.955]                     tryCatch({
[17:39:40.955]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.955]                     }, error = function(ex) {
[17:39:40.955]                       msg <- conditionMessage(ex)
[17:39:40.955]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.955]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.955]                         fi_tmp[["mtime"]], msg)
[17:39:40.955]                       ex$message <- msg
[17:39:40.955]                       stop(ex)
[17:39:40.955]                     })
[17:39:40.955]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.955]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.955]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.955]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.955]                       fi <- file.info(pathname)
[17:39:40.955]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.955]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.955]                         fi[["size"]], fi[["mtime"]])
[17:39:40.955]                       stop(msg)
[17:39:40.955]                     }
[17:39:40.955]                     invisible(pathname)
[17:39:40.955]                   }
[17:39:40.955]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.955]                     rootPath = tempdir()) 
[17:39:40.955]                   {
[17:39:40.955]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.955]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.955]                       tmpdir = path, fileext = ".rds")
[17:39:40.955]                     save_rds(obj, file)
[17:39:40.955]                   }
[17:39:40.955]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.955]                   {
[17:39:40.955]                     inherits <- base::inherits
[17:39:40.955]                     invokeRestart <- base::invokeRestart
[17:39:40.955]                     is.null <- base::is.null
[17:39:40.955]                     muffled <- FALSE
[17:39:40.955]                     if (inherits(cond, "message")) {
[17:39:40.955]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.955]                       if (muffled) 
[17:39:40.955]                         invokeRestart("muffleMessage")
[17:39:40.955]                     }
[17:39:40.955]                     else if (inherits(cond, "warning")) {
[17:39:40.955]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.955]                       if (muffled) 
[17:39:40.955]                         invokeRestart("muffleWarning")
[17:39:40.955]                     }
[17:39:40.955]                     else if (inherits(cond, "condition")) {
[17:39:40.955]                       if (!is.null(pattern)) {
[17:39:40.955]                         computeRestarts <- base::computeRestarts
[17:39:40.955]                         grepl <- base::grepl
[17:39:40.955]                         restarts <- computeRestarts(cond)
[17:39:40.955]                         for (restart in restarts) {
[17:39:40.955]                           name <- restart$name
[17:39:40.955]                           if (is.null(name)) 
[17:39:40.955]                             next
[17:39:40.955]                           if (!grepl(pattern, name)) 
[17:39:40.955]                             next
[17:39:40.955]                           invokeRestart(restart)
[17:39:40.955]                           muffled <- TRUE
[17:39:40.955]                           break
[17:39:40.955]                         }
[17:39:40.955]                       }
[17:39:40.955]                     }
[17:39:40.955]                     invisible(muffled)
[17:39:40.955]                   }
[17:39:40.955]                   muffleCondition(cond)
[17:39:40.955]                 })
[17:39:40.955]             }))
[17:39:40.955]             future::FutureResult(value = ...future.value$value, 
[17:39:40.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.955]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.955]                     ...future.globalenv.names))
[17:39:40.955]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.955]         }, condition = base::local({
[17:39:40.955]             c <- base::c
[17:39:40.955]             inherits <- base::inherits
[17:39:40.955]             invokeRestart <- base::invokeRestart
[17:39:40.955]             length <- base::length
[17:39:40.955]             list <- base::list
[17:39:40.955]             seq.int <- base::seq.int
[17:39:40.955]             signalCondition <- base::signalCondition
[17:39:40.955]             sys.calls <- base::sys.calls
[17:39:40.955]             `[[` <- base::`[[`
[17:39:40.955]             `+` <- base::`+`
[17:39:40.955]             `<<-` <- base::`<<-`
[17:39:40.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.955]                   3L)]
[17:39:40.955]             }
[17:39:40.955]             function(cond) {
[17:39:40.955]                 is_error <- inherits(cond, "error")
[17:39:40.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.955]                   NULL)
[17:39:40.955]                 if (is_error) {
[17:39:40.955]                   sessionInformation <- function() {
[17:39:40.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.955]                       search = base::search(), system = base::Sys.info())
[17:39:40.955]                   }
[17:39:40.955]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.955]                     cond$call), session = sessionInformation(), 
[17:39:40.955]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.955]                   signalCondition(cond)
[17:39:40.955]                 }
[17:39:40.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.955]                 "immediateCondition"))) {
[17:39:40.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.955]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.955]                   if (TRUE && !signal) {
[17:39:40.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.955]                     {
[17:39:40.955]                       inherits <- base::inherits
[17:39:40.955]                       invokeRestart <- base::invokeRestart
[17:39:40.955]                       is.null <- base::is.null
[17:39:40.955]                       muffled <- FALSE
[17:39:40.955]                       if (inherits(cond, "message")) {
[17:39:40.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.955]                         if (muffled) 
[17:39:40.955]                           invokeRestart("muffleMessage")
[17:39:40.955]                       }
[17:39:40.955]                       else if (inherits(cond, "warning")) {
[17:39:40.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.955]                         if (muffled) 
[17:39:40.955]                           invokeRestart("muffleWarning")
[17:39:40.955]                       }
[17:39:40.955]                       else if (inherits(cond, "condition")) {
[17:39:40.955]                         if (!is.null(pattern)) {
[17:39:40.955]                           computeRestarts <- base::computeRestarts
[17:39:40.955]                           grepl <- base::grepl
[17:39:40.955]                           restarts <- computeRestarts(cond)
[17:39:40.955]                           for (restart in restarts) {
[17:39:40.955]                             name <- restart$name
[17:39:40.955]                             if (is.null(name)) 
[17:39:40.955]                               next
[17:39:40.955]                             if (!grepl(pattern, name)) 
[17:39:40.955]                               next
[17:39:40.955]                             invokeRestart(restart)
[17:39:40.955]                             muffled <- TRUE
[17:39:40.955]                             break
[17:39:40.955]                           }
[17:39:40.955]                         }
[17:39:40.955]                       }
[17:39:40.955]                       invisible(muffled)
[17:39:40.955]                     }
[17:39:40.955]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.955]                   }
[17:39:40.955]                 }
[17:39:40.955]                 else {
[17:39:40.955]                   if (TRUE) {
[17:39:40.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.955]                     {
[17:39:40.955]                       inherits <- base::inherits
[17:39:40.955]                       invokeRestart <- base::invokeRestart
[17:39:40.955]                       is.null <- base::is.null
[17:39:40.955]                       muffled <- FALSE
[17:39:40.955]                       if (inherits(cond, "message")) {
[17:39:40.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.955]                         if (muffled) 
[17:39:40.955]                           invokeRestart("muffleMessage")
[17:39:40.955]                       }
[17:39:40.955]                       else if (inherits(cond, "warning")) {
[17:39:40.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.955]                         if (muffled) 
[17:39:40.955]                           invokeRestart("muffleWarning")
[17:39:40.955]                       }
[17:39:40.955]                       else if (inherits(cond, "condition")) {
[17:39:40.955]                         if (!is.null(pattern)) {
[17:39:40.955]                           computeRestarts <- base::computeRestarts
[17:39:40.955]                           grepl <- base::grepl
[17:39:40.955]                           restarts <- computeRestarts(cond)
[17:39:40.955]                           for (restart in restarts) {
[17:39:40.955]                             name <- restart$name
[17:39:40.955]                             if (is.null(name)) 
[17:39:40.955]                               next
[17:39:40.955]                             if (!grepl(pattern, name)) 
[17:39:40.955]                               next
[17:39:40.955]                             invokeRestart(restart)
[17:39:40.955]                             muffled <- TRUE
[17:39:40.955]                             break
[17:39:40.955]                           }
[17:39:40.955]                         }
[17:39:40.955]                       }
[17:39:40.955]                       invisible(muffled)
[17:39:40.955]                     }
[17:39:40.955]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.955]                   }
[17:39:40.955]                 }
[17:39:40.955]             }
[17:39:40.955]         }))
[17:39:40.955]     }, error = function(ex) {
[17:39:40.955]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.955]                 ...future.rng), started = ...future.startTime, 
[17:39:40.955]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.955]             version = "1.8"), class = "FutureResult")
[17:39:40.955]     }, finally = {
[17:39:40.955]         if (!identical(...future.workdir, getwd())) 
[17:39:40.955]             setwd(...future.workdir)
[17:39:40.955]         {
[17:39:40.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.955]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.955]             }
[17:39:40.955]             base::options(...future.oldOptions)
[17:39:40.955]             if (.Platform$OS.type == "windows") {
[17:39:40.955]                 old_names <- names(...future.oldEnvVars)
[17:39:40.955]                 envs <- base::Sys.getenv()
[17:39:40.955]                 names <- names(envs)
[17:39:40.955]                 common <- intersect(names, old_names)
[17:39:40.955]                 added <- setdiff(names, old_names)
[17:39:40.955]                 removed <- setdiff(old_names, names)
[17:39:40.955]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.955]                   envs[common]]
[17:39:40.955]                 NAMES <- toupper(changed)
[17:39:40.955]                 args <- list()
[17:39:40.955]                 for (kk in seq_along(NAMES)) {
[17:39:40.955]                   name <- changed[[kk]]
[17:39:40.955]                   NAME <- NAMES[[kk]]
[17:39:40.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.955]                     next
[17:39:40.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.955]                 }
[17:39:40.955]                 NAMES <- toupper(added)
[17:39:40.955]                 for (kk in seq_along(NAMES)) {
[17:39:40.955]                   name <- added[[kk]]
[17:39:40.955]                   NAME <- NAMES[[kk]]
[17:39:40.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.955]                     next
[17:39:40.955]                   args[[name]] <- ""
[17:39:40.955]                 }
[17:39:40.955]                 NAMES <- toupper(removed)
[17:39:40.955]                 for (kk in seq_along(NAMES)) {
[17:39:40.955]                   name <- removed[[kk]]
[17:39:40.955]                   NAME <- NAMES[[kk]]
[17:39:40.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.955]                     next
[17:39:40.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.955]                 }
[17:39:40.955]                 if (length(args) > 0) 
[17:39:40.955]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.955]             }
[17:39:40.955]             else {
[17:39:40.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.955]             }
[17:39:40.955]             {
[17:39:40.955]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.955]                   0L) {
[17:39:40.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.955]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.955]                   base::options(opts)
[17:39:40.955]                 }
[17:39:40.955]                 {
[17:39:40.955]                   {
[17:39:40.955]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.955]                     NULL
[17:39:40.955]                   }
[17:39:40.955]                   options(future.plan = NULL)
[17:39:40.955]                   if (is.na(NA_character_)) 
[17:39:40.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.955]                     .init = FALSE)
[17:39:40.955]                 }
[17:39:40.955]             }
[17:39:40.955]         }
[17:39:40.955]     })
[17:39:40.955]     if (TRUE) {
[17:39:40.955]         base::sink(type = "output", split = FALSE)
[17:39:40.955]         if (TRUE) {
[17:39:40.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.955]         }
[17:39:40.955]         else {
[17:39:40.955]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.955]         }
[17:39:40.955]         base::close(...future.stdout)
[17:39:40.955]         ...future.stdout <- NULL
[17:39:40.955]     }
[17:39:40.955]     ...future.result$conditions <- ...future.conditions
[17:39:40.955]     ...future.result$finished <- base::Sys.time()
[17:39:40.955]     ...future.result
[17:39:40.955] }
[17:39:40.957] assign_globals() ...
[17:39:40.957] List of 1
[17:39:40.957]  $ x: num [1:5] 1 1 2 2 2
[17:39:40.957]  - attr(*, "where")=List of 1
[17:39:40.957]   ..$ x:<environment: R_EmptyEnv> 
[17:39:40.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:40.957]  - attr(*, "resolved")= logi FALSE
[17:39:40.957]  - attr(*, "total_size")= num 96
[17:39:40.957]  - attr(*, "already-done")= logi TRUE
[17:39:40.960] - copied ‘x’ to environment
[17:39:40.960] assign_globals() ... done
[17:39:40.960] requestCore(): workers = 2
[17:39:40.962] MulticoreFuture started
[17:39:40.963] - Launch lazy future ... done
[17:39:40.963] run() for ‘MulticoreFuture’ ... done
[17:39:40.963] result() for MulticoreFuture ...
[17:39:40.964] plan(): Setting new future strategy stack:
[17:39:40.964] List of future strategies:
[17:39:40.964] 1. sequential:
[17:39:40.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.964]    - tweaked: FALSE
[17:39:40.964]    - call: NULL
[17:39:40.965] plan(): nbrOfWorkers() = 1
[17:39:40.968] plan(): Setting new future strategy stack:
[17:39:40.968] List of future strategies:
[17:39:40.968] 1. multicore:
[17:39:40.968]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:40.968]    - tweaked: FALSE
[17:39:40.968]    - call: plan(strategy)
[17:39:40.973] plan(): nbrOfWorkers() = 2
[17:39:40.974] result() for MulticoreFuture ...
[17:39:40.974] result() for MulticoreFuture ... done
[17:39:40.974] result() for MulticoreFuture ... done
[17:39:40.974] result() for MulticoreFuture ...
[17:39:40.974] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:39:40.977] getGlobalsAndPackages() ...
[17:39:40.977] Searching for globals...
[17:39:40.979] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:39:40.979] Searching for globals ... DONE
[17:39:40.979] Resolving globals: FALSE
[17:39:40.980] 
[17:39:40.980] - packages: [2] ‘stats’, ‘datasets’
[17:39:40.980] getGlobalsAndPackages() ... DONE
[17:39:40.980] run() for ‘Future’ ...
[17:39:40.981] - state: ‘created’
[17:39:40.981] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:40.985] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:40.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:40.985]   - Field: ‘label’
[17:39:40.985]   - Field: ‘local’
[17:39:40.985]   - Field: ‘owner’
[17:39:40.985]   - Field: ‘envir’
[17:39:40.986]   - Field: ‘workers’
[17:39:40.986]   - Field: ‘packages’
[17:39:40.986]   - Field: ‘gc’
[17:39:40.986]   - Field: ‘job’
[17:39:40.986]   - Field: ‘conditions’
[17:39:40.986]   - Field: ‘expr’
[17:39:40.986]   - Field: ‘uuid’
[17:39:40.986]   - Field: ‘seed’
[17:39:40.986]   - Field: ‘version’
[17:39:40.987]   - Field: ‘result’
[17:39:40.987]   - Field: ‘asynchronous’
[17:39:40.987]   - Field: ‘calls’
[17:39:40.987]   - Field: ‘globals’
[17:39:40.987]   - Field: ‘stdout’
[17:39:40.987]   - Field: ‘earlySignal’
[17:39:40.987]   - Field: ‘lazy’
[17:39:40.987]   - Field: ‘state’
[17:39:40.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:40.988] - Launch lazy future ...
[17:39:40.988] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:40.988] Packages needed by future strategies (n = 0): <none>
[17:39:40.991] {
[17:39:40.991]     {
[17:39:40.991]         {
[17:39:40.991]             ...future.startTime <- base::Sys.time()
[17:39:40.991]             {
[17:39:40.991]                 {
[17:39:40.991]                   {
[17:39:40.991]                     {
[17:39:40.991]                       {
[17:39:40.991]                         base::local({
[17:39:40.991]                           has_future <- base::requireNamespace("future", 
[17:39:40.991]                             quietly = TRUE)
[17:39:40.991]                           if (has_future) {
[17:39:40.991]                             ns <- base::getNamespace("future")
[17:39:40.991]                             version <- ns[[".package"]][["version"]]
[17:39:40.991]                             if (is.null(version)) 
[17:39:40.991]                               version <- utils::packageVersion("future")
[17:39:40.991]                           }
[17:39:40.991]                           else {
[17:39:40.991]                             version <- NULL
[17:39:40.991]                           }
[17:39:40.991]                           if (!has_future || version < "1.8.0") {
[17:39:40.991]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:40.991]                               "", base::R.version$version.string), 
[17:39:40.991]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:40.991]                                 base::R.version$platform, 8 * 
[17:39:40.991]                                   base::.Machine$sizeof.pointer), 
[17:39:40.991]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:40.991]                                 "release", "version")], collapse = " "), 
[17:39:40.991]                               hostname = base::Sys.info()[["nodename"]])
[17:39:40.991]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:40.991]                               info)
[17:39:40.991]                             info <- base::paste(info, collapse = "; ")
[17:39:40.991]                             if (!has_future) {
[17:39:40.991]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:40.991]                                 info)
[17:39:40.991]                             }
[17:39:40.991]                             else {
[17:39:40.991]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:40.991]                                 info, version)
[17:39:40.991]                             }
[17:39:40.991]                             base::stop(msg)
[17:39:40.991]                           }
[17:39:40.991]                         })
[17:39:40.991]                       }
[17:39:40.991]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:40.991]                       base::options(mc.cores = 1L)
[17:39:40.991]                     }
[17:39:40.991]                     base::local({
[17:39:40.991]                       for (pkg in c("stats", "datasets")) {
[17:39:40.991]                         base::loadNamespace(pkg)
[17:39:40.991]                         base::library(pkg, character.only = TRUE)
[17:39:40.991]                       }
[17:39:40.991]                     })
[17:39:40.991]                   }
[17:39:40.991]                   ...future.strategy.old <- future::plan("list")
[17:39:40.991]                   options(future.plan = NULL)
[17:39:40.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:40.991]                 }
[17:39:40.991]                 ...future.workdir <- getwd()
[17:39:40.991]             }
[17:39:40.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:40.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:40.991]         }
[17:39:40.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:40.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:40.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:40.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:40.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:40.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:40.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:40.991]             base::names(...future.oldOptions))
[17:39:40.991]     }
[17:39:40.991]     if (FALSE) {
[17:39:40.991]     }
[17:39:40.991]     else {
[17:39:40.991]         if (TRUE) {
[17:39:40.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:40.991]                 open = "w")
[17:39:40.991]         }
[17:39:40.991]         else {
[17:39:40.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:40.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:40.991]         }
[17:39:40.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:40.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:40.991]             base::sink(type = "output", split = FALSE)
[17:39:40.991]             base::close(...future.stdout)
[17:39:40.991]         }, add = TRUE)
[17:39:40.991]     }
[17:39:40.991]     ...future.frame <- base::sys.nframe()
[17:39:40.991]     ...future.conditions <- base::list()
[17:39:40.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:40.991]     if (FALSE) {
[17:39:40.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:40.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:40.991]     }
[17:39:40.991]     ...future.result <- base::tryCatch({
[17:39:40.991]         base::withCallingHandlers({
[17:39:40.991]             ...future.value <- base::withVisible(base::local({
[17:39:40.991]                 withCallingHandlers({
[17:39:40.991]                   {
[17:39:40.991]                     lm(dist ~ . - 1, data = cars)
[17:39:40.991]                   }
[17:39:40.991]                 }, immediateCondition = function(cond) {
[17:39:40.991]                   save_rds <- function (object, pathname, ...) 
[17:39:40.991]                   {
[17:39:40.991]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:40.991]                     if (file_test("-f", pathname_tmp)) {
[17:39:40.991]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.991]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:40.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.991]                         fi_tmp[["mtime"]])
[17:39:40.991]                     }
[17:39:40.991]                     tryCatch({
[17:39:40.991]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:40.991]                     }, error = function(ex) {
[17:39:40.991]                       msg <- conditionMessage(ex)
[17:39:40.991]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.991]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:40.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.991]                         fi_tmp[["mtime"]], msg)
[17:39:40.991]                       ex$message <- msg
[17:39:40.991]                       stop(ex)
[17:39:40.991]                     })
[17:39:40.991]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:40.991]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:40.991]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:40.991]                       fi_tmp <- file.info(pathname_tmp)
[17:39:40.991]                       fi <- file.info(pathname)
[17:39:40.991]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:40.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:40.991]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:40.991]                         fi[["size"]], fi[["mtime"]])
[17:39:40.991]                       stop(msg)
[17:39:40.991]                     }
[17:39:40.991]                     invisible(pathname)
[17:39:40.991]                   }
[17:39:40.991]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:40.991]                     rootPath = tempdir()) 
[17:39:40.991]                   {
[17:39:40.991]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:40.991]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:40.991]                       tmpdir = path, fileext = ".rds")
[17:39:40.991]                     save_rds(obj, file)
[17:39:40.991]                   }
[17:39:40.991]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:40.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.991]                   {
[17:39:40.991]                     inherits <- base::inherits
[17:39:40.991]                     invokeRestart <- base::invokeRestart
[17:39:40.991]                     is.null <- base::is.null
[17:39:40.991]                     muffled <- FALSE
[17:39:40.991]                     if (inherits(cond, "message")) {
[17:39:40.991]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:40.991]                       if (muffled) 
[17:39:40.991]                         invokeRestart("muffleMessage")
[17:39:40.991]                     }
[17:39:40.991]                     else if (inherits(cond, "warning")) {
[17:39:40.991]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:40.991]                       if (muffled) 
[17:39:40.991]                         invokeRestart("muffleWarning")
[17:39:40.991]                     }
[17:39:40.991]                     else if (inherits(cond, "condition")) {
[17:39:40.991]                       if (!is.null(pattern)) {
[17:39:40.991]                         computeRestarts <- base::computeRestarts
[17:39:40.991]                         grepl <- base::grepl
[17:39:40.991]                         restarts <- computeRestarts(cond)
[17:39:40.991]                         for (restart in restarts) {
[17:39:40.991]                           name <- restart$name
[17:39:40.991]                           if (is.null(name)) 
[17:39:40.991]                             next
[17:39:40.991]                           if (!grepl(pattern, name)) 
[17:39:40.991]                             next
[17:39:40.991]                           invokeRestart(restart)
[17:39:40.991]                           muffled <- TRUE
[17:39:40.991]                           break
[17:39:40.991]                         }
[17:39:40.991]                       }
[17:39:40.991]                     }
[17:39:40.991]                     invisible(muffled)
[17:39:40.991]                   }
[17:39:40.991]                   muffleCondition(cond)
[17:39:40.991]                 })
[17:39:40.991]             }))
[17:39:40.991]             future::FutureResult(value = ...future.value$value, 
[17:39:40.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.991]                   ...future.rng), globalenv = if (FALSE) 
[17:39:40.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:40.991]                     ...future.globalenv.names))
[17:39:40.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:40.991]         }, condition = base::local({
[17:39:40.991]             c <- base::c
[17:39:40.991]             inherits <- base::inherits
[17:39:40.991]             invokeRestart <- base::invokeRestart
[17:39:40.991]             length <- base::length
[17:39:40.991]             list <- base::list
[17:39:40.991]             seq.int <- base::seq.int
[17:39:40.991]             signalCondition <- base::signalCondition
[17:39:40.991]             sys.calls <- base::sys.calls
[17:39:40.991]             `[[` <- base::`[[`
[17:39:40.991]             `+` <- base::`+`
[17:39:40.991]             `<<-` <- base::`<<-`
[17:39:40.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:40.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:40.991]                   3L)]
[17:39:40.991]             }
[17:39:40.991]             function(cond) {
[17:39:40.991]                 is_error <- inherits(cond, "error")
[17:39:40.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:40.991]                   NULL)
[17:39:40.991]                 if (is_error) {
[17:39:40.991]                   sessionInformation <- function() {
[17:39:40.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:40.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:40.991]                       search = base::search(), system = base::Sys.info())
[17:39:40.991]                   }
[17:39:40.991]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:40.991]                     cond$call), session = sessionInformation(), 
[17:39:40.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:40.991]                   signalCondition(cond)
[17:39:40.991]                 }
[17:39:40.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:40.991]                 "immediateCondition"))) {
[17:39:40.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:40.991]                   ...future.conditions[[length(...future.conditions) + 
[17:39:40.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:40.991]                   if (TRUE && !signal) {
[17:39:40.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.991]                     {
[17:39:40.991]                       inherits <- base::inherits
[17:39:40.991]                       invokeRestart <- base::invokeRestart
[17:39:40.991]                       is.null <- base::is.null
[17:39:40.991]                       muffled <- FALSE
[17:39:40.991]                       if (inherits(cond, "message")) {
[17:39:40.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.991]                         if (muffled) 
[17:39:40.991]                           invokeRestart("muffleMessage")
[17:39:40.991]                       }
[17:39:40.991]                       else if (inherits(cond, "warning")) {
[17:39:40.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.991]                         if (muffled) 
[17:39:40.991]                           invokeRestart("muffleWarning")
[17:39:40.991]                       }
[17:39:40.991]                       else if (inherits(cond, "condition")) {
[17:39:40.991]                         if (!is.null(pattern)) {
[17:39:40.991]                           computeRestarts <- base::computeRestarts
[17:39:40.991]                           grepl <- base::grepl
[17:39:40.991]                           restarts <- computeRestarts(cond)
[17:39:40.991]                           for (restart in restarts) {
[17:39:40.991]                             name <- restart$name
[17:39:40.991]                             if (is.null(name)) 
[17:39:40.991]                               next
[17:39:40.991]                             if (!grepl(pattern, name)) 
[17:39:40.991]                               next
[17:39:40.991]                             invokeRestart(restart)
[17:39:40.991]                             muffled <- TRUE
[17:39:40.991]                             break
[17:39:40.991]                           }
[17:39:40.991]                         }
[17:39:40.991]                       }
[17:39:40.991]                       invisible(muffled)
[17:39:40.991]                     }
[17:39:40.991]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.991]                   }
[17:39:40.991]                 }
[17:39:40.991]                 else {
[17:39:40.991]                   if (TRUE) {
[17:39:40.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:40.991]                     {
[17:39:40.991]                       inherits <- base::inherits
[17:39:40.991]                       invokeRestart <- base::invokeRestart
[17:39:40.991]                       is.null <- base::is.null
[17:39:40.991]                       muffled <- FALSE
[17:39:40.991]                       if (inherits(cond, "message")) {
[17:39:40.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:40.991]                         if (muffled) 
[17:39:40.991]                           invokeRestart("muffleMessage")
[17:39:40.991]                       }
[17:39:40.991]                       else if (inherits(cond, "warning")) {
[17:39:40.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:40.991]                         if (muffled) 
[17:39:40.991]                           invokeRestart("muffleWarning")
[17:39:40.991]                       }
[17:39:40.991]                       else if (inherits(cond, "condition")) {
[17:39:40.991]                         if (!is.null(pattern)) {
[17:39:40.991]                           computeRestarts <- base::computeRestarts
[17:39:40.991]                           grepl <- base::grepl
[17:39:40.991]                           restarts <- computeRestarts(cond)
[17:39:40.991]                           for (restart in restarts) {
[17:39:40.991]                             name <- restart$name
[17:39:40.991]                             if (is.null(name)) 
[17:39:40.991]                               next
[17:39:40.991]                             if (!grepl(pattern, name)) 
[17:39:40.991]                               next
[17:39:40.991]                             invokeRestart(restart)
[17:39:40.991]                             muffled <- TRUE
[17:39:40.991]                             break
[17:39:40.991]                           }
[17:39:40.991]                         }
[17:39:40.991]                       }
[17:39:40.991]                       invisible(muffled)
[17:39:40.991]                     }
[17:39:40.991]                     muffleCondition(cond, pattern = "^muffle")
[17:39:40.991]                   }
[17:39:40.991]                 }
[17:39:40.991]             }
[17:39:40.991]         }))
[17:39:40.991]     }, error = function(ex) {
[17:39:40.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:40.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:40.991]                 ...future.rng), started = ...future.startTime, 
[17:39:40.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:40.991]             version = "1.8"), class = "FutureResult")
[17:39:40.991]     }, finally = {
[17:39:40.991]         if (!identical(...future.workdir, getwd())) 
[17:39:40.991]             setwd(...future.workdir)
[17:39:40.991]         {
[17:39:40.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:40.991]                 ...future.oldOptions$nwarnings <- NULL
[17:39:40.991]             }
[17:39:40.991]             base::options(...future.oldOptions)
[17:39:40.991]             if (.Platform$OS.type == "windows") {
[17:39:40.991]                 old_names <- names(...future.oldEnvVars)
[17:39:40.991]                 envs <- base::Sys.getenv()
[17:39:40.991]                 names <- names(envs)
[17:39:40.991]                 common <- intersect(names, old_names)
[17:39:40.991]                 added <- setdiff(names, old_names)
[17:39:40.991]                 removed <- setdiff(old_names, names)
[17:39:40.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:40.991]                   envs[common]]
[17:39:40.991]                 NAMES <- toupper(changed)
[17:39:40.991]                 args <- list()
[17:39:40.991]                 for (kk in seq_along(NAMES)) {
[17:39:40.991]                   name <- changed[[kk]]
[17:39:40.991]                   NAME <- NAMES[[kk]]
[17:39:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.991]                     next
[17:39:40.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.991]                 }
[17:39:40.991]                 NAMES <- toupper(added)
[17:39:40.991]                 for (kk in seq_along(NAMES)) {
[17:39:40.991]                   name <- added[[kk]]
[17:39:40.991]                   NAME <- NAMES[[kk]]
[17:39:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.991]                     next
[17:39:40.991]                   args[[name]] <- ""
[17:39:40.991]                 }
[17:39:40.991]                 NAMES <- toupper(removed)
[17:39:40.991]                 for (kk in seq_along(NAMES)) {
[17:39:40.991]                   name <- removed[[kk]]
[17:39:40.991]                   NAME <- NAMES[[kk]]
[17:39:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:40.991]                     next
[17:39:40.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:40.991]                 }
[17:39:40.991]                 if (length(args) > 0) 
[17:39:40.991]                   base::do.call(base::Sys.setenv, args = args)
[17:39:40.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:40.991]             }
[17:39:40.991]             else {
[17:39:40.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:40.991]             }
[17:39:40.991]             {
[17:39:40.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:40.991]                   0L) {
[17:39:40.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:40.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:40.991]                   base::options(opts)
[17:39:40.991]                 }
[17:39:40.991]                 {
[17:39:40.991]                   {
[17:39:40.991]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:40.991]                     NULL
[17:39:40.991]                   }
[17:39:40.991]                   options(future.plan = NULL)
[17:39:40.991]                   if (is.na(NA_character_)) 
[17:39:40.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:40.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:40.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:40.991]                     .init = FALSE)
[17:39:40.991]                 }
[17:39:40.991]             }
[17:39:40.991]         }
[17:39:40.991]     })
[17:39:40.991]     if (TRUE) {
[17:39:40.991]         base::sink(type = "output", split = FALSE)
[17:39:40.991]         if (TRUE) {
[17:39:40.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:40.991]         }
[17:39:40.991]         else {
[17:39:40.991]             ...future.result["stdout"] <- base::list(NULL)
[17:39:40.991]         }
[17:39:40.991]         base::close(...future.stdout)
[17:39:40.991]         ...future.stdout <- NULL
[17:39:40.991]     }
[17:39:40.991]     ...future.result$conditions <- ...future.conditions
[17:39:40.991]     ...future.result$finished <- base::Sys.time()
[17:39:40.991]     ...future.result
[17:39:40.991] }
[17:39:40.993] requestCore(): workers = 2
[17:39:40.995] MulticoreFuture started
[17:39:40.996] - Launch lazy future ... done
[17:39:40.996] run() for ‘MulticoreFuture’ ... done
[17:39:40.997] result() for MulticoreFuture ...
[17:39:40.997] plan(): Setting new future strategy stack:
[17:39:40.997] List of future strategies:
[17:39:40.997] 1. sequential:
[17:39:40.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:40.997]    - tweaked: FALSE
[17:39:40.997]    - call: NULL
[17:39:40.998] plan(): nbrOfWorkers() = 1
[17:39:41.002] plan(): Setting new future strategy stack:
[17:39:41.002] List of future strategies:
[17:39:41.002] 1. multicore:
[17:39:41.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.002]    - tweaked: FALSE
[17:39:41.002]    - call: plan(strategy)
[17:39:41.007] plan(): nbrOfWorkers() = 2
[17:39:41.009] result() for MulticoreFuture ...
[17:39:41.009] result() for MulticoreFuture ... done
[17:39:41.010] result() for MulticoreFuture ... done
[17:39:41.010] result() for MulticoreFuture ...
[17:39:41.010] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:39:41.013] getGlobalsAndPackages() ...
[17:39:41.013] Searching for globals...
[17:39:41.015] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:39:41.016] Searching for globals ... DONE
[17:39:41.016] Resolving globals: FALSE
[17:39:41.016] 
[17:39:41.016] - packages: [2] ‘stats’, ‘datasets’
[17:39:41.017] getGlobalsAndPackages() ... DONE
[17:39:41.017] run() for ‘Future’ ...
[17:39:41.017] - state: ‘created’
[17:39:41.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.021] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:41.022]   - Field: ‘label’
[17:39:41.022]   - Field: ‘local’
[17:39:41.022]   - Field: ‘owner’
[17:39:41.022]   - Field: ‘envir’
[17:39:41.022]   - Field: ‘workers’
[17:39:41.022]   - Field: ‘packages’
[17:39:41.022]   - Field: ‘gc’
[17:39:41.022]   - Field: ‘job’
[17:39:41.023]   - Field: ‘conditions’
[17:39:41.023]   - Field: ‘expr’
[17:39:41.023]   - Field: ‘uuid’
[17:39:41.023]   - Field: ‘seed’
[17:39:41.023]   - Field: ‘version’
[17:39:41.023]   - Field: ‘result’
[17:39:41.023]   - Field: ‘asynchronous’
[17:39:41.023]   - Field: ‘calls’
[17:39:41.023]   - Field: ‘globals’
[17:39:41.024]   - Field: ‘stdout’
[17:39:41.024]   - Field: ‘earlySignal’
[17:39:41.024]   - Field: ‘lazy’
[17:39:41.024]   - Field: ‘state’
[17:39:41.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:41.024] - Launch lazy future ...
[17:39:41.024] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:41.025] Packages needed by future strategies (n = 0): <none>
[17:39:41.025] {
[17:39:41.025]     {
[17:39:41.025]         {
[17:39:41.025]             ...future.startTime <- base::Sys.time()
[17:39:41.025]             {
[17:39:41.025]                 {
[17:39:41.025]                   {
[17:39:41.025]                     {
[17:39:41.025]                       {
[17:39:41.025]                         base::local({
[17:39:41.025]                           has_future <- base::requireNamespace("future", 
[17:39:41.025]                             quietly = TRUE)
[17:39:41.025]                           if (has_future) {
[17:39:41.025]                             ns <- base::getNamespace("future")
[17:39:41.025]                             version <- ns[[".package"]][["version"]]
[17:39:41.025]                             if (is.null(version)) 
[17:39:41.025]                               version <- utils::packageVersion("future")
[17:39:41.025]                           }
[17:39:41.025]                           else {
[17:39:41.025]                             version <- NULL
[17:39:41.025]                           }
[17:39:41.025]                           if (!has_future || version < "1.8.0") {
[17:39:41.025]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.025]                               "", base::R.version$version.string), 
[17:39:41.025]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:41.025]                                 base::R.version$platform, 8 * 
[17:39:41.025]                                   base::.Machine$sizeof.pointer), 
[17:39:41.025]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.025]                                 "release", "version")], collapse = " "), 
[17:39:41.025]                               hostname = base::Sys.info()[["nodename"]])
[17:39:41.025]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.025]                               info)
[17:39:41.025]                             info <- base::paste(info, collapse = "; ")
[17:39:41.025]                             if (!has_future) {
[17:39:41.025]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.025]                                 info)
[17:39:41.025]                             }
[17:39:41.025]                             else {
[17:39:41.025]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.025]                                 info, version)
[17:39:41.025]                             }
[17:39:41.025]                             base::stop(msg)
[17:39:41.025]                           }
[17:39:41.025]                         })
[17:39:41.025]                       }
[17:39:41.025]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.025]                       base::options(mc.cores = 1L)
[17:39:41.025]                     }
[17:39:41.025]                     base::local({
[17:39:41.025]                       for (pkg in c("stats", "datasets")) {
[17:39:41.025]                         base::loadNamespace(pkg)
[17:39:41.025]                         base::library(pkg, character.only = TRUE)
[17:39:41.025]                       }
[17:39:41.025]                     })
[17:39:41.025]                   }
[17:39:41.025]                   ...future.strategy.old <- future::plan("list")
[17:39:41.025]                   options(future.plan = NULL)
[17:39:41.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.025]                 }
[17:39:41.025]                 ...future.workdir <- getwd()
[17:39:41.025]             }
[17:39:41.025]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.025]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.025]         }
[17:39:41.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.025]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.025]             base::names(...future.oldOptions))
[17:39:41.025]     }
[17:39:41.025]     if (FALSE) {
[17:39:41.025]     }
[17:39:41.025]     else {
[17:39:41.025]         if (TRUE) {
[17:39:41.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.025]                 open = "w")
[17:39:41.025]         }
[17:39:41.025]         else {
[17:39:41.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.025]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.025]         }
[17:39:41.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.025]             base::sink(type = "output", split = FALSE)
[17:39:41.025]             base::close(...future.stdout)
[17:39:41.025]         }, add = TRUE)
[17:39:41.025]     }
[17:39:41.025]     ...future.frame <- base::sys.nframe()
[17:39:41.025]     ...future.conditions <- base::list()
[17:39:41.025]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.025]     if (FALSE) {
[17:39:41.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.025]     }
[17:39:41.025]     ...future.result <- base::tryCatch({
[17:39:41.025]         base::withCallingHandlers({
[17:39:41.025]             ...future.value <- base::withVisible(base::local({
[17:39:41.025]                 withCallingHandlers({
[17:39:41.025]                   {
[17:39:41.025]                     lm(dist ~ . + 0, data = cars)
[17:39:41.025]                   }
[17:39:41.025]                 }, immediateCondition = function(cond) {
[17:39:41.025]                   save_rds <- function (object, pathname, ...) 
[17:39:41.025]                   {
[17:39:41.025]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:41.025]                     if (file_test("-f", pathname_tmp)) {
[17:39:41.025]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.025]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:41.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.025]                         fi_tmp[["mtime"]])
[17:39:41.025]                     }
[17:39:41.025]                     tryCatch({
[17:39:41.025]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:41.025]                     }, error = function(ex) {
[17:39:41.025]                       msg <- conditionMessage(ex)
[17:39:41.025]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.025]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:41.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.025]                         fi_tmp[["mtime"]], msg)
[17:39:41.025]                       ex$message <- msg
[17:39:41.025]                       stop(ex)
[17:39:41.025]                     })
[17:39:41.025]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:41.025]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:41.025]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:41.025]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.025]                       fi <- file.info(pathname)
[17:39:41.025]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:41.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.025]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:41.025]                         fi[["size"]], fi[["mtime"]])
[17:39:41.025]                       stop(msg)
[17:39:41.025]                     }
[17:39:41.025]                     invisible(pathname)
[17:39:41.025]                   }
[17:39:41.025]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:41.025]                     rootPath = tempdir()) 
[17:39:41.025]                   {
[17:39:41.025]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:41.025]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:41.025]                       tmpdir = path, fileext = ".rds")
[17:39:41.025]                     save_rds(obj, file)
[17:39:41.025]                   }
[17:39:41.025]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:41.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.025]                   {
[17:39:41.025]                     inherits <- base::inherits
[17:39:41.025]                     invokeRestart <- base::invokeRestart
[17:39:41.025]                     is.null <- base::is.null
[17:39:41.025]                     muffled <- FALSE
[17:39:41.025]                     if (inherits(cond, "message")) {
[17:39:41.025]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.025]                       if (muffled) 
[17:39:41.025]                         invokeRestart("muffleMessage")
[17:39:41.025]                     }
[17:39:41.025]                     else if (inherits(cond, "warning")) {
[17:39:41.025]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.025]                       if (muffled) 
[17:39:41.025]                         invokeRestart("muffleWarning")
[17:39:41.025]                     }
[17:39:41.025]                     else if (inherits(cond, "condition")) {
[17:39:41.025]                       if (!is.null(pattern)) {
[17:39:41.025]                         computeRestarts <- base::computeRestarts
[17:39:41.025]                         grepl <- base::grepl
[17:39:41.025]                         restarts <- computeRestarts(cond)
[17:39:41.025]                         for (restart in restarts) {
[17:39:41.025]                           name <- restart$name
[17:39:41.025]                           if (is.null(name)) 
[17:39:41.025]                             next
[17:39:41.025]                           if (!grepl(pattern, name)) 
[17:39:41.025]                             next
[17:39:41.025]                           invokeRestart(restart)
[17:39:41.025]                           muffled <- TRUE
[17:39:41.025]                           break
[17:39:41.025]                         }
[17:39:41.025]                       }
[17:39:41.025]                     }
[17:39:41.025]                     invisible(muffled)
[17:39:41.025]                   }
[17:39:41.025]                   muffleCondition(cond)
[17:39:41.025]                 })
[17:39:41.025]             }))
[17:39:41.025]             future::FutureResult(value = ...future.value$value, 
[17:39:41.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.025]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.025]                     ...future.globalenv.names))
[17:39:41.025]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.025]         }, condition = base::local({
[17:39:41.025]             c <- base::c
[17:39:41.025]             inherits <- base::inherits
[17:39:41.025]             invokeRestart <- base::invokeRestart
[17:39:41.025]             length <- base::length
[17:39:41.025]             list <- base::list
[17:39:41.025]             seq.int <- base::seq.int
[17:39:41.025]             signalCondition <- base::signalCondition
[17:39:41.025]             sys.calls <- base::sys.calls
[17:39:41.025]             `[[` <- base::`[[`
[17:39:41.025]             `+` <- base::`+`
[17:39:41.025]             `<<-` <- base::`<<-`
[17:39:41.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.025]                   3L)]
[17:39:41.025]             }
[17:39:41.025]             function(cond) {
[17:39:41.025]                 is_error <- inherits(cond, "error")
[17:39:41.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.025]                   NULL)
[17:39:41.025]                 if (is_error) {
[17:39:41.025]                   sessionInformation <- function() {
[17:39:41.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.025]                       search = base::search(), system = base::Sys.info())
[17:39:41.025]                   }
[17:39:41.025]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.025]                     cond$call), session = sessionInformation(), 
[17:39:41.025]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.025]                   signalCondition(cond)
[17:39:41.025]                 }
[17:39:41.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.025]                 "immediateCondition"))) {
[17:39:41.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.025]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.025]                   if (TRUE && !signal) {
[17:39:41.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.025]                     {
[17:39:41.025]                       inherits <- base::inherits
[17:39:41.025]                       invokeRestart <- base::invokeRestart
[17:39:41.025]                       is.null <- base::is.null
[17:39:41.025]                       muffled <- FALSE
[17:39:41.025]                       if (inherits(cond, "message")) {
[17:39:41.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.025]                         if (muffled) 
[17:39:41.025]                           invokeRestart("muffleMessage")
[17:39:41.025]                       }
[17:39:41.025]                       else if (inherits(cond, "warning")) {
[17:39:41.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.025]                         if (muffled) 
[17:39:41.025]                           invokeRestart("muffleWarning")
[17:39:41.025]                       }
[17:39:41.025]                       else if (inherits(cond, "condition")) {
[17:39:41.025]                         if (!is.null(pattern)) {
[17:39:41.025]                           computeRestarts <- base::computeRestarts
[17:39:41.025]                           grepl <- base::grepl
[17:39:41.025]                           restarts <- computeRestarts(cond)
[17:39:41.025]                           for (restart in restarts) {
[17:39:41.025]                             name <- restart$name
[17:39:41.025]                             if (is.null(name)) 
[17:39:41.025]                               next
[17:39:41.025]                             if (!grepl(pattern, name)) 
[17:39:41.025]                               next
[17:39:41.025]                             invokeRestart(restart)
[17:39:41.025]                             muffled <- TRUE
[17:39:41.025]                             break
[17:39:41.025]                           }
[17:39:41.025]                         }
[17:39:41.025]                       }
[17:39:41.025]                       invisible(muffled)
[17:39:41.025]                     }
[17:39:41.025]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.025]                   }
[17:39:41.025]                 }
[17:39:41.025]                 else {
[17:39:41.025]                   if (TRUE) {
[17:39:41.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.025]                     {
[17:39:41.025]                       inherits <- base::inherits
[17:39:41.025]                       invokeRestart <- base::invokeRestart
[17:39:41.025]                       is.null <- base::is.null
[17:39:41.025]                       muffled <- FALSE
[17:39:41.025]                       if (inherits(cond, "message")) {
[17:39:41.025]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.025]                         if (muffled) 
[17:39:41.025]                           invokeRestart("muffleMessage")
[17:39:41.025]                       }
[17:39:41.025]                       else if (inherits(cond, "warning")) {
[17:39:41.025]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.025]                         if (muffled) 
[17:39:41.025]                           invokeRestart("muffleWarning")
[17:39:41.025]                       }
[17:39:41.025]                       else if (inherits(cond, "condition")) {
[17:39:41.025]                         if (!is.null(pattern)) {
[17:39:41.025]                           computeRestarts <- base::computeRestarts
[17:39:41.025]                           grepl <- base::grepl
[17:39:41.025]                           restarts <- computeRestarts(cond)
[17:39:41.025]                           for (restart in restarts) {
[17:39:41.025]                             name <- restart$name
[17:39:41.025]                             if (is.null(name)) 
[17:39:41.025]                               next
[17:39:41.025]                             if (!grepl(pattern, name)) 
[17:39:41.025]                               next
[17:39:41.025]                             invokeRestart(restart)
[17:39:41.025]                             muffled <- TRUE
[17:39:41.025]                             break
[17:39:41.025]                           }
[17:39:41.025]                         }
[17:39:41.025]                       }
[17:39:41.025]                       invisible(muffled)
[17:39:41.025]                     }
[17:39:41.025]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.025]                   }
[17:39:41.025]                 }
[17:39:41.025]             }
[17:39:41.025]         }))
[17:39:41.025]     }, error = function(ex) {
[17:39:41.025]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.025]                 ...future.rng), started = ...future.startTime, 
[17:39:41.025]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.025]             version = "1.8"), class = "FutureResult")
[17:39:41.025]     }, finally = {
[17:39:41.025]         if (!identical(...future.workdir, getwd())) 
[17:39:41.025]             setwd(...future.workdir)
[17:39:41.025]         {
[17:39:41.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.025]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.025]             }
[17:39:41.025]             base::options(...future.oldOptions)
[17:39:41.025]             if (.Platform$OS.type == "windows") {
[17:39:41.025]                 old_names <- names(...future.oldEnvVars)
[17:39:41.025]                 envs <- base::Sys.getenv()
[17:39:41.025]                 names <- names(envs)
[17:39:41.025]                 common <- intersect(names, old_names)
[17:39:41.025]                 added <- setdiff(names, old_names)
[17:39:41.025]                 removed <- setdiff(old_names, names)
[17:39:41.025]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.025]                   envs[common]]
[17:39:41.025]                 NAMES <- toupper(changed)
[17:39:41.025]                 args <- list()
[17:39:41.025]                 for (kk in seq_along(NAMES)) {
[17:39:41.025]                   name <- changed[[kk]]
[17:39:41.025]                   NAME <- NAMES[[kk]]
[17:39:41.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.025]                     next
[17:39:41.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.025]                 }
[17:39:41.025]                 NAMES <- toupper(added)
[17:39:41.025]                 for (kk in seq_along(NAMES)) {
[17:39:41.025]                   name <- added[[kk]]
[17:39:41.025]                   NAME <- NAMES[[kk]]
[17:39:41.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.025]                     next
[17:39:41.025]                   args[[name]] <- ""
[17:39:41.025]                 }
[17:39:41.025]                 NAMES <- toupper(removed)
[17:39:41.025]                 for (kk in seq_along(NAMES)) {
[17:39:41.025]                   name <- removed[[kk]]
[17:39:41.025]                   NAME <- NAMES[[kk]]
[17:39:41.025]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.025]                     next
[17:39:41.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.025]                 }
[17:39:41.025]                 if (length(args) > 0) 
[17:39:41.025]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.025]             }
[17:39:41.025]             else {
[17:39:41.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.025]             }
[17:39:41.025]             {
[17:39:41.025]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.025]                   0L) {
[17:39:41.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.025]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.025]                   base::options(opts)
[17:39:41.025]                 }
[17:39:41.025]                 {
[17:39:41.025]                   {
[17:39:41.025]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.025]                     NULL
[17:39:41.025]                   }
[17:39:41.025]                   options(future.plan = NULL)
[17:39:41.025]                   if (is.na(NA_character_)) 
[17:39:41.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.025]                     .init = FALSE)
[17:39:41.025]                 }
[17:39:41.025]             }
[17:39:41.025]         }
[17:39:41.025]     })
[17:39:41.025]     if (TRUE) {
[17:39:41.025]         base::sink(type = "output", split = FALSE)
[17:39:41.025]         if (TRUE) {
[17:39:41.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.025]         }
[17:39:41.025]         else {
[17:39:41.025]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.025]         }
[17:39:41.025]         base::close(...future.stdout)
[17:39:41.025]         ...future.stdout <- NULL
[17:39:41.025]     }
[17:39:41.025]     ...future.result$conditions <- ...future.conditions
[17:39:41.025]     ...future.result$finished <- base::Sys.time()
[17:39:41.025]     ...future.result
[17:39:41.025] }
[17:39:41.028] requestCore(): workers = 2
[17:39:41.030] MulticoreFuture started
[17:39:41.030] - Launch lazy future ... done
[17:39:41.030] run() for ‘MulticoreFuture’ ... done
[17:39:41.031] result() for MulticoreFuture ...
[17:39:41.031] plan(): Setting new future strategy stack:
[17:39:41.032] List of future strategies:
[17:39:41.032] 1. sequential:
[17:39:41.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:41.032]    - tweaked: FALSE
[17:39:41.032]    - call: NULL
[17:39:41.033] plan(): nbrOfWorkers() = 1
[17:39:41.036] plan(): Setting new future strategy stack:
[17:39:41.036] List of future strategies:
[17:39:41.036] 1. multicore:
[17:39:41.036]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.036]    - tweaked: FALSE
[17:39:41.036]    - call: plan(strategy)
[17:39:41.041] plan(): nbrOfWorkers() = 2
[17:39:41.044] result() for MulticoreFuture ...
[17:39:41.044] result() for MulticoreFuture ... done
[17:39:41.044] result() for MulticoreFuture ... done
[17:39:41.044] result() for MulticoreFuture ...
[17:39:41.044] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:39:41.047] getGlobalsAndPackages() ...
[17:39:41.048] Searching for globals...
[17:39:41.053] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:39:41.053] Searching for globals ... DONE
[17:39:41.053] Resolving globals: FALSE
[17:39:41.054] 
[17:39:41.054] - packages: [2] ‘stats’, ‘datasets’
[17:39:41.054] getGlobalsAndPackages() ... DONE
[17:39:41.055] run() for ‘Future’ ...
[17:39:41.055] - state: ‘created’
[17:39:41.055] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.059] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:41.060]   - Field: ‘label’
[17:39:41.060]   - Field: ‘local’
[17:39:41.060]   - Field: ‘owner’
[17:39:41.060]   - Field: ‘envir’
[17:39:41.060]   - Field: ‘workers’
[17:39:41.061]   - Field: ‘packages’
[17:39:41.061]   - Field: ‘gc’
[17:39:41.061]   - Field: ‘job’
[17:39:41.061]   - Field: ‘conditions’
[17:39:41.061]   - Field: ‘expr’
[17:39:41.061]   - Field: ‘uuid’
[17:39:41.061]   - Field: ‘seed’
[17:39:41.061]   - Field: ‘version’
[17:39:41.061]   - Field: ‘result’
[17:39:41.062]   - Field: ‘asynchronous’
[17:39:41.062]   - Field: ‘calls’
[17:39:41.062]   - Field: ‘globals’
[17:39:41.062]   - Field: ‘stdout’
[17:39:41.062]   - Field: ‘earlySignal’
[17:39:41.062]   - Field: ‘lazy’
[17:39:41.062]   - Field: ‘state’
[17:39:41.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:41.063] - Launch lazy future ...
[17:39:41.063] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:41.063] Packages needed by future strategies (n = 0): <none>
[17:39:41.064] {
[17:39:41.064]     {
[17:39:41.064]         {
[17:39:41.064]             ...future.startTime <- base::Sys.time()
[17:39:41.064]             {
[17:39:41.064]                 {
[17:39:41.064]                   {
[17:39:41.064]                     {
[17:39:41.064]                       {
[17:39:41.064]                         base::local({
[17:39:41.064]                           has_future <- base::requireNamespace("future", 
[17:39:41.064]                             quietly = TRUE)
[17:39:41.064]                           if (has_future) {
[17:39:41.064]                             ns <- base::getNamespace("future")
[17:39:41.064]                             version <- ns[[".package"]][["version"]]
[17:39:41.064]                             if (is.null(version)) 
[17:39:41.064]                               version <- utils::packageVersion("future")
[17:39:41.064]                           }
[17:39:41.064]                           else {
[17:39:41.064]                             version <- NULL
[17:39:41.064]                           }
[17:39:41.064]                           if (!has_future || version < "1.8.0") {
[17:39:41.064]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.064]                               "", base::R.version$version.string), 
[17:39:41.064]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:41.064]                                 base::R.version$platform, 8 * 
[17:39:41.064]                                   base::.Machine$sizeof.pointer), 
[17:39:41.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.064]                                 "release", "version")], collapse = " "), 
[17:39:41.064]                               hostname = base::Sys.info()[["nodename"]])
[17:39:41.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.064]                               info)
[17:39:41.064]                             info <- base::paste(info, collapse = "; ")
[17:39:41.064]                             if (!has_future) {
[17:39:41.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.064]                                 info)
[17:39:41.064]                             }
[17:39:41.064]                             else {
[17:39:41.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.064]                                 info, version)
[17:39:41.064]                             }
[17:39:41.064]                             base::stop(msg)
[17:39:41.064]                           }
[17:39:41.064]                         })
[17:39:41.064]                       }
[17:39:41.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.064]                       base::options(mc.cores = 1L)
[17:39:41.064]                     }
[17:39:41.064]                     base::local({
[17:39:41.064]                       for (pkg in c("stats", "datasets")) {
[17:39:41.064]                         base::loadNamespace(pkg)
[17:39:41.064]                         base::library(pkg, character.only = TRUE)
[17:39:41.064]                       }
[17:39:41.064]                     })
[17:39:41.064]                   }
[17:39:41.064]                   ...future.strategy.old <- future::plan("list")
[17:39:41.064]                   options(future.plan = NULL)
[17:39:41.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.064]                 }
[17:39:41.064]                 ...future.workdir <- getwd()
[17:39:41.064]             }
[17:39:41.064]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.064]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.064]         }
[17:39:41.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.064]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.064]             base::names(...future.oldOptions))
[17:39:41.064]     }
[17:39:41.064]     if (FALSE) {
[17:39:41.064]     }
[17:39:41.064]     else {
[17:39:41.064]         if (TRUE) {
[17:39:41.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.064]                 open = "w")
[17:39:41.064]         }
[17:39:41.064]         else {
[17:39:41.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.064]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.064]         }
[17:39:41.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.064]             base::sink(type = "output", split = FALSE)
[17:39:41.064]             base::close(...future.stdout)
[17:39:41.064]         }, add = TRUE)
[17:39:41.064]     }
[17:39:41.064]     ...future.frame <- base::sys.nframe()
[17:39:41.064]     ...future.conditions <- base::list()
[17:39:41.064]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.064]     if (FALSE) {
[17:39:41.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.064]     }
[17:39:41.064]     ...future.result <- base::tryCatch({
[17:39:41.064]         base::withCallingHandlers({
[17:39:41.064]             ...future.value <- base::withVisible(base::local({
[17:39:41.064]                 withCallingHandlers({
[17:39:41.064]                   {
[17:39:41.064]                     lm(dist ~ speed + speed^2, data = cars)
[17:39:41.064]                   }
[17:39:41.064]                 }, immediateCondition = function(cond) {
[17:39:41.064]                   save_rds <- function (object, pathname, ...) 
[17:39:41.064]                   {
[17:39:41.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:41.064]                     if (file_test("-f", pathname_tmp)) {
[17:39:41.064]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:41.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.064]                         fi_tmp[["mtime"]])
[17:39:41.064]                     }
[17:39:41.064]                     tryCatch({
[17:39:41.064]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:41.064]                     }, error = function(ex) {
[17:39:41.064]                       msg <- conditionMessage(ex)
[17:39:41.064]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:41.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.064]                         fi_tmp[["mtime"]], msg)
[17:39:41.064]                       ex$message <- msg
[17:39:41.064]                       stop(ex)
[17:39:41.064]                     })
[17:39:41.064]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:41.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:41.064]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:41.064]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.064]                       fi <- file.info(pathname)
[17:39:41.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:41.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:41.064]                         fi[["size"]], fi[["mtime"]])
[17:39:41.064]                       stop(msg)
[17:39:41.064]                     }
[17:39:41.064]                     invisible(pathname)
[17:39:41.064]                   }
[17:39:41.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:41.064]                     rootPath = tempdir()) 
[17:39:41.064]                   {
[17:39:41.064]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:41.064]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:41.064]                       tmpdir = path, fileext = ".rds")
[17:39:41.064]                     save_rds(obj, file)
[17:39:41.064]                   }
[17:39:41.064]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:41.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.064]                   {
[17:39:41.064]                     inherits <- base::inherits
[17:39:41.064]                     invokeRestart <- base::invokeRestart
[17:39:41.064]                     is.null <- base::is.null
[17:39:41.064]                     muffled <- FALSE
[17:39:41.064]                     if (inherits(cond, "message")) {
[17:39:41.064]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.064]                       if (muffled) 
[17:39:41.064]                         invokeRestart("muffleMessage")
[17:39:41.064]                     }
[17:39:41.064]                     else if (inherits(cond, "warning")) {
[17:39:41.064]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.064]                       if (muffled) 
[17:39:41.064]                         invokeRestart("muffleWarning")
[17:39:41.064]                     }
[17:39:41.064]                     else if (inherits(cond, "condition")) {
[17:39:41.064]                       if (!is.null(pattern)) {
[17:39:41.064]                         computeRestarts <- base::computeRestarts
[17:39:41.064]                         grepl <- base::grepl
[17:39:41.064]                         restarts <- computeRestarts(cond)
[17:39:41.064]                         for (restart in restarts) {
[17:39:41.064]                           name <- restart$name
[17:39:41.064]                           if (is.null(name)) 
[17:39:41.064]                             next
[17:39:41.064]                           if (!grepl(pattern, name)) 
[17:39:41.064]                             next
[17:39:41.064]                           invokeRestart(restart)
[17:39:41.064]                           muffled <- TRUE
[17:39:41.064]                           break
[17:39:41.064]                         }
[17:39:41.064]                       }
[17:39:41.064]                     }
[17:39:41.064]                     invisible(muffled)
[17:39:41.064]                   }
[17:39:41.064]                   muffleCondition(cond)
[17:39:41.064]                 })
[17:39:41.064]             }))
[17:39:41.064]             future::FutureResult(value = ...future.value$value, 
[17:39:41.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.064]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.064]                     ...future.globalenv.names))
[17:39:41.064]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.064]         }, condition = base::local({
[17:39:41.064]             c <- base::c
[17:39:41.064]             inherits <- base::inherits
[17:39:41.064]             invokeRestart <- base::invokeRestart
[17:39:41.064]             length <- base::length
[17:39:41.064]             list <- base::list
[17:39:41.064]             seq.int <- base::seq.int
[17:39:41.064]             signalCondition <- base::signalCondition
[17:39:41.064]             sys.calls <- base::sys.calls
[17:39:41.064]             `[[` <- base::`[[`
[17:39:41.064]             `+` <- base::`+`
[17:39:41.064]             `<<-` <- base::`<<-`
[17:39:41.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.064]                   3L)]
[17:39:41.064]             }
[17:39:41.064]             function(cond) {
[17:39:41.064]                 is_error <- inherits(cond, "error")
[17:39:41.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.064]                   NULL)
[17:39:41.064]                 if (is_error) {
[17:39:41.064]                   sessionInformation <- function() {
[17:39:41.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.064]                       search = base::search(), system = base::Sys.info())
[17:39:41.064]                   }
[17:39:41.064]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.064]                     cond$call), session = sessionInformation(), 
[17:39:41.064]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.064]                   signalCondition(cond)
[17:39:41.064]                 }
[17:39:41.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.064]                 "immediateCondition"))) {
[17:39:41.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.064]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.064]                   if (TRUE && !signal) {
[17:39:41.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.064]                     {
[17:39:41.064]                       inherits <- base::inherits
[17:39:41.064]                       invokeRestart <- base::invokeRestart
[17:39:41.064]                       is.null <- base::is.null
[17:39:41.064]                       muffled <- FALSE
[17:39:41.064]                       if (inherits(cond, "message")) {
[17:39:41.064]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.064]                         if (muffled) 
[17:39:41.064]                           invokeRestart("muffleMessage")
[17:39:41.064]                       }
[17:39:41.064]                       else if (inherits(cond, "warning")) {
[17:39:41.064]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.064]                         if (muffled) 
[17:39:41.064]                           invokeRestart("muffleWarning")
[17:39:41.064]                       }
[17:39:41.064]                       else if (inherits(cond, "condition")) {
[17:39:41.064]                         if (!is.null(pattern)) {
[17:39:41.064]                           computeRestarts <- base::computeRestarts
[17:39:41.064]                           grepl <- base::grepl
[17:39:41.064]                           restarts <- computeRestarts(cond)
[17:39:41.064]                           for (restart in restarts) {
[17:39:41.064]                             name <- restart$name
[17:39:41.064]                             if (is.null(name)) 
[17:39:41.064]                               next
[17:39:41.064]                             if (!grepl(pattern, name)) 
[17:39:41.064]                               next
[17:39:41.064]                             invokeRestart(restart)
[17:39:41.064]                             muffled <- TRUE
[17:39:41.064]                             break
[17:39:41.064]                           }
[17:39:41.064]                         }
[17:39:41.064]                       }
[17:39:41.064]                       invisible(muffled)
[17:39:41.064]                     }
[17:39:41.064]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.064]                   }
[17:39:41.064]                 }
[17:39:41.064]                 else {
[17:39:41.064]                   if (TRUE) {
[17:39:41.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.064]                     {
[17:39:41.064]                       inherits <- base::inherits
[17:39:41.064]                       invokeRestart <- base::invokeRestart
[17:39:41.064]                       is.null <- base::is.null
[17:39:41.064]                       muffled <- FALSE
[17:39:41.064]                       if (inherits(cond, "message")) {
[17:39:41.064]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.064]                         if (muffled) 
[17:39:41.064]                           invokeRestart("muffleMessage")
[17:39:41.064]                       }
[17:39:41.064]                       else if (inherits(cond, "warning")) {
[17:39:41.064]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.064]                         if (muffled) 
[17:39:41.064]                           invokeRestart("muffleWarning")
[17:39:41.064]                       }
[17:39:41.064]                       else if (inherits(cond, "condition")) {
[17:39:41.064]                         if (!is.null(pattern)) {
[17:39:41.064]                           computeRestarts <- base::computeRestarts
[17:39:41.064]                           grepl <- base::grepl
[17:39:41.064]                           restarts <- computeRestarts(cond)
[17:39:41.064]                           for (restart in restarts) {
[17:39:41.064]                             name <- restart$name
[17:39:41.064]                             if (is.null(name)) 
[17:39:41.064]                               next
[17:39:41.064]                             if (!grepl(pattern, name)) 
[17:39:41.064]                               next
[17:39:41.064]                             invokeRestart(restart)
[17:39:41.064]                             muffled <- TRUE
[17:39:41.064]                             break
[17:39:41.064]                           }
[17:39:41.064]                         }
[17:39:41.064]                       }
[17:39:41.064]                       invisible(muffled)
[17:39:41.064]                     }
[17:39:41.064]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.064]                   }
[17:39:41.064]                 }
[17:39:41.064]             }
[17:39:41.064]         }))
[17:39:41.064]     }, error = function(ex) {
[17:39:41.064]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.064]                 ...future.rng), started = ...future.startTime, 
[17:39:41.064]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.064]             version = "1.8"), class = "FutureResult")
[17:39:41.064]     }, finally = {
[17:39:41.064]         if (!identical(...future.workdir, getwd())) 
[17:39:41.064]             setwd(...future.workdir)
[17:39:41.064]         {
[17:39:41.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.064]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.064]             }
[17:39:41.064]             base::options(...future.oldOptions)
[17:39:41.064]             if (.Platform$OS.type == "windows") {
[17:39:41.064]                 old_names <- names(...future.oldEnvVars)
[17:39:41.064]                 envs <- base::Sys.getenv()
[17:39:41.064]                 names <- names(envs)
[17:39:41.064]                 common <- intersect(names, old_names)
[17:39:41.064]                 added <- setdiff(names, old_names)
[17:39:41.064]                 removed <- setdiff(old_names, names)
[17:39:41.064]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.064]                   envs[common]]
[17:39:41.064]                 NAMES <- toupper(changed)
[17:39:41.064]                 args <- list()
[17:39:41.064]                 for (kk in seq_along(NAMES)) {
[17:39:41.064]                   name <- changed[[kk]]
[17:39:41.064]                   NAME <- NAMES[[kk]]
[17:39:41.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.064]                     next
[17:39:41.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.064]                 }
[17:39:41.064]                 NAMES <- toupper(added)
[17:39:41.064]                 for (kk in seq_along(NAMES)) {
[17:39:41.064]                   name <- added[[kk]]
[17:39:41.064]                   NAME <- NAMES[[kk]]
[17:39:41.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.064]                     next
[17:39:41.064]                   args[[name]] <- ""
[17:39:41.064]                 }
[17:39:41.064]                 NAMES <- toupper(removed)
[17:39:41.064]                 for (kk in seq_along(NAMES)) {
[17:39:41.064]                   name <- removed[[kk]]
[17:39:41.064]                   NAME <- NAMES[[kk]]
[17:39:41.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.064]                     next
[17:39:41.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.064]                 }
[17:39:41.064]                 if (length(args) > 0) 
[17:39:41.064]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.064]             }
[17:39:41.064]             else {
[17:39:41.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.064]             }
[17:39:41.064]             {
[17:39:41.064]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.064]                   0L) {
[17:39:41.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.064]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.064]                   base::options(opts)
[17:39:41.064]                 }
[17:39:41.064]                 {
[17:39:41.064]                   {
[17:39:41.064]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.064]                     NULL
[17:39:41.064]                   }
[17:39:41.064]                   options(future.plan = NULL)
[17:39:41.064]                   if (is.na(NA_character_)) 
[17:39:41.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.064]                     .init = FALSE)
[17:39:41.064]                 }
[17:39:41.064]             }
[17:39:41.064]         }
[17:39:41.064]     })
[17:39:41.064]     if (TRUE) {
[17:39:41.064]         base::sink(type = "output", split = FALSE)
[17:39:41.064]         if (TRUE) {
[17:39:41.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.064]         }
[17:39:41.064]         else {
[17:39:41.064]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.064]         }
[17:39:41.064]         base::close(...future.stdout)
[17:39:41.064]         ...future.stdout <- NULL
[17:39:41.064]     }
[17:39:41.064]     ...future.result$conditions <- ...future.conditions
[17:39:41.064]     ...future.result$finished <- base::Sys.time()
[17:39:41.064]     ...future.result
[17:39:41.064] }
[17:39:41.066] requestCore(): workers = 2
[17:39:41.068] MulticoreFuture started
[17:39:41.068] - Launch lazy future ... done
[17:39:41.069] run() for ‘MulticoreFuture’ ... done
[17:39:41.069] result() for MulticoreFuture ...
[17:39:41.070] plan(): Setting new future strategy stack:
[17:39:41.070] List of future strategies:
[17:39:41.070] 1. sequential:
[17:39:41.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:41.070]    - tweaked: FALSE
[17:39:41.070]    - call: NULL
[17:39:41.071] plan(): nbrOfWorkers() = 1
[17:39:41.075] plan(): Setting new future strategy stack:
[17:39:41.075] List of future strategies:
[17:39:41.075] 1. multicore:
[17:39:41.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.075]    - tweaked: FALSE
[17:39:41.075]    - call: plan(strategy)
[17:39:41.080] plan(): nbrOfWorkers() = 2
[17:39:41.082] result() for MulticoreFuture ...
[17:39:41.082] result() for MulticoreFuture ... done
[17:39:41.082] result() for MulticoreFuture ... done
[17:39:41.082] result() for MulticoreFuture ...
[17:39:41.082] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:39:41.086] getGlobalsAndPackages() ...
[17:39:41.086] Searching for globals...
[17:39:41.089] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:39:41.089] Searching for globals ... DONE
[17:39:41.089] Resolving globals: FALSE
[17:39:41.090] 
[17:39:41.090] - packages: [2] ‘stats’, ‘datasets’
[17:39:41.090] getGlobalsAndPackages() ... DONE
[17:39:41.090] run() for ‘Future’ ...
[17:39:41.090] - state: ‘created’
[17:39:41.090] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.094] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.094] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:41.095]   - Field: ‘label’
[17:39:41.095]   - Field: ‘local’
[17:39:41.095]   - Field: ‘owner’
[17:39:41.095]   - Field: ‘envir’
[17:39:41.095]   - Field: ‘workers’
[17:39:41.095]   - Field: ‘packages’
[17:39:41.095]   - Field: ‘gc’
[17:39:41.095]   - Field: ‘job’
[17:39:41.096]   - Field: ‘conditions’
[17:39:41.096]   - Field: ‘expr’
[17:39:41.096]   - Field: ‘uuid’
[17:39:41.096]   - Field: ‘seed’
[17:39:41.096]   - Field: ‘version’
[17:39:41.096]   - Field: ‘result’
[17:39:41.096]   - Field: ‘asynchronous’
[17:39:41.096]   - Field: ‘calls’
[17:39:41.096]   - Field: ‘globals’
[17:39:41.097]   - Field: ‘stdout’
[17:39:41.097]   - Field: ‘earlySignal’
[17:39:41.097]   - Field: ‘lazy’
[17:39:41.097]   - Field: ‘state’
[17:39:41.097] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:41.097] - Launch lazy future ...
[17:39:41.097] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:41.098] Packages needed by future strategies (n = 0): <none>
[17:39:41.134] {
[17:39:41.134]     {
[17:39:41.134]         {
[17:39:41.134]             ...future.startTime <- base::Sys.time()
[17:39:41.134]             {
[17:39:41.134]                 {
[17:39:41.134]                   {
[17:39:41.134]                     {
[17:39:41.134]                       {
[17:39:41.134]                         base::local({
[17:39:41.134]                           has_future <- base::requireNamespace("future", 
[17:39:41.134]                             quietly = TRUE)
[17:39:41.134]                           if (has_future) {
[17:39:41.134]                             ns <- base::getNamespace("future")
[17:39:41.134]                             version <- ns[[".package"]][["version"]]
[17:39:41.134]                             if (is.null(version)) 
[17:39:41.134]                               version <- utils::packageVersion("future")
[17:39:41.134]                           }
[17:39:41.134]                           else {
[17:39:41.134]                             version <- NULL
[17:39:41.134]                           }
[17:39:41.134]                           if (!has_future || version < "1.8.0") {
[17:39:41.134]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.134]                               "", base::R.version$version.string), 
[17:39:41.134]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:41.134]                                 base::R.version$platform, 8 * 
[17:39:41.134]                                   base::.Machine$sizeof.pointer), 
[17:39:41.134]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.134]                                 "release", "version")], collapse = " "), 
[17:39:41.134]                               hostname = base::Sys.info()[["nodename"]])
[17:39:41.134]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.134]                               info)
[17:39:41.134]                             info <- base::paste(info, collapse = "; ")
[17:39:41.134]                             if (!has_future) {
[17:39:41.134]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.134]                                 info)
[17:39:41.134]                             }
[17:39:41.134]                             else {
[17:39:41.134]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.134]                                 info, version)
[17:39:41.134]                             }
[17:39:41.134]                             base::stop(msg)
[17:39:41.134]                           }
[17:39:41.134]                         })
[17:39:41.134]                       }
[17:39:41.134]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.134]                       base::options(mc.cores = 1L)
[17:39:41.134]                     }
[17:39:41.134]                     base::local({
[17:39:41.134]                       for (pkg in c("stats", "datasets")) {
[17:39:41.134]                         base::loadNamespace(pkg)
[17:39:41.134]                         base::library(pkg, character.only = TRUE)
[17:39:41.134]                       }
[17:39:41.134]                     })
[17:39:41.134]                   }
[17:39:41.134]                   ...future.strategy.old <- future::plan("list")
[17:39:41.134]                   options(future.plan = NULL)
[17:39:41.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.134]                 }
[17:39:41.134]                 ...future.workdir <- getwd()
[17:39:41.134]             }
[17:39:41.134]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.134]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.134]         }
[17:39:41.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.134]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.134]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.134]             base::names(...future.oldOptions))
[17:39:41.134]     }
[17:39:41.134]     if (FALSE) {
[17:39:41.134]     }
[17:39:41.134]     else {
[17:39:41.134]         if (TRUE) {
[17:39:41.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.134]                 open = "w")
[17:39:41.134]         }
[17:39:41.134]         else {
[17:39:41.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.134]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.134]         }
[17:39:41.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.134]             base::sink(type = "output", split = FALSE)
[17:39:41.134]             base::close(...future.stdout)
[17:39:41.134]         }, add = TRUE)
[17:39:41.134]     }
[17:39:41.134]     ...future.frame <- base::sys.nframe()
[17:39:41.134]     ...future.conditions <- base::list()
[17:39:41.134]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.134]     if (FALSE) {
[17:39:41.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.134]     }
[17:39:41.134]     ...future.result <- base::tryCatch({
[17:39:41.134]         base::withCallingHandlers({
[17:39:41.134]             ...future.value <- base::withVisible(base::local({
[17:39:41.134]                 withCallingHandlers({
[17:39:41.134]                   {
[17:39:41.134]                     lm(dist ~ speed + I(speed^2), data = cars)
[17:39:41.134]                   }
[17:39:41.134]                 }, immediateCondition = function(cond) {
[17:39:41.134]                   save_rds <- function (object, pathname, ...) 
[17:39:41.134]                   {
[17:39:41.134]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:41.134]                     if (file_test("-f", pathname_tmp)) {
[17:39:41.134]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.134]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:41.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.134]                         fi_tmp[["mtime"]])
[17:39:41.134]                     }
[17:39:41.134]                     tryCatch({
[17:39:41.134]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:41.134]                     }, error = function(ex) {
[17:39:41.134]                       msg <- conditionMessage(ex)
[17:39:41.134]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.134]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:41.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.134]                         fi_tmp[["mtime"]], msg)
[17:39:41.134]                       ex$message <- msg
[17:39:41.134]                       stop(ex)
[17:39:41.134]                     })
[17:39:41.134]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:41.134]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:41.134]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:41.134]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.134]                       fi <- file.info(pathname)
[17:39:41.134]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:41.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.134]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:41.134]                         fi[["size"]], fi[["mtime"]])
[17:39:41.134]                       stop(msg)
[17:39:41.134]                     }
[17:39:41.134]                     invisible(pathname)
[17:39:41.134]                   }
[17:39:41.134]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:41.134]                     rootPath = tempdir()) 
[17:39:41.134]                   {
[17:39:41.134]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:41.134]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:41.134]                       tmpdir = path, fileext = ".rds")
[17:39:41.134]                     save_rds(obj, file)
[17:39:41.134]                   }
[17:39:41.134]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:41.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.134]                   {
[17:39:41.134]                     inherits <- base::inherits
[17:39:41.134]                     invokeRestart <- base::invokeRestart
[17:39:41.134]                     is.null <- base::is.null
[17:39:41.134]                     muffled <- FALSE
[17:39:41.134]                     if (inherits(cond, "message")) {
[17:39:41.134]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.134]                       if (muffled) 
[17:39:41.134]                         invokeRestart("muffleMessage")
[17:39:41.134]                     }
[17:39:41.134]                     else if (inherits(cond, "warning")) {
[17:39:41.134]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.134]                       if (muffled) 
[17:39:41.134]                         invokeRestart("muffleWarning")
[17:39:41.134]                     }
[17:39:41.134]                     else if (inherits(cond, "condition")) {
[17:39:41.134]                       if (!is.null(pattern)) {
[17:39:41.134]                         computeRestarts <- base::computeRestarts
[17:39:41.134]                         grepl <- base::grepl
[17:39:41.134]                         restarts <- computeRestarts(cond)
[17:39:41.134]                         for (restart in restarts) {
[17:39:41.134]                           name <- restart$name
[17:39:41.134]                           if (is.null(name)) 
[17:39:41.134]                             next
[17:39:41.134]                           if (!grepl(pattern, name)) 
[17:39:41.134]                             next
[17:39:41.134]                           invokeRestart(restart)
[17:39:41.134]                           muffled <- TRUE
[17:39:41.134]                           break
[17:39:41.134]                         }
[17:39:41.134]                       }
[17:39:41.134]                     }
[17:39:41.134]                     invisible(muffled)
[17:39:41.134]                   }
[17:39:41.134]                   muffleCondition(cond)
[17:39:41.134]                 })
[17:39:41.134]             }))
[17:39:41.134]             future::FutureResult(value = ...future.value$value, 
[17:39:41.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.134]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.134]                     ...future.globalenv.names))
[17:39:41.134]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.134]         }, condition = base::local({
[17:39:41.134]             c <- base::c
[17:39:41.134]             inherits <- base::inherits
[17:39:41.134]             invokeRestart <- base::invokeRestart
[17:39:41.134]             length <- base::length
[17:39:41.134]             list <- base::list
[17:39:41.134]             seq.int <- base::seq.int
[17:39:41.134]             signalCondition <- base::signalCondition
[17:39:41.134]             sys.calls <- base::sys.calls
[17:39:41.134]             `[[` <- base::`[[`
[17:39:41.134]             `+` <- base::`+`
[17:39:41.134]             `<<-` <- base::`<<-`
[17:39:41.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.134]                   3L)]
[17:39:41.134]             }
[17:39:41.134]             function(cond) {
[17:39:41.134]                 is_error <- inherits(cond, "error")
[17:39:41.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.134]                   NULL)
[17:39:41.134]                 if (is_error) {
[17:39:41.134]                   sessionInformation <- function() {
[17:39:41.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.134]                       search = base::search(), system = base::Sys.info())
[17:39:41.134]                   }
[17:39:41.134]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.134]                     cond$call), session = sessionInformation(), 
[17:39:41.134]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.134]                   signalCondition(cond)
[17:39:41.134]                 }
[17:39:41.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.134]                 "immediateCondition"))) {
[17:39:41.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.134]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.134]                   if (TRUE && !signal) {
[17:39:41.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.134]                     {
[17:39:41.134]                       inherits <- base::inherits
[17:39:41.134]                       invokeRestart <- base::invokeRestart
[17:39:41.134]                       is.null <- base::is.null
[17:39:41.134]                       muffled <- FALSE
[17:39:41.134]                       if (inherits(cond, "message")) {
[17:39:41.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.134]                         if (muffled) 
[17:39:41.134]                           invokeRestart("muffleMessage")
[17:39:41.134]                       }
[17:39:41.134]                       else if (inherits(cond, "warning")) {
[17:39:41.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.134]                         if (muffled) 
[17:39:41.134]                           invokeRestart("muffleWarning")
[17:39:41.134]                       }
[17:39:41.134]                       else if (inherits(cond, "condition")) {
[17:39:41.134]                         if (!is.null(pattern)) {
[17:39:41.134]                           computeRestarts <- base::computeRestarts
[17:39:41.134]                           grepl <- base::grepl
[17:39:41.134]                           restarts <- computeRestarts(cond)
[17:39:41.134]                           for (restart in restarts) {
[17:39:41.134]                             name <- restart$name
[17:39:41.134]                             if (is.null(name)) 
[17:39:41.134]                               next
[17:39:41.134]                             if (!grepl(pattern, name)) 
[17:39:41.134]                               next
[17:39:41.134]                             invokeRestart(restart)
[17:39:41.134]                             muffled <- TRUE
[17:39:41.134]                             break
[17:39:41.134]                           }
[17:39:41.134]                         }
[17:39:41.134]                       }
[17:39:41.134]                       invisible(muffled)
[17:39:41.134]                     }
[17:39:41.134]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.134]                   }
[17:39:41.134]                 }
[17:39:41.134]                 else {
[17:39:41.134]                   if (TRUE) {
[17:39:41.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.134]                     {
[17:39:41.134]                       inherits <- base::inherits
[17:39:41.134]                       invokeRestart <- base::invokeRestart
[17:39:41.134]                       is.null <- base::is.null
[17:39:41.134]                       muffled <- FALSE
[17:39:41.134]                       if (inherits(cond, "message")) {
[17:39:41.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.134]                         if (muffled) 
[17:39:41.134]                           invokeRestart("muffleMessage")
[17:39:41.134]                       }
[17:39:41.134]                       else if (inherits(cond, "warning")) {
[17:39:41.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.134]                         if (muffled) 
[17:39:41.134]                           invokeRestart("muffleWarning")
[17:39:41.134]                       }
[17:39:41.134]                       else if (inherits(cond, "condition")) {
[17:39:41.134]                         if (!is.null(pattern)) {
[17:39:41.134]                           computeRestarts <- base::computeRestarts
[17:39:41.134]                           grepl <- base::grepl
[17:39:41.134]                           restarts <- computeRestarts(cond)
[17:39:41.134]                           for (restart in restarts) {
[17:39:41.134]                             name <- restart$name
[17:39:41.134]                             if (is.null(name)) 
[17:39:41.134]                               next
[17:39:41.134]                             if (!grepl(pattern, name)) 
[17:39:41.134]                               next
[17:39:41.134]                             invokeRestart(restart)
[17:39:41.134]                             muffled <- TRUE
[17:39:41.134]                             break
[17:39:41.134]                           }
[17:39:41.134]                         }
[17:39:41.134]                       }
[17:39:41.134]                       invisible(muffled)
[17:39:41.134]                     }
[17:39:41.134]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.134]                   }
[17:39:41.134]                 }
[17:39:41.134]             }
[17:39:41.134]         }))
[17:39:41.134]     }, error = function(ex) {
[17:39:41.134]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.134]                 ...future.rng), started = ...future.startTime, 
[17:39:41.134]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.134]             version = "1.8"), class = "FutureResult")
[17:39:41.134]     }, finally = {
[17:39:41.134]         if (!identical(...future.workdir, getwd())) 
[17:39:41.134]             setwd(...future.workdir)
[17:39:41.134]         {
[17:39:41.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.134]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.134]             }
[17:39:41.134]             base::options(...future.oldOptions)
[17:39:41.134]             if (.Platform$OS.type == "windows") {
[17:39:41.134]                 old_names <- names(...future.oldEnvVars)
[17:39:41.134]                 envs <- base::Sys.getenv()
[17:39:41.134]                 names <- names(envs)
[17:39:41.134]                 common <- intersect(names, old_names)
[17:39:41.134]                 added <- setdiff(names, old_names)
[17:39:41.134]                 removed <- setdiff(old_names, names)
[17:39:41.134]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.134]                   envs[common]]
[17:39:41.134]                 NAMES <- toupper(changed)
[17:39:41.134]                 args <- list()
[17:39:41.134]                 for (kk in seq_along(NAMES)) {
[17:39:41.134]                   name <- changed[[kk]]
[17:39:41.134]                   NAME <- NAMES[[kk]]
[17:39:41.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.134]                     next
[17:39:41.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.134]                 }
[17:39:41.134]                 NAMES <- toupper(added)
[17:39:41.134]                 for (kk in seq_along(NAMES)) {
[17:39:41.134]                   name <- added[[kk]]
[17:39:41.134]                   NAME <- NAMES[[kk]]
[17:39:41.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.134]                     next
[17:39:41.134]                   args[[name]] <- ""
[17:39:41.134]                 }
[17:39:41.134]                 NAMES <- toupper(removed)
[17:39:41.134]                 for (kk in seq_along(NAMES)) {
[17:39:41.134]                   name <- removed[[kk]]
[17:39:41.134]                   NAME <- NAMES[[kk]]
[17:39:41.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.134]                     next
[17:39:41.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.134]                 }
[17:39:41.134]                 if (length(args) > 0) 
[17:39:41.134]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.134]             }
[17:39:41.134]             else {
[17:39:41.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.134]             }
[17:39:41.134]             {
[17:39:41.134]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.134]                   0L) {
[17:39:41.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.134]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.134]                   base::options(opts)
[17:39:41.134]                 }
[17:39:41.134]                 {
[17:39:41.134]                   {
[17:39:41.134]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.134]                     NULL
[17:39:41.134]                   }
[17:39:41.134]                   options(future.plan = NULL)
[17:39:41.134]                   if (is.na(NA_character_)) 
[17:39:41.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.134]                     .init = FALSE)
[17:39:41.134]                 }
[17:39:41.134]             }
[17:39:41.134]         }
[17:39:41.134]     })
[17:39:41.134]     if (TRUE) {
[17:39:41.134]         base::sink(type = "output", split = FALSE)
[17:39:41.134]         if (TRUE) {
[17:39:41.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.134]         }
[17:39:41.134]         else {
[17:39:41.134]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.134]         }
[17:39:41.134]         base::close(...future.stdout)
[17:39:41.134]         ...future.stdout <- NULL
[17:39:41.134]     }
[17:39:41.134]     ...future.result$conditions <- ...future.conditions
[17:39:41.134]     ...future.result$finished <- base::Sys.time()
[17:39:41.134]     ...future.result
[17:39:41.134] }
[17:39:41.137] requestCore(): workers = 2
[17:39:41.139] MulticoreFuture started
[17:39:41.140] - Launch lazy future ... done
[17:39:41.141] run() for ‘MulticoreFuture’ ... done
[17:39:41.141] result() for MulticoreFuture ...
[17:39:41.142] plan(): Setting new future strategy stack:
[17:39:41.142] List of future strategies:
[17:39:41.142] 1. sequential:
[17:39:41.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:41.142]    - tweaked: FALSE
[17:39:41.142]    - call: NULL
[17:39:41.143] plan(): nbrOfWorkers() = 1
[17:39:41.148] plan(): Setting new future strategy stack:
[17:39:41.148] List of future strategies:
[17:39:41.148] 1. multicore:
[17:39:41.148]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.148]    - tweaked: FALSE
[17:39:41.148]    - call: plan(strategy)
[17:39:41.154] plan(): nbrOfWorkers() = 2
[17:39:41.157] result() for MulticoreFuture ...
[17:39:41.157] result() for MulticoreFuture ... done
[17:39:41.157] result() for MulticoreFuture ... done
[17:39:41.157] result() for MulticoreFuture ...
[17:39:41.157] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:39:41.161] getGlobalsAndPackages() ...
[17:39:41.162] Searching for globals...
[17:39:41.164] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:39:41.164] Searching for globals ... DONE
[17:39:41.164] Resolving globals: FALSE
[17:39:41.165] 
[17:39:41.165] - packages: [2] ‘stats’, ‘datasets’
[17:39:41.165] getGlobalsAndPackages() ... DONE
[17:39:41.165] run() for ‘Future’ ...
[17:39:41.165] - state: ‘created’
[17:39:41.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:41.170]   - Field: ‘label’
[17:39:41.170]   - Field: ‘local’
[17:39:41.170]   - Field: ‘owner’
[17:39:41.170]   - Field: ‘envir’
[17:39:41.170]   - Field: ‘workers’
[17:39:41.170]   - Field: ‘packages’
[17:39:41.170]   - Field: ‘gc’
[17:39:41.171]   - Field: ‘job’
[17:39:41.171]   - Field: ‘conditions’
[17:39:41.171]   - Field: ‘expr’
[17:39:41.171]   - Field: ‘uuid’
[17:39:41.171]   - Field: ‘seed’
[17:39:41.171]   - Field: ‘version’
[17:39:41.171]   - Field: ‘result’
[17:39:41.171]   - Field: ‘asynchronous’
[17:39:41.171]   - Field: ‘calls’
[17:39:41.171]   - Field: ‘globals’
[17:39:41.172]   - Field: ‘stdout’
[17:39:41.172]   - Field: ‘earlySignal’
[17:39:41.172]   - Field: ‘lazy’
[17:39:41.172]   - Field: ‘state’
[17:39:41.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:41.172] - Launch lazy future ...
[17:39:41.172] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:41.173] Packages needed by future strategies (n = 0): <none>
[17:39:41.173] {
[17:39:41.173]     {
[17:39:41.173]         {
[17:39:41.173]             ...future.startTime <- base::Sys.time()
[17:39:41.173]             {
[17:39:41.173]                 {
[17:39:41.173]                   {
[17:39:41.173]                     {
[17:39:41.173]                       {
[17:39:41.173]                         base::local({
[17:39:41.173]                           has_future <- base::requireNamespace("future", 
[17:39:41.173]                             quietly = TRUE)
[17:39:41.173]                           if (has_future) {
[17:39:41.173]                             ns <- base::getNamespace("future")
[17:39:41.173]                             version <- ns[[".package"]][["version"]]
[17:39:41.173]                             if (is.null(version)) 
[17:39:41.173]                               version <- utils::packageVersion("future")
[17:39:41.173]                           }
[17:39:41.173]                           else {
[17:39:41.173]                             version <- NULL
[17:39:41.173]                           }
[17:39:41.173]                           if (!has_future || version < "1.8.0") {
[17:39:41.173]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.173]                               "", base::R.version$version.string), 
[17:39:41.173]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:41.173]                                 base::R.version$platform, 8 * 
[17:39:41.173]                                   base::.Machine$sizeof.pointer), 
[17:39:41.173]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.173]                                 "release", "version")], collapse = " "), 
[17:39:41.173]                               hostname = base::Sys.info()[["nodename"]])
[17:39:41.173]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.173]                               info)
[17:39:41.173]                             info <- base::paste(info, collapse = "; ")
[17:39:41.173]                             if (!has_future) {
[17:39:41.173]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.173]                                 info)
[17:39:41.173]                             }
[17:39:41.173]                             else {
[17:39:41.173]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.173]                                 info, version)
[17:39:41.173]                             }
[17:39:41.173]                             base::stop(msg)
[17:39:41.173]                           }
[17:39:41.173]                         })
[17:39:41.173]                       }
[17:39:41.173]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.173]                       base::options(mc.cores = 1L)
[17:39:41.173]                     }
[17:39:41.173]                     base::local({
[17:39:41.173]                       for (pkg in c("stats", "datasets")) {
[17:39:41.173]                         base::loadNamespace(pkg)
[17:39:41.173]                         base::library(pkg, character.only = TRUE)
[17:39:41.173]                       }
[17:39:41.173]                     })
[17:39:41.173]                   }
[17:39:41.173]                   ...future.strategy.old <- future::plan("list")
[17:39:41.173]                   options(future.plan = NULL)
[17:39:41.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.173]                 }
[17:39:41.173]                 ...future.workdir <- getwd()
[17:39:41.173]             }
[17:39:41.173]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.173]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.173]         }
[17:39:41.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.173]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.173]             base::names(...future.oldOptions))
[17:39:41.173]     }
[17:39:41.173]     if (FALSE) {
[17:39:41.173]     }
[17:39:41.173]     else {
[17:39:41.173]         if (TRUE) {
[17:39:41.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.173]                 open = "w")
[17:39:41.173]         }
[17:39:41.173]         else {
[17:39:41.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.173]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.173]         }
[17:39:41.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.173]             base::sink(type = "output", split = FALSE)
[17:39:41.173]             base::close(...future.stdout)
[17:39:41.173]         }, add = TRUE)
[17:39:41.173]     }
[17:39:41.173]     ...future.frame <- base::sys.nframe()
[17:39:41.173]     ...future.conditions <- base::list()
[17:39:41.173]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.173]     if (FALSE) {
[17:39:41.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.173]     }
[17:39:41.173]     ...future.result <- base::tryCatch({
[17:39:41.173]         base::withCallingHandlers({
[17:39:41.173]             ...future.value <- base::withVisible(base::local({
[17:39:41.173]                 withCallingHandlers({
[17:39:41.173]                   {
[17:39:41.173]                     lm(dist ~ poly(speed, 2), data = cars)
[17:39:41.173]                   }
[17:39:41.173]                 }, immediateCondition = function(cond) {
[17:39:41.173]                   save_rds <- function (object, pathname, ...) 
[17:39:41.173]                   {
[17:39:41.173]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:41.173]                     if (file_test("-f", pathname_tmp)) {
[17:39:41.173]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.173]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:41.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.173]                         fi_tmp[["mtime"]])
[17:39:41.173]                     }
[17:39:41.173]                     tryCatch({
[17:39:41.173]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:41.173]                     }, error = function(ex) {
[17:39:41.173]                       msg <- conditionMessage(ex)
[17:39:41.173]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.173]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:41.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.173]                         fi_tmp[["mtime"]], msg)
[17:39:41.173]                       ex$message <- msg
[17:39:41.173]                       stop(ex)
[17:39:41.173]                     })
[17:39:41.173]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:41.173]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:41.173]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:41.173]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.173]                       fi <- file.info(pathname)
[17:39:41.173]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:41.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.173]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:41.173]                         fi[["size"]], fi[["mtime"]])
[17:39:41.173]                       stop(msg)
[17:39:41.173]                     }
[17:39:41.173]                     invisible(pathname)
[17:39:41.173]                   }
[17:39:41.173]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:41.173]                     rootPath = tempdir()) 
[17:39:41.173]                   {
[17:39:41.173]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:41.173]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:41.173]                       tmpdir = path, fileext = ".rds")
[17:39:41.173]                     save_rds(obj, file)
[17:39:41.173]                   }
[17:39:41.173]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:41.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.173]                   {
[17:39:41.173]                     inherits <- base::inherits
[17:39:41.173]                     invokeRestart <- base::invokeRestart
[17:39:41.173]                     is.null <- base::is.null
[17:39:41.173]                     muffled <- FALSE
[17:39:41.173]                     if (inherits(cond, "message")) {
[17:39:41.173]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.173]                       if (muffled) 
[17:39:41.173]                         invokeRestart("muffleMessage")
[17:39:41.173]                     }
[17:39:41.173]                     else if (inherits(cond, "warning")) {
[17:39:41.173]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.173]                       if (muffled) 
[17:39:41.173]                         invokeRestart("muffleWarning")
[17:39:41.173]                     }
[17:39:41.173]                     else if (inherits(cond, "condition")) {
[17:39:41.173]                       if (!is.null(pattern)) {
[17:39:41.173]                         computeRestarts <- base::computeRestarts
[17:39:41.173]                         grepl <- base::grepl
[17:39:41.173]                         restarts <- computeRestarts(cond)
[17:39:41.173]                         for (restart in restarts) {
[17:39:41.173]                           name <- restart$name
[17:39:41.173]                           if (is.null(name)) 
[17:39:41.173]                             next
[17:39:41.173]                           if (!grepl(pattern, name)) 
[17:39:41.173]                             next
[17:39:41.173]                           invokeRestart(restart)
[17:39:41.173]                           muffled <- TRUE
[17:39:41.173]                           break
[17:39:41.173]                         }
[17:39:41.173]                       }
[17:39:41.173]                     }
[17:39:41.173]                     invisible(muffled)
[17:39:41.173]                   }
[17:39:41.173]                   muffleCondition(cond)
[17:39:41.173]                 })
[17:39:41.173]             }))
[17:39:41.173]             future::FutureResult(value = ...future.value$value, 
[17:39:41.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.173]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.173]                     ...future.globalenv.names))
[17:39:41.173]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.173]         }, condition = base::local({
[17:39:41.173]             c <- base::c
[17:39:41.173]             inherits <- base::inherits
[17:39:41.173]             invokeRestart <- base::invokeRestart
[17:39:41.173]             length <- base::length
[17:39:41.173]             list <- base::list
[17:39:41.173]             seq.int <- base::seq.int
[17:39:41.173]             signalCondition <- base::signalCondition
[17:39:41.173]             sys.calls <- base::sys.calls
[17:39:41.173]             `[[` <- base::`[[`
[17:39:41.173]             `+` <- base::`+`
[17:39:41.173]             `<<-` <- base::`<<-`
[17:39:41.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.173]                   3L)]
[17:39:41.173]             }
[17:39:41.173]             function(cond) {
[17:39:41.173]                 is_error <- inherits(cond, "error")
[17:39:41.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.173]                   NULL)
[17:39:41.173]                 if (is_error) {
[17:39:41.173]                   sessionInformation <- function() {
[17:39:41.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.173]                       search = base::search(), system = base::Sys.info())
[17:39:41.173]                   }
[17:39:41.173]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.173]                     cond$call), session = sessionInformation(), 
[17:39:41.173]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.173]                   signalCondition(cond)
[17:39:41.173]                 }
[17:39:41.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.173]                 "immediateCondition"))) {
[17:39:41.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.173]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.173]                   if (TRUE && !signal) {
[17:39:41.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.173]                     {
[17:39:41.173]                       inherits <- base::inherits
[17:39:41.173]                       invokeRestart <- base::invokeRestart
[17:39:41.173]                       is.null <- base::is.null
[17:39:41.173]                       muffled <- FALSE
[17:39:41.173]                       if (inherits(cond, "message")) {
[17:39:41.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.173]                         if (muffled) 
[17:39:41.173]                           invokeRestart("muffleMessage")
[17:39:41.173]                       }
[17:39:41.173]                       else if (inherits(cond, "warning")) {
[17:39:41.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.173]                         if (muffled) 
[17:39:41.173]                           invokeRestart("muffleWarning")
[17:39:41.173]                       }
[17:39:41.173]                       else if (inherits(cond, "condition")) {
[17:39:41.173]                         if (!is.null(pattern)) {
[17:39:41.173]                           computeRestarts <- base::computeRestarts
[17:39:41.173]                           grepl <- base::grepl
[17:39:41.173]                           restarts <- computeRestarts(cond)
[17:39:41.173]                           for (restart in restarts) {
[17:39:41.173]                             name <- restart$name
[17:39:41.173]                             if (is.null(name)) 
[17:39:41.173]                               next
[17:39:41.173]                             if (!grepl(pattern, name)) 
[17:39:41.173]                               next
[17:39:41.173]                             invokeRestart(restart)
[17:39:41.173]                             muffled <- TRUE
[17:39:41.173]                             break
[17:39:41.173]                           }
[17:39:41.173]                         }
[17:39:41.173]                       }
[17:39:41.173]                       invisible(muffled)
[17:39:41.173]                     }
[17:39:41.173]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.173]                   }
[17:39:41.173]                 }
[17:39:41.173]                 else {
[17:39:41.173]                   if (TRUE) {
[17:39:41.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.173]                     {
[17:39:41.173]                       inherits <- base::inherits
[17:39:41.173]                       invokeRestart <- base::invokeRestart
[17:39:41.173]                       is.null <- base::is.null
[17:39:41.173]                       muffled <- FALSE
[17:39:41.173]                       if (inherits(cond, "message")) {
[17:39:41.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.173]                         if (muffled) 
[17:39:41.173]                           invokeRestart("muffleMessage")
[17:39:41.173]                       }
[17:39:41.173]                       else if (inherits(cond, "warning")) {
[17:39:41.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.173]                         if (muffled) 
[17:39:41.173]                           invokeRestart("muffleWarning")
[17:39:41.173]                       }
[17:39:41.173]                       else if (inherits(cond, "condition")) {
[17:39:41.173]                         if (!is.null(pattern)) {
[17:39:41.173]                           computeRestarts <- base::computeRestarts
[17:39:41.173]                           grepl <- base::grepl
[17:39:41.173]                           restarts <- computeRestarts(cond)
[17:39:41.173]                           for (restart in restarts) {
[17:39:41.173]                             name <- restart$name
[17:39:41.173]                             if (is.null(name)) 
[17:39:41.173]                               next
[17:39:41.173]                             if (!grepl(pattern, name)) 
[17:39:41.173]                               next
[17:39:41.173]                             invokeRestart(restart)
[17:39:41.173]                             muffled <- TRUE
[17:39:41.173]                             break
[17:39:41.173]                           }
[17:39:41.173]                         }
[17:39:41.173]                       }
[17:39:41.173]                       invisible(muffled)
[17:39:41.173]                     }
[17:39:41.173]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.173]                   }
[17:39:41.173]                 }
[17:39:41.173]             }
[17:39:41.173]         }))
[17:39:41.173]     }, error = function(ex) {
[17:39:41.173]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.173]                 ...future.rng), started = ...future.startTime, 
[17:39:41.173]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.173]             version = "1.8"), class = "FutureResult")
[17:39:41.173]     }, finally = {
[17:39:41.173]         if (!identical(...future.workdir, getwd())) 
[17:39:41.173]             setwd(...future.workdir)
[17:39:41.173]         {
[17:39:41.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.173]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.173]             }
[17:39:41.173]             base::options(...future.oldOptions)
[17:39:41.173]             if (.Platform$OS.type == "windows") {
[17:39:41.173]                 old_names <- names(...future.oldEnvVars)
[17:39:41.173]                 envs <- base::Sys.getenv()
[17:39:41.173]                 names <- names(envs)
[17:39:41.173]                 common <- intersect(names, old_names)
[17:39:41.173]                 added <- setdiff(names, old_names)
[17:39:41.173]                 removed <- setdiff(old_names, names)
[17:39:41.173]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.173]                   envs[common]]
[17:39:41.173]                 NAMES <- toupper(changed)
[17:39:41.173]                 args <- list()
[17:39:41.173]                 for (kk in seq_along(NAMES)) {
[17:39:41.173]                   name <- changed[[kk]]
[17:39:41.173]                   NAME <- NAMES[[kk]]
[17:39:41.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.173]                     next
[17:39:41.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.173]                 }
[17:39:41.173]                 NAMES <- toupper(added)
[17:39:41.173]                 for (kk in seq_along(NAMES)) {
[17:39:41.173]                   name <- added[[kk]]
[17:39:41.173]                   NAME <- NAMES[[kk]]
[17:39:41.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.173]                     next
[17:39:41.173]                   args[[name]] <- ""
[17:39:41.173]                 }
[17:39:41.173]                 NAMES <- toupper(removed)
[17:39:41.173]                 for (kk in seq_along(NAMES)) {
[17:39:41.173]                   name <- removed[[kk]]
[17:39:41.173]                   NAME <- NAMES[[kk]]
[17:39:41.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.173]                     next
[17:39:41.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.173]                 }
[17:39:41.173]                 if (length(args) > 0) 
[17:39:41.173]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.173]             }
[17:39:41.173]             else {
[17:39:41.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.173]             }
[17:39:41.173]             {
[17:39:41.173]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.173]                   0L) {
[17:39:41.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.173]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.173]                   base::options(opts)
[17:39:41.173]                 }
[17:39:41.173]                 {
[17:39:41.173]                   {
[17:39:41.173]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.173]                     NULL
[17:39:41.173]                   }
[17:39:41.173]                   options(future.plan = NULL)
[17:39:41.173]                   if (is.na(NA_character_)) 
[17:39:41.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.173]                     .init = FALSE)
[17:39:41.173]                 }
[17:39:41.173]             }
[17:39:41.173]         }
[17:39:41.173]     })
[17:39:41.173]     if (TRUE) {
[17:39:41.173]         base::sink(type = "output", split = FALSE)
[17:39:41.173]         if (TRUE) {
[17:39:41.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.173]         }
[17:39:41.173]         else {
[17:39:41.173]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.173]         }
[17:39:41.173]         base::close(...future.stdout)
[17:39:41.173]         ...future.stdout <- NULL
[17:39:41.173]     }
[17:39:41.173]     ...future.result$conditions <- ...future.conditions
[17:39:41.173]     ...future.result$finished <- base::Sys.time()
[17:39:41.173]     ...future.result
[17:39:41.173] }
[17:39:41.176] requestCore(): workers = 2
[17:39:41.178] MulticoreFuture started
[17:39:41.178] - Launch lazy future ... done
[17:39:41.178] run() for ‘MulticoreFuture’ ... done
[17:39:41.179] result() for MulticoreFuture ...
[17:39:41.179] plan(): Setting new future strategy stack:
[17:39:41.180] List of future strategies:
[17:39:41.180] 1. sequential:
[17:39:41.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:41.180]    - tweaked: FALSE
[17:39:41.180]    - call: NULL
[17:39:41.181] plan(): nbrOfWorkers() = 1
[17:39:41.185] plan(): Setting new future strategy stack:
[17:39:41.185] List of future strategies:
[17:39:41.185] 1. multicore:
[17:39:41.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.185]    - tweaked: FALSE
[17:39:41.185]    - call: plan(strategy)
[17:39:41.190] plan(): nbrOfWorkers() = 2
[17:39:41.193] result() for MulticoreFuture ...
[17:39:41.193] result() for MulticoreFuture ... done
[17:39:41.193] result() for MulticoreFuture ... done
[17:39:41.193] result() for MulticoreFuture ...
[17:39:41.193] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:39:41.196] getGlobalsAndPackages() ...
[17:39:41.197] Searching for globals...
[17:39:41.202] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:39:41.202] Searching for globals ... DONE
[17:39:41.202] Resolving globals: FALSE
[17:39:41.206] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:39:41.206] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:39:41.207] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:39:41.207] 
[17:39:41.207] getGlobalsAndPackages() ... DONE
[17:39:41.207] run() for ‘Future’ ...
[17:39:41.208] - state: ‘created’
[17:39:41.208] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.212] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.212] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:41.212]   - Field: ‘label’
[17:39:41.212]   - Field: ‘local’
[17:39:41.213]   - Field: ‘owner’
[17:39:41.213]   - Field: ‘envir’
[17:39:41.213]   - Field: ‘workers’
[17:39:41.213]   - Field: ‘packages’
[17:39:41.213]   - Field: ‘gc’
[17:39:41.213]   - Field: ‘job’
[17:39:41.213]   - Field: ‘conditions’
[17:39:41.213]   - Field: ‘expr’
[17:39:41.213]   - Field: ‘uuid’
[17:39:41.214]   - Field: ‘seed’
[17:39:41.214]   - Field: ‘version’
[17:39:41.214]   - Field: ‘result’
[17:39:41.214]   - Field: ‘asynchronous’
[17:39:41.214]   - Field: ‘calls’
[17:39:41.214]   - Field: ‘globals’
[17:39:41.214]   - Field: ‘stdout’
[17:39:41.214]   - Field: ‘earlySignal’
[17:39:41.214]   - Field: ‘lazy’
[17:39:41.215]   - Field: ‘state’
[17:39:41.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:41.215] - Launch lazy future ...
[17:39:41.215] Packages needed by the future expression (n = 0): <none>
[17:39:41.215] Packages needed by future strategies (n = 0): <none>
[17:39:41.216] {
[17:39:41.216]     {
[17:39:41.216]         {
[17:39:41.216]             ...future.startTime <- base::Sys.time()
[17:39:41.216]             {
[17:39:41.216]                 {
[17:39:41.216]                   {
[17:39:41.216]                     {
[17:39:41.216]                       base::local({
[17:39:41.216]                         has_future <- base::requireNamespace("future", 
[17:39:41.216]                           quietly = TRUE)
[17:39:41.216]                         if (has_future) {
[17:39:41.216]                           ns <- base::getNamespace("future")
[17:39:41.216]                           version <- ns[[".package"]][["version"]]
[17:39:41.216]                           if (is.null(version)) 
[17:39:41.216]                             version <- utils::packageVersion("future")
[17:39:41.216]                         }
[17:39:41.216]                         else {
[17:39:41.216]                           version <- NULL
[17:39:41.216]                         }
[17:39:41.216]                         if (!has_future || version < "1.8.0") {
[17:39:41.216]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.216]                             "", base::R.version$version.string), 
[17:39:41.216]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:41.216]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:41.216]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.216]                               "release", "version")], collapse = " "), 
[17:39:41.216]                             hostname = base::Sys.info()[["nodename"]])
[17:39:41.216]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.216]                             info)
[17:39:41.216]                           info <- base::paste(info, collapse = "; ")
[17:39:41.216]                           if (!has_future) {
[17:39:41.216]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.216]                               info)
[17:39:41.216]                           }
[17:39:41.216]                           else {
[17:39:41.216]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.216]                               info, version)
[17:39:41.216]                           }
[17:39:41.216]                           base::stop(msg)
[17:39:41.216]                         }
[17:39:41.216]                       })
[17:39:41.216]                     }
[17:39:41.216]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.216]                     base::options(mc.cores = 1L)
[17:39:41.216]                   }
[17:39:41.216]                   ...future.strategy.old <- future::plan("list")
[17:39:41.216]                   options(future.plan = NULL)
[17:39:41.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.216]                 }
[17:39:41.216]                 ...future.workdir <- getwd()
[17:39:41.216]             }
[17:39:41.216]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.216]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.216]         }
[17:39:41.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.216]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.216]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.216]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.216]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.216]             base::names(...future.oldOptions))
[17:39:41.216]     }
[17:39:41.216]     if (FALSE) {
[17:39:41.216]     }
[17:39:41.216]     else {
[17:39:41.216]         if (TRUE) {
[17:39:41.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.216]                 open = "w")
[17:39:41.216]         }
[17:39:41.216]         else {
[17:39:41.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.216]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.216]         }
[17:39:41.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.216]             base::sink(type = "output", split = FALSE)
[17:39:41.216]             base::close(...future.stdout)
[17:39:41.216]         }, add = TRUE)
[17:39:41.216]     }
[17:39:41.216]     ...future.frame <- base::sys.nframe()
[17:39:41.216]     ...future.conditions <- base::list()
[17:39:41.216]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.216]     if (FALSE) {
[17:39:41.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.216]     }
[17:39:41.216]     ...future.result <- base::tryCatch({
[17:39:41.216]         base::withCallingHandlers({
[17:39:41.216]             ...future.value <- base::withVisible(base::local({
[17:39:41.216]                 withCallingHandlers({
[17:39:41.216]                   {
[17:39:41.216]                     outer_function(1L)
[17:39:41.216]                   }
[17:39:41.216]                 }, immediateCondition = function(cond) {
[17:39:41.216]                   save_rds <- function (object, pathname, ...) 
[17:39:41.216]                   {
[17:39:41.216]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:41.216]                     if (file_test("-f", pathname_tmp)) {
[17:39:41.216]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.216]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:41.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.216]                         fi_tmp[["mtime"]])
[17:39:41.216]                     }
[17:39:41.216]                     tryCatch({
[17:39:41.216]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:41.216]                     }, error = function(ex) {
[17:39:41.216]                       msg <- conditionMessage(ex)
[17:39:41.216]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.216]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:41.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.216]                         fi_tmp[["mtime"]], msg)
[17:39:41.216]                       ex$message <- msg
[17:39:41.216]                       stop(ex)
[17:39:41.216]                     })
[17:39:41.216]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:41.216]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:41.216]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:41.216]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.216]                       fi <- file.info(pathname)
[17:39:41.216]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:41.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.216]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:41.216]                         fi[["size"]], fi[["mtime"]])
[17:39:41.216]                       stop(msg)
[17:39:41.216]                     }
[17:39:41.216]                     invisible(pathname)
[17:39:41.216]                   }
[17:39:41.216]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:41.216]                     rootPath = tempdir()) 
[17:39:41.216]                   {
[17:39:41.216]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:41.216]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:41.216]                       tmpdir = path, fileext = ".rds")
[17:39:41.216]                     save_rds(obj, file)
[17:39:41.216]                   }
[17:39:41.216]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:41.216]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.216]                   {
[17:39:41.216]                     inherits <- base::inherits
[17:39:41.216]                     invokeRestart <- base::invokeRestart
[17:39:41.216]                     is.null <- base::is.null
[17:39:41.216]                     muffled <- FALSE
[17:39:41.216]                     if (inherits(cond, "message")) {
[17:39:41.216]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.216]                       if (muffled) 
[17:39:41.216]                         invokeRestart("muffleMessage")
[17:39:41.216]                     }
[17:39:41.216]                     else if (inherits(cond, "warning")) {
[17:39:41.216]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.216]                       if (muffled) 
[17:39:41.216]                         invokeRestart("muffleWarning")
[17:39:41.216]                     }
[17:39:41.216]                     else if (inherits(cond, "condition")) {
[17:39:41.216]                       if (!is.null(pattern)) {
[17:39:41.216]                         computeRestarts <- base::computeRestarts
[17:39:41.216]                         grepl <- base::grepl
[17:39:41.216]                         restarts <- computeRestarts(cond)
[17:39:41.216]                         for (restart in restarts) {
[17:39:41.216]                           name <- restart$name
[17:39:41.216]                           if (is.null(name)) 
[17:39:41.216]                             next
[17:39:41.216]                           if (!grepl(pattern, name)) 
[17:39:41.216]                             next
[17:39:41.216]                           invokeRestart(restart)
[17:39:41.216]                           muffled <- TRUE
[17:39:41.216]                           break
[17:39:41.216]                         }
[17:39:41.216]                       }
[17:39:41.216]                     }
[17:39:41.216]                     invisible(muffled)
[17:39:41.216]                   }
[17:39:41.216]                   muffleCondition(cond)
[17:39:41.216]                 })
[17:39:41.216]             }))
[17:39:41.216]             future::FutureResult(value = ...future.value$value, 
[17:39:41.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.216]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.216]                     ...future.globalenv.names))
[17:39:41.216]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.216]         }, condition = base::local({
[17:39:41.216]             c <- base::c
[17:39:41.216]             inherits <- base::inherits
[17:39:41.216]             invokeRestart <- base::invokeRestart
[17:39:41.216]             length <- base::length
[17:39:41.216]             list <- base::list
[17:39:41.216]             seq.int <- base::seq.int
[17:39:41.216]             signalCondition <- base::signalCondition
[17:39:41.216]             sys.calls <- base::sys.calls
[17:39:41.216]             `[[` <- base::`[[`
[17:39:41.216]             `+` <- base::`+`
[17:39:41.216]             `<<-` <- base::`<<-`
[17:39:41.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.216]                   3L)]
[17:39:41.216]             }
[17:39:41.216]             function(cond) {
[17:39:41.216]                 is_error <- inherits(cond, "error")
[17:39:41.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.216]                   NULL)
[17:39:41.216]                 if (is_error) {
[17:39:41.216]                   sessionInformation <- function() {
[17:39:41.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.216]                       search = base::search(), system = base::Sys.info())
[17:39:41.216]                   }
[17:39:41.216]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.216]                     cond$call), session = sessionInformation(), 
[17:39:41.216]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.216]                   signalCondition(cond)
[17:39:41.216]                 }
[17:39:41.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.216]                 "immediateCondition"))) {
[17:39:41.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.216]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.216]                   if (TRUE && !signal) {
[17:39:41.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.216]                     {
[17:39:41.216]                       inherits <- base::inherits
[17:39:41.216]                       invokeRestart <- base::invokeRestart
[17:39:41.216]                       is.null <- base::is.null
[17:39:41.216]                       muffled <- FALSE
[17:39:41.216]                       if (inherits(cond, "message")) {
[17:39:41.216]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.216]                         if (muffled) 
[17:39:41.216]                           invokeRestart("muffleMessage")
[17:39:41.216]                       }
[17:39:41.216]                       else if (inherits(cond, "warning")) {
[17:39:41.216]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.216]                         if (muffled) 
[17:39:41.216]                           invokeRestart("muffleWarning")
[17:39:41.216]                       }
[17:39:41.216]                       else if (inherits(cond, "condition")) {
[17:39:41.216]                         if (!is.null(pattern)) {
[17:39:41.216]                           computeRestarts <- base::computeRestarts
[17:39:41.216]                           grepl <- base::grepl
[17:39:41.216]                           restarts <- computeRestarts(cond)
[17:39:41.216]                           for (restart in restarts) {
[17:39:41.216]                             name <- restart$name
[17:39:41.216]                             if (is.null(name)) 
[17:39:41.216]                               next
[17:39:41.216]                             if (!grepl(pattern, name)) 
[17:39:41.216]                               next
[17:39:41.216]                             invokeRestart(restart)
[17:39:41.216]                             muffled <- TRUE
[17:39:41.216]                             break
[17:39:41.216]                           }
[17:39:41.216]                         }
[17:39:41.216]                       }
[17:39:41.216]                       invisible(muffled)
[17:39:41.216]                     }
[17:39:41.216]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.216]                   }
[17:39:41.216]                 }
[17:39:41.216]                 else {
[17:39:41.216]                   if (TRUE) {
[17:39:41.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.216]                     {
[17:39:41.216]                       inherits <- base::inherits
[17:39:41.216]                       invokeRestart <- base::invokeRestart
[17:39:41.216]                       is.null <- base::is.null
[17:39:41.216]                       muffled <- FALSE
[17:39:41.216]                       if (inherits(cond, "message")) {
[17:39:41.216]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.216]                         if (muffled) 
[17:39:41.216]                           invokeRestart("muffleMessage")
[17:39:41.216]                       }
[17:39:41.216]                       else if (inherits(cond, "warning")) {
[17:39:41.216]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.216]                         if (muffled) 
[17:39:41.216]                           invokeRestart("muffleWarning")
[17:39:41.216]                       }
[17:39:41.216]                       else if (inherits(cond, "condition")) {
[17:39:41.216]                         if (!is.null(pattern)) {
[17:39:41.216]                           computeRestarts <- base::computeRestarts
[17:39:41.216]                           grepl <- base::grepl
[17:39:41.216]                           restarts <- computeRestarts(cond)
[17:39:41.216]                           for (restart in restarts) {
[17:39:41.216]                             name <- restart$name
[17:39:41.216]                             if (is.null(name)) 
[17:39:41.216]                               next
[17:39:41.216]                             if (!grepl(pattern, name)) 
[17:39:41.216]                               next
[17:39:41.216]                             invokeRestart(restart)
[17:39:41.216]                             muffled <- TRUE
[17:39:41.216]                             break
[17:39:41.216]                           }
[17:39:41.216]                         }
[17:39:41.216]                       }
[17:39:41.216]                       invisible(muffled)
[17:39:41.216]                     }
[17:39:41.216]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.216]                   }
[17:39:41.216]                 }
[17:39:41.216]             }
[17:39:41.216]         }))
[17:39:41.216]     }, error = function(ex) {
[17:39:41.216]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.216]                 ...future.rng), started = ...future.startTime, 
[17:39:41.216]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.216]             version = "1.8"), class = "FutureResult")
[17:39:41.216]     }, finally = {
[17:39:41.216]         if (!identical(...future.workdir, getwd())) 
[17:39:41.216]             setwd(...future.workdir)
[17:39:41.216]         {
[17:39:41.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.216]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.216]             }
[17:39:41.216]             base::options(...future.oldOptions)
[17:39:41.216]             if (.Platform$OS.type == "windows") {
[17:39:41.216]                 old_names <- names(...future.oldEnvVars)
[17:39:41.216]                 envs <- base::Sys.getenv()
[17:39:41.216]                 names <- names(envs)
[17:39:41.216]                 common <- intersect(names, old_names)
[17:39:41.216]                 added <- setdiff(names, old_names)
[17:39:41.216]                 removed <- setdiff(old_names, names)
[17:39:41.216]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.216]                   envs[common]]
[17:39:41.216]                 NAMES <- toupper(changed)
[17:39:41.216]                 args <- list()
[17:39:41.216]                 for (kk in seq_along(NAMES)) {
[17:39:41.216]                   name <- changed[[kk]]
[17:39:41.216]                   NAME <- NAMES[[kk]]
[17:39:41.216]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.216]                     next
[17:39:41.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.216]                 }
[17:39:41.216]                 NAMES <- toupper(added)
[17:39:41.216]                 for (kk in seq_along(NAMES)) {
[17:39:41.216]                   name <- added[[kk]]
[17:39:41.216]                   NAME <- NAMES[[kk]]
[17:39:41.216]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.216]                     next
[17:39:41.216]                   args[[name]] <- ""
[17:39:41.216]                 }
[17:39:41.216]                 NAMES <- toupper(removed)
[17:39:41.216]                 for (kk in seq_along(NAMES)) {
[17:39:41.216]                   name <- removed[[kk]]
[17:39:41.216]                   NAME <- NAMES[[kk]]
[17:39:41.216]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.216]                     next
[17:39:41.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.216]                 }
[17:39:41.216]                 if (length(args) > 0) 
[17:39:41.216]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.216]             }
[17:39:41.216]             else {
[17:39:41.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.216]             }
[17:39:41.216]             {
[17:39:41.216]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.216]                   0L) {
[17:39:41.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.216]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.216]                   base::options(opts)
[17:39:41.216]                 }
[17:39:41.216]                 {
[17:39:41.216]                   {
[17:39:41.216]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.216]                     NULL
[17:39:41.216]                   }
[17:39:41.216]                   options(future.plan = NULL)
[17:39:41.216]                   if (is.na(NA_character_)) 
[17:39:41.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.216]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.216]                     .init = FALSE)
[17:39:41.216]                 }
[17:39:41.216]             }
[17:39:41.216]         }
[17:39:41.216]     })
[17:39:41.216]     if (TRUE) {
[17:39:41.216]         base::sink(type = "output", split = FALSE)
[17:39:41.216]         if (TRUE) {
[17:39:41.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.216]         }
[17:39:41.216]         else {
[17:39:41.216]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.216]         }
[17:39:41.216]         base::close(...future.stdout)
[17:39:41.216]         ...future.stdout <- NULL
[17:39:41.216]     }
[17:39:41.216]     ...future.result$conditions <- ...future.conditions
[17:39:41.216]     ...future.result$finished <- base::Sys.time()
[17:39:41.216]     ...future.result
[17:39:41.216] }
[17:39:41.218] assign_globals() ...
[17:39:41.218] List of 3
[17:39:41.218]  $ outer_function:function (x)  
[17:39:41.218]  $ map           :function (.x, .f, ...)  
[17:39:41.218]  $ inner_function:function (x)  
[17:39:41.218]  - attr(*, "where")=List of 3
[17:39:41.218]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:39:41.218]   ..$ map           :<environment: R_EmptyEnv> 
[17:39:41.218]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:39:41.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:41.218]  - attr(*, "resolved")= logi FALSE
[17:39:41.218]  - attr(*, "total_size")= num 7704
[17:39:41.218]  - attr(*, "already-done")= logi TRUE
[17:39:41.222] - reassign environment for ‘outer_function’
[17:39:41.222] - copied ‘outer_function’ to environment
[17:39:41.222] - reassign environment for ‘map’
[17:39:41.222] - copied ‘map’ to environment
[17:39:41.222] - reassign environment for ‘inner_function’
[17:39:41.222] - copied ‘inner_function’ to environment
[17:39:41.222] assign_globals() ... done
[17:39:41.223] requestCore(): workers = 2
[17:39:41.225] MulticoreFuture started
[17:39:41.225] - Launch lazy future ... done
[17:39:41.225] run() for ‘MulticoreFuture’ ... done
[17:39:41.226] result() for MulticoreFuture ...
[17:39:41.226] plan(): Setting new future strategy stack:
[17:39:41.226] List of future strategies:
[17:39:41.226] 1. sequential:
[17:39:41.226]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:41.226]    - tweaked: FALSE
[17:39:41.226]    - call: NULL
[17:39:41.227] plan(): nbrOfWorkers() = 1
[17:39:41.230] plan(): Setting new future strategy stack:
[17:39:41.230] List of future strategies:
[17:39:41.230] 1. multicore:
[17:39:41.230]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.230]    - tweaked: FALSE
[17:39:41.230]    - call: plan(strategy)
[17:39:41.235] plan(): nbrOfWorkers() = 2
[17:39:41.236] result() for MulticoreFuture ...
[17:39:41.236] result() for MulticoreFuture ... done
[17:39:41.236] result() for MulticoreFuture ... done
[17:39:41.236] result() for MulticoreFuture ...
[17:39:41.237] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:39:41.239] getGlobalsAndPackages() ...
[17:39:41.239] Searching for globals...
[17:39:41.244] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:39:41.245] Searching for globals ... DONE
[17:39:41.245] Resolving globals: FALSE
[17:39:41.246] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:39:41.246] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:39:41.246] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:39:41.246] 
[17:39:41.247] getGlobalsAndPackages() ... DONE
[17:39:41.247] run() for ‘Future’ ...
[17:39:41.247] - state: ‘created’
[17:39:41.247] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.251] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:41.251]   - Field: ‘label’
[17:39:41.252]   - Field: ‘local’
[17:39:41.252]   - Field: ‘owner’
[17:39:41.252]   - Field: ‘envir’
[17:39:41.252]   - Field: ‘workers’
[17:39:41.252]   - Field: ‘packages’
[17:39:41.252]   - Field: ‘gc’
[17:39:41.252]   - Field: ‘job’
[17:39:41.252]   - Field: ‘conditions’
[17:39:41.253]   - Field: ‘expr’
[17:39:41.253]   - Field: ‘uuid’
[17:39:41.253]   - Field: ‘seed’
[17:39:41.253]   - Field: ‘version’
[17:39:41.253]   - Field: ‘result’
[17:39:41.255]   - Field: ‘asynchronous’
[17:39:41.255]   - Field: ‘calls’
[17:39:41.255]   - Field: ‘globals’
[17:39:41.255]   - Field: ‘stdout’
[17:39:41.256]   - Field: ‘earlySignal’
[17:39:41.256]   - Field: ‘lazy’
[17:39:41.256]   - Field: ‘state’
[17:39:41.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:41.256] - Launch lazy future ...
[17:39:41.257] Packages needed by the future expression (n = 0): <none>
[17:39:41.257] Packages needed by future strategies (n = 0): <none>
[17:39:41.257] {
[17:39:41.257]     {
[17:39:41.257]         {
[17:39:41.257]             ...future.startTime <- base::Sys.time()
[17:39:41.257]             {
[17:39:41.257]                 {
[17:39:41.257]                   {
[17:39:41.257]                     {
[17:39:41.257]                       base::local({
[17:39:41.257]                         has_future <- base::requireNamespace("future", 
[17:39:41.257]                           quietly = TRUE)
[17:39:41.257]                         if (has_future) {
[17:39:41.257]                           ns <- base::getNamespace("future")
[17:39:41.257]                           version <- ns[[".package"]][["version"]]
[17:39:41.257]                           if (is.null(version)) 
[17:39:41.257]                             version <- utils::packageVersion("future")
[17:39:41.257]                         }
[17:39:41.257]                         else {
[17:39:41.257]                           version <- NULL
[17:39:41.257]                         }
[17:39:41.257]                         if (!has_future || version < "1.8.0") {
[17:39:41.257]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.257]                             "", base::R.version$version.string), 
[17:39:41.257]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:41.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:41.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.257]                               "release", "version")], collapse = " "), 
[17:39:41.257]                             hostname = base::Sys.info()[["nodename"]])
[17:39:41.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.257]                             info)
[17:39:41.257]                           info <- base::paste(info, collapse = "; ")
[17:39:41.257]                           if (!has_future) {
[17:39:41.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.257]                               info)
[17:39:41.257]                           }
[17:39:41.257]                           else {
[17:39:41.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.257]                               info, version)
[17:39:41.257]                           }
[17:39:41.257]                           base::stop(msg)
[17:39:41.257]                         }
[17:39:41.257]                       })
[17:39:41.257]                     }
[17:39:41.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.257]                     base::options(mc.cores = 1L)
[17:39:41.257]                   }
[17:39:41.257]                   ...future.strategy.old <- future::plan("list")
[17:39:41.257]                   options(future.plan = NULL)
[17:39:41.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.257]                 }
[17:39:41.257]                 ...future.workdir <- getwd()
[17:39:41.257]             }
[17:39:41.257]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.257]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.257]         }
[17:39:41.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.257]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.257]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.257]             base::names(...future.oldOptions))
[17:39:41.257]     }
[17:39:41.257]     if (FALSE) {
[17:39:41.257]     }
[17:39:41.257]     else {
[17:39:41.257]         if (TRUE) {
[17:39:41.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.257]                 open = "w")
[17:39:41.257]         }
[17:39:41.257]         else {
[17:39:41.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.257]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.257]         }
[17:39:41.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.257]             base::sink(type = "output", split = FALSE)
[17:39:41.257]             base::close(...future.stdout)
[17:39:41.257]         }, add = TRUE)
[17:39:41.257]     }
[17:39:41.257]     ...future.frame <- base::sys.nframe()
[17:39:41.257]     ...future.conditions <- base::list()
[17:39:41.257]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.257]     if (FALSE) {
[17:39:41.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.257]     }
[17:39:41.257]     ...future.result <- base::tryCatch({
[17:39:41.257]         base::withCallingHandlers({
[17:39:41.257]             ...future.value <- base::withVisible(base::local({
[17:39:41.257]                 withCallingHandlers({
[17:39:41.257]                   {
[17:39:41.257]                     outer_function(1L)
[17:39:41.257]                   }
[17:39:41.257]                 }, immediateCondition = function(cond) {
[17:39:41.257]                   save_rds <- function (object, pathname, ...) 
[17:39:41.257]                   {
[17:39:41.257]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:41.257]                     if (file_test("-f", pathname_tmp)) {
[17:39:41.257]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.257]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:41.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.257]                         fi_tmp[["mtime"]])
[17:39:41.257]                     }
[17:39:41.257]                     tryCatch({
[17:39:41.257]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:41.257]                     }, error = function(ex) {
[17:39:41.257]                       msg <- conditionMessage(ex)
[17:39:41.257]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.257]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:41.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.257]                         fi_tmp[["mtime"]], msg)
[17:39:41.257]                       ex$message <- msg
[17:39:41.257]                       stop(ex)
[17:39:41.257]                     })
[17:39:41.257]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:41.257]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:41.257]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:41.257]                       fi_tmp <- file.info(pathname_tmp)
[17:39:41.257]                       fi <- file.info(pathname)
[17:39:41.257]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:41.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:41.257]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:41.257]                         fi[["size"]], fi[["mtime"]])
[17:39:41.257]                       stop(msg)
[17:39:41.257]                     }
[17:39:41.257]                     invisible(pathname)
[17:39:41.257]                   }
[17:39:41.257]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:41.257]                     rootPath = tempdir()) 
[17:39:41.257]                   {
[17:39:41.257]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:41.257]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:41.257]                       tmpdir = path, fileext = ".rds")
[17:39:41.257]                     save_rds(obj, file)
[17:39:41.257]                   }
[17:39:41.257]                   saveImmediateCondition(cond, path = "/tmp/RtmpHGd410/.future/immediateConditions")
[17:39:41.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.257]                   {
[17:39:41.257]                     inherits <- base::inherits
[17:39:41.257]                     invokeRestart <- base::invokeRestart
[17:39:41.257]                     is.null <- base::is.null
[17:39:41.257]                     muffled <- FALSE
[17:39:41.257]                     if (inherits(cond, "message")) {
[17:39:41.257]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.257]                       if (muffled) 
[17:39:41.257]                         invokeRestart("muffleMessage")
[17:39:41.257]                     }
[17:39:41.257]                     else if (inherits(cond, "warning")) {
[17:39:41.257]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.257]                       if (muffled) 
[17:39:41.257]                         invokeRestart("muffleWarning")
[17:39:41.257]                     }
[17:39:41.257]                     else if (inherits(cond, "condition")) {
[17:39:41.257]                       if (!is.null(pattern)) {
[17:39:41.257]                         computeRestarts <- base::computeRestarts
[17:39:41.257]                         grepl <- base::grepl
[17:39:41.257]                         restarts <- computeRestarts(cond)
[17:39:41.257]                         for (restart in restarts) {
[17:39:41.257]                           name <- restart$name
[17:39:41.257]                           if (is.null(name)) 
[17:39:41.257]                             next
[17:39:41.257]                           if (!grepl(pattern, name)) 
[17:39:41.257]                             next
[17:39:41.257]                           invokeRestart(restart)
[17:39:41.257]                           muffled <- TRUE
[17:39:41.257]                           break
[17:39:41.257]                         }
[17:39:41.257]                       }
[17:39:41.257]                     }
[17:39:41.257]                     invisible(muffled)
[17:39:41.257]                   }
[17:39:41.257]                   muffleCondition(cond)
[17:39:41.257]                 })
[17:39:41.257]             }))
[17:39:41.257]             future::FutureResult(value = ...future.value$value, 
[17:39:41.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.257]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.257]                     ...future.globalenv.names))
[17:39:41.257]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.257]         }, condition = base::local({
[17:39:41.257]             c <- base::c
[17:39:41.257]             inherits <- base::inherits
[17:39:41.257]             invokeRestart <- base::invokeRestart
[17:39:41.257]             length <- base::length
[17:39:41.257]             list <- base::list
[17:39:41.257]             seq.int <- base::seq.int
[17:39:41.257]             signalCondition <- base::signalCondition
[17:39:41.257]             sys.calls <- base::sys.calls
[17:39:41.257]             `[[` <- base::`[[`
[17:39:41.257]             `+` <- base::`+`
[17:39:41.257]             `<<-` <- base::`<<-`
[17:39:41.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.257]                   3L)]
[17:39:41.257]             }
[17:39:41.257]             function(cond) {
[17:39:41.257]                 is_error <- inherits(cond, "error")
[17:39:41.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.257]                   NULL)
[17:39:41.257]                 if (is_error) {
[17:39:41.257]                   sessionInformation <- function() {
[17:39:41.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.257]                       search = base::search(), system = base::Sys.info())
[17:39:41.257]                   }
[17:39:41.257]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.257]                     cond$call), session = sessionInformation(), 
[17:39:41.257]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.257]                   signalCondition(cond)
[17:39:41.257]                 }
[17:39:41.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.257]                 "immediateCondition"))) {
[17:39:41.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.257]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.257]                   if (TRUE && !signal) {
[17:39:41.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.257]                     {
[17:39:41.257]                       inherits <- base::inherits
[17:39:41.257]                       invokeRestart <- base::invokeRestart
[17:39:41.257]                       is.null <- base::is.null
[17:39:41.257]                       muffled <- FALSE
[17:39:41.257]                       if (inherits(cond, "message")) {
[17:39:41.257]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.257]                         if (muffled) 
[17:39:41.257]                           invokeRestart("muffleMessage")
[17:39:41.257]                       }
[17:39:41.257]                       else if (inherits(cond, "warning")) {
[17:39:41.257]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.257]                         if (muffled) 
[17:39:41.257]                           invokeRestart("muffleWarning")
[17:39:41.257]                       }
[17:39:41.257]                       else if (inherits(cond, "condition")) {
[17:39:41.257]                         if (!is.null(pattern)) {
[17:39:41.257]                           computeRestarts <- base::computeRestarts
[17:39:41.257]                           grepl <- base::grepl
[17:39:41.257]                           restarts <- computeRestarts(cond)
[17:39:41.257]                           for (restart in restarts) {
[17:39:41.257]                             name <- restart$name
[17:39:41.257]                             if (is.null(name)) 
[17:39:41.257]                               next
[17:39:41.257]                             if (!grepl(pattern, name)) 
[17:39:41.257]                               next
[17:39:41.257]                             invokeRestart(restart)
[17:39:41.257]                             muffled <- TRUE
[17:39:41.257]                             break
[17:39:41.257]                           }
[17:39:41.257]                         }
[17:39:41.257]                       }
[17:39:41.257]                       invisible(muffled)
[17:39:41.257]                     }
[17:39:41.257]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.257]                   }
[17:39:41.257]                 }
[17:39:41.257]                 else {
[17:39:41.257]                   if (TRUE) {
[17:39:41.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.257]                     {
[17:39:41.257]                       inherits <- base::inherits
[17:39:41.257]                       invokeRestart <- base::invokeRestart
[17:39:41.257]                       is.null <- base::is.null
[17:39:41.257]                       muffled <- FALSE
[17:39:41.257]                       if (inherits(cond, "message")) {
[17:39:41.257]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.257]                         if (muffled) 
[17:39:41.257]                           invokeRestart("muffleMessage")
[17:39:41.257]                       }
[17:39:41.257]                       else if (inherits(cond, "warning")) {
[17:39:41.257]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.257]                         if (muffled) 
[17:39:41.257]                           invokeRestart("muffleWarning")
[17:39:41.257]                       }
[17:39:41.257]                       else if (inherits(cond, "condition")) {
[17:39:41.257]                         if (!is.null(pattern)) {
[17:39:41.257]                           computeRestarts <- base::computeRestarts
[17:39:41.257]                           grepl <- base::grepl
[17:39:41.257]                           restarts <- computeRestarts(cond)
[17:39:41.257]                           for (restart in restarts) {
[17:39:41.257]                             name <- restart$name
[17:39:41.257]                             if (is.null(name)) 
[17:39:41.257]                               next
[17:39:41.257]                             if (!grepl(pattern, name)) 
[17:39:41.257]                               next
[17:39:41.257]                             invokeRestart(restart)
[17:39:41.257]                             muffled <- TRUE
[17:39:41.257]                             break
[17:39:41.257]                           }
[17:39:41.257]                         }
[17:39:41.257]                       }
[17:39:41.257]                       invisible(muffled)
[17:39:41.257]                     }
[17:39:41.257]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.257]                   }
[17:39:41.257]                 }
[17:39:41.257]             }
[17:39:41.257]         }))
[17:39:41.257]     }, error = function(ex) {
[17:39:41.257]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.257]                 ...future.rng), started = ...future.startTime, 
[17:39:41.257]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.257]             version = "1.8"), class = "FutureResult")
[17:39:41.257]     }, finally = {
[17:39:41.257]         if (!identical(...future.workdir, getwd())) 
[17:39:41.257]             setwd(...future.workdir)
[17:39:41.257]         {
[17:39:41.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.257]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.257]             }
[17:39:41.257]             base::options(...future.oldOptions)
[17:39:41.257]             if (.Platform$OS.type == "windows") {
[17:39:41.257]                 old_names <- names(...future.oldEnvVars)
[17:39:41.257]                 envs <- base::Sys.getenv()
[17:39:41.257]                 names <- names(envs)
[17:39:41.257]                 common <- intersect(names, old_names)
[17:39:41.257]                 added <- setdiff(names, old_names)
[17:39:41.257]                 removed <- setdiff(old_names, names)
[17:39:41.257]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.257]                   envs[common]]
[17:39:41.257]                 NAMES <- toupper(changed)
[17:39:41.257]                 args <- list()
[17:39:41.257]                 for (kk in seq_along(NAMES)) {
[17:39:41.257]                   name <- changed[[kk]]
[17:39:41.257]                   NAME <- NAMES[[kk]]
[17:39:41.257]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.257]                     next
[17:39:41.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.257]                 }
[17:39:41.257]                 NAMES <- toupper(added)
[17:39:41.257]                 for (kk in seq_along(NAMES)) {
[17:39:41.257]                   name <- added[[kk]]
[17:39:41.257]                   NAME <- NAMES[[kk]]
[17:39:41.257]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.257]                     next
[17:39:41.257]                   args[[name]] <- ""
[17:39:41.257]                 }
[17:39:41.257]                 NAMES <- toupper(removed)
[17:39:41.257]                 for (kk in seq_along(NAMES)) {
[17:39:41.257]                   name <- removed[[kk]]
[17:39:41.257]                   NAME <- NAMES[[kk]]
[17:39:41.257]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.257]                     next
[17:39:41.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.257]                 }
[17:39:41.257]                 if (length(args) > 0) 
[17:39:41.257]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.257]             }
[17:39:41.257]             else {
[17:39:41.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.257]             }
[17:39:41.257]             {
[17:39:41.257]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.257]                   0L) {
[17:39:41.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.257]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.257]                   base::options(opts)
[17:39:41.257]                 }
[17:39:41.257]                 {
[17:39:41.257]                   {
[17:39:41.257]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.257]                     NULL
[17:39:41.257]                   }
[17:39:41.257]                   options(future.plan = NULL)
[17:39:41.257]                   if (is.na(NA_character_)) 
[17:39:41.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.257]                     .init = FALSE)
[17:39:41.257]                 }
[17:39:41.257]             }
[17:39:41.257]         }
[17:39:41.257]     })
[17:39:41.257]     if (TRUE) {
[17:39:41.257]         base::sink(type = "output", split = FALSE)
[17:39:41.257]         if (TRUE) {
[17:39:41.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.257]         }
[17:39:41.257]         else {
[17:39:41.257]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.257]         }
[17:39:41.257]         base::close(...future.stdout)
[17:39:41.257]         ...future.stdout <- NULL
[17:39:41.257]     }
[17:39:41.257]     ...future.result$conditions <- ...future.conditions
[17:39:41.257]     ...future.result$finished <- base::Sys.time()
[17:39:41.257]     ...future.result
[17:39:41.257] }
[17:39:41.260] assign_globals() ...
[17:39:41.260] List of 3
[17:39:41.260]  $ outer_function:function (x)  
[17:39:41.260]  $ map           :function (.x, .f, ...)  
[17:39:41.260]  $ inner_function:function (x)  
[17:39:41.260]  - attr(*, "where")=List of 3
[17:39:41.260]   ..$ outer_function:<environment: R_EmptyEnv> 
[17:39:41.260]   ..$ map           :<environment: R_EmptyEnv> 
[17:39:41.260]   ..$ inner_function:<environment: R_EmptyEnv> 
[17:39:41.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:41.260]  - attr(*, "resolved")= logi FALSE
[17:39:41.260]  - attr(*, "total_size")= num 7704
[17:39:41.260]  - attr(*, "already-done")= logi TRUE
[17:39:41.264] - reassign environment for ‘outer_function’
[17:39:41.264] - copied ‘outer_function’ to environment
[17:39:41.264] - reassign environment for ‘map’
[17:39:41.264] - copied ‘map’ to environment
[17:39:41.264] - reassign environment for ‘inner_function’
[17:39:41.265] - copied ‘inner_function’ to environment
[17:39:41.265] assign_globals() ... done
[17:39:41.265] requestCore(): workers = 2
[17:39:41.267] MulticoreFuture started
[17:39:41.268] - Launch lazy future ... done
[17:39:41.268] run() for ‘MulticoreFuture’ ... done
[17:39:41.268] result() for MulticoreFuture ...
[17:39:41.268] plan(): Setting new future strategy stack:
[17:39:41.269] List of future strategies:
[17:39:41.269] 1. sequential:
[17:39:41.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:41.269]    - tweaked: FALSE
[17:39:41.269]    - call: NULL
[17:39:41.270] plan(): nbrOfWorkers() = 1
[17:39:41.272] plan(): Setting new future strategy stack:
[17:39:41.273] List of future strategies:
[17:39:41.273] 1. multicore:
[17:39:41.273]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:41.273]    - tweaked: FALSE
[17:39:41.273]    - call: plan(strategy)
[17:39:41.279] plan(): nbrOfWorkers() = 2
[17:39:41.280] result() for MulticoreFuture ...
[17:39:41.280] result() for MulticoreFuture ... done
[17:39:41.281] result() for MulticoreFuture ... done
[17:39:41.281] result() for MulticoreFuture ...
[17:39:41.281] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[17:39:41.284] plan(): Setting new future strategy stack:
[17:39:41.284] List of future strategies:
[17:39:41.284] 1. multisession:
[17:39:41.284]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:41.284]    - tweaked: FALSE
[17:39:41.284]    - call: plan(strategy)
[17:39:41.284] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:41.284] multisession:
[17:39:41.284] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:41.284] - tweaked: FALSE
[17:39:41.284] - call: plan(strategy)
[17:39:41.291] getGlobalsAndPackages() ...
[17:39:41.292] Not searching for globals
[17:39:41.292] - globals: [0] <none>
[17:39:41.292] getGlobalsAndPackages() ... DONE
[17:39:41.293] [local output] makeClusterPSOCK() ...
[17:39:41.340] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:41.341] [local output] Base port: 11566
[17:39:41.341] [local output] Getting setup options for 2 cluster nodes ...
[17:39:41.341] [local output]  - Node 1 of 2 ...
[17:39:41.342] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:41.342] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpHGd410/worker.rank=1.parallelly.parent=42759.a707557ebe46.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpHGd410/worker.rank=1.parallelly.parent=42759.a707557ebe46.pid")'’
[17:39:41.532] - Possible to infer worker's PID: TRUE
[17:39:41.532] [local output] Rscript port: 11566

[17:39:41.532] [local output]  - Node 2 of 2 ...
[17:39:41.533] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:41.533] [local output] Rscript port: 11566

[17:39:41.534] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:41.534] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:41.534] [local output] Setting up PSOCK nodes in parallel
[17:39:41.534] List of 36
[17:39:41.534]  $ worker          : chr "localhost"
[17:39:41.534]   ..- attr(*, "localhost")= logi TRUE
[17:39:41.534]  $ master          : chr "localhost"
[17:39:41.534]  $ port            : int 11566
[17:39:41.534]  $ connectTimeout  : num 120
[17:39:41.534]  $ timeout         : num 2592000
[17:39:41.534]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:41.534]  $ homogeneous     : logi TRUE
[17:39:41.534]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:41.534]  $ rscript_envs    : NULL
[17:39:41.534]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:41.534]  $ rscript_startup : NULL
[17:39:41.534]  $ rscript_sh      : chr "sh"
[17:39:41.534]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:41.534]  $ methods         : logi TRUE
[17:39:41.534]  $ socketOptions   : chr "no-delay"
[17:39:41.534]  $ useXDR          : logi FALSE
[17:39:41.534]  $ outfile         : chr "/dev/null"
[17:39:41.534]  $ renice          : int NA
[17:39:41.534]  $ rshcmd          : NULL
[17:39:41.534]  $ user            : chr(0) 
[17:39:41.534]  $ revtunnel       : logi FALSE
[17:39:41.534]  $ rshlogfile      : NULL
[17:39:41.534]  $ rshopts         : chr(0) 
[17:39:41.534]  $ rank            : int 1
[17:39:41.534]  $ manual          : logi FALSE
[17:39:41.534]  $ dryrun          : logi FALSE
[17:39:41.534]  $ quiet           : logi FALSE
[17:39:41.534]  $ setup_strategy  : chr "parallel"
[17:39:41.534]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:41.534]  $ pidfile         : chr "/tmp/RtmpHGd410/worker.rank=1.parallelly.parent=42759.a707557ebe46.pid"
[17:39:41.534]  $ rshcmd_label    : NULL
[17:39:41.534]  $ rsh_call        : NULL
[17:39:41.534]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:41.534]  $ localMachine    : logi TRUE
[17:39:41.534]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:41.534]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:41.534]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:41.534]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:41.534]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:41.534]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:41.534]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:41.534]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:41.534]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:41.534]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:41.534]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:41.534]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:41.534]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:41.534]  $ arguments       :List of 28
[17:39:41.534]   ..$ worker          : chr "localhost"
[17:39:41.534]   ..$ master          : NULL
[17:39:41.534]   ..$ port            : int 11566
[17:39:41.534]   ..$ connectTimeout  : num 120
[17:39:41.534]   ..$ timeout         : num 2592000
[17:39:41.534]   ..$ rscript         : NULL
[17:39:41.534]   ..$ homogeneous     : NULL
[17:39:41.534]   ..$ rscript_args    : NULL
[17:39:41.534]   ..$ rscript_envs    : NULL
[17:39:41.534]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:41.534]   ..$ rscript_startup : NULL
[17:39:41.534]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:41.534]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:41.534]   ..$ methods         : logi TRUE
[17:39:41.534]   ..$ socketOptions   : chr "no-delay"
[17:39:41.534]   ..$ useXDR          : logi FALSE
[17:39:41.534]   ..$ outfile         : chr "/dev/null"
[17:39:41.534]   ..$ renice          : int NA
[17:39:41.534]   ..$ rshcmd          : NULL
[17:39:41.534]   ..$ user            : NULL
[17:39:41.534]   ..$ revtunnel       : logi NA
[17:39:41.534]   ..$ rshlogfile      : NULL
[17:39:41.534]   ..$ rshopts         : NULL
[17:39:41.534]   ..$ rank            : int 1
[17:39:41.534]   ..$ manual          : logi FALSE
[17:39:41.534]   ..$ dryrun          : logi FALSE
[17:39:41.534]   ..$ quiet           : logi FALSE
[17:39:41.534]   ..$ setup_strategy  : chr "parallel"
[17:39:41.534]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:41.550] [local output] System call to launch all workers:
[17:39:41.551] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpHGd410/worker.rank=1.parallelly.parent=42759.a707557ebe46.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11566 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:41.551] [local output] Starting PSOCK main server
[17:39:41.556] [local output] Workers launched
[17:39:41.557] [local output] Waiting for workers to connect back
[17:39:41.557]  - [local output] 0 workers out of 2 ready
[17:39:41.826]  - [local output] 0 workers out of 2 ready
[17:39:41.827]  - [local output] 1 workers out of 2 ready
[17:39:41.827]  - [local output] 2 workers out of 2 ready
[17:39:41.827] [local output] Launching of workers completed
[17:39:41.827] [local output] Collecting session information from workers
[17:39:41.828] [local output]  - Worker #1 of 2
[17:39:41.829] [local output]  - Worker #2 of 2
[17:39:41.829] [local output] makeClusterPSOCK() ... done
[17:39:41.840] Packages needed by the future expression (n = 0): <none>
[17:39:41.840] Packages needed by future strategies (n = 0): <none>
[17:39:41.841] {
[17:39:41.841]     {
[17:39:41.841]         {
[17:39:41.841]             ...future.startTime <- base::Sys.time()
[17:39:41.841]             {
[17:39:41.841]                 {
[17:39:41.841]                   {
[17:39:41.841]                     {
[17:39:41.841]                       base::local({
[17:39:41.841]                         has_future <- base::requireNamespace("future", 
[17:39:41.841]                           quietly = TRUE)
[17:39:41.841]                         if (has_future) {
[17:39:41.841]                           ns <- base::getNamespace("future")
[17:39:41.841]                           version <- ns[[".package"]][["version"]]
[17:39:41.841]                           if (is.null(version)) 
[17:39:41.841]                             version <- utils::packageVersion("future")
[17:39:41.841]                         }
[17:39:41.841]                         else {
[17:39:41.841]                           version <- NULL
[17:39:41.841]                         }
[17:39:41.841]                         if (!has_future || version < "1.8.0") {
[17:39:41.841]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.841]                             "", base::R.version$version.string), 
[17:39:41.841]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:41.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:41.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.841]                               "release", "version")], collapse = " "), 
[17:39:41.841]                             hostname = base::Sys.info()[["nodename"]])
[17:39:41.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.841]                             info)
[17:39:41.841]                           info <- base::paste(info, collapse = "; ")
[17:39:41.841]                           if (!has_future) {
[17:39:41.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.841]                               info)
[17:39:41.841]                           }
[17:39:41.841]                           else {
[17:39:41.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.841]                               info, version)
[17:39:41.841]                           }
[17:39:41.841]                           base::stop(msg)
[17:39:41.841]                         }
[17:39:41.841]                       })
[17:39:41.841]                     }
[17:39:41.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.841]                     base::options(mc.cores = 1L)
[17:39:41.841]                   }
[17:39:41.841]                   ...future.strategy.old <- future::plan("list")
[17:39:41.841]                   options(future.plan = NULL)
[17:39:41.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.841]                 }
[17:39:41.841]                 ...future.workdir <- getwd()
[17:39:41.841]             }
[17:39:41.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.841]         }
[17:39:41.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.841]             base::names(...future.oldOptions))
[17:39:41.841]     }
[17:39:41.841]     if (FALSE) {
[17:39:41.841]     }
[17:39:41.841]     else {
[17:39:41.841]         if (TRUE) {
[17:39:41.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.841]                 open = "w")
[17:39:41.841]         }
[17:39:41.841]         else {
[17:39:41.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.841]         }
[17:39:41.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.841]             base::sink(type = "output", split = FALSE)
[17:39:41.841]             base::close(...future.stdout)
[17:39:41.841]         }, add = TRUE)
[17:39:41.841]     }
[17:39:41.841]     ...future.frame <- base::sys.nframe()
[17:39:41.841]     ...future.conditions <- base::list()
[17:39:41.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.841]     if (FALSE) {
[17:39:41.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.841]     }
[17:39:41.841]     ...future.result <- base::tryCatch({
[17:39:41.841]         base::withCallingHandlers({
[17:39:41.841]             ...future.value <- base::withVisible(base::local({
[17:39:41.841]                 ...future.makeSendCondition <- base::local({
[17:39:41.841]                   sendCondition <- NULL
[17:39:41.841]                   function(frame = 1L) {
[17:39:41.841]                     if (is.function(sendCondition)) 
[17:39:41.841]                       return(sendCondition)
[17:39:41.841]                     ns <- getNamespace("parallel")
[17:39:41.841]                     if (exists("sendData", mode = "function", 
[17:39:41.841]                       envir = ns)) {
[17:39:41.841]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:41.841]                         envir = ns)
[17:39:41.841]                       envir <- sys.frame(frame)
[17:39:41.841]                       master <- NULL
[17:39:41.841]                       while (!identical(envir, .GlobalEnv) && 
[17:39:41.841]                         !identical(envir, emptyenv())) {
[17:39:41.841]                         if (exists("master", mode = "list", envir = envir, 
[17:39:41.841]                           inherits = FALSE)) {
[17:39:41.841]                           master <- get("master", mode = "list", 
[17:39:41.841]                             envir = envir, inherits = FALSE)
[17:39:41.841]                           if (inherits(master, c("SOCKnode", 
[17:39:41.841]                             "SOCK0node"))) {
[17:39:41.841]                             sendCondition <<- function(cond) {
[17:39:41.841]                               data <- list(type = "VALUE", value = cond, 
[17:39:41.841]                                 success = TRUE)
[17:39:41.841]                               parallel_sendData(master, data)
[17:39:41.841]                             }
[17:39:41.841]                             return(sendCondition)
[17:39:41.841]                           }
[17:39:41.841]                         }
[17:39:41.841]                         frame <- frame + 1L
[17:39:41.841]                         envir <- sys.frame(frame)
[17:39:41.841]                       }
[17:39:41.841]                     }
[17:39:41.841]                     sendCondition <<- function(cond) NULL
[17:39:41.841]                   }
[17:39:41.841]                 })
[17:39:41.841]                 withCallingHandlers({
[17:39:41.841]                   NA
[17:39:41.841]                 }, immediateCondition = function(cond) {
[17:39:41.841]                   sendCondition <- ...future.makeSendCondition()
[17:39:41.841]                   sendCondition(cond)
[17:39:41.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.841]                   {
[17:39:41.841]                     inherits <- base::inherits
[17:39:41.841]                     invokeRestart <- base::invokeRestart
[17:39:41.841]                     is.null <- base::is.null
[17:39:41.841]                     muffled <- FALSE
[17:39:41.841]                     if (inherits(cond, "message")) {
[17:39:41.841]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.841]                       if (muffled) 
[17:39:41.841]                         invokeRestart("muffleMessage")
[17:39:41.841]                     }
[17:39:41.841]                     else if (inherits(cond, "warning")) {
[17:39:41.841]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.841]                       if (muffled) 
[17:39:41.841]                         invokeRestart("muffleWarning")
[17:39:41.841]                     }
[17:39:41.841]                     else if (inherits(cond, "condition")) {
[17:39:41.841]                       if (!is.null(pattern)) {
[17:39:41.841]                         computeRestarts <- base::computeRestarts
[17:39:41.841]                         grepl <- base::grepl
[17:39:41.841]                         restarts <- computeRestarts(cond)
[17:39:41.841]                         for (restart in restarts) {
[17:39:41.841]                           name <- restart$name
[17:39:41.841]                           if (is.null(name)) 
[17:39:41.841]                             next
[17:39:41.841]                           if (!grepl(pattern, name)) 
[17:39:41.841]                             next
[17:39:41.841]                           invokeRestart(restart)
[17:39:41.841]                           muffled <- TRUE
[17:39:41.841]                           break
[17:39:41.841]                         }
[17:39:41.841]                       }
[17:39:41.841]                     }
[17:39:41.841]                     invisible(muffled)
[17:39:41.841]                   }
[17:39:41.841]                   muffleCondition(cond)
[17:39:41.841]                 })
[17:39:41.841]             }))
[17:39:41.841]             future::FutureResult(value = ...future.value$value, 
[17:39:41.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.841]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.841]                     ...future.globalenv.names))
[17:39:41.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.841]         }, condition = base::local({
[17:39:41.841]             c <- base::c
[17:39:41.841]             inherits <- base::inherits
[17:39:41.841]             invokeRestart <- base::invokeRestart
[17:39:41.841]             length <- base::length
[17:39:41.841]             list <- base::list
[17:39:41.841]             seq.int <- base::seq.int
[17:39:41.841]             signalCondition <- base::signalCondition
[17:39:41.841]             sys.calls <- base::sys.calls
[17:39:41.841]             `[[` <- base::`[[`
[17:39:41.841]             `+` <- base::`+`
[17:39:41.841]             `<<-` <- base::`<<-`
[17:39:41.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.841]                   3L)]
[17:39:41.841]             }
[17:39:41.841]             function(cond) {
[17:39:41.841]                 is_error <- inherits(cond, "error")
[17:39:41.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.841]                   NULL)
[17:39:41.841]                 if (is_error) {
[17:39:41.841]                   sessionInformation <- function() {
[17:39:41.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.841]                       search = base::search(), system = base::Sys.info())
[17:39:41.841]                   }
[17:39:41.841]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.841]                     cond$call), session = sessionInformation(), 
[17:39:41.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.841]                   signalCondition(cond)
[17:39:41.841]                 }
[17:39:41.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.841]                 "immediateCondition"))) {
[17:39:41.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.841]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.841]                   if (TRUE && !signal) {
[17:39:41.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.841]                     {
[17:39:41.841]                       inherits <- base::inherits
[17:39:41.841]                       invokeRestart <- base::invokeRestart
[17:39:41.841]                       is.null <- base::is.null
[17:39:41.841]                       muffled <- FALSE
[17:39:41.841]                       if (inherits(cond, "message")) {
[17:39:41.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.841]                         if (muffled) 
[17:39:41.841]                           invokeRestart("muffleMessage")
[17:39:41.841]                       }
[17:39:41.841]                       else if (inherits(cond, "warning")) {
[17:39:41.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.841]                         if (muffled) 
[17:39:41.841]                           invokeRestart("muffleWarning")
[17:39:41.841]                       }
[17:39:41.841]                       else if (inherits(cond, "condition")) {
[17:39:41.841]                         if (!is.null(pattern)) {
[17:39:41.841]                           computeRestarts <- base::computeRestarts
[17:39:41.841]                           grepl <- base::grepl
[17:39:41.841]                           restarts <- computeRestarts(cond)
[17:39:41.841]                           for (restart in restarts) {
[17:39:41.841]                             name <- restart$name
[17:39:41.841]                             if (is.null(name)) 
[17:39:41.841]                               next
[17:39:41.841]                             if (!grepl(pattern, name)) 
[17:39:41.841]                               next
[17:39:41.841]                             invokeRestart(restart)
[17:39:41.841]                             muffled <- TRUE
[17:39:41.841]                             break
[17:39:41.841]                           }
[17:39:41.841]                         }
[17:39:41.841]                       }
[17:39:41.841]                       invisible(muffled)
[17:39:41.841]                     }
[17:39:41.841]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.841]                   }
[17:39:41.841]                 }
[17:39:41.841]                 else {
[17:39:41.841]                   if (TRUE) {
[17:39:41.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.841]                     {
[17:39:41.841]                       inherits <- base::inherits
[17:39:41.841]                       invokeRestart <- base::invokeRestart
[17:39:41.841]                       is.null <- base::is.null
[17:39:41.841]                       muffled <- FALSE
[17:39:41.841]                       if (inherits(cond, "message")) {
[17:39:41.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.841]                         if (muffled) 
[17:39:41.841]                           invokeRestart("muffleMessage")
[17:39:41.841]                       }
[17:39:41.841]                       else if (inherits(cond, "warning")) {
[17:39:41.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.841]                         if (muffled) 
[17:39:41.841]                           invokeRestart("muffleWarning")
[17:39:41.841]                       }
[17:39:41.841]                       else if (inherits(cond, "condition")) {
[17:39:41.841]                         if (!is.null(pattern)) {
[17:39:41.841]                           computeRestarts <- base::computeRestarts
[17:39:41.841]                           grepl <- base::grepl
[17:39:41.841]                           restarts <- computeRestarts(cond)
[17:39:41.841]                           for (restart in restarts) {
[17:39:41.841]                             name <- restart$name
[17:39:41.841]                             if (is.null(name)) 
[17:39:41.841]                               next
[17:39:41.841]                             if (!grepl(pattern, name)) 
[17:39:41.841]                               next
[17:39:41.841]                             invokeRestart(restart)
[17:39:41.841]                             muffled <- TRUE
[17:39:41.841]                             break
[17:39:41.841]                           }
[17:39:41.841]                         }
[17:39:41.841]                       }
[17:39:41.841]                       invisible(muffled)
[17:39:41.841]                     }
[17:39:41.841]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.841]                   }
[17:39:41.841]                 }
[17:39:41.841]             }
[17:39:41.841]         }))
[17:39:41.841]     }, error = function(ex) {
[17:39:41.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.841]                 ...future.rng), started = ...future.startTime, 
[17:39:41.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.841]             version = "1.8"), class = "FutureResult")
[17:39:41.841]     }, finally = {
[17:39:41.841]         if (!identical(...future.workdir, getwd())) 
[17:39:41.841]             setwd(...future.workdir)
[17:39:41.841]         {
[17:39:41.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.841]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.841]             }
[17:39:41.841]             base::options(...future.oldOptions)
[17:39:41.841]             if (.Platform$OS.type == "windows") {
[17:39:41.841]                 old_names <- names(...future.oldEnvVars)
[17:39:41.841]                 envs <- base::Sys.getenv()
[17:39:41.841]                 names <- names(envs)
[17:39:41.841]                 common <- intersect(names, old_names)
[17:39:41.841]                 added <- setdiff(names, old_names)
[17:39:41.841]                 removed <- setdiff(old_names, names)
[17:39:41.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.841]                   envs[common]]
[17:39:41.841]                 NAMES <- toupper(changed)
[17:39:41.841]                 args <- list()
[17:39:41.841]                 for (kk in seq_along(NAMES)) {
[17:39:41.841]                   name <- changed[[kk]]
[17:39:41.841]                   NAME <- NAMES[[kk]]
[17:39:41.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.841]                     next
[17:39:41.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.841]                 }
[17:39:41.841]                 NAMES <- toupper(added)
[17:39:41.841]                 for (kk in seq_along(NAMES)) {
[17:39:41.841]                   name <- added[[kk]]
[17:39:41.841]                   NAME <- NAMES[[kk]]
[17:39:41.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.841]                     next
[17:39:41.841]                   args[[name]] <- ""
[17:39:41.841]                 }
[17:39:41.841]                 NAMES <- toupper(removed)
[17:39:41.841]                 for (kk in seq_along(NAMES)) {
[17:39:41.841]                   name <- removed[[kk]]
[17:39:41.841]                   NAME <- NAMES[[kk]]
[17:39:41.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.841]                     next
[17:39:41.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.841]                 }
[17:39:41.841]                 if (length(args) > 0) 
[17:39:41.841]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.841]             }
[17:39:41.841]             else {
[17:39:41.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.841]             }
[17:39:41.841]             {
[17:39:41.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.841]                   0L) {
[17:39:41.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.841]                   base::options(opts)
[17:39:41.841]                 }
[17:39:41.841]                 {
[17:39:41.841]                   {
[17:39:41.841]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.841]                     NULL
[17:39:41.841]                   }
[17:39:41.841]                   options(future.plan = NULL)
[17:39:41.841]                   if (is.na(NA_character_)) 
[17:39:41.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.841]                     .init = FALSE)
[17:39:41.841]                 }
[17:39:41.841]             }
[17:39:41.841]         }
[17:39:41.841]     })
[17:39:41.841]     if (TRUE) {
[17:39:41.841]         base::sink(type = "output", split = FALSE)
[17:39:41.841]         if (TRUE) {
[17:39:41.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.841]         }
[17:39:41.841]         else {
[17:39:41.841]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.841]         }
[17:39:41.841]         base::close(...future.stdout)
[17:39:41.841]         ...future.stdout <- NULL
[17:39:41.841]     }
[17:39:41.841]     ...future.result$conditions <- ...future.conditions
[17:39:41.841]     ...future.result$finished <- base::Sys.time()
[17:39:41.841]     ...future.result
[17:39:41.841] }
[17:39:41.893] MultisessionFuture started
[17:39:41.893] result() for ClusterFuture ...
[17:39:41.894] receiveMessageFromWorker() for ClusterFuture ...
[17:39:41.894] - Validating connection of MultisessionFuture
[17:39:41.926] - received message: FutureResult
[17:39:41.926] - Received FutureResult
[17:39:41.926] - Erased future from FutureRegistry
[17:39:41.926] result() for ClusterFuture ...
[17:39:41.926] - result already collected: FutureResult
[17:39:41.926] result() for ClusterFuture ... done
[17:39:41.926] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:41.927] result() for ClusterFuture ... done
[17:39:41.927] result() for ClusterFuture ...
[17:39:41.927] - result already collected: FutureResult
[17:39:41.927] result() for ClusterFuture ... done
[17:39:41.927] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:41.931] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[17:39:41.931] getGlobalsAndPackages() ...
[17:39:41.931] Searching for globals...
[17:39:41.933] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:41.933] Searching for globals ... DONE
[17:39:41.934] Resolving globals: FALSE
[17:39:41.934] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:41.935] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:41.935] - globals: [2] ‘weight’, ‘group’
[17:39:41.935] - packages: [1] ‘stats’
[17:39:41.935] getGlobalsAndPackages() ... DONE
[17:39:41.935] run() for ‘Future’ ...
[17:39:41.935] - state: ‘created’
[17:39:41.936] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:41.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:41.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:41.950]   - Field: ‘node’
[17:39:41.950]   - Field: ‘label’
[17:39:41.950]   - Field: ‘local’
[17:39:41.950]   - Field: ‘owner’
[17:39:41.951]   - Field: ‘envir’
[17:39:41.951]   - Field: ‘workers’
[17:39:41.951]   - Field: ‘packages’
[17:39:41.951]   - Field: ‘gc’
[17:39:41.951]   - Field: ‘conditions’
[17:39:41.951]   - Field: ‘persistent’
[17:39:41.951]   - Field: ‘expr’
[17:39:41.951]   - Field: ‘uuid’
[17:39:41.951]   - Field: ‘seed’
[17:39:41.952]   - Field: ‘version’
[17:39:41.952]   - Field: ‘result’
[17:39:41.952]   - Field: ‘asynchronous’
[17:39:41.952]   - Field: ‘calls’
[17:39:41.952]   - Field: ‘globals’
[17:39:41.952]   - Field: ‘stdout’
[17:39:41.952]   - Field: ‘earlySignal’
[17:39:41.952]   - Field: ‘lazy’
[17:39:41.952]   - Field: ‘state’
[17:39:41.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:41.953] - Launch lazy future ...
[17:39:41.953] Packages needed by the future expression (n = 1): ‘stats’
[17:39:41.953] Packages needed by future strategies (n = 0): <none>
[17:39:41.954] {
[17:39:41.954]     {
[17:39:41.954]         {
[17:39:41.954]             ...future.startTime <- base::Sys.time()
[17:39:41.954]             {
[17:39:41.954]                 {
[17:39:41.954]                   {
[17:39:41.954]                     {
[17:39:41.954]                       {
[17:39:41.954]                         base::local({
[17:39:41.954]                           has_future <- base::requireNamespace("future", 
[17:39:41.954]                             quietly = TRUE)
[17:39:41.954]                           if (has_future) {
[17:39:41.954]                             ns <- base::getNamespace("future")
[17:39:41.954]                             version <- ns[[".package"]][["version"]]
[17:39:41.954]                             if (is.null(version)) 
[17:39:41.954]                               version <- utils::packageVersion("future")
[17:39:41.954]                           }
[17:39:41.954]                           else {
[17:39:41.954]                             version <- NULL
[17:39:41.954]                           }
[17:39:41.954]                           if (!has_future || version < "1.8.0") {
[17:39:41.954]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:41.954]                               "", base::R.version$version.string), 
[17:39:41.954]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:41.954]                                 base::R.version$platform, 8 * 
[17:39:41.954]                                   base::.Machine$sizeof.pointer), 
[17:39:41.954]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:41.954]                                 "release", "version")], collapse = " "), 
[17:39:41.954]                               hostname = base::Sys.info()[["nodename"]])
[17:39:41.954]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:41.954]                               info)
[17:39:41.954]                             info <- base::paste(info, collapse = "; ")
[17:39:41.954]                             if (!has_future) {
[17:39:41.954]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:41.954]                                 info)
[17:39:41.954]                             }
[17:39:41.954]                             else {
[17:39:41.954]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:41.954]                                 info, version)
[17:39:41.954]                             }
[17:39:41.954]                             base::stop(msg)
[17:39:41.954]                           }
[17:39:41.954]                         })
[17:39:41.954]                       }
[17:39:41.954]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:41.954]                       base::options(mc.cores = 1L)
[17:39:41.954]                     }
[17:39:41.954]                     base::local({
[17:39:41.954]                       for (pkg in "stats") {
[17:39:41.954]                         base::loadNamespace(pkg)
[17:39:41.954]                         base::library(pkg, character.only = TRUE)
[17:39:41.954]                       }
[17:39:41.954]                     })
[17:39:41.954]                   }
[17:39:41.954]                   ...future.strategy.old <- future::plan("list")
[17:39:41.954]                   options(future.plan = NULL)
[17:39:41.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:41.954]                 }
[17:39:41.954]                 ...future.workdir <- getwd()
[17:39:41.954]             }
[17:39:41.954]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:41.954]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:41.954]         }
[17:39:41.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:41.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:41.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:41.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:41.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:41.954]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:41.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:41.954]             base::names(...future.oldOptions))
[17:39:41.954]     }
[17:39:41.954]     if (FALSE) {
[17:39:41.954]     }
[17:39:41.954]     else {
[17:39:41.954]         if (TRUE) {
[17:39:41.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:41.954]                 open = "w")
[17:39:41.954]         }
[17:39:41.954]         else {
[17:39:41.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:41.954]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:41.954]         }
[17:39:41.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:41.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:41.954]             base::sink(type = "output", split = FALSE)
[17:39:41.954]             base::close(...future.stdout)
[17:39:41.954]         }, add = TRUE)
[17:39:41.954]     }
[17:39:41.954]     ...future.frame <- base::sys.nframe()
[17:39:41.954]     ...future.conditions <- base::list()
[17:39:41.954]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:41.954]     if (FALSE) {
[17:39:41.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:41.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:41.954]     }
[17:39:41.954]     ...future.result <- base::tryCatch({
[17:39:41.954]         base::withCallingHandlers({
[17:39:41.954]             ...future.value <- base::withVisible(base::local({
[17:39:41.954]                 ...future.makeSendCondition <- base::local({
[17:39:41.954]                   sendCondition <- NULL
[17:39:41.954]                   function(frame = 1L) {
[17:39:41.954]                     if (is.function(sendCondition)) 
[17:39:41.954]                       return(sendCondition)
[17:39:41.954]                     ns <- getNamespace("parallel")
[17:39:41.954]                     if (exists("sendData", mode = "function", 
[17:39:41.954]                       envir = ns)) {
[17:39:41.954]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:41.954]                         envir = ns)
[17:39:41.954]                       envir <- sys.frame(frame)
[17:39:41.954]                       master <- NULL
[17:39:41.954]                       while (!identical(envir, .GlobalEnv) && 
[17:39:41.954]                         !identical(envir, emptyenv())) {
[17:39:41.954]                         if (exists("master", mode = "list", envir = envir, 
[17:39:41.954]                           inherits = FALSE)) {
[17:39:41.954]                           master <- get("master", mode = "list", 
[17:39:41.954]                             envir = envir, inherits = FALSE)
[17:39:41.954]                           if (inherits(master, c("SOCKnode", 
[17:39:41.954]                             "SOCK0node"))) {
[17:39:41.954]                             sendCondition <<- function(cond) {
[17:39:41.954]                               data <- list(type = "VALUE", value = cond, 
[17:39:41.954]                                 success = TRUE)
[17:39:41.954]                               parallel_sendData(master, data)
[17:39:41.954]                             }
[17:39:41.954]                             return(sendCondition)
[17:39:41.954]                           }
[17:39:41.954]                         }
[17:39:41.954]                         frame <- frame + 1L
[17:39:41.954]                         envir <- sys.frame(frame)
[17:39:41.954]                       }
[17:39:41.954]                     }
[17:39:41.954]                     sendCondition <<- function(cond) NULL
[17:39:41.954]                   }
[17:39:41.954]                 })
[17:39:41.954]                 withCallingHandlers({
[17:39:41.954]                   {
[17:39:41.954]                     lm(weight ~ group - 1)
[17:39:41.954]                   }
[17:39:41.954]                 }, immediateCondition = function(cond) {
[17:39:41.954]                   sendCondition <- ...future.makeSendCondition()
[17:39:41.954]                   sendCondition(cond)
[17:39:41.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.954]                   {
[17:39:41.954]                     inherits <- base::inherits
[17:39:41.954]                     invokeRestart <- base::invokeRestart
[17:39:41.954]                     is.null <- base::is.null
[17:39:41.954]                     muffled <- FALSE
[17:39:41.954]                     if (inherits(cond, "message")) {
[17:39:41.954]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:41.954]                       if (muffled) 
[17:39:41.954]                         invokeRestart("muffleMessage")
[17:39:41.954]                     }
[17:39:41.954]                     else if (inherits(cond, "warning")) {
[17:39:41.954]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:41.954]                       if (muffled) 
[17:39:41.954]                         invokeRestart("muffleWarning")
[17:39:41.954]                     }
[17:39:41.954]                     else if (inherits(cond, "condition")) {
[17:39:41.954]                       if (!is.null(pattern)) {
[17:39:41.954]                         computeRestarts <- base::computeRestarts
[17:39:41.954]                         grepl <- base::grepl
[17:39:41.954]                         restarts <- computeRestarts(cond)
[17:39:41.954]                         for (restart in restarts) {
[17:39:41.954]                           name <- restart$name
[17:39:41.954]                           if (is.null(name)) 
[17:39:41.954]                             next
[17:39:41.954]                           if (!grepl(pattern, name)) 
[17:39:41.954]                             next
[17:39:41.954]                           invokeRestart(restart)
[17:39:41.954]                           muffled <- TRUE
[17:39:41.954]                           break
[17:39:41.954]                         }
[17:39:41.954]                       }
[17:39:41.954]                     }
[17:39:41.954]                     invisible(muffled)
[17:39:41.954]                   }
[17:39:41.954]                   muffleCondition(cond)
[17:39:41.954]                 })
[17:39:41.954]             }))
[17:39:41.954]             future::FutureResult(value = ...future.value$value, 
[17:39:41.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.954]                   ...future.rng), globalenv = if (FALSE) 
[17:39:41.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:41.954]                     ...future.globalenv.names))
[17:39:41.954]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:41.954]         }, condition = base::local({
[17:39:41.954]             c <- base::c
[17:39:41.954]             inherits <- base::inherits
[17:39:41.954]             invokeRestart <- base::invokeRestart
[17:39:41.954]             length <- base::length
[17:39:41.954]             list <- base::list
[17:39:41.954]             seq.int <- base::seq.int
[17:39:41.954]             signalCondition <- base::signalCondition
[17:39:41.954]             sys.calls <- base::sys.calls
[17:39:41.954]             `[[` <- base::`[[`
[17:39:41.954]             `+` <- base::`+`
[17:39:41.954]             `<<-` <- base::`<<-`
[17:39:41.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:41.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:41.954]                   3L)]
[17:39:41.954]             }
[17:39:41.954]             function(cond) {
[17:39:41.954]                 is_error <- inherits(cond, "error")
[17:39:41.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:41.954]                   NULL)
[17:39:41.954]                 if (is_error) {
[17:39:41.954]                   sessionInformation <- function() {
[17:39:41.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:41.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:41.954]                       search = base::search(), system = base::Sys.info())
[17:39:41.954]                   }
[17:39:41.954]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:41.954]                     cond$call), session = sessionInformation(), 
[17:39:41.954]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:41.954]                   signalCondition(cond)
[17:39:41.954]                 }
[17:39:41.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:41.954]                 "immediateCondition"))) {
[17:39:41.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:41.954]                   ...future.conditions[[length(...future.conditions) + 
[17:39:41.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:41.954]                   if (TRUE && !signal) {
[17:39:41.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.954]                     {
[17:39:41.954]                       inherits <- base::inherits
[17:39:41.954]                       invokeRestart <- base::invokeRestart
[17:39:41.954]                       is.null <- base::is.null
[17:39:41.954]                       muffled <- FALSE
[17:39:41.954]                       if (inherits(cond, "message")) {
[17:39:41.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.954]                         if (muffled) 
[17:39:41.954]                           invokeRestart("muffleMessage")
[17:39:41.954]                       }
[17:39:41.954]                       else if (inherits(cond, "warning")) {
[17:39:41.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.954]                         if (muffled) 
[17:39:41.954]                           invokeRestart("muffleWarning")
[17:39:41.954]                       }
[17:39:41.954]                       else if (inherits(cond, "condition")) {
[17:39:41.954]                         if (!is.null(pattern)) {
[17:39:41.954]                           computeRestarts <- base::computeRestarts
[17:39:41.954]                           grepl <- base::grepl
[17:39:41.954]                           restarts <- computeRestarts(cond)
[17:39:41.954]                           for (restart in restarts) {
[17:39:41.954]                             name <- restart$name
[17:39:41.954]                             if (is.null(name)) 
[17:39:41.954]                               next
[17:39:41.954]                             if (!grepl(pattern, name)) 
[17:39:41.954]                               next
[17:39:41.954]                             invokeRestart(restart)
[17:39:41.954]                             muffled <- TRUE
[17:39:41.954]                             break
[17:39:41.954]                           }
[17:39:41.954]                         }
[17:39:41.954]                       }
[17:39:41.954]                       invisible(muffled)
[17:39:41.954]                     }
[17:39:41.954]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.954]                   }
[17:39:41.954]                 }
[17:39:41.954]                 else {
[17:39:41.954]                   if (TRUE) {
[17:39:41.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:41.954]                     {
[17:39:41.954]                       inherits <- base::inherits
[17:39:41.954]                       invokeRestart <- base::invokeRestart
[17:39:41.954]                       is.null <- base::is.null
[17:39:41.954]                       muffled <- FALSE
[17:39:41.954]                       if (inherits(cond, "message")) {
[17:39:41.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:41.954]                         if (muffled) 
[17:39:41.954]                           invokeRestart("muffleMessage")
[17:39:41.954]                       }
[17:39:41.954]                       else if (inherits(cond, "warning")) {
[17:39:41.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:41.954]                         if (muffled) 
[17:39:41.954]                           invokeRestart("muffleWarning")
[17:39:41.954]                       }
[17:39:41.954]                       else if (inherits(cond, "condition")) {
[17:39:41.954]                         if (!is.null(pattern)) {
[17:39:41.954]                           computeRestarts <- base::computeRestarts
[17:39:41.954]                           grepl <- base::grepl
[17:39:41.954]                           restarts <- computeRestarts(cond)
[17:39:41.954]                           for (restart in restarts) {
[17:39:41.954]                             name <- restart$name
[17:39:41.954]                             if (is.null(name)) 
[17:39:41.954]                               next
[17:39:41.954]                             if (!grepl(pattern, name)) 
[17:39:41.954]                               next
[17:39:41.954]                             invokeRestart(restart)
[17:39:41.954]                             muffled <- TRUE
[17:39:41.954]                             break
[17:39:41.954]                           }
[17:39:41.954]                         }
[17:39:41.954]                       }
[17:39:41.954]                       invisible(muffled)
[17:39:41.954]                     }
[17:39:41.954]                     muffleCondition(cond, pattern = "^muffle")
[17:39:41.954]                   }
[17:39:41.954]                 }
[17:39:41.954]             }
[17:39:41.954]         }))
[17:39:41.954]     }, error = function(ex) {
[17:39:41.954]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:41.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:41.954]                 ...future.rng), started = ...future.startTime, 
[17:39:41.954]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:41.954]             version = "1.8"), class = "FutureResult")
[17:39:41.954]     }, finally = {
[17:39:41.954]         if (!identical(...future.workdir, getwd())) 
[17:39:41.954]             setwd(...future.workdir)
[17:39:41.954]         {
[17:39:41.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:41.954]                 ...future.oldOptions$nwarnings <- NULL
[17:39:41.954]             }
[17:39:41.954]             base::options(...future.oldOptions)
[17:39:41.954]             if (.Platform$OS.type == "windows") {
[17:39:41.954]                 old_names <- names(...future.oldEnvVars)
[17:39:41.954]                 envs <- base::Sys.getenv()
[17:39:41.954]                 names <- names(envs)
[17:39:41.954]                 common <- intersect(names, old_names)
[17:39:41.954]                 added <- setdiff(names, old_names)
[17:39:41.954]                 removed <- setdiff(old_names, names)
[17:39:41.954]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:41.954]                   envs[common]]
[17:39:41.954]                 NAMES <- toupper(changed)
[17:39:41.954]                 args <- list()
[17:39:41.954]                 for (kk in seq_along(NAMES)) {
[17:39:41.954]                   name <- changed[[kk]]
[17:39:41.954]                   NAME <- NAMES[[kk]]
[17:39:41.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.954]                     next
[17:39:41.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.954]                 }
[17:39:41.954]                 NAMES <- toupper(added)
[17:39:41.954]                 for (kk in seq_along(NAMES)) {
[17:39:41.954]                   name <- added[[kk]]
[17:39:41.954]                   NAME <- NAMES[[kk]]
[17:39:41.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.954]                     next
[17:39:41.954]                   args[[name]] <- ""
[17:39:41.954]                 }
[17:39:41.954]                 NAMES <- toupper(removed)
[17:39:41.954]                 for (kk in seq_along(NAMES)) {
[17:39:41.954]                   name <- removed[[kk]]
[17:39:41.954]                   NAME <- NAMES[[kk]]
[17:39:41.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:41.954]                     next
[17:39:41.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:41.954]                 }
[17:39:41.954]                 if (length(args) > 0) 
[17:39:41.954]                   base::do.call(base::Sys.setenv, args = args)
[17:39:41.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:41.954]             }
[17:39:41.954]             else {
[17:39:41.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:41.954]             }
[17:39:41.954]             {
[17:39:41.954]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:41.954]                   0L) {
[17:39:41.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:41.954]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:41.954]                   base::options(opts)
[17:39:41.954]                 }
[17:39:41.954]                 {
[17:39:41.954]                   {
[17:39:41.954]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:41.954]                     NULL
[17:39:41.954]                   }
[17:39:41.954]                   options(future.plan = NULL)
[17:39:41.954]                   if (is.na(NA_character_)) 
[17:39:41.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:41.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:41.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:41.954]                     .init = FALSE)
[17:39:41.954]                 }
[17:39:41.954]             }
[17:39:41.954]         }
[17:39:41.954]     })
[17:39:41.954]     if (TRUE) {
[17:39:41.954]         base::sink(type = "output", split = FALSE)
[17:39:41.954]         if (TRUE) {
[17:39:41.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:41.954]         }
[17:39:41.954]         else {
[17:39:41.954]             ...future.result["stdout"] <- base::list(NULL)
[17:39:41.954]         }
[17:39:41.954]         base::close(...future.stdout)
[17:39:41.954]         ...future.stdout <- NULL
[17:39:41.954]     }
[17:39:41.954]     ...future.result$conditions <- ...future.conditions
[17:39:41.954]     ...future.result$finished <- base::Sys.time()
[17:39:41.954]     ...future.result
[17:39:41.954] }
[17:39:41.957] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:39:41.957] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:39:41.957] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:39:41.958] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:39:41.958] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:39:41.958] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:39:41.959] MultisessionFuture started
[17:39:41.959] - Launch lazy future ... done
[17:39:41.959] run() for ‘MultisessionFuture’ ... done
[17:39:41.959] result() for ClusterFuture ...
[17:39:41.959] receiveMessageFromWorker() for ClusterFuture ...
[17:39:41.959] - Validating connection of MultisessionFuture
[17:39:42.009] - received message: FutureResult
[17:39:42.010] - Received FutureResult
[17:39:42.010] - Erased future from FutureRegistry
[17:39:42.010] result() for ClusterFuture ...
[17:39:42.010] - result already collected: FutureResult
[17:39:42.010] result() for ClusterFuture ... done
[17:39:42.010] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.010] result() for ClusterFuture ... done
[17:39:42.010] result() for ClusterFuture ...
[17:39:42.011] - result already collected: FutureResult
[17:39:42.011] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:42.013] getGlobalsAndPackages() ...
[17:39:42.013] Searching for globals...
[17:39:42.015] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:42.015] Searching for globals ... DONE
[17:39:42.015] Resolving globals: FALSE
[17:39:42.016] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:42.016] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:42.016] - globals: [2] ‘weight’, ‘group’
[17:39:42.016] - packages: [1] ‘stats’
[17:39:42.017] getGlobalsAndPackages() ... DONE
[17:39:42.017] run() for ‘Future’ ...
[17:39:42.017] - state: ‘created’
[17:39:42.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.032]   - Field: ‘node’
[17:39:42.032]   - Field: ‘label’
[17:39:42.032]   - Field: ‘local’
[17:39:42.033]   - Field: ‘owner’
[17:39:42.033]   - Field: ‘envir’
[17:39:42.033]   - Field: ‘workers’
[17:39:42.033]   - Field: ‘packages’
[17:39:42.033]   - Field: ‘gc’
[17:39:42.033]   - Field: ‘conditions’
[17:39:42.033]   - Field: ‘persistent’
[17:39:42.033]   - Field: ‘expr’
[17:39:42.033]   - Field: ‘uuid’
[17:39:42.034]   - Field: ‘seed’
[17:39:42.034]   - Field: ‘version’
[17:39:42.034]   - Field: ‘result’
[17:39:42.034]   - Field: ‘asynchronous’
[17:39:42.034]   - Field: ‘calls’
[17:39:42.034]   - Field: ‘globals’
[17:39:42.034]   - Field: ‘stdout’
[17:39:42.034]   - Field: ‘earlySignal’
[17:39:42.034]   - Field: ‘lazy’
[17:39:42.035]   - Field: ‘state’
[17:39:42.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.035] - Launch lazy future ...
[17:39:42.035] Packages needed by the future expression (n = 1): ‘stats’
[17:39:42.035] Packages needed by future strategies (n = 0): <none>
[17:39:42.036] {
[17:39:42.036]     {
[17:39:42.036]         {
[17:39:42.036]             ...future.startTime <- base::Sys.time()
[17:39:42.036]             {
[17:39:42.036]                 {
[17:39:42.036]                   {
[17:39:42.036]                     {
[17:39:42.036]                       {
[17:39:42.036]                         base::local({
[17:39:42.036]                           has_future <- base::requireNamespace("future", 
[17:39:42.036]                             quietly = TRUE)
[17:39:42.036]                           if (has_future) {
[17:39:42.036]                             ns <- base::getNamespace("future")
[17:39:42.036]                             version <- ns[[".package"]][["version"]]
[17:39:42.036]                             if (is.null(version)) 
[17:39:42.036]                               version <- utils::packageVersion("future")
[17:39:42.036]                           }
[17:39:42.036]                           else {
[17:39:42.036]                             version <- NULL
[17:39:42.036]                           }
[17:39:42.036]                           if (!has_future || version < "1.8.0") {
[17:39:42.036]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.036]                               "", base::R.version$version.string), 
[17:39:42.036]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.036]                                 base::R.version$platform, 8 * 
[17:39:42.036]                                   base::.Machine$sizeof.pointer), 
[17:39:42.036]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.036]                                 "release", "version")], collapse = " "), 
[17:39:42.036]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.036]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.036]                               info)
[17:39:42.036]                             info <- base::paste(info, collapse = "; ")
[17:39:42.036]                             if (!has_future) {
[17:39:42.036]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.036]                                 info)
[17:39:42.036]                             }
[17:39:42.036]                             else {
[17:39:42.036]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.036]                                 info, version)
[17:39:42.036]                             }
[17:39:42.036]                             base::stop(msg)
[17:39:42.036]                           }
[17:39:42.036]                         })
[17:39:42.036]                       }
[17:39:42.036]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.036]                       base::options(mc.cores = 1L)
[17:39:42.036]                     }
[17:39:42.036]                     base::local({
[17:39:42.036]                       for (pkg in "stats") {
[17:39:42.036]                         base::loadNamespace(pkg)
[17:39:42.036]                         base::library(pkg, character.only = TRUE)
[17:39:42.036]                       }
[17:39:42.036]                     })
[17:39:42.036]                   }
[17:39:42.036]                   ...future.strategy.old <- future::plan("list")
[17:39:42.036]                   options(future.plan = NULL)
[17:39:42.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.036]                 }
[17:39:42.036]                 ...future.workdir <- getwd()
[17:39:42.036]             }
[17:39:42.036]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.036]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.036]         }
[17:39:42.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.036]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.036]             base::names(...future.oldOptions))
[17:39:42.036]     }
[17:39:42.036]     if (FALSE) {
[17:39:42.036]     }
[17:39:42.036]     else {
[17:39:42.036]         if (TRUE) {
[17:39:42.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.036]                 open = "w")
[17:39:42.036]         }
[17:39:42.036]         else {
[17:39:42.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.036]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.036]         }
[17:39:42.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.036]             base::sink(type = "output", split = FALSE)
[17:39:42.036]             base::close(...future.stdout)
[17:39:42.036]         }, add = TRUE)
[17:39:42.036]     }
[17:39:42.036]     ...future.frame <- base::sys.nframe()
[17:39:42.036]     ...future.conditions <- base::list()
[17:39:42.036]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.036]     if (FALSE) {
[17:39:42.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.036]     }
[17:39:42.036]     ...future.result <- base::tryCatch({
[17:39:42.036]         base::withCallingHandlers({
[17:39:42.036]             ...future.value <- base::withVisible(base::local({
[17:39:42.036]                 ...future.makeSendCondition <- base::local({
[17:39:42.036]                   sendCondition <- NULL
[17:39:42.036]                   function(frame = 1L) {
[17:39:42.036]                     if (is.function(sendCondition)) 
[17:39:42.036]                       return(sendCondition)
[17:39:42.036]                     ns <- getNamespace("parallel")
[17:39:42.036]                     if (exists("sendData", mode = "function", 
[17:39:42.036]                       envir = ns)) {
[17:39:42.036]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.036]                         envir = ns)
[17:39:42.036]                       envir <- sys.frame(frame)
[17:39:42.036]                       master <- NULL
[17:39:42.036]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.036]                         !identical(envir, emptyenv())) {
[17:39:42.036]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.036]                           inherits = FALSE)) {
[17:39:42.036]                           master <- get("master", mode = "list", 
[17:39:42.036]                             envir = envir, inherits = FALSE)
[17:39:42.036]                           if (inherits(master, c("SOCKnode", 
[17:39:42.036]                             "SOCK0node"))) {
[17:39:42.036]                             sendCondition <<- function(cond) {
[17:39:42.036]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.036]                                 success = TRUE)
[17:39:42.036]                               parallel_sendData(master, data)
[17:39:42.036]                             }
[17:39:42.036]                             return(sendCondition)
[17:39:42.036]                           }
[17:39:42.036]                         }
[17:39:42.036]                         frame <- frame + 1L
[17:39:42.036]                         envir <- sys.frame(frame)
[17:39:42.036]                       }
[17:39:42.036]                     }
[17:39:42.036]                     sendCondition <<- function(cond) NULL
[17:39:42.036]                   }
[17:39:42.036]                 })
[17:39:42.036]                 withCallingHandlers({
[17:39:42.036]                   {
[17:39:42.036]                     lm(weight ~ group - 1)
[17:39:42.036]                   }
[17:39:42.036]                 }, immediateCondition = function(cond) {
[17:39:42.036]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.036]                   sendCondition(cond)
[17:39:42.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.036]                   {
[17:39:42.036]                     inherits <- base::inherits
[17:39:42.036]                     invokeRestart <- base::invokeRestart
[17:39:42.036]                     is.null <- base::is.null
[17:39:42.036]                     muffled <- FALSE
[17:39:42.036]                     if (inherits(cond, "message")) {
[17:39:42.036]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.036]                       if (muffled) 
[17:39:42.036]                         invokeRestart("muffleMessage")
[17:39:42.036]                     }
[17:39:42.036]                     else if (inherits(cond, "warning")) {
[17:39:42.036]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.036]                       if (muffled) 
[17:39:42.036]                         invokeRestart("muffleWarning")
[17:39:42.036]                     }
[17:39:42.036]                     else if (inherits(cond, "condition")) {
[17:39:42.036]                       if (!is.null(pattern)) {
[17:39:42.036]                         computeRestarts <- base::computeRestarts
[17:39:42.036]                         grepl <- base::grepl
[17:39:42.036]                         restarts <- computeRestarts(cond)
[17:39:42.036]                         for (restart in restarts) {
[17:39:42.036]                           name <- restart$name
[17:39:42.036]                           if (is.null(name)) 
[17:39:42.036]                             next
[17:39:42.036]                           if (!grepl(pattern, name)) 
[17:39:42.036]                             next
[17:39:42.036]                           invokeRestart(restart)
[17:39:42.036]                           muffled <- TRUE
[17:39:42.036]                           break
[17:39:42.036]                         }
[17:39:42.036]                       }
[17:39:42.036]                     }
[17:39:42.036]                     invisible(muffled)
[17:39:42.036]                   }
[17:39:42.036]                   muffleCondition(cond)
[17:39:42.036]                 })
[17:39:42.036]             }))
[17:39:42.036]             future::FutureResult(value = ...future.value$value, 
[17:39:42.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.036]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.036]                     ...future.globalenv.names))
[17:39:42.036]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.036]         }, condition = base::local({
[17:39:42.036]             c <- base::c
[17:39:42.036]             inherits <- base::inherits
[17:39:42.036]             invokeRestart <- base::invokeRestart
[17:39:42.036]             length <- base::length
[17:39:42.036]             list <- base::list
[17:39:42.036]             seq.int <- base::seq.int
[17:39:42.036]             signalCondition <- base::signalCondition
[17:39:42.036]             sys.calls <- base::sys.calls
[17:39:42.036]             `[[` <- base::`[[`
[17:39:42.036]             `+` <- base::`+`
[17:39:42.036]             `<<-` <- base::`<<-`
[17:39:42.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.036]                   3L)]
[17:39:42.036]             }
[17:39:42.036]             function(cond) {
[17:39:42.036]                 is_error <- inherits(cond, "error")
[17:39:42.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.036]                   NULL)
[17:39:42.036]                 if (is_error) {
[17:39:42.036]                   sessionInformation <- function() {
[17:39:42.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.036]                       search = base::search(), system = base::Sys.info())
[17:39:42.036]                   }
[17:39:42.036]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.036]                     cond$call), session = sessionInformation(), 
[17:39:42.036]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.036]                   signalCondition(cond)
[17:39:42.036]                 }
[17:39:42.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.036]                 "immediateCondition"))) {
[17:39:42.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.036]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.036]                   if (TRUE && !signal) {
[17:39:42.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.036]                     {
[17:39:42.036]                       inherits <- base::inherits
[17:39:42.036]                       invokeRestart <- base::invokeRestart
[17:39:42.036]                       is.null <- base::is.null
[17:39:42.036]                       muffled <- FALSE
[17:39:42.036]                       if (inherits(cond, "message")) {
[17:39:42.036]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.036]                         if (muffled) 
[17:39:42.036]                           invokeRestart("muffleMessage")
[17:39:42.036]                       }
[17:39:42.036]                       else if (inherits(cond, "warning")) {
[17:39:42.036]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.036]                         if (muffled) 
[17:39:42.036]                           invokeRestart("muffleWarning")
[17:39:42.036]                       }
[17:39:42.036]                       else if (inherits(cond, "condition")) {
[17:39:42.036]                         if (!is.null(pattern)) {
[17:39:42.036]                           computeRestarts <- base::computeRestarts
[17:39:42.036]                           grepl <- base::grepl
[17:39:42.036]                           restarts <- computeRestarts(cond)
[17:39:42.036]                           for (restart in restarts) {
[17:39:42.036]                             name <- restart$name
[17:39:42.036]                             if (is.null(name)) 
[17:39:42.036]                               next
[17:39:42.036]                             if (!grepl(pattern, name)) 
[17:39:42.036]                               next
[17:39:42.036]                             invokeRestart(restart)
[17:39:42.036]                             muffled <- TRUE
[17:39:42.036]                             break
[17:39:42.036]                           }
[17:39:42.036]                         }
[17:39:42.036]                       }
[17:39:42.036]                       invisible(muffled)
[17:39:42.036]                     }
[17:39:42.036]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.036]                   }
[17:39:42.036]                 }
[17:39:42.036]                 else {
[17:39:42.036]                   if (TRUE) {
[17:39:42.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.036]                     {
[17:39:42.036]                       inherits <- base::inherits
[17:39:42.036]                       invokeRestart <- base::invokeRestart
[17:39:42.036]                       is.null <- base::is.null
[17:39:42.036]                       muffled <- FALSE
[17:39:42.036]                       if (inherits(cond, "message")) {
[17:39:42.036]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.036]                         if (muffled) 
[17:39:42.036]                           invokeRestart("muffleMessage")
[17:39:42.036]                       }
[17:39:42.036]                       else if (inherits(cond, "warning")) {
[17:39:42.036]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.036]                         if (muffled) 
[17:39:42.036]                           invokeRestart("muffleWarning")
[17:39:42.036]                       }
[17:39:42.036]                       else if (inherits(cond, "condition")) {
[17:39:42.036]                         if (!is.null(pattern)) {
[17:39:42.036]                           computeRestarts <- base::computeRestarts
[17:39:42.036]                           grepl <- base::grepl
[17:39:42.036]                           restarts <- computeRestarts(cond)
[17:39:42.036]                           for (restart in restarts) {
[17:39:42.036]                             name <- restart$name
[17:39:42.036]                             if (is.null(name)) 
[17:39:42.036]                               next
[17:39:42.036]                             if (!grepl(pattern, name)) 
[17:39:42.036]                               next
[17:39:42.036]                             invokeRestart(restart)
[17:39:42.036]                             muffled <- TRUE
[17:39:42.036]                             break
[17:39:42.036]                           }
[17:39:42.036]                         }
[17:39:42.036]                       }
[17:39:42.036]                       invisible(muffled)
[17:39:42.036]                     }
[17:39:42.036]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.036]                   }
[17:39:42.036]                 }
[17:39:42.036]             }
[17:39:42.036]         }))
[17:39:42.036]     }, error = function(ex) {
[17:39:42.036]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.036]                 ...future.rng), started = ...future.startTime, 
[17:39:42.036]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.036]             version = "1.8"), class = "FutureResult")
[17:39:42.036]     }, finally = {
[17:39:42.036]         if (!identical(...future.workdir, getwd())) 
[17:39:42.036]             setwd(...future.workdir)
[17:39:42.036]         {
[17:39:42.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.036]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.036]             }
[17:39:42.036]             base::options(...future.oldOptions)
[17:39:42.036]             if (.Platform$OS.type == "windows") {
[17:39:42.036]                 old_names <- names(...future.oldEnvVars)
[17:39:42.036]                 envs <- base::Sys.getenv()
[17:39:42.036]                 names <- names(envs)
[17:39:42.036]                 common <- intersect(names, old_names)
[17:39:42.036]                 added <- setdiff(names, old_names)
[17:39:42.036]                 removed <- setdiff(old_names, names)
[17:39:42.036]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.036]                   envs[common]]
[17:39:42.036]                 NAMES <- toupper(changed)
[17:39:42.036]                 args <- list()
[17:39:42.036]                 for (kk in seq_along(NAMES)) {
[17:39:42.036]                   name <- changed[[kk]]
[17:39:42.036]                   NAME <- NAMES[[kk]]
[17:39:42.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.036]                     next
[17:39:42.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.036]                 }
[17:39:42.036]                 NAMES <- toupper(added)
[17:39:42.036]                 for (kk in seq_along(NAMES)) {
[17:39:42.036]                   name <- added[[kk]]
[17:39:42.036]                   NAME <- NAMES[[kk]]
[17:39:42.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.036]                     next
[17:39:42.036]                   args[[name]] <- ""
[17:39:42.036]                 }
[17:39:42.036]                 NAMES <- toupper(removed)
[17:39:42.036]                 for (kk in seq_along(NAMES)) {
[17:39:42.036]                   name <- removed[[kk]]
[17:39:42.036]                   NAME <- NAMES[[kk]]
[17:39:42.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.036]                     next
[17:39:42.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.036]                 }
[17:39:42.036]                 if (length(args) > 0) 
[17:39:42.036]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.036]             }
[17:39:42.036]             else {
[17:39:42.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.036]             }
[17:39:42.036]             {
[17:39:42.036]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.036]                   0L) {
[17:39:42.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.036]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.036]                   base::options(opts)
[17:39:42.036]                 }
[17:39:42.036]                 {
[17:39:42.036]                   {
[17:39:42.036]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.036]                     NULL
[17:39:42.036]                   }
[17:39:42.036]                   options(future.plan = NULL)
[17:39:42.036]                   if (is.na(NA_character_)) 
[17:39:42.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.036]                     .init = FALSE)
[17:39:42.036]                 }
[17:39:42.036]             }
[17:39:42.036]         }
[17:39:42.036]     })
[17:39:42.036]     if (TRUE) {
[17:39:42.036]         base::sink(type = "output", split = FALSE)
[17:39:42.036]         if (TRUE) {
[17:39:42.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.036]         }
[17:39:42.036]         else {
[17:39:42.036]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.036]         }
[17:39:42.036]         base::close(...future.stdout)
[17:39:42.036]         ...future.stdout <- NULL
[17:39:42.036]     }
[17:39:42.036]     ...future.result$conditions <- ...future.conditions
[17:39:42.036]     ...future.result$finished <- base::Sys.time()
[17:39:42.036]     ...future.result
[17:39:42.036] }
[17:39:42.039] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:39:42.039] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:39:42.039] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:39:42.040] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:39:42.040] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:39:42.040] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:39:42.041] MultisessionFuture started
[17:39:42.041] - Launch lazy future ... done
[17:39:42.041] run() for ‘MultisessionFuture’ ... done
[17:39:42.041] result() for ClusterFuture ...
[17:39:42.041] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.042] - Validating connection of MultisessionFuture
[17:39:42.087] - received message: FutureResult
[17:39:42.087] - Received FutureResult
[17:39:42.087] - Erased future from FutureRegistry
[17:39:42.087] result() for ClusterFuture ...
[17:39:42.087] - result already collected: FutureResult
[17:39:42.088] result() for ClusterFuture ... done
[17:39:42.088] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.088] result() for ClusterFuture ... done
[17:39:42.088] result() for ClusterFuture ...
[17:39:42.088] - result already collected: FutureResult
[17:39:42.088] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:42.090] getGlobalsAndPackages() ...
[17:39:42.091] Searching for globals...
[17:39:42.092] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:42.093] Searching for globals ... DONE
[17:39:42.093] Resolving globals: FALSE
[17:39:42.093] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:42.094] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:42.094] - globals: [2] ‘weight’, ‘group’
[17:39:42.094] - packages: [1] ‘stats’
[17:39:42.094] getGlobalsAndPackages() ... DONE
[17:39:42.094] run() for ‘Future’ ...
[17:39:42.095] - state: ‘created’
[17:39:42.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.110]   - Field: ‘node’
[17:39:42.110]   - Field: ‘label’
[17:39:42.110]   - Field: ‘local’
[17:39:42.110]   - Field: ‘owner’
[17:39:42.110]   - Field: ‘envir’
[17:39:42.110]   - Field: ‘workers’
[17:39:42.110]   - Field: ‘packages’
[17:39:42.110]   - Field: ‘gc’
[17:39:42.111]   - Field: ‘conditions’
[17:39:42.111]   - Field: ‘persistent’
[17:39:42.111]   - Field: ‘expr’
[17:39:42.111]   - Field: ‘uuid’
[17:39:42.111]   - Field: ‘seed’
[17:39:42.111]   - Field: ‘version’
[17:39:42.111]   - Field: ‘result’
[17:39:42.111]   - Field: ‘asynchronous’
[17:39:42.112]   - Field: ‘calls’
[17:39:42.112]   - Field: ‘globals’
[17:39:42.112]   - Field: ‘stdout’
[17:39:42.112]   - Field: ‘earlySignal’
[17:39:42.112]   - Field: ‘lazy’
[17:39:42.112]   - Field: ‘state’
[17:39:42.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.112] - Launch lazy future ...
[17:39:42.113] Packages needed by the future expression (n = 1): ‘stats’
[17:39:42.113] Packages needed by future strategies (n = 0): <none>
[17:39:42.114] {
[17:39:42.114]     {
[17:39:42.114]         {
[17:39:42.114]             ...future.startTime <- base::Sys.time()
[17:39:42.114]             {
[17:39:42.114]                 {
[17:39:42.114]                   {
[17:39:42.114]                     {
[17:39:42.114]                       {
[17:39:42.114]                         base::local({
[17:39:42.114]                           has_future <- base::requireNamespace("future", 
[17:39:42.114]                             quietly = TRUE)
[17:39:42.114]                           if (has_future) {
[17:39:42.114]                             ns <- base::getNamespace("future")
[17:39:42.114]                             version <- ns[[".package"]][["version"]]
[17:39:42.114]                             if (is.null(version)) 
[17:39:42.114]                               version <- utils::packageVersion("future")
[17:39:42.114]                           }
[17:39:42.114]                           else {
[17:39:42.114]                             version <- NULL
[17:39:42.114]                           }
[17:39:42.114]                           if (!has_future || version < "1.8.0") {
[17:39:42.114]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.114]                               "", base::R.version$version.string), 
[17:39:42.114]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.114]                                 base::R.version$platform, 8 * 
[17:39:42.114]                                   base::.Machine$sizeof.pointer), 
[17:39:42.114]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.114]                                 "release", "version")], collapse = " "), 
[17:39:42.114]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.114]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.114]                               info)
[17:39:42.114]                             info <- base::paste(info, collapse = "; ")
[17:39:42.114]                             if (!has_future) {
[17:39:42.114]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.114]                                 info)
[17:39:42.114]                             }
[17:39:42.114]                             else {
[17:39:42.114]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.114]                                 info, version)
[17:39:42.114]                             }
[17:39:42.114]                             base::stop(msg)
[17:39:42.114]                           }
[17:39:42.114]                         })
[17:39:42.114]                       }
[17:39:42.114]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.114]                       base::options(mc.cores = 1L)
[17:39:42.114]                     }
[17:39:42.114]                     base::local({
[17:39:42.114]                       for (pkg in "stats") {
[17:39:42.114]                         base::loadNamespace(pkg)
[17:39:42.114]                         base::library(pkg, character.only = TRUE)
[17:39:42.114]                       }
[17:39:42.114]                     })
[17:39:42.114]                   }
[17:39:42.114]                   ...future.strategy.old <- future::plan("list")
[17:39:42.114]                   options(future.plan = NULL)
[17:39:42.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.114]                 }
[17:39:42.114]                 ...future.workdir <- getwd()
[17:39:42.114]             }
[17:39:42.114]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.114]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.114]         }
[17:39:42.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.114]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.114]             base::names(...future.oldOptions))
[17:39:42.114]     }
[17:39:42.114]     if (FALSE) {
[17:39:42.114]     }
[17:39:42.114]     else {
[17:39:42.114]         if (TRUE) {
[17:39:42.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.114]                 open = "w")
[17:39:42.114]         }
[17:39:42.114]         else {
[17:39:42.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.114]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.114]         }
[17:39:42.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.114]             base::sink(type = "output", split = FALSE)
[17:39:42.114]             base::close(...future.stdout)
[17:39:42.114]         }, add = TRUE)
[17:39:42.114]     }
[17:39:42.114]     ...future.frame <- base::sys.nframe()
[17:39:42.114]     ...future.conditions <- base::list()
[17:39:42.114]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.114]     if (FALSE) {
[17:39:42.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.114]     }
[17:39:42.114]     ...future.result <- base::tryCatch({
[17:39:42.114]         base::withCallingHandlers({
[17:39:42.114]             ...future.value <- base::withVisible(base::local({
[17:39:42.114]                 ...future.makeSendCondition <- base::local({
[17:39:42.114]                   sendCondition <- NULL
[17:39:42.114]                   function(frame = 1L) {
[17:39:42.114]                     if (is.function(sendCondition)) 
[17:39:42.114]                       return(sendCondition)
[17:39:42.114]                     ns <- getNamespace("parallel")
[17:39:42.114]                     if (exists("sendData", mode = "function", 
[17:39:42.114]                       envir = ns)) {
[17:39:42.114]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.114]                         envir = ns)
[17:39:42.114]                       envir <- sys.frame(frame)
[17:39:42.114]                       master <- NULL
[17:39:42.114]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.114]                         !identical(envir, emptyenv())) {
[17:39:42.114]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.114]                           inherits = FALSE)) {
[17:39:42.114]                           master <- get("master", mode = "list", 
[17:39:42.114]                             envir = envir, inherits = FALSE)
[17:39:42.114]                           if (inherits(master, c("SOCKnode", 
[17:39:42.114]                             "SOCK0node"))) {
[17:39:42.114]                             sendCondition <<- function(cond) {
[17:39:42.114]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.114]                                 success = TRUE)
[17:39:42.114]                               parallel_sendData(master, data)
[17:39:42.114]                             }
[17:39:42.114]                             return(sendCondition)
[17:39:42.114]                           }
[17:39:42.114]                         }
[17:39:42.114]                         frame <- frame + 1L
[17:39:42.114]                         envir <- sys.frame(frame)
[17:39:42.114]                       }
[17:39:42.114]                     }
[17:39:42.114]                     sendCondition <<- function(cond) NULL
[17:39:42.114]                   }
[17:39:42.114]                 })
[17:39:42.114]                 withCallingHandlers({
[17:39:42.114]                   {
[17:39:42.114]                     lm(weight ~ group - 1)
[17:39:42.114]                   }
[17:39:42.114]                 }, immediateCondition = function(cond) {
[17:39:42.114]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.114]                   sendCondition(cond)
[17:39:42.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.114]                   {
[17:39:42.114]                     inherits <- base::inherits
[17:39:42.114]                     invokeRestart <- base::invokeRestart
[17:39:42.114]                     is.null <- base::is.null
[17:39:42.114]                     muffled <- FALSE
[17:39:42.114]                     if (inherits(cond, "message")) {
[17:39:42.114]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.114]                       if (muffled) 
[17:39:42.114]                         invokeRestart("muffleMessage")
[17:39:42.114]                     }
[17:39:42.114]                     else if (inherits(cond, "warning")) {
[17:39:42.114]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.114]                       if (muffled) 
[17:39:42.114]                         invokeRestart("muffleWarning")
[17:39:42.114]                     }
[17:39:42.114]                     else if (inherits(cond, "condition")) {
[17:39:42.114]                       if (!is.null(pattern)) {
[17:39:42.114]                         computeRestarts <- base::computeRestarts
[17:39:42.114]                         grepl <- base::grepl
[17:39:42.114]                         restarts <- computeRestarts(cond)
[17:39:42.114]                         for (restart in restarts) {
[17:39:42.114]                           name <- restart$name
[17:39:42.114]                           if (is.null(name)) 
[17:39:42.114]                             next
[17:39:42.114]                           if (!grepl(pattern, name)) 
[17:39:42.114]                             next
[17:39:42.114]                           invokeRestart(restart)
[17:39:42.114]                           muffled <- TRUE
[17:39:42.114]                           break
[17:39:42.114]                         }
[17:39:42.114]                       }
[17:39:42.114]                     }
[17:39:42.114]                     invisible(muffled)
[17:39:42.114]                   }
[17:39:42.114]                   muffleCondition(cond)
[17:39:42.114]                 })
[17:39:42.114]             }))
[17:39:42.114]             future::FutureResult(value = ...future.value$value, 
[17:39:42.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.114]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.114]                     ...future.globalenv.names))
[17:39:42.114]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.114]         }, condition = base::local({
[17:39:42.114]             c <- base::c
[17:39:42.114]             inherits <- base::inherits
[17:39:42.114]             invokeRestart <- base::invokeRestart
[17:39:42.114]             length <- base::length
[17:39:42.114]             list <- base::list
[17:39:42.114]             seq.int <- base::seq.int
[17:39:42.114]             signalCondition <- base::signalCondition
[17:39:42.114]             sys.calls <- base::sys.calls
[17:39:42.114]             `[[` <- base::`[[`
[17:39:42.114]             `+` <- base::`+`
[17:39:42.114]             `<<-` <- base::`<<-`
[17:39:42.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.114]                   3L)]
[17:39:42.114]             }
[17:39:42.114]             function(cond) {
[17:39:42.114]                 is_error <- inherits(cond, "error")
[17:39:42.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.114]                   NULL)
[17:39:42.114]                 if (is_error) {
[17:39:42.114]                   sessionInformation <- function() {
[17:39:42.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.114]                       search = base::search(), system = base::Sys.info())
[17:39:42.114]                   }
[17:39:42.114]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.114]                     cond$call), session = sessionInformation(), 
[17:39:42.114]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.114]                   signalCondition(cond)
[17:39:42.114]                 }
[17:39:42.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.114]                 "immediateCondition"))) {
[17:39:42.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.114]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.114]                   if (TRUE && !signal) {
[17:39:42.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.114]                     {
[17:39:42.114]                       inherits <- base::inherits
[17:39:42.114]                       invokeRestart <- base::invokeRestart
[17:39:42.114]                       is.null <- base::is.null
[17:39:42.114]                       muffled <- FALSE
[17:39:42.114]                       if (inherits(cond, "message")) {
[17:39:42.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.114]                         if (muffled) 
[17:39:42.114]                           invokeRestart("muffleMessage")
[17:39:42.114]                       }
[17:39:42.114]                       else if (inherits(cond, "warning")) {
[17:39:42.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.114]                         if (muffled) 
[17:39:42.114]                           invokeRestart("muffleWarning")
[17:39:42.114]                       }
[17:39:42.114]                       else if (inherits(cond, "condition")) {
[17:39:42.114]                         if (!is.null(pattern)) {
[17:39:42.114]                           computeRestarts <- base::computeRestarts
[17:39:42.114]                           grepl <- base::grepl
[17:39:42.114]                           restarts <- computeRestarts(cond)
[17:39:42.114]                           for (restart in restarts) {
[17:39:42.114]                             name <- restart$name
[17:39:42.114]                             if (is.null(name)) 
[17:39:42.114]                               next
[17:39:42.114]                             if (!grepl(pattern, name)) 
[17:39:42.114]                               next
[17:39:42.114]                             invokeRestart(restart)
[17:39:42.114]                             muffled <- TRUE
[17:39:42.114]                             break
[17:39:42.114]                           }
[17:39:42.114]                         }
[17:39:42.114]                       }
[17:39:42.114]                       invisible(muffled)
[17:39:42.114]                     }
[17:39:42.114]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.114]                   }
[17:39:42.114]                 }
[17:39:42.114]                 else {
[17:39:42.114]                   if (TRUE) {
[17:39:42.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.114]                     {
[17:39:42.114]                       inherits <- base::inherits
[17:39:42.114]                       invokeRestart <- base::invokeRestart
[17:39:42.114]                       is.null <- base::is.null
[17:39:42.114]                       muffled <- FALSE
[17:39:42.114]                       if (inherits(cond, "message")) {
[17:39:42.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.114]                         if (muffled) 
[17:39:42.114]                           invokeRestart("muffleMessage")
[17:39:42.114]                       }
[17:39:42.114]                       else if (inherits(cond, "warning")) {
[17:39:42.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.114]                         if (muffled) 
[17:39:42.114]                           invokeRestart("muffleWarning")
[17:39:42.114]                       }
[17:39:42.114]                       else if (inherits(cond, "condition")) {
[17:39:42.114]                         if (!is.null(pattern)) {
[17:39:42.114]                           computeRestarts <- base::computeRestarts
[17:39:42.114]                           grepl <- base::grepl
[17:39:42.114]                           restarts <- computeRestarts(cond)
[17:39:42.114]                           for (restart in restarts) {
[17:39:42.114]                             name <- restart$name
[17:39:42.114]                             if (is.null(name)) 
[17:39:42.114]                               next
[17:39:42.114]                             if (!grepl(pattern, name)) 
[17:39:42.114]                               next
[17:39:42.114]                             invokeRestart(restart)
[17:39:42.114]                             muffled <- TRUE
[17:39:42.114]                             break
[17:39:42.114]                           }
[17:39:42.114]                         }
[17:39:42.114]                       }
[17:39:42.114]                       invisible(muffled)
[17:39:42.114]                     }
[17:39:42.114]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.114]                   }
[17:39:42.114]                 }
[17:39:42.114]             }
[17:39:42.114]         }))
[17:39:42.114]     }, error = function(ex) {
[17:39:42.114]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.114]                 ...future.rng), started = ...future.startTime, 
[17:39:42.114]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.114]             version = "1.8"), class = "FutureResult")
[17:39:42.114]     }, finally = {
[17:39:42.114]         if (!identical(...future.workdir, getwd())) 
[17:39:42.114]             setwd(...future.workdir)
[17:39:42.114]         {
[17:39:42.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.114]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.114]             }
[17:39:42.114]             base::options(...future.oldOptions)
[17:39:42.114]             if (.Platform$OS.type == "windows") {
[17:39:42.114]                 old_names <- names(...future.oldEnvVars)
[17:39:42.114]                 envs <- base::Sys.getenv()
[17:39:42.114]                 names <- names(envs)
[17:39:42.114]                 common <- intersect(names, old_names)
[17:39:42.114]                 added <- setdiff(names, old_names)
[17:39:42.114]                 removed <- setdiff(old_names, names)
[17:39:42.114]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.114]                   envs[common]]
[17:39:42.114]                 NAMES <- toupper(changed)
[17:39:42.114]                 args <- list()
[17:39:42.114]                 for (kk in seq_along(NAMES)) {
[17:39:42.114]                   name <- changed[[kk]]
[17:39:42.114]                   NAME <- NAMES[[kk]]
[17:39:42.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.114]                     next
[17:39:42.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.114]                 }
[17:39:42.114]                 NAMES <- toupper(added)
[17:39:42.114]                 for (kk in seq_along(NAMES)) {
[17:39:42.114]                   name <- added[[kk]]
[17:39:42.114]                   NAME <- NAMES[[kk]]
[17:39:42.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.114]                     next
[17:39:42.114]                   args[[name]] <- ""
[17:39:42.114]                 }
[17:39:42.114]                 NAMES <- toupper(removed)
[17:39:42.114]                 for (kk in seq_along(NAMES)) {
[17:39:42.114]                   name <- removed[[kk]]
[17:39:42.114]                   NAME <- NAMES[[kk]]
[17:39:42.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.114]                     next
[17:39:42.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.114]                 }
[17:39:42.114]                 if (length(args) > 0) 
[17:39:42.114]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.114]             }
[17:39:42.114]             else {
[17:39:42.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.114]             }
[17:39:42.114]             {
[17:39:42.114]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.114]                   0L) {
[17:39:42.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.114]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.114]                   base::options(opts)
[17:39:42.114]                 }
[17:39:42.114]                 {
[17:39:42.114]                   {
[17:39:42.114]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.114]                     NULL
[17:39:42.114]                   }
[17:39:42.114]                   options(future.plan = NULL)
[17:39:42.114]                   if (is.na(NA_character_)) 
[17:39:42.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.114]                     .init = FALSE)
[17:39:42.114]                 }
[17:39:42.114]             }
[17:39:42.114]         }
[17:39:42.114]     })
[17:39:42.114]     if (TRUE) {
[17:39:42.114]         base::sink(type = "output", split = FALSE)
[17:39:42.114]         if (TRUE) {
[17:39:42.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.114]         }
[17:39:42.114]         else {
[17:39:42.114]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.114]         }
[17:39:42.114]         base::close(...future.stdout)
[17:39:42.114]         ...future.stdout <- NULL
[17:39:42.114]     }
[17:39:42.114]     ...future.result$conditions <- ...future.conditions
[17:39:42.114]     ...future.result$finished <- base::Sys.time()
[17:39:42.114]     ...future.result
[17:39:42.114] }
[17:39:42.117] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:39:42.117] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:39:42.117] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:39:42.117] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:39:42.118] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:39:42.118] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:39:42.119] MultisessionFuture started
[17:39:42.119] - Launch lazy future ... done
[17:39:42.119] run() for ‘MultisessionFuture’ ... done
[17:39:42.119] result() for ClusterFuture ...
[17:39:42.122] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.122] - Validating connection of MultisessionFuture
[17:39:42.163] - received message: FutureResult
[17:39:42.163] - Received FutureResult
[17:39:42.163] - Erased future from FutureRegistry
[17:39:42.164] result() for ClusterFuture ...
[17:39:42.164] - result already collected: FutureResult
[17:39:42.164] result() for ClusterFuture ... done
[17:39:42.164] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.164] result() for ClusterFuture ... done
[17:39:42.164] result() for ClusterFuture ...
[17:39:42.164] - result already collected: FutureResult
[17:39:42.164] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:42.166] getGlobalsAndPackages() ...
[17:39:42.166] Searching for globals...
[17:39:42.168] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:42.168] Searching for globals ... DONE
[17:39:42.168] Resolving globals: FALSE
[17:39:42.168] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:42.169] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:42.169] - globals: [2] ‘weight’, ‘group’
[17:39:42.169] - packages: [1] ‘stats’
[17:39:42.169] getGlobalsAndPackages() ... DONE
[17:39:42.169] run() for ‘Future’ ...
[17:39:42.169] - state: ‘created’
[17:39:42.169] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.183] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.184]   - Field: ‘node’
[17:39:42.184]   - Field: ‘label’
[17:39:42.184]   - Field: ‘local’
[17:39:42.184]   - Field: ‘owner’
[17:39:42.184]   - Field: ‘envir’
[17:39:42.184]   - Field: ‘workers’
[17:39:42.184]   - Field: ‘packages’
[17:39:42.184]   - Field: ‘gc’
[17:39:42.184]   - Field: ‘conditions’
[17:39:42.184]   - Field: ‘persistent’
[17:39:42.185]   - Field: ‘expr’
[17:39:42.185]   - Field: ‘uuid’
[17:39:42.185]   - Field: ‘seed’
[17:39:42.185]   - Field: ‘version’
[17:39:42.185]   - Field: ‘result’
[17:39:42.185]   - Field: ‘asynchronous’
[17:39:42.185]   - Field: ‘calls’
[17:39:42.185]   - Field: ‘globals’
[17:39:42.185]   - Field: ‘stdout’
[17:39:42.185]   - Field: ‘earlySignal’
[17:39:42.185]   - Field: ‘lazy’
[17:39:42.186]   - Field: ‘state’
[17:39:42.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.186] - Launch lazy future ...
[17:39:42.186] Packages needed by the future expression (n = 1): ‘stats’
[17:39:42.186] Packages needed by future strategies (n = 0): <none>
[17:39:42.187] {
[17:39:42.187]     {
[17:39:42.187]         {
[17:39:42.187]             ...future.startTime <- base::Sys.time()
[17:39:42.187]             {
[17:39:42.187]                 {
[17:39:42.187]                   {
[17:39:42.187]                     {
[17:39:42.187]                       {
[17:39:42.187]                         base::local({
[17:39:42.187]                           has_future <- base::requireNamespace("future", 
[17:39:42.187]                             quietly = TRUE)
[17:39:42.187]                           if (has_future) {
[17:39:42.187]                             ns <- base::getNamespace("future")
[17:39:42.187]                             version <- ns[[".package"]][["version"]]
[17:39:42.187]                             if (is.null(version)) 
[17:39:42.187]                               version <- utils::packageVersion("future")
[17:39:42.187]                           }
[17:39:42.187]                           else {
[17:39:42.187]                             version <- NULL
[17:39:42.187]                           }
[17:39:42.187]                           if (!has_future || version < "1.8.0") {
[17:39:42.187]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.187]                               "", base::R.version$version.string), 
[17:39:42.187]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.187]                                 base::R.version$platform, 8 * 
[17:39:42.187]                                   base::.Machine$sizeof.pointer), 
[17:39:42.187]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.187]                                 "release", "version")], collapse = " "), 
[17:39:42.187]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.187]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.187]                               info)
[17:39:42.187]                             info <- base::paste(info, collapse = "; ")
[17:39:42.187]                             if (!has_future) {
[17:39:42.187]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.187]                                 info)
[17:39:42.187]                             }
[17:39:42.187]                             else {
[17:39:42.187]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.187]                                 info, version)
[17:39:42.187]                             }
[17:39:42.187]                             base::stop(msg)
[17:39:42.187]                           }
[17:39:42.187]                         })
[17:39:42.187]                       }
[17:39:42.187]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.187]                       base::options(mc.cores = 1L)
[17:39:42.187]                     }
[17:39:42.187]                     base::local({
[17:39:42.187]                       for (pkg in "stats") {
[17:39:42.187]                         base::loadNamespace(pkg)
[17:39:42.187]                         base::library(pkg, character.only = TRUE)
[17:39:42.187]                       }
[17:39:42.187]                     })
[17:39:42.187]                   }
[17:39:42.187]                   ...future.strategy.old <- future::plan("list")
[17:39:42.187]                   options(future.plan = NULL)
[17:39:42.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.187]                 }
[17:39:42.187]                 ...future.workdir <- getwd()
[17:39:42.187]             }
[17:39:42.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.187]         }
[17:39:42.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.187]             base::names(...future.oldOptions))
[17:39:42.187]     }
[17:39:42.187]     if (FALSE) {
[17:39:42.187]     }
[17:39:42.187]     else {
[17:39:42.187]         if (TRUE) {
[17:39:42.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.187]                 open = "w")
[17:39:42.187]         }
[17:39:42.187]         else {
[17:39:42.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.187]         }
[17:39:42.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.187]             base::sink(type = "output", split = FALSE)
[17:39:42.187]             base::close(...future.stdout)
[17:39:42.187]         }, add = TRUE)
[17:39:42.187]     }
[17:39:42.187]     ...future.frame <- base::sys.nframe()
[17:39:42.187]     ...future.conditions <- base::list()
[17:39:42.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.187]     if (FALSE) {
[17:39:42.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.187]     }
[17:39:42.187]     ...future.result <- base::tryCatch({
[17:39:42.187]         base::withCallingHandlers({
[17:39:42.187]             ...future.value <- base::withVisible(base::local({
[17:39:42.187]                 ...future.makeSendCondition <- base::local({
[17:39:42.187]                   sendCondition <- NULL
[17:39:42.187]                   function(frame = 1L) {
[17:39:42.187]                     if (is.function(sendCondition)) 
[17:39:42.187]                       return(sendCondition)
[17:39:42.187]                     ns <- getNamespace("parallel")
[17:39:42.187]                     if (exists("sendData", mode = "function", 
[17:39:42.187]                       envir = ns)) {
[17:39:42.187]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.187]                         envir = ns)
[17:39:42.187]                       envir <- sys.frame(frame)
[17:39:42.187]                       master <- NULL
[17:39:42.187]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.187]                         !identical(envir, emptyenv())) {
[17:39:42.187]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.187]                           inherits = FALSE)) {
[17:39:42.187]                           master <- get("master", mode = "list", 
[17:39:42.187]                             envir = envir, inherits = FALSE)
[17:39:42.187]                           if (inherits(master, c("SOCKnode", 
[17:39:42.187]                             "SOCK0node"))) {
[17:39:42.187]                             sendCondition <<- function(cond) {
[17:39:42.187]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.187]                                 success = TRUE)
[17:39:42.187]                               parallel_sendData(master, data)
[17:39:42.187]                             }
[17:39:42.187]                             return(sendCondition)
[17:39:42.187]                           }
[17:39:42.187]                         }
[17:39:42.187]                         frame <- frame + 1L
[17:39:42.187]                         envir <- sys.frame(frame)
[17:39:42.187]                       }
[17:39:42.187]                     }
[17:39:42.187]                     sendCondition <<- function(cond) NULL
[17:39:42.187]                   }
[17:39:42.187]                 })
[17:39:42.187]                 withCallingHandlers({
[17:39:42.187]                   {
[17:39:42.187]                     lm(weight ~ group - 1)
[17:39:42.187]                   }
[17:39:42.187]                 }, immediateCondition = function(cond) {
[17:39:42.187]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.187]                   sendCondition(cond)
[17:39:42.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.187]                   {
[17:39:42.187]                     inherits <- base::inherits
[17:39:42.187]                     invokeRestart <- base::invokeRestart
[17:39:42.187]                     is.null <- base::is.null
[17:39:42.187]                     muffled <- FALSE
[17:39:42.187]                     if (inherits(cond, "message")) {
[17:39:42.187]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.187]                       if (muffled) 
[17:39:42.187]                         invokeRestart("muffleMessage")
[17:39:42.187]                     }
[17:39:42.187]                     else if (inherits(cond, "warning")) {
[17:39:42.187]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.187]                       if (muffled) 
[17:39:42.187]                         invokeRestart("muffleWarning")
[17:39:42.187]                     }
[17:39:42.187]                     else if (inherits(cond, "condition")) {
[17:39:42.187]                       if (!is.null(pattern)) {
[17:39:42.187]                         computeRestarts <- base::computeRestarts
[17:39:42.187]                         grepl <- base::grepl
[17:39:42.187]                         restarts <- computeRestarts(cond)
[17:39:42.187]                         for (restart in restarts) {
[17:39:42.187]                           name <- restart$name
[17:39:42.187]                           if (is.null(name)) 
[17:39:42.187]                             next
[17:39:42.187]                           if (!grepl(pattern, name)) 
[17:39:42.187]                             next
[17:39:42.187]                           invokeRestart(restart)
[17:39:42.187]                           muffled <- TRUE
[17:39:42.187]                           break
[17:39:42.187]                         }
[17:39:42.187]                       }
[17:39:42.187]                     }
[17:39:42.187]                     invisible(muffled)
[17:39:42.187]                   }
[17:39:42.187]                   muffleCondition(cond)
[17:39:42.187]                 })
[17:39:42.187]             }))
[17:39:42.187]             future::FutureResult(value = ...future.value$value, 
[17:39:42.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.187]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.187]                     ...future.globalenv.names))
[17:39:42.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.187]         }, condition = base::local({
[17:39:42.187]             c <- base::c
[17:39:42.187]             inherits <- base::inherits
[17:39:42.187]             invokeRestart <- base::invokeRestart
[17:39:42.187]             length <- base::length
[17:39:42.187]             list <- base::list
[17:39:42.187]             seq.int <- base::seq.int
[17:39:42.187]             signalCondition <- base::signalCondition
[17:39:42.187]             sys.calls <- base::sys.calls
[17:39:42.187]             `[[` <- base::`[[`
[17:39:42.187]             `+` <- base::`+`
[17:39:42.187]             `<<-` <- base::`<<-`
[17:39:42.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.187]                   3L)]
[17:39:42.187]             }
[17:39:42.187]             function(cond) {
[17:39:42.187]                 is_error <- inherits(cond, "error")
[17:39:42.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.187]                   NULL)
[17:39:42.187]                 if (is_error) {
[17:39:42.187]                   sessionInformation <- function() {
[17:39:42.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.187]                       search = base::search(), system = base::Sys.info())
[17:39:42.187]                   }
[17:39:42.187]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.187]                     cond$call), session = sessionInformation(), 
[17:39:42.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.187]                   signalCondition(cond)
[17:39:42.187]                 }
[17:39:42.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.187]                 "immediateCondition"))) {
[17:39:42.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.187]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.187]                   if (TRUE && !signal) {
[17:39:42.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.187]                     {
[17:39:42.187]                       inherits <- base::inherits
[17:39:42.187]                       invokeRestart <- base::invokeRestart
[17:39:42.187]                       is.null <- base::is.null
[17:39:42.187]                       muffled <- FALSE
[17:39:42.187]                       if (inherits(cond, "message")) {
[17:39:42.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.187]                         if (muffled) 
[17:39:42.187]                           invokeRestart("muffleMessage")
[17:39:42.187]                       }
[17:39:42.187]                       else if (inherits(cond, "warning")) {
[17:39:42.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.187]                         if (muffled) 
[17:39:42.187]                           invokeRestart("muffleWarning")
[17:39:42.187]                       }
[17:39:42.187]                       else if (inherits(cond, "condition")) {
[17:39:42.187]                         if (!is.null(pattern)) {
[17:39:42.187]                           computeRestarts <- base::computeRestarts
[17:39:42.187]                           grepl <- base::grepl
[17:39:42.187]                           restarts <- computeRestarts(cond)
[17:39:42.187]                           for (restart in restarts) {
[17:39:42.187]                             name <- restart$name
[17:39:42.187]                             if (is.null(name)) 
[17:39:42.187]                               next
[17:39:42.187]                             if (!grepl(pattern, name)) 
[17:39:42.187]                               next
[17:39:42.187]                             invokeRestart(restart)
[17:39:42.187]                             muffled <- TRUE
[17:39:42.187]                             break
[17:39:42.187]                           }
[17:39:42.187]                         }
[17:39:42.187]                       }
[17:39:42.187]                       invisible(muffled)
[17:39:42.187]                     }
[17:39:42.187]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.187]                   }
[17:39:42.187]                 }
[17:39:42.187]                 else {
[17:39:42.187]                   if (TRUE) {
[17:39:42.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.187]                     {
[17:39:42.187]                       inherits <- base::inherits
[17:39:42.187]                       invokeRestart <- base::invokeRestart
[17:39:42.187]                       is.null <- base::is.null
[17:39:42.187]                       muffled <- FALSE
[17:39:42.187]                       if (inherits(cond, "message")) {
[17:39:42.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.187]                         if (muffled) 
[17:39:42.187]                           invokeRestart("muffleMessage")
[17:39:42.187]                       }
[17:39:42.187]                       else if (inherits(cond, "warning")) {
[17:39:42.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.187]                         if (muffled) 
[17:39:42.187]                           invokeRestart("muffleWarning")
[17:39:42.187]                       }
[17:39:42.187]                       else if (inherits(cond, "condition")) {
[17:39:42.187]                         if (!is.null(pattern)) {
[17:39:42.187]                           computeRestarts <- base::computeRestarts
[17:39:42.187]                           grepl <- base::grepl
[17:39:42.187]                           restarts <- computeRestarts(cond)
[17:39:42.187]                           for (restart in restarts) {
[17:39:42.187]                             name <- restart$name
[17:39:42.187]                             if (is.null(name)) 
[17:39:42.187]                               next
[17:39:42.187]                             if (!grepl(pattern, name)) 
[17:39:42.187]                               next
[17:39:42.187]                             invokeRestart(restart)
[17:39:42.187]                             muffled <- TRUE
[17:39:42.187]                             break
[17:39:42.187]                           }
[17:39:42.187]                         }
[17:39:42.187]                       }
[17:39:42.187]                       invisible(muffled)
[17:39:42.187]                     }
[17:39:42.187]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.187]                   }
[17:39:42.187]                 }
[17:39:42.187]             }
[17:39:42.187]         }))
[17:39:42.187]     }, error = function(ex) {
[17:39:42.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.187]                 ...future.rng), started = ...future.startTime, 
[17:39:42.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.187]             version = "1.8"), class = "FutureResult")
[17:39:42.187]     }, finally = {
[17:39:42.187]         if (!identical(...future.workdir, getwd())) 
[17:39:42.187]             setwd(...future.workdir)
[17:39:42.187]         {
[17:39:42.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.187]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.187]             }
[17:39:42.187]             base::options(...future.oldOptions)
[17:39:42.187]             if (.Platform$OS.type == "windows") {
[17:39:42.187]                 old_names <- names(...future.oldEnvVars)
[17:39:42.187]                 envs <- base::Sys.getenv()
[17:39:42.187]                 names <- names(envs)
[17:39:42.187]                 common <- intersect(names, old_names)
[17:39:42.187]                 added <- setdiff(names, old_names)
[17:39:42.187]                 removed <- setdiff(old_names, names)
[17:39:42.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.187]                   envs[common]]
[17:39:42.187]                 NAMES <- toupper(changed)
[17:39:42.187]                 args <- list()
[17:39:42.187]                 for (kk in seq_along(NAMES)) {
[17:39:42.187]                   name <- changed[[kk]]
[17:39:42.187]                   NAME <- NAMES[[kk]]
[17:39:42.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.187]                     next
[17:39:42.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.187]                 }
[17:39:42.187]                 NAMES <- toupper(added)
[17:39:42.187]                 for (kk in seq_along(NAMES)) {
[17:39:42.187]                   name <- added[[kk]]
[17:39:42.187]                   NAME <- NAMES[[kk]]
[17:39:42.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.187]                     next
[17:39:42.187]                   args[[name]] <- ""
[17:39:42.187]                 }
[17:39:42.187]                 NAMES <- toupper(removed)
[17:39:42.187]                 for (kk in seq_along(NAMES)) {
[17:39:42.187]                   name <- removed[[kk]]
[17:39:42.187]                   NAME <- NAMES[[kk]]
[17:39:42.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.187]                     next
[17:39:42.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.187]                 }
[17:39:42.187]                 if (length(args) > 0) 
[17:39:42.187]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.187]             }
[17:39:42.187]             else {
[17:39:42.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.187]             }
[17:39:42.187]             {
[17:39:42.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.187]                   0L) {
[17:39:42.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.187]                   base::options(opts)
[17:39:42.187]                 }
[17:39:42.187]                 {
[17:39:42.187]                   {
[17:39:42.187]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.187]                     NULL
[17:39:42.187]                   }
[17:39:42.187]                   options(future.plan = NULL)
[17:39:42.187]                   if (is.na(NA_character_)) 
[17:39:42.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.187]                     .init = FALSE)
[17:39:42.187]                 }
[17:39:42.187]             }
[17:39:42.187]         }
[17:39:42.187]     })
[17:39:42.187]     if (TRUE) {
[17:39:42.187]         base::sink(type = "output", split = FALSE)
[17:39:42.187]         if (TRUE) {
[17:39:42.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.187]         }
[17:39:42.187]         else {
[17:39:42.187]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.187]         }
[17:39:42.187]         base::close(...future.stdout)
[17:39:42.187]         ...future.stdout <- NULL
[17:39:42.187]     }
[17:39:42.187]     ...future.result$conditions <- ...future.conditions
[17:39:42.187]     ...future.result$finished <- base::Sys.time()
[17:39:42.187]     ...future.result
[17:39:42.187] }
[17:39:42.189] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:39:42.190] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:39:42.190] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:39:42.190] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:39:42.190] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:39:42.190] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:39:42.191] MultisessionFuture started
[17:39:42.191] - Launch lazy future ... done
[17:39:42.191] run() for ‘MultisessionFuture’ ... done
[17:39:42.191] result() for ClusterFuture ...
[17:39:42.191] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.192] - Validating connection of MultisessionFuture
[17:39:42.235] - received message: FutureResult
[17:39:42.236] - Received FutureResult
[17:39:42.236] - Erased future from FutureRegistry
[17:39:42.236] result() for ClusterFuture ...
[17:39:42.236] - result already collected: FutureResult
[17:39:42.236] result() for ClusterFuture ... done
[17:39:42.236] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.236] result() for ClusterFuture ... done
[17:39:42.236] result() for ClusterFuture ...
[17:39:42.236] - result already collected: FutureResult
[17:39:42.237] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[17:39:42.238] getGlobalsAndPackages() ...
[17:39:42.238] Searching for globals...
[17:39:42.240] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[17:39:42.240] Searching for globals ... DONE
[17:39:42.240] Resolving globals: FALSE
[17:39:42.241] The total size of the 2 globals is 896 bytes (896 bytes)
[17:39:42.241] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[17:39:42.241] - globals: [2] ‘weight’, ‘group’
[17:39:42.241] - packages: [1] ‘stats’
[17:39:42.241] getGlobalsAndPackages() ... DONE
[17:39:42.242] run() for ‘Future’ ...
[17:39:42.242] - state: ‘created’
[17:39:42.242] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.257]   - Field: ‘node’
[17:39:42.257]   - Field: ‘label’
[17:39:42.257]   - Field: ‘local’
[17:39:42.257]   - Field: ‘owner’
[17:39:42.257]   - Field: ‘envir’
[17:39:42.257]   - Field: ‘workers’
[17:39:42.257]   - Field: ‘packages’
[17:39:42.257]   - Field: ‘gc’
[17:39:42.257]   - Field: ‘conditions’
[17:39:42.257]   - Field: ‘persistent’
[17:39:42.258]   - Field: ‘expr’
[17:39:42.258]   - Field: ‘uuid’
[17:39:42.258]   - Field: ‘seed’
[17:39:42.258]   - Field: ‘version’
[17:39:42.258]   - Field: ‘result’
[17:39:42.258]   - Field: ‘asynchronous’
[17:39:42.258]   - Field: ‘calls’
[17:39:42.258]   - Field: ‘globals’
[17:39:42.258]   - Field: ‘stdout’
[17:39:42.258]   - Field: ‘earlySignal’
[17:39:42.258]   - Field: ‘lazy’
[17:39:42.258]   - Field: ‘state’
[17:39:42.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.259] - Launch lazy future ...
[17:39:42.259] Packages needed by the future expression (n = 1): ‘stats’
[17:39:42.259] Packages needed by future strategies (n = 0): <none>
[17:39:42.260] {
[17:39:42.260]     {
[17:39:42.260]         {
[17:39:42.260]             ...future.startTime <- base::Sys.time()
[17:39:42.260]             {
[17:39:42.260]                 {
[17:39:42.260]                   {
[17:39:42.260]                     {
[17:39:42.260]                       {
[17:39:42.260]                         base::local({
[17:39:42.260]                           has_future <- base::requireNamespace("future", 
[17:39:42.260]                             quietly = TRUE)
[17:39:42.260]                           if (has_future) {
[17:39:42.260]                             ns <- base::getNamespace("future")
[17:39:42.260]                             version <- ns[[".package"]][["version"]]
[17:39:42.260]                             if (is.null(version)) 
[17:39:42.260]                               version <- utils::packageVersion("future")
[17:39:42.260]                           }
[17:39:42.260]                           else {
[17:39:42.260]                             version <- NULL
[17:39:42.260]                           }
[17:39:42.260]                           if (!has_future || version < "1.8.0") {
[17:39:42.260]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.260]                               "", base::R.version$version.string), 
[17:39:42.260]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.260]                                 base::R.version$platform, 8 * 
[17:39:42.260]                                   base::.Machine$sizeof.pointer), 
[17:39:42.260]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.260]                                 "release", "version")], collapse = " "), 
[17:39:42.260]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.260]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.260]                               info)
[17:39:42.260]                             info <- base::paste(info, collapse = "; ")
[17:39:42.260]                             if (!has_future) {
[17:39:42.260]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.260]                                 info)
[17:39:42.260]                             }
[17:39:42.260]                             else {
[17:39:42.260]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.260]                                 info, version)
[17:39:42.260]                             }
[17:39:42.260]                             base::stop(msg)
[17:39:42.260]                           }
[17:39:42.260]                         })
[17:39:42.260]                       }
[17:39:42.260]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.260]                       base::options(mc.cores = 1L)
[17:39:42.260]                     }
[17:39:42.260]                     base::local({
[17:39:42.260]                       for (pkg in "stats") {
[17:39:42.260]                         base::loadNamespace(pkg)
[17:39:42.260]                         base::library(pkg, character.only = TRUE)
[17:39:42.260]                       }
[17:39:42.260]                     })
[17:39:42.260]                   }
[17:39:42.260]                   ...future.strategy.old <- future::plan("list")
[17:39:42.260]                   options(future.plan = NULL)
[17:39:42.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.260]                 }
[17:39:42.260]                 ...future.workdir <- getwd()
[17:39:42.260]             }
[17:39:42.260]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.260]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.260]         }
[17:39:42.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.260]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.260]             base::names(...future.oldOptions))
[17:39:42.260]     }
[17:39:42.260]     if (FALSE) {
[17:39:42.260]     }
[17:39:42.260]     else {
[17:39:42.260]         if (TRUE) {
[17:39:42.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.260]                 open = "w")
[17:39:42.260]         }
[17:39:42.260]         else {
[17:39:42.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.260]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.260]         }
[17:39:42.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.260]             base::sink(type = "output", split = FALSE)
[17:39:42.260]             base::close(...future.stdout)
[17:39:42.260]         }, add = TRUE)
[17:39:42.260]     }
[17:39:42.260]     ...future.frame <- base::sys.nframe()
[17:39:42.260]     ...future.conditions <- base::list()
[17:39:42.260]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.260]     if (FALSE) {
[17:39:42.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.260]     }
[17:39:42.260]     ...future.result <- base::tryCatch({
[17:39:42.260]         base::withCallingHandlers({
[17:39:42.260]             ...future.value <- base::withVisible(base::local({
[17:39:42.260]                 ...future.makeSendCondition <- base::local({
[17:39:42.260]                   sendCondition <- NULL
[17:39:42.260]                   function(frame = 1L) {
[17:39:42.260]                     if (is.function(sendCondition)) 
[17:39:42.260]                       return(sendCondition)
[17:39:42.260]                     ns <- getNamespace("parallel")
[17:39:42.260]                     if (exists("sendData", mode = "function", 
[17:39:42.260]                       envir = ns)) {
[17:39:42.260]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.260]                         envir = ns)
[17:39:42.260]                       envir <- sys.frame(frame)
[17:39:42.260]                       master <- NULL
[17:39:42.260]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.260]                         !identical(envir, emptyenv())) {
[17:39:42.260]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.260]                           inherits = FALSE)) {
[17:39:42.260]                           master <- get("master", mode = "list", 
[17:39:42.260]                             envir = envir, inherits = FALSE)
[17:39:42.260]                           if (inherits(master, c("SOCKnode", 
[17:39:42.260]                             "SOCK0node"))) {
[17:39:42.260]                             sendCondition <<- function(cond) {
[17:39:42.260]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.260]                                 success = TRUE)
[17:39:42.260]                               parallel_sendData(master, data)
[17:39:42.260]                             }
[17:39:42.260]                             return(sendCondition)
[17:39:42.260]                           }
[17:39:42.260]                         }
[17:39:42.260]                         frame <- frame + 1L
[17:39:42.260]                         envir <- sys.frame(frame)
[17:39:42.260]                       }
[17:39:42.260]                     }
[17:39:42.260]                     sendCondition <<- function(cond) NULL
[17:39:42.260]                   }
[17:39:42.260]                 })
[17:39:42.260]                 withCallingHandlers({
[17:39:42.260]                   {
[17:39:42.260]                     lm(weight ~ group - 1)
[17:39:42.260]                   }
[17:39:42.260]                 }, immediateCondition = function(cond) {
[17:39:42.260]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.260]                   sendCondition(cond)
[17:39:42.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.260]                   {
[17:39:42.260]                     inherits <- base::inherits
[17:39:42.260]                     invokeRestart <- base::invokeRestart
[17:39:42.260]                     is.null <- base::is.null
[17:39:42.260]                     muffled <- FALSE
[17:39:42.260]                     if (inherits(cond, "message")) {
[17:39:42.260]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.260]                       if (muffled) 
[17:39:42.260]                         invokeRestart("muffleMessage")
[17:39:42.260]                     }
[17:39:42.260]                     else if (inherits(cond, "warning")) {
[17:39:42.260]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.260]                       if (muffled) 
[17:39:42.260]                         invokeRestart("muffleWarning")
[17:39:42.260]                     }
[17:39:42.260]                     else if (inherits(cond, "condition")) {
[17:39:42.260]                       if (!is.null(pattern)) {
[17:39:42.260]                         computeRestarts <- base::computeRestarts
[17:39:42.260]                         grepl <- base::grepl
[17:39:42.260]                         restarts <- computeRestarts(cond)
[17:39:42.260]                         for (restart in restarts) {
[17:39:42.260]                           name <- restart$name
[17:39:42.260]                           if (is.null(name)) 
[17:39:42.260]                             next
[17:39:42.260]                           if (!grepl(pattern, name)) 
[17:39:42.260]                             next
[17:39:42.260]                           invokeRestart(restart)
[17:39:42.260]                           muffled <- TRUE
[17:39:42.260]                           break
[17:39:42.260]                         }
[17:39:42.260]                       }
[17:39:42.260]                     }
[17:39:42.260]                     invisible(muffled)
[17:39:42.260]                   }
[17:39:42.260]                   muffleCondition(cond)
[17:39:42.260]                 })
[17:39:42.260]             }))
[17:39:42.260]             future::FutureResult(value = ...future.value$value, 
[17:39:42.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.260]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.260]                     ...future.globalenv.names))
[17:39:42.260]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.260]         }, condition = base::local({
[17:39:42.260]             c <- base::c
[17:39:42.260]             inherits <- base::inherits
[17:39:42.260]             invokeRestart <- base::invokeRestart
[17:39:42.260]             length <- base::length
[17:39:42.260]             list <- base::list
[17:39:42.260]             seq.int <- base::seq.int
[17:39:42.260]             signalCondition <- base::signalCondition
[17:39:42.260]             sys.calls <- base::sys.calls
[17:39:42.260]             `[[` <- base::`[[`
[17:39:42.260]             `+` <- base::`+`
[17:39:42.260]             `<<-` <- base::`<<-`
[17:39:42.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.260]                   3L)]
[17:39:42.260]             }
[17:39:42.260]             function(cond) {
[17:39:42.260]                 is_error <- inherits(cond, "error")
[17:39:42.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.260]                   NULL)
[17:39:42.260]                 if (is_error) {
[17:39:42.260]                   sessionInformation <- function() {
[17:39:42.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.260]                       search = base::search(), system = base::Sys.info())
[17:39:42.260]                   }
[17:39:42.260]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.260]                     cond$call), session = sessionInformation(), 
[17:39:42.260]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.260]                   signalCondition(cond)
[17:39:42.260]                 }
[17:39:42.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.260]                 "immediateCondition"))) {
[17:39:42.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.260]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.260]                   if (TRUE && !signal) {
[17:39:42.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.260]                     {
[17:39:42.260]                       inherits <- base::inherits
[17:39:42.260]                       invokeRestart <- base::invokeRestart
[17:39:42.260]                       is.null <- base::is.null
[17:39:42.260]                       muffled <- FALSE
[17:39:42.260]                       if (inherits(cond, "message")) {
[17:39:42.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.260]                         if (muffled) 
[17:39:42.260]                           invokeRestart("muffleMessage")
[17:39:42.260]                       }
[17:39:42.260]                       else if (inherits(cond, "warning")) {
[17:39:42.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.260]                         if (muffled) 
[17:39:42.260]                           invokeRestart("muffleWarning")
[17:39:42.260]                       }
[17:39:42.260]                       else if (inherits(cond, "condition")) {
[17:39:42.260]                         if (!is.null(pattern)) {
[17:39:42.260]                           computeRestarts <- base::computeRestarts
[17:39:42.260]                           grepl <- base::grepl
[17:39:42.260]                           restarts <- computeRestarts(cond)
[17:39:42.260]                           for (restart in restarts) {
[17:39:42.260]                             name <- restart$name
[17:39:42.260]                             if (is.null(name)) 
[17:39:42.260]                               next
[17:39:42.260]                             if (!grepl(pattern, name)) 
[17:39:42.260]                               next
[17:39:42.260]                             invokeRestart(restart)
[17:39:42.260]                             muffled <- TRUE
[17:39:42.260]                             break
[17:39:42.260]                           }
[17:39:42.260]                         }
[17:39:42.260]                       }
[17:39:42.260]                       invisible(muffled)
[17:39:42.260]                     }
[17:39:42.260]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.260]                   }
[17:39:42.260]                 }
[17:39:42.260]                 else {
[17:39:42.260]                   if (TRUE) {
[17:39:42.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.260]                     {
[17:39:42.260]                       inherits <- base::inherits
[17:39:42.260]                       invokeRestart <- base::invokeRestart
[17:39:42.260]                       is.null <- base::is.null
[17:39:42.260]                       muffled <- FALSE
[17:39:42.260]                       if (inherits(cond, "message")) {
[17:39:42.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.260]                         if (muffled) 
[17:39:42.260]                           invokeRestart("muffleMessage")
[17:39:42.260]                       }
[17:39:42.260]                       else if (inherits(cond, "warning")) {
[17:39:42.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.260]                         if (muffled) 
[17:39:42.260]                           invokeRestart("muffleWarning")
[17:39:42.260]                       }
[17:39:42.260]                       else if (inherits(cond, "condition")) {
[17:39:42.260]                         if (!is.null(pattern)) {
[17:39:42.260]                           computeRestarts <- base::computeRestarts
[17:39:42.260]                           grepl <- base::grepl
[17:39:42.260]                           restarts <- computeRestarts(cond)
[17:39:42.260]                           for (restart in restarts) {
[17:39:42.260]                             name <- restart$name
[17:39:42.260]                             if (is.null(name)) 
[17:39:42.260]                               next
[17:39:42.260]                             if (!grepl(pattern, name)) 
[17:39:42.260]                               next
[17:39:42.260]                             invokeRestart(restart)
[17:39:42.260]                             muffled <- TRUE
[17:39:42.260]                             break
[17:39:42.260]                           }
[17:39:42.260]                         }
[17:39:42.260]                       }
[17:39:42.260]                       invisible(muffled)
[17:39:42.260]                     }
[17:39:42.260]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.260]                   }
[17:39:42.260]                 }
[17:39:42.260]             }
[17:39:42.260]         }))
[17:39:42.260]     }, error = function(ex) {
[17:39:42.260]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.260]                 ...future.rng), started = ...future.startTime, 
[17:39:42.260]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.260]             version = "1.8"), class = "FutureResult")
[17:39:42.260]     }, finally = {
[17:39:42.260]         if (!identical(...future.workdir, getwd())) 
[17:39:42.260]             setwd(...future.workdir)
[17:39:42.260]         {
[17:39:42.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.260]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.260]             }
[17:39:42.260]             base::options(...future.oldOptions)
[17:39:42.260]             if (.Platform$OS.type == "windows") {
[17:39:42.260]                 old_names <- names(...future.oldEnvVars)
[17:39:42.260]                 envs <- base::Sys.getenv()
[17:39:42.260]                 names <- names(envs)
[17:39:42.260]                 common <- intersect(names, old_names)
[17:39:42.260]                 added <- setdiff(names, old_names)
[17:39:42.260]                 removed <- setdiff(old_names, names)
[17:39:42.260]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.260]                   envs[common]]
[17:39:42.260]                 NAMES <- toupper(changed)
[17:39:42.260]                 args <- list()
[17:39:42.260]                 for (kk in seq_along(NAMES)) {
[17:39:42.260]                   name <- changed[[kk]]
[17:39:42.260]                   NAME <- NAMES[[kk]]
[17:39:42.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.260]                     next
[17:39:42.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.260]                 }
[17:39:42.260]                 NAMES <- toupper(added)
[17:39:42.260]                 for (kk in seq_along(NAMES)) {
[17:39:42.260]                   name <- added[[kk]]
[17:39:42.260]                   NAME <- NAMES[[kk]]
[17:39:42.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.260]                     next
[17:39:42.260]                   args[[name]] <- ""
[17:39:42.260]                 }
[17:39:42.260]                 NAMES <- toupper(removed)
[17:39:42.260]                 for (kk in seq_along(NAMES)) {
[17:39:42.260]                   name <- removed[[kk]]
[17:39:42.260]                   NAME <- NAMES[[kk]]
[17:39:42.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.260]                     next
[17:39:42.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.260]                 }
[17:39:42.260]                 if (length(args) > 0) 
[17:39:42.260]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.260]             }
[17:39:42.260]             else {
[17:39:42.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.260]             }
[17:39:42.260]             {
[17:39:42.260]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.260]                   0L) {
[17:39:42.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.260]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.260]                   base::options(opts)
[17:39:42.260]                 }
[17:39:42.260]                 {
[17:39:42.260]                   {
[17:39:42.260]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.260]                     NULL
[17:39:42.260]                   }
[17:39:42.260]                   options(future.plan = NULL)
[17:39:42.260]                   if (is.na(NA_character_)) 
[17:39:42.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.260]                     .init = FALSE)
[17:39:42.260]                 }
[17:39:42.260]             }
[17:39:42.260]         }
[17:39:42.260]     })
[17:39:42.260]     if (TRUE) {
[17:39:42.260]         base::sink(type = "output", split = FALSE)
[17:39:42.260]         if (TRUE) {
[17:39:42.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.260]         }
[17:39:42.260]         else {
[17:39:42.260]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.260]         }
[17:39:42.260]         base::close(...future.stdout)
[17:39:42.260]         ...future.stdout <- NULL
[17:39:42.260]     }
[17:39:42.260]     ...future.result$conditions <- ...future.conditions
[17:39:42.260]     ...future.result$finished <- base::Sys.time()
[17:39:42.260]     ...future.result
[17:39:42.260] }
[17:39:42.262] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[17:39:42.262] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[17:39:42.263] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[17:39:42.263] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[17:39:42.263] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[17:39:42.263] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[17:39:42.264] MultisessionFuture started
[17:39:42.264] - Launch lazy future ... done
[17:39:42.264] run() for ‘MultisessionFuture’ ... done
[17:39:42.264] result() for ClusterFuture ...
[17:39:42.264] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.264] - Validating connection of MultisessionFuture
[17:39:42.307] - received message: FutureResult
[17:39:42.307] - Received FutureResult
[17:39:42.307] - Erased future from FutureRegistry
[17:39:42.308] result() for ClusterFuture ...
[17:39:42.308] - result already collected: FutureResult
[17:39:42.308] result() for ClusterFuture ... done
[17:39:42.308] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.308] result() for ClusterFuture ... done
[17:39:42.308] result() for ClusterFuture ...
[17:39:42.308] - result already collected: FutureResult
[17:39:42.308] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[17:39:42.310] getGlobalsAndPackages() ...
[17:39:42.310] Searching for globals...
[17:39:42.311] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:39:42.311] Searching for globals ... DONE
[17:39:42.312] Resolving globals: FALSE
[17:39:42.312] The total size of the 1 globals is 96 bytes (96 bytes)
[17:39:42.312] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:39:42.312] - globals: [1] ‘x’
[17:39:42.313] - packages: [1] ‘stats’
[17:39:42.313] getGlobalsAndPackages() ... DONE
[17:39:42.313] run() for ‘Future’ ...
[17:39:42.313] - state: ‘created’
[17:39:42.313] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.327] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.328]   - Field: ‘node’
[17:39:42.328]   - Field: ‘label’
[17:39:42.328]   - Field: ‘local’
[17:39:42.328]   - Field: ‘owner’
[17:39:42.328]   - Field: ‘envir’
[17:39:42.329]   - Field: ‘workers’
[17:39:42.329]   - Field: ‘packages’
[17:39:42.329]   - Field: ‘gc’
[17:39:42.329]   - Field: ‘conditions’
[17:39:42.329]   - Field: ‘persistent’
[17:39:42.329]   - Field: ‘expr’
[17:39:42.329]   - Field: ‘uuid’
[17:39:42.329]   - Field: ‘seed’
[17:39:42.329]   - Field: ‘version’
[17:39:42.329]   - Field: ‘result’
[17:39:42.329]   - Field: ‘asynchronous’
[17:39:42.330]   - Field: ‘calls’
[17:39:42.330]   - Field: ‘globals’
[17:39:42.330]   - Field: ‘stdout’
[17:39:42.330]   - Field: ‘earlySignal’
[17:39:42.330]   - Field: ‘lazy’
[17:39:42.330]   - Field: ‘state’
[17:39:42.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.330] - Launch lazy future ...
[17:39:42.330] Packages needed by the future expression (n = 1): ‘stats’
[17:39:42.331] Packages needed by future strategies (n = 0): <none>
[17:39:42.331] {
[17:39:42.331]     {
[17:39:42.331]         {
[17:39:42.331]             ...future.startTime <- base::Sys.time()
[17:39:42.331]             {
[17:39:42.331]                 {
[17:39:42.331]                   {
[17:39:42.331]                     {
[17:39:42.331]                       {
[17:39:42.331]                         base::local({
[17:39:42.331]                           has_future <- base::requireNamespace("future", 
[17:39:42.331]                             quietly = TRUE)
[17:39:42.331]                           if (has_future) {
[17:39:42.331]                             ns <- base::getNamespace("future")
[17:39:42.331]                             version <- ns[[".package"]][["version"]]
[17:39:42.331]                             if (is.null(version)) 
[17:39:42.331]                               version <- utils::packageVersion("future")
[17:39:42.331]                           }
[17:39:42.331]                           else {
[17:39:42.331]                             version <- NULL
[17:39:42.331]                           }
[17:39:42.331]                           if (!has_future || version < "1.8.0") {
[17:39:42.331]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.331]                               "", base::R.version$version.string), 
[17:39:42.331]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.331]                                 base::R.version$platform, 8 * 
[17:39:42.331]                                   base::.Machine$sizeof.pointer), 
[17:39:42.331]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.331]                                 "release", "version")], collapse = " "), 
[17:39:42.331]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.331]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.331]                               info)
[17:39:42.331]                             info <- base::paste(info, collapse = "; ")
[17:39:42.331]                             if (!has_future) {
[17:39:42.331]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.331]                                 info)
[17:39:42.331]                             }
[17:39:42.331]                             else {
[17:39:42.331]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.331]                                 info, version)
[17:39:42.331]                             }
[17:39:42.331]                             base::stop(msg)
[17:39:42.331]                           }
[17:39:42.331]                         })
[17:39:42.331]                       }
[17:39:42.331]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.331]                       base::options(mc.cores = 1L)
[17:39:42.331]                     }
[17:39:42.331]                     base::local({
[17:39:42.331]                       for (pkg in "stats") {
[17:39:42.331]                         base::loadNamespace(pkg)
[17:39:42.331]                         base::library(pkg, character.only = TRUE)
[17:39:42.331]                       }
[17:39:42.331]                     })
[17:39:42.331]                   }
[17:39:42.331]                   ...future.strategy.old <- future::plan("list")
[17:39:42.331]                   options(future.plan = NULL)
[17:39:42.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.331]                 }
[17:39:42.331]                 ...future.workdir <- getwd()
[17:39:42.331]             }
[17:39:42.331]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.331]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.331]         }
[17:39:42.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.331]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.331]             base::names(...future.oldOptions))
[17:39:42.331]     }
[17:39:42.331]     if (FALSE) {
[17:39:42.331]     }
[17:39:42.331]     else {
[17:39:42.331]         if (TRUE) {
[17:39:42.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.331]                 open = "w")
[17:39:42.331]         }
[17:39:42.331]         else {
[17:39:42.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.331]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.331]         }
[17:39:42.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.331]             base::sink(type = "output", split = FALSE)
[17:39:42.331]             base::close(...future.stdout)
[17:39:42.331]         }, add = TRUE)
[17:39:42.331]     }
[17:39:42.331]     ...future.frame <- base::sys.nframe()
[17:39:42.331]     ...future.conditions <- base::list()
[17:39:42.331]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.331]     if (FALSE) {
[17:39:42.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.331]     }
[17:39:42.331]     ...future.result <- base::tryCatch({
[17:39:42.331]         base::withCallingHandlers({
[17:39:42.331]             ...future.value <- base::withVisible(base::local({
[17:39:42.331]                 ...future.makeSendCondition <- base::local({
[17:39:42.331]                   sendCondition <- NULL
[17:39:42.331]                   function(frame = 1L) {
[17:39:42.331]                     if (is.function(sendCondition)) 
[17:39:42.331]                       return(sendCondition)
[17:39:42.331]                     ns <- getNamespace("parallel")
[17:39:42.331]                     if (exists("sendData", mode = "function", 
[17:39:42.331]                       envir = ns)) {
[17:39:42.331]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.331]                         envir = ns)
[17:39:42.331]                       envir <- sys.frame(frame)
[17:39:42.331]                       master <- NULL
[17:39:42.331]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.331]                         !identical(envir, emptyenv())) {
[17:39:42.331]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.331]                           inherits = FALSE)) {
[17:39:42.331]                           master <- get("master", mode = "list", 
[17:39:42.331]                             envir = envir, inherits = FALSE)
[17:39:42.331]                           if (inherits(master, c("SOCKnode", 
[17:39:42.331]                             "SOCK0node"))) {
[17:39:42.331]                             sendCondition <<- function(cond) {
[17:39:42.331]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.331]                                 success = TRUE)
[17:39:42.331]                               parallel_sendData(master, data)
[17:39:42.331]                             }
[17:39:42.331]                             return(sendCondition)
[17:39:42.331]                           }
[17:39:42.331]                         }
[17:39:42.331]                         frame <- frame + 1L
[17:39:42.331]                         envir <- sys.frame(frame)
[17:39:42.331]                       }
[17:39:42.331]                     }
[17:39:42.331]                     sendCondition <<- function(cond) NULL
[17:39:42.331]                   }
[17:39:42.331]                 })
[17:39:42.331]                 withCallingHandlers({
[17:39:42.331]                   {
[17:39:42.331]                     xtabs(~x)
[17:39:42.331]                   }
[17:39:42.331]                 }, immediateCondition = function(cond) {
[17:39:42.331]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.331]                   sendCondition(cond)
[17:39:42.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.331]                   {
[17:39:42.331]                     inherits <- base::inherits
[17:39:42.331]                     invokeRestart <- base::invokeRestart
[17:39:42.331]                     is.null <- base::is.null
[17:39:42.331]                     muffled <- FALSE
[17:39:42.331]                     if (inherits(cond, "message")) {
[17:39:42.331]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.331]                       if (muffled) 
[17:39:42.331]                         invokeRestart("muffleMessage")
[17:39:42.331]                     }
[17:39:42.331]                     else if (inherits(cond, "warning")) {
[17:39:42.331]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.331]                       if (muffled) 
[17:39:42.331]                         invokeRestart("muffleWarning")
[17:39:42.331]                     }
[17:39:42.331]                     else if (inherits(cond, "condition")) {
[17:39:42.331]                       if (!is.null(pattern)) {
[17:39:42.331]                         computeRestarts <- base::computeRestarts
[17:39:42.331]                         grepl <- base::grepl
[17:39:42.331]                         restarts <- computeRestarts(cond)
[17:39:42.331]                         for (restart in restarts) {
[17:39:42.331]                           name <- restart$name
[17:39:42.331]                           if (is.null(name)) 
[17:39:42.331]                             next
[17:39:42.331]                           if (!grepl(pattern, name)) 
[17:39:42.331]                             next
[17:39:42.331]                           invokeRestart(restart)
[17:39:42.331]                           muffled <- TRUE
[17:39:42.331]                           break
[17:39:42.331]                         }
[17:39:42.331]                       }
[17:39:42.331]                     }
[17:39:42.331]                     invisible(muffled)
[17:39:42.331]                   }
[17:39:42.331]                   muffleCondition(cond)
[17:39:42.331]                 })
[17:39:42.331]             }))
[17:39:42.331]             future::FutureResult(value = ...future.value$value, 
[17:39:42.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.331]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.331]                     ...future.globalenv.names))
[17:39:42.331]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.331]         }, condition = base::local({
[17:39:42.331]             c <- base::c
[17:39:42.331]             inherits <- base::inherits
[17:39:42.331]             invokeRestart <- base::invokeRestart
[17:39:42.331]             length <- base::length
[17:39:42.331]             list <- base::list
[17:39:42.331]             seq.int <- base::seq.int
[17:39:42.331]             signalCondition <- base::signalCondition
[17:39:42.331]             sys.calls <- base::sys.calls
[17:39:42.331]             `[[` <- base::`[[`
[17:39:42.331]             `+` <- base::`+`
[17:39:42.331]             `<<-` <- base::`<<-`
[17:39:42.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.331]                   3L)]
[17:39:42.331]             }
[17:39:42.331]             function(cond) {
[17:39:42.331]                 is_error <- inherits(cond, "error")
[17:39:42.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.331]                   NULL)
[17:39:42.331]                 if (is_error) {
[17:39:42.331]                   sessionInformation <- function() {
[17:39:42.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.331]                       search = base::search(), system = base::Sys.info())
[17:39:42.331]                   }
[17:39:42.331]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.331]                     cond$call), session = sessionInformation(), 
[17:39:42.331]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.331]                   signalCondition(cond)
[17:39:42.331]                 }
[17:39:42.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.331]                 "immediateCondition"))) {
[17:39:42.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.331]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.331]                   if (TRUE && !signal) {
[17:39:42.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.331]                     {
[17:39:42.331]                       inherits <- base::inherits
[17:39:42.331]                       invokeRestart <- base::invokeRestart
[17:39:42.331]                       is.null <- base::is.null
[17:39:42.331]                       muffled <- FALSE
[17:39:42.331]                       if (inherits(cond, "message")) {
[17:39:42.331]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.331]                         if (muffled) 
[17:39:42.331]                           invokeRestart("muffleMessage")
[17:39:42.331]                       }
[17:39:42.331]                       else if (inherits(cond, "warning")) {
[17:39:42.331]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.331]                         if (muffled) 
[17:39:42.331]                           invokeRestart("muffleWarning")
[17:39:42.331]                       }
[17:39:42.331]                       else if (inherits(cond, "condition")) {
[17:39:42.331]                         if (!is.null(pattern)) {
[17:39:42.331]                           computeRestarts <- base::computeRestarts
[17:39:42.331]                           grepl <- base::grepl
[17:39:42.331]                           restarts <- computeRestarts(cond)
[17:39:42.331]                           for (restart in restarts) {
[17:39:42.331]                             name <- restart$name
[17:39:42.331]                             if (is.null(name)) 
[17:39:42.331]                               next
[17:39:42.331]                             if (!grepl(pattern, name)) 
[17:39:42.331]                               next
[17:39:42.331]                             invokeRestart(restart)
[17:39:42.331]                             muffled <- TRUE
[17:39:42.331]                             break
[17:39:42.331]                           }
[17:39:42.331]                         }
[17:39:42.331]                       }
[17:39:42.331]                       invisible(muffled)
[17:39:42.331]                     }
[17:39:42.331]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.331]                   }
[17:39:42.331]                 }
[17:39:42.331]                 else {
[17:39:42.331]                   if (TRUE) {
[17:39:42.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.331]                     {
[17:39:42.331]                       inherits <- base::inherits
[17:39:42.331]                       invokeRestart <- base::invokeRestart
[17:39:42.331]                       is.null <- base::is.null
[17:39:42.331]                       muffled <- FALSE
[17:39:42.331]                       if (inherits(cond, "message")) {
[17:39:42.331]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.331]                         if (muffled) 
[17:39:42.331]                           invokeRestart("muffleMessage")
[17:39:42.331]                       }
[17:39:42.331]                       else if (inherits(cond, "warning")) {
[17:39:42.331]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.331]                         if (muffled) 
[17:39:42.331]                           invokeRestart("muffleWarning")
[17:39:42.331]                       }
[17:39:42.331]                       else if (inherits(cond, "condition")) {
[17:39:42.331]                         if (!is.null(pattern)) {
[17:39:42.331]                           computeRestarts <- base::computeRestarts
[17:39:42.331]                           grepl <- base::grepl
[17:39:42.331]                           restarts <- computeRestarts(cond)
[17:39:42.331]                           for (restart in restarts) {
[17:39:42.331]                             name <- restart$name
[17:39:42.331]                             if (is.null(name)) 
[17:39:42.331]                               next
[17:39:42.331]                             if (!grepl(pattern, name)) 
[17:39:42.331]                               next
[17:39:42.331]                             invokeRestart(restart)
[17:39:42.331]                             muffled <- TRUE
[17:39:42.331]                             break
[17:39:42.331]                           }
[17:39:42.331]                         }
[17:39:42.331]                       }
[17:39:42.331]                       invisible(muffled)
[17:39:42.331]                     }
[17:39:42.331]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.331]                   }
[17:39:42.331]                 }
[17:39:42.331]             }
[17:39:42.331]         }))
[17:39:42.331]     }, error = function(ex) {
[17:39:42.331]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.331]                 ...future.rng), started = ...future.startTime, 
[17:39:42.331]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.331]             version = "1.8"), class = "FutureResult")
[17:39:42.331]     }, finally = {
[17:39:42.331]         if (!identical(...future.workdir, getwd())) 
[17:39:42.331]             setwd(...future.workdir)
[17:39:42.331]         {
[17:39:42.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.331]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.331]             }
[17:39:42.331]             base::options(...future.oldOptions)
[17:39:42.331]             if (.Platform$OS.type == "windows") {
[17:39:42.331]                 old_names <- names(...future.oldEnvVars)
[17:39:42.331]                 envs <- base::Sys.getenv()
[17:39:42.331]                 names <- names(envs)
[17:39:42.331]                 common <- intersect(names, old_names)
[17:39:42.331]                 added <- setdiff(names, old_names)
[17:39:42.331]                 removed <- setdiff(old_names, names)
[17:39:42.331]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.331]                   envs[common]]
[17:39:42.331]                 NAMES <- toupper(changed)
[17:39:42.331]                 args <- list()
[17:39:42.331]                 for (kk in seq_along(NAMES)) {
[17:39:42.331]                   name <- changed[[kk]]
[17:39:42.331]                   NAME <- NAMES[[kk]]
[17:39:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.331]                     next
[17:39:42.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.331]                 }
[17:39:42.331]                 NAMES <- toupper(added)
[17:39:42.331]                 for (kk in seq_along(NAMES)) {
[17:39:42.331]                   name <- added[[kk]]
[17:39:42.331]                   NAME <- NAMES[[kk]]
[17:39:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.331]                     next
[17:39:42.331]                   args[[name]] <- ""
[17:39:42.331]                 }
[17:39:42.331]                 NAMES <- toupper(removed)
[17:39:42.331]                 for (kk in seq_along(NAMES)) {
[17:39:42.331]                   name <- removed[[kk]]
[17:39:42.331]                   NAME <- NAMES[[kk]]
[17:39:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.331]                     next
[17:39:42.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.331]                 }
[17:39:42.331]                 if (length(args) > 0) 
[17:39:42.331]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.331]             }
[17:39:42.331]             else {
[17:39:42.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.331]             }
[17:39:42.331]             {
[17:39:42.331]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.331]                   0L) {
[17:39:42.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.331]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.331]                   base::options(opts)
[17:39:42.331]                 }
[17:39:42.331]                 {
[17:39:42.331]                   {
[17:39:42.331]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.331]                     NULL
[17:39:42.331]                   }
[17:39:42.331]                   options(future.plan = NULL)
[17:39:42.331]                   if (is.na(NA_character_)) 
[17:39:42.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.331]                     .init = FALSE)
[17:39:42.331]                 }
[17:39:42.331]             }
[17:39:42.331]         }
[17:39:42.331]     })
[17:39:42.331]     if (TRUE) {
[17:39:42.331]         base::sink(type = "output", split = FALSE)
[17:39:42.331]         if (TRUE) {
[17:39:42.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.331]         }
[17:39:42.331]         else {
[17:39:42.331]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.331]         }
[17:39:42.331]         base::close(...future.stdout)
[17:39:42.331]         ...future.stdout <- NULL
[17:39:42.331]     }
[17:39:42.331]     ...future.result$conditions <- ...future.conditions
[17:39:42.331]     ...future.result$finished <- base::Sys.time()
[17:39:42.331]     ...future.result
[17:39:42.331] }
[17:39:42.334] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[17:39:42.334] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[17:39:42.334] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[17:39:42.335] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[17:39:42.335] MultisessionFuture started
[17:39:42.335] - Launch lazy future ... done
[17:39:42.335] run() for ‘MultisessionFuture’ ... done
[17:39:42.336] result() for ClusterFuture ...
[17:39:42.336] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.336] - Validating connection of MultisessionFuture
[17:39:42.379] - received message: FutureResult
[17:39:42.379] - Received FutureResult
[17:39:42.379] - Erased future from FutureRegistry
[17:39:42.380] result() for ClusterFuture ...
[17:39:42.380] - result already collected: FutureResult
[17:39:42.380] result() for ClusterFuture ... done
[17:39:42.380] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.380] result() for ClusterFuture ... done
[17:39:42.380] result() for ClusterFuture ...
[17:39:42.380] - result already collected: FutureResult
[17:39:42.380] result() for ClusterFuture ... done
x
1 2 
2 3 
[17:39:42.381] getGlobalsAndPackages() ...
[17:39:42.381] Searching for globals...
[17:39:42.382] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[17:39:42.382] Searching for globals ... DONE
[17:39:42.382] Resolving globals: FALSE
[17:39:42.383] The total size of the 1 globals is 96 bytes (96 bytes)
[17:39:42.383] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[17:39:42.383] - globals: [1] ‘x’
[17:39:42.383] - packages: [1] ‘stats’
[17:39:42.384] getGlobalsAndPackages() ... DONE
[17:39:42.384] run() for ‘Future’ ...
[17:39:42.384] - state: ‘created’
[17:39:42.384] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.398]   - Field: ‘node’
[17:39:42.398]   - Field: ‘label’
[17:39:42.399]   - Field: ‘local’
[17:39:42.399]   - Field: ‘owner’
[17:39:42.399]   - Field: ‘envir’
[17:39:42.399]   - Field: ‘workers’
[17:39:42.399]   - Field: ‘packages’
[17:39:42.399]   - Field: ‘gc’
[17:39:42.399]   - Field: ‘conditions’
[17:39:42.399]   - Field: ‘persistent’
[17:39:42.399]   - Field: ‘expr’
[17:39:42.399]   - Field: ‘uuid’
[17:39:42.399]   - Field: ‘seed’
[17:39:42.400]   - Field: ‘version’
[17:39:42.400]   - Field: ‘result’
[17:39:42.400]   - Field: ‘asynchronous’
[17:39:42.400]   - Field: ‘calls’
[17:39:42.400]   - Field: ‘globals’
[17:39:42.400]   - Field: ‘stdout’
[17:39:42.400]   - Field: ‘earlySignal’
[17:39:42.400]   - Field: ‘lazy’
[17:39:42.400]   - Field: ‘state’
[17:39:42.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.400] - Launch lazy future ...
[17:39:42.401] Packages needed by the future expression (n = 1): ‘stats’
[17:39:42.401] Packages needed by future strategies (n = 0): <none>
[17:39:42.401] {
[17:39:42.401]     {
[17:39:42.401]         {
[17:39:42.401]             ...future.startTime <- base::Sys.time()
[17:39:42.401]             {
[17:39:42.401]                 {
[17:39:42.401]                   {
[17:39:42.401]                     {
[17:39:42.401]                       {
[17:39:42.401]                         base::local({
[17:39:42.401]                           has_future <- base::requireNamespace("future", 
[17:39:42.401]                             quietly = TRUE)
[17:39:42.401]                           if (has_future) {
[17:39:42.401]                             ns <- base::getNamespace("future")
[17:39:42.401]                             version <- ns[[".package"]][["version"]]
[17:39:42.401]                             if (is.null(version)) 
[17:39:42.401]                               version <- utils::packageVersion("future")
[17:39:42.401]                           }
[17:39:42.401]                           else {
[17:39:42.401]                             version <- NULL
[17:39:42.401]                           }
[17:39:42.401]                           if (!has_future || version < "1.8.0") {
[17:39:42.401]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.401]                               "", base::R.version$version.string), 
[17:39:42.401]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.401]                                 base::R.version$platform, 8 * 
[17:39:42.401]                                   base::.Machine$sizeof.pointer), 
[17:39:42.401]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.401]                                 "release", "version")], collapse = " "), 
[17:39:42.401]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.401]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.401]                               info)
[17:39:42.401]                             info <- base::paste(info, collapse = "; ")
[17:39:42.401]                             if (!has_future) {
[17:39:42.401]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.401]                                 info)
[17:39:42.401]                             }
[17:39:42.401]                             else {
[17:39:42.401]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.401]                                 info, version)
[17:39:42.401]                             }
[17:39:42.401]                             base::stop(msg)
[17:39:42.401]                           }
[17:39:42.401]                         })
[17:39:42.401]                       }
[17:39:42.401]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.401]                       base::options(mc.cores = 1L)
[17:39:42.401]                     }
[17:39:42.401]                     base::local({
[17:39:42.401]                       for (pkg in "stats") {
[17:39:42.401]                         base::loadNamespace(pkg)
[17:39:42.401]                         base::library(pkg, character.only = TRUE)
[17:39:42.401]                       }
[17:39:42.401]                     })
[17:39:42.401]                   }
[17:39:42.401]                   ...future.strategy.old <- future::plan("list")
[17:39:42.401]                   options(future.plan = NULL)
[17:39:42.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.401]                 }
[17:39:42.401]                 ...future.workdir <- getwd()
[17:39:42.401]             }
[17:39:42.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.401]         }
[17:39:42.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.401]             base::names(...future.oldOptions))
[17:39:42.401]     }
[17:39:42.401]     if (FALSE) {
[17:39:42.401]     }
[17:39:42.401]     else {
[17:39:42.401]         if (TRUE) {
[17:39:42.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.401]                 open = "w")
[17:39:42.401]         }
[17:39:42.401]         else {
[17:39:42.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.401]         }
[17:39:42.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.401]             base::sink(type = "output", split = FALSE)
[17:39:42.401]             base::close(...future.stdout)
[17:39:42.401]         }, add = TRUE)
[17:39:42.401]     }
[17:39:42.401]     ...future.frame <- base::sys.nframe()
[17:39:42.401]     ...future.conditions <- base::list()
[17:39:42.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.401]     if (FALSE) {
[17:39:42.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.401]     }
[17:39:42.401]     ...future.result <- base::tryCatch({
[17:39:42.401]         base::withCallingHandlers({
[17:39:42.401]             ...future.value <- base::withVisible(base::local({
[17:39:42.401]                 ...future.makeSendCondition <- base::local({
[17:39:42.401]                   sendCondition <- NULL
[17:39:42.401]                   function(frame = 1L) {
[17:39:42.401]                     if (is.function(sendCondition)) 
[17:39:42.401]                       return(sendCondition)
[17:39:42.401]                     ns <- getNamespace("parallel")
[17:39:42.401]                     if (exists("sendData", mode = "function", 
[17:39:42.401]                       envir = ns)) {
[17:39:42.401]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.401]                         envir = ns)
[17:39:42.401]                       envir <- sys.frame(frame)
[17:39:42.401]                       master <- NULL
[17:39:42.401]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.401]                         !identical(envir, emptyenv())) {
[17:39:42.401]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.401]                           inherits = FALSE)) {
[17:39:42.401]                           master <- get("master", mode = "list", 
[17:39:42.401]                             envir = envir, inherits = FALSE)
[17:39:42.401]                           if (inherits(master, c("SOCKnode", 
[17:39:42.401]                             "SOCK0node"))) {
[17:39:42.401]                             sendCondition <<- function(cond) {
[17:39:42.401]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.401]                                 success = TRUE)
[17:39:42.401]                               parallel_sendData(master, data)
[17:39:42.401]                             }
[17:39:42.401]                             return(sendCondition)
[17:39:42.401]                           }
[17:39:42.401]                         }
[17:39:42.401]                         frame <- frame + 1L
[17:39:42.401]                         envir <- sys.frame(frame)
[17:39:42.401]                       }
[17:39:42.401]                     }
[17:39:42.401]                     sendCondition <<- function(cond) NULL
[17:39:42.401]                   }
[17:39:42.401]                 })
[17:39:42.401]                 withCallingHandlers({
[17:39:42.401]                   {
[17:39:42.401]                     xtabs(~x)
[17:39:42.401]                   }
[17:39:42.401]                 }, immediateCondition = function(cond) {
[17:39:42.401]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.401]                   sendCondition(cond)
[17:39:42.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.401]                   {
[17:39:42.401]                     inherits <- base::inherits
[17:39:42.401]                     invokeRestart <- base::invokeRestart
[17:39:42.401]                     is.null <- base::is.null
[17:39:42.401]                     muffled <- FALSE
[17:39:42.401]                     if (inherits(cond, "message")) {
[17:39:42.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.401]                       if (muffled) 
[17:39:42.401]                         invokeRestart("muffleMessage")
[17:39:42.401]                     }
[17:39:42.401]                     else if (inherits(cond, "warning")) {
[17:39:42.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.401]                       if (muffled) 
[17:39:42.401]                         invokeRestart("muffleWarning")
[17:39:42.401]                     }
[17:39:42.401]                     else if (inherits(cond, "condition")) {
[17:39:42.401]                       if (!is.null(pattern)) {
[17:39:42.401]                         computeRestarts <- base::computeRestarts
[17:39:42.401]                         grepl <- base::grepl
[17:39:42.401]                         restarts <- computeRestarts(cond)
[17:39:42.401]                         for (restart in restarts) {
[17:39:42.401]                           name <- restart$name
[17:39:42.401]                           if (is.null(name)) 
[17:39:42.401]                             next
[17:39:42.401]                           if (!grepl(pattern, name)) 
[17:39:42.401]                             next
[17:39:42.401]                           invokeRestart(restart)
[17:39:42.401]                           muffled <- TRUE
[17:39:42.401]                           break
[17:39:42.401]                         }
[17:39:42.401]                       }
[17:39:42.401]                     }
[17:39:42.401]                     invisible(muffled)
[17:39:42.401]                   }
[17:39:42.401]                   muffleCondition(cond)
[17:39:42.401]                 })
[17:39:42.401]             }))
[17:39:42.401]             future::FutureResult(value = ...future.value$value, 
[17:39:42.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.401]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.401]                     ...future.globalenv.names))
[17:39:42.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.401]         }, condition = base::local({
[17:39:42.401]             c <- base::c
[17:39:42.401]             inherits <- base::inherits
[17:39:42.401]             invokeRestart <- base::invokeRestart
[17:39:42.401]             length <- base::length
[17:39:42.401]             list <- base::list
[17:39:42.401]             seq.int <- base::seq.int
[17:39:42.401]             signalCondition <- base::signalCondition
[17:39:42.401]             sys.calls <- base::sys.calls
[17:39:42.401]             `[[` <- base::`[[`
[17:39:42.401]             `+` <- base::`+`
[17:39:42.401]             `<<-` <- base::`<<-`
[17:39:42.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.401]                   3L)]
[17:39:42.401]             }
[17:39:42.401]             function(cond) {
[17:39:42.401]                 is_error <- inherits(cond, "error")
[17:39:42.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.401]                   NULL)
[17:39:42.401]                 if (is_error) {
[17:39:42.401]                   sessionInformation <- function() {
[17:39:42.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.401]                       search = base::search(), system = base::Sys.info())
[17:39:42.401]                   }
[17:39:42.401]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.401]                     cond$call), session = sessionInformation(), 
[17:39:42.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.401]                   signalCondition(cond)
[17:39:42.401]                 }
[17:39:42.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.401]                 "immediateCondition"))) {
[17:39:42.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.401]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.401]                   if (TRUE && !signal) {
[17:39:42.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.401]                     {
[17:39:42.401]                       inherits <- base::inherits
[17:39:42.401]                       invokeRestart <- base::invokeRestart
[17:39:42.401]                       is.null <- base::is.null
[17:39:42.401]                       muffled <- FALSE
[17:39:42.401]                       if (inherits(cond, "message")) {
[17:39:42.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.401]                         if (muffled) 
[17:39:42.401]                           invokeRestart("muffleMessage")
[17:39:42.401]                       }
[17:39:42.401]                       else if (inherits(cond, "warning")) {
[17:39:42.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.401]                         if (muffled) 
[17:39:42.401]                           invokeRestart("muffleWarning")
[17:39:42.401]                       }
[17:39:42.401]                       else if (inherits(cond, "condition")) {
[17:39:42.401]                         if (!is.null(pattern)) {
[17:39:42.401]                           computeRestarts <- base::computeRestarts
[17:39:42.401]                           grepl <- base::grepl
[17:39:42.401]                           restarts <- computeRestarts(cond)
[17:39:42.401]                           for (restart in restarts) {
[17:39:42.401]                             name <- restart$name
[17:39:42.401]                             if (is.null(name)) 
[17:39:42.401]                               next
[17:39:42.401]                             if (!grepl(pattern, name)) 
[17:39:42.401]                               next
[17:39:42.401]                             invokeRestart(restart)
[17:39:42.401]                             muffled <- TRUE
[17:39:42.401]                             break
[17:39:42.401]                           }
[17:39:42.401]                         }
[17:39:42.401]                       }
[17:39:42.401]                       invisible(muffled)
[17:39:42.401]                     }
[17:39:42.401]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.401]                   }
[17:39:42.401]                 }
[17:39:42.401]                 else {
[17:39:42.401]                   if (TRUE) {
[17:39:42.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.401]                     {
[17:39:42.401]                       inherits <- base::inherits
[17:39:42.401]                       invokeRestart <- base::invokeRestart
[17:39:42.401]                       is.null <- base::is.null
[17:39:42.401]                       muffled <- FALSE
[17:39:42.401]                       if (inherits(cond, "message")) {
[17:39:42.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.401]                         if (muffled) 
[17:39:42.401]                           invokeRestart("muffleMessage")
[17:39:42.401]                       }
[17:39:42.401]                       else if (inherits(cond, "warning")) {
[17:39:42.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.401]                         if (muffled) 
[17:39:42.401]                           invokeRestart("muffleWarning")
[17:39:42.401]                       }
[17:39:42.401]                       else if (inherits(cond, "condition")) {
[17:39:42.401]                         if (!is.null(pattern)) {
[17:39:42.401]                           computeRestarts <- base::computeRestarts
[17:39:42.401]                           grepl <- base::grepl
[17:39:42.401]                           restarts <- computeRestarts(cond)
[17:39:42.401]                           for (restart in restarts) {
[17:39:42.401]                             name <- restart$name
[17:39:42.401]                             if (is.null(name)) 
[17:39:42.401]                               next
[17:39:42.401]                             if (!grepl(pattern, name)) 
[17:39:42.401]                               next
[17:39:42.401]                             invokeRestart(restart)
[17:39:42.401]                             muffled <- TRUE
[17:39:42.401]                             break
[17:39:42.401]                           }
[17:39:42.401]                         }
[17:39:42.401]                       }
[17:39:42.401]                       invisible(muffled)
[17:39:42.401]                     }
[17:39:42.401]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.401]                   }
[17:39:42.401]                 }
[17:39:42.401]             }
[17:39:42.401]         }))
[17:39:42.401]     }, error = function(ex) {
[17:39:42.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.401]                 ...future.rng), started = ...future.startTime, 
[17:39:42.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.401]             version = "1.8"), class = "FutureResult")
[17:39:42.401]     }, finally = {
[17:39:42.401]         if (!identical(...future.workdir, getwd())) 
[17:39:42.401]             setwd(...future.workdir)
[17:39:42.401]         {
[17:39:42.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.401]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.401]             }
[17:39:42.401]             base::options(...future.oldOptions)
[17:39:42.401]             if (.Platform$OS.type == "windows") {
[17:39:42.401]                 old_names <- names(...future.oldEnvVars)
[17:39:42.401]                 envs <- base::Sys.getenv()
[17:39:42.401]                 names <- names(envs)
[17:39:42.401]                 common <- intersect(names, old_names)
[17:39:42.401]                 added <- setdiff(names, old_names)
[17:39:42.401]                 removed <- setdiff(old_names, names)
[17:39:42.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.401]                   envs[common]]
[17:39:42.401]                 NAMES <- toupper(changed)
[17:39:42.401]                 args <- list()
[17:39:42.401]                 for (kk in seq_along(NAMES)) {
[17:39:42.401]                   name <- changed[[kk]]
[17:39:42.401]                   NAME <- NAMES[[kk]]
[17:39:42.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.401]                     next
[17:39:42.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.401]                 }
[17:39:42.401]                 NAMES <- toupper(added)
[17:39:42.401]                 for (kk in seq_along(NAMES)) {
[17:39:42.401]                   name <- added[[kk]]
[17:39:42.401]                   NAME <- NAMES[[kk]]
[17:39:42.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.401]                     next
[17:39:42.401]                   args[[name]] <- ""
[17:39:42.401]                 }
[17:39:42.401]                 NAMES <- toupper(removed)
[17:39:42.401]                 for (kk in seq_along(NAMES)) {
[17:39:42.401]                   name <- removed[[kk]]
[17:39:42.401]                   NAME <- NAMES[[kk]]
[17:39:42.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.401]                     next
[17:39:42.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.401]                 }
[17:39:42.401]                 if (length(args) > 0) 
[17:39:42.401]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.401]             }
[17:39:42.401]             else {
[17:39:42.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.401]             }
[17:39:42.401]             {
[17:39:42.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.401]                   0L) {
[17:39:42.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.401]                   base::options(opts)
[17:39:42.401]                 }
[17:39:42.401]                 {
[17:39:42.401]                   {
[17:39:42.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.401]                     NULL
[17:39:42.401]                   }
[17:39:42.401]                   options(future.plan = NULL)
[17:39:42.401]                   if (is.na(NA_character_)) 
[17:39:42.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.401]                     .init = FALSE)
[17:39:42.401]                 }
[17:39:42.401]             }
[17:39:42.401]         }
[17:39:42.401]     })
[17:39:42.401]     if (TRUE) {
[17:39:42.401]         base::sink(type = "output", split = FALSE)
[17:39:42.401]         if (TRUE) {
[17:39:42.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.401]         }
[17:39:42.401]         else {
[17:39:42.401]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.401]         }
[17:39:42.401]         base::close(...future.stdout)
[17:39:42.401]         ...future.stdout <- NULL
[17:39:42.401]     }
[17:39:42.401]     ...future.result$conditions <- ...future.conditions
[17:39:42.401]     ...future.result$finished <- base::Sys.time()
[17:39:42.401]     ...future.result
[17:39:42.401] }
[17:39:42.404] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[17:39:42.404] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[17:39:42.404] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[17:39:42.405] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[17:39:42.405] MultisessionFuture started
[17:39:42.405] - Launch lazy future ... done
[17:39:42.405] run() for ‘MultisessionFuture’ ... done
[17:39:42.405] result() for ClusterFuture ...
[17:39:42.405] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.406] - Validating connection of MultisessionFuture
[17:39:42.451] - received message: FutureResult
[17:39:42.451] - Received FutureResult
[17:39:42.451] - Erased future from FutureRegistry
[17:39:42.451] result() for ClusterFuture ...
[17:39:42.451] - result already collected: FutureResult
[17:39:42.451] result() for ClusterFuture ... done
[17:39:42.452] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.452] result() for ClusterFuture ... done
[17:39:42.452] result() for ClusterFuture ...
[17:39:42.452] - result already collected: FutureResult
[17:39:42.452] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[17:39:42.454] getGlobalsAndPackages() ...
[17:39:42.454] Searching for globals...
[17:39:42.455] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[17:39:42.455] Searching for globals ... DONE
[17:39:42.456] Resolving globals: FALSE
[17:39:42.456] 
[17:39:42.456] - packages: [2] ‘stats’, ‘datasets’
[17:39:42.456] getGlobalsAndPackages() ... DONE
[17:39:42.457] run() for ‘Future’ ...
[17:39:42.457] - state: ‘created’
[17:39:42.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.471] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.472]   - Field: ‘node’
[17:39:42.472]   - Field: ‘label’
[17:39:42.472]   - Field: ‘local’
[17:39:42.472]   - Field: ‘owner’
[17:39:42.472]   - Field: ‘envir’
[17:39:42.472]   - Field: ‘workers’
[17:39:42.472]   - Field: ‘packages’
[17:39:42.472]   - Field: ‘gc’
[17:39:42.472]   - Field: ‘conditions’
[17:39:42.472]   - Field: ‘persistent’
[17:39:42.473]   - Field: ‘expr’
[17:39:42.473]   - Field: ‘uuid’
[17:39:42.473]   - Field: ‘seed’
[17:39:42.473]   - Field: ‘version’
[17:39:42.473]   - Field: ‘result’
[17:39:42.473]   - Field: ‘asynchronous’
[17:39:42.473]   - Field: ‘calls’
[17:39:42.473]   - Field: ‘globals’
[17:39:42.473]   - Field: ‘stdout’
[17:39:42.473]   - Field: ‘earlySignal’
[17:39:42.473]   - Field: ‘lazy’
[17:39:42.474]   - Field: ‘state’
[17:39:42.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.474] - Launch lazy future ...
[17:39:42.474] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:42.474] Packages needed by future strategies (n = 0): <none>
[17:39:42.475] {
[17:39:42.475]     {
[17:39:42.475]         {
[17:39:42.475]             ...future.startTime <- base::Sys.time()
[17:39:42.475]             {
[17:39:42.475]                 {
[17:39:42.475]                   {
[17:39:42.475]                     {
[17:39:42.475]                       {
[17:39:42.475]                         base::local({
[17:39:42.475]                           has_future <- base::requireNamespace("future", 
[17:39:42.475]                             quietly = TRUE)
[17:39:42.475]                           if (has_future) {
[17:39:42.475]                             ns <- base::getNamespace("future")
[17:39:42.475]                             version <- ns[[".package"]][["version"]]
[17:39:42.475]                             if (is.null(version)) 
[17:39:42.475]                               version <- utils::packageVersion("future")
[17:39:42.475]                           }
[17:39:42.475]                           else {
[17:39:42.475]                             version <- NULL
[17:39:42.475]                           }
[17:39:42.475]                           if (!has_future || version < "1.8.0") {
[17:39:42.475]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.475]                               "", base::R.version$version.string), 
[17:39:42.475]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.475]                                 base::R.version$platform, 8 * 
[17:39:42.475]                                   base::.Machine$sizeof.pointer), 
[17:39:42.475]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.475]                                 "release", "version")], collapse = " "), 
[17:39:42.475]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.475]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.475]                               info)
[17:39:42.475]                             info <- base::paste(info, collapse = "; ")
[17:39:42.475]                             if (!has_future) {
[17:39:42.475]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.475]                                 info)
[17:39:42.475]                             }
[17:39:42.475]                             else {
[17:39:42.475]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.475]                                 info, version)
[17:39:42.475]                             }
[17:39:42.475]                             base::stop(msg)
[17:39:42.475]                           }
[17:39:42.475]                         })
[17:39:42.475]                       }
[17:39:42.475]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.475]                       base::options(mc.cores = 1L)
[17:39:42.475]                     }
[17:39:42.475]                     base::local({
[17:39:42.475]                       for (pkg in c("stats", "datasets")) {
[17:39:42.475]                         base::loadNamespace(pkg)
[17:39:42.475]                         base::library(pkg, character.only = TRUE)
[17:39:42.475]                       }
[17:39:42.475]                     })
[17:39:42.475]                   }
[17:39:42.475]                   ...future.strategy.old <- future::plan("list")
[17:39:42.475]                   options(future.plan = NULL)
[17:39:42.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.475]                 }
[17:39:42.475]                 ...future.workdir <- getwd()
[17:39:42.475]             }
[17:39:42.475]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.475]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.475]         }
[17:39:42.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.475]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.475]             base::names(...future.oldOptions))
[17:39:42.475]     }
[17:39:42.475]     if (FALSE) {
[17:39:42.475]     }
[17:39:42.475]     else {
[17:39:42.475]         if (TRUE) {
[17:39:42.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.475]                 open = "w")
[17:39:42.475]         }
[17:39:42.475]         else {
[17:39:42.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.475]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.475]         }
[17:39:42.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.475]             base::sink(type = "output", split = FALSE)
[17:39:42.475]             base::close(...future.stdout)
[17:39:42.475]         }, add = TRUE)
[17:39:42.475]     }
[17:39:42.475]     ...future.frame <- base::sys.nframe()
[17:39:42.475]     ...future.conditions <- base::list()
[17:39:42.475]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.475]     if (FALSE) {
[17:39:42.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.475]     }
[17:39:42.475]     ...future.result <- base::tryCatch({
[17:39:42.475]         base::withCallingHandlers({
[17:39:42.475]             ...future.value <- base::withVisible(base::local({
[17:39:42.475]                 ...future.makeSendCondition <- base::local({
[17:39:42.475]                   sendCondition <- NULL
[17:39:42.475]                   function(frame = 1L) {
[17:39:42.475]                     if (is.function(sendCondition)) 
[17:39:42.475]                       return(sendCondition)
[17:39:42.475]                     ns <- getNamespace("parallel")
[17:39:42.475]                     if (exists("sendData", mode = "function", 
[17:39:42.475]                       envir = ns)) {
[17:39:42.475]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.475]                         envir = ns)
[17:39:42.475]                       envir <- sys.frame(frame)
[17:39:42.475]                       master <- NULL
[17:39:42.475]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.475]                         !identical(envir, emptyenv())) {
[17:39:42.475]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.475]                           inherits = FALSE)) {
[17:39:42.475]                           master <- get("master", mode = "list", 
[17:39:42.475]                             envir = envir, inherits = FALSE)
[17:39:42.475]                           if (inherits(master, c("SOCKnode", 
[17:39:42.475]                             "SOCK0node"))) {
[17:39:42.475]                             sendCondition <<- function(cond) {
[17:39:42.475]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.475]                                 success = TRUE)
[17:39:42.475]                               parallel_sendData(master, data)
[17:39:42.475]                             }
[17:39:42.475]                             return(sendCondition)
[17:39:42.475]                           }
[17:39:42.475]                         }
[17:39:42.475]                         frame <- frame + 1L
[17:39:42.475]                         envir <- sys.frame(frame)
[17:39:42.475]                       }
[17:39:42.475]                     }
[17:39:42.475]                     sendCondition <<- function(cond) NULL
[17:39:42.475]                   }
[17:39:42.475]                 })
[17:39:42.475]                 withCallingHandlers({
[17:39:42.475]                   {
[17:39:42.475]                     lm(dist ~ . - 1, data = cars)
[17:39:42.475]                   }
[17:39:42.475]                 }, immediateCondition = function(cond) {
[17:39:42.475]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.475]                   sendCondition(cond)
[17:39:42.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.475]                   {
[17:39:42.475]                     inherits <- base::inherits
[17:39:42.475]                     invokeRestart <- base::invokeRestart
[17:39:42.475]                     is.null <- base::is.null
[17:39:42.475]                     muffled <- FALSE
[17:39:42.475]                     if (inherits(cond, "message")) {
[17:39:42.475]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.475]                       if (muffled) 
[17:39:42.475]                         invokeRestart("muffleMessage")
[17:39:42.475]                     }
[17:39:42.475]                     else if (inherits(cond, "warning")) {
[17:39:42.475]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.475]                       if (muffled) 
[17:39:42.475]                         invokeRestart("muffleWarning")
[17:39:42.475]                     }
[17:39:42.475]                     else if (inherits(cond, "condition")) {
[17:39:42.475]                       if (!is.null(pattern)) {
[17:39:42.475]                         computeRestarts <- base::computeRestarts
[17:39:42.475]                         grepl <- base::grepl
[17:39:42.475]                         restarts <- computeRestarts(cond)
[17:39:42.475]                         for (restart in restarts) {
[17:39:42.475]                           name <- restart$name
[17:39:42.475]                           if (is.null(name)) 
[17:39:42.475]                             next
[17:39:42.475]                           if (!grepl(pattern, name)) 
[17:39:42.475]                             next
[17:39:42.475]                           invokeRestart(restart)
[17:39:42.475]                           muffled <- TRUE
[17:39:42.475]                           break
[17:39:42.475]                         }
[17:39:42.475]                       }
[17:39:42.475]                     }
[17:39:42.475]                     invisible(muffled)
[17:39:42.475]                   }
[17:39:42.475]                   muffleCondition(cond)
[17:39:42.475]                 })
[17:39:42.475]             }))
[17:39:42.475]             future::FutureResult(value = ...future.value$value, 
[17:39:42.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.475]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.475]                     ...future.globalenv.names))
[17:39:42.475]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.475]         }, condition = base::local({
[17:39:42.475]             c <- base::c
[17:39:42.475]             inherits <- base::inherits
[17:39:42.475]             invokeRestart <- base::invokeRestart
[17:39:42.475]             length <- base::length
[17:39:42.475]             list <- base::list
[17:39:42.475]             seq.int <- base::seq.int
[17:39:42.475]             signalCondition <- base::signalCondition
[17:39:42.475]             sys.calls <- base::sys.calls
[17:39:42.475]             `[[` <- base::`[[`
[17:39:42.475]             `+` <- base::`+`
[17:39:42.475]             `<<-` <- base::`<<-`
[17:39:42.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.475]                   3L)]
[17:39:42.475]             }
[17:39:42.475]             function(cond) {
[17:39:42.475]                 is_error <- inherits(cond, "error")
[17:39:42.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.475]                   NULL)
[17:39:42.475]                 if (is_error) {
[17:39:42.475]                   sessionInformation <- function() {
[17:39:42.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.475]                       search = base::search(), system = base::Sys.info())
[17:39:42.475]                   }
[17:39:42.475]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.475]                     cond$call), session = sessionInformation(), 
[17:39:42.475]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.475]                   signalCondition(cond)
[17:39:42.475]                 }
[17:39:42.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.475]                 "immediateCondition"))) {
[17:39:42.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.475]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.475]                   if (TRUE && !signal) {
[17:39:42.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.475]                     {
[17:39:42.475]                       inherits <- base::inherits
[17:39:42.475]                       invokeRestart <- base::invokeRestart
[17:39:42.475]                       is.null <- base::is.null
[17:39:42.475]                       muffled <- FALSE
[17:39:42.475]                       if (inherits(cond, "message")) {
[17:39:42.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.475]                         if (muffled) 
[17:39:42.475]                           invokeRestart("muffleMessage")
[17:39:42.475]                       }
[17:39:42.475]                       else if (inherits(cond, "warning")) {
[17:39:42.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.475]                         if (muffled) 
[17:39:42.475]                           invokeRestart("muffleWarning")
[17:39:42.475]                       }
[17:39:42.475]                       else if (inherits(cond, "condition")) {
[17:39:42.475]                         if (!is.null(pattern)) {
[17:39:42.475]                           computeRestarts <- base::computeRestarts
[17:39:42.475]                           grepl <- base::grepl
[17:39:42.475]                           restarts <- computeRestarts(cond)
[17:39:42.475]                           for (restart in restarts) {
[17:39:42.475]                             name <- restart$name
[17:39:42.475]                             if (is.null(name)) 
[17:39:42.475]                               next
[17:39:42.475]                             if (!grepl(pattern, name)) 
[17:39:42.475]                               next
[17:39:42.475]                             invokeRestart(restart)
[17:39:42.475]                             muffled <- TRUE
[17:39:42.475]                             break
[17:39:42.475]                           }
[17:39:42.475]                         }
[17:39:42.475]                       }
[17:39:42.475]                       invisible(muffled)
[17:39:42.475]                     }
[17:39:42.475]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.475]                   }
[17:39:42.475]                 }
[17:39:42.475]                 else {
[17:39:42.475]                   if (TRUE) {
[17:39:42.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.475]                     {
[17:39:42.475]                       inherits <- base::inherits
[17:39:42.475]                       invokeRestart <- base::invokeRestart
[17:39:42.475]                       is.null <- base::is.null
[17:39:42.475]                       muffled <- FALSE
[17:39:42.475]                       if (inherits(cond, "message")) {
[17:39:42.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.475]                         if (muffled) 
[17:39:42.475]                           invokeRestart("muffleMessage")
[17:39:42.475]                       }
[17:39:42.475]                       else if (inherits(cond, "warning")) {
[17:39:42.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.475]                         if (muffled) 
[17:39:42.475]                           invokeRestart("muffleWarning")
[17:39:42.475]                       }
[17:39:42.475]                       else if (inherits(cond, "condition")) {
[17:39:42.475]                         if (!is.null(pattern)) {
[17:39:42.475]                           computeRestarts <- base::computeRestarts
[17:39:42.475]                           grepl <- base::grepl
[17:39:42.475]                           restarts <- computeRestarts(cond)
[17:39:42.475]                           for (restart in restarts) {
[17:39:42.475]                             name <- restart$name
[17:39:42.475]                             if (is.null(name)) 
[17:39:42.475]                               next
[17:39:42.475]                             if (!grepl(pattern, name)) 
[17:39:42.475]                               next
[17:39:42.475]                             invokeRestart(restart)
[17:39:42.475]                             muffled <- TRUE
[17:39:42.475]                             break
[17:39:42.475]                           }
[17:39:42.475]                         }
[17:39:42.475]                       }
[17:39:42.475]                       invisible(muffled)
[17:39:42.475]                     }
[17:39:42.475]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.475]                   }
[17:39:42.475]                 }
[17:39:42.475]             }
[17:39:42.475]         }))
[17:39:42.475]     }, error = function(ex) {
[17:39:42.475]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.475]                 ...future.rng), started = ...future.startTime, 
[17:39:42.475]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.475]             version = "1.8"), class = "FutureResult")
[17:39:42.475]     }, finally = {
[17:39:42.475]         if (!identical(...future.workdir, getwd())) 
[17:39:42.475]             setwd(...future.workdir)
[17:39:42.475]         {
[17:39:42.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.475]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.475]             }
[17:39:42.475]             base::options(...future.oldOptions)
[17:39:42.475]             if (.Platform$OS.type == "windows") {
[17:39:42.475]                 old_names <- names(...future.oldEnvVars)
[17:39:42.475]                 envs <- base::Sys.getenv()
[17:39:42.475]                 names <- names(envs)
[17:39:42.475]                 common <- intersect(names, old_names)
[17:39:42.475]                 added <- setdiff(names, old_names)
[17:39:42.475]                 removed <- setdiff(old_names, names)
[17:39:42.475]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.475]                   envs[common]]
[17:39:42.475]                 NAMES <- toupper(changed)
[17:39:42.475]                 args <- list()
[17:39:42.475]                 for (kk in seq_along(NAMES)) {
[17:39:42.475]                   name <- changed[[kk]]
[17:39:42.475]                   NAME <- NAMES[[kk]]
[17:39:42.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.475]                     next
[17:39:42.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.475]                 }
[17:39:42.475]                 NAMES <- toupper(added)
[17:39:42.475]                 for (kk in seq_along(NAMES)) {
[17:39:42.475]                   name <- added[[kk]]
[17:39:42.475]                   NAME <- NAMES[[kk]]
[17:39:42.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.475]                     next
[17:39:42.475]                   args[[name]] <- ""
[17:39:42.475]                 }
[17:39:42.475]                 NAMES <- toupper(removed)
[17:39:42.475]                 for (kk in seq_along(NAMES)) {
[17:39:42.475]                   name <- removed[[kk]]
[17:39:42.475]                   NAME <- NAMES[[kk]]
[17:39:42.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.475]                     next
[17:39:42.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.475]                 }
[17:39:42.475]                 if (length(args) > 0) 
[17:39:42.475]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.475]             }
[17:39:42.475]             else {
[17:39:42.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.475]             }
[17:39:42.475]             {
[17:39:42.475]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.475]                   0L) {
[17:39:42.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.475]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.475]                   base::options(opts)
[17:39:42.475]                 }
[17:39:42.475]                 {
[17:39:42.475]                   {
[17:39:42.475]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.475]                     NULL
[17:39:42.475]                   }
[17:39:42.475]                   options(future.plan = NULL)
[17:39:42.475]                   if (is.na(NA_character_)) 
[17:39:42.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.475]                     .init = FALSE)
[17:39:42.475]                 }
[17:39:42.475]             }
[17:39:42.475]         }
[17:39:42.475]     })
[17:39:42.475]     if (TRUE) {
[17:39:42.475]         base::sink(type = "output", split = FALSE)
[17:39:42.475]         if (TRUE) {
[17:39:42.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.475]         }
[17:39:42.475]         else {
[17:39:42.475]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.475]         }
[17:39:42.475]         base::close(...future.stdout)
[17:39:42.475]         ...future.stdout <- NULL
[17:39:42.475]     }
[17:39:42.475]     ...future.result$conditions <- ...future.conditions
[17:39:42.475]     ...future.result$finished <- base::Sys.time()
[17:39:42.475]     ...future.result
[17:39:42.475] }
[17:39:42.478] MultisessionFuture started
[17:39:42.478] - Launch lazy future ... done
[17:39:42.478] run() for ‘MultisessionFuture’ ... done
[17:39:42.478] result() for ClusterFuture ...
[17:39:42.478] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.478] - Validating connection of MultisessionFuture
[17:39:42.523] - received message: FutureResult
[17:39:42.524] - Received FutureResult
[17:39:42.524] - Erased future from FutureRegistry
[17:39:42.524] result() for ClusterFuture ...
[17:39:42.524] - result already collected: FutureResult
[17:39:42.524] result() for ClusterFuture ... done
[17:39:42.524] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.524] result() for ClusterFuture ... done
[17:39:42.524] result() for ClusterFuture ...
[17:39:42.525] - result already collected: FutureResult
[17:39:42.525] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[17:39:42.530] getGlobalsAndPackages() ...
[17:39:42.530] Searching for globals...
[17:39:42.531] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[17:39:42.532] Searching for globals ... DONE
[17:39:42.532] Resolving globals: FALSE
[17:39:42.532] 
[17:39:42.532] - packages: [2] ‘stats’, ‘datasets’
[17:39:42.532] getGlobalsAndPackages() ... DONE
[17:39:42.533] run() for ‘Future’ ...
[17:39:42.533] - state: ‘created’
[17:39:42.533] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.547] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.548]   - Field: ‘node’
[17:39:42.548]   - Field: ‘label’
[17:39:42.548]   - Field: ‘local’
[17:39:42.548]   - Field: ‘owner’
[17:39:42.548]   - Field: ‘envir’
[17:39:42.548]   - Field: ‘workers’
[17:39:42.548]   - Field: ‘packages’
[17:39:42.549]   - Field: ‘gc’
[17:39:42.549]   - Field: ‘conditions’
[17:39:42.549]   - Field: ‘persistent’
[17:39:42.549]   - Field: ‘expr’
[17:39:42.549]   - Field: ‘uuid’
[17:39:42.549]   - Field: ‘seed’
[17:39:42.549]   - Field: ‘version’
[17:39:42.549]   - Field: ‘result’
[17:39:42.549]   - Field: ‘asynchronous’
[17:39:42.549]   - Field: ‘calls’
[17:39:42.549]   - Field: ‘globals’
[17:39:42.550]   - Field: ‘stdout’
[17:39:42.550]   - Field: ‘earlySignal’
[17:39:42.550]   - Field: ‘lazy’
[17:39:42.550]   - Field: ‘state’
[17:39:42.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.550] - Launch lazy future ...
[17:39:42.550] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:42.550] Packages needed by future strategies (n = 0): <none>
[17:39:42.551] {
[17:39:42.551]     {
[17:39:42.551]         {
[17:39:42.551]             ...future.startTime <- base::Sys.time()
[17:39:42.551]             {
[17:39:42.551]                 {
[17:39:42.551]                   {
[17:39:42.551]                     {
[17:39:42.551]                       {
[17:39:42.551]                         base::local({
[17:39:42.551]                           has_future <- base::requireNamespace("future", 
[17:39:42.551]                             quietly = TRUE)
[17:39:42.551]                           if (has_future) {
[17:39:42.551]                             ns <- base::getNamespace("future")
[17:39:42.551]                             version <- ns[[".package"]][["version"]]
[17:39:42.551]                             if (is.null(version)) 
[17:39:42.551]                               version <- utils::packageVersion("future")
[17:39:42.551]                           }
[17:39:42.551]                           else {
[17:39:42.551]                             version <- NULL
[17:39:42.551]                           }
[17:39:42.551]                           if (!has_future || version < "1.8.0") {
[17:39:42.551]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.551]                               "", base::R.version$version.string), 
[17:39:42.551]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.551]                                 base::R.version$platform, 8 * 
[17:39:42.551]                                   base::.Machine$sizeof.pointer), 
[17:39:42.551]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.551]                                 "release", "version")], collapse = " "), 
[17:39:42.551]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.551]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.551]                               info)
[17:39:42.551]                             info <- base::paste(info, collapse = "; ")
[17:39:42.551]                             if (!has_future) {
[17:39:42.551]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.551]                                 info)
[17:39:42.551]                             }
[17:39:42.551]                             else {
[17:39:42.551]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.551]                                 info, version)
[17:39:42.551]                             }
[17:39:42.551]                             base::stop(msg)
[17:39:42.551]                           }
[17:39:42.551]                         })
[17:39:42.551]                       }
[17:39:42.551]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.551]                       base::options(mc.cores = 1L)
[17:39:42.551]                     }
[17:39:42.551]                     base::local({
[17:39:42.551]                       for (pkg in c("stats", "datasets")) {
[17:39:42.551]                         base::loadNamespace(pkg)
[17:39:42.551]                         base::library(pkg, character.only = TRUE)
[17:39:42.551]                       }
[17:39:42.551]                     })
[17:39:42.551]                   }
[17:39:42.551]                   ...future.strategy.old <- future::plan("list")
[17:39:42.551]                   options(future.plan = NULL)
[17:39:42.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.551]                 }
[17:39:42.551]                 ...future.workdir <- getwd()
[17:39:42.551]             }
[17:39:42.551]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.551]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.551]         }
[17:39:42.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.551]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.551]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.551]             base::names(...future.oldOptions))
[17:39:42.551]     }
[17:39:42.551]     if (FALSE) {
[17:39:42.551]     }
[17:39:42.551]     else {
[17:39:42.551]         if (TRUE) {
[17:39:42.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.551]                 open = "w")
[17:39:42.551]         }
[17:39:42.551]         else {
[17:39:42.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.551]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.551]         }
[17:39:42.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.551]             base::sink(type = "output", split = FALSE)
[17:39:42.551]             base::close(...future.stdout)
[17:39:42.551]         }, add = TRUE)
[17:39:42.551]     }
[17:39:42.551]     ...future.frame <- base::sys.nframe()
[17:39:42.551]     ...future.conditions <- base::list()
[17:39:42.551]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.551]     if (FALSE) {
[17:39:42.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.551]     }
[17:39:42.551]     ...future.result <- base::tryCatch({
[17:39:42.551]         base::withCallingHandlers({
[17:39:42.551]             ...future.value <- base::withVisible(base::local({
[17:39:42.551]                 ...future.makeSendCondition <- base::local({
[17:39:42.551]                   sendCondition <- NULL
[17:39:42.551]                   function(frame = 1L) {
[17:39:42.551]                     if (is.function(sendCondition)) 
[17:39:42.551]                       return(sendCondition)
[17:39:42.551]                     ns <- getNamespace("parallel")
[17:39:42.551]                     if (exists("sendData", mode = "function", 
[17:39:42.551]                       envir = ns)) {
[17:39:42.551]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.551]                         envir = ns)
[17:39:42.551]                       envir <- sys.frame(frame)
[17:39:42.551]                       master <- NULL
[17:39:42.551]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.551]                         !identical(envir, emptyenv())) {
[17:39:42.551]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.551]                           inherits = FALSE)) {
[17:39:42.551]                           master <- get("master", mode = "list", 
[17:39:42.551]                             envir = envir, inherits = FALSE)
[17:39:42.551]                           if (inherits(master, c("SOCKnode", 
[17:39:42.551]                             "SOCK0node"))) {
[17:39:42.551]                             sendCondition <<- function(cond) {
[17:39:42.551]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.551]                                 success = TRUE)
[17:39:42.551]                               parallel_sendData(master, data)
[17:39:42.551]                             }
[17:39:42.551]                             return(sendCondition)
[17:39:42.551]                           }
[17:39:42.551]                         }
[17:39:42.551]                         frame <- frame + 1L
[17:39:42.551]                         envir <- sys.frame(frame)
[17:39:42.551]                       }
[17:39:42.551]                     }
[17:39:42.551]                     sendCondition <<- function(cond) NULL
[17:39:42.551]                   }
[17:39:42.551]                 })
[17:39:42.551]                 withCallingHandlers({
[17:39:42.551]                   {
[17:39:42.551]                     lm(dist ~ . + 0, data = cars)
[17:39:42.551]                   }
[17:39:42.551]                 }, immediateCondition = function(cond) {
[17:39:42.551]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.551]                   sendCondition(cond)
[17:39:42.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.551]                   {
[17:39:42.551]                     inherits <- base::inherits
[17:39:42.551]                     invokeRestart <- base::invokeRestart
[17:39:42.551]                     is.null <- base::is.null
[17:39:42.551]                     muffled <- FALSE
[17:39:42.551]                     if (inherits(cond, "message")) {
[17:39:42.551]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.551]                       if (muffled) 
[17:39:42.551]                         invokeRestart("muffleMessage")
[17:39:42.551]                     }
[17:39:42.551]                     else if (inherits(cond, "warning")) {
[17:39:42.551]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.551]                       if (muffled) 
[17:39:42.551]                         invokeRestart("muffleWarning")
[17:39:42.551]                     }
[17:39:42.551]                     else if (inherits(cond, "condition")) {
[17:39:42.551]                       if (!is.null(pattern)) {
[17:39:42.551]                         computeRestarts <- base::computeRestarts
[17:39:42.551]                         grepl <- base::grepl
[17:39:42.551]                         restarts <- computeRestarts(cond)
[17:39:42.551]                         for (restart in restarts) {
[17:39:42.551]                           name <- restart$name
[17:39:42.551]                           if (is.null(name)) 
[17:39:42.551]                             next
[17:39:42.551]                           if (!grepl(pattern, name)) 
[17:39:42.551]                             next
[17:39:42.551]                           invokeRestart(restart)
[17:39:42.551]                           muffled <- TRUE
[17:39:42.551]                           break
[17:39:42.551]                         }
[17:39:42.551]                       }
[17:39:42.551]                     }
[17:39:42.551]                     invisible(muffled)
[17:39:42.551]                   }
[17:39:42.551]                   muffleCondition(cond)
[17:39:42.551]                 })
[17:39:42.551]             }))
[17:39:42.551]             future::FutureResult(value = ...future.value$value, 
[17:39:42.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.551]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.551]                     ...future.globalenv.names))
[17:39:42.551]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.551]         }, condition = base::local({
[17:39:42.551]             c <- base::c
[17:39:42.551]             inherits <- base::inherits
[17:39:42.551]             invokeRestart <- base::invokeRestart
[17:39:42.551]             length <- base::length
[17:39:42.551]             list <- base::list
[17:39:42.551]             seq.int <- base::seq.int
[17:39:42.551]             signalCondition <- base::signalCondition
[17:39:42.551]             sys.calls <- base::sys.calls
[17:39:42.551]             `[[` <- base::`[[`
[17:39:42.551]             `+` <- base::`+`
[17:39:42.551]             `<<-` <- base::`<<-`
[17:39:42.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.551]                   3L)]
[17:39:42.551]             }
[17:39:42.551]             function(cond) {
[17:39:42.551]                 is_error <- inherits(cond, "error")
[17:39:42.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.551]                   NULL)
[17:39:42.551]                 if (is_error) {
[17:39:42.551]                   sessionInformation <- function() {
[17:39:42.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.551]                       search = base::search(), system = base::Sys.info())
[17:39:42.551]                   }
[17:39:42.551]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.551]                     cond$call), session = sessionInformation(), 
[17:39:42.551]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.551]                   signalCondition(cond)
[17:39:42.551]                 }
[17:39:42.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.551]                 "immediateCondition"))) {
[17:39:42.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.551]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.551]                   if (TRUE && !signal) {
[17:39:42.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.551]                     {
[17:39:42.551]                       inherits <- base::inherits
[17:39:42.551]                       invokeRestart <- base::invokeRestart
[17:39:42.551]                       is.null <- base::is.null
[17:39:42.551]                       muffled <- FALSE
[17:39:42.551]                       if (inherits(cond, "message")) {
[17:39:42.551]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.551]                         if (muffled) 
[17:39:42.551]                           invokeRestart("muffleMessage")
[17:39:42.551]                       }
[17:39:42.551]                       else if (inherits(cond, "warning")) {
[17:39:42.551]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.551]                         if (muffled) 
[17:39:42.551]                           invokeRestart("muffleWarning")
[17:39:42.551]                       }
[17:39:42.551]                       else if (inherits(cond, "condition")) {
[17:39:42.551]                         if (!is.null(pattern)) {
[17:39:42.551]                           computeRestarts <- base::computeRestarts
[17:39:42.551]                           grepl <- base::grepl
[17:39:42.551]                           restarts <- computeRestarts(cond)
[17:39:42.551]                           for (restart in restarts) {
[17:39:42.551]                             name <- restart$name
[17:39:42.551]                             if (is.null(name)) 
[17:39:42.551]                               next
[17:39:42.551]                             if (!grepl(pattern, name)) 
[17:39:42.551]                               next
[17:39:42.551]                             invokeRestart(restart)
[17:39:42.551]                             muffled <- TRUE
[17:39:42.551]                             break
[17:39:42.551]                           }
[17:39:42.551]                         }
[17:39:42.551]                       }
[17:39:42.551]                       invisible(muffled)
[17:39:42.551]                     }
[17:39:42.551]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.551]                   }
[17:39:42.551]                 }
[17:39:42.551]                 else {
[17:39:42.551]                   if (TRUE) {
[17:39:42.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.551]                     {
[17:39:42.551]                       inherits <- base::inherits
[17:39:42.551]                       invokeRestart <- base::invokeRestart
[17:39:42.551]                       is.null <- base::is.null
[17:39:42.551]                       muffled <- FALSE
[17:39:42.551]                       if (inherits(cond, "message")) {
[17:39:42.551]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.551]                         if (muffled) 
[17:39:42.551]                           invokeRestart("muffleMessage")
[17:39:42.551]                       }
[17:39:42.551]                       else if (inherits(cond, "warning")) {
[17:39:42.551]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.551]                         if (muffled) 
[17:39:42.551]                           invokeRestart("muffleWarning")
[17:39:42.551]                       }
[17:39:42.551]                       else if (inherits(cond, "condition")) {
[17:39:42.551]                         if (!is.null(pattern)) {
[17:39:42.551]                           computeRestarts <- base::computeRestarts
[17:39:42.551]                           grepl <- base::grepl
[17:39:42.551]                           restarts <- computeRestarts(cond)
[17:39:42.551]                           for (restart in restarts) {
[17:39:42.551]                             name <- restart$name
[17:39:42.551]                             if (is.null(name)) 
[17:39:42.551]                               next
[17:39:42.551]                             if (!grepl(pattern, name)) 
[17:39:42.551]                               next
[17:39:42.551]                             invokeRestart(restart)
[17:39:42.551]                             muffled <- TRUE
[17:39:42.551]                             break
[17:39:42.551]                           }
[17:39:42.551]                         }
[17:39:42.551]                       }
[17:39:42.551]                       invisible(muffled)
[17:39:42.551]                     }
[17:39:42.551]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.551]                   }
[17:39:42.551]                 }
[17:39:42.551]             }
[17:39:42.551]         }))
[17:39:42.551]     }, error = function(ex) {
[17:39:42.551]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.551]                 ...future.rng), started = ...future.startTime, 
[17:39:42.551]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.551]             version = "1.8"), class = "FutureResult")
[17:39:42.551]     }, finally = {
[17:39:42.551]         if (!identical(...future.workdir, getwd())) 
[17:39:42.551]             setwd(...future.workdir)
[17:39:42.551]         {
[17:39:42.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.551]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.551]             }
[17:39:42.551]             base::options(...future.oldOptions)
[17:39:42.551]             if (.Platform$OS.type == "windows") {
[17:39:42.551]                 old_names <- names(...future.oldEnvVars)
[17:39:42.551]                 envs <- base::Sys.getenv()
[17:39:42.551]                 names <- names(envs)
[17:39:42.551]                 common <- intersect(names, old_names)
[17:39:42.551]                 added <- setdiff(names, old_names)
[17:39:42.551]                 removed <- setdiff(old_names, names)
[17:39:42.551]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.551]                   envs[common]]
[17:39:42.551]                 NAMES <- toupper(changed)
[17:39:42.551]                 args <- list()
[17:39:42.551]                 for (kk in seq_along(NAMES)) {
[17:39:42.551]                   name <- changed[[kk]]
[17:39:42.551]                   NAME <- NAMES[[kk]]
[17:39:42.551]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.551]                     next
[17:39:42.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.551]                 }
[17:39:42.551]                 NAMES <- toupper(added)
[17:39:42.551]                 for (kk in seq_along(NAMES)) {
[17:39:42.551]                   name <- added[[kk]]
[17:39:42.551]                   NAME <- NAMES[[kk]]
[17:39:42.551]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.551]                     next
[17:39:42.551]                   args[[name]] <- ""
[17:39:42.551]                 }
[17:39:42.551]                 NAMES <- toupper(removed)
[17:39:42.551]                 for (kk in seq_along(NAMES)) {
[17:39:42.551]                   name <- removed[[kk]]
[17:39:42.551]                   NAME <- NAMES[[kk]]
[17:39:42.551]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.551]                     next
[17:39:42.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.551]                 }
[17:39:42.551]                 if (length(args) > 0) 
[17:39:42.551]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.551]             }
[17:39:42.551]             else {
[17:39:42.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.551]             }
[17:39:42.551]             {
[17:39:42.551]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.551]                   0L) {
[17:39:42.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.551]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.551]                   base::options(opts)
[17:39:42.551]                 }
[17:39:42.551]                 {
[17:39:42.551]                   {
[17:39:42.551]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.551]                     NULL
[17:39:42.551]                   }
[17:39:42.551]                   options(future.plan = NULL)
[17:39:42.551]                   if (is.na(NA_character_)) 
[17:39:42.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.551]                     .init = FALSE)
[17:39:42.551]                 }
[17:39:42.551]             }
[17:39:42.551]         }
[17:39:42.551]     })
[17:39:42.551]     if (TRUE) {
[17:39:42.551]         base::sink(type = "output", split = FALSE)
[17:39:42.551]         if (TRUE) {
[17:39:42.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.551]         }
[17:39:42.551]         else {
[17:39:42.551]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.551]         }
[17:39:42.551]         base::close(...future.stdout)
[17:39:42.551]         ...future.stdout <- NULL
[17:39:42.551]     }
[17:39:42.551]     ...future.result$conditions <- ...future.conditions
[17:39:42.551]     ...future.result$finished <- base::Sys.time()
[17:39:42.551]     ...future.result
[17:39:42.551] }
[17:39:42.554] MultisessionFuture started
[17:39:42.554] - Launch lazy future ... done
[17:39:42.554] run() for ‘MultisessionFuture’ ... done
[17:39:42.554] result() for ClusterFuture ...
[17:39:42.555] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.555] - Validating connection of MultisessionFuture
[17:39:42.599] - received message: FutureResult
[17:39:42.599] - Received FutureResult
[17:39:42.599] - Erased future from FutureRegistry
[17:39:42.599] result() for ClusterFuture ...
[17:39:42.600] - result already collected: FutureResult
[17:39:42.600] result() for ClusterFuture ... done
[17:39:42.600] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.600] result() for ClusterFuture ... done
[17:39:42.600] result() for ClusterFuture ...
[17:39:42.600] - result already collected: FutureResult
[17:39:42.600] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[17:39:42.603] getGlobalsAndPackages() ...
[17:39:42.603] Searching for globals...
[17:39:42.605] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[17:39:42.605] Searching for globals ... DONE
[17:39:42.605] Resolving globals: FALSE
[17:39:42.605] 
[17:39:42.605] - packages: [2] ‘stats’, ‘datasets’
[17:39:42.605] getGlobalsAndPackages() ... DONE
[17:39:42.606] run() for ‘Future’ ...
[17:39:42.606] - state: ‘created’
[17:39:42.606] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.620] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.620]   - Field: ‘node’
[17:39:42.620]   - Field: ‘label’
[17:39:42.620]   - Field: ‘local’
[17:39:42.621]   - Field: ‘owner’
[17:39:42.621]   - Field: ‘envir’
[17:39:42.621]   - Field: ‘workers’
[17:39:42.621]   - Field: ‘packages’
[17:39:42.621]   - Field: ‘gc’
[17:39:42.621]   - Field: ‘conditions’
[17:39:42.621]   - Field: ‘persistent’
[17:39:42.621]   - Field: ‘expr’
[17:39:42.621]   - Field: ‘uuid’
[17:39:42.621]   - Field: ‘seed’
[17:39:42.621]   - Field: ‘version’
[17:39:42.621]   - Field: ‘result’
[17:39:42.622]   - Field: ‘asynchronous’
[17:39:42.622]   - Field: ‘calls’
[17:39:42.622]   - Field: ‘globals’
[17:39:42.622]   - Field: ‘stdout’
[17:39:42.622]   - Field: ‘earlySignal’
[17:39:42.622]   - Field: ‘lazy’
[17:39:42.622]   - Field: ‘state’
[17:39:42.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.622] - Launch lazy future ...
[17:39:42.623] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:42.623] Packages needed by future strategies (n = 0): <none>
[17:39:42.623] {
[17:39:42.623]     {
[17:39:42.623]         {
[17:39:42.623]             ...future.startTime <- base::Sys.time()
[17:39:42.623]             {
[17:39:42.623]                 {
[17:39:42.623]                   {
[17:39:42.623]                     {
[17:39:42.623]                       {
[17:39:42.623]                         base::local({
[17:39:42.623]                           has_future <- base::requireNamespace("future", 
[17:39:42.623]                             quietly = TRUE)
[17:39:42.623]                           if (has_future) {
[17:39:42.623]                             ns <- base::getNamespace("future")
[17:39:42.623]                             version <- ns[[".package"]][["version"]]
[17:39:42.623]                             if (is.null(version)) 
[17:39:42.623]                               version <- utils::packageVersion("future")
[17:39:42.623]                           }
[17:39:42.623]                           else {
[17:39:42.623]                             version <- NULL
[17:39:42.623]                           }
[17:39:42.623]                           if (!has_future || version < "1.8.0") {
[17:39:42.623]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.623]                               "", base::R.version$version.string), 
[17:39:42.623]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.623]                                 base::R.version$platform, 8 * 
[17:39:42.623]                                   base::.Machine$sizeof.pointer), 
[17:39:42.623]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.623]                                 "release", "version")], collapse = " "), 
[17:39:42.623]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.623]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.623]                               info)
[17:39:42.623]                             info <- base::paste(info, collapse = "; ")
[17:39:42.623]                             if (!has_future) {
[17:39:42.623]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.623]                                 info)
[17:39:42.623]                             }
[17:39:42.623]                             else {
[17:39:42.623]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.623]                                 info, version)
[17:39:42.623]                             }
[17:39:42.623]                             base::stop(msg)
[17:39:42.623]                           }
[17:39:42.623]                         })
[17:39:42.623]                       }
[17:39:42.623]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.623]                       base::options(mc.cores = 1L)
[17:39:42.623]                     }
[17:39:42.623]                     base::local({
[17:39:42.623]                       for (pkg in c("stats", "datasets")) {
[17:39:42.623]                         base::loadNamespace(pkg)
[17:39:42.623]                         base::library(pkg, character.only = TRUE)
[17:39:42.623]                       }
[17:39:42.623]                     })
[17:39:42.623]                   }
[17:39:42.623]                   ...future.strategy.old <- future::plan("list")
[17:39:42.623]                   options(future.plan = NULL)
[17:39:42.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.623]                 }
[17:39:42.623]                 ...future.workdir <- getwd()
[17:39:42.623]             }
[17:39:42.623]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.623]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.623]         }
[17:39:42.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.623]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.623]             base::names(...future.oldOptions))
[17:39:42.623]     }
[17:39:42.623]     if (FALSE) {
[17:39:42.623]     }
[17:39:42.623]     else {
[17:39:42.623]         if (TRUE) {
[17:39:42.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.623]                 open = "w")
[17:39:42.623]         }
[17:39:42.623]         else {
[17:39:42.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.623]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.623]         }
[17:39:42.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.623]             base::sink(type = "output", split = FALSE)
[17:39:42.623]             base::close(...future.stdout)
[17:39:42.623]         }, add = TRUE)
[17:39:42.623]     }
[17:39:42.623]     ...future.frame <- base::sys.nframe()
[17:39:42.623]     ...future.conditions <- base::list()
[17:39:42.623]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.623]     if (FALSE) {
[17:39:42.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.623]     }
[17:39:42.623]     ...future.result <- base::tryCatch({
[17:39:42.623]         base::withCallingHandlers({
[17:39:42.623]             ...future.value <- base::withVisible(base::local({
[17:39:42.623]                 ...future.makeSendCondition <- base::local({
[17:39:42.623]                   sendCondition <- NULL
[17:39:42.623]                   function(frame = 1L) {
[17:39:42.623]                     if (is.function(sendCondition)) 
[17:39:42.623]                       return(sendCondition)
[17:39:42.623]                     ns <- getNamespace("parallel")
[17:39:42.623]                     if (exists("sendData", mode = "function", 
[17:39:42.623]                       envir = ns)) {
[17:39:42.623]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.623]                         envir = ns)
[17:39:42.623]                       envir <- sys.frame(frame)
[17:39:42.623]                       master <- NULL
[17:39:42.623]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.623]                         !identical(envir, emptyenv())) {
[17:39:42.623]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.623]                           inherits = FALSE)) {
[17:39:42.623]                           master <- get("master", mode = "list", 
[17:39:42.623]                             envir = envir, inherits = FALSE)
[17:39:42.623]                           if (inherits(master, c("SOCKnode", 
[17:39:42.623]                             "SOCK0node"))) {
[17:39:42.623]                             sendCondition <<- function(cond) {
[17:39:42.623]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.623]                                 success = TRUE)
[17:39:42.623]                               parallel_sendData(master, data)
[17:39:42.623]                             }
[17:39:42.623]                             return(sendCondition)
[17:39:42.623]                           }
[17:39:42.623]                         }
[17:39:42.623]                         frame <- frame + 1L
[17:39:42.623]                         envir <- sys.frame(frame)
[17:39:42.623]                       }
[17:39:42.623]                     }
[17:39:42.623]                     sendCondition <<- function(cond) NULL
[17:39:42.623]                   }
[17:39:42.623]                 })
[17:39:42.623]                 withCallingHandlers({
[17:39:42.623]                   {
[17:39:42.623]                     lm(dist ~ speed + speed^2, data = cars)
[17:39:42.623]                   }
[17:39:42.623]                 }, immediateCondition = function(cond) {
[17:39:42.623]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.623]                   sendCondition(cond)
[17:39:42.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.623]                   {
[17:39:42.623]                     inherits <- base::inherits
[17:39:42.623]                     invokeRestart <- base::invokeRestart
[17:39:42.623]                     is.null <- base::is.null
[17:39:42.623]                     muffled <- FALSE
[17:39:42.623]                     if (inherits(cond, "message")) {
[17:39:42.623]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.623]                       if (muffled) 
[17:39:42.623]                         invokeRestart("muffleMessage")
[17:39:42.623]                     }
[17:39:42.623]                     else if (inherits(cond, "warning")) {
[17:39:42.623]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.623]                       if (muffled) 
[17:39:42.623]                         invokeRestart("muffleWarning")
[17:39:42.623]                     }
[17:39:42.623]                     else if (inherits(cond, "condition")) {
[17:39:42.623]                       if (!is.null(pattern)) {
[17:39:42.623]                         computeRestarts <- base::computeRestarts
[17:39:42.623]                         grepl <- base::grepl
[17:39:42.623]                         restarts <- computeRestarts(cond)
[17:39:42.623]                         for (restart in restarts) {
[17:39:42.623]                           name <- restart$name
[17:39:42.623]                           if (is.null(name)) 
[17:39:42.623]                             next
[17:39:42.623]                           if (!grepl(pattern, name)) 
[17:39:42.623]                             next
[17:39:42.623]                           invokeRestart(restart)
[17:39:42.623]                           muffled <- TRUE
[17:39:42.623]                           break
[17:39:42.623]                         }
[17:39:42.623]                       }
[17:39:42.623]                     }
[17:39:42.623]                     invisible(muffled)
[17:39:42.623]                   }
[17:39:42.623]                   muffleCondition(cond)
[17:39:42.623]                 })
[17:39:42.623]             }))
[17:39:42.623]             future::FutureResult(value = ...future.value$value, 
[17:39:42.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.623]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.623]                     ...future.globalenv.names))
[17:39:42.623]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.623]         }, condition = base::local({
[17:39:42.623]             c <- base::c
[17:39:42.623]             inherits <- base::inherits
[17:39:42.623]             invokeRestart <- base::invokeRestart
[17:39:42.623]             length <- base::length
[17:39:42.623]             list <- base::list
[17:39:42.623]             seq.int <- base::seq.int
[17:39:42.623]             signalCondition <- base::signalCondition
[17:39:42.623]             sys.calls <- base::sys.calls
[17:39:42.623]             `[[` <- base::`[[`
[17:39:42.623]             `+` <- base::`+`
[17:39:42.623]             `<<-` <- base::`<<-`
[17:39:42.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.623]                   3L)]
[17:39:42.623]             }
[17:39:42.623]             function(cond) {
[17:39:42.623]                 is_error <- inherits(cond, "error")
[17:39:42.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.623]                   NULL)
[17:39:42.623]                 if (is_error) {
[17:39:42.623]                   sessionInformation <- function() {
[17:39:42.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.623]                       search = base::search(), system = base::Sys.info())
[17:39:42.623]                   }
[17:39:42.623]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.623]                     cond$call), session = sessionInformation(), 
[17:39:42.623]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.623]                   signalCondition(cond)
[17:39:42.623]                 }
[17:39:42.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.623]                 "immediateCondition"))) {
[17:39:42.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.623]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.623]                   if (TRUE && !signal) {
[17:39:42.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.623]                     {
[17:39:42.623]                       inherits <- base::inherits
[17:39:42.623]                       invokeRestart <- base::invokeRestart
[17:39:42.623]                       is.null <- base::is.null
[17:39:42.623]                       muffled <- FALSE
[17:39:42.623]                       if (inherits(cond, "message")) {
[17:39:42.623]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.623]                         if (muffled) 
[17:39:42.623]                           invokeRestart("muffleMessage")
[17:39:42.623]                       }
[17:39:42.623]                       else if (inherits(cond, "warning")) {
[17:39:42.623]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.623]                         if (muffled) 
[17:39:42.623]                           invokeRestart("muffleWarning")
[17:39:42.623]                       }
[17:39:42.623]                       else if (inherits(cond, "condition")) {
[17:39:42.623]                         if (!is.null(pattern)) {
[17:39:42.623]                           computeRestarts <- base::computeRestarts
[17:39:42.623]                           grepl <- base::grepl
[17:39:42.623]                           restarts <- computeRestarts(cond)
[17:39:42.623]                           for (restart in restarts) {
[17:39:42.623]                             name <- restart$name
[17:39:42.623]                             if (is.null(name)) 
[17:39:42.623]                               next
[17:39:42.623]                             if (!grepl(pattern, name)) 
[17:39:42.623]                               next
[17:39:42.623]                             invokeRestart(restart)
[17:39:42.623]                             muffled <- TRUE
[17:39:42.623]                             break
[17:39:42.623]                           }
[17:39:42.623]                         }
[17:39:42.623]                       }
[17:39:42.623]                       invisible(muffled)
[17:39:42.623]                     }
[17:39:42.623]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.623]                   }
[17:39:42.623]                 }
[17:39:42.623]                 else {
[17:39:42.623]                   if (TRUE) {
[17:39:42.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.623]                     {
[17:39:42.623]                       inherits <- base::inherits
[17:39:42.623]                       invokeRestart <- base::invokeRestart
[17:39:42.623]                       is.null <- base::is.null
[17:39:42.623]                       muffled <- FALSE
[17:39:42.623]                       if (inherits(cond, "message")) {
[17:39:42.623]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.623]                         if (muffled) 
[17:39:42.623]                           invokeRestart("muffleMessage")
[17:39:42.623]                       }
[17:39:42.623]                       else if (inherits(cond, "warning")) {
[17:39:42.623]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.623]                         if (muffled) 
[17:39:42.623]                           invokeRestart("muffleWarning")
[17:39:42.623]                       }
[17:39:42.623]                       else if (inherits(cond, "condition")) {
[17:39:42.623]                         if (!is.null(pattern)) {
[17:39:42.623]                           computeRestarts <- base::computeRestarts
[17:39:42.623]                           grepl <- base::grepl
[17:39:42.623]                           restarts <- computeRestarts(cond)
[17:39:42.623]                           for (restart in restarts) {
[17:39:42.623]                             name <- restart$name
[17:39:42.623]                             if (is.null(name)) 
[17:39:42.623]                               next
[17:39:42.623]                             if (!grepl(pattern, name)) 
[17:39:42.623]                               next
[17:39:42.623]                             invokeRestart(restart)
[17:39:42.623]                             muffled <- TRUE
[17:39:42.623]                             break
[17:39:42.623]                           }
[17:39:42.623]                         }
[17:39:42.623]                       }
[17:39:42.623]                       invisible(muffled)
[17:39:42.623]                     }
[17:39:42.623]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.623]                   }
[17:39:42.623]                 }
[17:39:42.623]             }
[17:39:42.623]         }))
[17:39:42.623]     }, error = function(ex) {
[17:39:42.623]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.623]                 ...future.rng), started = ...future.startTime, 
[17:39:42.623]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.623]             version = "1.8"), class = "FutureResult")
[17:39:42.623]     }, finally = {
[17:39:42.623]         if (!identical(...future.workdir, getwd())) 
[17:39:42.623]             setwd(...future.workdir)
[17:39:42.623]         {
[17:39:42.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.623]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.623]             }
[17:39:42.623]             base::options(...future.oldOptions)
[17:39:42.623]             if (.Platform$OS.type == "windows") {
[17:39:42.623]                 old_names <- names(...future.oldEnvVars)
[17:39:42.623]                 envs <- base::Sys.getenv()
[17:39:42.623]                 names <- names(envs)
[17:39:42.623]                 common <- intersect(names, old_names)
[17:39:42.623]                 added <- setdiff(names, old_names)
[17:39:42.623]                 removed <- setdiff(old_names, names)
[17:39:42.623]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.623]                   envs[common]]
[17:39:42.623]                 NAMES <- toupper(changed)
[17:39:42.623]                 args <- list()
[17:39:42.623]                 for (kk in seq_along(NAMES)) {
[17:39:42.623]                   name <- changed[[kk]]
[17:39:42.623]                   NAME <- NAMES[[kk]]
[17:39:42.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.623]                     next
[17:39:42.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.623]                 }
[17:39:42.623]                 NAMES <- toupper(added)
[17:39:42.623]                 for (kk in seq_along(NAMES)) {
[17:39:42.623]                   name <- added[[kk]]
[17:39:42.623]                   NAME <- NAMES[[kk]]
[17:39:42.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.623]                     next
[17:39:42.623]                   args[[name]] <- ""
[17:39:42.623]                 }
[17:39:42.623]                 NAMES <- toupper(removed)
[17:39:42.623]                 for (kk in seq_along(NAMES)) {
[17:39:42.623]                   name <- removed[[kk]]
[17:39:42.623]                   NAME <- NAMES[[kk]]
[17:39:42.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.623]                     next
[17:39:42.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.623]                 }
[17:39:42.623]                 if (length(args) > 0) 
[17:39:42.623]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.623]             }
[17:39:42.623]             else {
[17:39:42.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.623]             }
[17:39:42.623]             {
[17:39:42.623]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.623]                   0L) {
[17:39:42.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.623]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.623]                   base::options(opts)
[17:39:42.623]                 }
[17:39:42.623]                 {
[17:39:42.623]                   {
[17:39:42.623]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.623]                     NULL
[17:39:42.623]                   }
[17:39:42.623]                   options(future.plan = NULL)
[17:39:42.623]                   if (is.na(NA_character_)) 
[17:39:42.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.623]                     .init = FALSE)
[17:39:42.623]                 }
[17:39:42.623]             }
[17:39:42.623]         }
[17:39:42.623]     })
[17:39:42.623]     if (TRUE) {
[17:39:42.623]         base::sink(type = "output", split = FALSE)
[17:39:42.623]         if (TRUE) {
[17:39:42.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.623]         }
[17:39:42.623]         else {
[17:39:42.623]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.623]         }
[17:39:42.623]         base::close(...future.stdout)
[17:39:42.623]         ...future.stdout <- NULL
[17:39:42.623]     }
[17:39:42.623]     ...future.result$conditions <- ...future.conditions
[17:39:42.623]     ...future.result$finished <- base::Sys.time()
[17:39:42.623]     ...future.result
[17:39:42.623] }
[17:39:42.626] MultisessionFuture started
[17:39:42.626] - Launch lazy future ... done
[17:39:42.626] run() for ‘MultisessionFuture’ ... done
[17:39:42.626] result() for ClusterFuture ...
[17:39:42.627] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.627] - Validating connection of MultisessionFuture
[17:39:42.671] - received message: FutureResult
[17:39:42.671] - Received FutureResult
[17:39:42.671] - Erased future from FutureRegistry
[17:39:42.671] result() for ClusterFuture ...
[17:39:42.671] - result already collected: FutureResult
[17:39:42.672] result() for ClusterFuture ... done
[17:39:42.672] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.672] result() for ClusterFuture ... done
[17:39:42.672] result() for ClusterFuture ...
[17:39:42.672] - result already collected: FutureResult
[17:39:42.672] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[17:39:42.675] getGlobalsAndPackages() ...
[17:39:42.675] Searching for globals...
[17:39:42.677] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[17:39:42.677] Searching for globals ... DONE
[17:39:42.677] Resolving globals: FALSE
[17:39:42.677] 
[17:39:42.677] - packages: [2] ‘stats’, ‘datasets’
[17:39:42.677] getGlobalsAndPackages() ... DONE
[17:39:42.678] run() for ‘Future’ ...
[17:39:42.678] - state: ‘created’
[17:39:42.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.692] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.692]   - Field: ‘node’
[17:39:42.692]   - Field: ‘label’
[17:39:42.692]   - Field: ‘local’
[17:39:42.692]   - Field: ‘owner’
[17:39:42.693]   - Field: ‘envir’
[17:39:42.693]   - Field: ‘workers’
[17:39:42.693]   - Field: ‘packages’
[17:39:42.693]   - Field: ‘gc’
[17:39:42.693]   - Field: ‘conditions’
[17:39:42.693]   - Field: ‘persistent’
[17:39:42.693]   - Field: ‘expr’
[17:39:42.693]   - Field: ‘uuid’
[17:39:42.693]   - Field: ‘seed’
[17:39:42.693]   - Field: ‘version’
[17:39:42.693]   - Field: ‘result’
[17:39:42.694]   - Field: ‘asynchronous’
[17:39:42.694]   - Field: ‘calls’
[17:39:42.694]   - Field: ‘globals’
[17:39:42.694]   - Field: ‘stdout’
[17:39:42.694]   - Field: ‘earlySignal’
[17:39:42.694]   - Field: ‘lazy’
[17:39:42.694]   - Field: ‘state’
[17:39:42.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.694] - Launch lazy future ...
[17:39:42.695] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:42.695] Packages needed by future strategies (n = 0): <none>
[17:39:42.695] {
[17:39:42.695]     {
[17:39:42.695]         {
[17:39:42.695]             ...future.startTime <- base::Sys.time()
[17:39:42.695]             {
[17:39:42.695]                 {
[17:39:42.695]                   {
[17:39:42.695]                     {
[17:39:42.695]                       {
[17:39:42.695]                         base::local({
[17:39:42.695]                           has_future <- base::requireNamespace("future", 
[17:39:42.695]                             quietly = TRUE)
[17:39:42.695]                           if (has_future) {
[17:39:42.695]                             ns <- base::getNamespace("future")
[17:39:42.695]                             version <- ns[[".package"]][["version"]]
[17:39:42.695]                             if (is.null(version)) 
[17:39:42.695]                               version <- utils::packageVersion("future")
[17:39:42.695]                           }
[17:39:42.695]                           else {
[17:39:42.695]                             version <- NULL
[17:39:42.695]                           }
[17:39:42.695]                           if (!has_future || version < "1.8.0") {
[17:39:42.695]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.695]                               "", base::R.version$version.string), 
[17:39:42.695]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.695]                                 base::R.version$platform, 8 * 
[17:39:42.695]                                   base::.Machine$sizeof.pointer), 
[17:39:42.695]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.695]                                 "release", "version")], collapse = " "), 
[17:39:42.695]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.695]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.695]                               info)
[17:39:42.695]                             info <- base::paste(info, collapse = "; ")
[17:39:42.695]                             if (!has_future) {
[17:39:42.695]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.695]                                 info)
[17:39:42.695]                             }
[17:39:42.695]                             else {
[17:39:42.695]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.695]                                 info, version)
[17:39:42.695]                             }
[17:39:42.695]                             base::stop(msg)
[17:39:42.695]                           }
[17:39:42.695]                         })
[17:39:42.695]                       }
[17:39:42.695]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.695]                       base::options(mc.cores = 1L)
[17:39:42.695]                     }
[17:39:42.695]                     base::local({
[17:39:42.695]                       for (pkg in c("stats", "datasets")) {
[17:39:42.695]                         base::loadNamespace(pkg)
[17:39:42.695]                         base::library(pkg, character.only = TRUE)
[17:39:42.695]                       }
[17:39:42.695]                     })
[17:39:42.695]                   }
[17:39:42.695]                   ...future.strategy.old <- future::plan("list")
[17:39:42.695]                   options(future.plan = NULL)
[17:39:42.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.695]                 }
[17:39:42.695]                 ...future.workdir <- getwd()
[17:39:42.695]             }
[17:39:42.695]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.695]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.695]         }
[17:39:42.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.695]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.695]             base::names(...future.oldOptions))
[17:39:42.695]     }
[17:39:42.695]     if (FALSE) {
[17:39:42.695]     }
[17:39:42.695]     else {
[17:39:42.695]         if (TRUE) {
[17:39:42.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.695]                 open = "w")
[17:39:42.695]         }
[17:39:42.695]         else {
[17:39:42.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.695]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.695]         }
[17:39:42.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.695]             base::sink(type = "output", split = FALSE)
[17:39:42.695]             base::close(...future.stdout)
[17:39:42.695]         }, add = TRUE)
[17:39:42.695]     }
[17:39:42.695]     ...future.frame <- base::sys.nframe()
[17:39:42.695]     ...future.conditions <- base::list()
[17:39:42.695]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.695]     if (FALSE) {
[17:39:42.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.695]     }
[17:39:42.695]     ...future.result <- base::tryCatch({
[17:39:42.695]         base::withCallingHandlers({
[17:39:42.695]             ...future.value <- base::withVisible(base::local({
[17:39:42.695]                 ...future.makeSendCondition <- base::local({
[17:39:42.695]                   sendCondition <- NULL
[17:39:42.695]                   function(frame = 1L) {
[17:39:42.695]                     if (is.function(sendCondition)) 
[17:39:42.695]                       return(sendCondition)
[17:39:42.695]                     ns <- getNamespace("parallel")
[17:39:42.695]                     if (exists("sendData", mode = "function", 
[17:39:42.695]                       envir = ns)) {
[17:39:42.695]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.695]                         envir = ns)
[17:39:42.695]                       envir <- sys.frame(frame)
[17:39:42.695]                       master <- NULL
[17:39:42.695]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.695]                         !identical(envir, emptyenv())) {
[17:39:42.695]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.695]                           inherits = FALSE)) {
[17:39:42.695]                           master <- get("master", mode = "list", 
[17:39:42.695]                             envir = envir, inherits = FALSE)
[17:39:42.695]                           if (inherits(master, c("SOCKnode", 
[17:39:42.695]                             "SOCK0node"))) {
[17:39:42.695]                             sendCondition <<- function(cond) {
[17:39:42.695]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.695]                                 success = TRUE)
[17:39:42.695]                               parallel_sendData(master, data)
[17:39:42.695]                             }
[17:39:42.695]                             return(sendCondition)
[17:39:42.695]                           }
[17:39:42.695]                         }
[17:39:42.695]                         frame <- frame + 1L
[17:39:42.695]                         envir <- sys.frame(frame)
[17:39:42.695]                       }
[17:39:42.695]                     }
[17:39:42.695]                     sendCondition <<- function(cond) NULL
[17:39:42.695]                   }
[17:39:42.695]                 })
[17:39:42.695]                 withCallingHandlers({
[17:39:42.695]                   {
[17:39:42.695]                     lm(dist ~ speed + I(speed^2), data = cars)
[17:39:42.695]                   }
[17:39:42.695]                 }, immediateCondition = function(cond) {
[17:39:42.695]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.695]                   sendCondition(cond)
[17:39:42.695]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.695]                   {
[17:39:42.695]                     inherits <- base::inherits
[17:39:42.695]                     invokeRestart <- base::invokeRestart
[17:39:42.695]                     is.null <- base::is.null
[17:39:42.695]                     muffled <- FALSE
[17:39:42.695]                     if (inherits(cond, "message")) {
[17:39:42.695]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.695]                       if (muffled) 
[17:39:42.695]                         invokeRestart("muffleMessage")
[17:39:42.695]                     }
[17:39:42.695]                     else if (inherits(cond, "warning")) {
[17:39:42.695]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.695]                       if (muffled) 
[17:39:42.695]                         invokeRestart("muffleWarning")
[17:39:42.695]                     }
[17:39:42.695]                     else if (inherits(cond, "condition")) {
[17:39:42.695]                       if (!is.null(pattern)) {
[17:39:42.695]                         computeRestarts <- base::computeRestarts
[17:39:42.695]                         grepl <- base::grepl
[17:39:42.695]                         restarts <- computeRestarts(cond)
[17:39:42.695]                         for (restart in restarts) {
[17:39:42.695]                           name <- restart$name
[17:39:42.695]                           if (is.null(name)) 
[17:39:42.695]                             next
[17:39:42.695]                           if (!grepl(pattern, name)) 
[17:39:42.695]                             next
[17:39:42.695]                           invokeRestart(restart)
[17:39:42.695]                           muffled <- TRUE
[17:39:42.695]                           break
[17:39:42.695]                         }
[17:39:42.695]                       }
[17:39:42.695]                     }
[17:39:42.695]                     invisible(muffled)
[17:39:42.695]                   }
[17:39:42.695]                   muffleCondition(cond)
[17:39:42.695]                 })
[17:39:42.695]             }))
[17:39:42.695]             future::FutureResult(value = ...future.value$value, 
[17:39:42.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.695]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.695]                     ...future.globalenv.names))
[17:39:42.695]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.695]         }, condition = base::local({
[17:39:42.695]             c <- base::c
[17:39:42.695]             inherits <- base::inherits
[17:39:42.695]             invokeRestart <- base::invokeRestart
[17:39:42.695]             length <- base::length
[17:39:42.695]             list <- base::list
[17:39:42.695]             seq.int <- base::seq.int
[17:39:42.695]             signalCondition <- base::signalCondition
[17:39:42.695]             sys.calls <- base::sys.calls
[17:39:42.695]             `[[` <- base::`[[`
[17:39:42.695]             `+` <- base::`+`
[17:39:42.695]             `<<-` <- base::`<<-`
[17:39:42.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.695]                   3L)]
[17:39:42.695]             }
[17:39:42.695]             function(cond) {
[17:39:42.695]                 is_error <- inherits(cond, "error")
[17:39:42.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.695]                   NULL)
[17:39:42.695]                 if (is_error) {
[17:39:42.695]                   sessionInformation <- function() {
[17:39:42.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.695]                       search = base::search(), system = base::Sys.info())
[17:39:42.695]                   }
[17:39:42.695]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.695]                     cond$call), session = sessionInformation(), 
[17:39:42.695]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.695]                   signalCondition(cond)
[17:39:42.695]                 }
[17:39:42.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.695]                 "immediateCondition"))) {
[17:39:42.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.695]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.695]                   if (TRUE && !signal) {
[17:39:42.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.695]                     {
[17:39:42.695]                       inherits <- base::inherits
[17:39:42.695]                       invokeRestart <- base::invokeRestart
[17:39:42.695]                       is.null <- base::is.null
[17:39:42.695]                       muffled <- FALSE
[17:39:42.695]                       if (inherits(cond, "message")) {
[17:39:42.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.695]                         if (muffled) 
[17:39:42.695]                           invokeRestart("muffleMessage")
[17:39:42.695]                       }
[17:39:42.695]                       else if (inherits(cond, "warning")) {
[17:39:42.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.695]                         if (muffled) 
[17:39:42.695]                           invokeRestart("muffleWarning")
[17:39:42.695]                       }
[17:39:42.695]                       else if (inherits(cond, "condition")) {
[17:39:42.695]                         if (!is.null(pattern)) {
[17:39:42.695]                           computeRestarts <- base::computeRestarts
[17:39:42.695]                           grepl <- base::grepl
[17:39:42.695]                           restarts <- computeRestarts(cond)
[17:39:42.695]                           for (restart in restarts) {
[17:39:42.695]                             name <- restart$name
[17:39:42.695]                             if (is.null(name)) 
[17:39:42.695]                               next
[17:39:42.695]                             if (!grepl(pattern, name)) 
[17:39:42.695]                               next
[17:39:42.695]                             invokeRestart(restart)
[17:39:42.695]                             muffled <- TRUE
[17:39:42.695]                             break
[17:39:42.695]                           }
[17:39:42.695]                         }
[17:39:42.695]                       }
[17:39:42.695]                       invisible(muffled)
[17:39:42.695]                     }
[17:39:42.695]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.695]                   }
[17:39:42.695]                 }
[17:39:42.695]                 else {
[17:39:42.695]                   if (TRUE) {
[17:39:42.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.695]                     {
[17:39:42.695]                       inherits <- base::inherits
[17:39:42.695]                       invokeRestart <- base::invokeRestart
[17:39:42.695]                       is.null <- base::is.null
[17:39:42.695]                       muffled <- FALSE
[17:39:42.695]                       if (inherits(cond, "message")) {
[17:39:42.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.695]                         if (muffled) 
[17:39:42.695]                           invokeRestart("muffleMessage")
[17:39:42.695]                       }
[17:39:42.695]                       else if (inherits(cond, "warning")) {
[17:39:42.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.695]                         if (muffled) 
[17:39:42.695]                           invokeRestart("muffleWarning")
[17:39:42.695]                       }
[17:39:42.695]                       else if (inherits(cond, "condition")) {
[17:39:42.695]                         if (!is.null(pattern)) {
[17:39:42.695]                           computeRestarts <- base::computeRestarts
[17:39:42.695]                           grepl <- base::grepl
[17:39:42.695]                           restarts <- computeRestarts(cond)
[17:39:42.695]                           for (restart in restarts) {
[17:39:42.695]                             name <- restart$name
[17:39:42.695]                             if (is.null(name)) 
[17:39:42.695]                               next
[17:39:42.695]                             if (!grepl(pattern, name)) 
[17:39:42.695]                               next
[17:39:42.695]                             invokeRestart(restart)
[17:39:42.695]                             muffled <- TRUE
[17:39:42.695]                             break
[17:39:42.695]                           }
[17:39:42.695]                         }
[17:39:42.695]                       }
[17:39:42.695]                       invisible(muffled)
[17:39:42.695]                     }
[17:39:42.695]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.695]                   }
[17:39:42.695]                 }
[17:39:42.695]             }
[17:39:42.695]         }))
[17:39:42.695]     }, error = function(ex) {
[17:39:42.695]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.695]                 ...future.rng), started = ...future.startTime, 
[17:39:42.695]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.695]             version = "1.8"), class = "FutureResult")
[17:39:42.695]     }, finally = {
[17:39:42.695]         if (!identical(...future.workdir, getwd())) 
[17:39:42.695]             setwd(...future.workdir)
[17:39:42.695]         {
[17:39:42.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.695]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.695]             }
[17:39:42.695]             base::options(...future.oldOptions)
[17:39:42.695]             if (.Platform$OS.type == "windows") {
[17:39:42.695]                 old_names <- names(...future.oldEnvVars)
[17:39:42.695]                 envs <- base::Sys.getenv()
[17:39:42.695]                 names <- names(envs)
[17:39:42.695]                 common <- intersect(names, old_names)
[17:39:42.695]                 added <- setdiff(names, old_names)
[17:39:42.695]                 removed <- setdiff(old_names, names)
[17:39:42.695]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.695]                   envs[common]]
[17:39:42.695]                 NAMES <- toupper(changed)
[17:39:42.695]                 args <- list()
[17:39:42.695]                 for (kk in seq_along(NAMES)) {
[17:39:42.695]                   name <- changed[[kk]]
[17:39:42.695]                   NAME <- NAMES[[kk]]
[17:39:42.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.695]                     next
[17:39:42.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.695]                 }
[17:39:42.695]                 NAMES <- toupper(added)
[17:39:42.695]                 for (kk in seq_along(NAMES)) {
[17:39:42.695]                   name <- added[[kk]]
[17:39:42.695]                   NAME <- NAMES[[kk]]
[17:39:42.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.695]                     next
[17:39:42.695]                   args[[name]] <- ""
[17:39:42.695]                 }
[17:39:42.695]                 NAMES <- toupper(removed)
[17:39:42.695]                 for (kk in seq_along(NAMES)) {
[17:39:42.695]                   name <- removed[[kk]]
[17:39:42.695]                   NAME <- NAMES[[kk]]
[17:39:42.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.695]                     next
[17:39:42.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.695]                 }
[17:39:42.695]                 if (length(args) > 0) 
[17:39:42.695]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.695]             }
[17:39:42.695]             else {
[17:39:42.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.695]             }
[17:39:42.695]             {
[17:39:42.695]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.695]                   0L) {
[17:39:42.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.695]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.695]                   base::options(opts)
[17:39:42.695]                 }
[17:39:42.695]                 {
[17:39:42.695]                   {
[17:39:42.695]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.695]                     NULL
[17:39:42.695]                   }
[17:39:42.695]                   options(future.plan = NULL)
[17:39:42.695]                   if (is.na(NA_character_)) 
[17:39:42.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.695]                     .init = FALSE)
[17:39:42.695]                 }
[17:39:42.695]             }
[17:39:42.695]         }
[17:39:42.695]     })
[17:39:42.695]     if (TRUE) {
[17:39:42.695]         base::sink(type = "output", split = FALSE)
[17:39:42.695]         if (TRUE) {
[17:39:42.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.695]         }
[17:39:42.695]         else {
[17:39:42.695]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.695]         }
[17:39:42.695]         base::close(...future.stdout)
[17:39:42.695]         ...future.stdout <- NULL
[17:39:42.695]     }
[17:39:42.695]     ...future.result$conditions <- ...future.conditions
[17:39:42.695]     ...future.result$finished <- base::Sys.time()
[17:39:42.695]     ...future.result
[17:39:42.695] }
[17:39:42.698] MultisessionFuture started
[17:39:42.698] - Launch lazy future ... done
[17:39:42.698] run() for ‘MultisessionFuture’ ... done
[17:39:42.698] result() for ClusterFuture ...
[17:39:42.699] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.699] - Validating connection of MultisessionFuture
[17:39:42.743] - received message: FutureResult
[17:39:42.743] - Received FutureResult
[17:39:42.743] - Erased future from FutureRegistry
[17:39:42.744] result() for ClusterFuture ...
[17:39:42.744] - result already collected: FutureResult
[17:39:42.744] result() for ClusterFuture ... done
[17:39:42.744] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.744] result() for ClusterFuture ... done
[17:39:42.744] result() for ClusterFuture ...
[17:39:42.744] - result already collected: FutureResult
[17:39:42.744] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[17:39:42.747] getGlobalsAndPackages() ...
[17:39:42.747] Searching for globals...
[17:39:42.749] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[17:39:42.749] Searching for globals ... DONE
[17:39:42.749] Resolving globals: FALSE
[17:39:42.749] 
[17:39:42.750] - packages: [2] ‘stats’, ‘datasets’
[17:39:42.750] getGlobalsAndPackages() ... DONE
[17:39:42.750] run() for ‘Future’ ...
[17:39:42.750] - state: ‘created’
[17:39:42.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.764]   - Field: ‘node’
[17:39:42.764]   - Field: ‘label’
[17:39:42.764]   - Field: ‘local’
[17:39:42.764]   - Field: ‘owner’
[17:39:42.765]   - Field: ‘envir’
[17:39:42.765]   - Field: ‘workers’
[17:39:42.765]   - Field: ‘packages’
[17:39:42.765]   - Field: ‘gc’
[17:39:42.765]   - Field: ‘conditions’
[17:39:42.765]   - Field: ‘persistent’
[17:39:42.765]   - Field: ‘expr’
[17:39:42.765]   - Field: ‘uuid’
[17:39:42.765]   - Field: ‘seed’
[17:39:42.765]   - Field: ‘version’
[17:39:42.765]   - Field: ‘result’
[17:39:42.765]   - Field: ‘asynchronous’
[17:39:42.766]   - Field: ‘calls’
[17:39:42.766]   - Field: ‘globals’
[17:39:42.766]   - Field: ‘stdout’
[17:39:42.766]   - Field: ‘earlySignal’
[17:39:42.766]   - Field: ‘lazy’
[17:39:42.766]   - Field: ‘state’
[17:39:42.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.766] - Launch lazy future ...
[17:39:42.766] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[17:39:42.767] Packages needed by future strategies (n = 0): <none>
[17:39:42.767] {
[17:39:42.767]     {
[17:39:42.767]         {
[17:39:42.767]             ...future.startTime <- base::Sys.time()
[17:39:42.767]             {
[17:39:42.767]                 {
[17:39:42.767]                   {
[17:39:42.767]                     {
[17:39:42.767]                       {
[17:39:42.767]                         base::local({
[17:39:42.767]                           has_future <- base::requireNamespace("future", 
[17:39:42.767]                             quietly = TRUE)
[17:39:42.767]                           if (has_future) {
[17:39:42.767]                             ns <- base::getNamespace("future")
[17:39:42.767]                             version <- ns[[".package"]][["version"]]
[17:39:42.767]                             if (is.null(version)) 
[17:39:42.767]                               version <- utils::packageVersion("future")
[17:39:42.767]                           }
[17:39:42.767]                           else {
[17:39:42.767]                             version <- NULL
[17:39:42.767]                           }
[17:39:42.767]                           if (!has_future || version < "1.8.0") {
[17:39:42.767]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.767]                               "", base::R.version$version.string), 
[17:39:42.767]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:42.767]                                 base::R.version$platform, 8 * 
[17:39:42.767]                                   base::.Machine$sizeof.pointer), 
[17:39:42.767]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.767]                                 "release", "version")], collapse = " "), 
[17:39:42.767]                               hostname = base::Sys.info()[["nodename"]])
[17:39:42.767]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.767]                               info)
[17:39:42.767]                             info <- base::paste(info, collapse = "; ")
[17:39:42.767]                             if (!has_future) {
[17:39:42.767]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.767]                                 info)
[17:39:42.767]                             }
[17:39:42.767]                             else {
[17:39:42.767]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.767]                                 info, version)
[17:39:42.767]                             }
[17:39:42.767]                             base::stop(msg)
[17:39:42.767]                           }
[17:39:42.767]                         })
[17:39:42.767]                       }
[17:39:42.767]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.767]                       base::options(mc.cores = 1L)
[17:39:42.767]                     }
[17:39:42.767]                     base::local({
[17:39:42.767]                       for (pkg in c("stats", "datasets")) {
[17:39:42.767]                         base::loadNamespace(pkg)
[17:39:42.767]                         base::library(pkg, character.only = TRUE)
[17:39:42.767]                       }
[17:39:42.767]                     })
[17:39:42.767]                   }
[17:39:42.767]                   ...future.strategy.old <- future::plan("list")
[17:39:42.767]                   options(future.plan = NULL)
[17:39:42.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.767]                 }
[17:39:42.767]                 ...future.workdir <- getwd()
[17:39:42.767]             }
[17:39:42.767]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.767]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.767]         }
[17:39:42.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.767]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.767]             base::names(...future.oldOptions))
[17:39:42.767]     }
[17:39:42.767]     if (FALSE) {
[17:39:42.767]     }
[17:39:42.767]     else {
[17:39:42.767]         if (TRUE) {
[17:39:42.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.767]                 open = "w")
[17:39:42.767]         }
[17:39:42.767]         else {
[17:39:42.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.767]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.767]         }
[17:39:42.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.767]             base::sink(type = "output", split = FALSE)
[17:39:42.767]             base::close(...future.stdout)
[17:39:42.767]         }, add = TRUE)
[17:39:42.767]     }
[17:39:42.767]     ...future.frame <- base::sys.nframe()
[17:39:42.767]     ...future.conditions <- base::list()
[17:39:42.767]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.767]     if (FALSE) {
[17:39:42.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.767]     }
[17:39:42.767]     ...future.result <- base::tryCatch({
[17:39:42.767]         base::withCallingHandlers({
[17:39:42.767]             ...future.value <- base::withVisible(base::local({
[17:39:42.767]                 ...future.makeSendCondition <- base::local({
[17:39:42.767]                   sendCondition <- NULL
[17:39:42.767]                   function(frame = 1L) {
[17:39:42.767]                     if (is.function(sendCondition)) 
[17:39:42.767]                       return(sendCondition)
[17:39:42.767]                     ns <- getNamespace("parallel")
[17:39:42.767]                     if (exists("sendData", mode = "function", 
[17:39:42.767]                       envir = ns)) {
[17:39:42.767]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.767]                         envir = ns)
[17:39:42.767]                       envir <- sys.frame(frame)
[17:39:42.767]                       master <- NULL
[17:39:42.767]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.767]                         !identical(envir, emptyenv())) {
[17:39:42.767]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.767]                           inherits = FALSE)) {
[17:39:42.767]                           master <- get("master", mode = "list", 
[17:39:42.767]                             envir = envir, inherits = FALSE)
[17:39:42.767]                           if (inherits(master, c("SOCKnode", 
[17:39:42.767]                             "SOCK0node"))) {
[17:39:42.767]                             sendCondition <<- function(cond) {
[17:39:42.767]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.767]                                 success = TRUE)
[17:39:42.767]                               parallel_sendData(master, data)
[17:39:42.767]                             }
[17:39:42.767]                             return(sendCondition)
[17:39:42.767]                           }
[17:39:42.767]                         }
[17:39:42.767]                         frame <- frame + 1L
[17:39:42.767]                         envir <- sys.frame(frame)
[17:39:42.767]                       }
[17:39:42.767]                     }
[17:39:42.767]                     sendCondition <<- function(cond) NULL
[17:39:42.767]                   }
[17:39:42.767]                 })
[17:39:42.767]                 withCallingHandlers({
[17:39:42.767]                   {
[17:39:42.767]                     lm(dist ~ poly(speed, 2), data = cars)
[17:39:42.767]                   }
[17:39:42.767]                 }, immediateCondition = function(cond) {
[17:39:42.767]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.767]                   sendCondition(cond)
[17:39:42.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.767]                   {
[17:39:42.767]                     inherits <- base::inherits
[17:39:42.767]                     invokeRestart <- base::invokeRestart
[17:39:42.767]                     is.null <- base::is.null
[17:39:42.767]                     muffled <- FALSE
[17:39:42.767]                     if (inherits(cond, "message")) {
[17:39:42.767]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.767]                       if (muffled) 
[17:39:42.767]                         invokeRestart("muffleMessage")
[17:39:42.767]                     }
[17:39:42.767]                     else if (inherits(cond, "warning")) {
[17:39:42.767]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.767]                       if (muffled) 
[17:39:42.767]                         invokeRestart("muffleWarning")
[17:39:42.767]                     }
[17:39:42.767]                     else if (inherits(cond, "condition")) {
[17:39:42.767]                       if (!is.null(pattern)) {
[17:39:42.767]                         computeRestarts <- base::computeRestarts
[17:39:42.767]                         grepl <- base::grepl
[17:39:42.767]                         restarts <- computeRestarts(cond)
[17:39:42.767]                         for (restart in restarts) {
[17:39:42.767]                           name <- restart$name
[17:39:42.767]                           if (is.null(name)) 
[17:39:42.767]                             next
[17:39:42.767]                           if (!grepl(pattern, name)) 
[17:39:42.767]                             next
[17:39:42.767]                           invokeRestart(restart)
[17:39:42.767]                           muffled <- TRUE
[17:39:42.767]                           break
[17:39:42.767]                         }
[17:39:42.767]                       }
[17:39:42.767]                     }
[17:39:42.767]                     invisible(muffled)
[17:39:42.767]                   }
[17:39:42.767]                   muffleCondition(cond)
[17:39:42.767]                 })
[17:39:42.767]             }))
[17:39:42.767]             future::FutureResult(value = ...future.value$value, 
[17:39:42.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.767]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.767]                     ...future.globalenv.names))
[17:39:42.767]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.767]         }, condition = base::local({
[17:39:42.767]             c <- base::c
[17:39:42.767]             inherits <- base::inherits
[17:39:42.767]             invokeRestart <- base::invokeRestart
[17:39:42.767]             length <- base::length
[17:39:42.767]             list <- base::list
[17:39:42.767]             seq.int <- base::seq.int
[17:39:42.767]             signalCondition <- base::signalCondition
[17:39:42.767]             sys.calls <- base::sys.calls
[17:39:42.767]             `[[` <- base::`[[`
[17:39:42.767]             `+` <- base::`+`
[17:39:42.767]             `<<-` <- base::`<<-`
[17:39:42.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.767]                   3L)]
[17:39:42.767]             }
[17:39:42.767]             function(cond) {
[17:39:42.767]                 is_error <- inherits(cond, "error")
[17:39:42.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.767]                   NULL)
[17:39:42.767]                 if (is_error) {
[17:39:42.767]                   sessionInformation <- function() {
[17:39:42.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.767]                       search = base::search(), system = base::Sys.info())
[17:39:42.767]                   }
[17:39:42.767]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.767]                     cond$call), session = sessionInformation(), 
[17:39:42.767]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.767]                   signalCondition(cond)
[17:39:42.767]                 }
[17:39:42.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.767]                 "immediateCondition"))) {
[17:39:42.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.767]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.767]                   if (TRUE && !signal) {
[17:39:42.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.767]                     {
[17:39:42.767]                       inherits <- base::inherits
[17:39:42.767]                       invokeRestart <- base::invokeRestart
[17:39:42.767]                       is.null <- base::is.null
[17:39:42.767]                       muffled <- FALSE
[17:39:42.767]                       if (inherits(cond, "message")) {
[17:39:42.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.767]                         if (muffled) 
[17:39:42.767]                           invokeRestart("muffleMessage")
[17:39:42.767]                       }
[17:39:42.767]                       else if (inherits(cond, "warning")) {
[17:39:42.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.767]                         if (muffled) 
[17:39:42.767]                           invokeRestart("muffleWarning")
[17:39:42.767]                       }
[17:39:42.767]                       else if (inherits(cond, "condition")) {
[17:39:42.767]                         if (!is.null(pattern)) {
[17:39:42.767]                           computeRestarts <- base::computeRestarts
[17:39:42.767]                           grepl <- base::grepl
[17:39:42.767]                           restarts <- computeRestarts(cond)
[17:39:42.767]                           for (restart in restarts) {
[17:39:42.767]                             name <- restart$name
[17:39:42.767]                             if (is.null(name)) 
[17:39:42.767]                               next
[17:39:42.767]                             if (!grepl(pattern, name)) 
[17:39:42.767]                               next
[17:39:42.767]                             invokeRestart(restart)
[17:39:42.767]                             muffled <- TRUE
[17:39:42.767]                             break
[17:39:42.767]                           }
[17:39:42.767]                         }
[17:39:42.767]                       }
[17:39:42.767]                       invisible(muffled)
[17:39:42.767]                     }
[17:39:42.767]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.767]                   }
[17:39:42.767]                 }
[17:39:42.767]                 else {
[17:39:42.767]                   if (TRUE) {
[17:39:42.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.767]                     {
[17:39:42.767]                       inherits <- base::inherits
[17:39:42.767]                       invokeRestart <- base::invokeRestart
[17:39:42.767]                       is.null <- base::is.null
[17:39:42.767]                       muffled <- FALSE
[17:39:42.767]                       if (inherits(cond, "message")) {
[17:39:42.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.767]                         if (muffled) 
[17:39:42.767]                           invokeRestart("muffleMessage")
[17:39:42.767]                       }
[17:39:42.767]                       else if (inherits(cond, "warning")) {
[17:39:42.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.767]                         if (muffled) 
[17:39:42.767]                           invokeRestart("muffleWarning")
[17:39:42.767]                       }
[17:39:42.767]                       else if (inherits(cond, "condition")) {
[17:39:42.767]                         if (!is.null(pattern)) {
[17:39:42.767]                           computeRestarts <- base::computeRestarts
[17:39:42.767]                           grepl <- base::grepl
[17:39:42.767]                           restarts <- computeRestarts(cond)
[17:39:42.767]                           for (restart in restarts) {
[17:39:42.767]                             name <- restart$name
[17:39:42.767]                             if (is.null(name)) 
[17:39:42.767]                               next
[17:39:42.767]                             if (!grepl(pattern, name)) 
[17:39:42.767]                               next
[17:39:42.767]                             invokeRestart(restart)
[17:39:42.767]                             muffled <- TRUE
[17:39:42.767]                             break
[17:39:42.767]                           }
[17:39:42.767]                         }
[17:39:42.767]                       }
[17:39:42.767]                       invisible(muffled)
[17:39:42.767]                     }
[17:39:42.767]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.767]                   }
[17:39:42.767]                 }
[17:39:42.767]             }
[17:39:42.767]         }))
[17:39:42.767]     }, error = function(ex) {
[17:39:42.767]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.767]                 ...future.rng), started = ...future.startTime, 
[17:39:42.767]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.767]             version = "1.8"), class = "FutureResult")
[17:39:42.767]     }, finally = {
[17:39:42.767]         if (!identical(...future.workdir, getwd())) 
[17:39:42.767]             setwd(...future.workdir)
[17:39:42.767]         {
[17:39:42.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.767]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.767]             }
[17:39:42.767]             base::options(...future.oldOptions)
[17:39:42.767]             if (.Platform$OS.type == "windows") {
[17:39:42.767]                 old_names <- names(...future.oldEnvVars)
[17:39:42.767]                 envs <- base::Sys.getenv()
[17:39:42.767]                 names <- names(envs)
[17:39:42.767]                 common <- intersect(names, old_names)
[17:39:42.767]                 added <- setdiff(names, old_names)
[17:39:42.767]                 removed <- setdiff(old_names, names)
[17:39:42.767]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.767]                   envs[common]]
[17:39:42.767]                 NAMES <- toupper(changed)
[17:39:42.767]                 args <- list()
[17:39:42.767]                 for (kk in seq_along(NAMES)) {
[17:39:42.767]                   name <- changed[[kk]]
[17:39:42.767]                   NAME <- NAMES[[kk]]
[17:39:42.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.767]                     next
[17:39:42.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.767]                 }
[17:39:42.767]                 NAMES <- toupper(added)
[17:39:42.767]                 for (kk in seq_along(NAMES)) {
[17:39:42.767]                   name <- added[[kk]]
[17:39:42.767]                   NAME <- NAMES[[kk]]
[17:39:42.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.767]                     next
[17:39:42.767]                   args[[name]] <- ""
[17:39:42.767]                 }
[17:39:42.767]                 NAMES <- toupper(removed)
[17:39:42.767]                 for (kk in seq_along(NAMES)) {
[17:39:42.767]                   name <- removed[[kk]]
[17:39:42.767]                   NAME <- NAMES[[kk]]
[17:39:42.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.767]                     next
[17:39:42.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.767]                 }
[17:39:42.767]                 if (length(args) > 0) 
[17:39:42.767]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.767]             }
[17:39:42.767]             else {
[17:39:42.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.767]             }
[17:39:42.767]             {
[17:39:42.767]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.767]                   0L) {
[17:39:42.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.767]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.767]                   base::options(opts)
[17:39:42.767]                 }
[17:39:42.767]                 {
[17:39:42.767]                   {
[17:39:42.767]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.767]                     NULL
[17:39:42.767]                   }
[17:39:42.767]                   options(future.plan = NULL)
[17:39:42.767]                   if (is.na(NA_character_)) 
[17:39:42.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.767]                     .init = FALSE)
[17:39:42.767]                 }
[17:39:42.767]             }
[17:39:42.767]         }
[17:39:42.767]     })
[17:39:42.767]     if (TRUE) {
[17:39:42.767]         base::sink(type = "output", split = FALSE)
[17:39:42.767]         if (TRUE) {
[17:39:42.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.767]         }
[17:39:42.767]         else {
[17:39:42.767]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.767]         }
[17:39:42.767]         base::close(...future.stdout)
[17:39:42.767]         ...future.stdout <- NULL
[17:39:42.767]     }
[17:39:42.767]     ...future.result$conditions <- ...future.conditions
[17:39:42.767]     ...future.result$finished <- base::Sys.time()
[17:39:42.767]     ...future.result
[17:39:42.767] }
[17:39:42.770] MultisessionFuture started
[17:39:42.770] - Launch lazy future ... done
[17:39:42.770] run() for ‘MultisessionFuture’ ... done
[17:39:42.770] result() for ClusterFuture ...
[17:39:42.770] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.771] - Validating connection of MultisessionFuture
[17:39:42.816] - received message: FutureResult
[17:39:42.816] - Received FutureResult
[17:39:42.817] - Erased future from FutureRegistry
[17:39:42.817] result() for ClusterFuture ...
[17:39:42.817] - result already collected: FutureResult
[17:39:42.817] result() for ClusterFuture ... done
[17:39:42.817] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.817] result() for ClusterFuture ... done
[17:39:42.817] result() for ClusterFuture ...
[17:39:42.817] - result already collected: FutureResult
[17:39:42.817] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[17:39:42.819] getGlobalsAndPackages() ...
[17:39:42.819] Searching for globals...
[17:39:42.824] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:39:42.824] Searching for globals ... DONE
[17:39:42.824] Resolving globals: FALSE
[17:39:42.825] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:39:42.825] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:39:42.825] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:39:42.825] 
[17:39:42.825] getGlobalsAndPackages() ... DONE
[17:39:42.825] run() for ‘Future’ ...
[17:39:42.826] - state: ‘created’
[17:39:42.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.840]   - Field: ‘node’
[17:39:42.840]   - Field: ‘label’
[17:39:42.840]   - Field: ‘local’
[17:39:42.840]   - Field: ‘owner’
[17:39:42.840]   - Field: ‘envir’
[17:39:42.840]   - Field: ‘workers’
[17:39:42.841]   - Field: ‘packages’
[17:39:42.841]   - Field: ‘gc’
[17:39:42.841]   - Field: ‘conditions’
[17:39:42.841]   - Field: ‘persistent’
[17:39:42.841]   - Field: ‘expr’
[17:39:42.841]   - Field: ‘uuid’
[17:39:42.841]   - Field: ‘seed’
[17:39:42.841]   - Field: ‘version’
[17:39:42.841]   - Field: ‘result’
[17:39:42.841]   - Field: ‘asynchronous’
[17:39:42.841]   - Field: ‘calls’
[17:39:42.841]   - Field: ‘globals’
[17:39:42.842]   - Field: ‘stdout’
[17:39:42.842]   - Field: ‘earlySignal’
[17:39:42.842]   - Field: ‘lazy’
[17:39:42.842]   - Field: ‘state’
[17:39:42.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.842] - Launch lazy future ...
[17:39:42.842] Packages needed by the future expression (n = 0): <none>
[17:39:42.842] Packages needed by future strategies (n = 0): <none>
[17:39:42.843] {
[17:39:42.843]     {
[17:39:42.843]         {
[17:39:42.843]             ...future.startTime <- base::Sys.time()
[17:39:42.843]             {
[17:39:42.843]                 {
[17:39:42.843]                   {
[17:39:42.843]                     {
[17:39:42.843]                       base::local({
[17:39:42.843]                         has_future <- base::requireNamespace("future", 
[17:39:42.843]                           quietly = TRUE)
[17:39:42.843]                         if (has_future) {
[17:39:42.843]                           ns <- base::getNamespace("future")
[17:39:42.843]                           version <- ns[[".package"]][["version"]]
[17:39:42.843]                           if (is.null(version)) 
[17:39:42.843]                             version <- utils::packageVersion("future")
[17:39:42.843]                         }
[17:39:42.843]                         else {
[17:39:42.843]                           version <- NULL
[17:39:42.843]                         }
[17:39:42.843]                         if (!has_future || version < "1.8.0") {
[17:39:42.843]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.843]                             "", base::R.version$version.string), 
[17:39:42.843]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:42.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:42.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.843]                               "release", "version")], collapse = " "), 
[17:39:42.843]                             hostname = base::Sys.info()[["nodename"]])
[17:39:42.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.843]                             info)
[17:39:42.843]                           info <- base::paste(info, collapse = "; ")
[17:39:42.843]                           if (!has_future) {
[17:39:42.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.843]                               info)
[17:39:42.843]                           }
[17:39:42.843]                           else {
[17:39:42.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.843]                               info, version)
[17:39:42.843]                           }
[17:39:42.843]                           base::stop(msg)
[17:39:42.843]                         }
[17:39:42.843]                       })
[17:39:42.843]                     }
[17:39:42.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.843]                     base::options(mc.cores = 1L)
[17:39:42.843]                   }
[17:39:42.843]                   ...future.strategy.old <- future::plan("list")
[17:39:42.843]                   options(future.plan = NULL)
[17:39:42.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.843]                 }
[17:39:42.843]                 ...future.workdir <- getwd()
[17:39:42.843]             }
[17:39:42.843]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.843]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.843]         }
[17:39:42.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.843]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.843]             base::names(...future.oldOptions))
[17:39:42.843]     }
[17:39:42.843]     if (FALSE) {
[17:39:42.843]     }
[17:39:42.843]     else {
[17:39:42.843]         if (TRUE) {
[17:39:42.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.843]                 open = "w")
[17:39:42.843]         }
[17:39:42.843]         else {
[17:39:42.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.843]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.843]         }
[17:39:42.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.843]             base::sink(type = "output", split = FALSE)
[17:39:42.843]             base::close(...future.stdout)
[17:39:42.843]         }, add = TRUE)
[17:39:42.843]     }
[17:39:42.843]     ...future.frame <- base::sys.nframe()
[17:39:42.843]     ...future.conditions <- base::list()
[17:39:42.843]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.843]     if (FALSE) {
[17:39:42.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.843]     }
[17:39:42.843]     ...future.result <- base::tryCatch({
[17:39:42.843]         base::withCallingHandlers({
[17:39:42.843]             ...future.value <- base::withVisible(base::local({
[17:39:42.843]                 ...future.makeSendCondition <- base::local({
[17:39:42.843]                   sendCondition <- NULL
[17:39:42.843]                   function(frame = 1L) {
[17:39:42.843]                     if (is.function(sendCondition)) 
[17:39:42.843]                       return(sendCondition)
[17:39:42.843]                     ns <- getNamespace("parallel")
[17:39:42.843]                     if (exists("sendData", mode = "function", 
[17:39:42.843]                       envir = ns)) {
[17:39:42.843]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.843]                         envir = ns)
[17:39:42.843]                       envir <- sys.frame(frame)
[17:39:42.843]                       master <- NULL
[17:39:42.843]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.843]                         !identical(envir, emptyenv())) {
[17:39:42.843]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.843]                           inherits = FALSE)) {
[17:39:42.843]                           master <- get("master", mode = "list", 
[17:39:42.843]                             envir = envir, inherits = FALSE)
[17:39:42.843]                           if (inherits(master, c("SOCKnode", 
[17:39:42.843]                             "SOCK0node"))) {
[17:39:42.843]                             sendCondition <<- function(cond) {
[17:39:42.843]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.843]                                 success = TRUE)
[17:39:42.843]                               parallel_sendData(master, data)
[17:39:42.843]                             }
[17:39:42.843]                             return(sendCondition)
[17:39:42.843]                           }
[17:39:42.843]                         }
[17:39:42.843]                         frame <- frame + 1L
[17:39:42.843]                         envir <- sys.frame(frame)
[17:39:42.843]                       }
[17:39:42.843]                     }
[17:39:42.843]                     sendCondition <<- function(cond) NULL
[17:39:42.843]                   }
[17:39:42.843]                 })
[17:39:42.843]                 withCallingHandlers({
[17:39:42.843]                   {
[17:39:42.843]                     outer_function(1L)
[17:39:42.843]                   }
[17:39:42.843]                 }, immediateCondition = function(cond) {
[17:39:42.843]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.843]                   sendCondition(cond)
[17:39:42.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.843]                   {
[17:39:42.843]                     inherits <- base::inherits
[17:39:42.843]                     invokeRestart <- base::invokeRestart
[17:39:42.843]                     is.null <- base::is.null
[17:39:42.843]                     muffled <- FALSE
[17:39:42.843]                     if (inherits(cond, "message")) {
[17:39:42.843]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.843]                       if (muffled) 
[17:39:42.843]                         invokeRestart("muffleMessage")
[17:39:42.843]                     }
[17:39:42.843]                     else if (inherits(cond, "warning")) {
[17:39:42.843]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.843]                       if (muffled) 
[17:39:42.843]                         invokeRestart("muffleWarning")
[17:39:42.843]                     }
[17:39:42.843]                     else if (inherits(cond, "condition")) {
[17:39:42.843]                       if (!is.null(pattern)) {
[17:39:42.843]                         computeRestarts <- base::computeRestarts
[17:39:42.843]                         grepl <- base::grepl
[17:39:42.843]                         restarts <- computeRestarts(cond)
[17:39:42.843]                         for (restart in restarts) {
[17:39:42.843]                           name <- restart$name
[17:39:42.843]                           if (is.null(name)) 
[17:39:42.843]                             next
[17:39:42.843]                           if (!grepl(pattern, name)) 
[17:39:42.843]                             next
[17:39:42.843]                           invokeRestart(restart)
[17:39:42.843]                           muffled <- TRUE
[17:39:42.843]                           break
[17:39:42.843]                         }
[17:39:42.843]                       }
[17:39:42.843]                     }
[17:39:42.843]                     invisible(muffled)
[17:39:42.843]                   }
[17:39:42.843]                   muffleCondition(cond)
[17:39:42.843]                 })
[17:39:42.843]             }))
[17:39:42.843]             future::FutureResult(value = ...future.value$value, 
[17:39:42.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.843]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.843]                     ...future.globalenv.names))
[17:39:42.843]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.843]         }, condition = base::local({
[17:39:42.843]             c <- base::c
[17:39:42.843]             inherits <- base::inherits
[17:39:42.843]             invokeRestart <- base::invokeRestart
[17:39:42.843]             length <- base::length
[17:39:42.843]             list <- base::list
[17:39:42.843]             seq.int <- base::seq.int
[17:39:42.843]             signalCondition <- base::signalCondition
[17:39:42.843]             sys.calls <- base::sys.calls
[17:39:42.843]             `[[` <- base::`[[`
[17:39:42.843]             `+` <- base::`+`
[17:39:42.843]             `<<-` <- base::`<<-`
[17:39:42.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.843]                   3L)]
[17:39:42.843]             }
[17:39:42.843]             function(cond) {
[17:39:42.843]                 is_error <- inherits(cond, "error")
[17:39:42.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.843]                   NULL)
[17:39:42.843]                 if (is_error) {
[17:39:42.843]                   sessionInformation <- function() {
[17:39:42.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.843]                       search = base::search(), system = base::Sys.info())
[17:39:42.843]                   }
[17:39:42.843]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.843]                     cond$call), session = sessionInformation(), 
[17:39:42.843]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.843]                   signalCondition(cond)
[17:39:42.843]                 }
[17:39:42.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.843]                 "immediateCondition"))) {
[17:39:42.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.843]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.843]                   if (TRUE && !signal) {
[17:39:42.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.843]                     {
[17:39:42.843]                       inherits <- base::inherits
[17:39:42.843]                       invokeRestart <- base::invokeRestart
[17:39:42.843]                       is.null <- base::is.null
[17:39:42.843]                       muffled <- FALSE
[17:39:42.843]                       if (inherits(cond, "message")) {
[17:39:42.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.843]                         if (muffled) 
[17:39:42.843]                           invokeRestart("muffleMessage")
[17:39:42.843]                       }
[17:39:42.843]                       else if (inherits(cond, "warning")) {
[17:39:42.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.843]                         if (muffled) 
[17:39:42.843]                           invokeRestart("muffleWarning")
[17:39:42.843]                       }
[17:39:42.843]                       else if (inherits(cond, "condition")) {
[17:39:42.843]                         if (!is.null(pattern)) {
[17:39:42.843]                           computeRestarts <- base::computeRestarts
[17:39:42.843]                           grepl <- base::grepl
[17:39:42.843]                           restarts <- computeRestarts(cond)
[17:39:42.843]                           for (restart in restarts) {
[17:39:42.843]                             name <- restart$name
[17:39:42.843]                             if (is.null(name)) 
[17:39:42.843]                               next
[17:39:42.843]                             if (!grepl(pattern, name)) 
[17:39:42.843]                               next
[17:39:42.843]                             invokeRestart(restart)
[17:39:42.843]                             muffled <- TRUE
[17:39:42.843]                             break
[17:39:42.843]                           }
[17:39:42.843]                         }
[17:39:42.843]                       }
[17:39:42.843]                       invisible(muffled)
[17:39:42.843]                     }
[17:39:42.843]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.843]                   }
[17:39:42.843]                 }
[17:39:42.843]                 else {
[17:39:42.843]                   if (TRUE) {
[17:39:42.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.843]                     {
[17:39:42.843]                       inherits <- base::inherits
[17:39:42.843]                       invokeRestart <- base::invokeRestart
[17:39:42.843]                       is.null <- base::is.null
[17:39:42.843]                       muffled <- FALSE
[17:39:42.843]                       if (inherits(cond, "message")) {
[17:39:42.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.843]                         if (muffled) 
[17:39:42.843]                           invokeRestart("muffleMessage")
[17:39:42.843]                       }
[17:39:42.843]                       else if (inherits(cond, "warning")) {
[17:39:42.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.843]                         if (muffled) 
[17:39:42.843]                           invokeRestart("muffleWarning")
[17:39:42.843]                       }
[17:39:42.843]                       else if (inherits(cond, "condition")) {
[17:39:42.843]                         if (!is.null(pattern)) {
[17:39:42.843]                           computeRestarts <- base::computeRestarts
[17:39:42.843]                           grepl <- base::grepl
[17:39:42.843]                           restarts <- computeRestarts(cond)
[17:39:42.843]                           for (restart in restarts) {
[17:39:42.843]                             name <- restart$name
[17:39:42.843]                             if (is.null(name)) 
[17:39:42.843]                               next
[17:39:42.843]                             if (!grepl(pattern, name)) 
[17:39:42.843]                               next
[17:39:42.843]                             invokeRestart(restart)
[17:39:42.843]                             muffled <- TRUE
[17:39:42.843]                             break
[17:39:42.843]                           }
[17:39:42.843]                         }
[17:39:42.843]                       }
[17:39:42.843]                       invisible(muffled)
[17:39:42.843]                     }
[17:39:42.843]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.843]                   }
[17:39:42.843]                 }
[17:39:42.843]             }
[17:39:42.843]         }))
[17:39:42.843]     }, error = function(ex) {
[17:39:42.843]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.843]                 ...future.rng), started = ...future.startTime, 
[17:39:42.843]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.843]             version = "1.8"), class = "FutureResult")
[17:39:42.843]     }, finally = {
[17:39:42.843]         if (!identical(...future.workdir, getwd())) 
[17:39:42.843]             setwd(...future.workdir)
[17:39:42.843]         {
[17:39:42.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.843]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.843]             }
[17:39:42.843]             base::options(...future.oldOptions)
[17:39:42.843]             if (.Platform$OS.type == "windows") {
[17:39:42.843]                 old_names <- names(...future.oldEnvVars)
[17:39:42.843]                 envs <- base::Sys.getenv()
[17:39:42.843]                 names <- names(envs)
[17:39:42.843]                 common <- intersect(names, old_names)
[17:39:42.843]                 added <- setdiff(names, old_names)
[17:39:42.843]                 removed <- setdiff(old_names, names)
[17:39:42.843]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.843]                   envs[common]]
[17:39:42.843]                 NAMES <- toupper(changed)
[17:39:42.843]                 args <- list()
[17:39:42.843]                 for (kk in seq_along(NAMES)) {
[17:39:42.843]                   name <- changed[[kk]]
[17:39:42.843]                   NAME <- NAMES[[kk]]
[17:39:42.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.843]                     next
[17:39:42.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.843]                 }
[17:39:42.843]                 NAMES <- toupper(added)
[17:39:42.843]                 for (kk in seq_along(NAMES)) {
[17:39:42.843]                   name <- added[[kk]]
[17:39:42.843]                   NAME <- NAMES[[kk]]
[17:39:42.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.843]                     next
[17:39:42.843]                   args[[name]] <- ""
[17:39:42.843]                 }
[17:39:42.843]                 NAMES <- toupper(removed)
[17:39:42.843]                 for (kk in seq_along(NAMES)) {
[17:39:42.843]                   name <- removed[[kk]]
[17:39:42.843]                   NAME <- NAMES[[kk]]
[17:39:42.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.843]                     next
[17:39:42.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.843]                 }
[17:39:42.843]                 if (length(args) > 0) 
[17:39:42.843]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.843]             }
[17:39:42.843]             else {
[17:39:42.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.843]             }
[17:39:42.843]             {
[17:39:42.843]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.843]                   0L) {
[17:39:42.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.843]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.843]                   base::options(opts)
[17:39:42.843]                 }
[17:39:42.843]                 {
[17:39:42.843]                   {
[17:39:42.843]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.843]                     NULL
[17:39:42.843]                   }
[17:39:42.843]                   options(future.plan = NULL)
[17:39:42.843]                   if (is.na(NA_character_)) 
[17:39:42.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.843]                     .init = FALSE)
[17:39:42.843]                 }
[17:39:42.843]             }
[17:39:42.843]         }
[17:39:42.843]     })
[17:39:42.843]     if (TRUE) {
[17:39:42.843]         base::sink(type = "output", split = FALSE)
[17:39:42.843]         if (TRUE) {
[17:39:42.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.843]         }
[17:39:42.843]         else {
[17:39:42.843]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.843]         }
[17:39:42.843]         base::close(...future.stdout)
[17:39:42.843]         ...future.stdout <- NULL
[17:39:42.843]     }
[17:39:42.843]     ...future.result$conditions <- ...future.conditions
[17:39:42.843]     ...future.result$finished <- base::Sys.time()
[17:39:42.843]     ...future.result
[17:39:42.843] }
[17:39:42.848] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[17:39:42.848] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[17:39:42.848] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[17:39:42.848] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[17:39:42.849] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[17:39:42.849] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[17:39:42.849] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[17:39:42.849] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[17:39:42.850] MultisessionFuture started
[17:39:42.850] - Launch lazy future ... done
[17:39:42.850] run() for ‘MultisessionFuture’ ... done
[17:39:42.850] result() for ClusterFuture ...
[17:39:42.850] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.850] - Validating connection of MultisessionFuture
[17:39:42.856] - received message: FutureResult
[17:39:42.856] - Received FutureResult
[17:39:42.856] - Erased future from FutureRegistry
[17:39:42.856] result() for ClusterFuture ...
[17:39:42.856] - result already collected: FutureResult
[17:39:42.857] result() for ClusterFuture ... done
[17:39:42.857] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.857] result() for ClusterFuture ... done
[17:39:42.857] result() for ClusterFuture ...
[17:39:42.857] - result already collected: FutureResult
[17:39:42.857] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[17:39:42.858] getGlobalsAndPackages() ...
[17:39:42.858] Searching for globals...
[17:39:42.862] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[17:39:42.862] Searching for globals ... DONE
[17:39:42.862] Resolving globals: FALSE
[17:39:42.863] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[17:39:42.863] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[17:39:42.864] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[17:39:42.864] 
[17:39:42.864] getGlobalsAndPackages() ... DONE
[17:39:42.864] run() for ‘Future’ ...
[17:39:42.864] - state: ‘created’
[17:39:42.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:42.879] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:42.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:42.879]   - Field: ‘node’
[17:39:42.879]   - Field: ‘label’
[17:39:42.879]   - Field: ‘local’
[17:39:42.879]   - Field: ‘owner’
[17:39:42.879]   - Field: ‘envir’
[17:39:42.879]   - Field: ‘workers’
[17:39:42.880]   - Field: ‘packages’
[17:39:42.880]   - Field: ‘gc’
[17:39:42.880]   - Field: ‘conditions’
[17:39:42.880]   - Field: ‘persistent’
[17:39:42.880]   - Field: ‘expr’
[17:39:42.880]   - Field: ‘uuid’
[17:39:42.880]   - Field: ‘seed’
[17:39:42.880]   - Field: ‘version’
[17:39:42.880]   - Field: ‘result’
[17:39:42.880]   - Field: ‘asynchronous’
[17:39:42.881]   - Field: ‘calls’
[17:39:42.881]   - Field: ‘globals’
[17:39:42.881]   - Field: ‘stdout’
[17:39:42.881]   - Field: ‘earlySignal’
[17:39:42.881]   - Field: ‘lazy’
[17:39:42.881]   - Field: ‘state’
[17:39:42.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:42.881] - Launch lazy future ...
[17:39:42.881] Packages needed by the future expression (n = 0): <none>
[17:39:42.882] Packages needed by future strategies (n = 0): <none>
[17:39:42.882] {
[17:39:42.882]     {
[17:39:42.882]         {
[17:39:42.882]             ...future.startTime <- base::Sys.time()
[17:39:42.882]             {
[17:39:42.882]                 {
[17:39:42.882]                   {
[17:39:42.882]                     {
[17:39:42.882]                       base::local({
[17:39:42.882]                         has_future <- base::requireNamespace("future", 
[17:39:42.882]                           quietly = TRUE)
[17:39:42.882]                         if (has_future) {
[17:39:42.882]                           ns <- base::getNamespace("future")
[17:39:42.882]                           version <- ns[[".package"]][["version"]]
[17:39:42.882]                           if (is.null(version)) 
[17:39:42.882]                             version <- utils::packageVersion("future")
[17:39:42.882]                         }
[17:39:42.882]                         else {
[17:39:42.882]                           version <- NULL
[17:39:42.882]                         }
[17:39:42.882]                         if (!has_future || version < "1.8.0") {
[17:39:42.882]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:42.882]                             "", base::R.version$version.string), 
[17:39:42.882]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:42.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:42.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:42.882]                               "release", "version")], collapse = " "), 
[17:39:42.882]                             hostname = base::Sys.info()[["nodename"]])
[17:39:42.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:42.882]                             info)
[17:39:42.882]                           info <- base::paste(info, collapse = "; ")
[17:39:42.882]                           if (!has_future) {
[17:39:42.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:42.882]                               info)
[17:39:42.882]                           }
[17:39:42.882]                           else {
[17:39:42.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:42.882]                               info, version)
[17:39:42.882]                           }
[17:39:42.882]                           base::stop(msg)
[17:39:42.882]                         }
[17:39:42.882]                       })
[17:39:42.882]                     }
[17:39:42.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:42.882]                     base::options(mc.cores = 1L)
[17:39:42.882]                   }
[17:39:42.882]                   ...future.strategy.old <- future::plan("list")
[17:39:42.882]                   options(future.plan = NULL)
[17:39:42.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:42.882]                 }
[17:39:42.882]                 ...future.workdir <- getwd()
[17:39:42.882]             }
[17:39:42.882]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:42.882]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:42.882]         }
[17:39:42.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:42.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:42.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:42.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:42.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:42.882]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:42.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:42.882]             base::names(...future.oldOptions))
[17:39:42.882]     }
[17:39:42.882]     if (FALSE) {
[17:39:42.882]     }
[17:39:42.882]     else {
[17:39:42.882]         if (TRUE) {
[17:39:42.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:42.882]                 open = "w")
[17:39:42.882]         }
[17:39:42.882]         else {
[17:39:42.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:42.882]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:42.882]         }
[17:39:42.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:42.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:42.882]             base::sink(type = "output", split = FALSE)
[17:39:42.882]             base::close(...future.stdout)
[17:39:42.882]         }, add = TRUE)
[17:39:42.882]     }
[17:39:42.882]     ...future.frame <- base::sys.nframe()
[17:39:42.882]     ...future.conditions <- base::list()
[17:39:42.882]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:42.882]     if (FALSE) {
[17:39:42.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:42.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:42.882]     }
[17:39:42.882]     ...future.result <- base::tryCatch({
[17:39:42.882]         base::withCallingHandlers({
[17:39:42.882]             ...future.value <- base::withVisible(base::local({
[17:39:42.882]                 ...future.makeSendCondition <- base::local({
[17:39:42.882]                   sendCondition <- NULL
[17:39:42.882]                   function(frame = 1L) {
[17:39:42.882]                     if (is.function(sendCondition)) 
[17:39:42.882]                       return(sendCondition)
[17:39:42.882]                     ns <- getNamespace("parallel")
[17:39:42.882]                     if (exists("sendData", mode = "function", 
[17:39:42.882]                       envir = ns)) {
[17:39:42.882]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:42.882]                         envir = ns)
[17:39:42.882]                       envir <- sys.frame(frame)
[17:39:42.882]                       master <- NULL
[17:39:42.882]                       while (!identical(envir, .GlobalEnv) && 
[17:39:42.882]                         !identical(envir, emptyenv())) {
[17:39:42.882]                         if (exists("master", mode = "list", envir = envir, 
[17:39:42.882]                           inherits = FALSE)) {
[17:39:42.882]                           master <- get("master", mode = "list", 
[17:39:42.882]                             envir = envir, inherits = FALSE)
[17:39:42.882]                           if (inherits(master, c("SOCKnode", 
[17:39:42.882]                             "SOCK0node"))) {
[17:39:42.882]                             sendCondition <<- function(cond) {
[17:39:42.882]                               data <- list(type = "VALUE", value = cond, 
[17:39:42.882]                                 success = TRUE)
[17:39:42.882]                               parallel_sendData(master, data)
[17:39:42.882]                             }
[17:39:42.882]                             return(sendCondition)
[17:39:42.882]                           }
[17:39:42.882]                         }
[17:39:42.882]                         frame <- frame + 1L
[17:39:42.882]                         envir <- sys.frame(frame)
[17:39:42.882]                       }
[17:39:42.882]                     }
[17:39:42.882]                     sendCondition <<- function(cond) NULL
[17:39:42.882]                   }
[17:39:42.882]                 })
[17:39:42.882]                 withCallingHandlers({
[17:39:42.882]                   {
[17:39:42.882]                     outer_function(1L)
[17:39:42.882]                   }
[17:39:42.882]                 }, immediateCondition = function(cond) {
[17:39:42.882]                   sendCondition <- ...future.makeSendCondition()
[17:39:42.882]                   sendCondition(cond)
[17:39:42.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.882]                   {
[17:39:42.882]                     inherits <- base::inherits
[17:39:42.882]                     invokeRestart <- base::invokeRestart
[17:39:42.882]                     is.null <- base::is.null
[17:39:42.882]                     muffled <- FALSE
[17:39:42.882]                     if (inherits(cond, "message")) {
[17:39:42.882]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:42.882]                       if (muffled) 
[17:39:42.882]                         invokeRestart("muffleMessage")
[17:39:42.882]                     }
[17:39:42.882]                     else if (inherits(cond, "warning")) {
[17:39:42.882]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:42.882]                       if (muffled) 
[17:39:42.882]                         invokeRestart("muffleWarning")
[17:39:42.882]                     }
[17:39:42.882]                     else if (inherits(cond, "condition")) {
[17:39:42.882]                       if (!is.null(pattern)) {
[17:39:42.882]                         computeRestarts <- base::computeRestarts
[17:39:42.882]                         grepl <- base::grepl
[17:39:42.882]                         restarts <- computeRestarts(cond)
[17:39:42.882]                         for (restart in restarts) {
[17:39:42.882]                           name <- restart$name
[17:39:42.882]                           if (is.null(name)) 
[17:39:42.882]                             next
[17:39:42.882]                           if (!grepl(pattern, name)) 
[17:39:42.882]                             next
[17:39:42.882]                           invokeRestart(restart)
[17:39:42.882]                           muffled <- TRUE
[17:39:42.882]                           break
[17:39:42.882]                         }
[17:39:42.882]                       }
[17:39:42.882]                     }
[17:39:42.882]                     invisible(muffled)
[17:39:42.882]                   }
[17:39:42.882]                   muffleCondition(cond)
[17:39:42.882]                 })
[17:39:42.882]             }))
[17:39:42.882]             future::FutureResult(value = ...future.value$value, 
[17:39:42.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.882]                   ...future.rng), globalenv = if (FALSE) 
[17:39:42.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:42.882]                     ...future.globalenv.names))
[17:39:42.882]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:42.882]         }, condition = base::local({
[17:39:42.882]             c <- base::c
[17:39:42.882]             inherits <- base::inherits
[17:39:42.882]             invokeRestart <- base::invokeRestart
[17:39:42.882]             length <- base::length
[17:39:42.882]             list <- base::list
[17:39:42.882]             seq.int <- base::seq.int
[17:39:42.882]             signalCondition <- base::signalCondition
[17:39:42.882]             sys.calls <- base::sys.calls
[17:39:42.882]             `[[` <- base::`[[`
[17:39:42.882]             `+` <- base::`+`
[17:39:42.882]             `<<-` <- base::`<<-`
[17:39:42.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:42.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:42.882]                   3L)]
[17:39:42.882]             }
[17:39:42.882]             function(cond) {
[17:39:42.882]                 is_error <- inherits(cond, "error")
[17:39:42.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:42.882]                   NULL)
[17:39:42.882]                 if (is_error) {
[17:39:42.882]                   sessionInformation <- function() {
[17:39:42.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:42.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:42.882]                       search = base::search(), system = base::Sys.info())
[17:39:42.882]                   }
[17:39:42.882]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:42.882]                     cond$call), session = sessionInformation(), 
[17:39:42.882]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:42.882]                   signalCondition(cond)
[17:39:42.882]                 }
[17:39:42.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:42.882]                 "immediateCondition"))) {
[17:39:42.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:42.882]                   ...future.conditions[[length(...future.conditions) + 
[17:39:42.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:42.882]                   if (TRUE && !signal) {
[17:39:42.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.882]                     {
[17:39:42.882]                       inherits <- base::inherits
[17:39:42.882]                       invokeRestart <- base::invokeRestart
[17:39:42.882]                       is.null <- base::is.null
[17:39:42.882]                       muffled <- FALSE
[17:39:42.882]                       if (inherits(cond, "message")) {
[17:39:42.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.882]                         if (muffled) 
[17:39:42.882]                           invokeRestart("muffleMessage")
[17:39:42.882]                       }
[17:39:42.882]                       else if (inherits(cond, "warning")) {
[17:39:42.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.882]                         if (muffled) 
[17:39:42.882]                           invokeRestart("muffleWarning")
[17:39:42.882]                       }
[17:39:42.882]                       else if (inherits(cond, "condition")) {
[17:39:42.882]                         if (!is.null(pattern)) {
[17:39:42.882]                           computeRestarts <- base::computeRestarts
[17:39:42.882]                           grepl <- base::grepl
[17:39:42.882]                           restarts <- computeRestarts(cond)
[17:39:42.882]                           for (restart in restarts) {
[17:39:42.882]                             name <- restart$name
[17:39:42.882]                             if (is.null(name)) 
[17:39:42.882]                               next
[17:39:42.882]                             if (!grepl(pattern, name)) 
[17:39:42.882]                               next
[17:39:42.882]                             invokeRestart(restart)
[17:39:42.882]                             muffled <- TRUE
[17:39:42.882]                             break
[17:39:42.882]                           }
[17:39:42.882]                         }
[17:39:42.882]                       }
[17:39:42.882]                       invisible(muffled)
[17:39:42.882]                     }
[17:39:42.882]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.882]                   }
[17:39:42.882]                 }
[17:39:42.882]                 else {
[17:39:42.882]                   if (TRUE) {
[17:39:42.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:42.882]                     {
[17:39:42.882]                       inherits <- base::inherits
[17:39:42.882]                       invokeRestart <- base::invokeRestart
[17:39:42.882]                       is.null <- base::is.null
[17:39:42.882]                       muffled <- FALSE
[17:39:42.882]                       if (inherits(cond, "message")) {
[17:39:42.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:42.882]                         if (muffled) 
[17:39:42.882]                           invokeRestart("muffleMessage")
[17:39:42.882]                       }
[17:39:42.882]                       else if (inherits(cond, "warning")) {
[17:39:42.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:42.882]                         if (muffled) 
[17:39:42.882]                           invokeRestart("muffleWarning")
[17:39:42.882]                       }
[17:39:42.882]                       else if (inherits(cond, "condition")) {
[17:39:42.882]                         if (!is.null(pattern)) {
[17:39:42.882]                           computeRestarts <- base::computeRestarts
[17:39:42.882]                           grepl <- base::grepl
[17:39:42.882]                           restarts <- computeRestarts(cond)
[17:39:42.882]                           for (restart in restarts) {
[17:39:42.882]                             name <- restart$name
[17:39:42.882]                             if (is.null(name)) 
[17:39:42.882]                               next
[17:39:42.882]                             if (!grepl(pattern, name)) 
[17:39:42.882]                               next
[17:39:42.882]                             invokeRestart(restart)
[17:39:42.882]                             muffled <- TRUE
[17:39:42.882]                             break
[17:39:42.882]                           }
[17:39:42.882]                         }
[17:39:42.882]                       }
[17:39:42.882]                       invisible(muffled)
[17:39:42.882]                     }
[17:39:42.882]                     muffleCondition(cond, pattern = "^muffle")
[17:39:42.882]                   }
[17:39:42.882]                 }
[17:39:42.882]             }
[17:39:42.882]         }))
[17:39:42.882]     }, error = function(ex) {
[17:39:42.882]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:42.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:42.882]                 ...future.rng), started = ...future.startTime, 
[17:39:42.882]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:42.882]             version = "1.8"), class = "FutureResult")
[17:39:42.882]     }, finally = {
[17:39:42.882]         if (!identical(...future.workdir, getwd())) 
[17:39:42.882]             setwd(...future.workdir)
[17:39:42.882]         {
[17:39:42.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:42.882]                 ...future.oldOptions$nwarnings <- NULL
[17:39:42.882]             }
[17:39:42.882]             base::options(...future.oldOptions)
[17:39:42.882]             if (.Platform$OS.type == "windows") {
[17:39:42.882]                 old_names <- names(...future.oldEnvVars)
[17:39:42.882]                 envs <- base::Sys.getenv()
[17:39:42.882]                 names <- names(envs)
[17:39:42.882]                 common <- intersect(names, old_names)
[17:39:42.882]                 added <- setdiff(names, old_names)
[17:39:42.882]                 removed <- setdiff(old_names, names)
[17:39:42.882]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:42.882]                   envs[common]]
[17:39:42.882]                 NAMES <- toupper(changed)
[17:39:42.882]                 args <- list()
[17:39:42.882]                 for (kk in seq_along(NAMES)) {
[17:39:42.882]                   name <- changed[[kk]]
[17:39:42.882]                   NAME <- NAMES[[kk]]
[17:39:42.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.882]                     next
[17:39:42.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.882]                 }
[17:39:42.882]                 NAMES <- toupper(added)
[17:39:42.882]                 for (kk in seq_along(NAMES)) {
[17:39:42.882]                   name <- added[[kk]]
[17:39:42.882]                   NAME <- NAMES[[kk]]
[17:39:42.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.882]                     next
[17:39:42.882]                   args[[name]] <- ""
[17:39:42.882]                 }
[17:39:42.882]                 NAMES <- toupper(removed)
[17:39:42.882]                 for (kk in seq_along(NAMES)) {
[17:39:42.882]                   name <- removed[[kk]]
[17:39:42.882]                   NAME <- NAMES[[kk]]
[17:39:42.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:42.882]                     next
[17:39:42.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:42.882]                 }
[17:39:42.882]                 if (length(args) > 0) 
[17:39:42.882]                   base::do.call(base::Sys.setenv, args = args)
[17:39:42.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:42.882]             }
[17:39:42.882]             else {
[17:39:42.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:42.882]             }
[17:39:42.882]             {
[17:39:42.882]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:42.882]                   0L) {
[17:39:42.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:42.882]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:42.882]                   base::options(opts)
[17:39:42.882]                 }
[17:39:42.882]                 {
[17:39:42.882]                   {
[17:39:42.882]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:42.882]                     NULL
[17:39:42.882]                   }
[17:39:42.882]                   options(future.plan = NULL)
[17:39:42.882]                   if (is.na(NA_character_)) 
[17:39:42.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:42.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:42.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:42.882]                     .init = FALSE)
[17:39:42.882]                 }
[17:39:42.882]             }
[17:39:42.882]         }
[17:39:42.882]     })
[17:39:42.882]     if (TRUE) {
[17:39:42.882]         base::sink(type = "output", split = FALSE)
[17:39:42.882]         if (TRUE) {
[17:39:42.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:42.882]         }
[17:39:42.882]         else {
[17:39:42.882]             ...future.result["stdout"] <- base::list(NULL)
[17:39:42.882]         }
[17:39:42.882]         base::close(...future.stdout)
[17:39:42.882]         ...future.stdout <- NULL
[17:39:42.882]     }
[17:39:42.882]     ...future.result$conditions <- ...future.conditions
[17:39:42.882]     ...future.result$finished <- base::Sys.time()
[17:39:42.882]     ...future.result
[17:39:42.882] }
[17:39:42.884] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[17:39:42.885] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[17:39:42.885] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[17:39:42.885] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[17:39:42.885] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[17:39:42.886] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[17:39:42.886] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[17:39:42.886] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[17:39:42.886] MultisessionFuture started
[17:39:42.887] - Launch lazy future ... done
[17:39:42.887] run() for ‘MultisessionFuture’ ... done
[17:39:42.887] result() for ClusterFuture ...
[17:39:42.887] receiveMessageFromWorker() for ClusterFuture ...
[17:39:42.887] - Validating connection of MultisessionFuture
[17:39:42.888] - received message: FutureResult
[17:39:42.888] - Received FutureResult
[17:39:42.888] - Erased future from FutureRegistry
[17:39:42.888] result() for ClusterFuture ...
[17:39:42.889] - result already collected: FutureResult
[17:39:42.889] result() for ClusterFuture ... done
[17:39:42.889] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:42.889] result() for ClusterFuture ... done
[17:39:42.889] result() for ClusterFuture ...
[17:39:42.889] - result already collected: FutureResult
[17:39:42.889] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[17:39:42.891] plan(): Setting new future strategy stack:
[17:39:42.891] List of future strategies:
[17:39:42.891] 1. FutureStrategy:
[17:39:42.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:42.891]    - tweaked: FALSE
[17:39:42.891]    - call: future::plan(oplan)
[17:39:42.892] plan(): nbrOfWorkers() = 1
> 
