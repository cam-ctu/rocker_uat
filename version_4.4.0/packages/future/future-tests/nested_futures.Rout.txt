
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:40:19.246] plan(): Setting new future strategy stack:
[17:40:19.247] List of future strategies:
[17:40:19.247] 1. sequential:
[17:40:19.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.247]    - tweaked: FALSE
[17:40:19.247]    - call: future::plan("sequential")
[17:40:19.257] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[17:40:19.311] plan(): Setting new future strategy stack:
[17:40:19.311] List of future strategies:
[17:40:19.311] 1. sequential:
[17:40:19.311]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.311]    - tweaked: FALSE
[17:40:19.311]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.311] 2. sequential:
[17:40:19.311]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.311]    - tweaked: FALSE
[17:40:19.311]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.322] plan(): nbrOfWorkers() = 1
[17:40:19.324] getGlobalsAndPackages() ...
[17:40:19.325] Searching for globals...
[17:40:19.344] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:19.344] Searching for globals ... DONE
[17:40:19.345] Resolving globals: FALSE
[17:40:19.346] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[17:40:19.347] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:19.348] - globals: [2] ‘nested’, ‘strategy2’
[17:40:19.348] - packages: [1] ‘future’
[17:40:19.348] getGlobalsAndPackages() ... DONE
[17:40:19.349] run() for ‘Future’ ...
[17:40:19.349] - state: ‘created’
[17:40:19.349] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.350] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.350]   - Field: ‘label’
[17:40:19.350]   - Field: ‘local’
[17:40:19.350]   - Field: ‘owner’
[17:40:19.350]   - Field: ‘envir’
[17:40:19.350]   - Field: ‘packages’
[17:40:19.350]   - Field: ‘gc’
[17:40:19.350]   - Field: ‘conditions’
[17:40:19.350]   - Field: ‘expr’
[17:40:19.351]   - Field: ‘uuid’
[17:40:19.351]   - Field: ‘seed’
[17:40:19.351]   - Field: ‘version’
[17:40:19.351]   - Field: ‘result’
[17:40:19.351]   - Field: ‘asynchronous’
[17:40:19.351]   - Field: ‘calls’
[17:40:19.351]   - Field: ‘globals’
[17:40:19.351]   - Field: ‘stdout’
[17:40:19.351]   - Field: ‘earlySignal’
[17:40:19.351]   - Field: ‘lazy’
[17:40:19.351]   - Field: ‘state’
[17:40:19.351] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.352] - Launch lazy future ...
[17:40:19.352] Packages needed by the future expression (n = 1): ‘future’
[17:40:19.352] Packages needed by future strategies (n = 1): ‘future’
[17:40:19.353] {
[17:40:19.353]     {
[17:40:19.353]         {
[17:40:19.353]             ...future.startTime <- base::Sys.time()
[17:40:19.353]             {
[17:40:19.353]                 {
[17:40:19.353]                   {
[17:40:19.353]                     {
[17:40:19.353]                       base::local({
[17:40:19.353]                         has_future <- base::requireNamespace("future", 
[17:40:19.353]                           quietly = TRUE)
[17:40:19.353]                         if (has_future) {
[17:40:19.353]                           ns <- base::getNamespace("future")
[17:40:19.353]                           version <- ns[[".package"]][["version"]]
[17:40:19.353]                           if (is.null(version)) 
[17:40:19.353]                             version <- utils::packageVersion("future")
[17:40:19.353]                         }
[17:40:19.353]                         else {
[17:40:19.353]                           version <- NULL
[17:40:19.353]                         }
[17:40:19.353]                         if (!has_future || version < "1.8.0") {
[17:40:19.353]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.353]                             "", base::R.version$version.string), 
[17:40:19.353]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.353]                               "release", "version")], collapse = " "), 
[17:40:19.353]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.353]                             info)
[17:40:19.353]                           info <- base::paste(info, collapse = "; ")
[17:40:19.353]                           if (!has_future) {
[17:40:19.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.353]                               info)
[17:40:19.353]                           }
[17:40:19.353]                           else {
[17:40:19.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.353]                               info, version)
[17:40:19.353]                           }
[17:40:19.353]                           base::stop(msg)
[17:40:19.353]                         }
[17:40:19.353]                       })
[17:40:19.353]                     }
[17:40:19.353]                     base::local({
[17:40:19.353]                       for (pkg in "future") {
[17:40:19.353]                         base::loadNamespace(pkg)
[17:40:19.353]                         base::library(pkg, character.only = TRUE)
[17:40:19.353]                       }
[17:40:19.353]                     })
[17:40:19.353]                   }
[17:40:19.353]                   ...future.strategy.old <- future::plan("list")
[17:40:19.353]                   options(future.plan = NULL)
[17:40:19.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.353]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:19.353]                   {
[17:40:19.353]                     future <- SequentialFuture(..., envir = envir)
[17:40:19.353]                     if (!future$lazy) 
[17:40:19.353]                       future <- run(future)
[17:40:19.353]                     invisible(future)
[17:40:19.353]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:19.353]                 }
[17:40:19.353]                 ...future.workdir <- getwd()
[17:40:19.353]             }
[17:40:19.353]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.353]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.353]         }
[17:40:19.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.353]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.353]             base::names(...future.oldOptions))
[17:40:19.353]     }
[17:40:19.353]     if (FALSE) {
[17:40:19.353]     }
[17:40:19.353]     else {
[17:40:19.353]         if (TRUE) {
[17:40:19.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.353]                 open = "w")
[17:40:19.353]         }
[17:40:19.353]         else {
[17:40:19.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.353]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.353]         }
[17:40:19.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.353]             base::sink(type = "output", split = FALSE)
[17:40:19.353]             base::close(...future.stdout)
[17:40:19.353]         }, add = TRUE)
[17:40:19.353]     }
[17:40:19.353]     ...future.frame <- base::sys.nframe()
[17:40:19.353]     ...future.conditions <- base::list()
[17:40:19.353]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.353]     if (FALSE) {
[17:40:19.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.353]     }
[17:40:19.353]     ...future.result <- base::tryCatch({
[17:40:19.353]         base::withCallingHandlers({
[17:40:19.353]             ...future.value <- base::withVisible(base::local({
[17:40:19.353]                 a <- 1L
[17:40:19.353]                 plan_a <- unclass(future::plan("list"))
[17:40:19.353]                 nested_a <- nested[-1]
[17:40:19.353]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:19.353]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.353]                   strategy2))
[17:40:19.353]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:19.353]                   "init") <- NULL
[17:40:19.353]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:19.353]                   "init") <- NULL
[17:40:19.353]                 stopifnot(all.equal(plan_a, nested_a))
[17:40:19.353]                 y %<-% {
[17:40:19.353]                   b <- 2L
[17:40:19.353]                   plan_b <- future::plan("list")
[17:40:19.353]                   nested_b <- nested_a[-1]
[17:40:19.353]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:19.353]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.353]                     "sequential"))
[17:40:19.353]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:19.353]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:19.353]                 }
[17:40:19.353]                 y
[17:40:19.353]             }))
[17:40:19.353]             future::FutureResult(value = ...future.value$value, 
[17:40:19.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.353]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.353]                     ...future.globalenv.names))
[17:40:19.353]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.353]         }, condition = base::local({
[17:40:19.353]             c <- base::c
[17:40:19.353]             inherits <- base::inherits
[17:40:19.353]             invokeRestart <- base::invokeRestart
[17:40:19.353]             length <- base::length
[17:40:19.353]             list <- base::list
[17:40:19.353]             seq.int <- base::seq.int
[17:40:19.353]             signalCondition <- base::signalCondition
[17:40:19.353]             sys.calls <- base::sys.calls
[17:40:19.353]             `[[` <- base::`[[`
[17:40:19.353]             `+` <- base::`+`
[17:40:19.353]             `<<-` <- base::`<<-`
[17:40:19.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.353]                   3L)]
[17:40:19.353]             }
[17:40:19.353]             function(cond) {
[17:40:19.353]                 is_error <- inherits(cond, "error")
[17:40:19.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.353]                   NULL)
[17:40:19.353]                 if (is_error) {
[17:40:19.353]                   sessionInformation <- function() {
[17:40:19.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.353]                       search = base::search(), system = base::Sys.info())
[17:40:19.353]                   }
[17:40:19.353]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.353]                     cond$call), session = sessionInformation(), 
[17:40:19.353]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.353]                   signalCondition(cond)
[17:40:19.353]                 }
[17:40:19.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.353]                 "immediateCondition"))) {
[17:40:19.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.353]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.353]                   if (TRUE && !signal) {
[17:40:19.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.353]                     {
[17:40:19.353]                       inherits <- base::inherits
[17:40:19.353]                       invokeRestart <- base::invokeRestart
[17:40:19.353]                       is.null <- base::is.null
[17:40:19.353]                       muffled <- FALSE
[17:40:19.353]                       if (inherits(cond, "message")) {
[17:40:19.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.353]                         if (muffled) 
[17:40:19.353]                           invokeRestart("muffleMessage")
[17:40:19.353]                       }
[17:40:19.353]                       else if (inherits(cond, "warning")) {
[17:40:19.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.353]                         if (muffled) 
[17:40:19.353]                           invokeRestart("muffleWarning")
[17:40:19.353]                       }
[17:40:19.353]                       else if (inherits(cond, "condition")) {
[17:40:19.353]                         if (!is.null(pattern)) {
[17:40:19.353]                           computeRestarts <- base::computeRestarts
[17:40:19.353]                           grepl <- base::grepl
[17:40:19.353]                           restarts <- computeRestarts(cond)
[17:40:19.353]                           for (restart in restarts) {
[17:40:19.353]                             name <- restart$name
[17:40:19.353]                             if (is.null(name)) 
[17:40:19.353]                               next
[17:40:19.353]                             if (!grepl(pattern, name)) 
[17:40:19.353]                               next
[17:40:19.353]                             invokeRestart(restart)
[17:40:19.353]                             muffled <- TRUE
[17:40:19.353]                             break
[17:40:19.353]                           }
[17:40:19.353]                         }
[17:40:19.353]                       }
[17:40:19.353]                       invisible(muffled)
[17:40:19.353]                     }
[17:40:19.353]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.353]                   }
[17:40:19.353]                 }
[17:40:19.353]                 else {
[17:40:19.353]                   if (TRUE) {
[17:40:19.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.353]                     {
[17:40:19.353]                       inherits <- base::inherits
[17:40:19.353]                       invokeRestart <- base::invokeRestart
[17:40:19.353]                       is.null <- base::is.null
[17:40:19.353]                       muffled <- FALSE
[17:40:19.353]                       if (inherits(cond, "message")) {
[17:40:19.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.353]                         if (muffled) 
[17:40:19.353]                           invokeRestart("muffleMessage")
[17:40:19.353]                       }
[17:40:19.353]                       else if (inherits(cond, "warning")) {
[17:40:19.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.353]                         if (muffled) 
[17:40:19.353]                           invokeRestart("muffleWarning")
[17:40:19.353]                       }
[17:40:19.353]                       else if (inherits(cond, "condition")) {
[17:40:19.353]                         if (!is.null(pattern)) {
[17:40:19.353]                           computeRestarts <- base::computeRestarts
[17:40:19.353]                           grepl <- base::grepl
[17:40:19.353]                           restarts <- computeRestarts(cond)
[17:40:19.353]                           for (restart in restarts) {
[17:40:19.353]                             name <- restart$name
[17:40:19.353]                             if (is.null(name)) 
[17:40:19.353]                               next
[17:40:19.353]                             if (!grepl(pattern, name)) 
[17:40:19.353]                               next
[17:40:19.353]                             invokeRestart(restart)
[17:40:19.353]                             muffled <- TRUE
[17:40:19.353]                             break
[17:40:19.353]                           }
[17:40:19.353]                         }
[17:40:19.353]                       }
[17:40:19.353]                       invisible(muffled)
[17:40:19.353]                     }
[17:40:19.353]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.353]                   }
[17:40:19.353]                 }
[17:40:19.353]             }
[17:40:19.353]         }))
[17:40:19.353]     }, error = function(ex) {
[17:40:19.353]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.353]                 ...future.rng), started = ...future.startTime, 
[17:40:19.353]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.353]             version = "1.8"), class = "FutureResult")
[17:40:19.353]     }, finally = {
[17:40:19.353]         if (!identical(...future.workdir, getwd())) 
[17:40:19.353]             setwd(...future.workdir)
[17:40:19.353]         {
[17:40:19.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.353]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.353]             }
[17:40:19.353]             base::options(...future.oldOptions)
[17:40:19.353]             if (.Platform$OS.type == "windows") {
[17:40:19.353]                 old_names <- names(...future.oldEnvVars)
[17:40:19.353]                 envs <- base::Sys.getenv()
[17:40:19.353]                 names <- names(envs)
[17:40:19.353]                 common <- intersect(names, old_names)
[17:40:19.353]                 added <- setdiff(names, old_names)
[17:40:19.353]                 removed <- setdiff(old_names, names)
[17:40:19.353]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.353]                   envs[common]]
[17:40:19.353]                 NAMES <- toupper(changed)
[17:40:19.353]                 args <- list()
[17:40:19.353]                 for (kk in seq_along(NAMES)) {
[17:40:19.353]                   name <- changed[[kk]]
[17:40:19.353]                   NAME <- NAMES[[kk]]
[17:40:19.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.353]                     next
[17:40:19.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.353]                 }
[17:40:19.353]                 NAMES <- toupper(added)
[17:40:19.353]                 for (kk in seq_along(NAMES)) {
[17:40:19.353]                   name <- added[[kk]]
[17:40:19.353]                   NAME <- NAMES[[kk]]
[17:40:19.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.353]                     next
[17:40:19.353]                   args[[name]] <- ""
[17:40:19.353]                 }
[17:40:19.353]                 NAMES <- toupper(removed)
[17:40:19.353]                 for (kk in seq_along(NAMES)) {
[17:40:19.353]                   name <- removed[[kk]]
[17:40:19.353]                   NAME <- NAMES[[kk]]
[17:40:19.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.353]                     next
[17:40:19.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.353]                 }
[17:40:19.353]                 if (length(args) > 0) 
[17:40:19.353]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.353]             }
[17:40:19.353]             else {
[17:40:19.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.353]             }
[17:40:19.353]             {
[17:40:19.353]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.353]                   0L) {
[17:40:19.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.353]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.353]                   base::options(opts)
[17:40:19.353]                 }
[17:40:19.353]                 {
[17:40:19.353]                   {
[17:40:19.353]                     NULL
[17:40:19.353]                     RNGkind("Mersenne-Twister")
[17:40:19.353]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.353]                       inherits = FALSE)
[17:40:19.353]                   }
[17:40:19.353]                   options(future.plan = NULL)
[17:40:19.353]                   if (is.na(NA_character_)) 
[17:40:19.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.353]                     .init = FALSE)
[17:40:19.353]                 }
[17:40:19.353]             }
[17:40:19.353]         }
[17:40:19.353]     })
[17:40:19.353]     if (TRUE) {
[17:40:19.353]         base::sink(type = "output", split = FALSE)
[17:40:19.353]         if (TRUE) {
[17:40:19.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.353]         }
[17:40:19.353]         else {
[17:40:19.353]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.353]         }
[17:40:19.353]         base::close(...future.stdout)
[17:40:19.353]         ...future.stdout <- NULL
[17:40:19.353]     }
[17:40:19.353]     ...future.result$conditions <- ...future.conditions
[17:40:19.353]     ...future.result$finished <- base::Sys.time()
[17:40:19.353]     ...future.result
[17:40:19.353] }
[17:40:19.355] assign_globals() ...
[17:40:19.355] List of 2
[17:40:19.355]  $ nested   :List of 2
[17:40:19.355]   ..$ a:function (..., envir = parent.frame())  
[17:40:19.355]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:19.355]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.355]   ..$ b:function (..., envir = parent.frame())  
[17:40:19.355]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:19.355]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.355]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:19.355]  $ strategy2: chr "sequential"
[17:40:19.355]  - attr(*, "where")=List of 2
[17:40:19.355]   ..$ nested   :<environment: R_EmptyEnv> 
[17:40:19.355]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:40:19.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.355]  - attr(*, "resolved")= logi FALSE
[17:40:19.355]  - attr(*, "total_size")= num 23144
[17:40:19.355]  - attr(*, "already-done")= logi TRUE
[17:40:19.362] - copied ‘nested’ to environment
[17:40:19.362] - copied ‘strategy2’ to environment
[17:40:19.362] assign_globals() ... done
[17:40:19.362] plan(): Setting new future strategy stack:
[17:40:19.362] List of future strategies:
[17:40:19.362] 1. sequential:
[17:40:19.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.362]    - tweaked: FALSE
[17:40:19.362]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.363] plan(): nbrOfWorkers() = 1
[17:40:19.398] plan(): Setting new future strategy stack:
[17:40:19.399] List of future strategies:
[17:40:19.399] 1. sequential:
[17:40:19.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.399]    - tweaked: FALSE
[17:40:19.399]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.399] 2. sequential:
[17:40:19.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.399]    - tweaked: FALSE
[17:40:19.399]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.399] plan(): nbrOfWorkers() = 1
[17:40:19.399] SequentialFuture started (and completed)
[17:40:19.400] signalConditions() ...
[17:40:19.401]  - include = ‘immediateCondition’
[17:40:19.401]  - exclude = 
[17:40:19.401]  - resignal = FALSE
[17:40:19.401]  - Number of conditions: 54
[17:40:19.401] signalConditions() ... done
[17:40:19.401] - Launch lazy future ... done
[17:40:19.401] run() for ‘SequentialFuture’ ... done
[17:40:19.401] signalConditions() ...
[17:40:19.401]  - include = ‘immediateCondition’
[17:40:19.401]  - exclude = 
[17:40:19.402]  - resignal = FALSE
[17:40:19.402]  - Number of conditions: 54
[17:40:19.402] signalConditions() ... done
[17:40:19.402] Future state: ‘finished’
[17:40:19.402] signalConditions() ...
[17:40:19.402]  - include = ‘condition’
[17:40:19.402]  - exclude = ‘immediateCondition’
[17:40:19.402]  - resignal = TRUE
[17:40:19.402]  - Number of conditions: 54
[17:40:19.402]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.364] getGlobalsAndPackages() ...
[17:40:19.403]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.364] Searching for globals...
[17:40:19.403]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.382] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:40:19.403]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.382] Searching for globals ... DONE
[17:40:19.403]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.383] Resolving globals: FALSE
[17:40:19.403]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.383] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[17:40:19.403]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.384] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:40:19.403]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.384] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:40:19.403]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.384] 
[17:40:19.404]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.384] getGlobalsAndPackages() ... DONE
[17:40:19.404]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.384] run() for ‘Future’ ...
[17:40:19.404]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.384] - state: ‘created’
[17:40:19.404]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.404]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.404]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.404]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385]   - Field: ‘label’
[17:40:19.404]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385]   - Field: ‘local’
[17:40:19.405]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385]   - Field: ‘owner’
[17:40:19.405]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385]   - Field: ‘envir’
[17:40:19.405]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.385]   - Field: ‘packages’
[17:40:19.405]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘gc’
[17:40:19.405]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘conditions’
[17:40:19.405]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘expr’
[17:40:19.405]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘uuid’
[17:40:19.405]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘seed’
[17:40:19.406]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘version’
[17:40:19.406]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘result’
[17:40:19.406]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘asynchronous’
[17:40:19.406]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.386]   - Field: ‘calls’
[17:40:19.406]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387]   - Field: ‘globals’
[17:40:19.406]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387]   - Field: ‘stdout’
[17:40:19.406]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387]   - Field: ‘earlySignal’
[17:40:19.406]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387]   - Field: ‘lazy’
[17:40:19.407]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387]   - Field: ‘state’
[17:40:19.407]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.407]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387] - Launch lazy future ...
[17:40:19.407]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387] Packages needed by the future expression (n = 0): <none>
[17:40:19.407]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.387] Packages needed by future strategies (n = 0): <none>
[17:40:19.407]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.388] {
[17:40:19.388]     {
[17:40:19.388]         {
[17:40:19.388]             ...future.startTime <- base::Sys.time()
[17:40:19.388]             {
[17:40:19.388]                 {
[17:40:19.388]                   {
[17:40:19.388]                     base::local({
[17:40:19.388]                       has_future <- base::requireNamespace("future", 
[17:40:19.388]                         quietly = TRUE)
[17:40:19.388]                       if (has_future) {
[17:40:19.388]                         ns <- base::getNamespace("future")
[17:40:19.388]                         version <- ns[[".package"]][["version"]]
[17:40:19.388]                         if (is.null(version)) 
[17:40:19.388]                           version <- utils::packageVersion("future")
[17:40:19.388]                       }
[17:40:19.388]                       else {
[17:40:19.388]                         version <- NULL
[17:40:19.388]                       }
[17:40:19.388]                       if (!has_future || version < "1.8.0") {
[17:40:19.388]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.388]                           "", base::R.version$version.string), 
[17:40:19.388]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:19.388]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.388]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.388]                             "release", "version")], collapse = " "), 
[17:40:19.388]                           hostname = base::Sys.info()[["nodename"]])
[17:40:19.388]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.388]                           info)
[17:40:19.388]                         info <- base::paste(info, collapse = "; ")
[17:40:19.388]                         if (!has_future) {
[17:40:19.388]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.388]                             info)
[17:40:19.388]                         }
[17:40:19.388]                         else {
[17:40:19.388]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.388]                             info, version)
[17:40:19.388]                         }
[17:40:19.388]                         base::stop(msg)
[17:40:19.388]                       }
[17:40:19.388]                     })
[17:40:19.388]                   }
[17:40:19.388]                   ...future.strategy.old <- future::plan("list")
[17:40:19.388]                   options(future.plan = NULL)
[17:40:19.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:19.388]                 }
[17:40:19.388]                 ...future.workdir <- getwd()
[17:40:19.388]             }
[17:40:19.388]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.388]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.388]         }
[17:40:19.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.388]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.388]             base::names(...future.oldOptions))
[17:40:19.388]     }
[17:40:19.388]     if (FALSE) {
[17:40:19.388]     }
[17:40:19.388]     else {
[17:40:19.388]         if (TRUE) {
[17:40:19.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.388]                 open = "w")
[17:40:19.388]         }
[17:40:19.388]         else {
[17:40:19.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.388]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.388]         }
[17:40:19.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.388]             base::sink(type = "output", split = FALSE)
[17:40:19.388]             base::close(...future.stdout)
[17:40:19.388]         }, add = TRUE)
[17:40:19.388]     }
[17:40:19.388]     ...future.frame <- base::sys.nframe()
[17:40:19.388]     ...future.conditions <- base::list()
[17:40:19.388]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.388]     if (FALSE) {
[17:40:19.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.388]     }
[17:40:19.388]     ...future.result <- base::tryCatch({
[17:40:19.388]         base::withCallingHandlers({
[17:40:19.388]             ...future.value <- base::withVisible(base::local({
[17:40:19.388]                 b <- 2L
[17:40:19.388]                 plan_b <- future::plan("list")
[17:40:19.388]                 nested_b <- nested_a[-1]
[17:40:19.388]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:19.388]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.388]                   "sequential"))
[17:40:19.388]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:19.388]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:19.388]             }))
[17:40:19.388]             future::FutureResult(value = ...future.value$value, 
[17:40:19.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.388]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.388]                     ...future.globalenv.names))
[17:40:19.388]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.388]         }, condition = base::local({
[17:40:19.388]             c <- base::c
[17:40:19.388]             inherits <- base::inherits
[17:40:19.388]             invokeRestart <- base::invokeRestart
[17:40:19.388]             length <- base::length
[17:40:19.388]             list <- base::list
[17:40:19.388]             seq.int <- base::seq.int
[17:40:19.388]             signalCondition <- base::signalCondition
[17:40:19.388]             sys.calls <- base::sys.calls
[17:40:19.388]             `[[` <- base::`[[`
[17:40:19.388]             `+` <- base::`+`
[17:40:19.388]             `<<-` <- base::`<<-`
[17:40:19.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.388]                   3L)]
[17:40:19.388]             }
[17:40:19.388]             function(cond) {
[17:40:19.388]                 is_error <- inherits(cond, "error")
[17:40:19.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.388]                   NULL)
[17:40:19.388]                 if (is_error) {
[17:40:19.388]                   sessionInformation <- function() {
[17:40:19.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.388]                       search = base::search(), system = base::Sys.info())
[17:40:19.388]                   }
[17:40:19.388]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.388]                     cond$call), session = sessionInformation(), 
[17:40:19.388]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.388]                   signalCondition(cond)
[17:40:19.388]                 }
[17:40:19.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.388]                 "immediateCondition"))) {
[17:40:19.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.388]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.388]                   if (TRUE && !signal) {
[17:40:19.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.388]                     {
[17:40:19.388]                       inherits <- base::inherits
[17:40:19.388]                       invokeRestart <- base::invokeRestart
[17:40:19.388]                       is.null <- base::is.null
[17:40:19.388]                       muffled <- FALSE
[17:40:19.388]                       if (inherits(cond, "message")) {
[17:40:19.388]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.388]                         if (muffled) 
[17:40:19.388]                           invokeRestart("muffleMessage")
[17:40:19.388]                       }
[17:40:19.388]                       else if (inherits(cond, "warning")) {
[17:40:19.388]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.388]                         if (muffled) 
[17:40:19.388]                           invokeRestart("muffleWarning")
[17:40:19.388]                       }
[17:40:19.388]                       else if (inherits(cond, "condition")) {
[17:40:19.388]                         if (!is.null(pattern)) {
[17:40:19.388]                           computeRestarts <- base::computeRestarts
[17:40:19.388]                           grepl <- base::grepl
[17:40:19.388]                           restarts <- computeRestarts(cond)
[17:40:19.388]                           for (restart in restarts) {
[17:40:19.388]                             name <- restart$name
[17:40:19.388]                             if (is.null(name)) 
[17:40:19.388]                               next
[17:40:19.388]                             if (!grepl(pattern, name)) 
[17:40:19.388]                               next
[17:40:19.388]                             invokeRestart(restart)
[17:40:19.388]                             muffled <- TRUE
[17:40:19.388]                             break
[17:40:19.388]                           }
[17:40:19.388]                         }
[17:40:19.388]                       }
[17:40:19.388]                       invisible(muffled)
[17:40:19.388]                     }
[17:40:19.388]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.388]                   }
[17:40:19.388]                 }
[17:40:19.388]                 else {
[17:40:19.388]                   if (TRUE) {
[17:40:19.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.388]                     {
[17:40:19.388]                       inherits <- base::inherits
[17:40:19.388]                       invokeRestart <- base::invokeRestart
[17:40:19.388]                       is.null <- base::is.null
[17:40:19.388]                       muffled <- FALSE
[17:40:19.388]                       if (inherits(cond, "message")) {
[17:40:19.388]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.388]                         if (muffled) 
[17:40:19.388]                           invokeRestart("muffleMessage")
[17:40:19.388]                       }
[17:40:19.388]                       else if (inherits(cond, "warning")) {
[17:40:19.388]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.388]                         if (muffled) 
[17:40:19.388]                           invokeRestart("muffleWarning")
[17:40:19.388]                       }
[17:40:19.388]                       else if (inherits(cond, "condition")) {
[17:40:19.388]                         if (!is.null(pattern)) {
[17:40:19.388]                           computeRestarts <- base::computeRestarts
[17:40:19.388]                           grepl <- base::grepl
[17:40:19.388]                           restarts <- computeRestarts(cond)
[17:40:19.388]                           for (restart in restarts) {
[17:40:19.388]                             name <- restart$name
[17:40:19.388]                             if (is.null(name)) 
[17:40:19.388]                               next
[17:40:19.388]                             if (!grepl(pattern, name)) 
[17:40:19.388]                               next
[17:40:19.388]                             invokeRestart(restart)
[17:40:19.388]                             muffled <- TRUE
[17:40:19.388]                             break
[17:40:19.388]                           }
[17:40:19.388]                         }
[17:40:19.388]                       }
[17:40:19.388]                       invisible(muffled)
[17:40:19.388]                     }
[17:40:19.388]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.388]                   }
[17:40:19.388]                 }
[17:40:19.388]             }
[17:40:19.388]         }))
[17:40:19.388]     }, error = function(ex) {
[17:40:19.388]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.388]                 ...future.rng), started = ...future.startTime, 
[17:40:19.388]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.388]             version = "1.8"), class = "FutureResult")
[17:40:19.388]     }, finally = {
[17:40:19.388]         if (!identical(...future.workdir, getwd())) 
[17:40:19.388]             setwd(...future.workdir)
[17:40:19.388]         {
[17:40:19.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.388]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.388]             }
[17:40:19.388]             base::options(...future.oldOptions)
[17:40:19.388]             if (.Platform$OS.type == "windows") {
[17:40:19.388]                 old_names <- names(...future.oldEnvVars)
[17:40:19.388]                 envs <- base::Sys.getenv()
[17:40:19.388]                 names <- names(envs)
[17:40:19.388]                 common <- intersect(names, old_names)
[17:40:19.388]                 added <- setdiff(names, old_names)
[17:40:19.388]                 removed <- setdiff(old_names, names)
[17:40:19.388]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.388]                   envs[common]]
[17:40:19.388]                 NAMES <- toupper(changed)
[17:40:19.388]                 args <- list()
[17:40:19.388]                 for (kk in seq_along(NAMES)) {
[17:40:19.388]                   name <- changed[[kk]]
[17:40:19.388]                   NAME <- NAMES[[kk]]
[17:40:19.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.388]                     next
[17:40:19.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.388]                 }
[17:40:19.388]                 NAMES <- toupper(added)
[17:40:19.388]                 for (kk in seq_along(NAMES)) {
[17:40:19.388]                   name <- added[[kk]]
[17:40:19.388]                   NAME <- NAMES[[kk]]
[17:40:19.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.388]                     next
[17:40:19.388]                   args[[name]] <- ""
[17:40:19.388]                 }
[17:40:19.388]                 NAMES <- toupper(removed)
[17:40:19.388]                 for (kk in seq_along(NAMES)) {
[17:40:19.388]                   name <- removed[[kk]]
[17:40:19.388]                   NAME <- NAMES[[kk]]
[17:40:19.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.388]                     next
[17:40:19.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.388]                 }
[17:40:19.388]                 if (length(args) > 0) 
[17:40:19.388]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.388]             }
[17:40:19.388]             else {
[17:40:19.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.388]             }
[17:40:19.388]             {
[17:40:19.388]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.388]                   0L) {
[17:40:19.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.388]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.388]                   base::options(opts)
[17:40:19.388]                 }
[17:40:19.388]                 {
[17:40:19.388]                   {
[17:40:19.388]                     NULL
[17:40:19.388]                     RNGkind("Mersenne-Twister")
[17:40:19.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.388]                       inherits = FALSE)
[17:40:19.388]                   }
[17:40:19.388]                   options(future.plan = NULL)
[17:40:19.388]                   if (is.na(NA_character_)) 
[17:40:19.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.388]                     .init = FALSE)
[17:40:19.388]                 }
[17:40:19.388]             }
[17:40:19.388]         }
[17:40:19.388]     })
[17:40:19.388]     if (TRUE) {
[17:40:19.388]         base::sink(type = "output", split = FALSE)
[17:40:19.388]         if (TRUE) {
[17:40:19.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.388]         }
[17:40:19.388]         else {
[17:40:19.388]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.388]         }
[17:40:19.388]         base::close(...future.stdout)
[17:40:19.388]         ...future.stdout <- NULL
[17:40:19.388]     }
[17:40:19.388]     ...future.result$conditions <- ...future.conditions
[17:40:19.388]     ...future.result$finished <- base::Sys.time()
[17:40:19.388]     ...future.result
[17:40:19.388] }
[17:40:19.407]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.389] assign_globals() ...
[17:40:19.407]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.390] List of 3
[17:40:19.390]  $ nested_a:List of 1
[17:40:19.390]   ..$ b:function (..., envir = parent.frame())  
[17:40:19.390]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:19.390]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.390]  $ a       : int 1
[17:40:19.390]  $ plan_a  :List of 1
[17:40:19.390]   ..$ b:function (..., envir = parent.frame())  
[17:40:19.390]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:19.390]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.390]  - attr(*, "where")=List of 3
[17:40:19.390]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:40:19.390]   ..$ a       :<environment: R_EmptyEnv> 
[17:40:19.390]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:40:19.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.390]  - attr(*, "resolved")= logi FALSE
[17:40:19.390]  - attr(*, "total_size")= num 23080
[17:40:19.390]  - attr(*, "already-done")= logi TRUE
[17:40:19.408]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.394] - copied ‘nested_a’ to environment
[17:40:19.408]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.394] - copied ‘a’ to environment
[17:40:19.408]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.394] - copied ‘plan_a’ to environment
[17:40:19.408]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.394] assign_globals() ... done
[17:40:19.408]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.395] plan(): Setting new future strategy stack:
[17:40:19.408]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.395] List of future strategies:
[17:40:19.395] 1. sequential:
[17:40:19.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.395]    - tweaked: FALSE
[17:40:19.395]    - call: NULL
[17:40:19.408]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.395] plan(): nbrOfWorkers() = 1
[17:40:19.408]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.396] plan(): Setting new future strategy stack:
[17:40:19.409]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.396] List of future strategies:
[17:40:19.396] 1. sequential:
[17:40:19.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.396]    - tweaked: FALSE
[17:40:19.396]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.409]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.397] plan(): nbrOfWorkers() = 1
[17:40:19.409]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.397] SequentialFuture started (and completed)
[17:40:19.409]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.398] - Launch lazy future ... done
[17:40:19.409]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.398] run() for ‘SequentialFuture’ ... done
[17:40:19.409] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:19.414] getGlobalsAndPackages() ...
[17:40:19.414] Searching for globals...
[17:40:19.415] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:19.415] Searching for globals ... DONE
[17:40:19.415] Resolving globals: FALSE
[17:40:19.416] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:19.416] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:19.416] - globals: [1] ‘data’
[17:40:19.416] - packages: [1] ‘future’
[17:40:19.416] getGlobalsAndPackages() ... DONE
[17:40:19.417] run() for ‘Future’ ...
[17:40:19.417] - state: ‘created’
[17:40:19.417] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.417] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.417]   - Field: ‘label’
[17:40:19.417]   - Field: ‘local’
[17:40:19.418]   - Field: ‘owner’
[17:40:19.418]   - Field: ‘envir’
[17:40:19.418]   - Field: ‘packages’
[17:40:19.418]   - Field: ‘gc’
[17:40:19.418]   - Field: ‘conditions’
[17:40:19.418]   - Field: ‘expr’
[17:40:19.418]   - Field: ‘uuid’
[17:40:19.418]   - Field: ‘seed’
[17:40:19.418]   - Field: ‘version’
[17:40:19.418]   - Field: ‘result’
[17:40:19.418]   - Field: ‘asynchronous’
[17:40:19.418]   - Field: ‘calls’
[17:40:19.419]   - Field: ‘globals’
[17:40:19.419]   - Field: ‘stdout’
[17:40:19.419]   - Field: ‘earlySignal’
[17:40:19.419]   - Field: ‘lazy’
[17:40:19.419]   - Field: ‘state’
[17:40:19.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.419] - Launch lazy future ...
[17:40:19.419] Packages needed by the future expression (n = 1): ‘future’
[17:40:19.419] Packages needed by future strategies (n = 1): ‘future’
[17:40:19.420] {
[17:40:19.420]     {
[17:40:19.420]         {
[17:40:19.420]             ...future.startTime <- base::Sys.time()
[17:40:19.420]             {
[17:40:19.420]                 {
[17:40:19.420]                   {
[17:40:19.420]                     {
[17:40:19.420]                       base::local({
[17:40:19.420]                         has_future <- base::requireNamespace("future", 
[17:40:19.420]                           quietly = TRUE)
[17:40:19.420]                         if (has_future) {
[17:40:19.420]                           ns <- base::getNamespace("future")
[17:40:19.420]                           version <- ns[[".package"]][["version"]]
[17:40:19.420]                           if (is.null(version)) 
[17:40:19.420]                             version <- utils::packageVersion("future")
[17:40:19.420]                         }
[17:40:19.420]                         else {
[17:40:19.420]                           version <- NULL
[17:40:19.420]                         }
[17:40:19.420]                         if (!has_future || version < "1.8.0") {
[17:40:19.420]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.420]                             "", base::R.version$version.string), 
[17:40:19.420]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.420]                               "release", "version")], collapse = " "), 
[17:40:19.420]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.420]                             info)
[17:40:19.420]                           info <- base::paste(info, collapse = "; ")
[17:40:19.420]                           if (!has_future) {
[17:40:19.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.420]                               info)
[17:40:19.420]                           }
[17:40:19.420]                           else {
[17:40:19.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.420]                               info, version)
[17:40:19.420]                           }
[17:40:19.420]                           base::stop(msg)
[17:40:19.420]                         }
[17:40:19.420]                       })
[17:40:19.420]                     }
[17:40:19.420]                     base::local({
[17:40:19.420]                       for (pkg in "future") {
[17:40:19.420]                         base::loadNamespace(pkg)
[17:40:19.420]                         base::library(pkg, character.only = TRUE)
[17:40:19.420]                       }
[17:40:19.420]                     })
[17:40:19.420]                   }
[17:40:19.420]                   ...future.strategy.old <- future::plan("list")
[17:40:19.420]                   options(future.plan = NULL)
[17:40:19.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.420]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:19.420]                   {
[17:40:19.420]                     future <- SequentialFuture(..., envir = envir)
[17:40:19.420]                     if (!future$lazy) 
[17:40:19.420]                       future <- run(future)
[17:40:19.420]                     invisible(future)
[17:40:19.420]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:19.420]                 }
[17:40:19.420]                 ...future.workdir <- getwd()
[17:40:19.420]             }
[17:40:19.420]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.420]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.420]         }
[17:40:19.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.420]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.420]             base::names(...future.oldOptions))
[17:40:19.420]     }
[17:40:19.420]     if (FALSE) {
[17:40:19.420]     }
[17:40:19.420]     else {
[17:40:19.420]         if (TRUE) {
[17:40:19.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.420]                 open = "w")
[17:40:19.420]         }
[17:40:19.420]         else {
[17:40:19.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.420]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.420]         }
[17:40:19.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.420]             base::sink(type = "output", split = FALSE)
[17:40:19.420]             base::close(...future.stdout)
[17:40:19.420]         }, add = TRUE)
[17:40:19.420]     }
[17:40:19.420]     ...future.frame <- base::sys.nframe()
[17:40:19.420]     ...future.conditions <- base::list()
[17:40:19.420]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.420]     if (FALSE) {
[17:40:19.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.420]     }
[17:40:19.420]     ...future.result <- base::tryCatch({
[17:40:19.420]         base::withCallingHandlers({
[17:40:19.420]             ...future.value <- base::withVisible(base::local({
[17:40:19.420]                 value(future(subset(data, a == 2)))
[17:40:19.420]             }))
[17:40:19.420]             future::FutureResult(value = ...future.value$value, 
[17:40:19.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.420]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.420]                     ...future.globalenv.names))
[17:40:19.420]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.420]         }, condition = base::local({
[17:40:19.420]             c <- base::c
[17:40:19.420]             inherits <- base::inherits
[17:40:19.420]             invokeRestart <- base::invokeRestart
[17:40:19.420]             length <- base::length
[17:40:19.420]             list <- base::list
[17:40:19.420]             seq.int <- base::seq.int
[17:40:19.420]             signalCondition <- base::signalCondition
[17:40:19.420]             sys.calls <- base::sys.calls
[17:40:19.420]             `[[` <- base::`[[`
[17:40:19.420]             `+` <- base::`+`
[17:40:19.420]             `<<-` <- base::`<<-`
[17:40:19.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.420]                   3L)]
[17:40:19.420]             }
[17:40:19.420]             function(cond) {
[17:40:19.420]                 is_error <- inherits(cond, "error")
[17:40:19.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.420]                   NULL)
[17:40:19.420]                 if (is_error) {
[17:40:19.420]                   sessionInformation <- function() {
[17:40:19.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.420]                       search = base::search(), system = base::Sys.info())
[17:40:19.420]                   }
[17:40:19.420]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.420]                     cond$call), session = sessionInformation(), 
[17:40:19.420]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.420]                   signalCondition(cond)
[17:40:19.420]                 }
[17:40:19.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.420]                 "immediateCondition"))) {
[17:40:19.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.420]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.420]                   if (TRUE && !signal) {
[17:40:19.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.420]                     {
[17:40:19.420]                       inherits <- base::inherits
[17:40:19.420]                       invokeRestart <- base::invokeRestart
[17:40:19.420]                       is.null <- base::is.null
[17:40:19.420]                       muffled <- FALSE
[17:40:19.420]                       if (inherits(cond, "message")) {
[17:40:19.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.420]                         if (muffled) 
[17:40:19.420]                           invokeRestart("muffleMessage")
[17:40:19.420]                       }
[17:40:19.420]                       else if (inherits(cond, "warning")) {
[17:40:19.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.420]                         if (muffled) 
[17:40:19.420]                           invokeRestart("muffleWarning")
[17:40:19.420]                       }
[17:40:19.420]                       else if (inherits(cond, "condition")) {
[17:40:19.420]                         if (!is.null(pattern)) {
[17:40:19.420]                           computeRestarts <- base::computeRestarts
[17:40:19.420]                           grepl <- base::grepl
[17:40:19.420]                           restarts <- computeRestarts(cond)
[17:40:19.420]                           for (restart in restarts) {
[17:40:19.420]                             name <- restart$name
[17:40:19.420]                             if (is.null(name)) 
[17:40:19.420]                               next
[17:40:19.420]                             if (!grepl(pattern, name)) 
[17:40:19.420]                               next
[17:40:19.420]                             invokeRestart(restart)
[17:40:19.420]                             muffled <- TRUE
[17:40:19.420]                             break
[17:40:19.420]                           }
[17:40:19.420]                         }
[17:40:19.420]                       }
[17:40:19.420]                       invisible(muffled)
[17:40:19.420]                     }
[17:40:19.420]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.420]                   }
[17:40:19.420]                 }
[17:40:19.420]                 else {
[17:40:19.420]                   if (TRUE) {
[17:40:19.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.420]                     {
[17:40:19.420]                       inherits <- base::inherits
[17:40:19.420]                       invokeRestart <- base::invokeRestart
[17:40:19.420]                       is.null <- base::is.null
[17:40:19.420]                       muffled <- FALSE
[17:40:19.420]                       if (inherits(cond, "message")) {
[17:40:19.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.420]                         if (muffled) 
[17:40:19.420]                           invokeRestart("muffleMessage")
[17:40:19.420]                       }
[17:40:19.420]                       else if (inherits(cond, "warning")) {
[17:40:19.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.420]                         if (muffled) 
[17:40:19.420]                           invokeRestart("muffleWarning")
[17:40:19.420]                       }
[17:40:19.420]                       else if (inherits(cond, "condition")) {
[17:40:19.420]                         if (!is.null(pattern)) {
[17:40:19.420]                           computeRestarts <- base::computeRestarts
[17:40:19.420]                           grepl <- base::grepl
[17:40:19.420]                           restarts <- computeRestarts(cond)
[17:40:19.420]                           for (restart in restarts) {
[17:40:19.420]                             name <- restart$name
[17:40:19.420]                             if (is.null(name)) 
[17:40:19.420]                               next
[17:40:19.420]                             if (!grepl(pattern, name)) 
[17:40:19.420]                               next
[17:40:19.420]                             invokeRestart(restart)
[17:40:19.420]                             muffled <- TRUE
[17:40:19.420]                             break
[17:40:19.420]                           }
[17:40:19.420]                         }
[17:40:19.420]                       }
[17:40:19.420]                       invisible(muffled)
[17:40:19.420]                     }
[17:40:19.420]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.420]                   }
[17:40:19.420]                 }
[17:40:19.420]             }
[17:40:19.420]         }))
[17:40:19.420]     }, error = function(ex) {
[17:40:19.420]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.420]                 ...future.rng), started = ...future.startTime, 
[17:40:19.420]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.420]             version = "1.8"), class = "FutureResult")
[17:40:19.420]     }, finally = {
[17:40:19.420]         if (!identical(...future.workdir, getwd())) 
[17:40:19.420]             setwd(...future.workdir)
[17:40:19.420]         {
[17:40:19.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.420]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.420]             }
[17:40:19.420]             base::options(...future.oldOptions)
[17:40:19.420]             if (.Platform$OS.type == "windows") {
[17:40:19.420]                 old_names <- names(...future.oldEnvVars)
[17:40:19.420]                 envs <- base::Sys.getenv()
[17:40:19.420]                 names <- names(envs)
[17:40:19.420]                 common <- intersect(names, old_names)
[17:40:19.420]                 added <- setdiff(names, old_names)
[17:40:19.420]                 removed <- setdiff(old_names, names)
[17:40:19.420]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.420]                   envs[common]]
[17:40:19.420]                 NAMES <- toupper(changed)
[17:40:19.420]                 args <- list()
[17:40:19.420]                 for (kk in seq_along(NAMES)) {
[17:40:19.420]                   name <- changed[[kk]]
[17:40:19.420]                   NAME <- NAMES[[kk]]
[17:40:19.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.420]                     next
[17:40:19.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.420]                 }
[17:40:19.420]                 NAMES <- toupper(added)
[17:40:19.420]                 for (kk in seq_along(NAMES)) {
[17:40:19.420]                   name <- added[[kk]]
[17:40:19.420]                   NAME <- NAMES[[kk]]
[17:40:19.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.420]                     next
[17:40:19.420]                   args[[name]] <- ""
[17:40:19.420]                 }
[17:40:19.420]                 NAMES <- toupper(removed)
[17:40:19.420]                 for (kk in seq_along(NAMES)) {
[17:40:19.420]                   name <- removed[[kk]]
[17:40:19.420]                   NAME <- NAMES[[kk]]
[17:40:19.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.420]                     next
[17:40:19.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.420]                 }
[17:40:19.420]                 if (length(args) > 0) 
[17:40:19.420]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.420]             }
[17:40:19.420]             else {
[17:40:19.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.420]             }
[17:40:19.420]             {
[17:40:19.420]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.420]                   0L) {
[17:40:19.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.420]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.420]                   base::options(opts)
[17:40:19.420]                 }
[17:40:19.420]                 {
[17:40:19.420]                   {
[17:40:19.420]                     NULL
[17:40:19.420]                     RNGkind("Mersenne-Twister")
[17:40:19.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.420]                       inherits = FALSE)
[17:40:19.420]                   }
[17:40:19.420]                   options(future.plan = NULL)
[17:40:19.420]                   if (is.na(NA_character_)) 
[17:40:19.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.420]                     .init = FALSE)
[17:40:19.420]                 }
[17:40:19.420]             }
[17:40:19.420]         }
[17:40:19.420]     })
[17:40:19.420]     if (TRUE) {
[17:40:19.420]         base::sink(type = "output", split = FALSE)
[17:40:19.420]         if (TRUE) {
[17:40:19.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.420]         }
[17:40:19.420]         else {
[17:40:19.420]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.420]         }
[17:40:19.420]         base::close(...future.stdout)
[17:40:19.420]         ...future.stdout <- NULL
[17:40:19.420]     }
[17:40:19.420]     ...future.result$conditions <- ...future.conditions
[17:40:19.420]     ...future.result$finished <- base::Sys.time()
[17:40:19.420]     ...future.result
[17:40:19.420] }
[17:40:19.421] assign_globals() ...
[17:40:19.422] List of 1
[17:40:19.422]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:19.422]   ..$ a: int [1:3] 1 2 3
[17:40:19.422]   ..$ b: int [1:3] 3 2 1
[17:40:19.422]  - attr(*, "where")=List of 1
[17:40:19.422]   ..$ data:<environment: R_EmptyEnv> 
[17:40:19.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.422]  - attr(*, "resolved")= logi FALSE
[17:40:19.422]  - attr(*, "total_size")= num 128
[17:40:19.422]  - attr(*, "already-done")= logi TRUE
[17:40:19.425] - copied ‘data’ to environment
[17:40:19.426] assign_globals() ... done
[17:40:19.426] plan(): Setting new future strategy stack:
[17:40:19.426] List of future strategies:
[17:40:19.426] 1. sequential:
[17:40:19.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.426]    - tweaked: FALSE
[17:40:19.426]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.426] plan(): nbrOfWorkers() = 1
[17:40:19.454] plan(): Setting new future strategy stack:
[17:40:19.454] List of future strategies:
[17:40:19.454] 1. sequential:
[17:40:19.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.454]    - tweaked: FALSE
[17:40:19.454]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.454] 2. sequential:
[17:40:19.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.454]    - tweaked: FALSE
[17:40:19.454]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.455] plan(): nbrOfWorkers() = 1
[17:40:19.455] SequentialFuture started (and completed)
[17:40:19.455] signalConditions() ...
[17:40:19.455]  - include = ‘immediateCondition’
[17:40:19.455]  - exclude = 
[17:40:19.455]  - resignal = FALSE
[17:40:19.456]  - Number of conditions: 52
[17:40:19.456] signalConditions() ... done
[17:40:19.456] - Launch lazy future ... done
[17:40:19.456] run() for ‘SequentialFuture’ ... done
[17:40:19.456] signalConditions() ...
[17:40:19.456]  - include = ‘immediateCondition’
[17:40:19.456]  - exclude = 
[17:40:19.456]  - resignal = FALSE
[17:40:19.456]  - Number of conditions: 52
[17:40:19.457] signalConditions() ... done
[17:40:19.457] Future state: ‘finished’
[17:40:19.457] signalConditions() ...
[17:40:19.457]  - include = ‘condition’
[17:40:19.457]  - exclude = ‘immediateCondition’
[17:40:19.457]  - resignal = TRUE
[17:40:19.457]  - Number of conditions: 52
[17:40:19.457]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.427] getGlobalsAndPackages() ...
[17:40:19.457]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.427] Searching for globals...
[17:40:19.457]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.440] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:19.458]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.440] Searching for globals ... DONE
[17:40:19.458]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.440] Resolving globals: FALSE
[17:40:19.458]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.441] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:19.458]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.441] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:19.458]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.441] - globals: [1] ‘data’
[17:40:19.458]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.441] 
[17:40:19.458]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.442] getGlobalsAndPackages() ... DONE
[17:40:19.458]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.442] run() for ‘Future’ ...
[17:40:19.459]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.442] - state: ‘created’
[17:40:19.459]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.459]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.442] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.459]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.459]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘label’
[17:40:19.459]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘local’
[17:40:19.459]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘owner’
[17:40:19.459]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘envir’
[17:40:19.460]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘packages’
[17:40:19.460]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘gc’
[17:40:19.460]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘conditions’
[17:40:19.460]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘expr’
[17:40:19.460]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘uuid’
[17:40:19.460]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.443]   - Field: ‘seed’
[17:40:19.460]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘version’
[17:40:19.461]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘result’
[17:40:19.461]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘asynchronous’
[17:40:19.461]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘calls’
[17:40:19.461]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘globals’
[17:40:19.461]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘stdout’
[17:40:19.461]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘earlySignal’
[17:40:19.461]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘lazy’
[17:40:19.461]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444]   - Field: ‘state’
[17:40:19.461]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.462]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.446] - Launch lazy future ...
[17:40:19.462]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.446] Packages needed by the future expression (n = 0): <none>
[17:40:19.462]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.446] Packages needed by future strategies (n = 0): <none>
[17:40:19.462]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.446] {
[17:40:19.446]     {
[17:40:19.446]         {
[17:40:19.446]             ...future.startTime <- base::Sys.time()
[17:40:19.446]             {
[17:40:19.446]                 {
[17:40:19.446]                   {
[17:40:19.446]                     base::local({
[17:40:19.446]                       has_future <- base::requireNamespace("future", 
[17:40:19.446]                         quietly = TRUE)
[17:40:19.446]                       if (has_future) {
[17:40:19.446]                         ns <- base::getNamespace("future")
[17:40:19.446]                         version <- ns[[".package"]][["version"]]
[17:40:19.446]                         if (is.null(version)) 
[17:40:19.446]                           version <- utils::packageVersion("future")
[17:40:19.446]                       }
[17:40:19.446]                       else {
[17:40:19.446]                         version <- NULL
[17:40:19.446]                       }
[17:40:19.446]                       if (!has_future || version < "1.8.0") {
[17:40:19.446]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.446]                           "", base::R.version$version.string), 
[17:40:19.446]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:19.446]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.446]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.446]                             "release", "version")], collapse = " "), 
[17:40:19.446]                           hostname = base::Sys.info()[["nodename"]])
[17:40:19.446]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.446]                           info)
[17:40:19.446]                         info <- base::paste(info, collapse = "; ")
[17:40:19.446]                         if (!has_future) {
[17:40:19.446]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.446]                             info)
[17:40:19.446]                         }
[17:40:19.446]                         else {
[17:40:19.446]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.446]                             info, version)
[17:40:19.446]                         }
[17:40:19.446]                         base::stop(msg)
[17:40:19.446]                       }
[17:40:19.446]                     })
[17:40:19.446]                   }
[17:40:19.446]                   ...future.strategy.old <- future::plan("list")
[17:40:19.446]                   options(future.plan = NULL)
[17:40:19.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:19.446]                 }
[17:40:19.446]                 ...future.workdir <- getwd()
[17:40:19.446]             }
[17:40:19.446]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.446]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.446]         }
[17:40:19.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.446]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.446]             base::names(...future.oldOptions))
[17:40:19.446]     }
[17:40:19.446]     if (FALSE) {
[17:40:19.446]     }
[17:40:19.446]     else {
[17:40:19.446]         if (TRUE) {
[17:40:19.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.446]                 open = "w")
[17:40:19.446]         }
[17:40:19.446]         else {
[17:40:19.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.446]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.446]         }
[17:40:19.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.446]             base::sink(type = "output", split = FALSE)
[17:40:19.446]             base::close(...future.stdout)
[17:40:19.446]         }, add = TRUE)
[17:40:19.446]     }
[17:40:19.446]     ...future.frame <- base::sys.nframe()
[17:40:19.446]     ...future.conditions <- base::list()
[17:40:19.446]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.446]     if (FALSE) {
[17:40:19.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.446]     }
[17:40:19.446]     ...future.result <- base::tryCatch({
[17:40:19.446]         base::withCallingHandlers({
[17:40:19.446]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:40:19.446]                 a == 2)))
[17:40:19.446]             future::FutureResult(value = ...future.value$value, 
[17:40:19.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.446]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.446]                     ...future.globalenv.names))
[17:40:19.446]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.446]         }, condition = base::local({
[17:40:19.446]             c <- base::c
[17:40:19.446]             inherits <- base::inherits
[17:40:19.446]             invokeRestart <- base::invokeRestart
[17:40:19.446]             length <- base::length
[17:40:19.446]             list <- base::list
[17:40:19.446]             seq.int <- base::seq.int
[17:40:19.446]             signalCondition <- base::signalCondition
[17:40:19.446]             sys.calls <- base::sys.calls
[17:40:19.446]             `[[` <- base::`[[`
[17:40:19.446]             `+` <- base::`+`
[17:40:19.446]             `<<-` <- base::`<<-`
[17:40:19.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.446]                   3L)]
[17:40:19.446]             }
[17:40:19.446]             function(cond) {
[17:40:19.446]                 is_error <- inherits(cond, "error")
[17:40:19.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.446]                   NULL)
[17:40:19.446]                 if (is_error) {
[17:40:19.446]                   sessionInformation <- function() {
[17:40:19.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.446]                       search = base::search(), system = base::Sys.info())
[17:40:19.446]                   }
[17:40:19.446]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.446]                     cond$call), session = sessionInformation(), 
[17:40:19.446]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.446]                   signalCondition(cond)
[17:40:19.446]                 }
[17:40:19.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.446]                 "immediateCondition"))) {
[17:40:19.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.446]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.446]                   if (TRUE && !signal) {
[17:40:19.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.446]                     {
[17:40:19.446]                       inherits <- base::inherits
[17:40:19.446]                       invokeRestart <- base::invokeRestart
[17:40:19.446]                       is.null <- base::is.null
[17:40:19.446]                       muffled <- FALSE
[17:40:19.446]                       if (inherits(cond, "message")) {
[17:40:19.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.446]                         if (muffled) 
[17:40:19.446]                           invokeRestart("muffleMessage")
[17:40:19.446]                       }
[17:40:19.446]                       else if (inherits(cond, "warning")) {
[17:40:19.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.446]                         if (muffled) 
[17:40:19.446]                           invokeRestart("muffleWarning")
[17:40:19.446]                       }
[17:40:19.446]                       else if (inherits(cond, "condition")) {
[17:40:19.446]                         if (!is.null(pattern)) {
[17:40:19.446]                           computeRestarts <- base::computeRestarts
[17:40:19.446]                           grepl <- base::grepl
[17:40:19.446]                           restarts <- computeRestarts(cond)
[17:40:19.446]                           for (restart in restarts) {
[17:40:19.446]                             name <- restart$name
[17:40:19.446]                             if (is.null(name)) 
[17:40:19.446]                               next
[17:40:19.446]                             if (!grepl(pattern, name)) 
[17:40:19.446]                               next
[17:40:19.446]                             invokeRestart(restart)
[17:40:19.446]                             muffled <- TRUE
[17:40:19.446]                             break
[17:40:19.446]                           }
[17:40:19.446]                         }
[17:40:19.446]                       }
[17:40:19.446]                       invisible(muffled)
[17:40:19.446]                     }
[17:40:19.446]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.446]                   }
[17:40:19.446]                 }
[17:40:19.446]                 else {
[17:40:19.446]                   if (TRUE) {
[17:40:19.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.446]                     {
[17:40:19.446]                       inherits <- base::inherits
[17:40:19.446]                       invokeRestart <- base::invokeRestart
[17:40:19.446]                       is.null <- base::is.null
[17:40:19.446]                       muffled <- FALSE
[17:40:19.446]                       if (inherits(cond, "message")) {
[17:40:19.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.446]                         if (muffled) 
[17:40:19.446]                           invokeRestart("muffleMessage")
[17:40:19.446]                       }
[17:40:19.446]                       else if (inherits(cond, "warning")) {
[17:40:19.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.446]                         if (muffled) 
[17:40:19.446]                           invokeRestart("muffleWarning")
[17:40:19.446]                       }
[17:40:19.446]                       else if (inherits(cond, "condition")) {
[17:40:19.446]                         if (!is.null(pattern)) {
[17:40:19.446]                           computeRestarts <- base::computeRestarts
[17:40:19.446]                           grepl <- base::grepl
[17:40:19.446]                           restarts <- computeRestarts(cond)
[17:40:19.446]                           for (restart in restarts) {
[17:40:19.446]                             name <- restart$name
[17:40:19.446]                             if (is.null(name)) 
[17:40:19.446]                               next
[17:40:19.446]                             if (!grepl(pattern, name)) 
[17:40:19.446]                               next
[17:40:19.446]                             invokeRestart(restart)
[17:40:19.446]                             muffled <- TRUE
[17:40:19.446]                             break
[17:40:19.446]                           }
[17:40:19.446]                         }
[17:40:19.446]                       }
[17:40:19.446]                       invisible(muffled)
[17:40:19.446]                     }
[17:40:19.446]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.446]                   }
[17:40:19.446]                 }
[17:40:19.446]             }
[17:40:19.446]         }))
[17:40:19.446]     }, error = function(ex) {
[17:40:19.446]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.446]                 ...future.rng), started = ...future.startTime, 
[17:40:19.446]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.446]             version = "1.8"), class = "FutureResult")
[17:40:19.446]     }, finally = {
[17:40:19.446]         if (!identical(...future.workdir, getwd())) 
[17:40:19.446]             setwd(...future.workdir)
[17:40:19.446]         {
[17:40:19.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.446]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.446]             }
[17:40:19.446]             base::options(...future.oldOptions)
[17:40:19.446]             if (.Platform$OS.type == "windows") {
[17:40:19.446]                 old_names <- names(...future.oldEnvVars)
[17:40:19.446]                 envs <- base::Sys.getenv()
[17:40:19.446]                 names <- names(envs)
[17:40:19.446]                 common <- intersect(names, old_names)
[17:40:19.446]                 added <- setdiff(names, old_names)
[17:40:19.446]                 removed <- setdiff(old_names, names)
[17:40:19.446]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.446]                   envs[common]]
[17:40:19.446]                 NAMES <- toupper(changed)
[17:40:19.446]                 args <- list()
[17:40:19.446]                 for (kk in seq_along(NAMES)) {
[17:40:19.446]                   name <- changed[[kk]]
[17:40:19.446]                   NAME <- NAMES[[kk]]
[17:40:19.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.446]                     next
[17:40:19.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.446]                 }
[17:40:19.446]                 NAMES <- toupper(added)
[17:40:19.446]                 for (kk in seq_along(NAMES)) {
[17:40:19.446]                   name <- added[[kk]]
[17:40:19.446]                   NAME <- NAMES[[kk]]
[17:40:19.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.446]                     next
[17:40:19.446]                   args[[name]] <- ""
[17:40:19.446]                 }
[17:40:19.446]                 NAMES <- toupper(removed)
[17:40:19.446]                 for (kk in seq_along(NAMES)) {
[17:40:19.446]                   name <- removed[[kk]]
[17:40:19.446]                   NAME <- NAMES[[kk]]
[17:40:19.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.446]                     next
[17:40:19.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.446]                 }
[17:40:19.446]                 if (length(args) > 0) 
[17:40:19.446]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.446]             }
[17:40:19.446]             else {
[17:40:19.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.446]             }
[17:40:19.446]             {
[17:40:19.446]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.446]                   0L) {
[17:40:19.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.446]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.446]                   base::options(opts)
[17:40:19.446]                 }
[17:40:19.446]                 {
[17:40:19.446]                   {
[17:40:19.446]                     NULL
[17:40:19.446]                     RNGkind("Mersenne-Twister")
[17:40:19.446]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.446]                       inherits = FALSE)
[17:40:19.446]                   }
[17:40:19.446]                   options(future.plan = NULL)
[17:40:19.446]                   if (is.na(NA_character_)) 
[17:40:19.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.446]                     .init = FALSE)
[17:40:19.446]                 }
[17:40:19.446]             }
[17:40:19.446]         }
[17:40:19.446]     })
[17:40:19.446]     if (TRUE) {
[17:40:19.446]         base::sink(type = "output", split = FALSE)
[17:40:19.446]         if (TRUE) {
[17:40:19.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.446]         }
[17:40:19.446]         else {
[17:40:19.446]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.446]         }
[17:40:19.446]         base::close(...future.stdout)
[17:40:19.446]         ...future.stdout <- NULL
[17:40:19.446]     }
[17:40:19.446]     ...future.result$conditions <- ...future.conditions
[17:40:19.446]     ...future.result$finished <- base::Sys.time()
[17:40:19.446]     ...future.result
[17:40:19.446] }
[17:40:19.462]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.448] assign_globals() ...
[17:40:19.462]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.448] List of 1
[17:40:19.448]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:19.448]   ..$ a: int [1:3] 1 2 3
[17:40:19.448]   ..$ b: int [1:3] 3 2 1
[17:40:19.448]  - attr(*, "where")=List of 1
[17:40:19.448]   ..$ data:<environment: R_EmptyEnv> 
[17:40:19.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.448]  - attr(*, "resolved")= logi FALSE
[17:40:19.448]  - attr(*, "total_size")= num 128
[17:40:19.448]  - attr(*, "already-done")= logi TRUE
[17:40:19.462]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.451] - copied ‘data’ to environment
[17:40:19.462]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.451] assign_globals() ... done
[17:40:19.463]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.452] plan(): Setting new future strategy stack:
[17:40:19.463]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.452] List of future strategies:
[17:40:19.452] 1. sequential:
[17:40:19.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.452]    - tweaked: FALSE
[17:40:19.452]    - call: NULL
[17:40:19.463]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.452] plan(): nbrOfWorkers() = 1
[17:40:19.463]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.453] plan(): Setting new future strategy stack:
[17:40:19.463]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.453] List of future strategies:
[17:40:19.453] 1. sequential:
[17:40:19.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.453]    - tweaked: FALSE
[17:40:19.453]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.463]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.453] plan(): nbrOfWorkers() = 1
[17:40:19.463]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.454] SequentialFuture started (and completed)
[17:40:19.463]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.454] - Launch lazy future ... done
[17:40:19.464]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.454] run() for ‘SequentialFuture’ ... done
[17:40:19.464] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[17:40:19.464] plan(): Setting new future strategy stack:
[17:40:19.464] List of future strategies:
[17:40:19.464] 1. sequential:
[17:40:19.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.464]    - tweaked: FALSE
[17:40:19.464]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.464] 2. multicore:
[17:40:19.464]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:19.464]    - tweaked: FALSE
[17:40:19.464]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.465] plan(): nbrOfWorkers() = 1
[17:40:19.465] getGlobalsAndPackages() ...
[17:40:19.465] Searching for globals...
[17:40:19.481] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:19.481] Searching for globals ... DONE
[17:40:19.481] Resolving globals: FALSE
[17:40:19.482] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[17:40:19.483] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:19.483] - globals: [2] ‘nested’, ‘strategy2’
[17:40:19.483] - packages: [1] ‘future’
[17:40:19.483] getGlobalsAndPackages() ... DONE
[17:40:19.483] run() for ‘Future’ ...
[17:40:19.483] - state: ‘created’
[17:40:19.483] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.484] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.484]   - Field: ‘label’
[17:40:19.484]   - Field: ‘local’
[17:40:19.484]   - Field: ‘owner’
[17:40:19.484]   - Field: ‘envir’
[17:40:19.484]   - Field: ‘packages’
[17:40:19.484]   - Field: ‘gc’
[17:40:19.484]   - Field: ‘conditions’
[17:40:19.484]   - Field: ‘expr’
[17:40:19.484]   - Field: ‘uuid’
[17:40:19.485]   - Field: ‘seed’
[17:40:19.485]   - Field: ‘version’
[17:40:19.485]   - Field: ‘result’
[17:40:19.485]   - Field: ‘asynchronous’
[17:40:19.485]   - Field: ‘calls’
[17:40:19.485]   - Field: ‘globals’
[17:40:19.485]   - Field: ‘stdout’
[17:40:19.485]   - Field: ‘earlySignal’
[17:40:19.485]   - Field: ‘lazy’
[17:40:19.485]   - Field: ‘state’
[17:40:19.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.486] - Launch lazy future ...
[17:40:19.486] Packages needed by the future expression (n = 1): ‘future’
[17:40:19.486] Packages needed by future strategies (n = 1): ‘future’
[17:40:19.487] {
[17:40:19.487]     {
[17:40:19.487]         {
[17:40:19.487]             ...future.startTime <- base::Sys.time()
[17:40:19.487]             {
[17:40:19.487]                 {
[17:40:19.487]                   {
[17:40:19.487]                     {
[17:40:19.487]                       base::local({
[17:40:19.487]                         has_future <- base::requireNamespace("future", 
[17:40:19.487]                           quietly = TRUE)
[17:40:19.487]                         if (has_future) {
[17:40:19.487]                           ns <- base::getNamespace("future")
[17:40:19.487]                           version <- ns[[".package"]][["version"]]
[17:40:19.487]                           if (is.null(version)) 
[17:40:19.487]                             version <- utils::packageVersion("future")
[17:40:19.487]                         }
[17:40:19.487]                         else {
[17:40:19.487]                           version <- NULL
[17:40:19.487]                         }
[17:40:19.487]                         if (!has_future || version < "1.8.0") {
[17:40:19.487]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.487]                             "", base::R.version$version.string), 
[17:40:19.487]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.487]                               "release", "version")], collapse = " "), 
[17:40:19.487]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.487]                             info)
[17:40:19.487]                           info <- base::paste(info, collapse = "; ")
[17:40:19.487]                           if (!has_future) {
[17:40:19.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.487]                               info)
[17:40:19.487]                           }
[17:40:19.487]                           else {
[17:40:19.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.487]                               info, version)
[17:40:19.487]                           }
[17:40:19.487]                           base::stop(msg)
[17:40:19.487]                         }
[17:40:19.487]                       })
[17:40:19.487]                     }
[17:40:19.487]                     base::local({
[17:40:19.487]                       for (pkg in "future") {
[17:40:19.487]                         base::loadNamespace(pkg)
[17:40:19.487]                         base::library(pkg, character.only = TRUE)
[17:40:19.487]                       }
[17:40:19.487]                     })
[17:40:19.487]                   }
[17:40:19.487]                   ...future.strategy.old <- future::plan("list")
[17:40:19.487]                   options(future.plan = NULL)
[17:40:19.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.487]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:19.487]                     envir = parent.frame()) 
[17:40:19.487]                   {
[17:40:19.487]                     default_workers <- missing(workers)
[17:40:19.487]                     if (is.function(workers)) 
[17:40:19.487]                       workers <- workers()
[17:40:19.487]                     workers <- structure(as.integer(workers), 
[17:40:19.487]                       class = class(workers))
[17:40:19.487]                     stop_if_not(is.finite(workers), workers >= 
[17:40:19.487]                       1L)
[17:40:19.487]                     if ((workers == 1L && !inherits(workers, 
[17:40:19.487]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:19.487]                       if (default_workers) 
[17:40:19.487]                         supportsMulticore(warn = TRUE)
[17:40:19.487]                       return(sequential(..., envir = envir))
[17:40:19.487]                     }
[17:40:19.487]                     oopts <- options(mc.cores = workers)
[17:40:19.487]                     on.exit(options(oopts))
[17:40:19.487]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:19.487]                       envir = envir)
[17:40:19.487]                     if (!future$lazy) 
[17:40:19.487]                       future <- run(future)
[17:40:19.487]                     invisible(future)
[17:40:19.487]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:19.487]                 }
[17:40:19.487]                 ...future.workdir <- getwd()
[17:40:19.487]             }
[17:40:19.487]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.487]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.487]         }
[17:40:19.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.487]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.487]             base::names(...future.oldOptions))
[17:40:19.487]     }
[17:40:19.487]     if (FALSE) {
[17:40:19.487]     }
[17:40:19.487]     else {
[17:40:19.487]         if (TRUE) {
[17:40:19.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.487]                 open = "w")
[17:40:19.487]         }
[17:40:19.487]         else {
[17:40:19.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.487]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.487]         }
[17:40:19.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.487]             base::sink(type = "output", split = FALSE)
[17:40:19.487]             base::close(...future.stdout)
[17:40:19.487]         }, add = TRUE)
[17:40:19.487]     }
[17:40:19.487]     ...future.frame <- base::sys.nframe()
[17:40:19.487]     ...future.conditions <- base::list()
[17:40:19.487]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.487]     if (FALSE) {
[17:40:19.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.487]     }
[17:40:19.487]     ...future.result <- base::tryCatch({
[17:40:19.487]         base::withCallingHandlers({
[17:40:19.487]             ...future.value <- base::withVisible(base::local({
[17:40:19.487]                 a <- 1L
[17:40:19.487]                 plan_a <- unclass(future::plan("list"))
[17:40:19.487]                 nested_a <- nested[-1]
[17:40:19.487]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:19.487]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.487]                   strategy2))
[17:40:19.487]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:19.487]                   "init") <- NULL
[17:40:19.487]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:19.487]                   "init") <- NULL
[17:40:19.487]                 stopifnot(all.equal(plan_a, nested_a))
[17:40:19.487]                 y %<-% {
[17:40:19.487]                   b <- 2L
[17:40:19.487]                   plan_b <- future::plan("list")
[17:40:19.487]                   nested_b <- nested_a[-1]
[17:40:19.487]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:19.487]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.487]                     "sequential"))
[17:40:19.487]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:19.487]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:19.487]                 }
[17:40:19.487]                 y
[17:40:19.487]             }))
[17:40:19.487]             future::FutureResult(value = ...future.value$value, 
[17:40:19.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.487]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.487]                     ...future.globalenv.names))
[17:40:19.487]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.487]         }, condition = base::local({
[17:40:19.487]             c <- base::c
[17:40:19.487]             inherits <- base::inherits
[17:40:19.487]             invokeRestart <- base::invokeRestart
[17:40:19.487]             length <- base::length
[17:40:19.487]             list <- base::list
[17:40:19.487]             seq.int <- base::seq.int
[17:40:19.487]             signalCondition <- base::signalCondition
[17:40:19.487]             sys.calls <- base::sys.calls
[17:40:19.487]             `[[` <- base::`[[`
[17:40:19.487]             `+` <- base::`+`
[17:40:19.487]             `<<-` <- base::`<<-`
[17:40:19.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.487]                   3L)]
[17:40:19.487]             }
[17:40:19.487]             function(cond) {
[17:40:19.487]                 is_error <- inherits(cond, "error")
[17:40:19.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.487]                   NULL)
[17:40:19.487]                 if (is_error) {
[17:40:19.487]                   sessionInformation <- function() {
[17:40:19.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.487]                       search = base::search(), system = base::Sys.info())
[17:40:19.487]                   }
[17:40:19.487]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.487]                     cond$call), session = sessionInformation(), 
[17:40:19.487]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.487]                   signalCondition(cond)
[17:40:19.487]                 }
[17:40:19.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.487]                 "immediateCondition"))) {
[17:40:19.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.487]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.487]                   if (TRUE && !signal) {
[17:40:19.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.487]                     {
[17:40:19.487]                       inherits <- base::inherits
[17:40:19.487]                       invokeRestart <- base::invokeRestart
[17:40:19.487]                       is.null <- base::is.null
[17:40:19.487]                       muffled <- FALSE
[17:40:19.487]                       if (inherits(cond, "message")) {
[17:40:19.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.487]                         if (muffled) 
[17:40:19.487]                           invokeRestart("muffleMessage")
[17:40:19.487]                       }
[17:40:19.487]                       else if (inherits(cond, "warning")) {
[17:40:19.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.487]                         if (muffled) 
[17:40:19.487]                           invokeRestart("muffleWarning")
[17:40:19.487]                       }
[17:40:19.487]                       else if (inherits(cond, "condition")) {
[17:40:19.487]                         if (!is.null(pattern)) {
[17:40:19.487]                           computeRestarts <- base::computeRestarts
[17:40:19.487]                           grepl <- base::grepl
[17:40:19.487]                           restarts <- computeRestarts(cond)
[17:40:19.487]                           for (restart in restarts) {
[17:40:19.487]                             name <- restart$name
[17:40:19.487]                             if (is.null(name)) 
[17:40:19.487]                               next
[17:40:19.487]                             if (!grepl(pattern, name)) 
[17:40:19.487]                               next
[17:40:19.487]                             invokeRestart(restart)
[17:40:19.487]                             muffled <- TRUE
[17:40:19.487]                             break
[17:40:19.487]                           }
[17:40:19.487]                         }
[17:40:19.487]                       }
[17:40:19.487]                       invisible(muffled)
[17:40:19.487]                     }
[17:40:19.487]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.487]                   }
[17:40:19.487]                 }
[17:40:19.487]                 else {
[17:40:19.487]                   if (TRUE) {
[17:40:19.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.487]                     {
[17:40:19.487]                       inherits <- base::inherits
[17:40:19.487]                       invokeRestart <- base::invokeRestart
[17:40:19.487]                       is.null <- base::is.null
[17:40:19.487]                       muffled <- FALSE
[17:40:19.487]                       if (inherits(cond, "message")) {
[17:40:19.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.487]                         if (muffled) 
[17:40:19.487]                           invokeRestart("muffleMessage")
[17:40:19.487]                       }
[17:40:19.487]                       else if (inherits(cond, "warning")) {
[17:40:19.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.487]                         if (muffled) 
[17:40:19.487]                           invokeRestart("muffleWarning")
[17:40:19.487]                       }
[17:40:19.487]                       else if (inherits(cond, "condition")) {
[17:40:19.487]                         if (!is.null(pattern)) {
[17:40:19.487]                           computeRestarts <- base::computeRestarts
[17:40:19.487]                           grepl <- base::grepl
[17:40:19.487]                           restarts <- computeRestarts(cond)
[17:40:19.487]                           for (restart in restarts) {
[17:40:19.487]                             name <- restart$name
[17:40:19.487]                             if (is.null(name)) 
[17:40:19.487]                               next
[17:40:19.487]                             if (!grepl(pattern, name)) 
[17:40:19.487]                               next
[17:40:19.487]                             invokeRestart(restart)
[17:40:19.487]                             muffled <- TRUE
[17:40:19.487]                             break
[17:40:19.487]                           }
[17:40:19.487]                         }
[17:40:19.487]                       }
[17:40:19.487]                       invisible(muffled)
[17:40:19.487]                     }
[17:40:19.487]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.487]                   }
[17:40:19.487]                 }
[17:40:19.487]             }
[17:40:19.487]         }))
[17:40:19.487]     }, error = function(ex) {
[17:40:19.487]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.487]                 ...future.rng), started = ...future.startTime, 
[17:40:19.487]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.487]             version = "1.8"), class = "FutureResult")
[17:40:19.487]     }, finally = {
[17:40:19.487]         if (!identical(...future.workdir, getwd())) 
[17:40:19.487]             setwd(...future.workdir)
[17:40:19.487]         {
[17:40:19.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.487]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.487]             }
[17:40:19.487]             base::options(...future.oldOptions)
[17:40:19.487]             if (.Platform$OS.type == "windows") {
[17:40:19.487]                 old_names <- names(...future.oldEnvVars)
[17:40:19.487]                 envs <- base::Sys.getenv()
[17:40:19.487]                 names <- names(envs)
[17:40:19.487]                 common <- intersect(names, old_names)
[17:40:19.487]                 added <- setdiff(names, old_names)
[17:40:19.487]                 removed <- setdiff(old_names, names)
[17:40:19.487]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.487]                   envs[common]]
[17:40:19.487]                 NAMES <- toupper(changed)
[17:40:19.487]                 args <- list()
[17:40:19.487]                 for (kk in seq_along(NAMES)) {
[17:40:19.487]                   name <- changed[[kk]]
[17:40:19.487]                   NAME <- NAMES[[kk]]
[17:40:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.487]                     next
[17:40:19.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.487]                 }
[17:40:19.487]                 NAMES <- toupper(added)
[17:40:19.487]                 for (kk in seq_along(NAMES)) {
[17:40:19.487]                   name <- added[[kk]]
[17:40:19.487]                   NAME <- NAMES[[kk]]
[17:40:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.487]                     next
[17:40:19.487]                   args[[name]] <- ""
[17:40:19.487]                 }
[17:40:19.487]                 NAMES <- toupper(removed)
[17:40:19.487]                 for (kk in seq_along(NAMES)) {
[17:40:19.487]                   name <- removed[[kk]]
[17:40:19.487]                   NAME <- NAMES[[kk]]
[17:40:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.487]                     next
[17:40:19.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.487]                 }
[17:40:19.487]                 if (length(args) > 0) 
[17:40:19.487]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.487]             }
[17:40:19.487]             else {
[17:40:19.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.487]             }
[17:40:19.487]             {
[17:40:19.487]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.487]                   0L) {
[17:40:19.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.487]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.487]                   base::options(opts)
[17:40:19.487]                 }
[17:40:19.487]                 {
[17:40:19.487]                   {
[17:40:19.487]                     NULL
[17:40:19.487]                     RNGkind("Mersenne-Twister")
[17:40:19.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.487]                       inherits = FALSE)
[17:40:19.487]                   }
[17:40:19.487]                   options(future.plan = NULL)
[17:40:19.487]                   if (is.na(NA_character_)) 
[17:40:19.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.487]                     .init = FALSE)
[17:40:19.487]                 }
[17:40:19.487]             }
[17:40:19.487]         }
[17:40:19.487]     })
[17:40:19.487]     if (TRUE) {
[17:40:19.487]         base::sink(type = "output", split = FALSE)
[17:40:19.487]         if (TRUE) {
[17:40:19.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.487]         }
[17:40:19.487]         else {
[17:40:19.487]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.487]         }
[17:40:19.487]         base::close(...future.stdout)
[17:40:19.487]         ...future.stdout <- NULL
[17:40:19.487]     }
[17:40:19.487]     ...future.result$conditions <- ...future.conditions
[17:40:19.487]     ...future.result$finished <- base::Sys.time()
[17:40:19.487]     ...future.result
[17:40:19.487] }
[17:40:19.490] assign_globals() ...
[17:40:19.490] List of 2
[17:40:19.490]  $ nested   :List of 2
[17:40:19.490]   ..$ a:function (..., envir = parent.frame())  
[17:40:19.490]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:19.490]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.490]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:19.490]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:19.490]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.490]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:19.490]  $ strategy2: chr "multicore"
[17:40:19.490]  - attr(*, "where")=List of 2
[17:40:19.490]   ..$ nested   :<environment: R_EmptyEnv> 
[17:40:19.490]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:40:19.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.490]  - attr(*, "resolved")= logi FALSE
[17:40:19.490]  - attr(*, "total_size")= num 59224
[17:40:19.490]  - attr(*, "already-done")= logi TRUE
[17:40:19.499] - copied ‘nested’ to environment
[17:40:19.499] - copied ‘strategy2’ to environment
[17:40:19.499] assign_globals() ... done
[17:40:19.500] plan(): Setting new future strategy stack:
[17:40:19.500] List of future strategies:
[17:40:19.500] 1. multicore:
[17:40:19.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:19.500]    - tweaked: FALSE
[17:40:19.500]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.505] plan(): nbrOfWorkers() = 2
[17:40:19.574] plan(): Setting new future strategy stack:
[17:40:19.574] List of future strategies:
[17:40:19.574] 1. sequential:
[17:40:19.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.574]    - tweaked: FALSE
[17:40:19.574]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.574] 2. multicore:
[17:40:19.574]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:19.574]    - tweaked: FALSE
[17:40:19.574]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.575] plan(): nbrOfWorkers() = 1
[17:40:19.576] SequentialFuture started (and completed)
[17:40:19.576] signalConditions() ...
[17:40:19.576]  - include = ‘immediateCondition’
[17:40:19.576]  - exclude = 
[17:40:19.576]  - resignal = FALSE
[17:40:19.576]  - Number of conditions: 57
[17:40:19.576] signalConditions() ... done
[17:40:19.576] - Launch lazy future ... done
[17:40:19.577] run() for ‘SequentialFuture’ ... done
[17:40:19.577] signalConditions() ...
[17:40:19.577]  - include = ‘immediateCondition’
[17:40:19.577]  - exclude = 
[17:40:19.577]  - resignal = FALSE
[17:40:19.577]  - Number of conditions: 57
[17:40:19.577] signalConditions() ... done
[17:40:19.578] Future state: ‘finished’
[17:40:19.578] signalConditions() ...
[17:40:19.578]  - include = ‘condition’
[17:40:19.578]  - exclude = ‘immediateCondition’
[17:40:19.578]  - resignal = TRUE
[17:40:19.578]  - Number of conditions: 57
[17:40:19.578]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.505] getGlobalsAndPackages() ...
[17:40:19.578]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.505] Searching for globals...
[17:40:19.579]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.524] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:40:19.579]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.524] Searching for globals ... DONE
[17:40:19.579]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.524] Resolving globals: FALSE
[17:40:19.579]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.525] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[17:40:19.579]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.525] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:40:19.579]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.525] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:40:19.579]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.526] 
[17:40:19.580]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.526] getGlobalsAndPackages() ... DONE
[17:40:19.580]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.526] run() for ‘Future’ ...
[17:40:19.580]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.526] - state: ‘created’
[17:40:19.580]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:19.580]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:19.580]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:19.581]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.531]   - Field: ‘label’
[17:40:19.581]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.531]   - Field: ‘local’
[17:40:19.581]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.531]   - Field: ‘owner’
[17:40:19.581]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.531]   - Field: ‘envir’
[17:40:19.581]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.532]   - Field: ‘workers’
[17:40:19.581]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.532]   - Field: ‘packages’
[17:40:19.581]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.532]   - Field: ‘gc’
[17:40:19.582]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.532]   - Field: ‘job’
[17:40:19.582]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.532]   - Field: ‘conditions’
[17:40:19.582]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.533]   - Field: ‘expr’
[17:40:19.582]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.533]   - Field: ‘uuid’
[17:40:19.582]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.533]   - Field: ‘seed’
[17:40:19.582]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.533]   - Field: ‘version’
[17:40:19.583]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.533]   - Field: ‘result’
[17:40:19.583]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.533]   - Field: ‘asynchronous’
[17:40:19.583]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.534]   - Field: ‘calls’
[17:40:19.583]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.534]   - Field: ‘globals’
[17:40:19.583]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.534]   - Field: ‘stdout’
[17:40:19.583]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.534]   - Field: ‘earlySignal’
[17:40:19.583]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.534]   - Field: ‘lazy’
[17:40:19.584]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.534]   - Field: ‘state’
[17:40:19.584]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:19.584]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.535] - Launch lazy future ...
[17:40:19.584]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.537] Packages needed by the future expression (n = 0): <none>
[17:40:19.584]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.537] Packages needed by future strategies (n = 0): <none>
[17:40:19.584]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.537] {
[17:40:19.537]     {
[17:40:19.537]         {
[17:40:19.537]             ...future.startTime <- base::Sys.time()
[17:40:19.537]             {
[17:40:19.537]                 {
[17:40:19.537]                   {
[17:40:19.537]                     {
[17:40:19.537]                       base::local({
[17:40:19.537]                         has_future <- base::requireNamespace("future", 
[17:40:19.537]                           quietly = TRUE)
[17:40:19.537]                         if (has_future) {
[17:40:19.537]                           ns <- base::getNamespace("future")
[17:40:19.537]                           version <- ns[[".package"]][["version"]]
[17:40:19.537]                           if (is.null(version)) 
[17:40:19.537]                             version <- utils::packageVersion("future")
[17:40:19.537]                         }
[17:40:19.537]                         else {
[17:40:19.537]                           version <- NULL
[17:40:19.537]                         }
[17:40:19.537]                         if (!has_future || version < "1.8.0") {
[17:40:19.537]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.537]                             "", base::R.version$version.string), 
[17:40:19.537]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.537]                               "release", "version")], collapse = " "), 
[17:40:19.537]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.537]                             info)
[17:40:19.537]                           info <- base::paste(info, collapse = "; ")
[17:40:19.537]                           if (!has_future) {
[17:40:19.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.537]                               info)
[17:40:19.537]                           }
[17:40:19.537]                           else {
[17:40:19.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.537]                               info, version)
[17:40:19.537]                           }
[17:40:19.537]                           base::stop(msg)
[17:40:19.537]                         }
[17:40:19.537]                       })
[17:40:19.537]                     }
[17:40:19.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:19.537]                     base::options(mc.cores = 1L)
[17:40:19.537]                   }
[17:40:19.537]                   ...future.strategy.old <- future::plan("list")
[17:40:19.537]                   options(future.plan = NULL)
[17:40:19.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:19.537]                 }
[17:40:19.537]                 ...future.workdir <- getwd()
[17:40:19.537]             }
[17:40:19.537]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.537]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.537]         }
[17:40:19.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.537]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.537]             base::names(...future.oldOptions))
[17:40:19.537]     }
[17:40:19.537]     if (FALSE) {
[17:40:19.537]     }
[17:40:19.537]     else {
[17:40:19.537]         if (TRUE) {
[17:40:19.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.537]                 open = "w")
[17:40:19.537]         }
[17:40:19.537]         else {
[17:40:19.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.537]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.537]         }
[17:40:19.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.537]             base::sink(type = "output", split = FALSE)
[17:40:19.537]             base::close(...future.stdout)
[17:40:19.537]         }, add = TRUE)
[17:40:19.537]     }
[17:40:19.537]     ...future.frame <- base::sys.nframe()
[17:40:19.537]     ...future.conditions <- base::list()
[17:40:19.537]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.537]     if (FALSE) {
[17:40:19.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.537]     }
[17:40:19.537]     ...future.result <- base::tryCatch({
[17:40:19.537]         base::withCallingHandlers({
[17:40:19.537]             ...future.value <- base::withVisible(base::local({
[17:40:19.537]                 withCallingHandlers({
[17:40:19.537]                   {
[17:40:19.537]                     b <- 2L
[17:40:19.537]                     plan_b <- future::plan("list")
[17:40:19.537]                     nested_b <- nested_a[-1]
[17:40:19.537]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:19.537]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.537]                       "sequential"))
[17:40:19.537]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:19.537]                       b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:19.537]                   }
[17:40:19.537]                 }, immediateCondition = function(cond) {
[17:40:19.537]                   save_rds <- function (object, pathname, ...) 
[17:40:19.537]                   {
[17:40:19.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:19.537]                     if (file_test("-f", pathname_tmp)) {
[17:40:19.537]                       fi_tmp <- file.info(pathname_tmp)
[17:40:19.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:19.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:19.537]                         fi_tmp[["mtime"]])
[17:40:19.537]                     }
[17:40:19.537]                     tryCatch({
[17:40:19.537]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:19.537]                     }, error = function(ex) {
[17:40:19.537]                       msg <- conditionMessage(ex)
[17:40:19.537]                       fi_tmp <- file.info(pathname_tmp)
[17:40:19.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:19.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:19.537]                         fi_tmp[["mtime"]], msg)
[17:40:19.537]                       ex$message <- msg
[17:40:19.537]                       stop(ex)
[17:40:19.537]                     })
[17:40:19.537]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:19.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:19.537]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:19.537]                       fi_tmp <- file.info(pathname_tmp)
[17:40:19.537]                       fi <- file.info(pathname)
[17:40:19.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:19.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:19.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:19.537]                         fi[["size"]], fi[["mtime"]])
[17:40:19.537]                       stop(msg)
[17:40:19.537]                     }
[17:40:19.537]                     invisible(pathname)
[17:40:19.537]                   }
[17:40:19.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:19.537]                     rootPath = tempdir()) 
[17:40:19.537]                   {
[17:40:19.537]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:19.537]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:19.537]                       tmpdir = path, fileext = ".rds")
[17:40:19.537]                     save_rds(obj, file)
[17:40:19.537]                   }
[17:40:19.537]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:19.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.537]                   {
[17:40:19.537]                     inherits <- base::inherits
[17:40:19.537]                     invokeRestart <- base::invokeRestart
[17:40:19.537]                     is.null <- base::is.null
[17:40:19.537]                     muffled <- FALSE
[17:40:19.537]                     if (inherits(cond, "message")) {
[17:40:19.537]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:19.537]                       if (muffled) 
[17:40:19.537]                         invokeRestart("muffleMessage")
[17:40:19.537]                     }
[17:40:19.537]                     else if (inherits(cond, "warning")) {
[17:40:19.537]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:19.537]                       if (muffled) 
[17:40:19.537]                         invokeRestart("muffleWarning")
[17:40:19.537]                     }
[17:40:19.537]                     else if (inherits(cond, "condition")) {
[17:40:19.537]                       if (!is.null(pattern)) {
[17:40:19.537]                         computeRestarts <- base::computeRestarts
[17:40:19.537]                         grepl <- base::grepl
[17:40:19.537]                         restarts <- computeRestarts(cond)
[17:40:19.537]                         for (restart in restarts) {
[17:40:19.537]                           name <- restart$name
[17:40:19.537]                           if (is.null(name)) 
[17:40:19.537]                             next
[17:40:19.537]                           if (!grepl(pattern, name)) 
[17:40:19.537]                             next
[17:40:19.537]                           invokeRestart(restart)
[17:40:19.537]                           muffled <- TRUE
[17:40:19.537]                           break
[17:40:19.537]                         }
[17:40:19.537]                       }
[17:40:19.537]                     }
[17:40:19.537]                     invisible(muffled)
[17:40:19.537]                   }
[17:40:19.537]                   muffleCondition(cond)
[17:40:19.537]                 })
[17:40:19.537]             }))
[17:40:19.537]             future::FutureResult(value = ...future.value$value, 
[17:40:19.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.537]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.537]                     ...future.globalenv.names))
[17:40:19.537]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.537]         }, condition = base::local({
[17:40:19.537]             c <- base::c
[17:40:19.537]             inherits <- base::inherits
[17:40:19.537]             invokeRestart <- base::invokeRestart
[17:40:19.537]             length <- base::length
[17:40:19.537]             list <- base::list
[17:40:19.537]             seq.int <- base::seq.int
[17:40:19.537]             signalCondition <- base::signalCondition
[17:40:19.537]             sys.calls <- base::sys.calls
[17:40:19.537]             `[[` <- base::`[[`
[17:40:19.537]             `+` <- base::`+`
[17:40:19.537]             `<<-` <- base::`<<-`
[17:40:19.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.537]                   3L)]
[17:40:19.537]             }
[17:40:19.537]             function(cond) {
[17:40:19.537]                 is_error <- inherits(cond, "error")
[17:40:19.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.537]                   NULL)
[17:40:19.537]                 if (is_error) {
[17:40:19.537]                   sessionInformation <- function() {
[17:40:19.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.537]                       search = base::search(), system = base::Sys.info())
[17:40:19.537]                   }
[17:40:19.537]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.537]                     cond$call), session = sessionInformation(), 
[17:40:19.537]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.537]                   signalCondition(cond)
[17:40:19.537]                 }
[17:40:19.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.537]                 "immediateCondition"))) {
[17:40:19.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.537]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.537]                   if (TRUE && !signal) {
[17:40:19.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.537]                     {
[17:40:19.537]                       inherits <- base::inherits
[17:40:19.537]                       invokeRestart <- base::invokeRestart
[17:40:19.537]                       is.null <- base::is.null
[17:40:19.537]                       muffled <- FALSE
[17:40:19.537]                       if (inherits(cond, "message")) {
[17:40:19.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.537]                         if (muffled) 
[17:40:19.537]                           invokeRestart("muffleMessage")
[17:40:19.537]                       }
[17:40:19.537]                       else if (inherits(cond, "warning")) {
[17:40:19.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.537]                         if (muffled) 
[17:40:19.537]                           invokeRestart("muffleWarning")
[17:40:19.537]                       }
[17:40:19.537]                       else if (inherits(cond, "condition")) {
[17:40:19.537]                         if (!is.null(pattern)) {
[17:40:19.537]                           computeRestarts <- base::computeRestarts
[17:40:19.537]                           grepl <- base::grepl
[17:40:19.537]                           restarts <- computeRestarts(cond)
[17:40:19.537]                           for (restart in restarts) {
[17:40:19.537]                             name <- restart$name
[17:40:19.537]                             if (is.null(name)) 
[17:40:19.537]                               next
[17:40:19.537]                             if (!grepl(pattern, name)) 
[17:40:19.537]                               next
[17:40:19.537]                             invokeRestart(restart)
[17:40:19.537]                             muffled <- TRUE
[17:40:19.537]                             break
[17:40:19.537]                           }
[17:40:19.537]                         }
[17:40:19.537]                       }
[17:40:19.537]                       invisible(muffled)
[17:40:19.537]                     }
[17:40:19.537]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.537]                   }
[17:40:19.537]                 }
[17:40:19.537]                 else {
[17:40:19.537]                   if (TRUE) {
[17:40:19.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.537]                     {
[17:40:19.537]                       inherits <- base::inherits
[17:40:19.537]                       invokeRestart <- base::invokeRestart
[17:40:19.537]                       is.null <- base::is.null
[17:40:19.537]                       muffled <- FALSE
[17:40:19.537]                       if (inherits(cond, "message")) {
[17:40:19.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.537]                         if (muffled) 
[17:40:19.537]                           invokeRestart("muffleMessage")
[17:40:19.537]                       }
[17:40:19.537]                       else if (inherits(cond, "warning")) {
[17:40:19.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.537]                         if (muffled) 
[17:40:19.537]                           invokeRestart("muffleWarning")
[17:40:19.537]                       }
[17:40:19.537]                       else if (inherits(cond, "condition")) {
[17:40:19.537]                         if (!is.null(pattern)) {
[17:40:19.537]                           computeRestarts <- base::computeRestarts
[17:40:19.537]                           grepl <- base::grepl
[17:40:19.537]                           restarts <- computeRestarts(cond)
[17:40:19.537]                           for (restart in restarts) {
[17:40:19.537]                             name <- restart$name
[17:40:19.537]                             if (is.null(name)) 
[17:40:19.537]                               next
[17:40:19.537]                             if (!grepl(pattern, name)) 
[17:40:19.537]                               next
[17:40:19.537]                             invokeRestart(restart)
[17:40:19.537]                             muffled <- TRUE
[17:40:19.537]                             break
[17:40:19.537]                           }
[17:40:19.537]                         }
[17:40:19.537]                       }
[17:40:19.537]                       invisible(muffled)
[17:40:19.537]                     }
[17:40:19.537]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.537]                   }
[17:40:19.537]                 }
[17:40:19.537]             }
[17:40:19.537]         }))
[17:40:19.537]     }, error = function(ex) {
[17:40:19.537]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.537]                 ...future.rng), started = ...future.startTime, 
[17:40:19.537]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.537]             version = "1.8"), class = "FutureResult")
[17:40:19.537]     }, finally = {
[17:40:19.537]         if (!identical(...future.workdir, getwd())) 
[17:40:19.537]             setwd(...future.workdir)
[17:40:19.537]         {
[17:40:19.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.537]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.537]             }
[17:40:19.537]             base::options(...future.oldOptions)
[17:40:19.537]             if (.Platform$OS.type == "windows") {
[17:40:19.537]                 old_names <- names(...future.oldEnvVars)
[17:40:19.537]                 envs <- base::Sys.getenv()
[17:40:19.537]                 names <- names(envs)
[17:40:19.537]                 common <- intersect(names, old_names)
[17:40:19.537]                 added <- setdiff(names, old_names)
[17:40:19.537]                 removed <- setdiff(old_names, names)
[17:40:19.537]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.537]                   envs[common]]
[17:40:19.537]                 NAMES <- toupper(changed)
[17:40:19.537]                 args <- list()
[17:40:19.537]                 for (kk in seq_along(NAMES)) {
[17:40:19.537]                   name <- changed[[kk]]
[17:40:19.537]                   NAME <- NAMES[[kk]]
[17:40:19.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.537]                     next
[17:40:19.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.537]                 }
[17:40:19.537]                 NAMES <- toupper(added)
[17:40:19.537]                 for (kk in seq_along(NAMES)) {
[17:40:19.537]                   name <- added[[kk]]
[17:40:19.537]                   NAME <- NAMES[[kk]]
[17:40:19.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.537]                     next
[17:40:19.537]                   args[[name]] <- ""
[17:40:19.537]                 }
[17:40:19.537]                 NAMES <- toupper(removed)
[17:40:19.537]                 for (kk in seq_along(NAMES)) {
[17:40:19.537]                   name <- removed[[kk]]
[17:40:19.537]                   NAME <- NAMES[[kk]]
[17:40:19.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.537]                     next
[17:40:19.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.537]                 }
[17:40:19.537]                 if (length(args) > 0) 
[17:40:19.537]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.537]             }
[17:40:19.537]             else {
[17:40:19.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.537]             }
[17:40:19.537]             {
[17:40:19.537]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.537]                   0L) {
[17:40:19.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.537]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.537]                   base::options(opts)
[17:40:19.537]                 }
[17:40:19.537]                 {
[17:40:19.537]                   {
[17:40:19.537]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:19.537]                     NULL
[17:40:19.537]                   }
[17:40:19.537]                   options(future.plan = NULL)
[17:40:19.537]                   if (is.na(NA_character_)) 
[17:40:19.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.537]                     .init = FALSE)
[17:40:19.537]                 }
[17:40:19.537]             }
[17:40:19.537]         }
[17:40:19.537]     })
[17:40:19.537]     if (TRUE) {
[17:40:19.537]         base::sink(type = "output", split = FALSE)
[17:40:19.537]         if (TRUE) {
[17:40:19.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.537]         }
[17:40:19.537]         else {
[17:40:19.537]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.537]         }
[17:40:19.537]         base::close(...future.stdout)
[17:40:19.537]         ...future.stdout <- NULL
[17:40:19.537]     }
[17:40:19.537]     ...future.result$conditions <- ...future.conditions
[17:40:19.537]     ...future.result$finished <- base::Sys.time()
[17:40:19.537]     ...future.result
[17:40:19.537] }
[17:40:19.585]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.541] assign_globals() ...
[17:40:19.585]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.542] List of 3
[17:40:19.542]  $ nested_a:List of 1
[17:40:19.542]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:19.542]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:19.542]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.542]  $ a       : int 1
[17:40:19.542]  $ plan_a  :List of 1
[17:40:19.542]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:19.542]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:19.542]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.542]  - attr(*, "where")=List of 3
[17:40:19.542]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:40:19.542]   ..$ a       :<environment: R_EmptyEnv> 
[17:40:19.542]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:40:19.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.542]  - attr(*, "resolved")= logi FALSE
[17:40:19.542]  - attr(*, "total_size")= num 95240
[17:40:19.542]  - attr(*, "already-done")= logi TRUE
[17:40:19.585]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.548] - copied ‘nested_a’ to environment
[17:40:19.585]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.548] - copied ‘a’ to environment
[17:40:19.585]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.548] - copied ‘plan_a’ to environment
[17:40:19.585]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.548] assign_globals() ... done
[17:40:19.586]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.548] requestCore(): workers = 2
[17:40:19.586]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.551] MulticoreFuture started
[17:40:19.586]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.552] - Launch lazy future ... done
[17:40:19.586]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.552] run() for ‘MulticoreFuture’ ... done
[17:40:19.586]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.553] result() for MulticoreFuture ...
[17:40:19.586]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.573] result() for MulticoreFuture ...
[17:40:19.586]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.573] result() for MulticoreFuture ... done
[17:40:19.587]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.573] result() for MulticoreFuture ... done
[17:40:19.587]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.574] result() for MulticoreFuture ...
[17:40:19.587]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.574] result() for MulticoreFuture ... done
[17:40:19.587] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:19.593] getGlobalsAndPackages() ...
[17:40:19.593] Searching for globals...
[17:40:19.594] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:19.595] Searching for globals ... DONE
[17:40:19.595] Resolving globals: FALSE
[17:40:19.595] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:19.596] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:19.596] - globals: [1] ‘data’
[17:40:19.596] - packages: [1] ‘future’
[17:40:19.596] getGlobalsAndPackages() ... DONE
[17:40:19.596] run() for ‘Future’ ...
[17:40:19.596] - state: ‘created’
[17:40:19.597] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.597] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.598]   - Field: ‘label’
[17:40:19.599]   - Field: ‘local’
[17:40:19.599]   - Field: ‘owner’
[17:40:19.599]   - Field: ‘envir’
[17:40:19.599]   - Field: ‘packages’
[17:40:19.599]   - Field: ‘gc’
[17:40:19.599]   - Field: ‘conditions’
[17:40:19.599]   - Field: ‘expr’
[17:40:19.599]   - Field: ‘uuid’
[17:40:19.599]   - Field: ‘seed’
[17:40:19.599]   - Field: ‘version’
[17:40:19.600]   - Field: ‘result’
[17:40:19.600]   - Field: ‘asynchronous’
[17:40:19.600]   - Field: ‘calls’
[17:40:19.600]   - Field: ‘globals’
[17:40:19.600]   - Field: ‘stdout’
[17:40:19.600]   - Field: ‘earlySignal’
[17:40:19.600]   - Field: ‘lazy’
[17:40:19.600]   - Field: ‘state’
[17:40:19.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.600] - Launch lazy future ...
[17:40:19.601] Packages needed by the future expression (n = 1): ‘future’
[17:40:19.601] Packages needed by future strategies (n = 1): ‘future’
[17:40:19.601] {
[17:40:19.601]     {
[17:40:19.601]         {
[17:40:19.601]             ...future.startTime <- base::Sys.time()
[17:40:19.601]             {
[17:40:19.601]                 {
[17:40:19.601]                   {
[17:40:19.601]                     {
[17:40:19.601]                       base::local({
[17:40:19.601]                         has_future <- base::requireNamespace("future", 
[17:40:19.601]                           quietly = TRUE)
[17:40:19.601]                         if (has_future) {
[17:40:19.601]                           ns <- base::getNamespace("future")
[17:40:19.601]                           version <- ns[[".package"]][["version"]]
[17:40:19.601]                           if (is.null(version)) 
[17:40:19.601]                             version <- utils::packageVersion("future")
[17:40:19.601]                         }
[17:40:19.601]                         else {
[17:40:19.601]                           version <- NULL
[17:40:19.601]                         }
[17:40:19.601]                         if (!has_future || version < "1.8.0") {
[17:40:19.601]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.601]                             "", base::R.version$version.string), 
[17:40:19.601]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.601]                               "release", "version")], collapse = " "), 
[17:40:19.601]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.601]                             info)
[17:40:19.601]                           info <- base::paste(info, collapse = "; ")
[17:40:19.601]                           if (!has_future) {
[17:40:19.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.601]                               info)
[17:40:19.601]                           }
[17:40:19.601]                           else {
[17:40:19.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.601]                               info, version)
[17:40:19.601]                           }
[17:40:19.601]                           base::stop(msg)
[17:40:19.601]                         }
[17:40:19.601]                       })
[17:40:19.601]                     }
[17:40:19.601]                     base::local({
[17:40:19.601]                       for (pkg in "future") {
[17:40:19.601]                         base::loadNamespace(pkg)
[17:40:19.601]                         base::library(pkg, character.only = TRUE)
[17:40:19.601]                       }
[17:40:19.601]                     })
[17:40:19.601]                   }
[17:40:19.601]                   ...future.strategy.old <- future::plan("list")
[17:40:19.601]                   options(future.plan = NULL)
[17:40:19.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.601]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:19.601]                     envir = parent.frame()) 
[17:40:19.601]                   {
[17:40:19.601]                     default_workers <- missing(workers)
[17:40:19.601]                     if (is.function(workers)) 
[17:40:19.601]                       workers <- workers()
[17:40:19.601]                     workers <- structure(as.integer(workers), 
[17:40:19.601]                       class = class(workers))
[17:40:19.601]                     stop_if_not(is.finite(workers), workers >= 
[17:40:19.601]                       1L)
[17:40:19.601]                     if ((workers == 1L && !inherits(workers, 
[17:40:19.601]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:19.601]                       if (default_workers) 
[17:40:19.601]                         supportsMulticore(warn = TRUE)
[17:40:19.601]                       return(sequential(..., envir = envir))
[17:40:19.601]                     }
[17:40:19.601]                     oopts <- options(mc.cores = workers)
[17:40:19.601]                     on.exit(options(oopts))
[17:40:19.601]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:19.601]                       envir = envir)
[17:40:19.601]                     if (!future$lazy) 
[17:40:19.601]                       future <- run(future)
[17:40:19.601]                     invisible(future)
[17:40:19.601]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:19.601]                 }
[17:40:19.601]                 ...future.workdir <- getwd()
[17:40:19.601]             }
[17:40:19.601]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.601]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.601]         }
[17:40:19.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.601]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.601]             base::names(...future.oldOptions))
[17:40:19.601]     }
[17:40:19.601]     if (FALSE) {
[17:40:19.601]     }
[17:40:19.601]     else {
[17:40:19.601]         if (TRUE) {
[17:40:19.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.601]                 open = "w")
[17:40:19.601]         }
[17:40:19.601]         else {
[17:40:19.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.601]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.601]         }
[17:40:19.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.601]             base::sink(type = "output", split = FALSE)
[17:40:19.601]             base::close(...future.stdout)
[17:40:19.601]         }, add = TRUE)
[17:40:19.601]     }
[17:40:19.601]     ...future.frame <- base::sys.nframe()
[17:40:19.601]     ...future.conditions <- base::list()
[17:40:19.601]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.601]     if (FALSE) {
[17:40:19.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.601]     }
[17:40:19.601]     ...future.result <- base::tryCatch({
[17:40:19.601]         base::withCallingHandlers({
[17:40:19.601]             ...future.value <- base::withVisible(base::local({
[17:40:19.601]                 value(future(subset(data, a == 2)))
[17:40:19.601]             }))
[17:40:19.601]             future::FutureResult(value = ...future.value$value, 
[17:40:19.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.601]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.601]                     ...future.globalenv.names))
[17:40:19.601]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.601]         }, condition = base::local({
[17:40:19.601]             c <- base::c
[17:40:19.601]             inherits <- base::inherits
[17:40:19.601]             invokeRestart <- base::invokeRestart
[17:40:19.601]             length <- base::length
[17:40:19.601]             list <- base::list
[17:40:19.601]             seq.int <- base::seq.int
[17:40:19.601]             signalCondition <- base::signalCondition
[17:40:19.601]             sys.calls <- base::sys.calls
[17:40:19.601]             `[[` <- base::`[[`
[17:40:19.601]             `+` <- base::`+`
[17:40:19.601]             `<<-` <- base::`<<-`
[17:40:19.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.601]                   3L)]
[17:40:19.601]             }
[17:40:19.601]             function(cond) {
[17:40:19.601]                 is_error <- inherits(cond, "error")
[17:40:19.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.601]                   NULL)
[17:40:19.601]                 if (is_error) {
[17:40:19.601]                   sessionInformation <- function() {
[17:40:19.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.601]                       search = base::search(), system = base::Sys.info())
[17:40:19.601]                   }
[17:40:19.601]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.601]                     cond$call), session = sessionInformation(), 
[17:40:19.601]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.601]                   signalCondition(cond)
[17:40:19.601]                 }
[17:40:19.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.601]                 "immediateCondition"))) {
[17:40:19.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.601]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.601]                   if (TRUE && !signal) {
[17:40:19.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.601]                     {
[17:40:19.601]                       inherits <- base::inherits
[17:40:19.601]                       invokeRestart <- base::invokeRestart
[17:40:19.601]                       is.null <- base::is.null
[17:40:19.601]                       muffled <- FALSE
[17:40:19.601]                       if (inherits(cond, "message")) {
[17:40:19.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.601]                         if (muffled) 
[17:40:19.601]                           invokeRestart("muffleMessage")
[17:40:19.601]                       }
[17:40:19.601]                       else if (inherits(cond, "warning")) {
[17:40:19.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.601]                         if (muffled) 
[17:40:19.601]                           invokeRestart("muffleWarning")
[17:40:19.601]                       }
[17:40:19.601]                       else if (inherits(cond, "condition")) {
[17:40:19.601]                         if (!is.null(pattern)) {
[17:40:19.601]                           computeRestarts <- base::computeRestarts
[17:40:19.601]                           grepl <- base::grepl
[17:40:19.601]                           restarts <- computeRestarts(cond)
[17:40:19.601]                           for (restart in restarts) {
[17:40:19.601]                             name <- restart$name
[17:40:19.601]                             if (is.null(name)) 
[17:40:19.601]                               next
[17:40:19.601]                             if (!grepl(pattern, name)) 
[17:40:19.601]                               next
[17:40:19.601]                             invokeRestart(restart)
[17:40:19.601]                             muffled <- TRUE
[17:40:19.601]                             break
[17:40:19.601]                           }
[17:40:19.601]                         }
[17:40:19.601]                       }
[17:40:19.601]                       invisible(muffled)
[17:40:19.601]                     }
[17:40:19.601]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.601]                   }
[17:40:19.601]                 }
[17:40:19.601]                 else {
[17:40:19.601]                   if (TRUE) {
[17:40:19.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.601]                     {
[17:40:19.601]                       inherits <- base::inherits
[17:40:19.601]                       invokeRestart <- base::invokeRestart
[17:40:19.601]                       is.null <- base::is.null
[17:40:19.601]                       muffled <- FALSE
[17:40:19.601]                       if (inherits(cond, "message")) {
[17:40:19.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.601]                         if (muffled) 
[17:40:19.601]                           invokeRestart("muffleMessage")
[17:40:19.601]                       }
[17:40:19.601]                       else if (inherits(cond, "warning")) {
[17:40:19.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.601]                         if (muffled) 
[17:40:19.601]                           invokeRestart("muffleWarning")
[17:40:19.601]                       }
[17:40:19.601]                       else if (inherits(cond, "condition")) {
[17:40:19.601]                         if (!is.null(pattern)) {
[17:40:19.601]                           computeRestarts <- base::computeRestarts
[17:40:19.601]                           grepl <- base::grepl
[17:40:19.601]                           restarts <- computeRestarts(cond)
[17:40:19.601]                           for (restart in restarts) {
[17:40:19.601]                             name <- restart$name
[17:40:19.601]                             if (is.null(name)) 
[17:40:19.601]                               next
[17:40:19.601]                             if (!grepl(pattern, name)) 
[17:40:19.601]                               next
[17:40:19.601]                             invokeRestart(restart)
[17:40:19.601]                             muffled <- TRUE
[17:40:19.601]                             break
[17:40:19.601]                           }
[17:40:19.601]                         }
[17:40:19.601]                       }
[17:40:19.601]                       invisible(muffled)
[17:40:19.601]                     }
[17:40:19.601]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.601]                   }
[17:40:19.601]                 }
[17:40:19.601]             }
[17:40:19.601]         }))
[17:40:19.601]     }, error = function(ex) {
[17:40:19.601]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.601]                 ...future.rng), started = ...future.startTime, 
[17:40:19.601]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.601]             version = "1.8"), class = "FutureResult")
[17:40:19.601]     }, finally = {
[17:40:19.601]         if (!identical(...future.workdir, getwd())) 
[17:40:19.601]             setwd(...future.workdir)
[17:40:19.601]         {
[17:40:19.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.601]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.601]             }
[17:40:19.601]             base::options(...future.oldOptions)
[17:40:19.601]             if (.Platform$OS.type == "windows") {
[17:40:19.601]                 old_names <- names(...future.oldEnvVars)
[17:40:19.601]                 envs <- base::Sys.getenv()
[17:40:19.601]                 names <- names(envs)
[17:40:19.601]                 common <- intersect(names, old_names)
[17:40:19.601]                 added <- setdiff(names, old_names)
[17:40:19.601]                 removed <- setdiff(old_names, names)
[17:40:19.601]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.601]                   envs[common]]
[17:40:19.601]                 NAMES <- toupper(changed)
[17:40:19.601]                 args <- list()
[17:40:19.601]                 for (kk in seq_along(NAMES)) {
[17:40:19.601]                   name <- changed[[kk]]
[17:40:19.601]                   NAME <- NAMES[[kk]]
[17:40:19.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.601]                     next
[17:40:19.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.601]                 }
[17:40:19.601]                 NAMES <- toupper(added)
[17:40:19.601]                 for (kk in seq_along(NAMES)) {
[17:40:19.601]                   name <- added[[kk]]
[17:40:19.601]                   NAME <- NAMES[[kk]]
[17:40:19.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.601]                     next
[17:40:19.601]                   args[[name]] <- ""
[17:40:19.601]                 }
[17:40:19.601]                 NAMES <- toupper(removed)
[17:40:19.601]                 for (kk in seq_along(NAMES)) {
[17:40:19.601]                   name <- removed[[kk]]
[17:40:19.601]                   NAME <- NAMES[[kk]]
[17:40:19.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.601]                     next
[17:40:19.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.601]                 }
[17:40:19.601]                 if (length(args) > 0) 
[17:40:19.601]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.601]             }
[17:40:19.601]             else {
[17:40:19.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.601]             }
[17:40:19.601]             {
[17:40:19.601]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.601]                   0L) {
[17:40:19.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.601]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.601]                   base::options(opts)
[17:40:19.601]                 }
[17:40:19.601]                 {
[17:40:19.601]                   {
[17:40:19.601]                     NULL
[17:40:19.601]                     RNGkind("Mersenne-Twister")
[17:40:19.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.601]                       inherits = FALSE)
[17:40:19.601]                   }
[17:40:19.601]                   options(future.plan = NULL)
[17:40:19.601]                   if (is.na(NA_character_)) 
[17:40:19.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.601]                     .init = FALSE)
[17:40:19.601]                 }
[17:40:19.601]             }
[17:40:19.601]         }
[17:40:19.601]     })
[17:40:19.601]     if (TRUE) {
[17:40:19.601]         base::sink(type = "output", split = FALSE)
[17:40:19.601]         if (TRUE) {
[17:40:19.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.601]         }
[17:40:19.601]         else {
[17:40:19.601]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.601]         }
[17:40:19.601]         base::close(...future.stdout)
[17:40:19.601]         ...future.stdout <- NULL
[17:40:19.601]     }
[17:40:19.601]     ...future.result$conditions <- ...future.conditions
[17:40:19.601]     ...future.result$finished <- base::Sys.time()
[17:40:19.601]     ...future.result
[17:40:19.601] }
[17:40:19.603] assign_globals() ...
[17:40:19.603] List of 1
[17:40:19.603]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:19.603]   ..$ a: int [1:3] 1 2 3
[17:40:19.603]   ..$ b: int [1:3] 3 2 1
[17:40:19.603]  - attr(*, "where")=List of 1
[17:40:19.603]   ..$ data:<environment: R_EmptyEnv> 
[17:40:19.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.603]  - attr(*, "resolved")= logi FALSE
[17:40:19.603]  - attr(*, "total_size")= num 128
[17:40:19.603]  - attr(*, "already-done")= logi TRUE
[17:40:19.606] - copied ‘data’ to environment
[17:40:19.606] assign_globals() ... done
[17:40:19.607] plan(): Setting new future strategy stack:
[17:40:19.607] List of future strategies:
[17:40:19.607] 1. multicore:
[17:40:19.607]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:19.607]    - tweaked: FALSE
[17:40:19.607]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.610] plan(): nbrOfWorkers() = 2
[17:40:19.654] plan(): Setting new future strategy stack:
[17:40:19.654] List of future strategies:
[17:40:19.654] 1. sequential:
[17:40:19.654]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.654]    - tweaked: FALSE
[17:40:19.654]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.654] 2. multicore:
[17:40:19.654]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:19.654]    - tweaked: FALSE
[17:40:19.654]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.655] plan(): nbrOfWorkers() = 1
[17:40:19.655] SequentialFuture started (and completed)
[17:40:19.655] signalConditions() ...
[17:40:19.656]  - include = ‘immediateCondition’
[17:40:19.656]  - exclude = 
[17:40:19.656]  - resignal = FALSE
[17:40:19.656]  - Number of conditions: 55
[17:40:19.656] signalConditions() ... done
[17:40:19.656] - Launch lazy future ... done
[17:40:19.656] run() for ‘SequentialFuture’ ... done
[17:40:19.657] signalConditions() ...
[17:40:19.657]  - include = ‘immediateCondition’
[17:40:19.657]  - exclude = 
[17:40:19.657]  - resignal = FALSE
[17:40:19.657]  - Number of conditions: 55
[17:40:19.657] signalConditions() ... done
[17:40:19.657] Future state: ‘finished’
[17:40:19.657] signalConditions() ...
[17:40:19.657]  - include = ‘condition’
[17:40:19.658]  - exclude = ‘immediateCondition’
[17:40:19.658]  - resignal = TRUE
[17:40:19.658]  - Number of conditions: 55
[17:40:19.658]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.611] getGlobalsAndPackages() ...
[17:40:19.658]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.611] Searching for globals...
[17:40:19.658]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.626] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:19.658]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.626] Searching for globals ... DONE
[17:40:19.659]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.626] Resolving globals: FALSE
[17:40:19.659]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.627] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:19.659]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.627] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:19.659]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.627] - globals: [1] ‘data’
[17:40:19.659]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.627] 
[17:40:19.659]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.627] getGlobalsAndPackages() ... DONE
[17:40:19.660]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.628] run() for ‘Future’ ...
[17:40:19.660]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.628] - state: ‘created’
[17:40:19.660]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:19.660]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:19.660]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:19.660]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘label’
[17:40:19.661]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘local’
[17:40:19.661]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘owner’
[17:40:19.661]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘envir’
[17:40:19.663]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘workers’
[17:40:19.663]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘packages’
[17:40:19.664]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘gc’
[17:40:19.664]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.632]   - Field: ‘job’
[17:40:19.664]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘conditions’
[17:40:19.664]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘expr’
[17:40:19.664]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘uuid’
[17:40:19.665]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘seed’
[17:40:19.665]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘version’
[17:40:19.665]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘result’
[17:40:19.665]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘asynchronous’
[17:40:19.665]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘calls’
[17:40:19.666]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘globals’
[17:40:19.666]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.633]   - Field: ‘stdout’
[17:40:19.666]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634]   - Field: ‘earlySignal’
[17:40:19.666]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634]   - Field: ‘lazy’
[17:40:19.666]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634]   - Field: ‘state’
[17:40:19.666]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:19.666]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634] - Launch lazy future ...
[17:40:19.667]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634] Packages needed by the future expression (n = 0): <none>
[17:40:19.667]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.634] Packages needed by future strategies (n = 0): <none>
[17:40:19.667]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.635] {
[17:40:19.635]     {
[17:40:19.635]         {
[17:40:19.635]             ...future.startTime <- base::Sys.time()
[17:40:19.635]             {
[17:40:19.635]                 {
[17:40:19.635]                   {
[17:40:19.635]                     {
[17:40:19.635]                       base::local({
[17:40:19.635]                         has_future <- base::requireNamespace("future", 
[17:40:19.635]                           quietly = TRUE)
[17:40:19.635]                         if (has_future) {
[17:40:19.635]                           ns <- base::getNamespace("future")
[17:40:19.635]                           version <- ns[[".package"]][["version"]]
[17:40:19.635]                           if (is.null(version)) 
[17:40:19.635]                             version <- utils::packageVersion("future")
[17:40:19.635]                         }
[17:40:19.635]                         else {
[17:40:19.635]                           version <- NULL
[17:40:19.635]                         }
[17:40:19.635]                         if (!has_future || version < "1.8.0") {
[17:40:19.635]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.635]                             "", base::R.version$version.string), 
[17:40:19.635]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.635]                               "release", "version")], collapse = " "), 
[17:40:19.635]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.635]                             info)
[17:40:19.635]                           info <- base::paste(info, collapse = "; ")
[17:40:19.635]                           if (!has_future) {
[17:40:19.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.635]                               info)
[17:40:19.635]                           }
[17:40:19.635]                           else {
[17:40:19.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.635]                               info, version)
[17:40:19.635]                           }
[17:40:19.635]                           base::stop(msg)
[17:40:19.635]                         }
[17:40:19.635]                       })
[17:40:19.635]                     }
[17:40:19.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:19.635]                     base::options(mc.cores = 1L)
[17:40:19.635]                   }
[17:40:19.635]                   ...future.strategy.old <- future::plan("list")
[17:40:19.635]                   options(future.plan = NULL)
[17:40:19.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:19.635]                 }
[17:40:19.635]                 ...future.workdir <- getwd()
[17:40:19.635]             }
[17:40:19.635]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.635]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.635]         }
[17:40:19.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.635]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.635]             base::names(...future.oldOptions))
[17:40:19.635]     }
[17:40:19.635]     if (FALSE) {
[17:40:19.635]     }
[17:40:19.635]     else {
[17:40:19.635]         if (TRUE) {
[17:40:19.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.635]                 open = "w")
[17:40:19.635]         }
[17:40:19.635]         else {
[17:40:19.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.635]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.635]         }
[17:40:19.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.635]             base::sink(type = "output", split = FALSE)
[17:40:19.635]             base::close(...future.stdout)
[17:40:19.635]         }, add = TRUE)
[17:40:19.635]     }
[17:40:19.635]     ...future.frame <- base::sys.nframe()
[17:40:19.635]     ...future.conditions <- base::list()
[17:40:19.635]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.635]     if (FALSE) {
[17:40:19.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.635]     }
[17:40:19.635]     ...future.result <- base::tryCatch({
[17:40:19.635]         base::withCallingHandlers({
[17:40:19.635]             ...future.value <- base::withVisible(base::local({
[17:40:19.635]                 withCallingHandlers({
[17:40:19.635]                   subset(data, a == 2)
[17:40:19.635]                 }, immediateCondition = function(cond) {
[17:40:19.635]                   save_rds <- function (object, pathname, ...) 
[17:40:19.635]                   {
[17:40:19.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:19.635]                     if (file_test("-f", pathname_tmp)) {
[17:40:19.635]                       fi_tmp <- file.info(pathname_tmp)
[17:40:19.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:19.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:19.635]                         fi_tmp[["mtime"]])
[17:40:19.635]                     }
[17:40:19.635]                     tryCatch({
[17:40:19.635]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:19.635]                     }, error = function(ex) {
[17:40:19.635]                       msg <- conditionMessage(ex)
[17:40:19.635]                       fi_tmp <- file.info(pathname_tmp)
[17:40:19.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:19.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:19.635]                         fi_tmp[["mtime"]], msg)
[17:40:19.635]                       ex$message <- msg
[17:40:19.635]                       stop(ex)
[17:40:19.635]                     })
[17:40:19.635]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:19.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:19.635]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:19.635]                       fi_tmp <- file.info(pathname_tmp)
[17:40:19.635]                       fi <- file.info(pathname)
[17:40:19.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:19.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:19.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:19.635]                         fi[["size"]], fi[["mtime"]])
[17:40:19.635]                       stop(msg)
[17:40:19.635]                     }
[17:40:19.635]                     invisible(pathname)
[17:40:19.635]                   }
[17:40:19.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:19.635]                     rootPath = tempdir()) 
[17:40:19.635]                   {
[17:40:19.635]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:19.635]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:19.635]                       tmpdir = path, fileext = ".rds")
[17:40:19.635]                     save_rds(obj, file)
[17:40:19.635]                   }
[17:40:19.635]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:19.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.635]                   {
[17:40:19.635]                     inherits <- base::inherits
[17:40:19.635]                     invokeRestart <- base::invokeRestart
[17:40:19.635]                     is.null <- base::is.null
[17:40:19.635]                     muffled <- FALSE
[17:40:19.635]                     if (inherits(cond, "message")) {
[17:40:19.635]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:19.635]                       if (muffled) 
[17:40:19.635]                         invokeRestart("muffleMessage")
[17:40:19.635]                     }
[17:40:19.635]                     else if (inherits(cond, "warning")) {
[17:40:19.635]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:19.635]                       if (muffled) 
[17:40:19.635]                         invokeRestart("muffleWarning")
[17:40:19.635]                     }
[17:40:19.635]                     else if (inherits(cond, "condition")) {
[17:40:19.635]                       if (!is.null(pattern)) {
[17:40:19.635]                         computeRestarts <- base::computeRestarts
[17:40:19.635]                         grepl <- base::grepl
[17:40:19.635]                         restarts <- computeRestarts(cond)
[17:40:19.635]                         for (restart in restarts) {
[17:40:19.635]                           name <- restart$name
[17:40:19.635]                           if (is.null(name)) 
[17:40:19.635]                             next
[17:40:19.635]                           if (!grepl(pattern, name)) 
[17:40:19.635]                             next
[17:40:19.635]                           invokeRestart(restart)
[17:40:19.635]                           muffled <- TRUE
[17:40:19.635]                           break
[17:40:19.635]                         }
[17:40:19.635]                       }
[17:40:19.635]                     }
[17:40:19.635]                     invisible(muffled)
[17:40:19.635]                   }
[17:40:19.635]                   muffleCondition(cond)
[17:40:19.635]                 })
[17:40:19.635]             }))
[17:40:19.635]             future::FutureResult(value = ...future.value$value, 
[17:40:19.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.635]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.635]                     ...future.globalenv.names))
[17:40:19.635]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.635]         }, condition = base::local({
[17:40:19.635]             c <- base::c
[17:40:19.635]             inherits <- base::inherits
[17:40:19.635]             invokeRestart <- base::invokeRestart
[17:40:19.635]             length <- base::length
[17:40:19.635]             list <- base::list
[17:40:19.635]             seq.int <- base::seq.int
[17:40:19.635]             signalCondition <- base::signalCondition
[17:40:19.635]             sys.calls <- base::sys.calls
[17:40:19.635]             `[[` <- base::`[[`
[17:40:19.635]             `+` <- base::`+`
[17:40:19.635]             `<<-` <- base::`<<-`
[17:40:19.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.635]                   3L)]
[17:40:19.635]             }
[17:40:19.635]             function(cond) {
[17:40:19.635]                 is_error <- inherits(cond, "error")
[17:40:19.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.635]                   NULL)
[17:40:19.635]                 if (is_error) {
[17:40:19.635]                   sessionInformation <- function() {
[17:40:19.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.635]                       search = base::search(), system = base::Sys.info())
[17:40:19.635]                   }
[17:40:19.635]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.635]                     cond$call), session = sessionInformation(), 
[17:40:19.635]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.635]                   signalCondition(cond)
[17:40:19.635]                 }
[17:40:19.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.635]                 "immediateCondition"))) {
[17:40:19.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.635]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.635]                   if (TRUE && !signal) {
[17:40:19.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.635]                     {
[17:40:19.635]                       inherits <- base::inherits
[17:40:19.635]                       invokeRestart <- base::invokeRestart
[17:40:19.635]                       is.null <- base::is.null
[17:40:19.635]                       muffled <- FALSE
[17:40:19.635]                       if (inherits(cond, "message")) {
[17:40:19.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.635]                         if (muffled) 
[17:40:19.635]                           invokeRestart("muffleMessage")
[17:40:19.635]                       }
[17:40:19.635]                       else if (inherits(cond, "warning")) {
[17:40:19.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.635]                         if (muffled) 
[17:40:19.635]                           invokeRestart("muffleWarning")
[17:40:19.635]                       }
[17:40:19.635]                       else if (inherits(cond, "condition")) {
[17:40:19.635]                         if (!is.null(pattern)) {
[17:40:19.635]                           computeRestarts <- base::computeRestarts
[17:40:19.635]                           grepl <- base::grepl
[17:40:19.635]                           restarts <- computeRestarts(cond)
[17:40:19.635]                           for (restart in restarts) {
[17:40:19.635]                             name <- restart$name
[17:40:19.635]                             if (is.null(name)) 
[17:40:19.635]                               next
[17:40:19.635]                             if (!grepl(pattern, name)) 
[17:40:19.635]                               next
[17:40:19.635]                             invokeRestart(restart)
[17:40:19.635]                             muffled <- TRUE
[17:40:19.635]                             break
[17:40:19.635]                           }
[17:40:19.635]                         }
[17:40:19.635]                       }
[17:40:19.635]                       invisible(muffled)
[17:40:19.635]                     }
[17:40:19.635]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.635]                   }
[17:40:19.635]                 }
[17:40:19.635]                 else {
[17:40:19.635]                   if (TRUE) {
[17:40:19.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.635]                     {
[17:40:19.635]                       inherits <- base::inherits
[17:40:19.635]                       invokeRestart <- base::invokeRestart
[17:40:19.635]                       is.null <- base::is.null
[17:40:19.635]                       muffled <- FALSE
[17:40:19.635]                       if (inherits(cond, "message")) {
[17:40:19.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.635]                         if (muffled) 
[17:40:19.635]                           invokeRestart("muffleMessage")
[17:40:19.635]                       }
[17:40:19.635]                       else if (inherits(cond, "warning")) {
[17:40:19.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.635]                         if (muffled) 
[17:40:19.635]                           invokeRestart("muffleWarning")
[17:40:19.635]                       }
[17:40:19.635]                       else if (inherits(cond, "condition")) {
[17:40:19.635]                         if (!is.null(pattern)) {
[17:40:19.635]                           computeRestarts <- base::computeRestarts
[17:40:19.635]                           grepl <- base::grepl
[17:40:19.635]                           restarts <- computeRestarts(cond)
[17:40:19.635]                           for (restart in restarts) {
[17:40:19.635]                             name <- restart$name
[17:40:19.635]                             if (is.null(name)) 
[17:40:19.635]                               next
[17:40:19.635]                             if (!grepl(pattern, name)) 
[17:40:19.635]                               next
[17:40:19.635]                             invokeRestart(restart)
[17:40:19.635]                             muffled <- TRUE
[17:40:19.635]                             break
[17:40:19.635]                           }
[17:40:19.635]                         }
[17:40:19.635]                       }
[17:40:19.635]                       invisible(muffled)
[17:40:19.635]                     }
[17:40:19.635]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.635]                   }
[17:40:19.635]                 }
[17:40:19.635]             }
[17:40:19.635]         }))
[17:40:19.635]     }, error = function(ex) {
[17:40:19.635]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.635]                 ...future.rng), started = ...future.startTime, 
[17:40:19.635]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.635]             version = "1.8"), class = "FutureResult")
[17:40:19.635]     }, finally = {
[17:40:19.635]         if (!identical(...future.workdir, getwd())) 
[17:40:19.635]             setwd(...future.workdir)
[17:40:19.635]         {
[17:40:19.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.635]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.635]             }
[17:40:19.635]             base::options(...future.oldOptions)
[17:40:19.635]             if (.Platform$OS.type == "windows") {
[17:40:19.635]                 old_names <- names(...future.oldEnvVars)
[17:40:19.635]                 envs <- base::Sys.getenv()
[17:40:19.635]                 names <- names(envs)
[17:40:19.635]                 common <- intersect(names, old_names)
[17:40:19.635]                 added <- setdiff(names, old_names)
[17:40:19.635]                 removed <- setdiff(old_names, names)
[17:40:19.635]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.635]                   envs[common]]
[17:40:19.635]                 NAMES <- toupper(changed)
[17:40:19.635]                 args <- list()
[17:40:19.635]                 for (kk in seq_along(NAMES)) {
[17:40:19.635]                   name <- changed[[kk]]
[17:40:19.635]                   NAME <- NAMES[[kk]]
[17:40:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.635]                     next
[17:40:19.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.635]                 }
[17:40:19.635]                 NAMES <- toupper(added)
[17:40:19.635]                 for (kk in seq_along(NAMES)) {
[17:40:19.635]                   name <- added[[kk]]
[17:40:19.635]                   NAME <- NAMES[[kk]]
[17:40:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.635]                     next
[17:40:19.635]                   args[[name]] <- ""
[17:40:19.635]                 }
[17:40:19.635]                 NAMES <- toupper(removed)
[17:40:19.635]                 for (kk in seq_along(NAMES)) {
[17:40:19.635]                   name <- removed[[kk]]
[17:40:19.635]                   NAME <- NAMES[[kk]]
[17:40:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.635]                     next
[17:40:19.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.635]                 }
[17:40:19.635]                 if (length(args) > 0) 
[17:40:19.635]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.635]             }
[17:40:19.635]             else {
[17:40:19.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.635]             }
[17:40:19.635]             {
[17:40:19.635]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.635]                   0L) {
[17:40:19.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.635]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.635]                   base::options(opts)
[17:40:19.635]                 }
[17:40:19.635]                 {
[17:40:19.635]                   {
[17:40:19.635]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:19.635]                     NULL
[17:40:19.635]                   }
[17:40:19.635]                   options(future.plan = NULL)
[17:40:19.635]                   if (is.na(NA_character_)) 
[17:40:19.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.635]                     .init = FALSE)
[17:40:19.635]                 }
[17:40:19.635]             }
[17:40:19.635]         }
[17:40:19.635]     })
[17:40:19.635]     if (TRUE) {
[17:40:19.635]         base::sink(type = "output", split = FALSE)
[17:40:19.635]         if (TRUE) {
[17:40:19.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.635]         }
[17:40:19.635]         else {
[17:40:19.635]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.635]         }
[17:40:19.635]         base::close(...future.stdout)
[17:40:19.635]         ...future.stdout <- NULL
[17:40:19.635]     }
[17:40:19.635]     ...future.result$conditions <- ...future.conditions
[17:40:19.635]     ...future.result$finished <- base::Sys.time()
[17:40:19.635]     ...future.result
[17:40:19.635] }
[17:40:19.667]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.637] assign_globals() ...
[17:40:19.667]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.637] List of 1
[17:40:19.637]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:19.637]   ..$ a: int [1:3] 1 2 3
[17:40:19.637]   ..$ b: int [1:3] 3 2 1
[17:40:19.637]  - attr(*, "where")=List of 1
[17:40:19.637]   ..$ data:<environment: R_EmptyEnv> 
[17:40:19.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.637]  - attr(*, "resolved")= logi FALSE
[17:40:19.637]  - attr(*, "total_size")= num 128
[17:40:19.637]  - attr(*, "already-done")= logi TRUE
[17:40:19.667]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.640] - copied ‘data’ to environment
[17:40:19.668]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.640] assign_globals() ... done
[17:40:19.668]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.640] requestCore(): workers = 2
[17:40:19.668]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.642] MulticoreFuture started
[17:40:19.668]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.643] - Launch lazy future ... done
[17:40:19.668]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.643] run() for ‘MulticoreFuture’ ... done
[17:40:19.669]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.644] result() for MulticoreFuture ...
[17:40:19.669]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.653] result() for MulticoreFuture ...
[17:40:19.669]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.653] result() for MulticoreFuture ... done
[17:40:19.669]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.653] result() for MulticoreFuture ... done
[17:40:19.669]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.653] result() for MulticoreFuture ...
[17:40:19.669]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.653] result() for MulticoreFuture ... done
[17:40:19.669] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[17:40:19.670] plan(): Setting new future strategy stack:
[17:40:19.670] List of future strategies:
[17:40:19.670] 1. sequential:
[17:40:19.670]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:19.670]    - tweaked: FALSE
[17:40:19.670]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.670] 2. multisession:
[17:40:19.670]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:19.670]    - tweaked: FALSE
[17:40:19.670]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.671] plan(): nbrOfWorkers() = 1
[17:40:19.671] getGlobalsAndPackages() ...
[17:40:19.671] Searching for globals...
[17:40:19.689] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:19.689] Searching for globals ... DONE
[17:40:19.689] Resolving globals: FALSE
[17:40:19.690] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[17:40:19.691] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:19.691] - globals: [2] ‘nested’, ‘strategy2’
[17:40:19.691] - packages: [1] ‘future’
[17:40:19.691] getGlobalsAndPackages() ... DONE
[17:40:19.691] run() for ‘Future’ ...
[17:40:19.691] - state: ‘created’
[17:40:19.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:19.692] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:19.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:19.692]   - Field: ‘label’
[17:40:19.692]   - Field: ‘local’
[17:40:19.692]   - Field: ‘owner’
[17:40:19.692]   - Field: ‘envir’
[17:40:19.693]   - Field: ‘packages’
[17:40:19.693]   - Field: ‘gc’
[17:40:19.693]   - Field: ‘conditions’
[17:40:19.693]   - Field: ‘expr’
[17:40:19.693]   - Field: ‘uuid’
[17:40:19.693]   - Field: ‘seed’
[17:40:19.693]   - Field: ‘version’
[17:40:19.693]   - Field: ‘result’
[17:40:19.693]   - Field: ‘asynchronous’
[17:40:19.693]   - Field: ‘calls’
[17:40:19.693]   - Field: ‘globals’
[17:40:19.694]   - Field: ‘stdout’
[17:40:19.694]   - Field: ‘earlySignal’
[17:40:19.694]   - Field: ‘lazy’
[17:40:19.694]   - Field: ‘state’
[17:40:19.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:19.694] - Launch lazy future ...
[17:40:19.694] Packages needed by the future expression (n = 1): ‘future’
[17:40:19.694] Packages needed by future strategies (n = 1): ‘future’
[17:40:19.695] {
[17:40:19.695]     {
[17:40:19.695]         {
[17:40:19.695]             ...future.startTime <- base::Sys.time()
[17:40:19.695]             {
[17:40:19.695]                 {
[17:40:19.695]                   {
[17:40:19.695]                     {
[17:40:19.695]                       base::local({
[17:40:19.695]                         has_future <- base::requireNamespace("future", 
[17:40:19.695]                           quietly = TRUE)
[17:40:19.695]                         if (has_future) {
[17:40:19.695]                           ns <- base::getNamespace("future")
[17:40:19.695]                           version <- ns[[".package"]][["version"]]
[17:40:19.695]                           if (is.null(version)) 
[17:40:19.695]                             version <- utils::packageVersion("future")
[17:40:19.695]                         }
[17:40:19.695]                         else {
[17:40:19.695]                           version <- NULL
[17:40:19.695]                         }
[17:40:19.695]                         if (!has_future || version < "1.8.0") {
[17:40:19.695]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:19.695]                             "", base::R.version$version.string), 
[17:40:19.695]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:19.695]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:19.695]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:19.695]                               "release", "version")], collapse = " "), 
[17:40:19.695]                             hostname = base::Sys.info()[["nodename"]])
[17:40:19.695]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:19.695]                             info)
[17:40:19.695]                           info <- base::paste(info, collapse = "; ")
[17:40:19.695]                           if (!has_future) {
[17:40:19.695]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:19.695]                               info)
[17:40:19.695]                           }
[17:40:19.695]                           else {
[17:40:19.695]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:19.695]                               info, version)
[17:40:19.695]                           }
[17:40:19.695]                           base::stop(msg)
[17:40:19.695]                         }
[17:40:19.695]                       })
[17:40:19.695]                     }
[17:40:19.695]                     base::local({
[17:40:19.695]                       for (pkg in "future") {
[17:40:19.695]                         base::loadNamespace(pkg)
[17:40:19.695]                         base::library(pkg, character.only = TRUE)
[17:40:19.695]                       }
[17:40:19.695]                     })
[17:40:19.695]                   }
[17:40:19.695]                   ...future.strategy.old <- future::plan("list")
[17:40:19.695]                   options(future.plan = NULL)
[17:40:19.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.695]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:19.695]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:19.695]                     envir = parent.frame()) 
[17:40:19.695]                   {
[17:40:19.695]                     if (is.function(workers)) 
[17:40:19.695]                       workers <- workers()
[17:40:19.695]                     workers <- structure(as.integer(workers), 
[17:40:19.695]                       class = class(workers))
[17:40:19.695]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:19.695]                       workers >= 1)
[17:40:19.695]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:19.695]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:19.695]                     }
[17:40:19.695]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:19.695]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:19.695]                       envir = envir)
[17:40:19.695]                     if (!future$lazy) 
[17:40:19.695]                       future <- run(future)
[17:40:19.695]                     invisible(future)
[17:40:19.695]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:19.695]                 }
[17:40:19.695]                 ...future.workdir <- getwd()
[17:40:19.695]             }
[17:40:19.695]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:19.695]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:19.695]         }
[17:40:19.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:19.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:19.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:19.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:19.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:19.695]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:19.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:19.695]             base::names(...future.oldOptions))
[17:40:19.695]     }
[17:40:19.695]     if (FALSE) {
[17:40:19.695]     }
[17:40:19.695]     else {
[17:40:19.695]         if (TRUE) {
[17:40:19.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:19.695]                 open = "w")
[17:40:19.695]         }
[17:40:19.695]         else {
[17:40:19.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:19.695]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:19.695]         }
[17:40:19.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:19.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:19.695]             base::sink(type = "output", split = FALSE)
[17:40:19.695]             base::close(...future.stdout)
[17:40:19.695]         }, add = TRUE)
[17:40:19.695]     }
[17:40:19.695]     ...future.frame <- base::sys.nframe()
[17:40:19.695]     ...future.conditions <- base::list()
[17:40:19.695]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:19.695]     if (FALSE) {
[17:40:19.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:19.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:19.695]     }
[17:40:19.695]     ...future.result <- base::tryCatch({
[17:40:19.695]         base::withCallingHandlers({
[17:40:19.695]             ...future.value <- base::withVisible(base::local({
[17:40:19.695]                 a <- 1L
[17:40:19.695]                 plan_a <- unclass(future::plan("list"))
[17:40:19.695]                 nested_a <- nested[-1]
[17:40:19.695]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:19.695]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.695]                   strategy2))
[17:40:19.695]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:19.695]                   "init") <- NULL
[17:40:19.695]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:19.695]                   "init") <- NULL
[17:40:19.695]                 stopifnot(all.equal(plan_a, nested_a))
[17:40:19.695]                 y %<-% {
[17:40:19.695]                   b <- 2L
[17:40:19.695]                   plan_b <- future::plan("list")
[17:40:19.695]                   nested_b <- nested_a[-1]
[17:40:19.695]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:19.695]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:19.695]                     "sequential"))
[17:40:19.695]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:19.695]                     b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:19.695]                 }
[17:40:19.695]                 y
[17:40:19.695]             }))
[17:40:19.695]             future::FutureResult(value = ...future.value$value, 
[17:40:19.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.695]                   ...future.rng), globalenv = if (FALSE) 
[17:40:19.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:19.695]                     ...future.globalenv.names))
[17:40:19.695]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:19.695]         }, condition = base::local({
[17:40:19.695]             c <- base::c
[17:40:19.695]             inherits <- base::inherits
[17:40:19.695]             invokeRestart <- base::invokeRestart
[17:40:19.695]             length <- base::length
[17:40:19.695]             list <- base::list
[17:40:19.695]             seq.int <- base::seq.int
[17:40:19.695]             signalCondition <- base::signalCondition
[17:40:19.695]             sys.calls <- base::sys.calls
[17:40:19.695]             `[[` <- base::`[[`
[17:40:19.695]             `+` <- base::`+`
[17:40:19.695]             `<<-` <- base::`<<-`
[17:40:19.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:19.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:19.695]                   3L)]
[17:40:19.695]             }
[17:40:19.695]             function(cond) {
[17:40:19.695]                 is_error <- inherits(cond, "error")
[17:40:19.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:19.695]                   NULL)
[17:40:19.695]                 if (is_error) {
[17:40:19.695]                   sessionInformation <- function() {
[17:40:19.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:19.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:19.695]                       search = base::search(), system = base::Sys.info())
[17:40:19.695]                   }
[17:40:19.695]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:19.695]                     cond$call), session = sessionInformation(), 
[17:40:19.695]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:19.695]                   signalCondition(cond)
[17:40:19.695]                 }
[17:40:19.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:19.695]                 "immediateCondition"))) {
[17:40:19.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:19.695]                   ...future.conditions[[length(...future.conditions) + 
[17:40:19.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:19.695]                   if (TRUE && !signal) {
[17:40:19.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.695]                     {
[17:40:19.695]                       inherits <- base::inherits
[17:40:19.695]                       invokeRestart <- base::invokeRestart
[17:40:19.695]                       is.null <- base::is.null
[17:40:19.695]                       muffled <- FALSE
[17:40:19.695]                       if (inherits(cond, "message")) {
[17:40:19.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.695]                         if (muffled) 
[17:40:19.695]                           invokeRestart("muffleMessage")
[17:40:19.695]                       }
[17:40:19.695]                       else if (inherits(cond, "warning")) {
[17:40:19.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.695]                         if (muffled) 
[17:40:19.695]                           invokeRestart("muffleWarning")
[17:40:19.695]                       }
[17:40:19.695]                       else if (inherits(cond, "condition")) {
[17:40:19.695]                         if (!is.null(pattern)) {
[17:40:19.695]                           computeRestarts <- base::computeRestarts
[17:40:19.695]                           grepl <- base::grepl
[17:40:19.695]                           restarts <- computeRestarts(cond)
[17:40:19.695]                           for (restart in restarts) {
[17:40:19.695]                             name <- restart$name
[17:40:19.695]                             if (is.null(name)) 
[17:40:19.695]                               next
[17:40:19.695]                             if (!grepl(pattern, name)) 
[17:40:19.695]                               next
[17:40:19.695]                             invokeRestart(restart)
[17:40:19.695]                             muffled <- TRUE
[17:40:19.695]                             break
[17:40:19.695]                           }
[17:40:19.695]                         }
[17:40:19.695]                       }
[17:40:19.695]                       invisible(muffled)
[17:40:19.695]                     }
[17:40:19.695]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.695]                   }
[17:40:19.695]                 }
[17:40:19.695]                 else {
[17:40:19.695]                   if (TRUE) {
[17:40:19.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:19.695]                     {
[17:40:19.695]                       inherits <- base::inherits
[17:40:19.695]                       invokeRestart <- base::invokeRestart
[17:40:19.695]                       is.null <- base::is.null
[17:40:19.695]                       muffled <- FALSE
[17:40:19.695]                       if (inherits(cond, "message")) {
[17:40:19.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:19.695]                         if (muffled) 
[17:40:19.695]                           invokeRestart("muffleMessage")
[17:40:19.695]                       }
[17:40:19.695]                       else if (inherits(cond, "warning")) {
[17:40:19.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:19.695]                         if (muffled) 
[17:40:19.695]                           invokeRestart("muffleWarning")
[17:40:19.695]                       }
[17:40:19.695]                       else if (inherits(cond, "condition")) {
[17:40:19.695]                         if (!is.null(pattern)) {
[17:40:19.695]                           computeRestarts <- base::computeRestarts
[17:40:19.695]                           grepl <- base::grepl
[17:40:19.695]                           restarts <- computeRestarts(cond)
[17:40:19.695]                           for (restart in restarts) {
[17:40:19.695]                             name <- restart$name
[17:40:19.695]                             if (is.null(name)) 
[17:40:19.695]                               next
[17:40:19.695]                             if (!grepl(pattern, name)) 
[17:40:19.695]                               next
[17:40:19.695]                             invokeRestart(restart)
[17:40:19.695]                             muffled <- TRUE
[17:40:19.695]                             break
[17:40:19.695]                           }
[17:40:19.695]                         }
[17:40:19.695]                       }
[17:40:19.695]                       invisible(muffled)
[17:40:19.695]                     }
[17:40:19.695]                     muffleCondition(cond, pattern = "^muffle")
[17:40:19.695]                   }
[17:40:19.695]                 }
[17:40:19.695]             }
[17:40:19.695]         }))
[17:40:19.695]     }, error = function(ex) {
[17:40:19.695]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:19.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:19.695]                 ...future.rng), started = ...future.startTime, 
[17:40:19.695]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:19.695]             version = "1.8"), class = "FutureResult")
[17:40:19.695]     }, finally = {
[17:40:19.695]         if (!identical(...future.workdir, getwd())) 
[17:40:19.695]             setwd(...future.workdir)
[17:40:19.695]         {
[17:40:19.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:19.695]                 ...future.oldOptions$nwarnings <- NULL
[17:40:19.695]             }
[17:40:19.695]             base::options(...future.oldOptions)
[17:40:19.695]             if (.Platform$OS.type == "windows") {
[17:40:19.695]                 old_names <- names(...future.oldEnvVars)
[17:40:19.695]                 envs <- base::Sys.getenv()
[17:40:19.695]                 names <- names(envs)
[17:40:19.695]                 common <- intersect(names, old_names)
[17:40:19.695]                 added <- setdiff(names, old_names)
[17:40:19.695]                 removed <- setdiff(old_names, names)
[17:40:19.695]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:19.695]                   envs[common]]
[17:40:19.695]                 NAMES <- toupper(changed)
[17:40:19.695]                 args <- list()
[17:40:19.695]                 for (kk in seq_along(NAMES)) {
[17:40:19.695]                   name <- changed[[kk]]
[17:40:19.695]                   NAME <- NAMES[[kk]]
[17:40:19.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.695]                     next
[17:40:19.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.695]                 }
[17:40:19.695]                 NAMES <- toupper(added)
[17:40:19.695]                 for (kk in seq_along(NAMES)) {
[17:40:19.695]                   name <- added[[kk]]
[17:40:19.695]                   NAME <- NAMES[[kk]]
[17:40:19.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.695]                     next
[17:40:19.695]                   args[[name]] <- ""
[17:40:19.695]                 }
[17:40:19.695]                 NAMES <- toupper(removed)
[17:40:19.695]                 for (kk in seq_along(NAMES)) {
[17:40:19.695]                   name <- removed[[kk]]
[17:40:19.695]                   NAME <- NAMES[[kk]]
[17:40:19.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:19.695]                     next
[17:40:19.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:19.695]                 }
[17:40:19.695]                 if (length(args) > 0) 
[17:40:19.695]                   base::do.call(base::Sys.setenv, args = args)
[17:40:19.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:19.695]             }
[17:40:19.695]             else {
[17:40:19.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:19.695]             }
[17:40:19.695]             {
[17:40:19.695]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:19.695]                   0L) {
[17:40:19.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:19.695]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:19.695]                   base::options(opts)
[17:40:19.695]                 }
[17:40:19.695]                 {
[17:40:19.695]                   {
[17:40:19.695]                     NULL
[17:40:19.695]                     RNGkind("Mersenne-Twister")
[17:40:19.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:19.695]                       inherits = FALSE)
[17:40:19.695]                   }
[17:40:19.695]                   options(future.plan = NULL)
[17:40:19.695]                   if (is.na(NA_character_)) 
[17:40:19.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:19.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:19.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:19.695]                     .init = FALSE)
[17:40:19.695]                 }
[17:40:19.695]             }
[17:40:19.695]         }
[17:40:19.695]     })
[17:40:19.695]     if (TRUE) {
[17:40:19.695]         base::sink(type = "output", split = FALSE)
[17:40:19.695]         if (TRUE) {
[17:40:19.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:19.695]         }
[17:40:19.695]         else {
[17:40:19.695]             ...future.result["stdout"] <- base::list(NULL)
[17:40:19.695]         }
[17:40:19.695]         base::close(...future.stdout)
[17:40:19.695]         ...future.stdout <- NULL
[17:40:19.695]     }
[17:40:19.695]     ...future.result$conditions <- ...future.conditions
[17:40:19.695]     ...future.result$finished <- base::Sys.time()
[17:40:19.695]     ...future.result
[17:40:19.695] }
[17:40:19.697] assign_globals() ...
[17:40:19.697] List of 2
[17:40:19.697]  $ nested   :List of 2
[17:40:19.697]   ..$ a:function (..., envir = parent.frame())  
[17:40:19.697]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:19.697]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.697]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:19.697]     envir = parent.frame())  
[17:40:19.697]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:40:19.697]   .. ..- attr(*, "init")= logi TRUE
[17:40:19.697]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:40:19.697]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:19.697]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:19.697]  $ strategy2: chr "multisession"
[17:40:19.697]  - attr(*, "where")=List of 2
[17:40:19.697]   ..$ nested   :<environment: R_EmptyEnv> 
[17:40:19.697]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:40:19.697]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:19.697]  - attr(*, "resolved")= logi FALSE
[17:40:19.697]  - attr(*, "total_size")= num 56736
[17:40:19.697]  - attr(*, "already-done")= logi TRUE
[17:40:19.702] - copied ‘nested’ to environment
[17:40:19.702] - copied ‘strategy2’ to environment
[17:40:19.702] assign_globals() ... done
[17:40:19.702] plan(): Setting new future strategy stack:
[17:40:19.702] List of future strategies:
[17:40:19.702] 1. multisession:
[17:40:19.702]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:19.702]    - tweaked: FALSE
[17:40:19.702]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:19.706] plan(): nbrOfWorkers() = 2
[17:40:20.448] plan(): Setting new future strategy stack:
[17:40:20.448] List of future strategies:
[17:40:20.448] 1. sequential:
[17:40:20.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.448]    - tweaked: FALSE
[17:40:20.448]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.448] 2. multisession:
[17:40:20.448]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:20.448]    - tweaked: FALSE
[17:40:20.448]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.449] plan(): nbrOfWorkers() = 1
[17:40:20.449] SequentialFuture started (and completed)
[17:40:20.449] signalConditions() ...
[17:40:20.449]  - include = ‘immediateCondition’
[17:40:20.449]  - exclude = 
[17:40:20.450]  - resignal = FALSE
[17:40:20.450]  - Number of conditions: 98
[17:40:20.450] signalConditions() ... done
[17:40:20.450] - Launch lazy future ... done
[17:40:20.450] run() for ‘SequentialFuture’ ... done
[17:40:20.450] signalConditions() ...
[17:40:20.450]  - include = ‘immediateCondition’
[17:40:20.451]  - exclude = 
[17:40:20.451]  - resignal = FALSE
[17:40:20.451]  - Number of conditions: 98
[17:40:20.451] signalConditions() ... done
[17:40:20.451] Future state: ‘finished’
[17:40:20.451] signalConditions() ...
[17:40:20.451]  - include = ‘condition’
[17:40:20.452]  - exclude = ‘immediateCondition’
[17:40:20.452]  - resignal = TRUE
[17:40:20.452]  - Number of conditions: 98
[17:40:20.452]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.709] getGlobalsAndPackages() ...
[17:40:20.452]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.709] Searching for globals...
[17:40:20.452]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.728] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:40:20.452]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.728] Searching for globals ... DONE
[17:40:20.453]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.728] Resolving globals: FALSE
[17:40:20.453]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.729] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[17:40:20.453]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.730] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:40:20.453]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.730] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:40:20.453]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.730] 
[17:40:20.453]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.730] getGlobalsAndPackages() ... DONE
[17:40:20.454]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.730] run() for ‘Future’ ...
[17:40:20.454]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.730] - state: ‘created’
[17:40:20.454]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.454]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.739] [local output] makeClusterPSOCK() ...
[17:40:20.454]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.796] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:20.454]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.797] [local output] Base port: 11311
[17:40:20.455]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.797] [local output] Getting setup options for 2 cluster nodes ...
[17:40:20.455]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.798] [local output]  - Node 1 of 2 ...
[17:40:20.455]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.798] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:20.455]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.799] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b919450fb568.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b919450fb568.pid")'’
[17:40:20.455]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.986] - Possible to infer worker's PID: TRUE
[17:40:20.455]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.986] [local output] Rscript port: 11311

[17:40:20.456]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.987] [local output]  - Node 2 of 2 ...
[17:40:20.456]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.987] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:20.456]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.988] [local output] Rscript port: 11311

[17:40:20.456]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.988] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:20.456]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.988] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:20.456]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.989] [local output] Setting up PSOCK nodes in parallel
[17:40:20.457]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:19.989] List of 36
[17:40:19.989]  $ worker          : chr "localhost"
[17:40:19.989]   ..- attr(*, "localhost")= logi TRUE
[17:40:19.989]  $ master          : chr "localhost"
[17:40:19.989]  $ port            : int 11311
[17:40:19.989]  $ connectTimeout  : num 120
[17:40:19.989]  $ timeout         : num 2592000
[17:40:19.989]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:19.989]  $ homogeneous     : logi TRUE
[17:40:19.989]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:19.989]  $ rscript_envs    : NULL
[17:40:19.989]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:19.989]  $ rscript_startup : NULL
[17:40:19.989]  $ rscript_sh      : chr "sh"
[17:40:19.989]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:19.989]  $ methods         : logi TRUE
[17:40:19.989]  $ socketOptions   : chr "no-delay"
[17:40:19.989]  $ useXDR          : logi FALSE
[17:40:19.989]  $ outfile         : chr "/dev/null"
[17:40:19.989]  $ renice          : int NA
[17:40:19.989]  $ rshcmd          : NULL
[17:40:19.989]  $ user            : chr(0) 
[17:40:19.989]  $ revtunnel       : logi FALSE
[17:40:19.989]  $ rshlogfile      : NULL
[17:40:19.989]  $ rshopts         : chr(0) 
[17:40:19.989]  $ rank            : int 1
[17:40:19.989]  $ manual          : logi FALSE
[17:40:19.989]  $ dryrun          : logi FALSE
[17:40:19.989]  $ quiet           : logi FALSE
[17:40:19.989]  $ setup_strategy  : chr "parallel"
[17:40:19.989]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:19.989]  $ pidfile         : chr "/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b919450fb568.pid"
[17:40:19.989]  $ rshcmd_label    : NULL
[17:40:19.989]  $ rsh_call        : NULL
[17:40:19.989]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:19.989]  $ localMachine    : logi TRUE
[17:40:19.989]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:19.989]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:19.989]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:19.989]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:19.989]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:19.989]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:19.989]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:19.989]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:19.989]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:19.989]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:19.989]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:19.989]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:19.989]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:19.989]  $ arguments       :List of 28
[17:40:19.989]   ..$ worker          : chr "localhost"
[17:40:19.989]   ..$ master          : NULL
[17:40:19.989]   ..$ port            : int 11311
[17:40:19.989]   ..$ connectTimeout  : num 120
[17:40:19.989]   ..$ timeout         : num 2592000
[17:40:19.989]   ..$ rscript         : NULL
[17:40:19.989]   ..$ homogeneous     : NULL
[17:40:19.989]   ..$ rscript_args    : NULL
[17:40:19.989]   ..$ rscript_envs    : NULL
[17:40:19.989]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:19.989]   ..$ rscript_startup : NULL
[17:40:19.989]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:19.989]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:19.989]   ..$ methods         : logi TRUE
[17:40:19.989]   ..$ socketOptions   : chr "no-delay"
[17:40:19.989]   ..$ useXDR          : logi FALSE
[17:40:19.989]   ..$ outfile         : chr "/dev/null"
[17:40:19.989]   ..$ renice          : int NA
[17:40:19.989]   ..$ rshcmd          : NULL
[17:40:19.989]   ..$ user            : NULL
[17:40:19.989]   ..$ revtunnel       : logi NA
[17:40:19.989]   ..$ rshlogfile      : NULL
[17:40:19.989]   ..$ rshopts         : NULL
[17:40:19.989]   ..$ rank            : int 1
[17:40:19.989]   ..$ manual          : logi FALSE
[17:40:19.989]   ..$ dryrun          : logi FALSE
[17:40:19.989]   ..$ quiet           : logi FALSE
[17:40:19.989]   ..$ setup_strategy  : chr "parallel"
[17:40:19.989]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:20.457]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.005] [local output] System call to launch all workers:
[17:40:20.457]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.005] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b919450fb568.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11311 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:20.457]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.005] [local output] Starting PSOCK main server
[17:40:20.457]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.011] [local output] Workers launched
[17:40:20.457]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.011] [local output] Waiting for workers to connect back
[17:40:20.457]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.012]  - [local output] 0 workers out of 2 ready
[17:40:20.458]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.251]  - [local output] 0 workers out of 2 ready
[17:40:20.458]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.252]  - [local output] 1 workers out of 2 ready
[17:40:20.458]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.256]  - [local output] 1 workers out of 2 ready
[17:40:20.458]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.257]  - [local output] 2 workers out of 2 ready
[17:40:20.458]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.257] [local output] Launching of workers completed
[17:40:20.458]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.257] [local output] Collecting session information from workers
[17:40:20.459]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.258] [local output]  - Worker #1 of 2
[17:40:20.459]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.258] [local output]  - Worker #2 of 2
[17:40:20.459]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.259] [local output] makeClusterPSOCK() ... done
[17:40:20.459]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.459]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:20.459]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘node’
[17:40:20.460]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘label’
[17:40:20.460]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘local’
[17:40:20.460]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘owner’
[17:40:20.460]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘envir’
[17:40:20.460]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘workers’
[17:40:20.460]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘packages’
[17:40:20.461]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘gc’
[17:40:20.461]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.270]   - Field: ‘conditions’
[17:40:20.461]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘persistent’
[17:40:20.461]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘expr’
[17:40:20.461]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘uuid’
[17:40:20.461]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘seed’
[17:40:20.462]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘version’
[17:40:20.462]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘result’
[17:40:20.462]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘asynchronous’
[17:40:20.462]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.271]   - Field: ‘calls’
[17:40:20.462]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272]   - Field: ‘globals’
[17:40:20.462]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272]   - Field: ‘stdout’
[17:40:20.463]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272]   - Field: ‘earlySignal’
[17:40:20.463]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272]   - Field: ‘lazy’
[17:40:20.463]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272]   - Field: ‘state’
[17:40:20.463]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:20.463]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.272] - Launch lazy future ...
[17:40:20.463]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.273] Packages needed by the future expression (n = 0): <none>
[17:40:20.463]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.273] Packages needed by future strategies (n = 0): <none>
[17:40:20.464]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.274] {
[17:40:20.274]     {
[17:40:20.274]         {
[17:40:20.274]             ...future.startTime <- base::Sys.time()
[17:40:20.274]             {
[17:40:20.274]                 {
[17:40:20.274]                   {
[17:40:20.274]                     {
[17:40:20.274]                       base::local({
[17:40:20.274]                         has_future <- base::requireNamespace("future", 
[17:40:20.274]                           quietly = TRUE)
[17:40:20.274]                         if (has_future) {
[17:40:20.274]                           ns <- base::getNamespace("future")
[17:40:20.274]                           version <- ns[[".package"]][["version"]]
[17:40:20.274]                           if (is.null(version)) 
[17:40:20.274]                             version <- utils::packageVersion("future")
[17:40:20.274]                         }
[17:40:20.274]                         else {
[17:40:20.274]                           version <- NULL
[17:40:20.274]                         }
[17:40:20.274]                         if (!has_future || version < "1.8.0") {
[17:40:20.274]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.274]                             "", base::R.version$version.string), 
[17:40:20.274]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:20.274]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.274]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.274]                               "release", "version")], collapse = " "), 
[17:40:20.274]                             hostname = base::Sys.info()[["nodename"]])
[17:40:20.274]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.274]                             info)
[17:40:20.274]                           info <- base::paste(info, collapse = "; ")
[17:40:20.274]                           if (!has_future) {
[17:40:20.274]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.274]                               info)
[17:40:20.274]                           }
[17:40:20.274]                           else {
[17:40:20.274]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.274]                               info, version)
[17:40:20.274]                           }
[17:40:20.274]                           base::stop(msg)
[17:40:20.274]                         }
[17:40:20.274]                       })
[17:40:20.274]                     }
[17:40:20.274]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.274]                     base::options(mc.cores = 1L)
[17:40:20.274]                   }
[17:40:20.274]                   ...future.strategy.old <- future::plan("list")
[17:40:20.274]                   options(future.plan = NULL)
[17:40:20.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:20.274]                 }
[17:40:20.274]                 ...future.workdir <- getwd()
[17:40:20.274]             }
[17:40:20.274]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.274]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.274]         }
[17:40:20.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.274]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.274]             base::names(...future.oldOptions))
[17:40:20.274]     }
[17:40:20.274]     if (FALSE) {
[17:40:20.274]     }
[17:40:20.274]     else {
[17:40:20.274]         if (TRUE) {
[17:40:20.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.274]                 open = "w")
[17:40:20.274]         }
[17:40:20.274]         else {
[17:40:20.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.274]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.274]         }
[17:40:20.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.274]             base::sink(type = "output", split = FALSE)
[17:40:20.274]             base::close(...future.stdout)
[17:40:20.274]         }, add = TRUE)
[17:40:20.274]     }
[17:40:20.274]     ...future.frame <- base::sys.nframe()
[17:40:20.274]     ...future.conditions <- base::list()
[17:40:20.274]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.274]     if (FALSE) {
[17:40:20.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.274]     }
[17:40:20.274]     ...future.result <- base::tryCatch({
[17:40:20.274]         base::withCallingHandlers({
[17:40:20.274]             ...future.value <- base::withVisible(base::local({
[17:40:20.274]                 ...future.makeSendCondition <- base::local({
[17:40:20.274]                   sendCondition <- NULL
[17:40:20.274]                   function(frame = 1L) {
[17:40:20.274]                     if (is.function(sendCondition)) 
[17:40:20.274]                       return(sendCondition)
[17:40:20.274]                     ns <- getNamespace("parallel")
[17:40:20.274]                     if (exists("sendData", mode = "function", 
[17:40:20.274]                       envir = ns)) {
[17:40:20.274]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:20.274]                         envir = ns)
[17:40:20.274]                       envir <- sys.frame(frame)
[17:40:20.274]                       master <- NULL
[17:40:20.274]                       while (!identical(envir, .GlobalEnv) && 
[17:40:20.274]                         !identical(envir, emptyenv())) {
[17:40:20.274]                         if (exists("master", mode = "list", envir = envir, 
[17:40:20.274]                           inherits = FALSE)) {
[17:40:20.274]                           master <- get("master", mode = "list", 
[17:40:20.274]                             envir = envir, inherits = FALSE)
[17:40:20.274]                           if (inherits(master, c("SOCKnode", 
[17:40:20.274]                             "SOCK0node"))) {
[17:40:20.274]                             sendCondition <<- function(cond) {
[17:40:20.274]                               data <- list(type = "VALUE", value = cond, 
[17:40:20.274]                                 success = TRUE)
[17:40:20.274]                               parallel_sendData(master, data)
[17:40:20.274]                             }
[17:40:20.274]                             return(sendCondition)
[17:40:20.274]                           }
[17:40:20.274]                         }
[17:40:20.274]                         frame <- frame + 1L
[17:40:20.274]                         envir <- sys.frame(frame)
[17:40:20.274]                       }
[17:40:20.274]                     }
[17:40:20.274]                     sendCondition <<- function(cond) NULL
[17:40:20.274]                   }
[17:40:20.274]                 })
[17:40:20.274]                 withCallingHandlers({
[17:40:20.274]                   {
[17:40:20.274]                     b <- 2L
[17:40:20.274]                     plan_b <- future::plan("list")
[17:40:20.274]                     nested_b <- nested_a[-1]
[17:40:20.274]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:20.274]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:20.274]                       "sequential"))
[17:40:20.274]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:20.274]                       b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:20.274]                   }
[17:40:20.274]                 }, immediateCondition = function(cond) {
[17:40:20.274]                   sendCondition <- ...future.makeSendCondition()
[17:40:20.274]                   sendCondition(cond)
[17:40:20.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.274]                   {
[17:40:20.274]                     inherits <- base::inherits
[17:40:20.274]                     invokeRestart <- base::invokeRestart
[17:40:20.274]                     is.null <- base::is.null
[17:40:20.274]                     muffled <- FALSE
[17:40:20.274]                     if (inherits(cond, "message")) {
[17:40:20.274]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.274]                       if (muffled) 
[17:40:20.274]                         invokeRestart("muffleMessage")
[17:40:20.274]                     }
[17:40:20.274]                     else if (inherits(cond, "warning")) {
[17:40:20.274]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.274]                       if (muffled) 
[17:40:20.274]                         invokeRestart("muffleWarning")
[17:40:20.274]                     }
[17:40:20.274]                     else if (inherits(cond, "condition")) {
[17:40:20.274]                       if (!is.null(pattern)) {
[17:40:20.274]                         computeRestarts <- base::computeRestarts
[17:40:20.274]                         grepl <- base::grepl
[17:40:20.274]                         restarts <- computeRestarts(cond)
[17:40:20.274]                         for (restart in restarts) {
[17:40:20.274]                           name <- restart$name
[17:40:20.274]                           if (is.null(name)) 
[17:40:20.274]                             next
[17:40:20.274]                           if (!grepl(pattern, name)) 
[17:40:20.274]                             next
[17:40:20.274]                           invokeRestart(restart)
[17:40:20.274]                           muffled <- TRUE
[17:40:20.274]                           break
[17:40:20.274]                         }
[17:40:20.274]                       }
[17:40:20.274]                     }
[17:40:20.274]                     invisible(muffled)
[17:40:20.274]                   }
[17:40:20.274]                   muffleCondition(cond)
[17:40:20.274]                 })
[17:40:20.274]             }))
[17:40:20.274]             future::FutureResult(value = ...future.value$value, 
[17:40:20.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.274]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.274]                     ...future.globalenv.names))
[17:40:20.274]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.274]         }, condition = base::local({
[17:40:20.274]             c <- base::c
[17:40:20.274]             inherits <- base::inherits
[17:40:20.274]             invokeRestart <- base::invokeRestart
[17:40:20.274]             length <- base::length
[17:40:20.274]             list <- base::list
[17:40:20.274]             seq.int <- base::seq.int
[17:40:20.274]             signalCondition <- base::signalCondition
[17:40:20.274]             sys.calls <- base::sys.calls
[17:40:20.274]             `[[` <- base::`[[`
[17:40:20.274]             `+` <- base::`+`
[17:40:20.274]             `<<-` <- base::`<<-`
[17:40:20.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.274]                   3L)]
[17:40:20.274]             }
[17:40:20.274]             function(cond) {
[17:40:20.274]                 is_error <- inherits(cond, "error")
[17:40:20.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.274]                   NULL)
[17:40:20.274]                 if (is_error) {
[17:40:20.274]                   sessionInformation <- function() {
[17:40:20.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.274]                       search = base::search(), system = base::Sys.info())
[17:40:20.274]                   }
[17:40:20.274]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.274]                     cond$call), session = sessionInformation(), 
[17:40:20.274]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.274]                   signalCondition(cond)
[17:40:20.274]                 }
[17:40:20.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.274]                 "immediateCondition"))) {
[17:40:20.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.274]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.274]                   if (TRUE && !signal) {
[17:40:20.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.274]                     {
[17:40:20.274]                       inherits <- base::inherits
[17:40:20.274]                       invokeRestart <- base::invokeRestart
[17:40:20.274]                       is.null <- base::is.null
[17:40:20.274]                       muffled <- FALSE
[17:40:20.274]                       if (inherits(cond, "message")) {
[17:40:20.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.274]                         if (muffled) 
[17:40:20.274]                           invokeRestart("muffleMessage")
[17:40:20.274]                       }
[17:40:20.274]                       else if (inherits(cond, "warning")) {
[17:40:20.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.274]                         if (muffled) 
[17:40:20.274]                           invokeRestart("muffleWarning")
[17:40:20.274]                       }
[17:40:20.274]                       else if (inherits(cond, "condition")) {
[17:40:20.274]                         if (!is.null(pattern)) {
[17:40:20.274]                           computeRestarts <- base::computeRestarts
[17:40:20.274]                           grepl <- base::grepl
[17:40:20.274]                           restarts <- computeRestarts(cond)
[17:40:20.274]                           for (restart in restarts) {
[17:40:20.274]                             name <- restart$name
[17:40:20.274]                             if (is.null(name)) 
[17:40:20.274]                               next
[17:40:20.274]                             if (!grepl(pattern, name)) 
[17:40:20.274]                               next
[17:40:20.274]                             invokeRestart(restart)
[17:40:20.274]                             muffled <- TRUE
[17:40:20.274]                             break
[17:40:20.274]                           }
[17:40:20.274]                         }
[17:40:20.274]                       }
[17:40:20.274]                       invisible(muffled)
[17:40:20.274]                     }
[17:40:20.274]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.274]                   }
[17:40:20.274]                 }
[17:40:20.274]                 else {
[17:40:20.274]                   if (TRUE) {
[17:40:20.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.274]                     {
[17:40:20.274]                       inherits <- base::inherits
[17:40:20.274]                       invokeRestart <- base::invokeRestart
[17:40:20.274]                       is.null <- base::is.null
[17:40:20.274]                       muffled <- FALSE
[17:40:20.274]                       if (inherits(cond, "message")) {
[17:40:20.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.274]                         if (muffled) 
[17:40:20.274]                           invokeRestart("muffleMessage")
[17:40:20.274]                       }
[17:40:20.274]                       else if (inherits(cond, "warning")) {
[17:40:20.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.274]                         if (muffled) 
[17:40:20.274]                           invokeRestart("muffleWarning")
[17:40:20.274]                       }
[17:40:20.274]                       else if (inherits(cond, "condition")) {
[17:40:20.274]                         if (!is.null(pattern)) {
[17:40:20.274]                           computeRestarts <- base::computeRestarts
[17:40:20.274]                           grepl <- base::grepl
[17:40:20.274]                           restarts <- computeRestarts(cond)
[17:40:20.274]                           for (restart in restarts) {
[17:40:20.274]                             name <- restart$name
[17:40:20.274]                             if (is.null(name)) 
[17:40:20.274]                               next
[17:40:20.274]                             if (!grepl(pattern, name)) 
[17:40:20.274]                               next
[17:40:20.274]                             invokeRestart(restart)
[17:40:20.274]                             muffled <- TRUE
[17:40:20.274]                             break
[17:40:20.274]                           }
[17:40:20.274]                         }
[17:40:20.274]                       }
[17:40:20.274]                       invisible(muffled)
[17:40:20.274]                     }
[17:40:20.274]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.274]                   }
[17:40:20.274]                 }
[17:40:20.274]             }
[17:40:20.274]         }))
[17:40:20.274]     }, error = function(ex) {
[17:40:20.274]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.274]                 ...future.rng), started = ...future.startTime, 
[17:40:20.274]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.274]             version = "1.8"), class = "FutureResult")
[17:40:20.274]     }, finally = {
[17:40:20.274]         if (!identical(...future.workdir, getwd())) 
[17:40:20.274]             setwd(...future.workdir)
[17:40:20.274]         {
[17:40:20.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.274]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.274]             }
[17:40:20.274]             base::options(...future.oldOptions)
[17:40:20.274]             if (.Platform$OS.type == "windows") {
[17:40:20.274]                 old_names <- names(...future.oldEnvVars)
[17:40:20.274]                 envs <- base::Sys.getenv()
[17:40:20.274]                 names <- names(envs)
[17:40:20.274]                 common <- intersect(names, old_names)
[17:40:20.274]                 added <- setdiff(names, old_names)
[17:40:20.274]                 removed <- setdiff(old_names, names)
[17:40:20.274]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.274]                   envs[common]]
[17:40:20.274]                 NAMES <- toupper(changed)
[17:40:20.274]                 args <- list()
[17:40:20.274]                 for (kk in seq_along(NAMES)) {
[17:40:20.274]                   name <- changed[[kk]]
[17:40:20.274]                   NAME <- NAMES[[kk]]
[17:40:20.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.274]                     next
[17:40:20.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.274]                 }
[17:40:20.274]                 NAMES <- toupper(added)
[17:40:20.274]                 for (kk in seq_along(NAMES)) {
[17:40:20.274]                   name <- added[[kk]]
[17:40:20.274]                   NAME <- NAMES[[kk]]
[17:40:20.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.274]                     next
[17:40:20.274]                   args[[name]] <- ""
[17:40:20.274]                 }
[17:40:20.274]                 NAMES <- toupper(removed)
[17:40:20.274]                 for (kk in seq_along(NAMES)) {
[17:40:20.274]                   name <- removed[[kk]]
[17:40:20.274]                   NAME <- NAMES[[kk]]
[17:40:20.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.274]                     next
[17:40:20.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.274]                 }
[17:40:20.274]                 if (length(args) > 0) 
[17:40:20.274]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.274]             }
[17:40:20.274]             else {
[17:40:20.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.274]             }
[17:40:20.274]             {
[17:40:20.274]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.274]                   0L) {
[17:40:20.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.274]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.274]                   base::options(opts)
[17:40:20.274]                 }
[17:40:20.274]                 {
[17:40:20.274]                   {
[17:40:20.274]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.274]                     NULL
[17:40:20.274]                   }
[17:40:20.274]                   options(future.plan = NULL)
[17:40:20.274]                   if (is.na(NA_character_)) 
[17:40:20.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.274]                     .init = FALSE)
[17:40:20.274]                 }
[17:40:20.274]             }
[17:40:20.274]         }
[17:40:20.274]     })
[17:40:20.274]     if (TRUE) {
[17:40:20.274]         base::sink(type = "output", split = FALSE)
[17:40:20.274]         if (TRUE) {
[17:40:20.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.274]         }
[17:40:20.274]         else {
[17:40:20.274]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.274]         }
[17:40:20.274]         base::close(...future.stdout)
[17:40:20.274]         ...future.stdout <- NULL
[17:40:20.274]     }
[17:40:20.274]     ...future.result$conditions <- ...future.conditions
[17:40:20.274]     ...future.result$finished <- base::Sys.time()
[17:40:20.274]     ...future.result
[17:40:20.274] }
[17:40:20.464]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.325] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[17:40:20.464]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.325] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[17:40:20.464]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.326] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[17:40:20.464]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.326] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:40:20.465]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.326] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:40:20.465]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.326] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[17:40:20.465]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.369] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[17:40:20.465]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.369] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[17:40:20.465]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.370] MultisessionFuture started
[17:40:20.465]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.370] - Launch lazy future ... done
[17:40:20.465]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.370] run() for ‘MultisessionFuture’ ... done
[17:40:20.466]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.370] result() for ClusterFuture ...
[17:40:20.466]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.371] receiveMessageFromWorker() for ClusterFuture ...
[17:40:20.466]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.371] - Validating connection of MultisessionFuture
[17:40:20.466]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.446] - received message: FutureResult
[17:40:20.466]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.446] - Received FutureResult
[17:40:20.466]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.446] - Erased future from FutureRegistry
[17:40:20.467]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.446] result() for ClusterFuture ...
[17:40:20.467]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.446] - result already collected: FutureResult
[17:40:20.467]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.447] result() for ClusterFuture ... done
[17:40:20.467]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.447] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:20.467]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.447] result() for ClusterFuture ... done
[17:40:20.467]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.447] result() for ClusterFuture ...
[17:40:20.468]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.447] - result already collected: FutureResult
[17:40:20.468]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.447] result() for ClusterFuture ... done
[17:40:20.468] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:20.475] getGlobalsAndPackages() ...
[17:40:20.475] Searching for globals...
[17:40:20.476] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:20.477] Searching for globals ... DONE
[17:40:20.477] Resolving globals: FALSE
[17:40:20.477] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:20.478] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:20.478] - globals: [1] ‘data’
[17:40:20.478] - packages: [1] ‘future’
[17:40:20.478] getGlobalsAndPackages() ... DONE
[17:40:20.478] run() for ‘Future’ ...
[17:40:20.479] - state: ‘created’
[17:40:20.479] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:20.479] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:20.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:20.479]   - Field: ‘label’
[17:40:20.480]   - Field: ‘local’
[17:40:20.480]   - Field: ‘owner’
[17:40:20.480]   - Field: ‘envir’
[17:40:20.480]   - Field: ‘packages’
[17:40:20.480]   - Field: ‘gc’
[17:40:20.480]   - Field: ‘conditions’
[17:40:20.480]   - Field: ‘expr’
[17:40:20.480]   - Field: ‘uuid’
[17:40:20.480]   - Field: ‘seed’
[17:40:20.481]   - Field: ‘version’
[17:40:20.481]   - Field: ‘result’
[17:40:20.481]   - Field: ‘asynchronous’
[17:40:20.481]   - Field: ‘calls’
[17:40:20.481]   - Field: ‘globals’
[17:40:20.481]   - Field: ‘stdout’
[17:40:20.481]   - Field: ‘earlySignal’
[17:40:20.481]   - Field: ‘lazy’
[17:40:20.481]   - Field: ‘state’
[17:40:20.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:20.482] - Launch lazy future ...
[17:40:20.482] Packages needed by the future expression (n = 1): ‘future’
[17:40:20.482] Packages needed by future strategies (n = 1): ‘future’
[17:40:20.483] {
[17:40:20.483]     {
[17:40:20.483]         {
[17:40:20.483]             ...future.startTime <- base::Sys.time()
[17:40:20.483]             {
[17:40:20.483]                 {
[17:40:20.483]                   {
[17:40:20.483]                     {
[17:40:20.483]                       base::local({
[17:40:20.483]                         has_future <- base::requireNamespace("future", 
[17:40:20.483]                           quietly = TRUE)
[17:40:20.483]                         if (has_future) {
[17:40:20.483]                           ns <- base::getNamespace("future")
[17:40:20.483]                           version <- ns[[".package"]][["version"]]
[17:40:20.483]                           if (is.null(version)) 
[17:40:20.483]                             version <- utils::packageVersion("future")
[17:40:20.483]                         }
[17:40:20.483]                         else {
[17:40:20.483]                           version <- NULL
[17:40:20.483]                         }
[17:40:20.483]                         if (!has_future || version < "1.8.0") {
[17:40:20.483]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.483]                             "", base::R.version$version.string), 
[17:40:20.483]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:20.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.483]                               "release", "version")], collapse = " "), 
[17:40:20.483]                             hostname = base::Sys.info()[["nodename"]])
[17:40:20.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.483]                             info)
[17:40:20.483]                           info <- base::paste(info, collapse = "; ")
[17:40:20.483]                           if (!has_future) {
[17:40:20.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.483]                               info)
[17:40:20.483]                           }
[17:40:20.483]                           else {
[17:40:20.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.483]                               info, version)
[17:40:20.483]                           }
[17:40:20.483]                           base::stop(msg)
[17:40:20.483]                         }
[17:40:20.483]                       })
[17:40:20.483]                     }
[17:40:20.483]                     base::local({
[17:40:20.483]                       for (pkg in "future") {
[17:40:20.483]                         base::loadNamespace(pkg)
[17:40:20.483]                         base::library(pkg, character.only = TRUE)
[17:40:20.483]                       }
[17:40:20.483]                     })
[17:40:20.483]                   }
[17:40:20.483]                   ...future.strategy.old <- future::plan("list")
[17:40:20.483]                   options(future.plan = NULL)
[17:40:20.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.483]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:20.483]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:20.483]                     envir = parent.frame()) 
[17:40:20.483]                   {
[17:40:20.483]                     if (is.function(workers)) 
[17:40:20.483]                       workers <- workers()
[17:40:20.483]                     workers <- structure(as.integer(workers), 
[17:40:20.483]                       class = class(workers))
[17:40:20.483]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:20.483]                       workers >= 1)
[17:40:20.483]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:20.483]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:20.483]                     }
[17:40:20.483]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:20.483]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:20.483]                       envir = envir)
[17:40:20.483]                     if (!future$lazy) 
[17:40:20.483]                       future <- run(future)
[17:40:20.483]                     invisible(future)
[17:40:20.483]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:20.483]                 }
[17:40:20.483]                 ...future.workdir <- getwd()
[17:40:20.483]             }
[17:40:20.483]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.483]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.483]         }
[17:40:20.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.483]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.483]             base::names(...future.oldOptions))
[17:40:20.483]     }
[17:40:20.483]     if (FALSE) {
[17:40:20.483]     }
[17:40:20.483]     else {
[17:40:20.483]         if (TRUE) {
[17:40:20.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.483]                 open = "w")
[17:40:20.483]         }
[17:40:20.483]         else {
[17:40:20.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.483]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.483]         }
[17:40:20.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.483]             base::sink(type = "output", split = FALSE)
[17:40:20.483]             base::close(...future.stdout)
[17:40:20.483]         }, add = TRUE)
[17:40:20.483]     }
[17:40:20.483]     ...future.frame <- base::sys.nframe()
[17:40:20.483]     ...future.conditions <- base::list()
[17:40:20.483]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.483]     if (FALSE) {
[17:40:20.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.483]     }
[17:40:20.483]     ...future.result <- base::tryCatch({
[17:40:20.483]         base::withCallingHandlers({
[17:40:20.483]             ...future.value <- base::withVisible(base::local({
[17:40:20.483]                 value(future(subset(data, a == 2)))
[17:40:20.483]             }))
[17:40:20.483]             future::FutureResult(value = ...future.value$value, 
[17:40:20.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.483]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.483]                     ...future.globalenv.names))
[17:40:20.483]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.483]         }, condition = base::local({
[17:40:20.483]             c <- base::c
[17:40:20.483]             inherits <- base::inherits
[17:40:20.483]             invokeRestart <- base::invokeRestart
[17:40:20.483]             length <- base::length
[17:40:20.483]             list <- base::list
[17:40:20.483]             seq.int <- base::seq.int
[17:40:20.483]             signalCondition <- base::signalCondition
[17:40:20.483]             sys.calls <- base::sys.calls
[17:40:20.483]             `[[` <- base::`[[`
[17:40:20.483]             `+` <- base::`+`
[17:40:20.483]             `<<-` <- base::`<<-`
[17:40:20.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.483]                   3L)]
[17:40:20.483]             }
[17:40:20.483]             function(cond) {
[17:40:20.483]                 is_error <- inherits(cond, "error")
[17:40:20.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.483]                   NULL)
[17:40:20.483]                 if (is_error) {
[17:40:20.483]                   sessionInformation <- function() {
[17:40:20.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.483]                       search = base::search(), system = base::Sys.info())
[17:40:20.483]                   }
[17:40:20.483]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.483]                     cond$call), session = sessionInformation(), 
[17:40:20.483]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.483]                   signalCondition(cond)
[17:40:20.483]                 }
[17:40:20.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.483]                 "immediateCondition"))) {
[17:40:20.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.483]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.483]                   if (TRUE && !signal) {
[17:40:20.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.483]                     {
[17:40:20.483]                       inherits <- base::inherits
[17:40:20.483]                       invokeRestart <- base::invokeRestart
[17:40:20.483]                       is.null <- base::is.null
[17:40:20.483]                       muffled <- FALSE
[17:40:20.483]                       if (inherits(cond, "message")) {
[17:40:20.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.483]                         if (muffled) 
[17:40:20.483]                           invokeRestart("muffleMessage")
[17:40:20.483]                       }
[17:40:20.483]                       else if (inherits(cond, "warning")) {
[17:40:20.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.483]                         if (muffled) 
[17:40:20.483]                           invokeRestart("muffleWarning")
[17:40:20.483]                       }
[17:40:20.483]                       else if (inherits(cond, "condition")) {
[17:40:20.483]                         if (!is.null(pattern)) {
[17:40:20.483]                           computeRestarts <- base::computeRestarts
[17:40:20.483]                           grepl <- base::grepl
[17:40:20.483]                           restarts <- computeRestarts(cond)
[17:40:20.483]                           for (restart in restarts) {
[17:40:20.483]                             name <- restart$name
[17:40:20.483]                             if (is.null(name)) 
[17:40:20.483]                               next
[17:40:20.483]                             if (!grepl(pattern, name)) 
[17:40:20.483]                               next
[17:40:20.483]                             invokeRestart(restart)
[17:40:20.483]                             muffled <- TRUE
[17:40:20.483]                             break
[17:40:20.483]                           }
[17:40:20.483]                         }
[17:40:20.483]                       }
[17:40:20.483]                       invisible(muffled)
[17:40:20.483]                     }
[17:40:20.483]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.483]                   }
[17:40:20.483]                 }
[17:40:20.483]                 else {
[17:40:20.483]                   if (TRUE) {
[17:40:20.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.483]                     {
[17:40:20.483]                       inherits <- base::inherits
[17:40:20.483]                       invokeRestart <- base::invokeRestart
[17:40:20.483]                       is.null <- base::is.null
[17:40:20.483]                       muffled <- FALSE
[17:40:20.483]                       if (inherits(cond, "message")) {
[17:40:20.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.483]                         if (muffled) 
[17:40:20.483]                           invokeRestart("muffleMessage")
[17:40:20.483]                       }
[17:40:20.483]                       else if (inherits(cond, "warning")) {
[17:40:20.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.483]                         if (muffled) 
[17:40:20.483]                           invokeRestart("muffleWarning")
[17:40:20.483]                       }
[17:40:20.483]                       else if (inherits(cond, "condition")) {
[17:40:20.483]                         if (!is.null(pattern)) {
[17:40:20.483]                           computeRestarts <- base::computeRestarts
[17:40:20.483]                           grepl <- base::grepl
[17:40:20.483]                           restarts <- computeRestarts(cond)
[17:40:20.483]                           for (restart in restarts) {
[17:40:20.483]                             name <- restart$name
[17:40:20.483]                             if (is.null(name)) 
[17:40:20.483]                               next
[17:40:20.483]                             if (!grepl(pattern, name)) 
[17:40:20.483]                               next
[17:40:20.483]                             invokeRestart(restart)
[17:40:20.483]                             muffled <- TRUE
[17:40:20.483]                             break
[17:40:20.483]                           }
[17:40:20.483]                         }
[17:40:20.483]                       }
[17:40:20.483]                       invisible(muffled)
[17:40:20.483]                     }
[17:40:20.483]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.483]                   }
[17:40:20.483]                 }
[17:40:20.483]             }
[17:40:20.483]         }))
[17:40:20.483]     }, error = function(ex) {
[17:40:20.483]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.483]                 ...future.rng), started = ...future.startTime, 
[17:40:20.483]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.483]             version = "1.8"), class = "FutureResult")
[17:40:20.483]     }, finally = {
[17:40:20.483]         if (!identical(...future.workdir, getwd())) 
[17:40:20.483]             setwd(...future.workdir)
[17:40:20.483]         {
[17:40:20.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.483]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.483]             }
[17:40:20.483]             base::options(...future.oldOptions)
[17:40:20.483]             if (.Platform$OS.type == "windows") {
[17:40:20.483]                 old_names <- names(...future.oldEnvVars)
[17:40:20.483]                 envs <- base::Sys.getenv()
[17:40:20.483]                 names <- names(envs)
[17:40:20.483]                 common <- intersect(names, old_names)
[17:40:20.483]                 added <- setdiff(names, old_names)
[17:40:20.483]                 removed <- setdiff(old_names, names)
[17:40:20.483]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.483]                   envs[common]]
[17:40:20.483]                 NAMES <- toupper(changed)
[17:40:20.483]                 args <- list()
[17:40:20.483]                 for (kk in seq_along(NAMES)) {
[17:40:20.483]                   name <- changed[[kk]]
[17:40:20.483]                   NAME <- NAMES[[kk]]
[17:40:20.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.483]                     next
[17:40:20.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.483]                 }
[17:40:20.483]                 NAMES <- toupper(added)
[17:40:20.483]                 for (kk in seq_along(NAMES)) {
[17:40:20.483]                   name <- added[[kk]]
[17:40:20.483]                   NAME <- NAMES[[kk]]
[17:40:20.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.483]                     next
[17:40:20.483]                   args[[name]] <- ""
[17:40:20.483]                 }
[17:40:20.483]                 NAMES <- toupper(removed)
[17:40:20.483]                 for (kk in seq_along(NAMES)) {
[17:40:20.483]                   name <- removed[[kk]]
[17:40:20.483]                   NAME <- NAMES[[kk]]
[17:40:20.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.483]                     next
[17:40:20.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.483]                 }
[17:40:20.483]                 if (length(args) > 0) 
[17:40:20.483]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.483]             }
[17:40:20.483]             else {
[17:40:20.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.483]             }
[17:40:20.483]             {
[17:40:20.483]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.483]                   0L) {
[17:40:20.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.483]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.483]                   base::options(opts)
[17:40:20.483]                 }
[17:40:20.483]                 {
[17:40:20.483]                   {
[17:40:20.483]                     NULL
[17:40:20.483]                     RNGkind("Mersenne-Twister")
[17:40:20.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:20.483]                       inherits = FALSE)
[17:40:20.483]                   }
[17:40:20.483]                   options(future.plan = NULL)
[17:40:20.483]                   if (is.na(NA_character_)) 
[17:40:20.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.483]                     .init = FALSE)
[17:40:20.483]                 }
[17:40:20.483]             }
[17:40:20.483]         }
[17:40:20.483]     })
[17:40:20.483]     if (TRUE) {
[17:40:20.483]         base::sink(type = "output", split = FALSE)
[17:40:20.483]         if (TRUE) {
[17:40:20.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.483]         }
[17:40:20.483]         else {
[17:40:20.483]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.483]         }
[17:40:20.483]         base::close(...future.stdout)
[17:40:20.483]         ...future.stdout <- NULL
[17:40:20.483]     }
[17:40:20.483]     ...future.result$conditions <- ...future.conditions
[17:40:20.483]     ...future.result$finished <- base::Sys.time()
[17:40:20.483]     ...future.result
[17:40:20.483] }
[17:40:20.485] assign_globals() ...
[17:40:20.485] List of 1
[17:40:20.485]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:20.485]   ..$ a: int [1:3] 1 2 3
[17:40:20.485]   ..$ b: int [1:3] 3 2 1
[17:40:20.485]  - attr(*, "where")=List of 1
[17:40:20.485]   ..$ data:<environment: R_EmptyEnv> 
[17:40:20.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.485]  - attr(*, "resolved")= logi FALSE
[17:40:20.485]  - attr(*, "total_size")= num 128
[17:40:20.485]  - attr(*, "already-done")= logi TRUE
[17:40:20.491] - copied ‘data’ to environment
[17:40:20.491] assign_globals() ... done
[17:40:20.491] plan(): Setting new future strategy stack:
[17:40:20.491] List of future strategies:
[17:40:20.491] 1. multisession:
[17:40:20.491]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:20.491]    - tweaked: FALSE
[17:40:20.491]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.495] plan(): nbrOfWorkers() = 2
[17:40:20.537] plan(): Setting new future strategy stack:
[17:40:20.537] List of future strategies:
[17:40:20.537] 1. sequential:
[17:40:20.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.537]    - tweaked: FALSE
[17:40:20.537]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.537] 2. multisession:
[17:40:20.537]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:20.537]    - tweaked: FALSE
[17:40:20.537]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.538] plan(): nbrOfWorkers() = 1
[17:40:20.538] SequentialFuture started (and completed)
[17:40:20.538] signalConditions() ...
[17:40:20.538]  - include = ‘immediateCondition’
[17:40:20.538]  - exclude = 
[17:40:20.538]  - resignal = FALSE
[17:40:20.538]  - Number of conditions: 63
[17:40:20.539] signalConditions() ... done
[17:40:20.539] - Launch lazy future ... done
[17:40:20.539] run() for ‘SequentialFuture’ ... done
[17:40:20.539] signalConditions() ...
[17:40:20.539]  - include = ‘immediateCondition’
[17:40:20.539]  - exclude = 
[17:40:20.539]  - resignal = FALSE
[17:40:20.539]  - Number of conditions: 63
[17:40:20.539] signalConditions() ... done
[17:40:20.539] Future state: ‘finished’
[17:40:20.539] signalConditions() ...
[17:40:20.540]  - include = ‘condition’
[17:40:20.540]  - exclude = ‘immediateCondition’
[17:40:20.540]  - resignal = TRUE
[17:40:20.540]  - Number of conditions: 63
[17:40:20.540]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.496] getGlobalsAndPackages() ...
[17:40:20.540]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.496] Searching for globals...
[17:40:20.540]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.510] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:20.540]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.510] Searching for globals ... DONE
[17:40:20.540]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.510] Resolving globals: FALSE
[17:40:20.541]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.510] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:20.541]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:20.541]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] - globals: [1] ‘data’
[17:40:20.541]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] 
[17:40:20.541]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] getGlobalsAndPackages() ... DONE
[17:40:20.541]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] run() for ‘Future’ ...
[17:40:20.541]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] - state: ‘created’
[17:40:20.541]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.511] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.542]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.542]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:20.542]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.526]   - Field: ‘node’
[17:40:20.542]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.526]   - Field: ‘label’
[17:40:20.542]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.526]   - Field: ‘local’
[17:40:20.542]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.526]   - Field: ‘owner’
[17:40:20.542]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘envir’
[17:40:20.543]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘workers’
[17:40:20.543]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘packages’
[17:40:20.543]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘gc’
[17:40:20.543]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘conditions’
[17:40:20.543]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘persistent’
[17:40:20.543]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘expr’
[17:40:20.543]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘uuid’
[17:40:20.543]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘seed’
[17:40:20.543]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.527]   - Field: ‘version’
[17:40:20.544]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘result’
[17:40:20.544]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘asynchronous’
[17:40:20.544]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘calls’
[17:40:20.544]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘globals’
[17:40:20.544]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘stdout’
[17:40:20.544]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘earlySignal’
[17:40:20.544]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘lazy’
[17:40:20.545]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528]   - Field: ‘state’
[17:40:20.545]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:20.545]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.529] - Launch lazy future ...
[17:40:20.545]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.529] Packages needed by the future expression (n = 0): <none>
[17:40:20.545]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.529] Packages needed by future strategies (n = 0): <none>
[17:40:20.545]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.529] {
[17:40:20.529]     {
[17:40:20.529]         {
[17:40:20.529]             ...future.startTime <- base::Sys.time()
[17:40:20.529]             {
[17:40:20.529]                 {
[17:40:20.529]                   {
[17:40:20.529]                     {
[17:40:20.529]                       base::local({
[17:40:20.529]                         has_future <- base::requireNamespace("future", 
[17:40:20.529]                           quietly = TRUE)
[17:40:20.529]                         if (has_future) {
[17:40:20.529]                           ns <- base::getNamespace("future")
[17:40:20.529]                           version <- ns[[".package"]][["version"]]
[17:40:20.529]                           if (is.null(version)) 
[17:40:20.529]                             version <- utils::packageVersion("future")
[17:40:20.529]                         }
[17:40:20.529]                         else {
[17:40:20.529]                           version <- NULL
[17:40:20.529]                         }
[17:40:20.529]                         if (!has_future || version < "1.8.0") {
[17:40:20.529]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.529]                             "", base::R.version$version.string), 
[17:40:20.529]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:20.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.529]                               "release", "version")], collapse = " "), 
[17:40:20.529]                             hostname = base::Sys.info()[["nodename"]])
[17:40:20.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.529]                             info)
[17:40:20.529]                           info <- base::paste(info, collapse = "; ")
[17:40:20.529]                           if (!has_future) {
[17:40:20.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.529]                               info)
[17:40:20.529]                           }
[17:40:20.529]                           else {
[17:40:20.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.529]                               info, version)
[17:40:20.529]                           }
[17:40:20.529]                           base::stop(msg)
[17:40:20.529]                         }
[17:40:20.529]                       })
[17:40:20.529]                     }
[17:40:20.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.529]                     base::options(mc.cores = 1L)
[17:40:20.529]                   }
[17:40:20.529]                   ...future.strategy.old <- future::plan("list")
[17:40:20.529]                   options(future.plan = NULL)
[17:40:20.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:20.529]                 }
[17:40:20.529]                 ...future.workdir <- getwd()
[17:40:20.529]             }
[17:40:20.529]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.529]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.529]         }
[17:40:20.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.529]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.529]             base::names(...future.oldOptions))
[17:40:20.529]     }
[17:40:20.529]     if (FALSE) {
[17:40:20.529]     }
[17:40:20.529]     else {
[17:40:20.529]         if (TRUE) {
[17:40:20.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.529]                 open = "w")
[17:40:20.529]         }
[17:40:20.529]         else {
[17:40:20.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.529]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.529]         }
[17:40:20.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.529]             base::sink(type = "output", split = FALSE)
[17:40:20.529]             base::close(...future.stdout)
[17:40:20.529]         }, add = TRUE)
[17:40:20.529]     }
[17:40:20.529]     ...future.frame <- base::sys.nframe()
[17:40:20.529]     ...future.conditions <- base::list()
[17:40:20.529]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.529]     if (FALSE) {
[17:40:20.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.529]     }
[17:40:20.529]     ...future.result <- base::tryCatch({
[17:40:20.529]         base::withCallingHandlers({
[17:40:20.529]             ...future.value <- base::withVisible(base::local({
[17:40:20.529]                 ...future.makeSendCondition <- base::local({
[17:40:20.529]                   sendCondition <- NULL
[17:40:20.529]                   function(frame = 1L) {
[17:40:20.529]                     if (is.function(sendCondition)) 
[17:40:20.529]                       return(sendCondition)
[17:40:20.529]                     ns <- getNamespace("parallel")
[17:40:20.529]                     if (exists("sendData", mode = "function", 
[17:40:20.529]                       envir = ns)) {
[17:40:20.529]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:20.529]                         envir = ns)
[17:40:20.529]                       envir <- sys.frame(frame)
[17:40:20.529]                       master <- NULL
[17:40:20.529]                       while (!identical(envir, .GlobalEnv) && 
[17:40:20.529]                         !identical(envir, emptyenv())) {
[17:40:20.529]                         if (exists("master", mode = "list", envir = envir, 
[17:40:20.529]                           inherits = FALSE)) {
[17:40:20.529]                           master <- get("master", mode = "list", 
[17:40:20.529]                             envir = envir, inherits = FALSE)
[17:40:20.529]                           if (inherits(master, c("SOCKnode", 
[17:40:20.529]                             "SOCK0node"))) {
[17:40:20.529]                             sendCondition <<- function(cond) {
[17:40:20.529]                               data <- list(type = "VALUE", value = cond, 
[17:40:20.529]                                 success = TRUE)
[17:40:20.529]                               parallel_sendData(master, data)
[17:40:20.529]                             }
[17:40:20.529]                             return(sendCondition)
[17:40:20.529]                           }
[17:40:20.529]                         }
[17:40:20.529]                         frame <- frame + 1L
[17:40:20.529]                         envir <- sys.frame(frame)
[17:40:20.529]                       }
[17:40:20.529]                     }
[17:40:20.529]                     sendCondition <<- function(cond) NULL
[17:40:20.529]                   }
[17:40:20.529]                 })
[17:40:20.529]                 withCallingHandlers({
[17:40:20.529]                   subset(data, a == 2)
[17:40:20.529]                 }, immediateCondition = function(cond) {
[17:40:20.529]                   sendCondition <- ...future.makeSendCondition()
[17:40:20.529]                   sendCondition(cond)
[17:40:20.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.529]                   {
[17:40:20.529]                     inherits <- base::inherits
[17:40:20.529]                     invokeRestart <- base::invokeRestart
[17:40:20.529]                     is.null <- base::is.null
[17:40:20.529]                     muffled <- FALSE
[17:40:20.529]                     if (inherits(cond, "message")) {
[17:40:20.529]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.529]                       if (muffled) 
[17:40:20.529]                         invokeRestart("muffleMessage")
[17:40:20.529]                     }
[17:40:20.529]                     else if (inherits(cond, "warning")) {
[17:40:20.529]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.529]                       if (muffled) 
[17:40:20.529]                         invokeRestart("muffleWarning")
[17:40:20.529]                     }
[17:40:20.529]                     else if (inherits(cond, "condition")) {
[17:40:20.529]                       if (!is.null(pattern)) {
[17:40:20.529]                         computeRestarts <- base::computeRestarts
[17:40:20.529]                         grepl <- base::grepl
[17:40:20.529]                         restarts <- computeRestarts(cond)
[17:40:20.529]                         for (restart in restarts) {
[17:40:20.529]                           name <- restart$name
[17:40:20.529]                           if (is.null(name)) 
[17:40:20.529]                             next
[17:40:20.529]                           if (!grepl(pattern, name)) 
[17:40:20.529]                             next
[17:40:20.529]                           invokeRestart(restart)
[17:40:20.529]                           muffled <- TRUE
[17:40:20.529]                           break
[17:40:20.529]                         }
[17:40:20.529]                       }
[17:40:20.529]                     }
[17:40:20.529]                     invisible(muffled)
[17:40:20.529]                   }
[17:40:20.529]                   muffleCondition(cond)
[17:40:20.529]                 })
[17:40:20.529]             }))
[17:40:20.529]             future::FutureResult(value = ...future.value$value, 
[17:40:20.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.529]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.529]                     ...future.globalenv.names))
[17:40:20.529]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.529]         }, condition = base::local({
[17:40:20.529]             c <- base::c
[17:40:20.529]             inherits <- base::inherits
[17:40:20.529]             invokeRestart <- base::invokeRestart
[17:40:20.529]             length <- base::length
[17:40:20.529]             list <- base::list
[17:40:20.529]             seq.int <- base::seq.int
[17:40:20.529]             signalCondition <- base::signalCondition
[17:40:20.529]             sys.calls <- base::sys.calls
[17:40:20.529]             `[[` <- base::`[[`
[17:40:20.529]             `+` <- base::`+`
[17:40:20.529]             `<<-` <- base::`<<-`
[17:40:20.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.529]                   3L)]
[17:40:20.529]             }
[17:40:20.529]             function(cond) {
[17:40:20.529]                 is_error <- inherits(cond, "error")
[17:40:20.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.529]                   NULL)
[17:40:20.529]                 if (is_error) {
[17:40:20.529]                   sessionInformation <- function() {
[17:40:20.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.529]                       search = base::search(), system = base::Sys.info())
[17:40:20.529]                   }
[17:40:20.529]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.529]                     cond$call), session = sessionInformation(), 
[17:40:20.529]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.529]                   signalCondition(cond)
[17:40:20.529]                 }
[17:40:20.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.529]                 "immediateCondition"))) {
[17:40:20.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.529]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.529]                   if (TRUE && !signal) {
[17:40:20.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.529]                     {
[17:40:20.529]                       inherits <- base::inherits
[17:40:20.529]                       invokeRestart <- base::invokeRestart
[17:40:20.529]                       is.null <- base::is.null
[17:40:20.529]                       muffled <- FALSE
[17:40:20.529]                       if (inherits(cond, "message")) {
[17:40:20.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.529]                         if (muffled) 
[17:40:20.529]                           invokeRestart("muffleMessage")
[17:40:20.529]                       }
[17:40:20.529]                       else if (inherits(cond, "warning")) {
[17:40:20.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.529]                         if (muffled) 
[17:40:20.529]                           invokeRestart("muffleWarning")
[17:40:20.529]                       }
[17:40:20.529]                       else if (inherits(cond, "condition")) {
[17:40:20.529]                         if (!is.null(pattern)) {
[17:40:20.529]                           computeRestarts <- base::computeRestarts
[17:40:20.529]                           grepl <- base::grepl
[17:40:20.529]                           restarts <- computeRestarts(cond)
[17:40:20.529]                           for (restart in restarts) {
[17:40:20.529]                             name <- restart$name
[17:40:20.529]                             if (is.null(name)) 
[17:40:20.529]                               next
[17:40:20.529]                             if (!grepl(pattern, name)) 
[17:40:20.529]                               next
[17:40:20.529]                             invokeRestart(restart)
[17:40:20.529]                             muffled <- TRUE
[17:40:20.529]                             break
[17:40:20.529]                           }
[17:40:20.529]                         }
[17:40:20.529]                       }
[17:40:20.529]                       invisible(muffled)
[17:40:20.529]                     }
[17:40:20.529]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.529]                   }
[17:40:20.529]                 }
[17:40:20.529]                 else {
[17:40:20.529]                   if (TRUE) {
[17:40:20.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.529]                     {
[17:40:20.529]                       inherits <- base::inherits
[17:40:20.529]                       invokeRestart <- base::invokeRestart
[17:40:20.529]                       is.null <- base::is.null
[17:40:20.529]                       muffled <- FALSE
[17:40:20.529]                       if (inherits(cond, "message")) {
[17:40:20.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.529]                         if (muffled) 
[17:40:20.529]                           invokeRestart("muffleMessage")
[17:40:20.529]                       }
[17:40:20.529]                       else if (inherits(cond, "warning")) {
[17:40:20.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.529]                         if (muffled) 
[17:40:20.529]                           invokeRestart("muffleWarning")
[17:40:20.529]                       }
[17:40:20.529]                       else if (inherits(cond, "condition")) {
[17:40:20.529]                         if (!is.null(pattern)) {
[17:40:20.529]                           computeRestarts <- base::computeRestarts
[17:40:20.529]                           grepl <- base::grepl
[17:40:20.529]                           restarts <- computeRestarts(cond)
[17:40:20.529]                           for (restart in restarts) {
[17:40:20.529]                             name <- restart$name
[17:40:20.529]                             if (is.null(name)) 
[17:40:20.529]                               next
[17:40:20.529]                             if (!grepl(pattern, name)) 
[17:40:20.529]                               next
[17:40:20.529]                             invokeRestart(restart)
[17:40:20.529]                             muffled <- TRUE
[17:40:20.529]                             break
[17:40:20.529]                           }
[17:40:20.529]                         }
[17:40:20.529]                       }
[17:40:20.529]                       invisible(muffled)
[17:40:20.529]                     }
[17:40:20.529]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.529]                   }
[17:40:20.529]                 }
[17:40:20.529]             }
[17:40:20.529]         }))
[17:40:20.529]     }, error = function(ex) {
[17:40:20.529]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.529]                 ...future.rng), started = ...future.startTime, 
[17:40:20.529]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.529]             version = "1.8"), class = "FutureResult")
[17:40:20.529]     }, finally = {
[17:40:20.529]         if (!identical(...future.workdir, getwd())) 
[17:40:20.529]             setwd(...future.workdir)
[17:40:20.529]         {
[17:40:20.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.529]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.529]             }
[17:40:20.529]             base::options(...future.oldOptions)
[17:40:20.529]             if (.Platform$OS.type == "windows") {
[17:40:20.529]                 old_names <- names(...future.oldEnvVars)
[17:40:20.529]                 envs <- base::Sys.getenv()
[17:40:20.529]                 names <- names(envs)
[17:40:20.529]                 common <- intersect(names, old_names)
[17:40:20.529]                 added <- setdiff(names, old_names)
[17:40:20.529]                 removed <- setdiff(old_names, names)
[17:40:20.529]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.529]                   envs[common]]
[17:40:20.529]                 NAMES <- toupper(changed)
[17:40:20.529]                 args <- list()
[17:40:20.529]                 for (kk in seq_along(NAMES)) {
[17:40:20.529]                   name <- changed[[kk]]
[17:40:20.529]                   NAME <- NAMES[[kk]]
[17:40:20.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.529]                     next
[17:40:20.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.529]                 }
[17:40:20.529]                 NAMES <- toupper(added)
[17:40:20.529]                 for (kk in seq_along(NAMES)) {
[17:40:20.529]                   name <- added[[kk]]
[17:40:20.529]                   NAME <- NAMES[[kk]]
[17:40:20.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.529]                     next
[17:40:20.529]                   args[[name]] <- ""
[17:40:20.529]                 }
[17:40:20.529]                 NAMES <- toupper(removed)
[17:40:20.529]                 for (kk in seq_along(NAMES)) {
[17:40:20.529]                   name <- removed[[kk]]
[17:40:20.529]                   NAME <- NAMES[[kk]]
[17:40:20.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.529]                     next
[17:40:20.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.529]                 }
[17:40:20.529]                 if (length(args) > 0) 
[17:40:20.529]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.529]             }
[17:40:20.529]             else {
[17:40:20.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.529]             }
[17:40:20.529]             {
[17:40:20.529]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.529]                   0L) {
[17:40:20.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.529]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.529]                   base::options(opts)
[17:40:20.529]                 }
[17:40:20.529]                 {
[17:40:20.529]                   {
[17:40:20.529]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.529]                     NULL
[17:40:20.529]                   }
[17:40:20.529]                   options(future.plan = NULL)
[17:40:20.529]                   if (is.na(NA_character_)) 
[17:40:20.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.529]                     .init = FALSE)
[17:40:20.529]                 }
[17:40:20.529]             }
[17:40:20.529]         }
[17:40:20.529]     })
[17:40:20.529]     if (TRUE) {
[17:40:20.529]         base::sink(type = "output", split = FALSE)
[17:40:20.529]         if (TRUE) {
[17:40:20.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.529]         }
[17:40:20.529]         else {
[17:40:20.529]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.529]         }
[17:40:20.529]         base::close(...future.stdout)
[17:40:20.529]         ...future.stdout <- NULL
[17:40:20.529]     }
[17:40:20.529]     ...future.result$conditions <- ...future.conditions
[17:40:20.529]     ...future.result$finished <- base::Sys.time()
[17:40:20.529]     ...future.result
[17:40:20.529] }
[17:40:20.545]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.532] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:40:20.545]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.532] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:40:20.546]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.532] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:40:20.546]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.533] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:40:20.546]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.533] MultisessionFuture started
[17:40:20.546]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.533] - Launch lazy future ... done
[17:40:20.546]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.534] run() for ‘MultisessionFuture’ ... done
[17:40:20.546]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.534] result() for ClusterFuture ...
[17:40:20.546]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.534] receiveMessageFromWorker() for ClusterFuture ...
[17:40:20.546]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.534] - Validating connection of MultisessionFuture
[17:40:20.547]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.535] - received message: FutureResult
[17:40:20.547]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] - Received FutureResult
[17:40:20.547]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] - Erased future from FutureRegistry
[17:40:20.547]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] result() for ClusterFuture ...
[17:40:20.547]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] - result already collected: FutureResult
[17:40:20.547]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] result() for ClusterFuture ... done
[17:40:20.547]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:20.547]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] result() for ClusterFuture ... done
[17:40:20.548]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.536] result() for ClusterFuture ...
[17:40:20.548]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.537] - result already collected: FutureResult
[17:40:20.548]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.537] result() for ClusterFuture ... done
[17:40:20.548] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[17:40:20.548] plan(): Setting new future strategy stack:
[17:40:20.548] List of future strategies:
[17:40:20.548] 1. multicore:
[17:40:20.548]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.548]    - tweaked: FALSE
[17:40:20.548]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.548] 2. sequential:
[17:40:20.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.548]    - tweaked: FALSE
[17:40:20.548]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.553] plan(): nbrOfWorkers() = 2
[17:40:20.553] getGlobalsAndPackages() ...
[17:40:20.553] Searching for globals...
[17:40:20.576] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:20.576] Searching for globals ... DONE
[17:40:20.576] Resolving globals: FALSE
[17:40:20.577] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[17:40:20.577] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:20.578] - globals: [2] ‘nested’, ‘strategy2’
[17:40:20.578] - packages: [1] ‘future’
[17:40:20.578] getGlobalsAndPackages() ... DONE
[17:40:20.578] run() for ‘Future’ ...
[17:40:20.578] - state: ‘created’
[17:40:20.578] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.582] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:20.582]   - Field: ‘label’
[17:40:20.582]   - Field: ‘local’
[17:40:20.583]   - Field: ‘owner’
[17:40:20.583]   - Field: ‘envir’
[17:40:20.583]   - Field: ‘workers’
[17:40:20.583]   - Field: ‘packages’
[17:40:20.583]   - Field: ‘gc’
[17:40:20.583]   - Field: ‘job’
[17:40:20.583]   - Field: ‘conditions’
[17:40:20.583]   - Field: ‘expr’
[17:40:20.583]   - Field: ‘uuid’
[17:40:20.584]   - Field: ‘seed’
[17:40:20.584]   - Field: ‘version’
[17:40:20.584]   - Field: ‘result’
[17:40:20.584]   - Field: ‘asynchronous’
[17:40:20.584]   - Field: ‘calls’
[17:40:20.584]   - Field: ‘globals’
[17:40:20.584]   - Field: ‘stdout’
[17:40:20.584]   - Field: ‘earlySignal’
[17:40:20.584]   - Field: ‘lazy’
[17:40:20.584]   - Field: ‘state’
[17:40:20.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:20.585] - Launch lazy future ...
[17:40:20.585] Packages needed by the future expression (n = 1): ‘future’
[17:40:20.585] Packages needed by future strategies (n = 1): ‘future’
[17:40:20.586] {
[17:40:20.586]     {
[17:40:20.586]         {
[17:40:20.586]             ...future.startTime <- base::Sys.time()
[17:40:20.586]             {
[17:40:20.586]                 {
[17:40:20.586]                   {
[17:40:20.586]                     {
[17:40:20.586]                       {
[17:40:20.586]                         base::local({
[17:40:20.586]                           has_future <- base::requireNamespace("future", 
[17:40:20.586]                             quietly = TRUE)
[17:40:20.586]                           if (has_future) {
[17:40:20.586]                             ns <- base::getNamespace("future")
[17:40:20.586]                             version <- ns[[".package"]][["version"]]
[17:40:20.586]                             if (is.null(version)) 
[17:40:20.586]                               version <- utils::packageVersion("future")
[17:40:20.586]                           }
[17:40:20.586]                           else {
[17:40:20.586]                             version <- NULL
[17:40:20.586]                           }
[17:40:20.586]                           if (!has_future || version < "1.8.0") {
[17:40:20.586]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.586]                               "", base::R.version$version.string), 
[17:40:20.586]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:20.586]                                 base::R.version$platform, 8 * 
[17:40:20.586]                                   base::.Machine$sizeof.pointer), 
[17:40:20.586]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.586]                                 "release", "version")], collapse = " "), 
[17:40:20.586]                               hostname = base::Sys.info()[["nodename"]])
[17:40:20.586]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.586]                               info)
[17:40:20.586]                             info <- base::paste(info, collapse = "; ")
[17:40:20.586]                             if (!has_future) {
[17:40:20.586]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.586]                                 info)
[17:40:20.586]                             }
[17:40:20.586]                             else {
[17:40:20.586]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.586]                                 info, version)
[17:40:20.586]                             }
[17:40:20.586]                             base::stop(msg)
[17:40:20.586]                           }
[17:40:20.586]                         })
[17:40:20.586]                       }
[17:40:20.586]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.586]                       base::options(mc.cores = 1L)
[17:40:20.586]                     }
[17:40:20.586]                     base::local({
[17:40:20.586]                       for (pkg in "future") {
[17:40:20.586]                         base::loadNamespace(pkg)
[17:40:20.586]                         base::library(pkg, character.only = TRUE)
[17:40:20.586]                       }
[17:40:20.586]                     })
[17:40:20.586]                   }
[17:40:20.586]                   ...future.strategy.old <- future::plan("list")
[17:40:20.586]                   options(future.plan = NULL)
[17:40:20.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.586]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:20.586]                   {
[17:40:20.586]                     future <- SequentialFuture(..., envir = envir)
[17:40:20.586]                     if (!future$lazy) 
[17:40:20.586]                       future <- run(future)
[17:40:20.586]                     invisible(future)
[17:40:20.586]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:20.586]                 }
[17:40:20.586]                 ...future.workdir <- getwd()
[17:40:20.586]             }
[17:40:20.586]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.586]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.586]         }
[17:40:20.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.586]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.586]             base::names(...future.oldOptions))
[17:40:20.586]     }
[17:40:20.586]     if (FALSE) {
[17:40:20.586]     }
[17:40:20.586]     else {
[17:40:20.586]         if (TRUE) {
[17:40:20.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.586]                 open = "w")
[17:40:20.586]         }
[17:40:20.586]         else {
[17:40:20.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.586]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.586]         }
[17:40:20.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.586]             base::sink(type = "output", split = FALSE)
[17:40:20.586]             base::close(...future.stdout)
[17:40:20.586]         }, add = TRUE)
[17:40:20.586]     }
[17:40:20.586]     ...future.frame <- base::sys.nframe()
[17:40:20.586]     ...future.conditions <- base::list()
[17:40:20.586]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.586]     if (FALSE) {
[17:40:20.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.586]     }
[17:40:20.586]     ...future.result <- base::tryCatch({
[17:40:20.586]         base::withCallingHandlers({
[17:40:20.586]             ...future.value <- base::withVisible(base::local({
[17:40:20.586]                 withCallingHandlers({
[17:40:20.586]                   {
[17:40:20.586]                     a <- 1L
[17:40:20.586]                     plan_a <- unclass(future::plan("list"))
[17:40:20.586]                     nested_a <- nested[-1]
[17:40:20.586]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:20.586]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:20.586]                       strategy2))
[17:40:20.586]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:20.586]                       "init") <- NULL
[17:40:20.586]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:20.586]                       "init") <- NULL
[17:40:20.586]                     stopifnot(all.equal(plan_a, nested_a))
[17:40:20.586]                     y %<-% {
[17:40:20.586]                       b <- 2L
[17:40:20.586]                       plan_b <- future::plan("list")
[17:40:20.586]                       nested_b <- nested_a[-1]
[17:40:20.586]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:20.586]                         1L, inherits(plan_b[[1]], "future"), 
[17:40:20.586]                         inherits(future::plan("next"), "sequential"))
[17:40:20.586]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:20.586]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:20.586]                     }
[17:40:20.586]                     y
[17:40:20.586]                   }
[17:40:20.586]                 }, immediateCondition = function(cond) {
[17:40:20.586]                   save_rds <- function (object, pathname, ...) 
[17:40:20.586]                   {
[17:40:20.586]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:20.586]                     if (file_test("-f", pathname_tmp)) {
[17:40:20.586]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.586]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:20.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.586]                         fi_tmp[["mtime"]])
[17:40:20.586]                     }
[17:40:20.586]                     tryCatch({
[17:40:20.586]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:20.586]                     }, error = function(ex) {
[17:40:20.586]                       msg <- conditionMessage(ex)
[17:40:20.586]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.586]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:20.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.586]                         fi_tmp[["mtime"]], msg)
[17:40:20.586]                       ex$message <- msg
[17:40:20.586]                       stop(ex)
[17:40:20.586]                     })
[17:40:20.586]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:20.586]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:20.586]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:20.586]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.586]                       fi <- file.info(pathname)
[17:40:20.586]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:20.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.586]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:20.586]                         fi[["size"]], fi[["mtime"]])
[17:40:20.586]                       stop(msg)
[17:40:20.586]                     }
[17:40:20.586]                     invisible(pathname)
[17:40:20.586]                   }
[17:40:20.586]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:20.586]                     rootPath = tempdir()) 
[17:40:20.586]                   {
[17:40:20.586]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:20.586]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:20.586]                       tmpdir = path, fileext = ".rds")
[17:40:20.586]                     save_rds(obj, file)
[17:40:20.586]                   }
[17:40:20.586]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:20.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.586]                   {
[17:40:20.586]                     inherits <- base::inherits
[17:40:20.586]                     invokeRestart <- base::invokeRestart
[17:40:20.586]                     is.null <- base::is.null
[17:40:20.586]                     muffled <- FALSE
[17:40:20.586]                     if (inherits(cond, "message")) {
[17:40:20.586]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.586]                       if (muffled) 
[17:40:20.586]                         invokeRestart("muffleMessage")
[17:40:20.586]                     }
[17:40:20.586]                     else if (inherits(cond, "warning")) {
[17:40:20.586]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.586]                       if (muffled) 
[17:40:20.586]                         invokeRestart("muffleWarning")
[17:40:20.586]                     }
[17:40:20.586]                     else if (inherits(cond, "condition")) {
[17:40:20.586]                       if (!is.null(pattern)) {
[17:40:20.586]                         computeRestarts <- base::computeRestarts
[17:40:20.586]                         grepl <- base::grepl
[17:40:20.586]                         restarts <- computeRestarts(cond)
[17:40:20.586]                         for (restart in restarts) {
[17:40:20.586]                           name <- restart$name
[17:40:20.586]                           if (is.null(name)) 
[17:40:20.586]                             next
[17:40:20.586]                           if (!grepl(pattern, name)) 
[17:40:20.586]                             next
[17:40:20.586]                           invokeRestart(restart)
[17:40:20.586]                           muffled <- TRUE
[17:40:20.586]                           break
[17:40:20.586]                         }
[17:40:20.586]                       }
[17:40:20.586]                     }
[17:40:20.586]                     invisible(muffled)
[17:40:20.586]                   }
[17:40:20.586]                   muffleCondition(cond)
[17:40:20.586]                 })
[17:40:20.586]             }))
[17:40:20.586]             future::FutureResult(value = ...future.value$value, 
[17:40:20.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.586]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.586]                     ...future.globalenv.names))
[17:40:20.586]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.586]         }, condition = base::local({
[17:40:20.586]             c <- base::c
[17:40:20.586]             inherits <- base::inherits
[17:40:20.586]             invokeRestart <- base::invokeRestart
[17:40:20.586]             length <- base::length
[17:40:20.586]             list <- base::list
[17:40:20.586]             seq.int <- base::seq.int
[17:40:20.586]             signalCondition <- base::signalCondition
[17:40:20.586]             sys.calls <- base::sys.calls
[17:40:20.586]             `[[` <- base::`[[`
[17:40:20.586]             `+` <- base::`+`
[17:40:20.586]             `<<-` <- base::`<<-`
[17:40:20.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.586]                   3L)]
[17:40:20.586]             }
[17:40:20.586]             function(cond) {
[17:40:20.586]                 is_error <- inherits(cond, "error")
[17:40:20.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.586]                   NULL)
[17:40:20.586]                 if (is_error) {
[17:40:20.586]                   sessionInformation <- function() {
[17:40:20.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.586]                       search = base::search(), system = base::Sys.info())
[17:40:20.586]                   }
[17:40:20.586]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.586]                     cond$call), session = sessionInformation(), 
[17:40:20.586]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.586]                   signalCondition(cond)
[17:40:20.586]                 }
[17:40:20.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.586]                 "immediateCondition"))) {
[17:40:20.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.586]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.586]                   if (TRUE && !signal) {
[17:40:20.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.586]                     {
[17:40:20.586]                       inherits <- base::inherits
[17:40:20.586]                       invokeRestart <- base::invokeRestart
[17:40:20.586]                       is.null <- base::is.null
[17:40:20.586]                       muffled <- FALSE
[17:40:20.586]                       if (inherits(cond, "message")) {
[17:40:20.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.586]                         if (muffled) 
[17:40:20.586]                           invokeRestart("muffleMessage")
[17:40:20.586]                       }
[17:40:20.586]                       else if (inherits(cond, "warning")) {
[17:40:20.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.586]                         if (muffled) 
[17:40:20.586]                           invokeRestart("muffleWarning")
[17:40:20.586]                       }
[17:40:20.586]                       else if (inherits(cond, "condition")) {
[17:40:20.586]                         if (!is.null(pattern)) {
[17:40:20.586]                           computeRestarts <- base::computeRestarts
[17:40:20.586]                           grepl <- base::grepl
[17:40:20.586]                           restarts <- computeRestarts(cond)
[17:40:20.586]                           for (restart in restarts) {
[17:40:20.586]                             name <- restart$name
[17:40:20.586]                             if (is.null(name)) 
[17:40:20.586]                               next
[17:40:20.586]                             if (!grepl(pattern, name)) 
[17:40:20.586]                               next
[17:40:20.586]                             invokeRestart(restart)
[17:40:20.586]                             muffled <- TRUE
[17:40:20.586]                             break
[17:40:20.586]                           }
[17:40:20.586]                         }
[17:40:20.586]                       }
[17:40:20.586]                       invisible(muffled)
[17:40:20.586]                     }
[17:40:20.586]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.586]                   }
[17:40:20.586]                 }
[17:40:20.586]                 else {
[17:40:20.586]                   if (TRUE) {
[17:40:20.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.586]                     {
[17:40:20.586]                       inherits <- base::inherits
[17:40:20.586]                       invokeRestart <- base::invokeRestart
[17:40:20.586]                       is.null <- base::is.null
[17:40:20.586]                       muffled <- FALSE
[17:40:20.586]                       if (inherits(cond, "message")) {
[17:40:20.586]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.586]                         if (muffled) 
[17:40:20.586]                           invokeRestart("muffleMessage")
[17:40:20.586]                       }
[17:40:20.586]                       else if (inherits(cond, "warning")) {
[17:40:20.586]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.586]                         if (muffled) 
[17:40:20.586]                           invokeRestart("muffleWarning")
[17:40:20.586]                       }
[17:40:20.586]                       else if (inherits(cond, "condition")) {
[17:40:20.586]                         if (!is.null(pattern)) {
[17:40:20.586]                           computeRestarts <- base::computeRestarts
[17:40:20.586]                           grepl <- base::grepl
[17:40:20.586]                           restarts <- computeRestarts(cond)
[17:40:20.586]                           for (restart in restarts) {
[17:40:20.586]                             name <- restart$name
[17:40:20.586]                             if (is.null(name)) 
[17:40:20.586]                               next
[17:40:20.586]                             if (!grepl(pattern, name)) 
[17:40:20.586]                               next
[17:40:20.586]                             invokeRestart(restart)
[17:40:20.586]                             muffled <- TRUE
[17:40:20.586]                             break
[17:40:20.586]                           }
[17:40:20.586]                         }
[17:40:20.586]                       }
[17:40:20.586]                       invisible(muffled)
[17:40:20.586]                     }
[17:40:20.586]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.586]                   }
[17:40:20.586]                 }
[17:40:20.586]             }
[17:40:20.586]         }))
[17:40:20.586]     }, error = function(ex) {
[17:40:20.586]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.586]                 ...future.rng), started = ...future.startTime, 
[17:40:20.586]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.586]             version = "1.8"), class = "FutureResult")
[17:40:20.586]     }, finally = {
[17:40:20.586]         if (!identical(...future.workdir, getwd())) 
[17:40:20.586]             setwd(...future.workdir)
[17:40:20.586]         {
[17:40:20.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.586]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.586]             }
[17:40:20.586]             base::options(...future.oldOptions)
[17:40:20.586]             if (.Platform$OS.type == "windows") {
[17:40:20.586]                 old_names <- names(...future.oldEnvVars)
[17:40:20.586]                 envs <- base::Sys.getenv()
[17:40:20.586]                 names <- names(envs)
[17:40:20.586]                 common <- intersect(names, old_names)
[17:40:20.586]                 added <- setdiff(names, old_names)
[17:40:20.586]                 removed <- setdiff(old_names, names)
[17:40:20.586]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.586]                   envs[common]]
[17:40:20.586]                 NAMES <- toupper(changed)
[17:40:20.586]                 args <- list()
[17:40:20.586]                 for (kk in seq_along(NAMES)) {
[17:40:20.586]                   name <- changed[[kk]]
[17:40:20.586]                   NAME <- NAMES[[kk]]
[17:40:20.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.586]                     next
[17:40:20.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.586]                 }
[17:40:20.586]                 NAMES <- toupper(added)
[17:40:20.586]                 for (kk in seq_along(NAMES)) {
[17:40:20.586]                   name <- added[[kk]]
[17:40:20.586]                   NAME <- NAMES[[kk]]
[17:40:20.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.586]                     next
[17:40:20.586]                   args[[name]] <- ""
[17:40:20.586]                 }
[17:40:20.586]                 NAMES <- toupper(removed)
[17:40:20.586]                 for (kk in seq_along(NAMES)) {
[17:40:20.586]                   name <- removed[[kk]]
[17:40:20.586]                   NAME <- NAMES[[kk]]
[17:40:20.586]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.586]                     next
[17:40:20.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.586]                 }
[17:40:20.586]                 if (length(args) > 0) 
[17:40:20.586]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.586]             }
[17:40:20.586]             else {
[17:40:20.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.586]             }
[17:40:20.586]             {
[17:40:20.586]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.586]                   0L) {
[17:40:20.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.586]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.586]                   base::options(opts)
[17:40:20.586]                 }
[17:40:20.586]                 {
[17:40:20.586]                   {
[17:40:20.586]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.586]                     NULL
[17:40:20.586]                   }
[17:40:20.586]                   options(future.plan = NULL)
[17:40:20.586]                   if (is.na(NA_character_)) 
[17:40:20.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.586]                     .init = FALSE)
[17:40:20.586]                 }
[17:40:20.586]             }
[17:40:20.586]         }
[17:40:20.586]     })
[17:40:20.586]     if (TRUE) {
[17:40:20.586]         base::sink(type = "output", split = FALSE)
[17:40:20.586]         if (TRUE) {
[17:40:20.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.586]         }
[17:40:20.586]         else {
[17:40:20.586]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.586]         }
[17:40:20.586]         base::close(...future.stdout)
[17:40:20.586]         ...future.stdout <- NULL
[17:40:20.586]     }
[17:40:20.586]     ...future.result$conditions <- ...future.conditions
[17:40:20.586]     ...future.result$finished <- base::Sys.time()
[17:40:20.586]     ...future.result
[17:40:20.586] }
[17:40:20.588] assign_globals() ...
[17:40:20.588] List of 2
[17:40:20.588]  $ nested   :List of 2
[17:40:20.588]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:20.588]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:20.588]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.588]   ..$ b:function (..., envir = parent.frame())  
[17:40:20.588]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:20.588]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.588]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:20.588]  $ strategy2: chr "sequential"
[17:40:20.588]  - attr(*, "where")=List of 2
[17:40:20.588]   ..$ nested   :<environment: R_EmptyEnv> 
[17:40:20.588]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:40:20.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.588]  - attr(*, "resolved")= logi FALSE
[17:40:20.588]  - attr(*, "total_size")= num 59224
[17:40:20.588]  - attr(*, "already-done")= logi TRUE
[17:40:20.593] - copied ‘nested’ to environment
[17:40:20.593] - copied ‘strategy2’ to environment
[17:40:20.593] assign_globals() ... done
[17:40:20.593] requestCore(): workers = 2
[17:40:20.595] MulticoreFuture started
[17:40:20.595] - Launch lazy future ... done
[17:40:20.596] run() for ‘MulticoreFuture’ ... done
[17:40:20.596] result() for MulticoreFuture ...
[17:40:20.597] plan(): Setting new future strategy stack:
[17:40:20.597] List of future strategies:
[17:40:20.597] 1. sequential:
[17:40:20.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.597]    - tweaked: FALSE
[17:40:20.597]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.598] plan(): nbrOfWorkers() = 1
[17:40:20.635] plan(): Setting new future strategy stack:
[17:40:20.635] List of future strategies:
[17:40:20.635] 1. multicore:
[17:40:20.635]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.635]    - tweaked: FALSE
[17:40:20.635]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.635] 2. sequential:
[17:40:20.635]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.635]    - tweaked: FALSE
[17:40:20.635]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.640] plan(): nbrOfWorkers() = 2
[17:40:20.641] result() for MulticoreFuture ...
[17:40:20.642] result() for MulticoreFuture ... done
[17:40:20.642] signalConditions() ...
[17:40:20.642]  - include = ‘immediateCondition’
[17:40:20.642]  - exclude = 
[17:40:20.642]  - resignal = FALSE
[17:40:20.642]  - Number of conditions: 54
[17:40:20.643] signalConditions() ... done
[17:40:20.643] result() for MulticoreFuture ... done
[17:40:20.643] result() for MulticoreFuture ...
[17:40:20.643] result() for MulticoreFuture ... done
[17:40:20.643] signalConditions() ...
[17:40:20.643]  - include = ‘immediateCondition’
[17:40:20.644]  - exclude = 
[17:40:20.644]  - resignal = FALSE
[17:40:20.644]  - Number of conditions: 54
[17:40:20.644] signalConditions() ... done
[17:40:20.644] Future state: ‘finished’
[17:40:20.644] result() for MulticoreFuture ...
[17:40:20.645] result() for MulticoreFuture ... done
[17:40:20.645] signalConditions() ...
[17:40:20.645]  - include = ‘condition’
[17:40:20.645]  - exclude = ‘immediateCondition’
[17:40:20.645]  - resignal = TRUE
[17:40:20.645]  - Number of conditions: 54
[17:40:20.645]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.600] getGlobalsAndPackages() ...
[17:40:20.646]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.600] Searching for globals...
[17:40:20.646]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.609] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:40:20.646]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.610] Searching for globals ... DONE
[17:40:20.646]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.610] Resolving globals: FALSE
[17:40:20.647]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.611] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[17:40:20.647]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.612] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:40:20.647]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.612] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:40:20.647]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.612] 
[17:40:20.647]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.613] getGlobalsAndPackages() ... DONE
[17:40:20.648]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.613] run() for ‘Future’ ...
[17:40:20.648]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.614] - state: ‘created’
[17:40:20.648]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.614] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:20.648]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.614] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:20.648]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:20.649]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.615]   - Field: ‘label’
[17:40:20.649]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.615]   - Field: ‘local’
[17:40:20.649]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.615]   - Field: ‘owner’
[17:40:20.649]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.615]   - Field: ‘envir’
[17:40:20.649]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.616]   - Field: ‘packages’
[17:40:20.649]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.616]   - Field: ‘gc’
[17:40:20.650]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.616]   - Field: ‘conditions’
[17:40:20.650]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.616]   - Field: ‘expr’
[17:40:20.650]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.616]   - Field: ‘uuid’
[17:40:20.650]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.617]   - Field: ‘seed’
[17:40:20.650]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.617]   - Field: ‘version’
[17:40:20.650]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.617]   - Field: ‘result’
[17:40:20.651]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.617]   - Field: ‘asynchronous’
[17:40:20.651]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.617]   - Field: ‘calls’
[17:40:20.651]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.617]   - Field: ‘globals’
[17:40:20.651]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.618]   - Field: ‘stdout’
[17:40:20.651]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.618]   - Field: ‘earlySignal’
[17:40:20.652]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.618]   - Field: ‘lazy’
[17:40:20.652]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.618]   - Field: ‘state’
[17:40:20.652]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:20.652]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.618] - Launch lazy future ...
[17:40:20.652]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.619] Packages needed by the future expression (n = 0): <none>
[17:40:20.652]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.619] Packages needed by future strategies (n = 0): <none>
[17:40:20.653]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.620] {
[17:40:20.620]     {
[17:40:20.620]         {
[17:40:20.620]             ...future.startTime <- base::Sys.time()
[17:40:20.620]             {
[17:40:20.620]                 {
[17:40:20.620]                   {
[17:40:20.620]                     base::local({
[17:40:20.620]                       has_future <- base::requireNamespace("future", 
[17:40:20.620]                         quietly = TRUE)
[17:40:20.620]                       if (has_future) {
[17:40:20.620]                         ns <- base::getNamespace("future")
[17:40:20.620]                         version <- ns[[".package"]][["version"]]
[17:40:20.620]                         if (is.null(version)) 
[17:40:20.620]                           version <- utils::packageVersion("future")
[17:40:20.620]                       }
[17:40:20.620]                       else {
[17:40:20.620]                         version <- NULL
[17:40:20.620]                       }
[17:40:20.620]                       if (!has_future || version < "1.8.0") {
[17:40:20.620]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.620]                           "", base::R.version$version.string), 
[17:40:20.620]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:20.620]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.620]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.620]                             "release", "version")], collapse = " "), 
[17:40:20.620]                           hostname = base::Sys.info()[["nodename"]])
[17:40:20.620]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.620]                           info)
[17:40:20.620]                         info <- base::paste(info, collapse = "; ")
[17:40:20.620]                         if (!has_future) {
[17:40:20.620]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.620]                             info)
[17:40:20.620]                         }
[17:40:20.620]                         else {
[17:40:20.620]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.620]                             info, version)
[17:40:20.620]                         }
[17:40:20.620]                         base::stop(msg)
[17:40:20.620]                       }
[17:40:20.620]                     })
[17:40:20.620]                   }
[17:40:20.620]                   ...future.strategy.old <- future::plan("list")
[17:40:20.620]                   options(future.plan = NULL)
[17:40:20.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:20.620]                 }
[17:40:20.620]                 ...future.workdir <- getwd()
[17:40:20.620]             }
[17:40:20.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.620]         }
[17:40:20.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.620]             base::names(...future.oldOptions))
[17:40:20.620]     }
[17:40:20.620]     if (FALSE) {
[17:40:20.620]     }
[17:40:20.620]     else {
[17:40:20.620]         if (TRUE) {
[17:40:20.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.620]                 open = "w")
[17:40:20.620]         }
[17:40:20.620]         else {
[17:40:20.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.620]         }
[17:40:20.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.620]             base::sink(type = "output", split = FALSE)
[17:40:20.620]             base::close(...future.stdout)
[17:40:20.620]         }, add = TRUE)
[17:40:20.620]     }
[17:40:20.620]     ...future.frame <- base::sys.nframe()
[17:40:20.620]     ...future.conditions <- base::list()
[17:40:20.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.620]     if (FALSE) {
[17:40:20.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.620]     }
[17:40:20.620]     ...future.result <- base::tryCatch({
[17:40:20.620]         base::withCallingHandlers({
[17:40:20.620]             ...future.value <- base::withVisible(base::local({
[17:40:20.620]                 b <- 2L
[17:40:20.620]                 plan_b <- future::plan("list")
[17:40:20.620]                 nested_b <- nested_a[-1]
[17:40:20.620]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:20.620]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:20.620]                   "sequential"))
[17:40:20.620]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:20.620]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:20.620]             }))
[17:40:20.620]             future::FutureResult(value = ...future.value$value, 
[17:40:20.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.620]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.620]                     ...future.globalenv.names))
[17:40:20.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.620]         }, condition = base::local({
[17:40:20.620]             c <- base::c
[17:40:20.620]             inherits <- base::inherits
[17:40:20.620]             invokeRestart <- base::invokeRestart
[17:40:20.620]             length <- base::length
[17:40:20.620]             list <- base::list
[17:40:20.620]             seq.int <- base::seq.int
[17:40:20.620]             signalCondition <- base::signalCondition
[17:40:20.620]             sys.calls <- base::sys.calls
[17:40:20.620]             `[[` <- base::`[[`
[17:40:20.620]             `+` <- base::`+`
[17:40:20.620]             `<<-` <- base::`<<-`
[17:40:20.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.620]                   3L)]
[17:40:20.620]             }
[17:40:20.620]             function(cond) {
[17:40:20.620]                 is_error <- inherits(cond, "error")
[17:40:20.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.620]                   NULL)
[17:40:20.620]                 if (is_error) {
[17:40:20.620]                   sessionInformation <- function() {
[17:40:20.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.620]                       search = base::search(), system = base::Sys.info())
[17:40:20.620]                   }
[17:40:20.620]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.620]                     cond$call), session = sessionInformation(), 
[17:40:20.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.620]                   signalCondition(cond)
[17:40:20.620]                 }
[17:40:20.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.620]                 "immediateCondition"))) {
[17:40:20.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.620]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.620]                   if (TRUE && !signal) {
[17:40:20.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.620]                     {
[17:40:20.620]                       inherits <- base::inherits
[17:40:20.620]                       invokeRestart <- base::invokeRestart
[17:40:20.620]                       is.null <- base::is.null
[17:40:20.620]                       muffled <- FALSE
[17:40:20.620]                       if (inherits(cond, "message")) {
[17:40:20.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.620]                         if (muffled) 
[17:40:20.620]                           invokeRestart("muffleMessage")
[17:40:20.620]                       }
[17:40:20.620]                       else if (inherits(cond, "warning")) {
[17:40:20.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.620]                         if (muffled) 
[17:40:20.620]                           invokeRestart("muffleWarning")
[17:40:20.620]                       }
[17:40:20.620]                       else if (inherits(cond, "condition")) {
[17:40:20.620]                         if (!is.null(pattern)) {
[17:40:20.620]                           computeRestarts <- base::computeRestarts
[17:40:20.620]                           grepl <- base::grepl
[17:40:20.620]                           restarts <- computeRestarts(cond)
[17:40:20.620]                           for (restart in restarts) {
[17:40:20.620]                             name <- restart$name
[17:40:20.620]                             if (is.null(name)) 
[17:40:20.620]                               next
[17:40:20.620]                             if (!grepl(pattern, name)) 
[17:40:20.620]                               next
[17:40:20.620]                             invokeRestart(restart)
[17:40:20.620]                             muffled <- TRUE
[17:40:20.620]                             break
[17:40:20.620]                           }
[17:40:20.620]                         }
[17:40:20.620]                       }
[17:40:20.620]                       invisible(muffled)
[17:40:20.620]                     }
[17:40:20.620]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.620]                   }
[17:40:20.620]                 }
[17:40:20.620]                 else {
[17:40:20.620]                   if (TRUE) {
[17:40:20.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.620]                     {
[17:40:20.620]                       inherits <- base::inherits
[17:40:20.620]                       invokeRestart <- base::invokeRestart
[17:40:20.620]                       is.null <- base::is.null
[17:40:20.620]                       muffled <- FALSE
[17:40:20.620]                       if (inherits(cond, "message")) {
[17:40:20.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.620]                         if (muffled) 
[17:40:20.620]                           invokeRestart("muffleMessage")
[17:40:20.620]                       }
[17:40:20.620]                       else if (inherits(cond, "warning")) {
[17:40:20.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.620]                         if (muffled) 
[17:40:20.620]                           invokeRestart("muffleWarning")
[17:40:20.620]                       }
[17:40:20.620]                       else if (inherits(cond, "condition")) {
[17:40:20.620]                         if (!is.null(pattern)) {
[17:40:20.620]                           computeRestarts <- base::computeRestarts
[17:40:20.620]                           grepl <- base::grepl
[17:40:20.620]                           restarts <- computeRestarts(cond)
[17:40:20.620]                           for (restart in restarts) {
[17:40:20.620]                             name <- restart$name
[17:40:20.620]                             if (is.null(name)) 
[17:40:20.620]                               next
[17:40:20.620]                             if (!grepl(pattern, name)) 
[17:40:20.620]                               next
[17:40:20.620]                             invokeRestart(restart)
[17:40:20.620]                             muffled <- TRUE
[17:40:20.620]                             break
[17:40:20.620]                           }
[17:40:20.620]                         }
[17:40:20.620]                       }
[17:40:20.620]                       invisible(muffled)
[17:40:20.620]                     }
[17:40:20.620]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.620]                   }
[17:40:20.620]                 }
[17:40:20.620]             }
[17:40:20.620]         }))
[17:40:20.620]     }, error = function(ex) {
[17:40:20.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.620]                 ...future.rng), started = ...future.startTime, 
[17:40:20.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.620]             version = "1.8"), class = "FutureResult")
[17:40:20.620]     }, finally = {
[17:40:20.620]         if (!identical(...future.workdir, getwd())) 
[17:40:20.620]             setwd(...future.workdir)
[17:40:20.620]         {
[17:40:20.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.620]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.620]             }
[17:40:20.620]             base::options(...future.oldOptions)
[17:40:20.620]             if (.Platform$OS.type == "windows") {
[17:40:20.620]                 old_names <- names(...future.oldEnvVars)
[17:40:20.620]                 envs <- base::Sys.getenv()
[17:40:20.620]                 names <- names(envs)
[17:40:20.620]                 common <- intersect(names, old_names)
[17:40:20.620]                 added <- setdiff(names, old_names)
[17:40:20.620]                 removed <- setdiff(old_names, names)
[17:40:20.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.620]                   envs[common]]
[17:40:20.620]                 NAMES <- toupper(changed)
[17:40:20.620]                 args <- list()
[17:40:20.620]                 for (kk in seq_along(NAMES)) {
[17:40:20.620]                   name <- changed[[kk]]
[17:40:20.620]                   NAME <- NAMES[[kk]]
[17:40:20.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.620]                     next
[17:40:20.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.620]                 }
[17:40:20.620]                 NAMES <- toupper(added)
[17:40:20.620]                 for (kk in seq_along(NAMES)) {
[17:40:20.620]                   name <- added[[kk]]
[17:40:20.620]                   NAME <- NAMES[[kk]]
[17:40:20.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.620]                     next
[17:40:20.620]                   args[[name]] <- ""
[17:40:20.620]                 }
[17:40:20.620]                 NAMES <- toupper(removed)
[17:40:20.620]                 for (kk in seq_along(NAMES)) {
[17:40:20.620]                   name <- removed[[kk]]
[17:40:20.620]                   NAME <- NAMES[[kk]]
[17:40:20.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.620]                     next
[17:40:20.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.620]                 }
[17:40:20.620]                 if (length(args) > 0) 
[17:40:20.620]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.620]             }
[17:40:20.620]             else {
[17:40:20.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.620]             }
[17:40:20.620]             {
[17:40:20.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.620]                   0L) {
[17:40:20.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.620]                   base::options(opts)
[17:40:20.620]                 }
[17:40:20.620]                 {
[17:40:20.620]                   {
[17:40:20.620]                     NULL
[17:40:20.620]                     RNGkind("Mersenne-Twister")
[17:40:20.620]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:20.620]                       inherits = FALSE)
[17:40:20.620]                   }
[17:40:20.620]                   options(future.plan = NULL)
[17:40:20.620]                   if (is.na(NA_character_)) 
[17:40:20.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.620]                     .init = FALSE)
[17:40:20.620]                 }
[17:40:20.620]             }
[17:40:20.620]         }
[17:40:20.620]     })
[17:40:20.620]     if (TRUE) {
[17:40:20.620]         base::sink(type = "output", split = FALSE)
[17:40:20.620]         if (TRUE) {
[17:40:20.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.620]         }
[17:40:20.620]         else {
[17:40:20.620]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.620]         }
[17:40:20.620]         base::close(...future.stdout)
[17:40:20.620]         ...future.stdout <- NULL
[17:40:20.620]     }
[17:40:20.620]     ...future.result$conditions <- ...future.conditions
[17:40:20.620]     ...future.result$finished <- base::Sys.time()
[17:40:20.620]     ...future.result
[17:40:20.620] }
[17:40:20.653]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.622] assign_globals() ...
[17:40:20.653]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.622] List of 3
[17:40:20.622]  $ nested_a:List of 1
[17:40:20.622]   ..$ b:function (..., envir = parent.frame())  
[17:40:20.622]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:20.622]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.622]  $ a       : int 1
[17:40:20.622]  $ plan_a  :List of 1
[17:40:20.622]   ..$ b:function (..., envir = parent.frame())  
[17:40:20.622]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[17:40:20.622]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.622]  - attr(*, "where")=List of 3
[17:40:20.622]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:40:20.622]   ..$ a       :<environment: R_EmptyEnv> 
[17:40:20.622]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:40:20.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.622]  - attr(*, "resolved")= logi FALSE
[17:40:20.622]  - attr(*, "total_size")= num 23080
[17:40:20.622]  - attr(*, "already-done")= logi TRUE
[17:40:20.653]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.630] - copied ‘nested_a’ to environment
[17:40:20.653]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.630] - copied ‘a’ to environment
[17:40:20.653]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.630] - copied ‘plan_a’ to environment
[17:40:20.654]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.630] assign_globals() ... done
[17:40:20.654]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.631] plan(): Setting new future strategy stack:
[17:40:20.654]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.631] List of future strategies:
[17:40:20.631] 1. sequential:
[17:40:20.631]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.631]    - tweaked: FALSE
[17:40:20.631]    - call: NULL
[17:40:20.654]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.632] plan(): nbrOfWorkers() = 1
[17:40:20.654]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.633] plan(): Setting new future strategy stack:
[17:40:20.654]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.633] List of future strategies:
[17:40:20.633] 1. sequential:
[17:40:20.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.633]    - tweaked: FALSE
[17:40:20.633]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.655]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.634] plan(): nbrOfWorkers() = 1
[17:40:20.655]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.634] SequentialFuture started (and completed)
[17:40:20.655]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.634] - Launch lazy future ... done
[17:40:20.655]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.634] run() for ‘SequentialFuture’ ... done
[17:40:20.655] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:20.662] getGlobalsAndPackages() ...
[17:40:20.662] Searching for globals...
[17:40:20.663] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:20.664] Searching for globals ... DONE
[17:40:20.664] Resolving globals: FALSE
[17:40:20.665] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:20.665] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:20.665] - globals: [1] ‘data’
[17:40:20.665] - packages: [1] ‘future’
[17:40:20.665] getGlobalsAndPackages() ... DONE
[17:40:20.666] run() for ‘Future’ ...
[17:40:20.666] - state: ‘created’
[17:40:20.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.670] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.670] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:20.670]   - Field: ‘label’
[17:40:20.670]   - Field: ‘local’
[17:40:20.671]   - Field: ‘owner’
[17:40:20.671]   - Field: ‘envir’
[17:40:20.671]   - Field: ‘workers’
[17:40:20.671]   - Field: ‘packages’
[17:40:20.671]   - Field: ‘gc’
[17:40:20.671]   - Field: ‘job’
[17:40:20.671]   - Field: ‘conditions’
[17:40:20.671]   - Field: ‘expr’
[17:40:20.671]   - Field: ‘uuid’
[17:40:20.672]   - Field: ‘seed’
[17:40:20.672]   - Field: ‘version’
[17:40:20.672]   - Field: ‘result’
[17:40:20.672]   - Field: ‘asynchronous’
[17:40:20.672]   - Field: ‘calls’
[17:40:20.672]   - Field: ‘globals’
[17:40:20.672]   - Field: ‘stdout’
[17:40:20.672]   - Field: ‘earlySignal’
[17:40:20.672]   - Field: ‘lazy’
[17:40:20.673]   - Field: ‘state’
[17:40:20.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:20.673] - Launch lazy future ...
[17:40:20.673] Packages needed by the future expression (n = 1): ‘future’
[17:40:20.673] Packages needed by future strategies (n = 1): ‘future’
[17:40:20.674] {
[17:40:20.674]     {
[17:40:20.674]         {
[17:40:20.674]             ...future.startTime <- base::Sys.time()
[17:40:20.674]             {
[17:40:20.674]                 {
[17:40:20.674]                   {
[17:40:20.674]                     {
[17:40:20.674]                       {
[17:40:20.674]                         base::local({
[17:40:20.674]                           has_future <- base::requireNamespace("future", 
[17:40:20.674]                             quietly = TRUE)
[17:40:20.674]                           if (has_future) {
[17:40:20.674]                             ns <- base::getNamespace("future")
[17:40:20.674]                             version <- ns[[".package"]][["version"]]
[17:40:20.674]                             if (is.null(version)) 
[17:40:20.674]                               version <- utils::packageVersion("future")
[17:40:20.674]                           }
[17:40:20.674]                           else {
[17:40:20.674]                             version <- NULL
[17:40:20.674]                           }
[17:40:20.674]                           if (!has_future || version < "1.8.0") {
[17:40:20.674]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.674]                               "", base::R.version$version.string), 
[17:40:20.674]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:20.674]                                 base::R.version$platform, 8 * 
[17:40:20.674]                                   base::.Machine$sizeof.pointer), 
[17:40:20.674]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.674]                                 "release", "version")], collapse = " "), 
[17:40:20.674]                               hostname = base::Sys.info()[["nodename"]])
[17:40:20.674]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.674]                               info)
[17:40:20.674]                             info <- base::paste(info, collapse = "; ")
[17:40:20.674]                             if (!has_future) {
[17:40:20.674]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.674]                                 info)
[17:40:20.674]                             }
[17:40:20.674]                             else {
[17:40:20.674]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.674]                                 info, version)
[17:40:20.674]                             }
[17:40:20.674]                             base::stop(msg)
[17:40:20.674]                           }
[17:40:20.674]                         })
[17:40:20.674]                       }
[17:40:20.674]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.674]                       base::options(mc.cores = 1L)
[17:40:20.674]                     }
[17:40:20.674]                     base::local({
[17:40:20.674]                       for (pkg in "future") {
[17:40:20.674]                         base::loadNamespace(pkg)
[17:40:20.674]                         base::library(pkg, character.only = TRUE)
[17:40:20.674]                       }
[17:40:20.674]                     })
[17:40:20.674]                   }
[17:40:20.674]                   ...future.strategy.old <- future::plan("list")
[17:40:20.674]                   options(future.plan = NULL)
[17:40:20.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.674]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:20.674]                   {
[17:40:20.674]                     future <- SequentialFuture(..., envir = envir)
[17:40:20.674]                     if (!future$lazy) 
[17:40:20.674]                       future <- run(future)
[17:40:20.674]                     invisible(future)
[17:40:20.674]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:20.674]                 }
[17:40:20.674]                 ...future.workdir <- getwd()
[17:40:20.674]             }
[17:40:20.674]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.674]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.674]         }
[17:40:20.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.674]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.674]             base::names(...future.oldOptions))
[17:40:20.674]     }
[17:40:20.674]     if (FALSE) {
[17:40:20.674]     }
[17:40:20.674]     else {
[17:40:20.674]         if (TRUE) {
[17:40:20.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.674]                 open = "w")
[17:40:20.674]         }
[17:40:20.674]         else {
[17:40:20.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.674]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.674]         }
[17:40:20.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.674]             base::sink(type = "output", split = FALSE)
[17:40:20.674]             base::close(...future.stdout)
[17:40:20.674]         }, add = TRUE)
[17:40:20.674]     }
[17:40:20.674]     ...future.frame <- base::sys.nframe()
[17:40:20.674]     ...future.conditions <- base::list()
[17:40:20.674]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.674]     if (FALSE) {
[17:40:20.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.674]     }
[17:40:20.674]     ...future.result <- base::tryCatch({
[17:40:20.674]         base::withCallingHandlers({
[17:40:20.674]             ...future.value <- base::withVisible(base::local({
[17:40:20.674]                 withCallingHandlers({
[17:40:20.674]                   {
[17:40:20.674]                     value(future(subset(data, a == 2)))
[17:40:20.674]                   }
[17:40:20.674]                 }, immediateCondition = function(cond) {
[17:40:20.674]                   save_rds <- function (object, pathname, ...) 
[17:40:20.674]                   {
[17:40:20.674]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:20.674]                     if (file_test("-f", pathname_tmp)) {
[17:40:20.674]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.674]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:20.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.674]                         fi_tmp[["mtime"]])
[17:40:20.674]                     }
[17:40:20.674]                     tryCatch({
[17:40:20.674]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:20.674]                     }, error = function(ex) {
[17:40:20.674]                       msg <- conditionMessage(ex)
[17:40:20.674]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.674]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:20.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.674]                         fi_tmp[["mtime"]], msg)
[17:40:20.674]                       ex$message <- msg
[17:40:20.674]                       stop(ex)
[17:40:20.674]                     })
[17:40:20.674]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:20.674]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:20.674]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:20.674]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.674]                       fi <- file.info(pathname)
[17:40:20.674]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:20.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.674]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:20.674]                         fi[["size"]], fi[["mtime"]])
[17:40:20.674]                       stop(msg)
[17:40:20.674]                     }
[17:40:20.674]                     invisible(pathname)
[17:40:20.674]                   }
[17:40:20.674]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:20.674]                     rootPath = tempdir()) 
[17:40:20.674]                   {
[17:40:20.674]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:20.674]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:20.674]                       tmpdir = path, fileext = ".rds")
[17:40:20.674]                     save_rds(obj, file)
[17:40:20.674]                   }
[17:40:20.674]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:20.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.674]                   {
[17:40:20.674]                     inherits <- base::inherits
[17:40:20.674]                     invokeRestart <- base::invokeRestart
[17:40:20.674]                     is.null <- base::is.null
[17:40:20.674]                     muffled <- FALSE
[17:40:20.674]                     if (inherits(cond, "message")) {
[17:40:20.674]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.674]                       if (muffled) 
[17:40:20.674]                         invokeRestart("muffleMessage")
[17:40:20.674]                     }
[17:40:20.674]                     else if (inherits(cond, "warning")) {
[17:40:20.674]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.674]                       if (muffled) 
[17:40:20.674]                         invokeRestart("muffleWarning")
[17:40:20.674]                     }
[17:40:20.674]                     else if (inherits(cond, "condition")) {
[17:40:20.674]                       if (!is.null(pattern)) {
[17:40:20.674]                         computeRestarts <- base::computeRestarts
[17:40:20.674]                         grepl <- base::grepl
[17:40:20.674]                         restarts <- computeRestarts(cond)
[17:40:20.674]                         for (restart in restarts) {
[17:40:20.674]                           name <- restart$name
[17:40:20.674]                           if (is.null(name)) 
[17:40:20.674]                             next
[17:40:20.674]                           if (!grepl(pattern, name)) 
[17:40:20.674]                             next
[17:40:20.674]                           invokeRestart(restart)
[17:40:20.674]                           muffled <- TRUE
[17:40:20.674]                           break
[17:40:20.674]                         }
[17:40:20.674]                       }
[17:40:20.674]                     }
[17:40:20.674]                     invisible(muffled)
[17:40:20.674]                   }
[17:40:20.674]                   muffleCondition(cond)
[17:40:20.674]                 })
[17:40:20.674]             }))
[17:40:20.674]             future::FutureResult(value = ...future.value$value, 
[17:40:20.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.674]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.674]                     ...future.globalenv.names))
[17:40:20.674]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.674]         }, condition = base::local({
[17:40:20.674]             c <- base::c
[17:40:20.674]             inherits <- base::inherits
[17:40:20.674]             invokeRestart <- base::invokeRestart
[17:40:20.674]             length <- base::length
[17:40:20.674]             list <- base::list
[17:40:20.674]             seq.int <- base::seq.int
[17:40:20.674]             signalCondition <- base::signalCondition
[17:40:20.674]             sys.calls <- base::sys.calls
[17:40:20.674]             `[[` <- base::`[[`
[17:40:20.674]             `+` <- base::`+`
[17:40:20.674]             `<<-` <- base::`<<-`
[17:40:20.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.674]                   3L)]
[17:40:20.674]             }
[17:40:20.674]             function(cond) {
[17:40:20.674]                 is_error <- inherits(cond, "error")
[17:40:20.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.674]                   NULL)
[17:40:20.674]                 if (is_error) {
[17:40:20.674]                   sessionInformation <- function() {
[17:40:20.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.674]                       search = base::search(), system = base::Sys.info())
[17:40:20.674]                   }
[17:40:20.674]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.674]                     cond$call), session = sessionInformation(), 
[17:40:20.674]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.674]                   signalCondition(cond)
[17:40:20.674]                 }
[17:40:20.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.674]                 "immediateCondition"))) {
[17:40:20.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.674]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.674]                   if (TRUE && !signal) {
[17:40:20.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.674]                     {
[17:40:20.674]                       inherits <- base::inherits
[17:40:20.674]                       invokeRestart <- base::invokeRestart
[17:40:20.674]                       is.null <- base::is.null
[17:40:20.674]                       muffled <- FALSE
[17:40:20.674]                       if (inherits(cond, "message")) {
[17:40:20.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.674]                         if (muffled) 
[17:40:20.674]                           invokeRestart("muffleMessage")
[17:40:20.674]                       }
[17:40:20.674]                       else if (inherits(cond, "warning")) {
[17:40:20.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.674]                         if (muffled) 
[17:40:20.674]                           invokeRestart("muffleWarning")
[17:40:20.674]                       }
[17:40:20.674]                       else if (inherits(cond, "condition")) {
[17:40:20.674]                         if (!is.null(pattern)) {
[17:40:20.674]                           computeRestarts <- base::computeRestarts
[17:40:20.674]                           grepl <- base::grepl
[17:40:20.674]                           restarts <- computeRestarts(cond)
[17:40:20.674]                           for (restart in restarts) {
[17:40:20.674]                             name <- restart$name
[17:40:20.674]                             if (is.null(name)) 
[17:40:20.674]                               next
[17:40:20.674]                             if (!grepl(pattern, name)) 
[17:40:20.674]                               next
[17:40:20.674]                             invokeRestart(restart)
[17:40:20.674]                             muffled <- TRUE
[17:40:20.674]                             break
[17:40:20.674]                           }
[17:40:20.674]                         }
[17:40:20.674]                       }
[17:40:20.674]                       invisible(muffled)
[17:40:20.674]                     }
[17:40:20.674]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.674]                   }
[17:40:20.674]                 }
[17:40:20.674]                 else {
[17:40:20.674]                   if (TRUE) {
[17:40:20.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.674]                     {
[17:40:20.674]                       inherits <- base::inherits
[17:40:20.674]                       invokeRestart <- base::invokeRestart
[17:40:20.674]                       is.null <- base::is.null
[17:40:20.674]                       muffled <- FALSE
[17:40:20.674]                       if (inherits(cond, "message")) {
[17:40:20.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.674]                         if (muffled) 
[17:40:20.674]                           invokeRestart("muffleMessage")
[17:40:20.674]                       }
[17:40:20.674]                       else if (inherits(cond, "warning")) {
[17:40:20.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.674]                         if (muffled) 
[17:40:20.674]                           invokeRestart("muffleWarning")
[17:40:20.674]                       }
[17:40:20.674]                       else if (inherits(cond, "condition")) {
[17:40:20.674]                         if (!is.null(pattern)) {
[17:40:20.674]                           computeRestarts <- base::computeRestarts
[17:40:20.674]                           grepl <- base::grepl
[17:40:20.674]                           restarts <- computeRestarts(cond)
[17:40:20.674]                           for (restart in restarts) {
[17:40:20.674]                             name <- restart$name
[17:40:20.674]                             if (is.null(name)) 
[17:40:20.674]                               next
[17:40:20.674]                             if (!grepl(pattern, name)) 
[17:40:20.674]                               next
[17:40:20.674]                             invokeRestart(restart)
[17:40:20.674]                             muffled <- TRUE
[17:40:20.674]                             break
[17:40:20.674]                           }
[17:40:20.674]                         }
[17:40:20.674]                       }
[17:40:20.674]                       invisible(muffled)
[17:40:20.674]                     }
[17:40:20.674]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.674]                   }
[17:40:20.674]                 }
[17:40:20.674]             }
[17:40:20.674]         }))
[17:40:20.674]     }, error = function(ex) {
[17:40:20.674]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.674]                 ...future.rng), started = ...future.startTime, 
[17:40:20.674]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.674]             version = "1.8"), class = "FutureResult")
[17:40:20.674]     }, finally = {
[17:40:20.674]         if (!identical(...future.workdir, getwd())) 
[17:40:20.674]             setwd(...future.workdir)
[17:40:20.674]         {
[17:40:20.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.674]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.674]             }
[17:40:20.674]             base::options(...future.oldOptions)
[17:40:20.674]             if (.Platform$OS.type == "windows") {
[17:40:20.674]                 old_names <- names(...future.oldEnvVars)
[17:40:20.674]                 envs <- base::Sys.getenv()
[17:40:20.674]                 names <- names(envs)
[17:40:20.674]                 common <- intersect(names, old_names)
[17:40:20.674]                 added <- setdiff(names, old_names)
[17:40:20.674]                 removed <- setdiff(old_names, names)
[17:40:20.674]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.674]                   envs[common]]
[17:40:20.674]                 NAMES <- toupper(changed)
[17:40:20.674]                 args <- list()
[17:40:20.674]                 for (kk in seq_along(NAMES)) {
[17:40:20.674]                   name <- changed[[kk]]
[17:40:20.674]                   NAME <- NAMES[[kk]]
[17:40:20.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.674]                     next
[17:40:20.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.674]                 }
[17:40:20.674]                 NAMES <- toupper(added)
[17:40:20.674]                 for (kk in seq_along(NAMES)) {
[17:40:20.674]                   name <- added[[kk]]
[17:40:20.674]                   NAME <- NAMES[[kk]]
[17:40:20.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.674]                     next
[17:40:20.674]                   args[[name]] <- ""
[17:40:20.674]                 }
[17:40:20.674]                 NAMES <- toupper(removed)
[17:40:20.674]                 for (kk in seq_along(NAMES)) {
[17:40:20.674]                   name <- removed[[kk]]
[17:40:20.674]                   NAME <- NAMES[[kk]]
[17:40:20.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.674]                     next
[17:40:20.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.674]                 }
[17:40:20.674]                 if (length(args) > 0) 
[17:40:20.674]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.674]             }
[17:40:20.674]             else {
[17:40:20.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.674]             }
[17:40:20.674]             {
[17:40:20.674]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.674]                   0L) {
[17:40:20.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.674]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.674]                   base::options(opts)
[17:40:20.674]                 }
[17:40:20.674]                 {
[17:40:20.674]                   {
[17:40:20.674]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.674]                     NULL
[17:40:20.674]                   }
[17:40:20.674]                   options(future.plan = NULL)
[17:40:20.674]                   if (is.na(NA_character_)) 
[17:40:20.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.674]                     .init = FALSE)
[17:40:20.674]                 }
[17:40:20.674]             }
[17:40:20.674]         }
[17:40:20.674]     })
[17:40:20.674]     if (TRUE) {
[17:40:20.674]         base::sink(type = "output", split = FALSE)
[17:40:20.674]         if (TRUE) {
[17:40:20.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.674]         }
[17:40:20.674]         else {
[17:40:20.674]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.674]         }
[17:40:20.674]         base::close(...future.stdout)
[17:40:20.674]         ...future.stdout <- NULL
[17:40:20.674]     }
[17:40:20.674]     ...future.result$conditions <- ...future.conditions
[17:40:20.674]     ...future.result$finished <- base::Sys.time()
[17:40:20.674]     ...future.result
[17:40:20.674] }
[17:40:20.676] assign_globals() ...
[17:40:20.677] List of 1
[17:40:20.677]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:20.677]   ..$ a: int [1:3] 1 2 3
[17:40:20.677]   ..$ b: int [1:3] 3 2 1
[17:40:20.677]  - attr(*, "where")=List of 1
[17:40:20.677]   ..$ data:<environment: R_EmptyEnv> 
[17:40:20.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.677]  - attr(*, "resolved")= logi FALSE
[17:40:20.677]  - attr(*, "total_size")= num 128
[17:40:20.677]  - attr(*, "already-done")= logi TRUE
[17:40:20.680] - copied ‘data’ to environment
[17:40:20.680] assign_globals() ... done
[17:40:20.680] requestCore(): workers = 2
[17:40:20.683] MulticoreFuture started
[17:40:20.683] - Launch lazy future ... done
[17:40:20.683] run() for ‘MulticoreFuture’ ... done
[17:40:20.684] result() for MulticoreFuture ...
[17:40:20.684] plan(): Setting new future strategy stack:
[17:40:20.684] List of future strategies:
[17:40:20.684] 1. sequential:
[17:40:20.684]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.684]    - tweaked: FALSE
[17:40:20.684]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.685] plan(): nbrOfWorkers() = 1
[17:40:20.709] plan(): Setting new future strategy stack:
[17:40:20.709] List of future strategies:
[17:40:20.709] 1. multicore:
[17:40:20.709]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.709]    - tweaked: FALSE
[17:40:20.709]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.709] 2. sequential:
[17:40:20.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.709]    - tweaked: FALSE
[17:40:20.709]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.714] plan(): nbrOfWorkers() = 2
[17:40:20.716] result() for MulticoreFuture ...
[17:40:20.716] result() for MulticoreFuture ... done
[17:40:20.716] signalConditions() ...
[17:40:20.716]  - include = ‘immediateCondition’
[17:40:20.716]  - exclude = 
[17:40:20.716]  - resignal = FALSE
[17:40:20.716]  - Number of conditions: 52
[17:40:20.717] signalConditions() ... done
[17:40:20.717] result() for MulticoreFuture ... done
[17:40:20.717] result() for MulticoreFuture ...
[17:40:20.717] result() for MulticoreFuture ... done
[17:40:20.717] signalConditions() ...
[17:40:20.717]  - include = ‘immediateCondition’
[17:40:20.718]  - exclude = 
[17:40:20.718]  - resignal = FALSE
[17:40:20.718]  - Number of conditions: 52
[17:40:20.718] signalConditions() ... done
[17:40:20.718] Future state: ‘finished’
[17:40:20.718] result() for MulticoreFuture ...
[17:40:20.719] result() for MulticoreFuture ... done
[17:40:20.719] signalConditions() ...
[17:40:20.719]  - include = ‘condition’
[17:40:20.719]  - exclude = ‘immediateCondition’
[17:40:20.719]  - resignal = TRUE
[17:40:20.719]  - Number of conditions: 52
[17:40:20.719]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.686] getGlobalsAndPackages() ...
[17:40:20.720]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.687] Searching for globals...
[17:40:20.720]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.688] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:20.720]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.689] Searching for globals ... DONE
[17:40:20.720]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.689] Resolving globals: FALSE
[17:40:20.720]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.690] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:20.721]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.691] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:20.721]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.691] - globals: [1] ‘data’
[17:40:20.721]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.691] 
[17:40:20.721]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.691] getGlobalsAndPackages() ... DONE
[17:40:20.721]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.692] run() for ‘Future’ ...
[17:40:20.721]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.692] - state: ‘created’
[17:40:20.722]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:20.722]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.693] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:20.722]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:20.722]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.693]   - Field: ‘label’
[17:40:20.722]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.693]   - Field: ‘local’
[17:40:20.722]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.694]   - Field: ‘owner’
[17:40:20.722]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.694]   - Field: ‘envir’
[17:40:20.723]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.694]   - Field: ‘packages’
[17:40:20.723]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.694]   - Field: ‘gc’
[17:40:20.723]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.694]   - Field: ‘conditions’
[17:40:20.723]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.694]   - Field: ‘expr’
[17:40:20.723]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘uuid’
[17:40:20.723]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘seed’
[17:40:20.723]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘version’
[17:40:20.724]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘result’
[17:40:20.724]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘asynchronous’
[17:40:20.724]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘calls’
[17:40:20.724]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.695]   - Field: ‘globals’
[17:40:20.724]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.696]   - Field: ‘stdout’
[17:40:20.724]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.696]   - Field: ‘earlySignal’
[17:40:20.725]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.696]   - Field: ‘lazy’
[17:40:20.725]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.696]   - Field: ‘state’
[17:40:20.725]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:20.725]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.697] - Launch lazy future ...
[17:40:20.725]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.697] Packages needed by the future expression (n = 0): <none>
[17:40:20.725]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.697] Packages needed by future strategies (n = 0): <none>
[17:40:20.725]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.698] {
[17:40:20.698]     {
[17:40:20.698]         {
[17:40:20.698]             ...future.startTime <- base::Sys.time()
[17:40:20.698]             {
[17:40:20.698]                 {
[17:40:20.698]                   {
[17:40:20.698]                     base::local({
[17:40:20.698]                       has_future <- base::requireNamespace("future", 
[17:40:20.698]                         quietly = TRUE)
[17:40:20.698]                       if (has_future) {
[17:40:20.698]                         ns <- base::getNamespace("future")
[17:40:20.698]                         version <- ns[[".package"]][["version"]]
[17:40:20.698]                         if (is.null(version)) 
[17:40:20.698]                           version <- utils::packageVersion("future")
[17:40:20.698]                       }
[17:40:20.698]                       else {
[17:40:20.698]                         version <- NULL
[17:40:20.698]                       }
[17:40:20.698]                       if (!has_future || version < "1.8.0") {
[17:40:20.698]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.698]                           "", base::R.version$version.string), 
[17:40:20.698]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:20.698]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.698]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.698]                             "release", "version")], collapse = " "), 
[17:40:20.698]                           hostname = base::Sys.info()[["nodename"]])
[17:40:20.698]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.698]                           info)
[17:40:20.698]                         info <- base::paste(info, collapse = "; ")
[17:40:20.698]                         if (!has_future) {
[17:40:20.698]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.698]                             info)
[17:40:20.698]                         }
[17:40:20.698]                         else {
[17:40:20.698]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.698]                             info, version)
[17:40:20.698]                         }
[17:40:20.698]                         base::stop(msg)
[17:40:20.698]                       }
[17:40:20.698]                     })
[17:40:20.698]                   }
[17:40:20.698]                   ...future.strategy.old <- future::plan("list")
[17:40:20.698]                   options(future.plan = NULL)
[17:40:20.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:20.698]                 }
[17:40:20.698]                 ...future.workdir <- getwd()
[17:40:20.698]             }
[17:40:20.698]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.698]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.698]         }
[17:40:20.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.698]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.698]             base::names(...future.oldOptions))
[17:40:20.698]     }
[17:40:20.698]     if (FALSE) {
[17:40:20.698]     }
[17:40:20.698]     else {
[17:40:20.698]         if (TRUE) {
[17:40:20.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.698]                 open = "w")
[17:40:20.698]         }
[17:40:20.698]         else {
[17:40:20.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.698]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.698]         }
[17:40:20.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.698]             base::sink(type = "output", split = FALSE)
[17:40:20.698]             base::close(...future.stdout)
[17:40:20.698]         }, add = TRUE)
[17:40:20.698]     }
[17:40:20.698]     ...future.frame <- base::sys.nframe()
[17:40:20.698]     ...future.conditions <- base::list()
[17:40:20.698]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.698]     if (FALSE) {
[17:40:20.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.698]     }
[17:40:20.698]     ...future.result <- base::tryCatch({
[17:40:20.698]         base::withCallingHandlers({
[17:40:20.698]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:40:20.698]                 a == 2)))
[17:40:20.698]             future::FutureResult(value = ...future.value$value, 
[17:40:20.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.698]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.698]                     ...future.globalenv.names))
[17:40:20.698]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.698]         }, condition = base::local({
[17:40:20.698]             c <- base::c
[17:40:20.698]             inherits <- base::inherits
[17:40:20.698]             invokeRestart <- base::invokeRestart
[17:40:20.698]             length <- base::length
[17:40:20.698]             list <- base::list
[17:40:20.698]             seq.int <- base::seq.int
[17:40:20.698]             signalCondition <- base::signalCondition
[17:40:20.698]             sys.calls <- base::sys.calls
[17:40:20.698]             `[[` <- base::`[[`
[17:40:20.698]             `+` <- base::`+`
[17:40:20.698]             `<<-` <- base::`<<-`
[17:40:20.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.698]                   3L)]
[17:40:20.698]             }
[17:40:20.698]             function(cond) {
[17:40:20.698]                 is_error <- inherits(cond, "error")
[17:40:20.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.698]                   NULL)
[17:40:20.698]                 if (is_error) {
[17:40:20.698]                   sessionInformation <- function() {
[17:40:20.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.698]                       search = base::search(), system = base::Sys.info())
[17:40:20.698]                   }
[17:40:20.698]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.698]                     cond$call), session = sessionInformation(), 
[17:40:20.698]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.698]                   signalCondition(cond)
[17:40:20.698]                 }
[17:40:20.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.698]                 "immediateCondition"))) {
[17:40:20.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.698]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.698]                   if (TRUE && !signal) {
[17:40:20.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.698]                     {
[17:40:20.698]                       inherits <- base::inherits
[17:40:20.698]                       invokeRestart <- base::invokeRestart
[17:40:20.698]                       is.null <- base::is.null
[17:40:20.698]                       muffled <- FALSE
[17:40:20.698]                       if (inherits(cond, "message")) {
[17:40:20.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.698]                         if (muffled) 
[17:40:20.698]                           invokeRestart("muffleMessage")
[17:40:20.698]                       }
[17:40:20.698]                       else if (inherits(cond, "warning")) {
[17:40:20.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.698]                         if (muffled) 
[17:40:20.698]                           invokeRestart("muffleWarning")
[17:40:20.698]                       }
[17:40:20.698]                       else if (inherits(cond, "condition")) {
[17:40:20.698]                         if (!is.null(pattern)) {
[17:40:20.698]                           computeRestarts <- base::computeRestarts
[17:40:20.698]                           grepl <- base::grepl
[17:40:20.698]                           restarts <- computeRestarts(cond)
[17:40:20.698]                           for (restart in restarts) {
[17:40:20.698]                             name <- restart$name
[17:40:20.698]                             if (is.null(name)) 
[17:40:20.698]                               next
[17:40:20.698]                             if (!grepl(pattern, name)) 
[17:40:20.698]                               next
[17:40:20.698]                             invokeRestart(restart)
[17:40:20.698]                             muffled <- TRUE
[17:40:20.698]                             break
[17:40:20.698]                           }
[17:40:20.698]                         }
[17:40:20.698]                       }
[17:40:20.698]                       invisible(muffled)
[17:40:20.698]                     }
[17:40:20.698]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.698]                   }
[17:40:20.698]                 }
[17:40:20.698]                 else {
[17:40:20.698]                   if (TRUE) {
[17:40:20.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.698]                     {
[17:40:20.698]                       inherits <- base::inherits
[17:40:20.698]                       invokeRestart <- base::invokeRestart
[17:40:20.698]                       is.null <- base::is.null
[17:40:20.698]                       muffled <- FALSE
[17:40:20.698]                       if (inherits(cond, "message")) {
[17:40:20.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.698]                         if (muffled) 
[17:40:20.698]                           invokeRestart("muffleMessage")
[17:40:20.698]                       }
[17:40:20.698]                       else if (inherits(cond, "warning")) {
[17:40:20.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.698]                         if (muffled) 
[17:40:20.698]                           invokeRestart("muffleWarning")
[17:40:20.698]                       }
[17:40:20.698]                       else if (inherits(cond, "condition")) {
[17:40:20.698]                         if (!is.null(pattern)) {
[17:40:20.698]                           computeRestarts <- base::computeRestarts
[17:40:20.698]                           grepl <- base::grepl
[17:40:20.698]                           restarts <- computeRestarts(cond)
[17:40:20.698]                           for (restart in restarts) {
[17:40:20.698]                             name <- restart$name
[17:40:20.698]                             if (is.null(name)) 
[17:40:20.698]                               next
[17:40:20.698]                             if (!grepl(pattern, name)) 
[17:40:20.698]                               next
[17:40:20.698]                             invokeRestart(restart)
[17:40:20.698]                             muffled <- TRUE
[17:40:20.698]                             break
[17:40:20.698]                           }
[17:40:20.698]                         }
[17:40:20.698]                       }
[17:40:20.698]                       invisible(muffled)
[17:40:20.698]                     }
[17:40:20.698]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.698]                   }
[17:40:20.698]                 }
[17:40:20.698]             }
[17:40:20.698]         }))
[17:40:20.698]     }, error = function(ex) {
[17:40:20.698]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.698]                 ...future.rng), started = ...future.startTime, 
[17:40:20.698]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.698]             version = "1.8"), class = "FutureResult")
[17:40:20.698]     }, finally = {
[17:40:20.698]         if (!identical(...future.workdir, getwd())) 
[17:40:20.698]             setwd(...future.workdir)
[17:40:20.698]         {
[17:40:20.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.698]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.698]             }
[17:40:20.698]             base::options(...future.oldOptions)
[17:40:20.698]             if (.Platform$OS.type == "windows") {
[17:40:20.698]                 old_names <- names(...future.oldEnvVars)
[17:40:20.698]                 envs <- base::Sys.getenv()
[17:40:20.698]                 names <- names(envs)
[17:40:20.698]                 common <- intersect(names, old_names)
[17:40:20.698]                 added <- setdiff(names, old_names)
[17:40:20.698]                 removed <- setdiff(old_names, names)
[17:40:20.698]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.698]                   envs[common]]
[17:40:20.698]                 NAMES <- toupper(changed)
[17:40:20.698]                 args <- list()
[17:40:20.698]                 for (kk in seq_along(NAMES)) {
[17:40:20.698]                   name <- changed[[kk]]
[17:40:20.698]                   NAME <- NAMES[[kk]]
[17:40:20.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.698]                     next
[17:40:20.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.698]                 }
[17:40:20.698]                 NAMES <- toupper(added)
[17:40:20.698]                 for (kk in seq_along(NAMES)) {
[17:40:20.698]                   name <- added[[kk]]
[17:40:20.698]                   NAME <- NAMES[[kk]]
[17:40:20.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.698]                     next
[17:40:20.698]                   args[[name]] <- ""
[17:40:20.698]                 }
[17:40:20.698]                 NAMES <- toupper(removed)
[17:40:20.698]                 for (kk in seq_along(NAMES)) {
[17:40:20.698]                   name <- removed[[kk]]
[17:40:20.698]                   NAME <- NAMES[[kk]]
[17:40:20.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.698]                     next
[17:40:20.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.698]                 }
[17:40:20.698]                 if (length(args) > 0) 
[17:40:20.698]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.698]             }
[17:40:20.698]             else {
[17:40:20.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.698]             }
[17:40:20.698]             {
[17:40:20.698]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.698]                   0L) {
[17:40:20.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.698]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.698]                   base::options(opts)
[17:40:20.698]                 }
[17:40:20.698]                 {
[17:40:20.698]                   {
[17:40:20.698]                     NULL
[17:40:20.698]                     RNGkind("Mersenne-Twister")
[17:40:20.698]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:20.698]                       inherits = FALSE)
[17:40:20.698]                   }
[17:40:20.698]                   options(future.plan = NULL)
[17:40:20.698]                   if (is.na(NA_character_)) 
[17:40:20.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.698]                     .init = FALSE)
[17:40:20.698]                 }
[17:40:20.698]             }
[17:40:20.698]         }
[17:40:20.698]     })
[17:40:20.698]     if (TRUE) {
[17:40:20.698]         base::sink(type = "output", split = FALSE)
[17:40:20.698]         if (TRUE) {
[17:40:20.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.698]         }
[17:40:20.698]         else {
[17:40:20.698]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.698]         }
[17:40:20.698]         base::close(...future.stdout)
[17:40:20.698]         ...future.stdout <- NULL
[17:40:20.698]     }
[17:40:20.698]     ...future.result$conditions <- ...future.conditions
[17:40:20.698]     ...future.result$finished <- base::Sys.time()
[17:40:20.698]     ...future.result
[17:40:20.698] }
[17:40:20.726]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.700] assign_globals() ...
[17:40:20.726]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.700] List of 1
[17:40:20.700]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:20.700]   ..$ a: int [1:3] 1 2 3
[17:40:20.700]   ..$ b: int [1:3] 3 2 1
[17:40:20.700]  - attr(*, "where")=List of 1
[17:40:20.700]   ..$ data:<environment: R_EmptyEnv> 
[17:40:20.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.700]  - attr(*, "resolved")= logi FALSE
[17:40:20.700]  - attr(*, "total_size")= num 128
[17:40:20.700]  - attr(*, "already-done")= logi TRUE
[17:40:20.726]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.705] - copied ‘data’ to environment
[17:40:20.726]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.705] assign_globals() ... done
[17:40:20.726]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.705] plan(): Setting new future strategy stack:
[17:40:20.726]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.705] List of future strategies:
[17:40:20.705] 1. sequential:
[17:40:20.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.705]    - tweaked: FALSE
[17:40:20.705]    - call: NULL
[17:40:20.727]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.706] plan(): nbrOfWorkers() = 1
[17:40:20.727]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.707] plan(): Setting new future strategy stack:
[17:40:20.727]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.707] List of future strategies:
[17:40:20.707] 1. sequential:
[17:40:20.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.707]    - tweaked: FALSE
[17:40:20.707]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.727]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.708] plan(): nbrOfWorkers() = 1
[17:40:20.727]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.708] SequentialFuture started (and completed)
[17:40:20.727]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.708] - Launch lazy future ... done
[17:40:20.727]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.709] run() for ‘SequentialFuture’ ... done
[17:40:20.728] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[17:40:20.728] plan(): Setting new future strategy stack:
[17:40:20.728] List of future strategies:
[17:40:20.728] 1. multicore:
[17:40:20.728]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.728]    - tweaked: FALSE
[17:40:20.728]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.728] 2. multicore:
[17:40:20.728]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.728]    - tweaked: FALSE
[17:40:20.728]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.733] plan(): nbrOfWorkers() = 2
[17:40:20.733] getGlobalsAndPackages() ...
[17:40:20.733] Searching for globals...
[17:40:20.756] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:20.756] Searching for globals ... DONE
[17:40:20.756] Resolving globals: FALSE
[17:40:20.757] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[17:40:20.758] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:20.758] - globals: [2] ‘nested’, ‘strategy2’
[17:40:20.758] - packages: [1] ‘future’
[17:40:20.758] getGlobalsAndPackages() ... DONE
[17:40:20.758] run() for ‘Future’ ...
[17:40:20.758] - state: ‘created’
[17:40:20.759] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:20.763]   - Field: ‘label’
[17:40:20.763]   - Field: ‘local’
[17:40:20.763]   - Field: ‘owner’
[17:40:20.763]   - Field: ‘envir’
[17:40:20.763]   - Field: ‘workers’
[17:40:20.763]   - Field: ‘packages’
[17:40:20.763]   - Field: ‘gc’
[17:40:20.763]   - Field: ‘job’
[17:40:20.763]   - Field: ‘conditions’
[17:40:20.764]   - Field: ‘expr’
[17:40:20.764]   - Field: ‘uuid’
[17:40:20.764]   - Field: ‘seed’
[17:40:20.764]   - Field: ‘version’
[17:40:20.764]   - Field: ‘result’
[17:40:20.764]   - Field: ‘asynchronous’
[17:40:20.764]   - Field: ‘calls’
[17:40:20.764]   - Field: ‘globals’
[17:40:20.764]   - Field: ‘stdout’
[17:40:20.765]   - Field: ‘earlySignal’
[17:40:20.765]   - Field: ‘lazy’
[17:40:20.765]   - Field: ‘state’
[17:40:20.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:20.765] - Launch lazy future ...
[17:40:20.765] Packages needed by the future expression (n = 1): ‘future’
[17:40:20.766] Packages needed by future strategies (n = 1): ‘future’
[17:40:20.766] {
[17:40:20.766]     {
[17:40:20.766]         {
[17:40:20.766]             ...future.startTime <- base::Sys.time()
[17:40:20.766]             {
[17:40:20.766]                 {
[17:40:20.766]                   {
[17:40:20.766]                     {
[17:40:20.766]                       {
[17:40:20.766]                         base::local({
[17:40:20.766]                           has_future <- base::requireNamespace("future", 
[17:40:20.766]                             quietly = TRUE)
[17:40:20.766]                           if (has_future) {
[17:40:20.766]                             ns <- base::getNamespace("future")
[17:40:20.766]                             version <- ns[[".package"]][["version"]]
[17:40:20.766]                             if (is.null(version)) 
[17:40:20.766]                               version <- utils::packageVersion("future")
[17:40:20.766]                           }
[17:40:20.766]                           else {
[17:40:20.766]                             version <- NULL
[17:40:20.766]                           }
[17:40:20.766]                           if (!has_future || version < "1.8.0") {
[17:40:20.766]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.766]                               "", base::R.version$version.string), 
[17:40:20.766]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:20.766]                                 base::R.version$platform, 8 * 
[17:40:20.766]                                   base::.Machine$sizeof.pointer), 
[17:40:20.766]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.766]                                 "release", "version")], collapse = " "), 
[17:40:20.766]                               hostname = base::Sys.info()[["nodename"]])
[17:40:20.766]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.766]                               info)
[17:40:20.766]                             info <- base::paste(info, collapse = "; ")
[17:40:20.766]                             if (!has_future) {
[17:40:20.766]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.766]                                 info)
[17:40:20.766]                             }
[17:40:20.766]                             else {
[17:40:20.766]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.766]                                 info, version)
[17:40:20.766]                             }
[17:40:20.766]                             base::stop(msg)
[17:40:20.766]                           }
[17:40:20.766]                         })
[17:40:20.766]                       }
[17:40:20.766]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.766]                       base::options(mc.cores = 1L)
[17:40:20.766]                     }
[17:40:20.766]                     base::local({
[17:40:20.766]                       for (pkg in "future") {
[17:40:20.766]                         base::loadNamespace(pkg)
[17:40:20.766]                         base::library(pkg, character.only = TRUE)
[17:40:20.766]                       }
[17:40:20.766]                     })
[17:40:20.766]                   }
[17:40:20.766]                   ...future.strategy.old <- future::plan("list")
[17:40:20.766]                   options(future.plan = NULL)
[17:40:20.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.766]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:20.766]                     envir = parent.frame()) 
[17:40:20.766]                   {
[17:40:20.766]                     default_workers <- missing(workers)
[17:40:20.766]                     if (is.function(workers)) 
[17:40:20.766]                       workers <- workers()
[17:40:20.766]                     workers <- structure(as.integer(workers), 
[17:40:20.766]                       class = class(workers))
[17:40:20.766]                     stop_if_not(is.finite(workers), workers >= 
[17:40:20.766]                       1L)
[17:40:20.766]                     if ((workers == 1L && !inherits(workers, 
[17:40:20.766]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:20.766]                       if (default_workers) 
[17:40:20.766]                         supportsMulticore(warn = TRUE)
[17:40:20.766]                       return(sequential(..., envir = envir))
[17:40:20.766]                     }
[17:40:20.766]                     oopts <- options(mc.cores = workers)
[17:40:20.766]                     on.exit(options(oopts))
[17:40:20.766]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:20.766]                       envir = envir)
[17:40:20.766]                     if (!future$lazy) 
[17:40:20.766]                       future <- run(future)
[17:40:20.766]                     invisible(future)
[17:40:20.766]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:20.766]                 }
[17:40:20.766]                 ...future.workdir <- getwd()
[17:40:20.766]             }
[17:40:20.766]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.766]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.766]         }
[17:40:20.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.766]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.766]             base::names(...future.oldOptions))
[17:40:20.766]     }
[17:40:20.766]     if (FALSE) {
[17:40:20.766]     }
[17:40:20.766]     else {
[17:40:20.766]         if (TRUE) {
[17:40:20.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.766]                 open = "w")
[17:40:20.766]         }
[17:40:20.766]         else {
[17:40:20.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.766]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.766]         }
[17:40:20.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.766]             base::sink(type = "output", split = FALSE)
[17:40:20.766]             base::close(...future.stdout)
[17:40:20.766]         }, add = TRUE)
[17:40:20.766]     }
[17:40:20.766]     ...future.frame <- base::sys.nframe()
[17:40:20.766]     ...future.conditions <- base::list()
[17:40:20.766]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.766]     if (FALSE) {
[17:40:20.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.766]     }
[17:40:20.766]     ...future.result <- base::tryCatch({
[17:40:20.766]         base::withCallingHandlers({
[17:40:20.766]             ...future.value <- base::withVisible(base::local({
[17:40:20.766]                 withCallingHandlers({
[17:40:20.766]                   {
[17:40:20.766]                     a <- 1L
[17:40:20.766]                     plan_a <- unclass(future::plan("list"))
[17:40:20.766]                     nested_a <- nested[-1]
[17:40:20.766]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:20.766]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:20.766]                       strategy2))
[17:40:20.766]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:20.766]                       "init") <- NULL
[17:40:20.766]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:20.766]                       "init") <- NULL
[17:40:20.766]                     stopifnot(all.equal(plan_a, nested_a))
[17:40:20.766]                     y %<-% {
[17:40:20.766]                       b <- 2L
[17:40:20.766]                       plan_b <- future::plan("list")
[17:40:20.766]                       nested_b <- nested_a[-1]
[17:40:20.766]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:20.766]                         1L, inherits(plan_b[[1]], "future"), 
[17:40:20.766]                         inherits(future::plan("next"), "sequential"))
[17:40:20.766]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:20.766]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:20.766]                     }
[17:40:20.766]                     y
[17:40:20.766]                   }
[17:40:20.766]                 }, immediateCondition = function(cond) {
[17:40:20.766]                   save_rds <- function (object, pathname, ...) 
[17:40:20.766]                   {
[17:40:20.766]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:20.766]                     if (file_test("-f", pathname_tmp)) {
[17:40:20.766]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.766]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:20.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.766]                         fi_tmp[["mtime"]])
[17:40:20.766]                     }
[17:40:20.766]                     tryCatch({
[17:40:20.766]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:20.766]                     }, error = function(ex) {
[17:40:20.766]                       msg <- conditionMessage(ex)
[17:40:20.766]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.766]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:20.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.766]                         fi_tmp[["mtime"]], msg)
[17:40:20.766]                       ex$message <- msg
[17:40:20.766]                       stop(ex)
[17:40:20.766]                     })
[17:40:20.766]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:20.766]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:20.766]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:20.766]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.766]                       fi <- file.info(pathname)
[17:40:20.766]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:20.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.766]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:20.766]                         fi[["size"]], fi[["mtime"]])
[17:40:20.766]                       stop(msg)
[17:40:20.766]                     }
[17:40:20.766]                     invisible(pathname)
[17:40:20.766]                   }
[17:40:20.766]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:20.766]                     rootPath = tempdir()) 
[17:40:20.766]                   {
[17:40:20.766]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:20.766]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:20.766]                       tmpdir = path, fileext = ".rds")
[17:40:20.766]                     save_rds(obj, file)
[17:40:20.766]                   }
[17:40:20.766]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:20.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.766]                   {
[17:40:20.766]                     inherits <- base::inherits
[17:40:20.766]                     invokeRestart <- base::invokeRestart
[17:40:20.766]                     is.null <- base::is.null
[17:40:20.766]                     muffled <- FALSE
[17:40:20.766]                     if (inherits(cond, "message")) {
[17:40:20.766]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.766]                       if (muffled) 
[17:40:20.766]                         invokeRestart("muffleMessage")
[17:40:20.766]                     }
[17:40:20.766]                     else if (inherits(cond, "warning")) {
[17:40:20.766]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.766]                       if (muffled) 
[17:40:20.766]                         invokeRestart("muffleWarning")
[17:40:20.766]                     }
[17:40:20.766]                     else if (inherits(cond, "condition")) {
[17:40:20.766]                       if (!is.null(pattern)) {
[17:40:20.766]                         computeRestarts <- base::computeRestarts
[17:40:20.766]                         grepl <- base::grepl
[17:40:20.766]                         restarts <- computeRestarts(cond)
[17:40:20.766]                         for (restart in restarts) {
[17:40:20.766]                           name <- restart$name
[17:40:20.766]                           if (is.null(name)) 
[17:40:20.766]                             next
[17:40:20.766]                           if (!grepl(pattern, name)) 
[17:40:20.766]                             next
[17:40:20.766]                           invokeRestart(restart)
[17:40:20.766]                           muffled <- TRUE
[17:40:20.766]                           break
[17:40:20.766]                         }
[17:40:20.766]                       }
[17:40:20.766]                     }
[17:40:20.766]                     invisible(muffled)
[17:40:20.766]                   }
[17:40:20.766]                   muffleCondition(cond)
[17:40:20.766]                 })
[17:40:20.766]             }))
[17:40:20.766]             future::FutureResult(value = ...future.value$value, 
[17:40:20.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.766]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.766]                     ...future.globalenv.names))
[17:40:20.766]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.766]         }, condition = base::local({
[17:40:20.766]             c <- base::c
[17:40:20.766]             inherits <- base::inherits
[17:40:20.766]             invokeRestart <- base::invokeRestart
[17:40:20.766]             length <- base::length
[17:40:20.766]             list <- base::list
[17:40:20.766]             seq.int <- base::seq.int
[17:40:20.766]             signalCondition <- base::signalCondition
[17:40:20.766]             sys.calls <- base::sys.calls
[17:40:20.766]             `[[` <- base::`[[`
[17:40:20.766]             `+` <- base::`+`
[17:40:20.766]             `<<-` <- base::`<<-`
[17:40:20.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.766]                   3L)]
[17:40:20.766]             }
[17:40:20.766]             function(cond) {
[17:40:20.766]                 is_error <- inherits(cond, "error")
[17:40:20.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.766]                   NULL)
[17:40:20.766]                 if (is_error) {
[17:40:20.766]                   sessionInformation <- function() {
[17:40:20.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.766]                       search = base::search(), system = base::Sys.info())
[17:40:20.766]                   }
[17:40:20.766]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.766]                     cond$call), session = sessionInformation(), 
[17:40:20.766]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.766]                   signalCondition(cond)
[17:40:20.766]                 }
[17:40:20.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.766]                 "immediateCondition"))) {
[17:40:20.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.766]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.766]                   if (TRUE && !signal) {
[17:40:20.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.766]                     {
[17:40:20.766]                       inherits <- base::inherits
[17:40:20.766]                       invokeRestart <- base::invokeRestart
[17:40:20.766]                       is.null <- base::is.null
[17:40:20.766]                       muffled <- FALSE
[17:40:20.766]                       if (inherits(cond, "message")) {
[17:40:20.766]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.766]                         if (muffled) 
[17:40:20.766]                           invokeRestart("muffleMessage")
[17:40:20.766]                       }
[17:40:20.766]                       else if (inherits(cond, "warning")) {
[17:40:20.766]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.766]                         if (muffled) 
[17:40:20.766]                           invokeRestart("muffleWarning")
[17:40:20.766]                       }
[17:40:20.766]                       else if (inherits(cond, "condition")) {
[17:40:20.766]                         if (!is.null(pattern)) {
[17:40:20.766]                           computeRestarts <- base::computeRestarts
[17:40:20.766]                           grepl <- base::grepl
[17:40:20.766]                           restarts <- computeRestarts(cond)
[17:40:20.766]                           for (restart in restarts) {
[17:40:20.766]                             name <- restart$name
[17:40:20.766]                             if (is.null(name)) 
[17:40:20.766]                               next
[17:40:20.766]                             if (!grepl(pattern, name)) 
[17:40:20.766]                               next
[17:40:20.766]                             invokeRestart(restart)
[17:40:20.766]                             muffled <- TRUE
[17:40:20.766]                             break
[17:40:20.766]                           }
[17:40:20.766]                         }
[17:40:20.766]                       }
[17:40:20.766]                       invisible(muffled)
[17:40:20.766]                     }
[17:40:20.766]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.766]                   }
[17:40:20.766]                 }
[17:40:20.766]                 else {
[17:40:20.766]                   if (TRUE) {
[17:40:20.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.766]                     {
[17:40:20.766]                       inherits <- base::inherits
[17:40:20.766]                       invokeRestart <- base::invokeRestart
[17:40:20.766]                       is.null <- base::is.null
[17:40:20.766]                       muffled <- FALSE
[17:40:20.766]                       if (inherits(cond, "message")) {
[17:40:20.766]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.766]                         if (muffled) 
[17:40:20.766]                           invokeRestart("muffleMessage")
[17:40:20.766]                       }
[17:40:20.766]                       else if (inherits(cond, "warning")) {
[17:40:20.766]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.766]                         if (muffled) 
[17:40:20.766]                           invokeRestart("muffleWarning")
[17:40:20.766]                       }
[17:40:20.766]                       else if (inherits(cond, "condition")) {
[17:40:20.766]                         if (!is.null(pattern)) {
[17:40:20.766]                           computeRestarts <- base::computeRestarts
[17:40:20.766]                           grepl <- base::grepl
[17:40:20.766]                           restarts <- computeRestarts(cond)
[17:40:20.766]                           for (restart in restarts) {
[17:40:20.766]                             name <- restart$name
[17:40:20.766]                             if (is.null(name)) 
[17:40:20.766]                               next
[17:40:20.766]                             if (!grepl(pattern, name)) 
[17:40:20.766]                               next
[17:40:20.766]                             invokeRestart(restart)
[17:40:20.766]                             muffled <- TRUE
[17:40:20.766]                             break
[17:40:20.766]                           }
[17:40:20.766]                         }
[17:40:20.766]                       }
[17:40:20.766]                       invisible(muffled)
[17:40:20.766]                     }
[17:40:20.766]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.766]                   }
[17:40:20.766]                 }
[17:40:20.766]             }
[17:40:20.766]         }))
[17:40:20.766]     }, error = function(ex) {
[17:40:20.766]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.766]                 ...future.rng), started = ...future.startTime, 
[17:40:20.766]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.766]             version = "1.8"), class = "FutureResult")
[17:40:20.766]     }, finally = {
[17:40:20.766]         if (!identical(...future.workdir, getwd())) 
[17:40:20.766]             setwd(...future.workdir)
[17:40:20.766]         {
[17:40:20.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.766]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.766]             }
[17:40:20.766]             base::options(...future.oldOptions)
[17:40:20.766]             if (.Platform$OS.type == "windows") {
[17:40:20.766]                 old_names <- names(...future.oldEnvVars)
[17:40:20.766]                 envs <- base::Sys.getenv()
[17:40:20.766]                 names <- names(envs)
[17:40:20.766]                 common <- intersect(names, old_names)
[17:40:20.766]                 added <- setdiff(names, old_names)
[17:40:20.766]                 removed <- setdiff(old_names, names)
[17:40:20.766]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.766]                   envs[common]]
[17:40:20.766]                 NAMES <- toupper(changed)
[17:40:20.766]                 args <- list()
[17:40:20.766]                 for (kk in seq_along(NAMES)) {
[17:40:20.766]                   name <- changed[[kk]]
[17:40:20.766]                   NAME <- NAMES[[kk]]
[17:40:20.766]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.766]                     next
[17:40:20.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.766]                 }
[17:40:20.766]                 NAMES <- toupper(added)
[17:40:20.766]                 for (kk in seq_along(NAMES)) {
[17:40:20.766]                   name <- added[[kk]]
[17:40:20.766]                   NAME <- NAMES[[kk]]
[17:40:20.766]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.766]                     next
[17:40:20.766]                   args[[name]] <- ""
[17:40:20.766]                 }
[17:40:20.766]                 NAMES <- toupper(removed)
[17:40:20.766]                 for (kk in seq_along(NAMES)) {
[17:40:20.766]                   name <- removed[[kk]]
[17:40:20.766]                   NAME <- NAMES[[kk]]
[17:40:20.766]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.766]                     next
[17:40:20.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.766]                 }
[17:40:20.766]                 if (length(args) > 0) 
[17:40:20.766]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.766]             }
[17:40:20.766]             else {
[17:40:20.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.766]             }
[17:40:20.766]             {
[17:40:20.766]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.766]                   0L) {
[17:40:20.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.766]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.766]                   base::options(opts)
[17:40:20.766]                 }
[17:40:20.766]                 {
[17:40:20.766]                   {
[17:40:20.766]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.766]                     NULL
[17:40:20.766]                   }
[17:40:20.766]                   options(future.plan = NULL)
[17:40:20.766]                   if (is.na(NA_character_)) 
[17:40:20.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.766]                     .init = FALSE)
[17:40:20.766]                 }
[17:40:20.766]             }
[17:40:20.766]         }
[17:40:20.766]     })
[17:40:20.766]     if (TRUE) {
[17:40:20.766]         base::sink(type = "output", split = FALSE)
[17:40:20.766]         if (TRUE) {
[17:40:20.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.766]         }
[17:40:20.766]         else {
[17:40:20.766]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.766]         }
[17:40:20.766]         base::close(...future.stdout)
[17:40:20.766]         ...future.stdout <- NULL
[17:40:20.766]     }
[17:40:20.766]     ...future.result$conditions <- ...future.conditions
[17:40:20.766]     ...future.result$finished <- base::Sys.time()
[17:40:20.766]     ...future.result
[17:40:20.766] }
[17:40:20.769] assign_globals() ...
[17:40:20.769] List of 2
[17:40:20.769]  $ nested   :List of 2
[17:40:20.769]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:20.769]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:20.769]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.769]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:20.769]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:20.769]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.769]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:20.769]  $ strategy2: chr "multicore"
[17:40:20.769]  - attr(*, "where")=List of 2
[17:40:20.769]   ..$ nested   :<environment: R_EmptyEnv> 
[17:40:20.769]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:40:20.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.769]  - attr(*, "resolved")= logi FALSE
[17:40:20.769]  - attr(*, "total_size")= num 95304
[17:40:20.769]  - attr(*, "already-done")= logi TRUE
[17:40:20.774] - copied ‘nested’ to environment
[17:40:20.775] - copied ‘strategy2’ to environment
[17:40:20.775] assign_globals() ... done
[17:40:20.775] requestCore(): workers = 2
[17:40:20.777] MulticoreFuture started
[17:40:20.777] - Launch lazy future ... done
[17:40:20.778] run() for ‘MulticoreFuture’ ... done
[17:40:20.778] result() for MulticoreFuture ...
[17:40:20.778] plan(): Setting new future strategy stack:
[17:40:20.779] List of future strategies:
[17:40:20.779] 1. multicore:
[17:40:20.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.779]    - tweaked: FALSE
[17:40:20.779]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.785] plan(): nbrOfWorkers() = 1
[17:40:20.826] plan(): Setting new future strategy stack:
[17:40:20.826] List of future strategies:
[17:40:20.826] 1. multicore:
[17:40:20.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.826]    - tweaked: FALSE
[17:40:20.826]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.826] 2. multicore:
[17:40:20.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.826]    - tweaked: FALSE
[17:40:20.826]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.830] plan(): nbrOfWorkers() = 2
[17:40:20.832] result() for MulticoreFuture ...
[17:40:20.832] result() for MulticoreFuture ... done
[17:40:20.832] signalConditions() ...
[17:40:20.832]  - include = ‘immediateCondition’
[17:40:20.833]  - exclude = 
[17:40:20.833]  - resignal = FALSE
[17:40:20.833]  - Number of conditions: 54
[17:40:20.833] signalConditions() ... done
[17:40:20.833] result() for MulticoreFuture ... done
[17:40:20.833] result() for MulticoreFuture ...
[17:40:20.834] result() for MulticoreFuture ... done
[17:40:20.834] signalConditions() ...
[17:40:20.834]  - include = ‘immediateCondition’
[17:40:20.834]  - exclude = 
[17:40:20.834]  - resignal = FALSE
[17:40:20.834]  - Number of conditions: 54
[17:40:20.835] signalConditions() ... done
[17:40:20.835] Future state: ‘finished’
[17:40:20.835] result() for MulticoreFuture ...
[17:40:20.835] result() for MulticoreFuture ... done
[17:40:20.835] signalConditions() ...
[17:40:20.836]  - include = ‘condition’
[17:40:20.836]  - exclude = ‘immediateCondition’
[17:40:20.836]  - resignal = TRUE
[17:40:20.836]  - Number of conditions: 54
[17:40:20.836]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.786] getGlobalsAndPackages() ...
[17:40:20.836]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.787] Searching for globals...
[17:40:20.837]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.795] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:40:20.837]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.795] Searching for globals ... DONE
[17:40:20.837]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.795] Resolving globals: FALSE
[17:40:20.837]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.797] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[17:40:20.837]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.797] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:40:20.838]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.798] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:40:20.838]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.798] 
[17:40:20.838]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.798] getGlobalsAndPackages() ... DONE
[17:40:20.838]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.799] run() for ‘Future’ ...
[17:40:20.838]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.799] - state: ‘created’
[17:40:20.839]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.839]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.803] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:20.839]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:20.839]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.804]   - Field: ‘label’
[17:40:20.839]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.804]   - Field: ‘local’
[17:40:20.839]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.804]   - Field: ‘owner’
[17:40:20.840]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.804]   - Field: ‘envir’
[17:40:20.840]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.804]   - Field: ‘packages’
[17:40:20.840]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘gc’
[17:40:20.840]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘conditions’
[17:40:20.840]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘expr’
[17:40:20.840]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘uuid’
[17:40:20.841]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘seed’
[17:40:20.841]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘version’
[17:40:20.841]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.805]   - Field: ‘result’
[17:40:20.841]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.806]   - Field: ‘asynchronous’
[17:40:20.841]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.806]   - Field: ‘calls’
[17:40:20.841]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.806]   - Field: ‘globals’
[17:40:20.842]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.806]   - Field: ‘stdout’
[17:40:20.842]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.806]   - Field: ‘earlySignal’
[17:40:20.842]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.806]   - Field: ‘lazy’
[17:40:20.842]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.807]   - Field: ‘state’
[17:40:20.842]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:20.842]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.807] - Launch lazy future ...
[17:40:20.842]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.807] Packages needed by the future expression (n = 0): <none>
[17:40:20.843]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.807] Packages needed by future strategies (n = 0): <none>
[17:40:20.843]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.808] {
[17:40:20.808]     {
[17:40:20.808]         {
[17:40:20.808]             ...future.startTime <- base::Sys.time()
[17:40:20.808]             {
[17:40:20.808]                 {
[17:40:20.808]                   {
[17:40:20.808]                     base::local({
[17:40:20.808]                       has_future <- base::requireNamespace("future", 
[17:40:20.808]                         quietly = TRUE)
[17:40:20.808]                       if (has_future) {
[17:40:20.808]                         ns <- base::getNamespace("future")
[17:40:20.808]                         version <- ns[[".package"]][["version"]]
[17:40:20.808]                         if (is.null(version)) 
[17:40:20.808]                           version <- utils::packageVersion("future")
[17:40:20.808]                       }
[17:40:20.808]                       else {
[17:40:20.808]                         version <- NULL
[17:40:20.808]                       }
[17:40:20.808]                       if (!has_future || version < "1.8.0") {
[17:40:20.808]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.808]                           "", base::R.version$version.string), 
[17:40:20.808]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:20.808]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.808]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.808]                             "release", "version")], collapse = " "), 
[17:40:20.808]                           hostname = base::Sys.info()[["nodename"]])
[17:40:20.808]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.808]                           info)
[17:40:20.808]                         info <- base::paste(info, collapse = "; ")
[17:40:20.808]                         if (!has_future) {
[17:40:20.808]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.808]                             info)
[17:40:20.808]                         }
[17:40:20.808]                         else {
[17:40:20.808]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.808]                             info, version)
[17:40:20.808]                         }
[17:40:20.808]                         base::stop(msg)
[17:40:20.808]                       }
[17:40:20.808]                     })
[17:40:20.808]                   }
[17:40:20.808]                   ...future.strategy.old <- future::plan("list")
[17:40:20.808]                   options(future.plan = NULL)
[17:40:20.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:20.808]                 }
[17:40:20.808]                 ...future.workdir <- getwd()
[17:40:20.808]             }
[17:40:20.808]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.808]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.808]         }
[17:40:20.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.808]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.808]             base::names(...future.oldOptions))
[17:40:20.808]     }
[17:40:20.808]     if (FALSE) {
[17:40:20.808]     }
[17:40:20.808]     else {
[17:40:20.808]         if (TRUE) {
[17:40:20.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.808]                 open = "w")
[17:40:20.808]         }
[17:40:20.808]         else {
[17:40:20.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.808]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.808]         }
[17:40:20.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.808]             base::sink(type = "output", split = FALSE)
[17:40:20.808]             base::close(...future.stdout)
[17:40:20.808]         }, add = TRUE)
[17:40:20.808]     }
[17:40:20.808]     ...future.frame <- base::sys.nframe()
[17:40:20.808]     ...future.conditions <- base::list()
[17:40:20.808]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.808]     if (FALSE) {
[17:40:20.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.808]     }
[17:40:20.808]     ...future.result <- base::tryCatch({
[17:40:20.808]         base::withCallingHandlers({
[17:40:20.808]             ...future.value <- base::withVisible(base::local({
[17:40:20.808]                 b <- 2L
[17:40:20.808]                 plan_b <- future::plan("list")
[17:40:20.808]                 nested_b <- nested_a[-1]
[17:40:20.808]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:20.808]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:20.808]                   "sequential"))
[17:40:20.808]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:20.808]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:20.808]             }))
[17:40:20.808]             future::FutureResult(value = ...future.value$value, 
[17:40:20.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.808]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.808]                     ...future.globalenv.names))
[17:40:20.808]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.808]         }, condition = base::local({
[17:40:20.808]             c <- base::c
[17:40:20.808]             inherits <- base::inherits
[17:40:20.808]             invokeRestart <- base::invokeRestart
[17:40:20.808]             length <- base::length
[17:40:20.808]             list <- base::list
[17:40:20.808]             seq.int <- base::seq.int
[17:40:20.808]             signalCondition <- base::signalCondition
[17:40:20.808]             sys.calls <- base::sys.calls
[17:40:20.808]             `[[` <- base::`[[`
[17:40:20.808]             `+` <- base::`+`
[17:40:20.808]             `<<-` <- base::`<<-`
[17:40:20.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.808]                   3L)]
[17:40:20.808]             }
[17:40:20.808]             function(cond) {
[17:40:20.808]                 is_error <- inherits(cond, "error")
[17:40:20.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.808]                   NULL)
[17:40:20.808]                 if (is_error) {
[17:40:20.808]                   sessionInformation <- function() {
[17:40:20.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.808]                       search = base::search(), system = base::Sys.info())
[17:40:20.808]                   }
[17:40:20.808]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.808]                     cond$call), session = sessionInformation(), 
[17:40:20.808]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.808]                   signalCondition(cond)
[17:40:20.808]                 }
[17:40:20.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.808]                 "immediateCondition"))) {
[17:40:20.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.808]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.808]                   if (TRUE && !signal) {
[17:40:20.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.808]                     {
[17:40:20.808]                       inherits <- base::inherits
[17:40:20.808]                       invokeRestart <- base::invokeRestart
[17:40:20.808]                       is.null <- base::is.null
[17:40:20.808]                       muffled <- FALSE
[17:40:20.808]                       if (inherits(cond, "message")) {
[17:40:20.808]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.808]                         if (muffled) 
[17:40:20.808]                           invokeRestart("muffleMessage")
[17:40:20.808]                       }
[17:40:20.808]                       else if (inherits(cond, "warning")) {
[17:40:20.808]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.808]                         if (muffled) 
[17:40:20.808]                           invokeRestart("muffleWarning")
[17:40:20.808]                       }
[17:40:20.808]                       else if (inherits(cond, "condition")) {
[17:40:20.808]                         if (!is.null(pattern)) {
[17:40:20.808]                           computeRestarts <- base::computeRestarts
[17:40:20.808]                           grepl <- base::grepl
[17:40:20.808]                           restarts <- computeRestarts(cond)
[17:40:20.808]                           for (restart in restarts) {
[17:40:20.808]                             name <- restart$name
[17:40:20.808]                             if (is.null(name)) 
[17:40:20.808]                               next
[17:40:20.808]                             if (!grepl(pattern, name)) 
[17:40:20.808]                               next
[17:40:20.808]                             invokeRestart(restart)
[17:40:20.808]                             muffled <- TRUE
[17:40:20.808]                             break
[17:40:20.808]                           }
[17:40:20.808]                         }
[17:40:20.808]                       }
[17:40:20.808]                       invisible(muffled)
[17:40:20.808]                     }
[17:40:20.808]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.808]                   }
[17:40:20.808]                 }
[17:40:20.808]                 else {
[17:40:20.808]                   if (TRUE) {
[17:40:20.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.808]                     {
[17:40:20.808]                       inherits <- base::inherits
[17:40:20.808]                       invokeRestart <- base::invokeRestart
[17:40:20.808]                       is.null <- base::is.null
[17:40:20.808]                       muffled <- FALSE
[17:40:20.808]                       if (inherits(cond, "message")) {
[17:40:20.808]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.808]                         if (muffled) 
[17:40:20.808]                           invokeRestart("muffleMessage")
[17:40:20.808]                       }
[17:40:20.808]                       else if (inherits(cond, "warning")) {
[17:40:20.808]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.808]                         if (muffled) 
[17:40:20.808]                           invokeRestart("muffleWarning")
[17:40:20.808]                       }
[17:40:20.808]                       else if (inherits(cond, "condition")) {
[17:40:20.808]                         if (!is.null(pattern)) {
[17:40:20.808]                           computeRestarts <- base::computeRestarts
[17:40:20.808]                           grepl <- base::grepl
[17:40:20.808]                           restarts <- computeRestarts(cond)
[17:40:20.808]                           for (restart in restarts) {
[17:40:20.808]                             name <- restart$name
[17:40:20.808]                             if (is.null(name)) 
[17:40:20.808]                               next
[17:40:20.808]                             if (!grepl(pattern, name)) 
[17:40:20.808]                               next
[17:40:20.808]                             invokeRestart(restart)
[17:40:20.808]                             muffled <- TRUE
[17:40:20.808]                             break
[17:40:20.808]                           }
[17:40:20.808]                         }
[17:40:20.808]                       }
[17:40:20.808]                       invisible(muffled)
[17:40:20.808]                     }
[17:40:20.808]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.808]                   }
[17:40:20.808]                 }
[17:40:20.808]             }
[17:40:20.808]         }))
[17:40:20.808]     }, error = function(ex) {
[17:40:20.808]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.808]                 ...future.rng), started = ...future.startTime, 
[17:40:20.808]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.808]             version = "1.8"), class = "FutureResult")
[17:40:20.808]     }, finally = {
[17:40:20.808]         if (!identical(...future.workdir, getwd())) 
[17:40:20.808]             setwd(...future.workdir)
[17:40:20.808]         {
[17:40:20.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.808]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.808]             }
[17:40:20.808]             base::options(...future.oldOptions)
[17:40:20.808]             if (.Platform$OS.type == "windows") {
[17:40:20.808]                 old_names <- names(...future.oldEnvVars)
[17:40:20.808]                 envs <- base::Sys.getenv()
[17:40:20.808]                 names <- names(envs)
[17:40:20.808]                 common <- intersect(names, old_names)
[17:40:20.808]                 added <- setdiff(names, old_names)
[17:40:20.808]                 removed <- setdiff(old_names, names)
[17:40:20.808]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.808]                   envs[common]]
[17:40:20.808]                 NAMES <- toupper(changed)
[17:40:20.808]                 args <- list()
[17:40:20.808]                 for (kk in seq_along(NAMES)) {
[17:40:20.808]                   name <- changed[[kk]]
[17:40:20.808]                   NAME <- NAMES[[kk]]
[17:40:20.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.808]                     next
[17:40:20.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.808]                 }
[17:40:20.808]                 NAMES <- toupper(added)
[17:40:20.808]                 for (kk in seq_along(NAMES)) {
[17:40:20.808]                   name <- added[[kk]]
[17:40:20.808]                   NAME <- NAMES[[kk]]
[17:40:20.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.808]                     next
[17:40:20.808]                   args[[name]] <- ""
[17:40:20.808]                 }
[17:40:20.808]                 NAMES <- toupper(removed)
[17:40:20.808]                 for (kk in seq_along(NAMES)) {
[17:40:20.808]                   name <- removed[[kk]]
[17:40:20.808]                   NAME <- NAMES[[kk]]
[17:40:20.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.808]                     next
[17:40:20.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.808]                 }
[17:40:20.808]                 if (length(args) > 0) 
[17:40:20.808]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.808]             }
[17:40:20.808]             else {
[17:40:20.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.808]             }
[17:40:20.808]             {
[17:40:20.808]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.808]                   0L) {
[17:40:20.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.808]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.808]                   base::options(opts)
[17:40:20.808]                 }
[17:40:20.808]                 {
[17:40:20.808]                   {
[17:40:20.808]                     NULL
[17:40:20.808]                     RNGkind("Mersenne-Twister")
[17:40:20.808]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:20.808]                       inherits = FALSE)
[17:40:20.808]                   }
[17:40:20.808]                   options(future.plan = NULL)
[17:40:20.808]                   if (is.na(NA_character_)) 
[17:40:20.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.808]                     .init = FALSE)
[17:40:20.808]                 }
[17:40:20.808]             }
[17:40:20.808]         }
[17:40:20.808]     })
[17:40:20.808]     if (TRUE) {
[17:40:20.808]         base::sink(type = "output", split = FALSE)
[17:40:20.808]         if (TRUE) {
[17:40:20.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.808]         }
[17:40:20.808]         else {
[17:40:20.808]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.808]         }
[17:40:20.808]         base::close(...future.stdout)
[17:40:20.808]         ...future.stdout <- NULL
[17:40:20.808]     }
[17:40:20.808]     ...future.result$conditions <- ...future.conditions
[17:40:20.808]     ...future.result$finished <- base::Sys.time()
[17:40:20.808]     ...future.result
[17:40:20.808] }
[17:40:20.843]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.811] assign_globals() ...
[17:40:20.843]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.811] List of 3
[17:40:20.811]  $ nested_a:List of 1
[17:40:20.811]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:20.811]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:20.811]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.811]  $ a       : int 1
[17:40:20.811]  $ plan_a  :List of 1
[17:40:20.811]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:20.811]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:20.811]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.811]  - attr(*, "where")=List of 3
[17:40:20.811]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:40:20.811]   ..$ a       :<environment: R_EmptyEnv> 
[17:40:20.811]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:40:20.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.811]  - attr(*, "resolved")= logi FALSE
[17:40:20.811]  - attr(*, "total_size")= num 95240
[17:40:20.811]  - attr(*, "already-done")= logi TRUE
[17:40:20.843]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.818] - copied ‘nested_a’ to environment
[17:40:20.844]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.818] - copied ‘a’ to environment
[17:40:20.844]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.818] - copied ‘plan_a’ to environment
[17:40:20.844]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.818] assign_globals() ... done
[17:40:20.844]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.819] plan(): Setting new future strategy stack:
[17:40:20.844]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.819] List of future strategies:
[17:40:20.819] 1. sequential:
[17:40:20.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.819]    - tweaked: FALSE
[17:40:20.819]    - call: NULL
[17:40:20.844]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.819] plan(): nbrOfWorkers() = 1
[17:40:20.845]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.820] plan(): Setting new future strategy stack:
[17:40:20.845]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.821] List of future strategies:
[17:40:20.821] 1. multicore:
[17:40:20.821]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.821]    - tweaked: FALSE
[17:40:20.821]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.845]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.825] plan(): nbrOfWorkers() = 1
[17:40:20.845]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.825] SequentialFuture started (and completed)
[17:40:20.845]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.825] - Launch lazy future ... done
[17:40:20.845]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.825] run() for ‘SequentialFuture’ ... done
[17:40:20.845] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:20.851] getGlobalsAndPackages() ...
[17:40:20.852] Searching for globals...
[17:40:20.853] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:20.853] Searching for globals ... DONE
[17:40:20.854] Resolving globals: FALSE
[17:40:20.854] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:20.855] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:20.855] - globals: [1] ‘data’
[17:40:20.855] - packages: [1] ‘future’
[17:40:20.855] getGlobalsAndPackages() ... DONE
[17:40:20.855] run() for ‘Future’ ...
[17:40:20.856] - state: ‘created’
[17:40:20.856] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:20.860]   - Field: ‘label’
[17:40:20.860]   - Field: ‘local’
[17:40:20.860]   - Field: ‘owner’
[17:40:20.860]   - Field: ‘envir’
[17:40:20.861]   - Field: ‘workers’
[17:40:20.861]   - Field: ‘packages’
[17:40:20.861]   - Field: ‘gc’
[17:40:20.861]   - Field: ‘job’
[17:40:20.861]   - Field: ‘conditions’
[17:40:20.861]   - Field: ‘expr’
[17:40:20.861]   - Field: ‘uuid’
[17:40:20.861]   - Field: ‘seed’
[17:40:20.861]   - Field: ‘version’
[17:40:20.861]   - Field: ‘result’
[17:40:20.862]   - Field: ‘asynchronous’
[17:40:20.862]   - Field: ‘calls’
[17:40:20.862]   - Field: ‘globals’
[17:40:20.862]   - Field: ‘stdout’
[17:40:20.862]   - Field: ‘earlySignal’
[17:40:20.862]   - Field: ‘lazy’
[17:40:20.862]   - Field: ‘state’
[17:40:20.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:20.862] - Launch lazy future ...
[17:40:20.863] Packages needed by the future expression (n = 1): ‘future’
[17:40:20.863] Packages needed by future strategies (n = 1): ‘future’
[17:40:20.864] {
[17:40:20.864]     {
[17:40:20.864]         {
[17:40:20.864]             ...future.startTime <- base::Sys.time()
[17:40:20.864]             {
[17:40:20.864]                 {
[17:40:20.864]                   {
[17:40:20.864]                     {
[17:40:20.864]                       {
[17:40:20.864]                         base::local({
[17:40:20.864]                           has_future <- base::requireNamespace("future", 
[17:40:20.864]                             quietly = TRUE)
[17:40:20.864]                           if (has_future) {
[17:40:20.864]                             ns <- base::getNamespace("future")
[17:40:20.864]                             version <- ns[[".package"]][["version"]]
[17:40:20.864]                             if (is.null(version)) 
[17:40:20.864]                               version <- utils::packageVersion("future")
[17:40:20.864]                           }
[17:40:20.864]                           else {
[17:40:20.864]                             version <- NULL
[17:40:20.864]                           }
[17:40:20.864]                           if (!has_future || version < "1.8.0") {
[17:40:20.864]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.864]                               "", base::R.version$version.string), 
[17:40:20.864]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:20.864]                                 base::R.version$platform, 8 * 
[17:40:20.864]                                   base::.Machine$sizeof.pointer), 
[17:40:20.864]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.864]                                 "release", "version")], collapse = " "), 
[17:40:20.864]                               hostname = base::Sys.info()[["nodename"]])
[17:40:20.864]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.864]                               info)
[17:40:20.864]                             info <- base::paste(info, collapse = "; ")
[17:40:20.864]                             if (!has_future) {
[17:40:20.864]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.864]                                 info)
[17:40:20.864]                             }
[17:40:20.864]                             else {
[17:40:20.864]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.864]                                 info, version)
[17:40:20.864]                             }
[17:40:20.864]                             base::stop(msg)
[17:40:20.864]                           }
[17:40:20.864]                         })
[17:40:20.864]                       }
[17:40:20.864]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.864]                       base::options(mc.cores = 1L)
[17:40:20.864]                     }
[17:40:20.864]                     base::local({
[17:40:20.864]                       for (pkg in "future") {
[17:40:20.864]                         base::loadNamespace(pkg)
[17:40:20.864]                         base::library(pkg, character.only = TRUE)
[17:40:20.864]                       }
[17:40:20.864]                     })
[17:40:20.864]                   }
[17:40:20.864]                   ...future.strategy.old <- future::plan("list")
[17:40:20.864]                   options(future.plan = NULL)
[17:40:20.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.864]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:20.864]                     envir = parent.frame()) 
[17:40:20.864]                   {
[17:40:20.864]                     default_workers <- missing(workers)
[17:40:20.864]                     if (is.function(workers)) 
[17:40:20.864]                       workers <- workers()
[17:40:20.864]                     workers <- structure(as.integer(workers), 
[17:40:20.864]                       class = class(workers))
[17:40:20.864]                     stop_if_not(is.finite(workers), workers >= 
[17:40:20.864]                       1L)
[17:40:20.864]                     if ((workers == 1L && !inherits(workers, 
[17:40:20.864]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:20.864]                       if (default_workers) 
[17:40:20.864]                         supportsMulticore(warn = TRUE)
[17:40:20.864]                       return(sequential(..., envir = envir))
[17:40:20.864]                     }
[17:40:20.864]                     oopts <- options(mc.cores = workers)
[17:40:20.864]                     on.exit(options(oopts))
[17:40:20.864]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:20.864]                       envir = envir)
[17:40:20.864]                     if (!future$lazy) 
[17:40:20.864]                       future <- run(future)
[17:40:20.864]                     invisible(future)
[17:40:20.864]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:20.864]                 }
[17:40:20.864]                 ...future.workdir <- getwd()
[17:40:20.864]             }
[17:40:20.864]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.864]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.864]         }
[17:40:20.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.864]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.864]             base::names(...future.oldOptions))
[17:40:20.864]     }
[17:40:20.864]     if (FALSE) {
[17:40:20.864]     }
[17:40:20.864]     else {
[17:40:20.864]         if (TRUE) {
[17:40:20.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.864]                 open = "w")
[17:40:20.864]         }
[17:40:20.864]         else {
[17:40:20.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.864]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.864]         }
[17:40:20.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.864]             base::sink(type = "output", split = FALSE)
[17:40:20.864]             base::close(...future.stdout)
[17:40:20.864]         }, add = TRUE)
[17:40:20.864]     }
[17:40:20.864]     ...future.frame <- base::sys.nframe()
[17:40:20.864]     ...future.conditions <- base::list()
[17:40:20.864]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.864]     if (FALSE) {
[17:40:20.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.864]     }
[17:40:20.864]     ...future.result <- base::tryCatch({
[17:40:20.864]         base::withCallingHandlers({
[17:40:20.864]             ...future.value <- base::withVisible(base::local({
[17:40:20.864]                 withCallingHandlers({
[17:40:20.864]                   {
[17:40:20.864]                     value(future(subset(data, a == 2)))
[17:40:20.864]                   }
[17:40:20.864]                 }, immediateCondition = function(cond) {
[17:40:20.864]                   save_rds <- function (object, pathname, ...) 
[17:40:20.864]                   {
[17:40:20.864]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:20.864]                     if (file_test("-f", pathname_tmp)) {
[17:40:20.864]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.864]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:20.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.864]                         fi_tmp[["mtime"]])
[17:40:20.864]                     }
[17:40:20.864]                     tryCatch({
[17:40:20.864]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:20.864]                     }, error = function(ex) {
[17:40:20.864]                       msg <- conditionMessage(ex)
[17:40:20.864]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.864]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:20.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.864]                         fi_tmp[["mtime"]], msg)
[17:40:20.864]                       ex$message <- msg
[17:40:20.864]                       stop(ex)
[17:40:20.864]                     })
[17:40:20.864]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:20.864]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:20.864]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:20.864]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.864]                       fi <- file.info(pathname)
[17:40:20.864]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:20.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.864]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:20.864]                         fi[["size"]], fi[["mtime"]])
[17:40:20.864]                       stop(msg)
[17:40:20.864]                     }
[17:40:20.864]                     invisible(pathname)
[17:40:20.864]                   }
[17:40:20.864]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:20.864]                     rootPath = tempdir()) 
[17:40:20.864]                   {
[17:40:20.864]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:20.864]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:20.864]                       tmpdir = path, fileext = ".rds")
[17:40:20.864]                     save_rds(obj, file)
[17:40:20.864]                   }
[17:40:20.864]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:20.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.864]                   {
[17:40:20.864]                     inherits <- base::inherits
[17:40:20.864]                     invokeRestart <- base::invokeRestart
[17:40:20.864]                     is.null <- base::is.null
[17:40:20.864]                     muffled <- FALSE
[17:40:20.864]                     if (inherits(cond, "message")) {
[17:40:20.864]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.864]                       if (muffled) 
[17:40:20.864]                         invokeRestart("muffleMessage")
[17:40:20.864]                     }
[17:40:20.864]                     else if (inherits(cond, "warning")) {
[17:40:20.864]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.864]                       if (muffled) 
[17:40:20.864]                         invokeRestart("muffleWarning")
[17:40:20.864]                     }
[17:40:20.864]                     else if (inherits(cond, "condition")) {
[17:40:20.864]                       if (!is.null(pattern)) {
[17:40:20.864]                         computeRestarts <- base::computeRestarts
[17:40:20.864]                         grepl <- base::grepl
[17:40:20.864]                         restarts <- computeRestarts(cond)
[17:40:20.864]                         for (restart in restarts) {
[17:40:20.864]                           name <- restart$name
[17:40:20.864]                           if (is.null(name)) 
[17:40:20.864]                             next
[17:40:20.864]                           if (!grepl(pattern, name)) 
[17:40:20.864]                             next
[17:40:20.864]                           invokeRestart(restart)
[17:40:20.864]                           muffled <- TRUE
[17:40:20.864]                           break
[17:40:20.864]                         }
[17:40:20.864]                       }
[17:40:20.864]                     }
[17:40:20.864]                     invisible(muffled)
[17:40:20.864]                   }
[17:40:20.864]                   muffleCondition(cond)
[17:40:20.864]                 })
[17:40:20.864]             }))
[17:40:20.864]             future::FutureResult(value = ...future.value$value, 
[17:40:20.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.864]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.864]                     ...future.globalenv.names))
[17:40:20.864]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.864]         }, condition = base::local({
[17:40:20.864]             c <- base::c
[17:40:20.864]             inherits <- base::inherits
[17:40:20.864]             invokeRestart <- base::invokeRestart
[17:40:20.864]             length <- base::length
[17:40:20.864]             list <- base::list
[17:40:20.864]             seq.int <- base::seq.int
[17:40:20.864]             signalCondition <- base::signalCondition
[17:40:20.864]             sys.calls <- base::sys.calls
[17:40:20.864]             `[[` <- base::`[[`
[17:40:20.864]             `+` <- base::`+`
[17:40:20.864]             `<<-` <- base::`<<-`
[17:40:20.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.864]                   3L)]
[17:40:20.864]             }
[17:40:20.864]             function(cond) {
[17:40:20.864]                 is_error <- inherits(cond, "error")
[17:40:20.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.864]                   NULL)
[17:40:20.864]                 if (is_error) {
[17:40:20.864]                   sessionInformation <- function() {
[17:40:20.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.864]                       search = base::search(), system = base::Sys.info())
[17:40:20.864]                   }
[17:40:20.864]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.864]                     cond$call), session = sessionInformation(), 
[17:40:20.864]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.864]                   signalCondition(cond)
[17:40:20.864]                 }
[17:40:20.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.864]                 "immediateCondition"))) {
[17:40:20.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.864]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.864]                   if (TRUE && !signal) {
[17:40:20.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.864]                     {
[17:40:20.864]                       inherits <- base::inherits
[17:40:20.864]                       invokeRestart <- base::invokeRestart
[17:40:20.864]                       is.null <- base::is.null
[17:40:20.864]                       muffled <- FALSE
[17:40:20.864]                       if (inherits(cond, "message")) {
[17:40:20.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.864]                         if (muffled) 
[17:40:20.864]                           invokeRestart("muffleMessage")
[17:40:20.864]                       }
[17:40:20.864]                       else if (inherits(cond, "warning")) {
[17:40:20.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.864]                         if (muffled) 
[17:40:20.864]                           invokeRestart("muffleWarning")
[17:40:20.864]                       }
[17:40:20.864]                       else if (inherits(cond, "condition")) {
[17:40:20.864]                         if (!is.null(pattern)) {
[17:40:20.864]                           computeRestarts <- base::computeRestarts
[17:40:20.864]                           grepl <- base::grepl
[17:40:20.864]                           restarts <- computeRestarts(cond)
[17:40:20.864]                           for (restart in restarts) {
[17:40:20.864]                             name <- restart$name
[17:40:20.864]                             if (is.null(name)) 
[17:40:20.864]                               next
[17:40:20.864]                             if (!grepl(pattern, name)) 
[17:40:20.864]                               next
[17:40:20.864]                             invokeRestart(restart)
[17:40:20.864]                             muffled <- TRUE
[17:40:20.864]                             break
[17:40:20.864]                           }
[17:40:20.864]                         }
[17:40:20.864]                       }
[17:40:20.864]                       invisible(muffled)
[17:40:20.864]                     }
[17:40:20.864]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.864]                   }
[17:40:20.864]                 }
[17:40:20.864]                 else {
[17:40:20.864]                   if (TRUE) {
[17:40:20.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.864]                     {
[17:40:20.864]                       inherits <- base::inherits
[17:40:20.864]                       invokeRestart <- base::invokeRestart
[17:40:20.864]                       is.null <- base::is.null
[17:40:20.864]                       muffled <- FALSE
[17:40:20.864]                       if (inherits(cond, "message")) {
[17:40:20.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.864]                         if (muffled) 
[17:40:20.864]                           invokeRestart("muffleMessage")
[17:40:20.864]                       }
[17:40:20.864]                       else if (inherits(cond, "warning")) {
[17:40:20.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.864]                         if (muffled) 
[17:40:20.864]                           invokeRestart("muffleWarning")
[17:40:20.864]                       }
[17:40:20.864]                       else if (inherits(cond, "condition")) {
[17:40:20.864]                         if (!is.null(pattern)) {
[17:40:20.864]                           computeRestarts <- base::computeRestarts
[17:40:20.864]                           grepl <- base::grepl
[17:40:20.864]                           restarts <- computeRestarts(cond)
[17:40:20.864]                           for (restart in restarts) {
[17:40:20.864]                             name <- restart$name
[17:40:20.864]                             if (is.null(name)) 
[17:40:20.864]                               next
[17:40:20.864]                             if (!grepl(pattern, name)) 
[17:40:20.864]                               next
[17:40:20.864]                             invokeRestart(restart)
[17:40:20.864]                             muffled <- TRUE
[17:40:20.864]                             break
[17:40:20.864]                           }
[17:40:20.864]                         }
[17:40:20.864]                       }
[17:40:20.864]                       invisible(muffled)
[17:40:20.864]                     }
[17:40:20.864]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.864]                   }
[17:40:20.864]                 }
[17:40:20.864]             }
[17:40:20.864]         }))
[17:40:20.864]     }, error = function(ex) {
[17:40:20.864]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.864]                 ...future.rng), started = ...future.startTime, 
[17:40:20.864]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.864]             version = "1.8"), class = "FutureResult")
[17:40:20.864]     }, finally = {
[17:40:20.864]         if (!identical(...future.workdir, getwd())) 
[17:40:20.864]             setwd(...future.workdir)
[17:40:20.864]         {
[17:40:20.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.864]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.864]             }
[17:40:20.864]             base::options(...future.oldOptions)
[17:40:20.864]             if (.Platform$OS.type == "windows") {
[17:40:20.864]                 old_names <- names(...future.oldEnvVars)
[17:40:20.864]                 envs <- base::Sys.getenv()
[17:40:20.864]                 names <- names(envs)
[17:40:20.864]                 common <- intersect(names, old_names)
[17:40:20.864]                 added <- setdiff(names, old_names)
[17:40:20.864]                 removed <- setdiff(old_names, names)
[17:40:20.864]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.864]                   envs[common]]
[17:40:20.864]                 NAMES <- toupper(changed)
[17:40:20.864]                 args <- list()
[17:40:20.864]                 for (kk in seq_along(NAMES)) {
[17:40:20.864]                   name <- changed[[kk]]
[17:40:20.864]                   NAME <- NAMES[[kk]]
[17:40:20.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.864]                     next
[17:40:20.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.864]                 }
[17:40:20.864]                 NAMES <- toupper(added)
[17:40:20.864]                 for (kk in seq_along(NAMES)) {
[17:40:20.864]                   name <- added[[kk]]
[17:40:20.864]                   NAME <- NAMES[[kk]]
[17:40:20.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.864]                     next
[17:40:20.864]                   args[[name]] <- ""
[17:40:20.864]                 }
[17:40:20.864]                 NAMES <- toupper(removed)
[17:40:20.864]                 for (kk in seq_along(NAMES)) {
[17:40:20.864]                   name <- removed[[kk]]
[17:40:20.864]                   NAME <- NAMES[[kk]]
[17:40:20.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.864]                     next
[17:40:20.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.864]                 }
[17:40:20.864]                 if (length(args) > 0) 
[17:40:20.864]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.864]             }
[17:40:20.864]             else {
[17:40:20.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.864]             }
[17:40:20.864]             {
[17:40:20.864]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.864]                   0L) {
[17:40:20.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.864]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.864]                   base::options(opts)
[17:40:20.864]                 }
[17:40:20.864]                 {
[17:40:20.864]                   {
[17:40:20.864]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.864]                     NULL
[17:40:20.864]                   }
[17:40:20.864]                   options(future.plan = NULL)
[17:40:20.864]                   if (is.na(NA_character_)) 
[17:40:20.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.864]                     .init = FALSE)
[17:40:20.864]                 }
[17:40:20.864]             }
[17:40:20.864]         }
[17:40:20.864]     })
[17:40:20.864]     if (TRUE) {
[17:40:20.864]         base::sink(type = "output", split = FALSE)
[17:40:20.864]         if (TRUE) {
[17:40:20.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.864]         }
[17:40:20.864]         else {
[17:40:20.864]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.864]         }
[17:40:20.864]         base::close(...future.stdout)
[17:40:20.864]         ...future.stdout <- NULL
[17:40:20.864]     }
[17:40:20.864]     ...future.result$conditions <- ...future.conditions
[17:40:20.864]     ...future.result$finished <- base::Sys.time()
[17:40:20.864]     ...future.result
[17:40:20.864] }
[17:40:20.866] assign_globals() ...
[17:40:20.866] List of 1
[17:40:20.866]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:20.866]   ..$ a: int [1:3] 1 2 3
[17:40:20.866]   ..$ b: int [1:3] 3 2 1
[17:40:20.866]  - attr(*, "where")=List of 1
[17:40:20.866]   ..$ data:<environment: R_EmptyEnv> 
[17:40:20.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.866]  - attr(*, "resolved")= logi FALSE
[17:40:20.866]  - attr(*, "total_size")= num 128
[17:40:20.866]  - attr(*, "already-done")= logi TRUE
[17:40:20.870] - copied ‘data’ to environment
[17:40:20.870] assign_globals() ... done
[17:40:20.870] requestCore(): workers = 2
[17:40:20.873] MulticoreFuture started
[17:40:20.873] - Launch lazy future ... done
[17:40:20.873] run() for ‘MulticoreFuture’ ... done
[17:40:20.873] result() for MulticoreFuture ...
[17:40:20.874] plan(): Setting new future strategy stack:
[17:40:20.874] List of future strategies:
[17:40:20.874] 1. multicore:
[17:40:20.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.874]    - tweaked: FALSE
[17:40:20.874]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.880] plan(): nbrOfWorkers() = 1
[17:40:20.916] plan(): Setting new future strategy stack:
[17:40:20.916] List of future strategies:
[17:40:20.916] 1. multicore:
[17:40:20.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.916]    - tweaked: FALSE
[17:40:20.916]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.916] 2. multicore:
[17:40:20.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.916]    - tweaked: FALSE
[17:40:20.916]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.920] plan(): nbrOfWorkers() = 2
[17:40:20.921] result() for MulticoreFuture ...
[17:40:20.921] result() for MulticoreFuture ... done
[17:40:20.922] signalConditions() ...
[17:40:20.922]  - include = ‘immediateCondition’
[17:40:20.922]  - exclude = 
[17:40:20.922]  - resignal = FALSE
[17:40:20.922]  - Number of conditions: 52
[17:40:20.922] signalConditions() ... done
[17:40:20.923] result() for MulticoreFuture ... done
[17:40:20.923] result() for MulticoreFuture ...
[17:40:20.923] result() for MulticoreFuture ... done
[17:40:20.923] signalConditions() ...
[17:40:20.923]  - include = ‘immediateCondition’
[17:40:20.923]  - exclude = 
[17:40:20.923]  - resignal = FALSE
[17:40:20.924]  - Number of conditions: 52
[17:40:20.924] signalConditions() ... done
[17:40:20.924] Future state: ‘finished’
[17:40:20.924] result() for MulticoreFuture ...
[17:40:20.924] result() for MulticoreFuture ... done
[17:40:20.925] signalConditions() ...
[17:40:20.925]  - include = ‘condition’
[17:40:20.925]  - exclude = ‘immediateCondition’
[17:40:20.925]  - resignal = TRUE
[17:40:20.925]  - Number of conditions: 52
[17:40:20.925]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.881] getGlobalsAndPackages() ...
[17:40:20.925]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.881] Searching for globals...
[17:40:20.926]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.883] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:20.926]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.883] Searching for globals ... DONE
[17:40:20.926]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.883] Resolving globals: FALSE
[17:40:20.926]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.884] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:20.926]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.885] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:20.927]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.885] - globals: [1] ‘data’
[17:40:20.927]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.885] 
[17:40:20.927]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.885] getGlobalsAndPackages() ... DONE
[17:40:20.927]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.886] run() for ‘Future’ ...
[17:40:20.927]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.886] - state: ‘created’
[17:40:20.927]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.886] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.927]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.890] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:20.928]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:20.928]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.891]   - Field: ‘label’
[17:40:20.928]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.891]   - Field: ‘local’
[17:40:20.928]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.891]   - Field: ‘owner’
[17:40:20.928]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.891]   - Field: ‘envir’
[17:40:20.928]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘packages’
[17:40:20.929]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘gc’
[17:40:20.929]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘conditions’
[17:40:20.929]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘expr’
[17:40:20.929]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘uuid’
[17:40:20.929]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘seed’
[17:40:20.929]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.892]   - Field: ‘version’
[17:40:20.929]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.893]   - Field: ‘result’
[17:40:20.930]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.893]   - Field: ‘asynchronous’
[17:40:20.930]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.893]   - Field: ‘calls’
[17:40:20.930]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.893]   - Field: ‘globals’
[17:40:20.930]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.893]   - Field: ‘stdout’
[17:40:20.930]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.893]   - Field: ‘earlySignal’
[17:40:20.930]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.894]   - Field: ‘lazy’
[17:40:20.930]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.894]   - Field: ‘state’
[17:40:20.931]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:20.931]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.894] - Launch lazy future ...
[17:40:20.931]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.894] Packages needed by the future expression (n = 0): <none>
[17:40:20.931]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.895] Packages needed by future strategies (n = 0): <none>
[17:40:20.931]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.895] {
[17:40:20.895]     {
[17:40:20.895]         {
[17:40:20.895]             ...future.startTime <- base::Sys.time()
[17:40:20.895]             {
[17:40:20.895]                 {
[17:40:20.895]                   {
[17:40:20.895]                     base::local({
[17:40:20.895]                       has_future <- base::requireNamespace("future", 
[17:40:20.895]                         quietly = TRUE)
[17:40:20.895]                       if (has_future) {
[17:40:20.895]                         ns <- base::getNamespace("future")
[17:40:20.895]                         version <- ns[[".package"]][["version"]]
[17:40:20.895]                         if (is.null(version)) 
[17:40:20.895]                           version <- utils::packageVersion("future")
[17:40:20.895]                       }
[17:40:20.895]                       else {
[17:40:20.895]                         version <- NULL
[17:40:20.895]                       }
[17:40:20.895]                       if (!has_future || version < "1.8.0") {
[17:40:20.895]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.895]                           "", base::R.version$version.string), 
[17:40:20.895]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:20.895]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:20.895]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.895]                             "release", "version")], collapse = " "), 
[17:40:20.895]                           hostname = base::Sys.info()[["nodename"]])
[17:40:20.895]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.895]                           info)
[17:40:20.895]                         info <- base::paste(info, collapse = "; ")
[17:40:20.895]                         if (!has_future) {
[17:40:20.895]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.895]                             info)
[17:40:20.895]                         }
[17:40:20.895]                         else {
[17:40:20.895]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.895]                             info, version)
[17:40:20.895]                         }
[17:40:20.895]                         base::stop(msg)
[17:40:20.895]                       }
[17:40:20.895]                     })
[17:40:20.895]                   }
[17:40:20.895]                   ...future.strategy.old <- future::plan("list")
[17:40:20.895]                   options(future.plan = NULL)
[17:40:20.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:20.895]                 }
[17:40:20.895]                 ...future.workdir <- getwd()
[17:40:20.895]             }
[17:40:20.895]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.895]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.895]         }
[17:40:20.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.895]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.895]             base::names(...future.oldOptions))
[17:40:20.895]     }
[17:40:20.895]     if (FALSE) {
[17:40:20.895]     }
[17:40:20.895]     else {
[17:40:20.895]         if (TRUE) {
[17:40:20.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.895]                 open = "w")
[17:40:20.895]         }
[17:40:20.895]         else {
[17:40:20.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.895]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.895]         }
[17:40:20.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.895]             base::sink(type = "output", split = FALSE)
[17:40:20.895]             base::close(...future.stdout)
[17:40:20.895]         }, add = TRUE)
[17:40:20.895]     }
[17:40:20.895]     ...future.frame <- base::sys.nframe()
[17:40:20.895]     ...future.conditions <- base::list()
[17:40:20.895]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.895]     if (FALSE) {
[17:40:20.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.895]     }
[17:40:20.895]     ...future.result <- base::tryCatch({
[17:40:20.895]         base::withCallingHandlers({
[17:40:20.895]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:40:20.895]                 a == 2)))
[17:40:20.895]             future::FutureResult(value = ...future.value$value, 
[17:40:20.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.895]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.895]                     ...future.globalenv.names))
[17:40:20.895]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.895]         }, condition = base::local({
[17:40:20.895]             c <- base::c
[17:40:20.895]             inherits <- base::inherits
[17:40:20.895]             invokeRestart <- base::invokeRestart
[17:40:20.895]             length <- base::length
[17:40:20.895]             list <- base::list
[17:40:20.895]             seq.int <- base::seq.int
[17:40:20.895]             signalCondition <- base::signalCondition
[17:40:20.895]             sys.calls <- base::sys.calls
[17:40:20.895]             `[[` <- base::`[[`
[17:40:20.895]             `+` <- base::`+`
[17:40:20.895]             `<<-` <- base::`<<-`
[17:40:20.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.895]                   3L)]
[17:40:20.895]             }
[17:40:20.895]             function(cond) {
[17:40:20.895]                 is_error <- inherits(cond, "error")
[17:40:20.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.895]                   NULL)
[17:40:20.895]                 if (is_error) {
[17:40:20.895]                   sessionInformation <- function() {
[17:40:20.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.895]                       search = base::search(), system = base::Sys.info())
[17:40:20.895]                   }
[17:40:20.895]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.895]                     cond$call), session = sessionInformation(), 
[17:40:20.895]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.895]                   signalCondition(cond)
[17:40:20.895]                 }
[17:40:20.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.895]                 "immediateCondition"))) {
[17:40:20.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.895]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.895]                   if (TRUE && !signal) {
[17:40:20.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.895]                     {
[17:40:20.895]                       inherits <- base::inherits
[17:40:20.895]                       invokeRestart <- base::invokeRestart
[17:40:20.895]                       is.null <- base::is.null
[17:40:20.895]                       muffled <- FALSE
[17:40:20.895]                       if (inherits(cond, "message")) {
[17:40:20.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.895]                         if (muffled) 
[17:40:20.895]                           invokeRestart("muffleMessage")
[17:40:20.895]                       }
[17:40:20.895]                       else if (inherits(cond, "warning")) {
[17:40:20.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.895]                         if (muffled) 
[17:40:20.895]                           invokeRestart("muffleWarning")
[17:40:20.895]                       }
[17:40:20.895]                       else if (inherits(cond, "condition")) {
[17:40:20.895]                         if (!is.null(pattern)) {
[17:40:20.895]                           computeRestarts <- base::computeRestarts
[17:40:20.895]                           grepl <- base::grepl
[17:40:20.895]                           restarts <- computeRestarts(cond)
[17:40:20.895]                           for (restart in restarts) {
[17:40:20.895]                             name <- restart$name
[17:40:20.895]                             if (is.null(name)) 
[17:40:20.895]                               next
[17:40:20.895]                             if (!grepl(pattern, name)) 
[17:40:20.895]                               next
[17:40:20.895]                             invokeRestart(restart)
[17:40:20.895]                             muffled <- TRUE
[17:40:20.895]                             break
[17:40:20.895]                           }
[17:40:20.895]                         }
[17:40:20.895]                       }
[17:40:20.895]                       invisible(muffled)
[17:40:20.895]                     }
[17:40:20.895]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.895]                   }
[17:40:20.895]                 }
[17:40:20.895]                 else {
[17:40:20.895]                   if (TRUE) {
[17:40:20.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.895]                     {
[17:40:20.895]                       inherits <- base::inherits
[17:40:20.895]                       invokeRestart <- base::invokeRestart
[17:40:20.895]                       is.null <- base::is.null
[17:40:20.895]                       muffled <- FALSE
[17:40:20.895]                       if (inherits(cond, "message")) {
[17:40:20.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.895]                         if (muffled) 
[17:40:20.895]                           invokeRestart("muffleMessage")
[17:40:20.895]                       }
[17:40:20.895]                       else if (inherits(cond, "warning")) {
[17:40:20.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.895]                         if (muffled) 
[17:40:20.895]                           invokeRestart("muffleWarning")
[17:40:20.895]                       }
[17:40:20.895]                       else if (inherits(cond, "condition")) {
[17:40:20.895]                         if (!is.null(pattern)) {
[17:40:20.895]                           computeRestarts <- base::computeRestarts
[17:40:20.895]                           grepl <- base::grepl
[17:40:20.895]                           restarts <- computeRestarts(cond)
[17:40:20.895]                           for (restart in restarts) {
[17:40:20.895]                             name <- restart$name
[17:40:20.895]                             if (is.null(name)) 
[17:40:20.895]                               next
[17:40:20.895]                             if (!grepl(pattern, name)) 
[17:40:20.895]                               next
[17:40:20.895]                             invokeRestart(restart)
[17:40:20.895]                             muffled <- TRUE
[17:40:20.895]                             break
[17:40:20.895]                           }
[17:40:20.895]                         }
[17:40:20.895]                       }
[17:40:20.895]                       invisible(muffled)
[17:40:20.895]                     }
[17:40:20.895]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.895]                   }
[17:40:20.895]                 }
[17:40:20.895]             }
[17:40:20.895]         }))
[17:40:20.895]     }, error = function(ex) {
[17:40:20.895]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.895]                 ...future.rng), started = ...future.startTime, 
[17:40:20.895]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.895]             version = "1.8"), class = "FutureResult")
[17:40:20.895]     }, finally = {
[17:40:20.895]         if (!identical(...future.workdir, getwd())) 
[17:40:20.895]             setwd(...future.workdir)
[17:40:20.895]         {
[17:40:20.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.895]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.895]             }
[17:40:20.895]             base::options(...future.oldOptions)
[17:40:20.895]             if (.Platform$OS.type == "windows") {
[17:40:20.895]                 old_names <- names(...future.oldEnvVars)
[17:40:20.895]                 envs <- base::Sys.getenv()
[17:40:20.895]                 names <- names(envs)
[17:40:20.895]                 common <- intersect(names, old_names)
[17:40:20.895]                 added <- setdiff(names, old_names)
[17:40:20.895]                 removed <- setdiff(old_names, names)
[17:40:20.895]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.895]                   envs[common]]
[17:40:20.895]                 NAMES <- toupper(changed)
[17:40:20.895]                 args <- list()
[17:40:20.895]                 for (kk in seq_along(NAMES)) {
[17:40:20.895]                   name <- changed[[kk]]
[17:40:20.895]                   NAME <- NAMES[[kk]]
[17:40:20.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.895]                     next
[17:40:20.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.895]                 }
[17:40:20.895]                 NAMES <- toupper(added)
[17:40:20.895]                 for (kk in seq_along(NAMES)) {
[17:40:20.895]                   name <- added[[kk]]
[17:40:20.895]                   NAME <- NAMES[[kk]]
[17:40:20.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.895]                     next
[17:40:20.895]                   args[[name]] <- ""
[17:40:20.895]                 }
[17:40:20.895]                 NAMES <- toupper(removed)
[17:40:20.895]                 for (kk in seq_along(NAMES)) {
[17:40:20.895]                   name <- removed[[kk]]
[17:40:20.895]                   NAME <- NAMES[[kk]]
[17:40:20.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.895]                     next
[17:40:20.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.895]                 }
[17:40:20.895]                 if (length(args) > 0) 
[17:40:20.895]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.895]             }
[17:40:20.895]             else {
[17:40:20.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.895]             }
[17:40:20.895]             {
[17:40:20.895]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.895]                   0L) {
[17:40:20.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.895]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.895]                   base::options(opts)
[17:40:20.895]                 }
[17:40:20.895]                 {
[17:40:20.895]                   {
[17:40:20.895]                     NULL
[17:40:20.895]                     RNGkind("Mersenne-Twister")
[17:40:20.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:20.895]                       inherits = FALSE)
[17:40:20.895]                   }
[17:40:20.895]                   options(future.plan = NULL)
[17:40:20.895]                   if (is.na(NA_character_)) 
[17:40:20.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.895]                     .init = FALSE)
[17:40:20.895]                 }
[17:40:20.895]             }
[17:40:20.895]         }
[17:40:20.895]     })
[17:40:20.895]     if (TRUE) {
[17:40:20.895]         base::sink(type = "output", split = FALSE)
[17:40:20.895]         if (TRUE) {
[17:40:20.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.895]         }
[17:40:20.895]         else {
[17:40:20.895]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.895]         }
[17:40:20.895]         base::close(...future.stdout)
[17:40:20.895]         ...future.stdout <- NULL
[17:40:20.895]     }
[17:40:20.895]     ...future.result$conditions <- ...future.conditions
[17:40:20.895]     ...future.result$finished <- base::Sys.time()
[17:40:20.895]     ...future.result
[17:40:20.895] }
[17:40:20.931]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.897] assign_globals() ...
[17:40:20.932]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.898] List of 1
[17:40:20.898]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:20.898]   ..$ a: int [1:3] 1 2 3
[17:40:20.898]   ..$ b: int [1:3] 3 2 1
[17:40:20.898]  - attr(*, "where")=List of 1
[17:40:20.898]   ..$ data:<environment: R_EmptyEnv> 
[17:40:20.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.898]  - attr(*, "resolved")= logi FALSE
[17:40:20.898]  - attr(*, "total_size")= num 128
[17:40:20.898]  - attr(*, "already-done")= logi TRUE
[17:40:20.932]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.902] - copied ‘data’ to environment
[17:40:20.932]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.902] assign_globals() ... done
[17:40:20.932]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.903] plan(): Setting new future strategy stack:
[17:40:20.932]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.903] List of future strategies:
[17:40:20.903] 1. sequential:
[17:40:20.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:20.903]    - tweaked: FALSE
[17:40:20.903]    - call: NULL
[17:40:20.932]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.904] plan(): nbrOfWorkers() = 1
[17:40:20.932]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.905] plan(): Setting new future strategy stack:
[17:40:20.933]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.905] List of future strategies:
[17:40:20.905] 1. multicore:
[17:40:20.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.905]    - tweaked: FALSE
[17:40:20.905]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.933]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.909] plan(): nbrOfWorkers() = 1
[17:40:20.933]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.909] SequentialFuture started (and completed)
[17:40:20.933]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.909] - Launch lazy future ... done
[17:40:20.933]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.915] run() for ‘SequentialFuture’ ... done
[17:40:20.933] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[17:40:20.934] plan(): Setting new future strategy stack:
[17:40:20.934] List of future strategies:
[17:40:20.934] 1. multicore:
[17:40:20.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:20.934]    - tweaked: FALSE
[17:40:20.934]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.934] 2. multisession:
[17:40:20.934]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:20.934]    - tweaked: FALSE
[17:40:20.934]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.938] plan(): nbrOfWorkers() = 2
[17:40:20.939] getGlobalsAndPackages() ...
[17:40:20.939] Searching for globals...
[17:40:20.961] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:20.962] Searching for globals ... DONE
[17:40:20.962] Resolving globals: FALSE
[17:40:20.963] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[17:40:20.963] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:20.964] - globals: [2] ‘nested’, ‘strategy2’
[17:40:20.964] - packages: [1] ‘future’
[17:40:20.964] getGlobalsAndPackages() ... DONE
[17:40:20.964] run() for ‘Future’ ...
[17:40:20.964] - state: ‘created’
[17:40:20.964] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:20.968] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:20.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:20.968]   - Field: ‘label’
[17:40:20.969]   - Field: ‘local’
[17:40:20.969]   - Field: ‘owner’
[17:40:20.969]   - Field: ‘envir’
[17:40:20.969]   - Field: ‘workers’
[17:40:20.969]   - Field: ‘packages’
[17:40:20.969]   - Field: ‘gc’
[17:40:20.969]   - Field: ‘job’
[17:40:20.969]   - Field: ‘conditions’
[17:40:20.969]   - Field: ‘expr’
[17:40:20.970]   - Field: ‘uuid’
[17:40:20.970]   - Field: ‘seed’
[17:40:20.970]   - Field: ‘version’
[17:40:20.970]   - Field: ‘result’
[17:40:20.970]   - Field: ‘asynchronous’
[17:40:20.970]   - Field: ‘calls’
[17:40:20.970]   - Field: ‘globals’
[17:40:20.970]   - Field: ‘stdout’
[17:40:20.970]   - Field: ‘earlySignal’
[17:40:20.970]   - Field: ‘lazy’
[17:40:20.971]   - Field: ‘state’
[17:40:20.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:20.971] - Launch lazy future ...
[17:40:20.971] Packages needed by the future expression (n = 1): ‘future’
[17:40:20.971] Packages needed by future strategies (n = 1): ‘future’
[17:40:20.972] {
[17:40:20.972]     {
[17:40:20.972]         {
[17:40:20.972]             ...future.startTime <- base::Sys.time()
[17:40:20.972]             {
[17:40:20.972]                 {
[17:40:20.972]                   {
[17:40:20.972]                     {
[17:40:20.972]                       {
[17:40:20.972]                         base::local({
[17:40:20.972]                           has_future <- base::requireNamespace("future", 
[17:40:20.972]                             quietly = TRUE)
[17:40:20.972]                           if (has_future) {
[17:40:20.972]                             ns <- base::getNamespace("future")
[17:40:20.972]                             version <- ns[[".package"]][["version"]]
[17:40:20.972]                             if (is.null(version)) 
[17:40:20.972]                               version <- utils::packageVersion("future")
[17:40:20.972]                           }
[17:40:20.972]                           else {
[17:40:20.972]                             version <- NULL
[17:40:20.972]                           }
[17:40:20.972]                           if (!has_future || version < "1.8.0") {
[17:40:20.972]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:20.972]                               "", base::R.version$version.string), 
[17:40:20.972]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:20.972]                                 base::R.version$platform, 8 * 
[17:40:20.972]                                   base::.Machine$sizeof.pointer), 
[17:40:20.972]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:20.972]                                 "release", "version")], collapse = " "), 
[17:40:20.972]                               hostname = base::Sys.info()[["nodename"]])
[17:40:20.972]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:20.972]                               info)
[17:40:20.972]                             info <- base::paste(info, collapse = "; ")
[17:40:20.972]                             if (!has_future) {
[17:40:20.972]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:20.972]                                 info)
[17:40:20.972]                             }
[17:40:20.972]                             else {
[17:40:20.972]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:20.972]                                 info, version)
[17:40:20.972]                             }
[17:40:20.972]                             base::stop(msg)
[17:40:20.972]                           }
[17:40:20.972]                         })
[17:40:20.972]                       }
[17:40:20.972]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:20.972]                       base::options(mc.cores = 1L)
[17:40:20.972]                     }
[17:40:20.972]                     base::local({
[17:40:20.972]                       for (pkg in "future") {
[17:40:20.972]                         base::loadNamespace(pkg)
[17:40:20.972]                         base::library(pkg, character.only = TRUE)
[17:40:20.972]                       }
[17:40:20.972]                     })
[17:40:20.972]                   }
[17:40:20.972]                   ...future.strategy.old <- future::plan("list")
[17:40:20.972]                   options(future.plan = NULL)
[17:40:20.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.972]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:20.972]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:20.972]                     envir = parent.frame()) 
[17:40:20.972]                   {
[17:40:20.972]                     if (is.function(workers)) 
[17:40:20.972]                       workers <- workers()
[17:40:20.972]                     workers <- structure(as.integer(workers), 
[17:40:20.972]                       class = class(workers))
[17:40:20.972]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:20.972]                       workers >= 1)
[17:40:20.972]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:20.972]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:20.972]                     }
[17:40:20.972]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:20.972]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:20.972]                       envir = envir)
[17:40:20.972]                     if (!future$lazy) 
[17:40:20.972]                       future <- run(future)
[17:40:20.972]                     invisible(future)
[17:40:20.972]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:20.972]                 }
[17:40:20.972]                 ...future.workdir <- getwd()
[17:40:20.972]             }
[17:40:20.972]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:20.972]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:20.972]         }
[17:40:20.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:20.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:20.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:20.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:20.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:20.972]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:20.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:20.972]             base::names(...future.oldOptions))
[17:40:20.972]     }
[17:40:20.972]     if (FALSE) {
[17:40:20.972]     }
[17:40:20.972]     else {
[17:40:20.972]         if (TRUE) {
[17:40:20.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:20.972]                 open = "w")
[17:40:20.972]         }
[17:40:20.972]         else {
[17:40:20.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:20.972]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:20.972]         }
[17:40:20.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:20.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:20.972]             base::sink(type = "output", split = FALSE)
[17:40:20.972]             base::close(...future.stdout)
[17:40:20.972]         }, add = TRUE)
[17:40:20.972]     }
[17:40:20.972]     ...future.frame <- base::sys.nframe()
[17:40:20.972]     ...future.conditions <- base::list()
[17:40:20.972]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:20.972]     if (FALSE) {
[17:40:20.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:20.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:20.972]     }
[17:40:20.972]     ...future.result <- base::tryCatch({
[17:40:20.972]         base::withCallingHandlers({
[17:40:20.972]             ...future.value <- base::withVisible(base::local({
[17:40:20.972]                 withCallingHandlers({
[17:40:20.972]                   {
[17:40:20.972]                     a <- 1L
[17:40:20.972]                     plan_a <- unclass(future::plan("list"))
[17:40:20.972]                     nested_a <- nested[-1]
[17:40:20.972]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:20.972]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:20.972]                       strategy2))
[17:40:20.972]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:20.972]                       "init") <- NULL
[17:40:20.972]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:20.972]                       "init") <- NULL
[17:40:20.972]                     stopifnot(all.equal(plan_a, nested_a))
[17:40:20.972]                     y %<-% {
[17:40:20.972]                       b <- 2L
[17:40:20.972]                       plan_b <- future::plan("list")
[17:40:20.972]                       nested_b <- nested_a[-1]
[17:40:20.972]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:20.972]                         1L, inherits(plan_b[[1]], "future"), 
[17:40:20.972]                         inherits(future::plan("next"), "sequential"))
[17:40:20.972]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:20.972]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:20.972]                     }
[17:40:20.972]                     y
[17:40:20.972]                   }
[17:40:20.972]                 }, immediateCondition = function(cond) {
[17:40:20.972]                   save_rds <- function (object, pathname, ...) 
[17:40:20.972]                   {
[17:40:20.972]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:20.972]                     if (file_test("-f", pathname_tmp)) {
[17:40:20.972]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.972]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:20.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.972]                         fi_tmp[["mtime"]])
[17:40:20.972]                     }
[17:40:20.972]                     tryCatch({
[17:40:20.972]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:20.972]                     }, error = function(ex) {
[17:40:20.972]                       msg <- conditionMessage(ex)
[17:40:20.972]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.972]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:20.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.972]                         fi_tmp[["mtime"]], msg)
[17:40:20.972]                       ex$message <- msg
[17:40:20.972]                       stop(ex)
[17:40:20.972]                     })
[17:40:20.972]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:20.972]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:20.972]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:20.972]                       fi_tmp <- file.info(pathname_tmp)
[17:40:20.972]                       fi <- file.info(pathname)
[17:40:20.972]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:20.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:20.972]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:20.972]                         fi[["size"]], fi[["mtime"]])
[17:40:20.972]                       stop(msg)
[17:40:20.972]                     }
[17:40:20.972]                     invisible(pathname)
[17:40:20.972]                   }
[17:40:20.972]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:20.972]                     rootPath = tempdir()) 
[17:40:20.972]                   {
[17:40:20.972]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:20.972]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:20.972]                       tmpdir = path, fileext = ".rds")
[17:40:20.972]                     save_rds(obj, file)
[17:40:20.972]                   }
[17:40:20.972]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:20.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.972]                   {
[17:40:20.972]                     inherits <- base::inherits
[17:40:20.972]                     invokeRestart <- base::invokeRestart
[17:40:20.972]                     is.null <- base::is.null
[17:40:20.972]                     muffled <- FALSE
[17:40:20.972]                     if (inherits(cond, "message")) {
[17:40:20.972]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:20.972]                       if (muffled) 
[17:40:20.972]                         invokeRestart("muffleMessage")
[17:40:20.972]                     }
[17:40:20.972]                     else if (inherits(cond, "warning")) {
[17:40:20.972]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:20.972]                       if (muffled) 
[17:40:20.972]                         invokeRestart("muffleWarning")
[17:40:20.972]                     }
[17:40:20.972]                     else if (inherits(cond, "condition")) {
[17:40:20.972]                       if (!is.null(pattern)) {
[17:40:20.972]                         computeRestarts <- base::computeRestarts
[17:40:20.972]                         grepl <- base::grepl
[17:40:20.972]                         restarts <- computeRestarts(cond)
[17:40:20.972]                         for (restart in restarts) {
[17:40:20.972]                           name <- restart$name
[17:40:20.972]                           if (is.null(name)) 
[17:40:20.972]                             next
[17:40:20.972]                           if (!grepl(pattern, name)) 
[17:40:20.972]                             next
[17:40:20.972]                           invokeRestart(restart)
[17:40:20.972]                           muffled <- TRUE
[17:40:20.972]                           break
[17:40:20.972]                         }
[17:40:20.972]                       }
[17:40:20.972]                     }
[17:40:20.972]                     invisible(muffled)
[17:40:20.972]                   }
[17:40:20.972]                   muffleCondition(cond)
[17:40:20.972]                 })
[17:40:20.972]             }))
[17:40:20.972]             future::FutureResult(value = ...future.value$value, 
[17:40:20.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.972]                   ...future.rng), globalenv = if (FALSE) 
[17:40:20.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:20.972]                     ...future.globalenv.names))
[17:40:20.972]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:20.972]         }, condition = base::local({
[17:40:20.972]             c <- base::c
[17:40:20.972]             inherits <- base::inherits
[17:40:20.972]             invokeRestart <- base::invokeRestart
[17:40:20.972]             length <- base::length
[17:40:20.972]             list <- base::list
[17:40:20.972]             seq.int <- base::seq.int
[17:40:20.972]             signalCondition <- base::signalCondition
[17:40:20.972]             sys.calls <- base::sys.calls
[17:40:20.972]             `[[` <- base::`[[`
[17:40:20.972]             `+` <- base::`+`
[17:40:20.972]             `<<-` <- base::`<<-`
[17:40:20.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:20.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:20.972]                   3L)]
[17:40:20.972]             }
[17:40:20.972]             function(cond) {
[17:40:20.972]                 is_error <- inherits(cond, "error")
[17:40:20.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:20.972]                   NULL)
[17:40:20.972]                 if (is_error) {
[17:40:20.972]                   sessionInformation <- function() {
[17:40:20.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:20.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:20.972]                       search = base::search(), system = base::Sys.info())
[17:40:20.972]                   }
[17:40:20.972]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:20.972]                     cond$call), session = sessionInformation(), 
[17:40:20.972]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:20.972]                   signalCondition(cond)
[17:40:20.972]                 }
[17:40:20.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:20.972]                 "immediateCondition"))) {
[17:40:20.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:20.972]                   ...future.conditions[[length(...future.conditions) + 
[17:40:20.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:20.972]                   if (TRUE && !signal) {
[17:40:20.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.972]                     {
[17:40:20.972]                       inherits <- base::inherits
[17:40:20.972]                       invokeRestart <- base::invokeRestart
[17:40:20.972]                       is.null <- base::is.null
[17:40:20.972]                       muffled <- FALSE
[17:40:20.972]                       if (inherits(cond, "message")) {
[17:40:20.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.972]                         if (muffled) 
[17:40:20.972]                           invokeRestart("muffleMessage")
[17:40:20.972]                       }
[17:40:20.972]                       else if (inherits(cond, "warning")) {
[17:40:20.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.972]                         if (muffled) 
[17:40:20.972]                           invokeRestart("muffleWarning")
[17:40:20.972]                       }
[17:40:20.972]                       else if (inherits(cond, "condition")) {
[17:40:20.972]                         if (!is.null(pattern)) {
[17:40:20.972]                           computeRestarts <- base::computeRestarts
[17:40:20.972]                           grepl <- base::grepl
[17:40:20.972]                           restarts <- computeRestarts(cond)
[17:40:20.972]                           for (restart in restarts) {
[17:40:20.972]                             name <- restart$name
[17:40:20.972]                             if (is.null(name)) 
[17:40:20.972]                               next
[17:40:20.972]                             if (!grepl(pattern, name)) 
[17:40:20.972]                               next
[17:40:20.972]                             invokeRestart(restart)
[17:40:20.972]                             muffled <- TRUE
[17:40:20.972]                             break
[17:40:20.972]                           }
[17:40:20.972]                         }
[17:40:20.972]                       }
[17:40:20.972]                       invisible(muffled)
[17:40:20.972]                     }
[17:40:20.972]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.972]                   }
[17:40:20.972]                 }
[17:40:20.972]                 else {
[17:40:20.972]                   if (TRUE) {
[17:40:20.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:20.972]                     {
[17:40:20.972]                       inherits <- base::inherits
[17:40:20.972]                       invokeRestart <- base::invokeRestart
[17:40:20.972]                       is.null <- base::is.null
[17:40:20.972]                       muffled <- FALSE
[17:40:20.972]                       if (inherits(cond, "message")) {
[17:40:20.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:20.972]                         if (muffled) 
[17:40:20.972]                           invokeRestart("muffleMessage")
[17:40:20.972]                       }
[17:40:20.972]                       else if (inherits(cond, "warning")) {
[17:40:20.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:20.972]                         if (muffled) 
[17:40:20.972]                           invokeRestart("muffleWarning")
[17:40:20.972]                       }
[17:40:20.972]                       else if (inherits(cond, "condition")) {
[17:40:20.972]                         if (!is.null(pattern)) {
[17:40:20.972]                           computeRestarts <- base::computeRestarts
[17:40:20.972]                           grepl <- base::grepl
[17:40:20.972]                           restarts <- computeRestarts(cond)
[17:40:20.972]                           for (restart in restarts) {
[17:40:20.972]                             name <- restart$name
[17:40:20.972]                             if (is.null(name)) 
[17:40:20.972]                               next
[17:40:20.972]                             if (!grepl(pattern, name)) 
[17:40:20.972]                               next
[17:40:20.972]                             invokeRestart(restart)
[17:40:20.972]                             muffled <- TRUE
[17:40:20.972]                             break
[17:40:20.972]                           }
[17:40:20.972]                         }
[17:40:20.972]                       }
[17:40:20.972]                       invisible(muffled)
[17:40:20.972]                     }
[17:40:20.972]                     muffleCondition(cond, pattern = "^muffle")
[17:40:20.972]                   }
[17:40:20.972]                 }
[17:40:20.972]             }
[17:40:20.972]         }))
[17:40:20.972]     }, error = function(ex) {
[17:40:20.972]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:20.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:20.972]                 ...future.rng), started = ...future.startTime, 
[17:40:20.972]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:20.972]             version = "1.8"), class = "FutureResult")
[17:40:20.972]     }, finally = {
[17:40:20.972]         if (!identical(...future.workdir, getwd())) 
[17:40:20.972]             setwd(...future.workdir)
[17:40:20.972]         {
[17:40:20.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:20.972]                 ...future.oldOptions$nwarnings <- NULL
[17:40:20.972]             }
[17:40:20.972]             base::options(...future.oldOptions)
[17:40:20.972]             if (.Platform$OS.type == "windows") {
[17:40:20.972]                 old_names <- names(...future.oldEnvVars)
[17:40:20.972]                 envs <- base::Sys.getenv()
[17:40:20.972]                 names <- names(envs)
[17:40:20.972]                 common <- intersect(names, old_names)
[17:40:20.972]                 added <- setdiff(names, old_names)
[17:40:20.972]                 removed <- setdiff(old_names, names)
[17:40:20.972]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:20.972]                   envs[common]]
[17:40:20.972]                 NAMES <- toupper(changed)
[17:40:20.972]                 args <- list()
[17:40:20.972]                 for (kk in seq_along(NAMES)) {
[17:40:20.972]                   name <- changed[[kk]]
[17:40:20.972]                   NAME <- NAMES[[kk]]
[17:40:20.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.972]                     next
[17:40:20.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.972]                 }
[17:40:20.972]                 NAMES <- toupper(added)
[17:40:20.972]                 for (kk in seq_along(NAMES)) {
[17:40:20.972]                   name <- added[[kk]]
[17:40:20.972]                   NAME <- NAMES[[kk]]
[17:40:20.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.972]                     next
[17:40:20.972]                   args[[name]] <- ""
[17:40:20.972]                 }
[17:40:20.972]                 NAMES <- toupper(removed)
[17:40:20.972]                 for (kk in seq_along(NAMES)) {
[17:40:20.972]                   name <- removed[[kk]]
[17:40:20.972]                   NAME <- NAMES[[kk]]
[17:40:20.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:20.972]                     next
[17:40:20.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:20.972]                 }
[17:40:20.972]                 if (length(args) > 0) 
[17:40:20.972]                   base::do.call(base::Sys.setenv, args = args)
[17:40:20.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:20.972]             }
[17:40:20.972]             else {
[17:40:20.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:20.972]             }
[17:40:20.972]             {
[17:40:20.972]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:20.972]                   0L) {
[17:40:20.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:20.972]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:20.972]                   base::options(opts)
[17:40:20.972]                 }
[17:40:20.972]                 {
[17:40:20.972]                   {
[17:40:20.972]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:20.972]                     NULL
[17:40:20.972]                   }
[17:40:20.972]                   options(future.plan = NULL)
[17:40:20.972]                   if (is.na(NA_character_)) 
[17:40:20.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:20.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:20.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:20.972]                     .init = FALSE)
[17:40:20.972]                 }
[17:40:20.972]             }
[17:40:20.972]         }
[17:40:20.972]     })
[17:40:20.972]     if (TRUE) {
[17:40:20.972]         base::sink(type = "output", split = FALSE)
[17:40:20.972]         if (TRUE) {
[17:40:20.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:20.972]         }
[17:40:20.972]         else {
[17:40:20.972]             ...future.result["stdout"] <- base::list(NULL)
[17:40:20.972]         }
[17:40:20.972]         base::close(...future.stdout)
[17:40:20.972]         ...future.stdout <- NULL
[17:40:20.972]     }
[17:40:20.972]     ...future.result$conditions <- ...future.conditions
[17:40:20.972]     ...future.result$finished <- base::Sys.time()
[17:40:20.972]     ...future.result
[17:40:20.972] }
[17:40:20.975] assign_globals() ...
[17:40:20.975] List of 2
[17:40:20.975]  $ nested   :List of 2
[17:40:20.975]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[17:40:20.975]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[17:40:20.975]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.975]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:20.975]     envir = parent.frame())  
[17:40:20.975]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:40:20.975]   .. ..- attr(*, "init")= logi TRUE
[17:40:20.975]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:40:20.975]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:20.975]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:20.975]  $ strategy2: chr "multisession"
[17:40:20.975]  - attr(*, "where")=List of 2
[17:40:20.975]   ..$ nested   :<environment: R_EmptyEnv> 
[17:40:20.975]   ..$ strategy2:<environment: R_EmptyEnv> 
[17:40:20.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:20.975]  - attr(*, "resolved")= logi FALSE
[17:40:20.975]  - attr(*, "total_size")= num 92816
[17:40:20.975]  - attr(*, "already-done")= logi TRUE
[17:40:20.981] - copied ‘nested’ to environment
[17:40:20.981] - copied ‘strategy2’ to environment
[17:40:20.981] assign_globals() ... done
[17:40:20.981] requestCore(): workers = 2
[17:40:20.983] MulticoreFuture started
[17:40:20.984] - Launch lazy future ... done
[17:40:20.984] run() for ‘MulticoreFuture’ ... done
[17:40:20.984] result() for MulticoreFuture ...
[17:40:20.985] plan(): Setting new future strategy stack:
[17:40:20.985] List of future strategies:
[17:40:20.985] 1. multisession:
[17:40:20.985]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:20.985]    - tweaked: FALSE
[17:40:20.985]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:20.991] plan(): nbrOfWorkers() = 1
[17:40:21.031] plan(): Setting new future strategy stack:
[17:40:21.031] List of future strategies:
[17:40:21.031] 1. multicore:
[17:40:21.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:21.031]    - tweaked: FALSE
[17:40:21.031]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.031] 2. multisession:
[17:40:21.031]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.031]    - tweaked: FALSE
[17:40:21.031]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.036] plan(): nbrOfWorkers() = 2
[17:40:21.037] result() for MulticoreFuture ...
[17:40:21.037] result() for MulticoreFuture ... done
[17:40:21.038] signalConditions() ...
[17:40:21.038]  - include = ‘immediateCondition’
[17:40:21.038]  - exclude = 
[17:40:21.038]  - resignal = FALSE
[17:40:21.038]  - Number of conditions: 54
[17:40:21.038] signalConditions() ... done
[17:40:21.039] result() for MulticoreFuture ... done
[17:40:21.039] result() for MulticoreFuture ...
[17:40:21.039] result() for MulticoreFuture ... done
[17:40:21.039] signalConditions() ...
[17:40:21.039]  - include = ‘immediateCondition’
[17:40:21.039]  - exclude = 
[17:40:21.039]  - resignal = FALSE
[17:40:21.040]  - Number of conditions: 54
[17:40:21.040] signalConditions() ... done
[17:40:21.040] Future state: ‘finished’
[17:40:21.040] result() for MulticoreFuture ...
[17:40:21.040] result() for MulticoreFuture ... done
[17:40:21.041] signalConditions() ...
[17:40:21.041]  - include = ‘condition’
[17:40:21.041]  - exclude = ‘immediateCondition’
[17:40:21.041]  - resignal = TRUE
[17:40:21.041]  - Number of conditions: 54
[17:40:21.041]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.992] getGlobalsAndPackages() ...
[17:40:21.042]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:20.993] Searching for globals...
[17:40:21.042]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.000] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[17:40:21.042]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.000] Searching for globals ... DONE
[17:40:21.042]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.001] Resolving globals: FALSE
[17:40:21.042]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.002] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[17:40:21.042]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.002] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[17:40:21.043]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.003] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[17:40:21.043]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.003] 
[17:40:21.043]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.003] getGlobalsAndPackages() ... DONE
[17:40:21.043]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.004] run() for ‘Future’ ...
[17:40:21.043]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.004] - state: ‘created’
[17:40:21.043]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:21.044]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:21.044]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:21.044]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.008]   - Field: ‘label’
[17:40:21.044]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.009]   - Field: ‘local’
[17:40:21.044]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.009]   - Field: ‘owner’
[17:40:21.044]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.009]   - Field: ‘envir’
[17:40:21.045]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.009]   - Field: ‘packages’
[17:40:21.045]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.009]   - Field: ‘gc’
[17:40:21.045]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.009]   - Field: ‘conditions’
[17:40:21.045]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘expr’
[17:40:21.045]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘uuid’
[17:40:21.045]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘seed’
[17:40:21.045]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘version’
[17:40:21.046]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘result’
[17:40:21.046]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘asynchronous’
[17:40:21.046]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.010]   - Field: ‘calls’
[17:40:21.046]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011]   - Field: ‘globals’
[17:40:21.046]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011]   - Field: ‘stdout’
[17:40:21.046]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011]   - Field: ‘earlySignal’
[17:40:21.047]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011]   - Field: ‘lazy’
[17:40:21.047]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011]   - Field: ‘state’
[17:40:21.047]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:21.047]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.011] - Launch lazy future ...
[17:40:21.047]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.012] Packages needed by the future expression (n = 0): <none>
[17:40:21.047]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.012] Packages needed by future strategies (n = 0): <none>
[17:40:21.047]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.013] {
[17:40:21.013]     {
[17:40:21.013]         {
[17:40:21.013]             ...future.startTime <- base::Sys.time()
[17:40:21.013]             {
[17:40:21.013]                 {
[17:40:21.013]                   {
[17:40:21.013]                     base::local({
[17:40:21.013]                       has_future <- base::requireNamespace("future", 
[17:40:21.013]                         quietly = TRUE)
[17:40:21.013]                       if (has_future) {
[17:40:21.013]                         ns <- base::getNamespace("future")
[17:40:21.013]                         version <- ns[[".package"]][["version"]]
[17:40:21.013]                         if (is.null(version)) 
[17:40:21.013]                           version <- utils::packageVersion("future")
[17:40:21.013]                       }
[17:40:21.013]                       else {
[17:40:21.013]                         version <- NULL
[17:40:21.013]                       }
[17:40:21.013]                       if (!has_future || version < "1.8.0") {
[17:40:21.013]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:21.013]                           "", base::R.version$version.string), 
[17:40:21.013]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:21.013]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:21.013]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:21.013]                             "release", "version")], collapse = " "), 
[17:40:21.013]                           hostname = base::Sys.info()[["nodename"]])
[17:40:21.013]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:21.013]                           info)
[17:40:21.013]                         info <- base::paste(info, collapse = "; ")
[17:40:21.013]                         if (!has_future) {
[17:40:21.013]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:21.013]                             info)
[17:40:21.013]                         }
[17:40:21.013]                         else {
[17:40:21.013]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:21.013]                             info, version)
[17:40:21.013]                         }
[17:40:21.013]                         base::stop(msg)
[17:40:21.013]                       }
[17:40:21.013]                     })
[17:40:21.013]                   }
[17:40:21.013]                   ...future.strategy.old <- future::plan("list")
[17:40:21.013]                   options(future.plan = NULL)
[17:40:21.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:21.013]                 }
[17:40:21.013]                 ...future.workdir <- getwd()
[17:40:21.013]             }
[17:40:21.013]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:21.013]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:21.013]         }
[17:40:21.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:21.013]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:21.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:21.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:21.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:21.013]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:21.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:21.013]             base::names(...future.oldOptions))
[17:40:21.013]     }
[17:40:21.013]     if (FALSE) {
[17:40:21.013]     }
[17:40:21.013]     else {
[17:40:21.013]         if (TRUE) {
[17:40:21.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:21.013]                 open = "w")
[17:40:21.013]         }
[17:40:21.013]         else {
[17:40:21.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:21.013]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:21.013]         }
[17:40:21.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:21.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:21.013]             base::sink(type = "output", split = FALSE)
[17:40:21.013]             base::close(...future.stdout)
[17:40:21.013]         }, add = TRUE)
[17:40:21.013]     }
[17:40:21.013]     ...future.frame <- base::sys.nframe()
[17:40:21.013]     ...future.conditions <- base::list()
[17:40:21.013]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:21.013]     if (FALSE) {
[17:40:21.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:21.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:21.013]     }
[17:40:21.013]     ...future.result <- base::tryCatch({
[17:40:21.013]         base::withCallingHandlers({
[17:40:21.013]             ...future.value <- base::withVisible(base::local({
[17:40:21.013]                 b <- 2L
[17:40:21.013]                 plan_b <- future::plan("list")
[17:40:21.013]                 nested_b <- nested_a[-1]
[17:40:21.013]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:21.013]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[17:40:21.013]                   "sequential"))
[17:40:21.013]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:21.013]                   b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:21.013]             }))
[17:40:21.013]             future::FutureResult(value = ...future.value$value, 
[17:40:21.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.013]                   ...future.rng), globalenv = if (FALSE) 
[17:40:21.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:21.013]                     ...future.globalenv.names))
[17:40:21.013]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:21.013]         }, condition = base::local({
[17:40:21.013]             c <- base::c
[17:40:21.013]             inherits <- base::inherits
[17:40:21.013]             invokeRestart <- base::invokeRestart
[17:40:21.013]             length <- base::length
[17:40:21.013]             list <- base::list
[17:40:21.013]             seq.int <- base::seq.int
[17:40:21.013]             signalCondition <- base::signalCondition
[17:40:21.013]             sys.calls <- base::sys.calls
[17:40:21.013]             `[[` <- base::`[[`
[17:40:21.013]             `+` <- base::`+`
[17:40:21.013]             `<<-` <- base::`<<-`
[17:40:21.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:21.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:21.013]                   3L)]
[17:40:21.013]             }
[17:40:21.013]             function(cond) {
[17:40:21.013]                 is_error <- inherits(cond, "error")
[17:40:21.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:21.013]                   NULL)
[17:40:21.013]                 if (is_error) {
[17:40:21.013]                   sessionInformation <- function() {
[17:40:21.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:21.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:21.013]                       search = base::search(), system = base::Sys.info())
[17:40:21.013]                   }
[17:40:21.013]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:21.013]                     cond$call), session = sessionInformation(), 
[17:40:21.013]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:21.013]                   signalCondition(cond)
[17:40:21.013]                 }
[17:40:21.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:21.013]                 "immediateCondition"))) {
[17:40:21.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:21.013]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:21.013]                   if (TRUE && !signal) {
[17:40:21.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.013]                     {
[17:40:21.013]                       inherits <- base::inherits
[17:40:21.013]                       invokeRestart <- base::invokeRestart
[17:40:21.013]                       is.null <- base::is.null
[17:40:21.013]                       muffled <- FALSE
[17:40:21.013]                       if (inherits(cond, "message")) {
[17:40:21.013]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.013]                         if (muffled) 
[17:40:21.013]                           invokeRestart("muffleMessage")
[17:40:21.013]                       }
[17:40:21.013]                       else if (inherits(cond, "warning")) {
[17:40:21.013]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.013]                         if (muffled) 
[17:40:21.013]                           invokeRestart("muffleWarning")
[17:40:21.013]                       }
[17:40:21.013]                       else if (inherits(cond, "condition")) {
[17:40:21.013]                         if (!is.null(pattern)) {
[17:40:21.013]                           computeRestarts <- base::computeRestarts
[17:40:21.013]                           grepl <- base::grepl
[17:40:21.013]                           restarts <- computeRestarts(cond)
[17:40:21.013]                           for (restart in restarts) {
[17:40:21.013]                             name <- restart$name
[17:40:21.013]                             if (is.null(name)) 
[17:40:21.013]                               next
[17:40:21.013]                             if (!grepl(pattern, name)) 
[17:40:21.013]                               next
[17:40:21.013]                             invokeRestart(restart)
[17:40:21.013]                             muffled <- TRUE
[17:40:21.013]                             break
[17:40:21.013]                           }
[17:40:21.013]                         }
[17:40:21.013]                       }
[17:40:21.013]                       invisible(muffled)
[17:40:21.013]                     }
[17:40:21.013]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.013]                   }
[17:40:21.013]                 }
[17:40:21.013]                 else {
[17:40:21.013]                   if (TRUE) {
[17:40:21.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.013]                     {
[17:40:21.013]                       inherits <- base::inherits
[17:40:21.013]                       invokeRestart <- base::invokeRestart
[17:40:21.013]                       is.null <- base::is.null
[17:40:21.013]                       muffled <- FALSE
[17:40:21.013]                       if (inherits(cond, "message")) {
[17:40:21.013]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.013]                         if (muffled) 
[17:40:21.013]                           invokeRestart("muffleMessage")
[17:40:21.013]                       }
[17:40:21.013]                       else if (inherits(cond, "warning")) {
[17:40:21.013]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.013]                         if (muffled) 
[17:40:21.013]                           invokeRestart("muffleWarning")
[17:40:21.013]                       }
[17:40:21.013]                       else if (inherits(cond, "condition")) {
[17:40:21.013]                         if (!is.null(pattern)) {
[17:40:21.013]                           computeRestarts <- base::computeRestarts
[17:40:21.013]                           grepl <- base::grepl
[17:40:21.013]                           restarts <- computeRestarts(cond)
[17:40:21.013]                           for (restart in restarts) {
[17:40:21.013]                             name <- restart$name
[17:40:21.013]                             if (is.null(name)) 
[17:40:21.013]                               next
[17:40:21.013]                             if (!grepl(pattern, name)) 
[17:40:21.013]                               next
[17:40:21.013]                             invokeRestart(restart)
[17:40:21.013]                             muffled <- TRUE
[17:40:21.013]                             break
[17:40:21.013]                           }
[17:40:21.013]                         }
[17:40:21.013]                       }
[17:40:21.013]                       invisible(muffled)
[17:40:21.013]                     }
[17:40:21.013]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.013]                   }
[17:40:21.013]                 }
[17:40:21.013]             }
[17:40:21.013]         }))
[17:40:21.013]     }, error = function(ex) {
[17:40:21.013]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:21.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.013]                 ...future.rng), started = ...future.startTime, 
[17:40:21.013]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:21.013]             version = "1.8"), class = "FutureResult")
[17:40:21.013]     }, finally = {
[17:40:21.013]         if (!identical(...future.workdir, getwd())) 
[17:40:21.013]             setwd(...future.workdir)
[17:40:21.013]         {
[17:40:21.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:21.013]                 ...future.oldOptions$nwarnings <- NULL
[17:40:21.013]             }
[17:40:21.013]             base::options(...future.oldOptions)
[17:40:21.013]             if (.Platform$OS.type == "windows") {
[17:40:21.013]                 old_names <- names(...future.oldEnvVars)
[17:40:21.013]                 envs <- base::Sys.getenv()
[17:40:21.013]                 names <- names(envs)
[17:40:21.013]                 common <- intersect(names, old_names)
[17:40:21.013]                 added <- setdiff(names, old_names)
[17:40:21.013]                 removed <- setdiff(old_names, names)
[17:40:21.013]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:21.013]                   envs[common]]
[17:40:21.013]                 NAMES <- toupper(changed)
[17:40:21.013]                 args <- list()
[17:40:21.013]                 for (kk in seq_along(NAMES)) {
[17:40:21.013]                   name <- changed[[kk]]
[17:40:21.013]                   NAME <- NAMES[[kk]]
[17:40:21.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.013]                     next
[17:40:21.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.013]                 }
[17:40:21.013]                 NAMES <- toupper(added)
[17:40:21.013]                 for (kk in seq_along(NAMES)) {
[17:40:21.013]                   name <- added[[kk]]
[17:40:21.013]                   NAME <- NAMES[[kk]]
[17:40:21.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.013]                     next
[17:40:21.013]                   args[[name]] <- ""
[17:40:21.013]                 }
[17:40:21.013]                 NAMES <- toupper(removed)
[17:40:21.013]                 for (kk in seq_along(NAMES)) {
[17:40:21.013]                   name <- removed[[kk]]
[17:40:21.013]                   NAME <- NAMES[[kk]]
[17:40:21.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.013]                     next
[17:40:21.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.013]                 }
[17:40:21.013]                 if (length(args) > 0) 
[17:40:21.013]                   base::do.call(base::Sys.setenv, args = args)
[17:40:21.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:21.013]             }
[17:40:21.013]             else {
[17:40:21.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:21.013]             }
[17:40:21.013]             {
[17:40:21.013]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:21.013]                   0L) {
[17:40:21.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:21.013]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:21.013]                   base::options(opts)
[17:40:21.013]                 }
[17:40:21.013]                 {
[17:40:21.013]                   {
[17:40:21.013]                     NULL
[17:40:21.013]                     RNGkind("Mersenne-Twister")
[17:40:21.013]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:21.013]                       inherits = FALSE)
[17:40:21.013]                   }
[17:40:21.013]                   options(future.plan = NULL)
[17:40:21.013]                   if (is.na(NA_character_)) 
[17:40:21.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:21.013]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:21.013]                     .init = FALSE)
[17:40:21.013]                 }
[17:40:21.013]             }
[17:40:21.013]         }
[17:40:21.013]     })
[17:40:21.013]     if (TRUE) {
[17:40:21.013]         base::sink(type = "output", split = FALSE)
[17:40:21.013]         if (TRUE) {
[17:40:21.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:21.013]         }
[17:40:21.013]         else {
[17:40:21.013]             ...future.result["stdout"] <- base::list(NULL)
[17:40:21.013]         }
[17:40:21.013]         base::close(...future.stdout)
[17:40:21.013]         ...future.stdout <- NULL
[17:40:21.013]     }
[17:40:21.013]     ...future.result$conditions <- ...future.conditions
[17:40:21.013]     ...future.result$finished <- base::Sys.time()
[17:40:21.013]     ...future.result
[17:40:21.013] }
[17:40:21.048]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.015] assign_globals() ...
[17:40:21.048]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.015] List of 3
[17:40:21.015]  $ nested_a:List of 1
[17:40:21.015]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:21.015]     envir = parent.frame())  
[17:40:21.015]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:40:21.015]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:40:21.015]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:21.015]  $ a       : int 1
[17:40:21.015]  $ plan_a  :List of 1
[17:40:21.015]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:21.015]     envir = parent.frame())  
[17:40:21.015]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[17:40:21.015]   .. ..- attr(*, "untweakable")= chr "persistent"
[17:40:21.015]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[17:40:21.015]  - attr(*, "where")=List of 3
[17:40:21.015]   ..$ nested_a:<environment: R_EmptyEnv> 
[17:40:21.015]   ..$ a       :<environment: R_EmptyEnv> 
[17:40:21.015]   ..$ plan_a  :<environment: R_EmptyEnv> 
[17:40:21.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:21.015]  - attr(*, "resolved")= logi FALSE
[17:40:21.015]  - attr(*, "total_size")= num 89928
[17:40:21.015]  - attr(*, "already-done")= logi TRUE
[17:40:21.048]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.023] - copied ‘nested_a’ to environment
[17:40:21.048]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.023] - copied ‘a’ to environment
[17:40:21.048]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.023] - copied ‘plan_a’ to environment
[17:40:21.048]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.024] assign_globals() ... done
[17:40:21.049]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.024] plan(): Setting new future strategy stack:
[17:40:21.049]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.024] List of future strategies:
[17:40:21.024] 1. sequential:
[17:40:21.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:21.024]    - tweaked: FALSE
[17:40:21.024]    - call: NULL
[17:40:21.049]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.025] plan(): nbrOfWorkers() = 1
[17:40:21.049]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.026] plan(): Setting new future strategy stack:
[17:40:21.049]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.026] List of future strategies:
[17:40:21.026] 1. multisession:
[17:40:21.026]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.026]    - tweaked: FALSE
[17:40:21.026]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.049]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.030] plan(): nbrOfWorkers() = 1
[17:40:21.050]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.030] SequentialFuture started (and completed)
[17:40:21.050]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.030] - Launch lazy future ... done
[17:40:21.050]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.031] run() for ‘SequentialFuture’ ... done
[17:40:21.050] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:21.057] getGlobalsAndPackages() ...
[17:40:21.057] Searching for globals...
[17:40:21.058] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:21.059] Searching for globals ... DONE
[17:40:21.059] Resolving globals: FALSE
[17:40:21.059] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:21.060] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:21.060] - globals: [1] ‘data’
[17:40:21.060] - packages: [1] ‘future’
[17:40:21.060] getGlobalsAndPackages() ... DONE
[17:40:21.061] run() for ‘Future’ ...
[17:40:21.061] - state: ‘created’
[17:40:21.061] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:21.065] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:21.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:21.065]   - Field: ‘label’
[17:40:21.066]   - Field: ‘local’
[17:40:21.066]   - Field: ‘owner’
[17:40:21.066]   - Field: ‘envir’
[17:40:21.066]   - Field: ‘workers’
[17:40:21.066]   - Field: ‘packages’
[17:40:21.066]   - Field: ‘gc’
[17:40:21.066]   - Field: ‘job’
[17:40:21.066]   - Field: ‘conditions’
[17:40:21.066]   - Field: ‘expr’
[17:40:21.066]   - Field: ‘uuid’
[17:40:21.067]   - Field: ‘seed’
[17:40:21.067]   - Field: ‘version’
[17:40:21.067]   - Field: ‘result’
[17:40:21.067]   - Field: ‘asynchronous’
[17:40:21.067]   - Field: ‘calls’
[17:40:21.067]   - Field: ‘globals’
[17:40:21.067]   - Field: ‘stdout’
[17:40:21.067]   - Field: ‘earlySignal’
[17:40:21.067]   - Field: ‘lazy’
[17:40:21.068]   - Field: ‘state’
[17:40:21.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:21.068] - Launch lazy future ...
[17:40:21.068] Packages needed by the future expression (n = 1): ‘future’
[17:40:21.068] Packages needed by future strategies (n = 1): ‘future’
[17:40:21.069] {
[17:40:21.069]     {
[17:40:21.069]         {
[17:40:21.069]             ...future.startTime <- base::Sys.time()
[17:40:21.069]             {
[17:40:21.069]                 {
[17:40:21.069]                   {
[17:40:21.069]                     {
[17:40:21.069]                       {
[17:40:21.069]                         base::local({
[17:40:21.069]                           has_future <- base::requireNamespace("future", 
[17:40:21.069]                             quietly = TRUE)
[17:40:21.069]                           if (has_future) {
[17:40:21.069]                             ns <- base::getNamespace("future")
[17:40:21.069]                             version <- ns[[".package"]][["version"]]
[17:40:21.069]                             if (is.null(version)) 
[17:40:21.069]                               version <- utils::packageVersion("future")
[17:40:21.069]                           }
[17:40:21.069]                           else {
[17:40:21.069]                             version <- NULL
[17:40:21.069]                           }
[17:40:21.069]                           if (!has_future || version < "1.8.0") {
[17:40:21.069]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:21.069]                               "", base::R.version$version.string), 
[17:40:21.069]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:21.069]                                 base::R.version$platform, 8 * 
[17:40:21.069]                                   base::.Machine$sizeof.pointer), 
[17:40:21.069]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:21.069]                                 "release", "version")], collapse = " "), 
[17:40:21.069]                               hostname = base::Sys.info()[["nodename"]])
[17:40:21.069]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:21.069]                               info)
[17:40:21.069]                             info <- base::paste(info, collapse = "; ")
[17:40:21.069]                             if (!has_future) {
[17:40:21.069]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:21.069]                                 info)
[17:40:21.069]                             }
[17:40:21.069]                             else {
[17:40:21.069]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:21.069]                                 info, version)
[17:40:21.069]                             }
[17:40:21.069]                             base::stop(msg)
[17:40:21.069]                           }
[17:40:21.069]                         })
[17:40:21.069]                       }
[17:40:21.069]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:21.069]                       base::options(mc.cores = 1L)
[17:40:21.069]                     }
[17:40:21.069]                     base::local({
[17:40:21.069]                       for (pkg in "future") {
[17:40:21.069]                         base::loadNamespace(pkg)
[17:40:21.069]                         base::library(pkg, character.only = TRUE)
[17:40:21.069]                       }
[17:40:21.069]                     })
[17:40:21.069]                   }
[17:40:21.069]                   ...future.strategy.old <- future::plan("list")
[17:40:21.069]                   options(future.plan = NULL)
[17:40:21.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.069]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:21.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:21.069]                     envir = parent.frame()) 
[17:40:21.069]                   {
[17:40:21.069]                     if (is.function(workers)) 
[17:40:21.069]                       workers <- workers()
[17:40:21.069]                     workers <- structure(as.integer(workers), 
[17:40:21.069]                       class = class(workers))
[17:40:21.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:21.069]                       workers >= 1)
[17:40:21.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:21.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:21.069]                     }
[17:40:21.069]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:21.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:21.069]                       envir = envir)
[17:40:21.069]                     if (!future$lazy) 
[17:40:21.069]                       future <- run(future)
[17:40:21.069]                     invisible(future)
[17:40:21.069]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:21.069]                 }
[17:40:21.069]                 ...future.workdir <- getwd()
[17:40:21.069]             }
[17:40:21.069]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:21.069]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:21.069]         }
[17:40:21.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:21.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:21.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:21.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:21.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:21.069]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:21.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:21.069]             base::names(...future.oldOptions))
[17:40:21.069]     }
[17:40:21.069]     if (FALSE) {
[17:40:21.069]     }
[17:40:21.069]     else {
[17:40:21.069]         if (TRUE) {
[17:40:21.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:21.069]                 open = "w")
[17:40:21.069]         }
[17:40:21.069]         else {
[17:40:21.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:21.069]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:21.069]         }
[17:40:21.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:21.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:21.069]             base::sink(type = "output", split = FALSE)
[17:40:21.069]             base::close(...future.stdout)
[17:40:21.069]         }, add = TRUE)
[17:40:21.069]     }
[17:40:21.069]     ...future.frame <- base::sys.nframe()
[17:40:21.069]     ...future.conditions <- base::list()
[17:40:21.069]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:21.069]     if (FALSE) {
[17:40:21.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:21.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:21.069]     }
[17:40:21.069]     ...future.result <- base::tryCatch({
[17:40:21.069]         base::withCallingHandlers({
[17:40:21.069]             ...future.value <- base::withVisible(base::local({
[17:40:21.069]                 withCallingHandlers({
[17:40:21.069]                   {
[17:40:21.069]                     value(future(subset(data, a == 2)))
[17:40:21.069]                   }
[17:40:21.069]                 }, immediateCondition = function(cond) {
[17:40:21.069]                   save_rds <- function (object, pathname, ...) 
[17:40:21.069]                   {
[17:40:21.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:21.069]                     if (file_test("-f", pathname_tmp)) {
[17:40:21.069]                       fi_tmp <- file.info(pathname_tmp)
[17:40:21.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:21.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:21.069]                         fi_tmp[["mtime"]])
[17:40:21.069]                     }
[17:40:21.069]                     tryCatch({
[17:40:21.069]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:21.069]                     }, error = function(ex) {
[17:40:21.069]                       msg <- conditionMessage(ex)
[17:40:21.069]                       fi_tmp <- file.info(pathname_tmp)
[17:40:21.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:21.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:21.069]                         fi_tmp[["mtime"]], msg)
[17:40:21.069]                       ex$message <- msg
[17:40:21.069]                       stop(ex)
[17:40:21.069]                     })
[17:40:21.069]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:21.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:21.069]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:21.069]                       fi_tmp <- file.info(pathname_tmp)
[17:40:21.069]                       fi <- file.info(pathname)
[17:40:21.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:21.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:21.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:21.069]                         fi[["size"]], fi[["mtime"]])
[17:40:21.069]                       stop(msg)
[17:40:21.069]                     }
[17:40:21.069]                     invisible(pathname)
[17:40:21.069]                   }
[17:40:21.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:21.069]                     rootPath = tempdir()) 
[17:40:21.069]                   {
[17:40:21.069]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:21.069]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:21.069]                       tmpdir = path, fileext = ".rds")
[17:40:21.069]                     save_rds(obj, file)
[17:40:21.069]                   }
[17:40:21.069]                   saveImmediateCondition(cond, path = "/tmp/Rtmp7aEZT3/.future/immediateConditions")
[17:40:21.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.069]                   {
[17:40:21.069]                     inherits <- base::inherits
[17:40:21.069]                     invokeRestart <- base::invokeRestart
[17:40:21.069]                     is.null <- base::is.null
[17:40:21.069]                     muffled <- FALSE
[17:40:21.069]                     if (inherits(cond, "message")) {
[17:40:21.069]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:21.069]                       if (muffled) 
[17:40:21.069]                         invokeRestart("muffleMessage")
[17:40:21.069]                     }
[17:40:21.069]                     else if (inherits(cond, "warning")) {
[17:40:21.069]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:21.069]                       if (muffled) 
[17:40:21.069]                         invokeRestart("muffleWarning")
[17:40:21.069]                     }
[17:40:21.069]                     else if (inherits(cond, "condition")) {
[17:40:21.069]                       if (!is.null(pattern)) {
[17:40:21.069]                         computeRestarts <- base::computeRestarts
[17:40:21.069]                         grepl <- base::grepl
[17:40:21.069]                         restarts <- computeRestarts(cond)
[17:40:21.069]                         for (restart in restarts) {
[17:40:21.069]                           name <- restart$name
[17:40:21.069]                           if (is.null(name)) 
[17:40:21.069]                             next
[17:40:21.069]                           if (!grepl(pattern, name)) 
[17:40:21.069]                             next
[17:40:21.069]                           invokeRestart(restart)
[17:40:21.069]                           muffled <- TRUE
[17:40:21.069]                           break
[17:40:21.069]                         }
[17:40:21.069]                       }
[17:40:21.069]                     }
[17:40:21.069]                     invisible(muffled)
[17:40:21.069]                   }
[17:40:21.069]                   muffleCondition(cond)
[17:40:21.069]                 })
[17:40:21.069]             }))
[17:40:21.069]             future::FutureResult(value = ...future.value$value, 
[17:40:21.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.069]                   ...future.rng), globalenv = if (FALSE) 
[17:40:21.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:21.069]                     ...future.globalenv.names))
[17:40:21.069]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:21.069]         }, condition = base::local({
[17:40:21.069]             c <- base::c
[17:40:21.069]             inherits <- base::inherits
[17:40:21.069]             invokeRestart <- base::invokeRestart
[17:40:21.069]             length <- base::length
[17:40:21.069]             list <- base::list
[17:40:21.069]             seq.int <- base::seq.int
[17:40:21.069]             signalCondition <- base::signalCondition
[17:40:21.069]             sys.calls <- base::sys.calls
[17:40:21.069]             `[[` <- base::`[[`
[17:40:21.069]             `+` <- base::`+`
[17:40:21.069]             `<<-` <- base::`<<-`
[17:40:21.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:21.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:21.069]                   3L)]
[17:40:21.069]             }
[17:40:21.069]             function(cond) {
[17:40:21.069]                 is_error <- inherits(cond, "error")
[17:40:21.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:21.069]                   NULL)
[17:40:21.069]                 if (is_error) {
[17:40:21.069]                   sessionInformation <- function() {
[17:40:21.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:21.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:21.069]                       search = base::search(), system = base::Sys.info())
[17:40:21.069]                   }
[17:40:21.069]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:21.069]                     cond$call), session = sessionInformation(), 
[17:40:21.069]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:21.069]                   signalCondition(cond)
[17:40:21.069]                 }
[17:40:21.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:21.069]                 "immediateCondition"))) {
[17:40:21.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:21.069]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:21.069]                   if (TRUE && !signal) {
[17:40:21.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.069]                     {
[17:40:21.069]                       inherits <- base::inherits
[17:40:21.069]                       invokeRestart <- base::invokeRestart
[17:40:21.069]                       is.null <- base::is.null
[17:40:21.069]                       muffled <- FALSE
[17:40:21.069]                       if (inherits(cond, "message")) {
[17:40:21.069]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.069]                         if (muffled) 
[17:40:21.069]                           invokeRestart("muffleMessage")
[17:40:21.069]                       }
[17:40:21.069]                       else if (inherits(cond, "warning")) {
[17:40:21.069]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.069]                         if (muffled) 
[17:40:21.069]                           invokeRestart("muffleWarning")
[17:40:21.069]                       }
[17:40:21.069]                       else if (inherits(cond, "condition")) {
[17:40:21.069]                         if (!is.null(pattern)) {
[17:40:21.069]                           computeRestarts <- base::computeRestarts
[17:40:21.069]                           grepl <- base::grepl
[17:40:21.069]                           restarts <- computeRestarts(cond)
[17:40:21.069]                           for (restart in restarts) {
[17:40:21.069]                             name <- restart$name
[17:40:21.069]                             if (is.null(name)) 
[17:40:21.069]                               next
[17:40:21.069]                             if (!grepl(pattern, name)) 
[17:40:21.069]                               next
[17:40:21.069]                             invokeRestart(restart)
[17:40:21.069]                             muffled <- TRUE
[17:40:21.069]                             break
[17:40:21.069]                           }
[17:40:21.069]                         }
[17:40:21.069]                       }
[17:40:21.069]                       invisible(muffled)
[17:40:21.069]                     }
[17:40:21.069]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.069]                   }
[17:40:21.069]                 }
[17:40:21.069]                 else {
[17:40:21.069]                   if (TRUE) {
[17:40:21.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.069]                     {
[17:40:21.069]                       inherits <- base::inherits
[17:40:21.069]                       invokeRestart <- base::invokeRestart
[17:40:21.069]                       is.null <- base::is.null
[17:40:21.069]                       muffled <- FALSE
[17:40:21.069]                       if (inherits(cond, "message")) {
[17:40:21.069]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.069]                         if (muffled) 
[17:40:21.069]                           invokeRestart("muffleMessage")
[17:40:21.069]                       }
[17:40:21.069]                       else if (inherits(cond, "warning")) {
[17:40:21.069]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.069]                         if (muffled) 
[17:40:21.069]                           invokeRestart("muffleWarning")
[17:40:21.069]                       }
[17:40:21.069]                       else if (inherits(cond, "condition")) {
[17:40:21.069]                         if (!is.null(pattern)) {
[17:40:21.069]                           computeRestarts <- base::computeRestarts
[17:40:21.069]                           grepl <- base::grepl
[17:40:21.069]                           restarts <- computeRestarts(cond)
[17:40:21.069]                           for (restart in restarts) {
[17:40:21.069]                             name <- restart$name
[17:40:21.069]                             if (is.null(name)) 
[17:40:21.069]                               next
[17:40:21.069]                             if (!grepl(pattern, name)) 
[17:40:21.069]                               next
[17:40:21.069]                             invokeRestart(restart)
[17:40:21.069]                             muffled <- TRUE
[17:40:21.069]                             break
[17:40:21.069]                           }
[17:40:21.069]                         }
[17:40:21.069]                       }
[17:40:21.069]                       invisible(muffled)
[17:40:21.069]                     }
[17:40:21.069]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.069]                   }
[17:40:21.069]                 }
[17:40:21.069]             }
[17:40:21.069]         }))
[17:40:21.069]     }, error = function(ex) {
[17:40:21.069]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:21.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.069]                 ...future.rng), started = ...future.startTime, 
[17:40:21.069]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:21.069]             version = "1.8"), class = "FutureResult")
[17:40:21.069]     }, finally = {
[17:40:21.069]         if (!identical(...future.workdir, getwd())) 
[17:40:21.069]             setwd(...future.workdir)
[17:40:21.069]         {
[17:40:21.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:21.069]                 ...future.oldOptions$nwarnings <- NULL
[17:40:21.069]             }
[17:40:21.069]             base::options(...future.oldOptions)
[17:40:21.069]             if (.Platform$OS.type == "windows") {
[17:40:21.069]                 old_names <- names(...future.oldEnvVars)
[17:40:21.069]                 envs <- base::Sys.getenv()
[17:40:21.069]                 names <- names(envs)
[17:40:21.069]                 common <- intersect(names, old_names)
[17:40:21.069]                 added <- setdiff(names, old_names)
[17:40:21.069]                 removed <- setdiff(old_names, names)
[17:40:21.069]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:21.069]                   envs[common]]
[17:40:21.069]                 NAMES <- toupper(changed)
[17:40:21.069]                 args <- list()
[17:40:21.069]                 for (kk in seq_along(NAMES)) {
[17:40:21.069]                   name <- changed[[kk]]
[17:40:21.069]                   NAME <- NAMES[[kk]]
[17:40:21.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.069]                     next
[17:40:21.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.069]                 }
[17:40:21.069]                 NAMES <- toupper(added)
[17:40:21.069]                 for (kk in seq_along(NAMES)) {
[17:40:21.069]                   name <- added[[kk]]
[17:40:21.069]                   NAME <- NAMES[[kk]]
[17:40:21.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.069]                     next
[17:40:21.069]                   args[[name]] <- ""
[17:40:21.069]                 }
[17:40:21.069]                 NAMES <- toupper(removed)
[17:40:21.069]                 for (kk in seq_along(NAMES)) {
[17:40:21.069]                   name <- removed[[kk]]
[17:40:21.069]                   NAME <- NAMES[[kk]]
[17:40:21.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.069]                     next
[17:40:21.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.069]                 }
[17:40:21.069]                 if (length(args) > 0) 
[17:40:21.069]                   base::do.call(base::Sys.setenv, args = args)
[17:40:21.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:21.069]             }
[17:40:21.069]             else {
[17:40:21.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:21.069]             }
[17:40:21.069]             {
[17:40:21.069]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:21.069]                   0L) {
[17:40:21.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:21.069]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:21.069]                   base::options(opts)
[17:40:21.069]                 }
[17:40:21.069]                 {
[17:40:21.069]                   {
[17:40:21.069]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:21.069]                     NULL
[17:40:21.069]                   }
[17:40:21.069]                   options(future.plan = NULL)
[17:40:21.069]                   if (is.na(NA_character_)) 
[17:40:21.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:21.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:21.069]                     .init = FALSE)
[17:40:21.069]                 }
[17:40:21.069]             }
[17:40:21.069]         }
[17:40:21.069]     })
[17:40:21.069]     if (TRUE) {
[17:40:21.069]         base::sink(type = "output", split = FALSE)
[17:40:21.069]         if (TRUE) {
[17:40:21.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:21.069]         }
[17:40:21.069]         else {
[17:40:21.069]             ...future.result["stdout"] <- base::list(NULL)
[17:40:21.069]         }
[17:40:21.069]         base::close(...future.stdout)
[17:40:21.069]         ...future.stdout <- NULL
[17:40:21.069]     }
[17:40:21.069]     ...future.result$conditions <- ...future.conditions
[17:40:21.069]     ...future.result$finished <- base::Sys.time()
[17:40:21.069]     ...future.result
[17:40:21.069] }
[17:40:21.072] assign_globals() ...
[17:40:21.072] List of 1
[17:40:21.072]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:21.072]   ..$ a: int [1:3] 1 2 3
[17:40:21.072]   ..$ b: int [1:3] 3 2 1
[17:40:21.072]  - attr(*, "where")=List of 1
[17:40:21.072]   ..$ data:<environment: R_EmptyEnv> 
[17:40:21.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:21.072]  - attr(*, "resolved")= logi FALSE
[17:40:21.072]  - attr(*, "total_size")= num 128
[17:40:21.072]  - attr(*, "already-done")= logi TRUE
[17:40:21.075] - copied ‘data’ to environment
[17:40:21.075] assign_globals() ... done
[17:40:21.075] requestCore(): workers = 2
[17:40:21.078] MulticoreFuture started
[17:40:21.078] - Launch lazy future ... done
[17:40:21.078] run() for ‘MulticoreFuture’ ... done
[17:40:21.079] result() for MulticoreFuture ...
[17:40:21.079] plan(): Setting new future strategy stack:
[17:40:21.079] List of future strategies:
[17:40:21.079] 1. multisession:
[17:40:21.079]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.079]    - tweaked: FALSE
[17:40:21.079]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.085] plan(): nbrOfWorkers() = 1
[17:40:21.123] plan(): Setting new future strategy stack:
[17:40:21.123] List of future strategies:
[17:40:21.123] 1. multicore:
[17:40:21.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:21.123]    - tweaked: FALSE
[17:40:21.123]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.123] 2. multisession:
[17:40:21.123]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.123]    - tweaked: FALSE
[17:40:21.123]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.127] plan(): nbrOfWorkers() = 2
[17:40:21.128] result() for MulticoreFuture ...
[17:40:21.128] result() for MulticoreFuture ... done
[17:40:21.128] signalConditions() ...
[17:40:21.128]  - include = ‘immediateCondition’
[17:40:21.129]  - exclude = 
[17:40:21.129]  - resignal = FALSE
[17:40:21.129]  - Number of conditions: 52
[17:40:21.129] signalConditions() ... done
[17:40:21.129] result() for MulticoreFuture ... done
[17:40:21.129] result() for MulticoreFuture ...
[17:40:21.130] result() for MulticoreFuture ... done
[17:40:21.130] signalConditions() ...
[17:40:21.130]  - include = ‘immediateCondition’
[17:40:21.130]  - exclude = 
[17:40:21.130]  - resignal = FALSE
[17:40:21.130]  - Number of conditions: 52
[17:40:21.130] signalConditions() ... done
[17:40:21.131] Future state: ‘finished’
[17:40:21.131] result() for MulticoreFuture ...
[17:40:21.131] result() for MulticoreFuture ... done
[17:40:21.131] signalConditions() ...
[17:40:21.131]  - include = ‘condition’
[17:40:21.131]  - exclude = ‘immediateCondition’
[17:40:21.132]  - resignal = TRUE
[17:40:21.132]  - Number of conditions: 52
[17:40:21.132]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.085] getGlobalsAndPackages() ...
[17:40:21.132]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.086] Searching for globals...
[17:40:21.132]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.087] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:21.133]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.088] Searching for globals ... DONE
[17:40:21.133]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.088] Resolving globals: FALSE
[17:40:21.133]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.089] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:21.133]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.089] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:21.133]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.089] - globals: [1] ‘data’
[17:40:21.133]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.090] 
[17:40:21.134]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.090] getGlobalsAndPackages() ... DONE
[17:40:21.134]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.091] run() for ‘Future’ ...
[17:40:21.134]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.091] - state: ‘created’
[17:40:21.134]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:21.134]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:21.134]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:21.135]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.103]   - Field: ‘label’
[17:40:21.138]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.103]   - Field: ‘local’
[17:40:21.139]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.103]   - Field: ‘owner’
[17:40:21.139]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.103]   - Field: ‘envir’
[17:40:21.139]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.103]   - Field: ‘packages’
[17:40:21.139]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.104]   - Field: ‘gc’
[17:40:21.139]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.104]   - Field: ‘conditions’
[17:40:21.140]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.104]   - Field: ‘expr’
[17:40:21.140]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.104]   - Field: ‘uuid’
[17:40:21.140]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.104]   - Field: ‘seed’
[17:40:21.140]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.105]   - Field: ‘version’
[17:40:21.140]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.105]   - Field: ‘result’
[17:40:21.140]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.105]   - Field: ‘asynchronous’
[17:40:21.141]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.105]   - Field: ‘calls’
[17:40:21.141]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.105]   - Field: ‘globals’
[17:40:21.141]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.105]   - Field: ‘stdout’
[17:40:21.141]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.106]   - Field: ‘earlySignal’
[17:40:21.141]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.106]   - Field: ‘lazy’
[17:40:21.142]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.106]   - Field: ‘state’
[17:40:21.142]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:21.142]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.106] - Launch lazy future ...
[17:40:21.142]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.107] Packages needed by the future expression (n = 0): <none>
[17:40:21.142]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.107] Packages needed by future strategies (n = 0): <none>
[17:40:21.142]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.107] {
[17:40:21.107]     {
[17:40:21.107]         {
[17:40:21.107]             ...future.startTime <- base::Sys.time()
[17:40:21.107]             {
[17:40:21.107]                 {
[17:40:21.107]                   {
[17:40:21.107]                     base::local({
[17:40:21.107]                       has_future <- base::requireNamespace("future", 
[17:40:21.107]                         quietly = TRUE)
[17:40:21.107]                       if (has_future) {
[17:40:21.107]                         ns <- base::getNamespace("future")
[17:40:21.107]                         version <- ns[[".package"]][["version"]]
[17:40:21.107]                         if (is.null(version)) 
[17:40:21.107]                           version <- utils::packageVersion("future")
[17:40:21.107]                       }
[17:40:21.107]                       else {
[17:40:21.107]                         version <- NULL
[17:40:21.107]                       }
[17:40:21.107]                       if (!has_future || version < "1.8.0") {
[17:40:21.107]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:21.107]                           "", base::R.version$version.string), 
[17:40:21.107]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:21.107]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:21.107]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:21.107]                             "release", "version")], collapse = " "), 
[17:40:21.107]                           hostname = base::Sys.info()[["nodename"]])
[17:40:21.107]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:21.107]                           info)
[17:40:21.107]                         info <- base::paste(info, collapse = "; ")
[17:40:21.107]                         if (!has_future) {
[17:40:21.107]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:21.107]                             info)
[17:40:21.107]                         }
[17:40:21.107]                         else {
[17:40:21.107]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:21.107]                             info, version)
[17:40:21.107]                         }
[17:40:21.107]                         base::stop(msg)
[17:40:21.107]                       }
[17:40:21.107]                     })
[17:40:21.107]                   }
[17:40:21.107]                   ...future.strategy.old <- future::plan("list")
[17:40:21.107]                   options(future.plan = NULL)
[17:40:21.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:21.107]                 }
[17:40:21.107]                 ...future.workdir <- getwd()
[17:40:21.107]             }
[17:40:21.107]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:21.107]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:21.107]         }
[17:40:21.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:21.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:21.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:21.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:21.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:21.107]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:21.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:21.107]             base::names(...future.oldOptions))
[17:40:21.107]     }
[17:40:21.107]     if (FALSE) {
[17:40:21.107]     }
[17:40:21.107]     else {
[17:40:21.107]         if (TRUE) {
[17:40:21.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:21.107]                 open = "w")
[17:40:21.107]         }
[17:40:21.107]         else {
[17:40:21.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:21.107]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:21.107]         }
[17:40:21.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:21.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:21.107]             base::sink(type = "output", split = FALSE)
[17:40:21.107]             base::close(...future.stdout)
[17:40:21.107]         }, add = TRUE)
[17:40:21.107]     }
[17:40:21.107]     ...future.frame <- base::sys.nframe()
[17:40:21.107]     ...future.conditions <- base::list()
[17:40:21.107]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:21.107]     if (FALSE) {
[17:40:21.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:21.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:21.107]     }
[17:40:21.107]     ...future.result <- base::tryCatch({
[17:40:21.107]         base::withCallingHandlers({
[17:40:21.107]             ...future.value <- base::withVisible(base::local(subset(data, 
[17:40:21.107]                 a == 2)))
[17:40:21.107]             future::FutureResult(value = ...future.value$value, 
[17:40:21.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.107]                   ...future.rng), globalenv = if (FALSE) 
[17:40:21.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:21.107]                     ...future.globalenv.names))
[17:40:21.107]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:21.107]         }, condition = base::local({
[17:40:21.107]             c <- base::c
[17:40:21.107]             inherits <- base::inherits
[17:40:21.107]             invokeRestart <- base::invokeRestart
[17:40:21.107]             length <- base::length
[17:40:21.107]             list <- base::list
[17:40:21.107]             seq.int <- base::seq.int
[17:40:21.107]             signalCondition <- base::signalCondition
[17:40:21.107]             sys.calls <- base::sys.calls
[17:40:21.107]             `[[` <- base::`[[`
[17:40:21.107]             `+` <- base::`+`
[17:40:21.107]             `<<-` <- base::`<<-`
[17:40:21.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:21.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:21.107]                   3L)]
[17:40:21.107]             }
[17:40:21.107]             function(cond) {
[17:40:21.107]                 is_error <- inherits(cond, "error")
[17:40:21.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:21.107]                   NULL)
[17:40:21.107]                 if (is_error) {
[17:40:21.107]                   sessionInformation <- function() {
[17:40:21.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:21.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:21.107]                       search = base::search(), system = base::Sys.info())
[17:40:21.107]                   }
[17:40:21.107]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:21.107]                     cond$call), session = sessionInformation(), 
[17:40:21.107]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:21.107]                   signalCondition(cond)
[17:40:21.107]                 }
[17:40:21.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:21.107]                 "immediateCondition"))) {
[17:40:21.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:21.107]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:21.107]                   if (TRUE && !signal) {
[17:40:21.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.107]                     {
[17:40:21.107]                       inherits <- base::inherits
[17:40:21.107]                       invokeRestart <- base::invokeRestart
[17:40:21.107]                       is.null <- base::is.null
[17:40:21.107]                       muffled <- FALSE
[17:40:21.107]                       if (inherits(cond, "message")) {
[17:40:21.107]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.107]                         if (muffled) 
[17:40:21.107]                           invokeRestart("muffleMessage")
[17:40:21.107]                       }
[17:40:21.107]                       else if (inherits(cond, "warning")) {
[17:40:21.107]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.107]                         if (muffled) 
[17:40:21.107]                           invokeRestart("muffleWarning")
[17:40:21.107]                       }
[17:40:21.107]                       else if (inherits(cond, "condition")) {
[17:40:21.107]                         if (!is.null(pattern)) {
[17:40:21.107]                           computeRestarts <- base::computeRestarts
[17:40:21.107]                           grepl <- base::grepl
[17:40:21.107]                           restarts <- computeRestarts(cond)
[17:40:21.107]                           for (restart in restarts) {
[17:40:21.107]                             name <- restart$name
[17:40:21.107]                             if (is.null(name)) 
[17:40:21.107]                               next
[17:40:21.107]                             if (!grepl(pattern, name)) 
[17:40:21.107]                               next
[17:40:21.107]                             invokeRestart(restart)
[17:40:21.107]                             muffled <- TRUE
[17:40:21.107]                             break
[17:40:21.107]                           }
[17:40:21.107]                         }
[17:40:21.107]                       }
[17:40:21.107]                       invisible(muffled)
[17:40:21.107]                     }
[17:40:21.107]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.107]                   }
[17:40:21.107]                 }
[17:40:21.107]                 else {
[17:40:21.107]                   if (TRUE) {
[17:40:21.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.107]                     {
[17:40:21.107]                       inherits <- base::inherits
[17:40:21.107]                       invokeRestart <- base::invokeRestart
[17:40:21.107]                       is.null <- base::is.null
[17:40:21.107]                       muffled <- FALSE
[17:40:21.107]                       if (inherits(cond, "message")) {
[17:40:21.107]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.107]                         if (muffled) 
[17:40:21.107]                           invokeRestart("muffleMessage")
[17:40:21.107]                       }
[17:40:21.107]                       else if (inherits(cond, "warning")) {
[17:40:21.107]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.107]                         if (muffled) 
[17:40:21.107]                           invokeRestart("muffleWarning")
[17:40:21.107]                       }
[17:40:21.107]                       else if (inherits(cond, "condition")) {
[17:40:21.107]                         if (!is.null(pattern)) {
[17:40:21.107]                           computeRestarts <- base::computeRestarts
[17:40:21.107]                           grepl <- base::grepl
[17:40:21.107]                           restarts <- computeRestarts(cond)
[17:40:21.107]                           for (restart in restarts) {
[17:40:21.107]                             name <- restart$name
[17:40:21.107]                             if (is.null(name)) 
[17:40:21.107]                               next
[17:40:21.107]                             if (!grepl(pattern, name)) 
[17:40:21.107]                               next
[17:40:21.107]                             invokeRestart(restart)
[17:40:21.107]                             muffled <- TRUE
[17:40:21.107]                             break
[17:40:21.107]                           }
[17:40:21.107]                         }
[17:40:21.107]                       }
[17:40:21.107]                       invisible(muffled)
[17:40:21.107]                     }
[17:40:21.107]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.107]                   }
[17:40:21.107]                 }
[17:40:21.107]             }
[17:40:21.107]         }))
[17:40:21.107]     }, error = function(ex) {
[17:40:21.107]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:21.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.107]                 ...future.rng), started = ...future.startTime, 
[17:40:21.107]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:21.107]             version = "1.8"), class = "FutureResult")
[17:40:21.107]     }, finally = {
[17:40:21.107]         if (!identical(...future.workdir, getwd())) 
[17:40:21.107]             setwd(...future.workdir)
[17:40:21.107]         {
[17:40:21.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:21.107]                 ...future.oldOptions$nwarnings <- NULL
[17:40:21.107]             }
[17:40:21.107]             base::options(...future.oldOptions)
[17:40:21.107]             if (.Platform$OS.type == "windows") {
[17:40:21.107]                 old_names <- names(...future.oldEnvVars)
[17:40:21.107]                 envs <- base::Sys.getenv()
[17:40:21.107]                 names <- names(envs)
[17:40:21.107]                 common <- intersect(names, old_names)
[17:40:21.107]                 added <- setdiff(names, old_names)
[17:40:21.107]                 removed <- setdiff(old_names, names)
[17:40:21.107]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:21.107]                   envs[common]]
[17:40:21.107]                 NAMES <- toupper(changed)
[17:40:21.107]                 args <- list()
[17:40:21.107]                 for (kk in seq_along(NAMES)) {
[17:40:21.107]                   name <- changed[[kk]]
[17:40:21.107]                   NAME <- NAMES[[kk]]
[17:40:21.107]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.107]                     next
[17:40:21.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.107]                 }
[17:40:21.107]                 NAMES <- toupper(added)
[17:40:21.107]                 for (kk in seq_along(NAMES)) {
[17:40:21.107]                   name <- added[[kk]]
[17:40:21.107]                   NAME <- NAMES[[kk]]
[17:40:21.107]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.107]                     next
[17:40:21.107]                   args[[name]] <- ""
[17:40:21.107]                 }
[17:40:21.107]                 NAMES <- toupper(removed)
[17:40:21.107]                 for (kk in seq_along(NAMES)) {
[17:40:21.107]                   name <- removed[[kk]]
[17:40:21.107]                   NAME <- NAMES[[kk]]
[17:40:21.107]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.107]                     next
[17:40:21.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.107]                 }
[17:40:21.107]                 if (length(args) > 0) 
[17:40:21.107]                   base::do.call(base::Sys.setenv, args = args)
[17:40:21.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:21.107]             }
[17:40:21.107]             else {
[17:40:21.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:21.107]             }
[17:40:21.107]             {
[17:40:21.107]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:21.107]                   0L) {
[17:40:21.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:21.107]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:21.107]                   base::options(opts)
[17:40:21.107]                 }
[17:40:21.107]                 {
[17:40:21.107]                   {
[17:40:21.107]                     NULL
[17:40:21.107]                     RNGkind("Mersenne-Twister")
[17:40:21.107]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:21.107]                       inherits = FALSE)
[17:40:21.107]                   }
[17:40:21.107]                   options(future.plan = NULL)
[17:40:21.107]                   if (is.na(NA_character_)) 
[17:40:21.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:21.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:21.107]                     .init = FALSE)
[17:40:21.107]                 }
[17:40:21.107]             }
[17:40:21.107]         }
[17:40:21.107]     })
[17:40:21.107]     if (TRUE) {
[17:40:21.107]         base::sink(type = "output", split = FALSE)
[17:40:21.107]         if (TRUE) {
[17:40:21.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:21.107]         }
[17:40:21.107]         else {
[17:40:21.107]             ...future.result["stdout"] <- base::list(NULL)
[17:40:21.107]         }
[17:40:21.107]         base::close(...future.stdout)
[17:40:21.107]         ...future.stdout <- NULL
[17:40:21.107]     }
[17:40:21.107]     ...future.result$conditions <- ...future.conditions
[17:40:21.107]     ...future.result$finished <- base::Sys.time()
[17:40:21.107]     ...future.result
[17:40:21.107] }
[17:40:21.142]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.109] assign_globals() ...
[17:40:21.143]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.110] List of 1
[17:40:21.110]  $ data:'data.frame':	3 obs. of  2 variables:
[17:40:21.110]   ..$ a: int [1:3] 1 2 3
[17:40:21.110]   ..$ b: int [1:3] 3 2 1
[17:40:21.110]  - attr(*, "where")=List of 1
[17:40:21.110]   ..$ data:<environment: R_EmptyEnv> 
[17:40:21.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:21.110]  - attr(*, "resolved")= logi FALSE
[17:40:21.110]  - attr(*, "total_size")= num 128
[17:40:21.110]  - attr(*, "already-done")= logi TRUE
[17:40:21.143]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.115] - copied ‘data’ to environment
[17:40:21.143]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.115] assign_globals() ... done
[17:40:21.143]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.115] plan(): Setting new future strategy stack:
[17:40:21.143]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.115] List of future strategies:
[17:40:21.115] 1. sequential:
[17:40:21.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:21.115]    - tweaked: FALSE
[17:40:21.115]    - call: NULL
[17:40:21.143]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.116] plan(): nbrOfWorkers() = 1
[17:40:21.143]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.117] plan(): Setting new future strategy stack:
[17:40:21.144]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.117] List of future strategies:
[17:40:21.117] 1. multisession:
[17:40:21.117]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.117]    - tweaked: FALSE
[17:40:21.117]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.144]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.121] plan(): nbrOfWorkers() = 1
[17:40:21.144]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.122] SequentialFuture started (and completed)
[17:40:21.144]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.122] - Launch lazy future ... done
[17:40:21.144]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[17:40:21.122] run() for ‘SequentialFuture’ ... done
[17:40:21.144] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[17:40:21.145] plan(): Setting new future strategy stack:
[17:40:21.145] List of future strategies:
[17:40:21.145] 1. multisession:
[17:40:21.145]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.145]    - tweaked: FALSE
[17:40:21.145]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.145] 2. sequential:
[17:40:21.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:21.145]    - tweaked: FALSE
[17:40:21.145]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.146] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:21.146] multisession:
[17:40:21.146] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.146] - tweaked: FALSE
[17:40:21.146] - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.150] getGlobalsAndPackages() ...
[17:40:21.150] Not searching for globals
[17:40:21.150] - globals: [0] <none>
[17:40:21.150] getGlobalsAndPackages() ... DONE
[17:40:21.151] [local output] makeClusterPSOCK() ...
[17:40:21.154] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:21.155] [local output] Base port: 11267
[17:40:21.155] [local output] Getting setup options for 2 cluster nodes ...
[17:40:21.155] [local output]  - Node 1 of 2 ...
[17:40:21.155] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:21.156] [local output] Rscript port: 11267

[17:40:21.156] [local output]  - Node 2 of 2 ...
[17:40:21.157] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:21.157] [local output] Rscript port: 11267

[17:40:21.158] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:21.158] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:21.158] [local output] Setting up PSOCK nodes in parallel
[17:40:21.158] List of 36
[17:40:21.158]  $ worker          : chr "localhost"
[17:40:21.158]   ..- attr(*, "localhost")= logi TRUE
[17:40:21.158]  $ master          : chr "localhost"
[17:40:21.158]  $ port            : int 11267
[17:40:21.158]  $ connectTimeout  : num 120
[17:40:21.158]  $ timeout         : num 2592000
[17:40:21.158]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:21.158]  $ homogeneous     : logi TRUE
[17:40:21.158]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:21.158]  $ rscript_envs    : NULL
[17:40:21.158]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:21.158]  $ rscript_startup : NULL
[17:40:21.158]  $ rscript_sh      : chr "sh"
[17:40:21.158]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:21.158]  $ methods         : logi TRUE
[17:40:21.158]  $ socketOptions   : chr "no-delay"
[17:40:21.158]  $ useXDR          : logi FALSE
[17:40:21.158]  $ outfile         : chr "/dev/null"
[17:40:21.158]  $ renice          : int NA
[17:40:21.158]  $ rshcmd          : NULL
[17:40:21.158]  $ user            : chr(0) 
[17:40:21.158]  $ revtunnel       : logi FALSE
[17:40:21.158]  $ rshlogfile      : NULL
[17:40:21.158]  $ rshopts         : chr(0) 
[17:40:21.158]  $ rank            : int 1
[17:40:21.158]  $ manual          : logi FALSE
[17:40:21.158]  $ dryrun          : logi FALSE
[17:40:21.158]  $ quiet           : logi FALSE
[17:40:21.158]  $ setup_strategy  : chr "parallel"
[17:40:21.158]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:21.158]  $ pidfile         : chr "/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b9193c4a5783.pid"
[17:40:21.158]  $ rshcmd_label    : NULL
[17:40:21.158]  $ rsh_call        : NULL
[17:40:21.158]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:21.158]  $ localMachine    : logi TRUE
[17:40:21.158]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:21.158]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:21.158]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:21.158]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:21.158]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:21.158]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:21.158]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:21.158]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:21.158]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:21.158]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:21.158]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:21.158]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:21.158]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:21.158]  $ arguments       :List of 28
[17:40:21.158]   ..$ worker          : chr "localhost"
[17:40:21.158]   ..$ master          : NULL
[17:40:21.158]   ..$ port            : int 11267
[17:40:21.158]   ..$ connectTimeout  : num 120
[17:40:21.158]   ..$ timeout         : num 2592000
[17:40:21.158]   ..$ rscript         : NULL
[17:40:21.158]   ..$ homogeneous     : NULL
[17:40:21.158]   ..$ rscript_args    : NULL
[17:40:21.158]   ..$ rscript_envs    : NULL
[17:40:21.158]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:21.158]   ..$ rscript_startup : NULL
[17:40:21.158]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:21.158]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:21.158]   ..$ methods         : logi TRUE
[17:40:21.158]   ..$ socketOptions   : chr "no-delay"
[17:40:21.158]   ..$ useXDR          : logi FALSE
[17:40:21.158]   ..$ outfile         : chr "/dev/null"
[17:40:21.158]   ..$ renice          : int NA
[17:40:21.158]   ..$ rshcmd          : NULL
[17:40:21.158]   ..$ user            : NULL
[17:40:21.158]   ..$ revtunnel       : logi NA
[17:40:21.158]   ..$ rshlogfile      : NULL
[17:40:21.158]   ..$ rshopts         : NULL
[17:40:21.158]   ..$ rank            : int 1
[17:40:21.158]   ..$ manual          : logi FALSE
[17:40:21.158]   ..$ dryrun          : logi FALSE
[17:40:21.158]   ..$ quiet           : logi FALSE
[17:40:21.158]   ..$ setup_strategy  : chr "parallel"
[17:40:21.158]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:21.178] [local output] System call to launch all workers:
[17:40:21.179] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b9193c4a5783.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11267 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:21.179] [local output] Starting PSOCK main server
[17:40:21.180] [local output] Workers launched
[17:40:21.180] [local output] Waiting for workers to connect back
[17:40:21.180]  - [local output] 0 workers out of 2 ready
[17:40:21.403]  - [local output] 0 workers out of 2 ready
[17:40:21.404]  - [local output] 1 workers out of 2 ready
[17:40:21.428]  - [local output] 1 workers out of 2 ready
[17:40:21.428]  - [local output] 2 workers out of 2 ready
[17:40:21.428] [local output] Launching of workers completed
[17:40:21.428] [local output] Collecting session information from workers
[17:40:21.429] [local output]  - Worker #1 of 2
[17:40:21.430] [local output]  - Worker #2 of 2
[17:40:21.430] [local output] makeClusterPSOCK() ... done
[17:40:21.441] Packages needed by the future expression (n = 0): <none>
[17:40:21.441] Packages needed by future strategies (n = 1): ‘future’
[17:40:21.442] {
[17:40:21.442]     {
[17:40:21.442]         {
[17:40:21.442]             ...future.startTime <- base::Sys.time()
[17:40:21.442]             {
[17:40:21.442]                 {
[17:40:21.442]                   {
[17:40:21.442]                     {
[17:40:21.442]                       {
[17:40:21.442]                         base::local({
[17:40:21.442]                           has_future <- base::requireNamespace("future", 
[17:40:21.442]                             quietly = TRUE)
[17:40:21.442]                           if (has_future) {
[17:40:21.442]                             ns <- base::getNamespace("future")
[17:40:21.442]                             version <- ns[[".package"]][["version"]]
[17:40:21.442]                             if (is.null(version)) 
[17:40:21.442]                               version <- utils::packageVersion("future")
[17:40:21.442]                           }
[17:40:21.442]                           else {
[17:40:21.442]                             version <- NULL
[17:40:21.442]                           }
[17:40:21.442]                           if (!has_future || version < "1.8.0") {
[17:40:21.442]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:21.442]                               "", base::R.version$version.string), 
[17:40:21.442]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:21.442]                                 base::R.version$platform, 8 * 
[17:40:21.442]                                   base::.Machine$sizeof.pointer), 
[17:40:21.442]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:21.442]                                 "release", "version")], collapse = " "), 
[17:40:21.442]                               hostname = base::Sys.info()[["nodename"]])
[17:40:21.442]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:21.442]                               info)
[17:40:21.442]                             info <- base::paste(info, collapse = "; ")
[17:40:21.442]                             if (!has_future) {
[17:40:21.442]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:21.442]                                 info)
[17:40:21.442]                             }
[17:40:21.442]                             else {
[17:40:21.442]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:21.442]                                 info, version)
[17:40:21.442]                             }
[17:40:21.442]                             base::stop(msg)
[17:40:21.442]                           }
[17:40:21.442]                         })
[17:40:21.442]                       }
[17:40:21.442]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:21.442]                       base::options(mc.cores = 1L)
[17:40:21.442]                     }
[17:40:21.442]                     base::local({
[17:40:21.442]                       for (pkg in "future") {
[17:40:21.442]                         base::loadNamespace(pkg)
[17:40:21.442]                         base::library(pkg, character.only = TRUE)
[17:40:21.442]                       }
[17:40:21.442]                     })
[17:40:21.442]                   }
[17:40:21.442]                   ...future.strategy.old <- future::plan("list")
[17:40:21.442]                   options(future.plan = NULL)
[17:40:21.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.442]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:21.442]                   {
[17:40:21.442]                     future <- SequentialFuture(..., envir = envir)
[17:40:21.442]                     if (!future$lazy) 
[17:40:21.442]                       future <- run(future)
[17:40:21.442]                     invisible(future)
[17:40:21.442]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:21.442]                 }
[17:40:21.442]                 ...future.workdir <- getwd()
[17:40:21.442]             }
[17:40:21.442]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:21.442]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:21.442]         }
[17:40:21.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:21.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:21.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:21.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:21.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:21.442]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:21.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:21.442]             base::names(...future.oldOptions))
[17:40:21.442]     }
[17:40:21.442]     if (FALSE) {
[17:40:21.442]     }
[17:40:21.442]     else {
[17:40:21.442]         if (TRUE) {
[17:40:21.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:21.442]                 open = "w")
[17:40:21.442]         }
[17:40:21.442]         else {
[17:40:21.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:21.442]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:21.442]         }
[17:40:21.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:21.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:21.442]             base::sink(type = "output", split = FALSE)
[17:40:21.442]             base::close(...future.stdout)
[17:40:21.442]         }, add = TRUE)
[17:40:21.442]     }
[17:40:21.442]     ...future.frame <- base::sys.nframe()
[17:40:21.442]     ...future.conditions <- base::list()
[17:40:21.442]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:21.442]     if (FALSE) {
[17:40:21.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:21.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:21.442]     }
[17:40:21.442]     ...future.result <- base::tryCatch({
[17:40:21.442]         base::withCallingHandlers({
[17:40:21.442]             ...future.value <- base::withVisible(base::local({
[17:40:21.442]                 ...future.makeSendCondition <- base::local({
[17:40:21.442]                   sendCondition <- NULL
[17:40:21.442]                   function(frame = 1L) {
[17:40:21.442]                     if (is.function(sendCondition)) 
[17:40:21.442]                       return(sendCondition)
[17:40:21.442]                     ns <- getNamespace("parallel")
[17:40:21.442]                     if (exists("sendData", mode = "function", 
[17:40:21.442]                       envir = ns)) {
[17:40:21.442]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:21.442]                         envir = ns)
[17:40:21.442]                       envir <- sys.frame(frame)
[17:40:21.442]                       master <- NULL
[17:40:21.442]                       while (!identical(envir, .GlobalEnv) && 
[17:40:21.442]                         !identical(envir, emptyenv())) {
[17:40:21.442]                         if (exists("master", mode = "list", envir = envir, 
[17:40:21.442]                           inherits = FALSE)) {
[17:40:21.442]                           master <- get("master", mode = "list", 
[17:40:21.442]                             envir = envir, inherits = FALSE)
[17:40:21.442]                           if (inherits(master, c("SOCKnode", 
[17:40:21.442]                             "SOCK0node"))) {
[17:40:21.442]                             sendCondition <<- function(cond) {
[17:40:21.442]                               data <- list(type = "VALUE", value = cond, 
[17:40:21.442]                                 success = TRUE)
[17:40:21.442]                               parallel_sendData(master, data)
[17:40:21.442]                             }
[17:40:21.442]                             return(sendCondition)
[17:40:21.442]                           }
[17:40:21.442]                         }
[17:40:21.442]                         frame <- frame + 1L
[17:40:21.442]                         envir <- sys.frame(frame)
[17:40:21.442]                       }
[17:40:21.442]                     }
[17:40:21.442]                     sendCondition <<- function(cond) NULL
[17:40:21.442]                   }
[17:40:21.442]                 })
[17:40:21.442]                 withCallingHandlers({
[17:40:21.442]                   NA
[17:40:21.442]                 }, immediateCondition = function(cond) {
[17:40:21.442]                   sendCondition <- ...future.makeSendCondition()
[17:40:21.442]                   sendCondition(cond)
[17:40:21.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.442]                   {
[17:40:21.442]                     inherits <- base::inherits
[17:40:21.442]                     invokeRestart <- base::invokeRestart
[17:40:21.442]                     is.null <- base::is.null
[17:40:21.442]                     muffled <- FALSE
[17:40:21.442]                     if (inherits(cond, "message")) {
[17:40:21.442]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:21.442]                       if (muffled) 
[17:40:21.442]                         invokeRestart("muffleMessage")
[17:40:21.442]                     }
[17:40:21.442]                     else if (inherits(cond, "warning")) {
[17:40:21.442]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:21.442]                       if (muffled) 
[17:40:21.442]                         invokeRestart("muffleWarning")
[17:40:21.442]                     }
[17:40:21.442]                     else if (inherits(cond, "condition")) {
[17:40:21.442]                       if (!is.null(pattern)) {
[17:40:21.442]                         computeRestarts <- base::computeRestarts
[17:40:21.442]                         grepl <- base::grepl
[17:40:21.442]                         restarts <- computeRestarts(cond)
[17:40:21.442]                         for (restart in restarts) {
[17:40:21.442]                           name <- restart$name
[17:40:21.442]                           if (is.null(name)) 
[17:40:21.442]                             next
[17:40:21.442]                           if (!grepl(pattern, name)) 
[17:40:21.442]                             next
[17:40:21.442]                           invokeRestart(restart)
[17:40:21.442]                           muffled <- TRUE
[17:40:21.442]                           break
[17:40:21.442]                         }
[17:40:21.442]                       }
[17:40:21.442]                     }
[17:40:21.442]                     invisible(muffled)
[17:40:21.442]                   }
[17:40:21.442]                   muffleCondition(cond)
[17:40:21.442]                 })
[17:40:21.442]             }))
[17:40:21.442]             future::FutureResult(value = ...future.value$value, 
[17:40:21.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.442]                   ...future.rng), globalenv = if (FALSE) 
[17:40:21.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:21.442]                     ...future.globalenv.names))
[17:40:21.442]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:21.442]         }, condition = base::local({
[17:40:21.442]             c <- base::c
[17:40:21.442]             inherits <- base::inherits
[17:40:21.442]             invokeRestart <- base::invokeRestart
[17:40:21.442]             length <- base::length
[17:40:21.442]             list <- base::list
[17:40:21.442]             seq.int <- base::seq.int
[17:40:21.442]             signalCondition <- base::signalCondition
[17:40:21.442]             sys.calls <- base::sys.calls
[17:40:21.442]             `[[` <- base::`[[`
[17:40:21.442]             `+` <- base::`+`
[17:40:21.442]             `<<-` <- base::`<<-`
[17:40:21.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:21.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:21.442]                   3L)]
[17:40:21.442]             }
[17:40:21.442]             function(cond) {
[17:40:21.442]                 is_error <- inherits(cond, "error")
[17:40:21.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:21.442]                   NULL)
[17:40:21.442]                 if (is_error) {
[17:40:21.442]                   sessionInformation <- function() {
[17:40:21.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:21.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:21.442]                       search = base::search(), system = base::Sys.info())
[17:40:21.442]                   }
[17:40:21.442]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:21.442]                     cond$call), session = sessionInformation(), 
[17:40:21.442]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:21.442]                   signalCondition(cond)
[17:40:21.442]                 }
[17:40:21.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:21.442]                 "immediateCondition"))) {
[17:40:21.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:21.442]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:21.442]                   if (TRUE && !signal) {
[17:40:21.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.442]                     {
[17:40:21.442]                       inherits <- base::inherits
[17:40:21.442]                       invokeRestart <- base::invokeRestart
[17:40:21.442]                       is.null <- base::is.null
[17:40:21.442]                       muffled <- FALSE
[17:40:21.442]                       if (inherits(cond, "message")) {
[17:40:21.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.442]                         if (muffled) 
[17:40:21.442]                           invokeRestart("muffleMessage")
[17:40:21.442]                       }
[17:40:21.442]                       else if (inherits(cond, "warning")) {
[17:40:21.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.442]                         if (muffled) 
[17:40:21.442]                           invokeRestart("muffleWarning")
[17:40:21.442]                       }
[17:40:21.442]                       else if (inherits(cond, "condition")) {
[17:40:21.442]                         if (!is.null(pattern)) {
[17:40:21.442]                           computeRestarts <- base::computeRestarts
[17:40:21.442]                           grepl <- base::grepl
[17:40:21.442]                           restarts <- computeRestarts(cond)
[17:40:21.442]                           for (restart in restarts) {
[17:40:21.442]                             name <- restart$name
[17:40:21.442]                             if (is.null(name)) 
[17:40:21.442]                               next
[17:40:21.442]                             if (!grepl(pattern, name)) 
[17:40:21.442]                               next
[17:40:21.442]                             invokeRestart(restart)
[17:40:21.442]                             muffled <- TRUE
[17:40:21.442]                             break
[17:40:21.442]                           }
[17:40:21.442]                         }
[17:40:21.442]                       }
[17:40:21.442]                       invisible(muffled)
[17:40:21.442]                     }
[17:40:21.442]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.442]                   }
[17:40:21.442]                 }
[17:40:21.442]                 else {
[17:40:21.442]                   if (TRUE) {
[17:40:21.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.442]                     {
[17:40:21.442]                       inherits <- base::inherits
[17:40:21.442]                       invokeRestart <- base::invokeRestart
[17:40:21.442]                       is.null <- base::is.null
[17:40:21.442]                       muffled <- FALSE
[17:40:21.442]                       if (inherits(cond, "message")) {
[17:40:21.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.442]                         if (muffled) 
[17:40:21.442]                           invokeRestart("muffleMessage")
[17:40:21.442]                       }
[17:40:21.442]                       else if (inherits(cond, "warning")) {
[17:40:21.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.442]                         if (muffled) 
[17:40:21.442]                           invokeRestart("muffleWarning")
[17:40:21.442]                       }
[17:40:21.442]                       else if (inherits(cond, "condition")) {
[17:40:21.442]                         if (!is.null(pattern)) {
[17:40:21.442]                           computeRestarts <- base::computeRestarts
[17:40:21.442]                           grepl <- base::grepl
[17:40:21.442]                           restarts <- computeRestarts(cond)
[17:40:21.442]                           for (restart in restarts) {
[17:40:21.442]                             name <- restart$name
[17:40:21.442]                             if (is.null(name)) 
[17:40:21.442]                               next
[17:40:21.442]                             if (!grepl(pattern, name)) 
[17:40:21.442]                               next
[17:40:21.442]                             invokeRestart(restart)
[17:40:21.442]                             muffled <- TRUE
[17:40:21.442]                             break
[17:40:21.442]                           }
[17:40:21.442]                         }
[17:40:21.442]                       }
[17:40:21.442]                       invisible(muffled)
[17:40:21.442]                     }
[17:40:21.442]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.442]                   }
[17:40:21.442]                 }
[17:40:21.442]             }
[17:40:21.442]         }))
[17:40:21.442]     }, error = function(ex) {
[17:40:21.442]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:21.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.442]                 ...future.rng), started = ...future.startTime, 
[17:40:21.442]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:21.442]             version = "1.8"), class = "FutureResult")
[17:40:21.442]     }, finally = {
[17:40:21.442]         if (!identical(...future.workdir, getwd())) 
[17:40:21.442]             setwd(...future.workdir)
[17:40:21.442]         {
[17:40:21.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:21.442]                 ...future.oldOptions$nwarnings <- NULL
[17:40:21.442]             }
[17:40:21.442]             base::options(...future.oldOptions)
[17:40:21.442]             if (.Platform$OS.type == "windows") {
[17:40:21.442]                 old_names <- names(...future.oldEnvVars)
[17:40:21.442]                 envs <- base::Sys.getenv()
[17:40:21.442]                 names <- names(envs)
[17:40:21.442]                 common <- intersect(names, old_names)
[17:40:21.442]                 added <- setdiff(names, old_names)
[17:40:21.442]                 removed <- setdiff(old_names, names)
[17:40:21.442]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:21.442]                   envs[common]]
[17:40:21.442]                 NAMES <- toupper(changed)
[17:40:21.442]                 args <- list()
[17:40:21.442]                 for (kk in seq_along(NAMES)) {
[17:40:21.442]                   name <- changed[[kk]]
[17:40:21.442]                   NAME <- NAMES[[kk]]
[17:40:21.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.442]                     next
[17:40:21.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.442]                 }
[17:40:21.442]                 NAMES <- toupper(added)
[17:40:21.442]                 for (kk in seq_along(NAMES)) {
[17:40:21.442]                   name <- added[[kk]]
[17:40:21.442]                   NAME <- NAMES[[kk]]
[17:40:21.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.442]                     next
[17:40:21.442]                   args[[name]] <- ""
[17:40:21.442]                 }
[17:40:21.442]                 NAMES <- toupper(removed)
[17:40:21.442]                 for (kk in seq_along(NAMES)) {
[17:40:21.442]                   name <- removed[[kk]]
[17:40:21.442]                   NAME <- NAMES[[kk]]
[17:40:21.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.442]                     next
[17:40:21.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.442]                 }
[17:40:21.442]                 if (length(args) > 0) 
[17:40:21.442]                   base::do.call(base::Sys.setenv, args = args)
[17:40:21.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:21.442]             }
[17:40:21.442]             else {
[17:40:21.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:21.442]             }
[17:40:21.442]             {
[17:40:21.442]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:21.442]                   0L) {
[17:40:21.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:21.442]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:21.442]                   base::options(opts)
[17:40:21.442]                 }
[17:40:21.442]                 {
[17:40:21.442]                   {
[17:40:21.442]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:21.442]                     NULL
[17:40:21.442]                   }
[17:40:21.442]                   options(future.plan = NULL)
[17:40:21.442]                   if (is.na(NA_character_)) 
[17:40:21.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:21.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:21.442]                     .init = FALSE)
[17:40:21.442]                 }
[17:40:21.442]             }
[17:40:21.442]         }
[17:40:21.442]     })
[17:40:21.442]     if (TRUE) {
[17:40:21.442]         base::sink(type = "output", split = FALSE)
[17:40:21.442]         if (TRUE) {
[17:40:21.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:21.442]         }
[17:40:21.442]         else {
[17:40:21.442]             ...future.result["stdout"] <- base::list(NULL)
[17:40:21.442]         }
[17:40:21.442]         base::close(...future.stdout)
[17:40:21.442]         ...future.stdout <- NULL
[17:40:21.442]     }
[17:40:21.442]     ...future.result$conditions <- ...future.conditions
[17:40:21.442]     ...future.result$finished <- base::Sys.time()
[17:40:21.442]     ...future.result
[17:40:21.442] }
[17:40:21.493] MultisessionFuture started
[17:40:21.493] result() for ClusterFuture ...
[17:40:21.494] receiveMessageFromWorker() for ClusterFuture ...
[17:40:21.494] - Validating connection of MultisessionFuture
[17:40:21.528] - received message: FutureResult
[17:40:21.528] - Received FutureResult
[17:40:21.528] - Erased future from FutureRegistry
[17:40:21.528] result() for ClusterFuture ...
[17:40:21.528] - result already collected: FutureResult
[17:40:21.528] result() for ClusterFuture ... done
[17:40:21.528] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:21.528] result() for ClusterFuture ... done
[17:40:21.529] result() for ClusterFuture ...
[17:40:21.529] - result already collected: FutureResult
[17:40:21.529] result() for ClusterFuture ... done
[17:40:21.529] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:21.533] plan(): nbrOfWorkers() = 2
[17:40:21.533] getGlobalsAndPackages() ...
[17:40:21.533] Searching for globals...
[17:40:21.551] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:21.551] Searching for globals ... DONE
[17:40:21.551] Resolving globals: FALSE
[17:40:21.552] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[17:40:21.553] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:21.553] - globals: [2] ‘nested’, ‘strategy2’
[17:40:21.553] - packages: [1] ‘future’
[17:40:21.553] getGlobalsAndPackages() ... DONE
[17:40:21.554] run() for ‘Future’ ...
[17:40:21.554] - state: ‘created’
[17:40:21.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:21.574] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:21.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:21.574]   - Field: ‘node’
[17:40:21.574]   - Field: ‘label’
[17:40:21.574]   - Field: ‘local’
[17:40:21.574]   - Field: ‘owner’
[17:40:21.574]   - Field: ‘envir’
[17:40:21.574]   - Field: ‘workers’
[17:40:21.575]   - Field: ‘packages’
[17:40:21.575]   - Field: ‘gc’
[17:40:21.575]   - Field: ‘conditions’
[17:40:21.575]   - Field: ‘persistent’
[17:40:21.575]   - Field: ‘expr’
[17:40:21.575]   - Field: ‘uuid’
[17:40:21.575]   - Field: ‘seed’
[17:40:21.575]   - Field: ‘version’
[17:40:21.575]   - Field: ‘result’
[17:40:21.575]   - Field: ‘asynchronous’
[17:40:21.575]   - Field: ‘calls’
[17:40:21.576]   - Field: ‘globals’
[17:40:21.576]   - Field: ‘stdout’
[17:40:21.576]   - Field: ‘earlySignal’
[17:40:21.576]   - Field: ‘lazy’
[17:40:21.576]   - Field: ‘state’
[17:40:21.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:21.576] - Launch lazy future ...
[17:40:21.576] Packages needed by the future expression (n = 1): ‘future’
[17:40:21.577] Packages needed by future strategies (n = 1): ‘future’
[17:40:21.577] {
[17:40:21.577]     {
[17:40:21.577]         {
[17:40:21.577]             ...future.startTime <- base::Sys.time()
[17:40:21.577]             {
[17:40:21.577]                 {
[17:40:21.577]                   {
[17:40:21.577]                     {
[17:40:21.577]                       {
[17:40:21.577]                         base::local({
[17:40:21.577]                           has_future <- base::requireNamespace("future", 
[17:40:21.577]                             quietly = TRUE)
[17:40:21.577]                           if (has_future) {
[17:40:21.577]                             ns <- base::getNamespace("future")
[17:40:21.577]                             version <- ns[[".package"]][["version"]]
[17:40:21.577]                             if (is.null(version)) 
[17:40:21.577]                               version <- utils::packageVersion("future")
[17:40:21.577]                           }
[17:40:21.577]                           else {
[17:40:21.577]                             version <- NULL
[17:40:21.577]                           }
[17:40:21.577]                           if (!has_future || version < "1.8.0") {
[17:40:21.577]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:21.577]                               "", base::R.version$version.string), 
[17:40:21.577]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:21.577]                                 base::R.version$platform, 8 * 
[17:40:21.577]                                   base::.Machine$sizeof.pointer), 
[17:40:21.577]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:21.577]                                 "release", "version")], collapse = " "), 
[17:40:21.577]                               hostname = base::Sys.info()[["nodename"]])
[17:40:21.577]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:21.577]                               info)
[17:40:21.577]                             info <- base::paste(info, collapse = "; ")
[17:40:21.577]                             if (!has_future) {
[17:40:21.577]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:21.577]                                 info)
[17:40:21.577]                             }
[17:40:21.577]                             else {
[17:40:21.577]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:21.577]                                 info, version)
[17:40:21.577]                             }
[17:40:21.577]                             base::stop(msg)
[17:40:21.577]                           }
[17:40:21.577]                         })
[17:40:21.577]                       }
[17:40:21.577]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:21.577]                       base::options(mc.cores = 1L)
[17:40:21.577]                     }
[17:40:21.577]                     base::local({
[17:40:21.577]                       for (pkg in "future") {
[17:40:21.577]                         base::loadNamespace(pkg)
[17:40:21.577]                         base::library(pkg, character.only = TRUE)
[17:40:21.577]                       }
[17:40:21.577]                     })
[17:40:21.577]                   }
[17:40:21.577]                   ...future.strategy.old <- future::plan("list")
[17:40:21.577]                   options(future.plan = NULL)
[17:40:21.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.577]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:21.577]                   {
[17:40:21.577]                     future <- SequentialFuture(..., envir = envir)
[17:40:21.577]                     if (!future$lazy) 
[17:40:21.577]                       future <- run(future)
[17:40:21.577]                     invisible(future)
[17:40:21.577]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:21.577]                 }
[17:40:21.577]                 ...future.workdir <- getwd()
[17:40:21.577]             }
[17:40:21.577]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:21.577]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:21.577]         }
[17:40:21.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:21.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:21.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:21.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:21.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:21.577]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:21.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:21.577]             base::names(...future.oldOptions))
[17:40:21.577]     }
[17:40:21.577]     if (FALSE) {
[17:40:21.577]     }
[17:40:21.577]     else {
[17:40:21.577]         if (TRUE) {
[17:40:21.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:21.577]                 open = "w")
[17:40:21.577]         }
[17:40:21.577]         else {
[17:40:21.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:21.577]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:21.577]         }
[17:40:21.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:21.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:21.577]             base::sink(type = "output", split = FALSE)
[17:40:21.577]             base::close(...future.stdout)
[17:40:21.577]         }, add = TRUE)
[17:40:21.577]     }
[17:40:21.577]     ...future.frame <- base::sys.nframe()
[17:40:21.577]     ...future.conditions <- base::list()
[17:40:21.577]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:21.577]     if (FALSE) {
[17:40:21.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:21.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:21.577]     }
[17:40:21.577]     ...future.result <- base::tryCatch({
[17:40:21.577]         base::withCallingHandlers({
[17:40:21.577]             ...future.value <- base::withVisible(base::local({
[17:40:21.577]                 ...future.makeSendCondition <- base::local({
[17:40:21.577]                   sendCondition <- NULL
[17:40:21.577]                   function(frame = 1L) {
[17:40:21.577]                     if (is.function(sendCondition)) 
[17:40:21.577]                       return(sendCondition)
[17:40:21.577]                     ns <- getNamespace("parallel")
[17:40:21.577]                     if (exists("sendData", mode = "function", 
[17:40:21.577]                       envir = ns)) {
[17:40:21.577]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:21.577]                         envir = ns)
[17:40:21.577]                       envir <- sys.frame(frame)
[17:40:21.577]                       master <- NULL
[17:40:21.577]                       while (!identical(envir, .GlobalEnv) && 
[17:40:21.577]                         !identical(envir, emptyenv())) {
[17:40:21.577]                         if (exists("master", mode = "list", envir = envir, 
[17:40:21.577]                           inherits = FALSE)) {
[17:40:21.577]                           master <- get("master", mode = "list", 
[17:40:21.577]                             envir = envir, inherits = FALSE)
[17:40:21.577]                           if (inherits(master, c("SOCKnode", 
[17:40:21.577]                             "SOCK0node"))) {
[17:40:21.577]                             sendCondition <<- function(cond) {
[17:40:21.577]                               data <- list(type = "VALUE", value = cond, 
[17:40:21.577]                                 success = TRUE)
[17:40:21.577]                               parallel_sendData(master, data)
[17:40:21.577]                             }
[17:40:21.577]                             return(sendCondition)
[17:40:21.577]                           }
[17:40:21.577]                         }
[17:40:21.577]                         frame <- frame + 1L
[17:40:21.577]                         envir <- sys.frame(frame)
[17:40:21.577]                       }
[17:40:21.577]                     }
[17:40:21.577]                     sendCondition <<- function(cond) NULL
[17:40:21.577]                   }
[17:40:21.577]                 })
[17:40:21.577]                 withCallingHandlers({
[17:40:21.577]                   {
[17:40:21.577]                     a <- 1L
[17:40:21.577]                     plan_a <- unclass(future::plan("list"))
[17:40:21.577]                     nested_a <- nested[-1]
[17:40:21.577]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:21.577]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:21.577]                       strategy2))
[17:40:21.577]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:21.577]                       "init") <- NULL
[17:40:21.577]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:21.577]                       "init") <- NULL
[17:40:21.577]                     stopifnot(all.equal(plan_a, nested_a))
[17:40:21.577]                     y %<-% {
[17:40:21.577]                       b <- 2L
[17:40:21.577]                       plan_b <- future::plan("list")
[17:40:21.577]                       nested_b <- nested_a[-1]
[17:40:21.577]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:21.577]                         1L, inherits(plan_b[[1]], "future"), 
[17:40:21.577]                         inherits(future::plan("next"), "sequential"))
[17:40:21.577]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:21.577]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:21.577]                     }
[17:40:21.577]                     y
[17:40:21.577]                   }
[17:40:21.577]                 }, immediateCondition = function(cond) {
[17:40:21.577]                   sendCondition <- ...future.makeSendCondition()
[17:40:21.577]                   sendCondition(cond)
[17:40:21.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.577]                   {
[17:40:21.577]                     inherits <- base::inherits
[17:40:21.577]                     invokeRestart <- base::invokeRestart
[17:40:21.577]                     is.null <- base::is.null
[17:40:21.577]                     muffled <- FALSE
[17:40:21.577]                     if (inherits(cond, "message")) {
[17:40:21.577]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:21.577]                       if (muffled) 
[17:40:21.577]                         invokeRestart("muffleMessage")
[17:40:21.577]                     }
[17:40:21.577]                     else if (inherits(cond, "warning")) {
[17:40:21.577]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:21.577]                       if (muffled) 
[17:40:21.577]                         invokeRestart("muffleWarning")
[17:40:21.577]                     }
[17:40:21.577]                     else if (inherits(cond, "condition")) {
[17:40:21.577]                       if (!is.null(pattern)) {
[17:40:21.577]                         computeRestarts <- base::computeRestarts
[17:40:21.577]                         grepl <- base::grepl
[17:40:21.577]                         restarts <- computeRestarts(cond)
[17:40:21.577]                         for (restart in restarts) {
[17:40:21.577]                           name <- restart$name
[17:40:21.577]                           if (is.null(name)) 
[17:40:21.577]                             next
[17:40:21.577]                           if (!grepl(pattern, name)) 
[17:40:21.577]                             next
[17:40:21.577]                           invokeRestart(restart)
[17:40:21.577]                           muffled <- TRUE
[17:40:21.577]                           break
[17:40:21.577]                         }
[17:40:21.577]                       }
[17:40:21.577]                     }
[17:40:21.577]                     invisible(muffled)
[17:40:21.577]                   }
[17:40:21.577]                   muffleCondition(cond)
[17:40:21.577]                 })
[17:40:21.577]             }))
[17:40:21.577]             future::FutureResult(value = ...future.value$value, 
[17:40:21.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.577]                   ...future.rng), globalenv = if (FALSE) 
[17:40:21.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:21.577]                     ...future.globalenv.names))
[17:40:21.577]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:21.577]         }, condition = base::local({
[17:40:21.577]             c <- base::c
[17:40:21.577]             inherits <- base::inherits
[17:40:21.577]             invokeRestart <- base::invokeRestart
[17:40:21.577]             length <- base::length
[17:40:21.577]             list <- base::list
[17:40:21.577]             seq.int <- base::seq.int
[17:40:21.577]             signalCondition <- base::signalCondition
[17:40:21.577]             sys.calls <- base::sys.calls
[17:40:21.577]             `[[` <- base::`[[`
[17:40:21.577]             `+` <- base::`+`
[17:40:21.577]             `<<-` <- base::`<<-`
[17:40:21.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:21.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:21.577]                   3L)]
[17:40:21.577]             }
[17:40:21.577]             function(cond) {
[17:40:21.577]                 is_error <- inherits(cond, "error")
[17:40:21.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:21.577]                   NULL)
[17:40:21.577]                 if (is_error) {
[17:40:21.577]                   sessionInformation <- function() {
[17:40:21.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:21.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:21.577]                       search = base::search(), system = base::Sys.info())
[17:40:21.577]                   }
[17:40:21.577]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:21.577]                     cond$call), session = sessionInformation(), 
[17:40:21.577]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:21.577]                   signalCondition(cond)
[17:40:21.577]                 }
[17:40:21.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:21.577]                 "immediateCondition"))) {
[17:40:21.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:21.577]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:21.577]                   if (TRUE && !signal) {
[17:40:21.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.577]                     {
[17:40:21.577]                       inherits <- base::inherits
[17:40:21.577]                       invokeRestart <- base::invokeRestart
[17:40:21.577]                       is.null <- base::is.null
[17:40:21.577]                       muffled <- FALSE
[17:40:21.577]                       if (inherits(cond, "message")) {
[17:40:21.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.577]                         if (muffled) 
[17:40:21.577]                           invokeRestart("muffleMessage")
[17:40:21.577]                       }
[17:40:21.577]                       else if (inherits(cond, "warning")) {
[17:40:21.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.577]                         if (muffled) 
[17:40:21.577]                           invokeRestart("muffleWarning")
[17:40:21.577]                       }
[17:40:21.577]                       else if (inherits(cond, "condition")) {
[17:40:21.577]                         if (!is.null(pattern)) {
[17:40:21.577]                           computeRestarts <- base::computeRestarts
[17:40:21.577]                           grepl <- base::grepl
[17:40:21.577]                           restarts <- computeRestarts(cond)
[17:40:21.577]                           for (restart in restarts) {
[17:40:21.577]                             name <- restart$name
[17:40:21.577]                             if (is.null(name)) 
[17:40:21.577]                               next
[17:40:21.577]                             if (!grepl(pattern, name)) 
[17:40:21.577]                               next
[17:40:21.577]                             invokeRestart(restart)
[17:40:21.577]                             muffled <- TRUE
[17:40:21.577]                             break
[17:40:21.577]                           }
[17:40:21.577]                         }
[17:40:21.577]                       }
[17:40:21.577]                       invisible(muffled)
[17:40:21.577]                     }
[17:40:21.577]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.577]                   }
[17:40:21.577]                 }
[17:40:21.577]                 else {
[17:40:21.577]                   if (TRUE) {
[17:40:21.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.577]                     {
[17:40:21.577]                       inherits <- base::inherits
[17:40:21.577]                       invokeRestart <- base::invokeRestart
[17:40:21.577]                       is.null <- base::is.null
[17:40:21.577]                       muffled <- FALSE
[17:40:21.577]                       if (inherits(cond, "message")) {
[17:40:21.577]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.577]                         if (muffled) 
[17:40:21.577]                           invokeRestart("muffleMessage")
[17:40:21.577]                       }
[17:40:21.577]                       else if (inherits(cond, "warning")) {
[17:40:21.577]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.577]                         if (muffled) 
[17:40:21.577]                           invokeRestart("muffleWarning")
[17:40:21.577]                       }
[17:40:21.577]                       else if (inherits(cond, "condition")) {
[17:40:21.577]                         if (!is.null(pattern)) {
[17:40:21.577]                           computeRestarts <- base::computeRestarts
[17:40:21.577]                           grepl <- base::grepl
[17:40:21.577]                           restarts <- computeRestarts(cond)
[17:40:21.577]                           for (restart in restarts) {
[17:40:21.577]                             name <- restart$name
[17:40:21.577]                             if (is.null(name)) 
[17:40:21.577]                               next
[17:40:21.577]                             if (!grepl(pattern, name)) 
[17:40:21.577]                               next
[17:40:21.577]                             invokeRestart(restart)
[17:40:21.577]                             muffled <- TRUE
[17:40:21.577]                             break
[17:40:21.577]                           }
[17:40:21.577]                         }
[17:40:21.577]                       }
[17:40:21.577]                       invisible(muffled)
[17:40:21.577]                     }
[17:40:21.577]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.577]                   }
[17:40:21.577]                 }
[17:40:21.577]             }
[17:40:21.577]         }))
[17:40:21.577]     }, error = function(ex) {
[17:40:21.577]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:21.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.577]                 ...future.rng), started = ...future.startTime, 
[17:40:21.577]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:21.577]             version = "1.8"), class = "FutureResult")
[17:40:21.577]     }, finally = {
[17:40:21.577]         if (!identical(...future.workdir, getwd())) 
[17:40:21.577]             setwd(...future.workdir)
[17:40:21.577]         {
[17:40:21.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:21.577]                 ...future.oldOptions$nwarnings <- NULL
[17:40:21.577]             }
[17:40:21.577]             base::options(...future.oldOptions)
[17:40:21.577]             if (.Platform$OS.type == "windows") {
[17:40:21.577]                 old_names <- names(...future.oldEnvVars)
[17:40:21.577]                 envs <- base::Sys.getenv()
[17:40:21.577]                 names <- names(envs)
[17:40:21.577]                 common <- intersect(names, old_names)
[17:40:21.577]                 added <- setdiff(names, old_names)
[17:40:21.577]                 removed <- setdiff(old_names, names)
[17:40:21.577]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:21.577]                   envs[common]]
[17:40:21.577]                 NAMES <- toupper(changed)
[17:40:21.577]                 args <- list()
[17:40:21.577]                 for (kk in seq_along(NAMES)) {
[17:40:21.577]                   name <- changed[[kk]]
[17:40:21.577]                   NAME <- NAMES[[kk]]
[17:40:21.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.577]                     next
[17:40:21.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.577]                 }
[17:40:21.577]                 NAMES <- toupper(added)
[17:40:21.577]                 for (kk in seq_along(NAMES)) {
[17:40:21.577]                   name <- added[[kk]]
[17:40:21.577]                   NAME <- NAMES[[kk]]
[17:40:21.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.577]                     next
[17:40:21.577]                   args[[name]] <- ""
[17:40:21.577]                 }
[17:40:21.577]                 NAMES <- toupper(removed)
[17:40:21.577]                 for (kk in seq_along(NAMES)) {
[17:40:21.577]                   name <- removed[[kk]]
[17:40:21.577]                   NAME <- NAMES[[kk]]
[17:40:21.577]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.577]                     next
[17:40:21.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.577]                 }
[17:40:21.577]                 if (length(args) > 0) 
[17:40:21.577]                   base::do.call(base::Sys.setenv, args = args)
[17:40:21.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:21.577]             }
[17:40:21.577]             else {
[17:40:21.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:21.577]             }
[17:40:21.577]             {
[17:40:21.577]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:21.577]                   0L) {
[17:40:21.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:21.577]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:21.577]                   base::options(opts)
[17:40:21.577]                 }
[17:40:21.577]                 {
[17:40:21.577]                   {
[17:40:21.577]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:21.577]                     NULL
[17:40:21.577]                   }
[17:40:21.577]                   options(future.plan = NULL)
[17:40:21.577]                   if (is.na(NA_character_)) 
[17:40:21.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:21.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:21.577]                     .init = FALSE)
[17:40:21.577]                 }
[17:40:21.577]             }
[17:40:21.577]         }
[17:40:21.577]     })
[17:40:21.577]     if (TRUE) {
[17:40:21.577]         base::sink(type = "output", split = FALSE)
[17:40:21.577]         if (TRUE) {
[17:40:21.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:21.577]         }
[17:40:21.577]         else {
[17:40:21.577]             ...future.result["stdout"] <- base::list(NULL)
[17:40:21.577]         }
[17:40:21.577]         base::close(...future.stdout)
[17:40:21.577]         ...future.stdout <- NULL
[17:40:21.577]     }
[17:40:21.577]     ...future.result$conditions <- ...future.conditions
[17:40:21.577]     ...future.result$finished <- base::Sys.time()
[17:40:21.577]     ...future.result
[17:40:21.577] }
[17:40:21.580] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[17:40:21.580] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[17:40:21.621] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[17:40:21.621] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:40:21.621] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:40:21.621] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[17:40:21.622] MultisessionFuture started
[17:40:21.622] - Launch lazy future ... done
[17:40:21.622] run() for ‘MultisessionFuture’ ... done
[17:40:21.622] result() for ClusterFuture ...
[17:40:21.622] receiveMessageFromWorker() for ClusterFuture ...
[17:40:21.623] - Validating connection of MultisessionFuture
[17:40:21.687] - received message: FutureResult
[17:40:21.687] - Received FutureResult
[17:40:21.687] - Erased future from FutureRegistry
[17:40:21.687] result() for ClusterFuture ...
[17:40:21.687] - result already collected: FutureResult
[17:40:21.687] result() for ClusterFuture ... done
[17:40:21.688] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:21.688] result() for ClusterFuture ... done
[17:40:21.688] result() for ClusterFuture ...
[17:40:21.688] - result already collected: FutureResult
[17:40:21.688] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:21.693] getGlobalsAndPackages() ...
[17:40:21.693] Searching for globals...
[17:40:21.694] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:21.694] Searching for globals ... DONE
[17:40:21.694] Resolving globals: FALSE
[17:40:21.695] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:21.695] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:21.695] - globals: [1] ‘data’
[17:40:21.695] - packages: [1] ‘future’
[17:40:21.696] getGlobalsAndPackages() ... DONE
[17:40:21.696] run() for ‘Future’ ...
[17:40:21.696] - state: ‘created’
[17:40:21.696] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:21.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:21.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:21.712]   - Field: ‘node’
[17:40:21.712]   - Field: ‘label’
[17:40:21.712]   - Field: ‘local’
[17:40:21.712]   - Field: ‘owner’
[17:40:21.712]   - Field: ‘envir’
[17:40:21.712]   - Field: ‘workers’
[17:40:21.712]   - Field: ‘packages’
[17:40:21.712]   - Field: ‘gc’
[17:40:21.712]   - Field: ‘conditions’
[17:40:21.713]   - Field: ‘persistent’
[17:40:21.713]   - Field: ‘expr’
[17:40:21.713]   - Field: ‘uuid’
[17:40:21.713]   - Field: ‘seed’
[17:40:21.713]   - Field: ‘version’
[17:40:21.713]   - Field: ‘result’
[17:40:21.713]   - Field: ‘asynchronous’
[17:40:21.713]   - Field: ‘calls’
[17:40:21.713]   - Field: ‘globals’
[17:40:21.713]   - Field: ‘stdout’
[17:40:21.713]   - Field: ‘earlySignal’
[17:40:21.714]   - Field: ‘lazy’
[17:40:21.714]   - Field: ‘state’
[17:40:21.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:21.714] - Launch lazy future ...
[17:40:21.714] Packages needed by the future expression (n = 1): ‘future’
[17:40:21.714] Packages needed by future strategies (n = 1): ‘future’
[17:40:21.715] {
[17:40:21.715]     {
[17:40:21.715]         {
[17:40:21.715]             ...future.startTime <- base::Sys.time()
[17:40:21.715]             {
[17:40:21.715]                 {
[17:40:21.715]                   {
[17:40:21.715]                     {
[17:40:21.715]                       {
[17:40:21.715]                         base::local({
[17:40:21.715]                           has_future <- base::requireNamespace("future", 
[17:40:21.715]                             quietly = TRUE)
[17:40:21.715]                           if (has_future) {
[17:40:21.715]                             ns <- base::getNamespace("future")
[17:40:21.715]                             version <- ns[[".package"]][["version"]]
[17:40:21.715]                             if (is.null(version)) 
[17:40:21.715]                               version <- utils::packageVersion("future")
[17:40:21.715]                           }
[17:40:21.715]                           else {
[17:40:21.715]                             version <- NULL
[17:40:21.715]                           }
[17:40:21.715]                           if (!has_future || version < "1.8.0") {
[17:40:21.715]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:21.715]                               "", base::R.version$version.string), 
[17:40:21.715]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:21.715]                                 base::R.version$platform, 8 * 
[17:40:21.715]                                   base::.Machine$sizeof.pointer), 
[17:40:21.715]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:21.715]                                 "release", "version")], collapse = " "), 
[17:40:21.715]                               hostname = base::Sys.info()[["nodename"]])
[17:40:21.715]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:21.715]                               info)
[17:40:21.715]                             info <- base::paste(info, collapse = "; ")
[17:40:21.715]                             if (!has_future) {
[17:40:21.715]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:21.715]                                 info)
[17:40:21.715]                             }
[17:40:21.715]                             else {
[17:40:21.715]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:21.715]                                 info, version)
[17:40:21.715]                             }
[17:40:21.715]                             base::stop(msg)
[17:40:21.715]                           }
[17:40:21.715]                         })
[17:40:21.715]                       }
[17:40:21.715]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:21.715]                       base::options(mc.cores = 1L)
[17:40:21.715]                     }
[17:40:21.715]                     base::local({
[17:40:21.715]                       for (pkg in "future") {
[17:40:21.715]                         base::loadNamespace(pkg)
[17:40:21.715]                         base::library(pkg, character.only = TRUE)
[17:40:21.715]                       }
[17:40:21.715]                     })
[17:40:21.715]                   }
[17:40:21.715]                   ...future.strategy.old <- future::plan("list")
[17:40:21.715]                   options(future.plan = NULL)
[17:40:21.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.715]                   future::plan(list(b = function (..., envir = parent.frame()) 
[17:40:21.715]                   {
[17:40:21.715]                     future <- SequentialFuture(..., envir = envir)
[17:40:21.715]                     if (!future$lazy) 
[17:40:21.715]                       future <- run(future)
[17:40:21.715]                     invisible(future)
[17:40:21.715]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:21.715]                 }
[17:40:21.715]                 ...future.workdir <- getwd()
[17:40:21.715]             }
[17:40:21.715]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:21.715]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:21.715]         }
[17:40:21.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:21.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:21.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:21.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:21.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:21.715]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:21.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:21.715]             base::names(...future.oldOptions))
[17:40:21.715]     }
[17:40:21.715]     if (FALSE) {
[17:40:21.715]     }
[17:40:21.715]     else {
[17:40:21.715]         if (TRUE) {
[17:40:21.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:21.715]                 open = "w")
[17:40:21.715]         }
[17:40:21.715]         else {
[17:40:21.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:21.715]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:21.715]         }
[17:40:21.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:21.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:21.715]             base::sink(type = "output", split = FALSE)
[17:40:21.715]             base::close(...future.stdout)
[17:40:21.715]         }, add = TRUE)
[17:40:21.715]     }
[17:40:21.715]     ...future.frame <- base::sys.nframe()
[17:40:21.715]     ...future.conditions <- base::list()
[17:40:21.715]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:21.715]     if (FALSE) {
[17:40:21.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:21.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:21.715]     }
[17:40:21.715]     ...future.result <- base::tryCatch({
[17:40:21.715]         base::withCallingHandlers({
[17:40:21.715]             ...future.value <- base::withVisible(base::local({
[17:40:21.715]                 ...future.makeSendCondition <- base::local({
[17:40:21.715]                   sendCondition <- NULL
[17:40:21.715]                   function(frame = 1L) {
[17:40:21.715]                     if (is.function(sendCondition)) 
[17:40:21.715]                       return(sendCondition)
[17:40:21.715]                     ns <- getNamespace("parallel")
[17:40:21.715]                     if (exists("sendData", mode = "function", 
[17:40:21.715]                       envir = ns)) {
[17:40:21.715]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:21.715]                         envir = ns)
[17:40:21.715]                       envir <- sys.frame(frame)
[17:40:21.715]                       master <- NULL
[17:40:21.715]                       while (!identical(envir, .GlobalEnv) && 
[17:40:21.715]                         !identical(envir, emptyenv())) {
[17:40:21.715]                         if (exists("master", mode = "list", envir = envir, 
[17:40:21.715]                           inherits = FALSE)) {
[17:40:21.715]                           master <- get("master", mode = "list", 
[17:40:21.715]                             envir = envir, inherits = FALSE)
[17:40:21.715]                           if (inherits(master, c("SOCKnode", 
[17:40:21.715]                             "SOCK0node"))) {
[17:40:21.715]                             sendCondition <<- function(cond) {
[17:40:21.715]                               data <- list(type = "VALUE", value = cond, 
[17:40:21.715]                                 success = TRUE)
[17:40:21.715]                               parallel_sendData(master, data)
[17:40:21.715]                             }
[17:40:21.715]                             return(sendCondition)
[17:40:21.715]                           }
[17:40:21.715]                         }
[17:40:21.715]                         frame <- frame + 1L
[17:40:21.715]                         envir <- sys.frame(frame)
[17:40:21.715]                       }
[17:40:21.715]                     }
[17:40:21.715]                     sendCondition <<- function(cond) NULL
[17:40:21.715]                   }
[17:40:21.715]                 })
[17:40:21.715]                 withCallingHandlers({
[17:40:21.715]                   {
[17:40:21.715]                     value(future(subset(data, a == 2)))
[17:40:21.715]                   }
[17:40:21.715]                 }, immediateCondition = function(cond) {
[17:40:21.715]                   sendCondition <- ...future.makeSendCondition()
[17:40:21.715]                   sendCondition(cond)
[17:40:21.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.715]                   {
[17:40:21.715]                     inherits <- base::inherits
[17:40:21.715]                     invokeRestart <- base::invokeRestart
[17:40:21.715]                     is.null <- base::is.null
[17:40:21.715]                     muffled <- FALSE
[17:40:21.715]                     if (inherits(cond, "message")) {
[17:40:21.715]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:21.715]                       if (muffled) 
[17:40:21.715]                         invokeRestart("muffleMessage")
[17:40:21.715]                     }
[17:40:21.715]                     else if (inherits(cond, "warning")) {
[17:40:21.715]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:21.715]                       if (muffled) 
[17:40:21.715]                         invokeRestart("muffleWarning")
[17:40:21.715]                     }
[17:40:21.715]                     else if (inherits(cond, "condition")) {
[17:40:21.715]                       if (!is.null(pattern)) {
[17:40:21.715]                         computeRestarts <- base::computeRestarts
[17:40:21.715]                         grepl <- base::grepl
[17:40:21.715]                         restarts <- computeRestarts(cond)
[17:40:21.715]                         for (restart in restarts) {
[17:40:21.715]                           name <- restart$name
[17:40:21.715]                           if (is.null(name)) 
[17:40:21.715]                             next
[17:40:21.715]                           if (!grepl(pattern, name)) 
[17:40:21.715]                             next
[17:40:21.715]                           invokeRestart(restart)
[17:40:21.715]                           muffled <- TRUE
[17:40:21.715]                           break
[17:40:21.715]                         }
[17:40:21.715]                       }
[17:40:21.715]                     }
[17:40:21.715]                     invisible(muffled)
[17:40:21.715]                   }
[17:40:21.715]                   muffleCondition(cond)
[17:40:21.715]                 })
[17:40:21.715]             }))
[17:40:21.715]             future::FutureResult(value = ...future.value$value, 
[17:40:21.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.715]                   ...future.rng), globalenv = if (FALSE) 
[17:40:21.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:21.715]                     ...future.globalenv.names))
[17:40:21.715]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:21.715]         }, condition = base::local({
[17:40:21.715]             c <- base::c
[17:40:21.715]             inherits <- base::inherits
[17:40:21.715]             invokeRestart <- base::invokeRestart
[17:40:21.715]             length <- base::length
[17:40:21.715]             list <- base::list
[17:40:21.715]             seq.int <- base::seq.int
[17:40:21.715]             signalCondition <- base::signalCondition
[17:40:21.715]             sys.calls <- base::sys.calls
[17:40:21.715]             `[[` <- base::`[[`
[17:40:21.715]             `+` <- base::`+`
[17:40:21.715]             `<<-` <- base::`<<-`
[17:40:21.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:21.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:21.715]                   3L)]
[17:40:21.715]             }
[17:40:21.715]             function(cond) {
[17:40:21.715]                 is_error <- inherits(cond, "error")
[17:40:21.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:21.715]                   NULL)
[17:40:21.715]                 if (is_error) {
[17:40:21.715]                   sessionInformation <- function() {
[17:40:21.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:21.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:21.715]                       search = base::search(), system = base::Sys.info())
[17:40:21.715]                   }
[17:40:21.715]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:21.715]                     cond$call), session = sessionInformation(), 
[17:40:21.715]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:21.715]                   signalCondition(cond)
[17:40:21.715]                 }
[17:40:21.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:21.715]                 "immediateCondition"))) {
[17:40:21.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:21.715]                   ...future.conditions[[length(...future.conditions) + 
[17:40:21.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:21.715]                   if (TRUE && !signal) {
[17:40:21.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.715]                     {
[17:40:21.715]                       inherits <- base::inherits
[17:40:21.715]                       invokeRestart <- base::invokeRestart
[17:40:21.715]                       is.null <- base::is.null
[17:40:21.715]                       muffled <- FALSE
[17:40:21.715]                       if (inherits(cond, "message")) {
[17:40:21.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.715]                         if (muffled) 
[17:40:21.715]                           invokeRestart("muffleMessage")
[17:40:21.715]                       }
[17:40:21.715]                       else if (inherits(cond, "warning")) {
[17:40:21.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.715]                         if (muffled) 
[17:40:21.715]                           invokeRestart("muffleWarning")
[17:40:21.715]                       }
[17:40:21.715]                       else if (inherits(cond, "condition")) {
[17:40:21.715]                         if (!is.null(pattern)) {
[17:40:21.715]                           computeRestarts <- base::computeRestarts
[17:40:21.715]                           grepl <- base::grepl
[17:40:21.715]                           restarts <- computeRestarts(cond)
[17:40:21.715]                           for (restart in restarts) {
[17:40:21.715]                             name <- restart$name
[17:40:21.715]                             if (is.null(name)) 
[17:40:21.715]                               next
[17:40:21.715]                             if (!grepl(pattern, name)) 
[17:40:21.715]                               next
[17:40:21.715]                             invokeRestart(restart)
[17:40:21.715]                             muffled <- TRUE
[17:40:21.715]                             break
[17:40:21.715]                           }
[17:40:21.715]                         }
[17:40:21.715]                       }
[17:40:21.715]                       invisible(muffled)
[17:40:21.715]                     }
[17:40:21.715]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.715]                   }
[17:40:21.715]                 }
[17:40:21.715]                 else {
[17:40:21.715]                   if (TRUE) {
[17:40:21.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:21.715]                     {
[17:40:21.715]                       inherits <- base::inherits
[17:40:21.715]                       invokeRestart <- base::invokeRestart
[17:40:21.715]                       is.null <- base::is.null
[17:40:21.715]                       muffled <- FALSE
[17:40:21.715]                       if (inherits(cond, "message")) {
[17:40:21.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:21.715]                         if (muffled) 
[17:40:21.715]                           invokeRestart("muffleMessage")
[17:40:21.715]                       }
[17:40:21.715]                       else if (inherits(cond, "warning")) {
[17:40:21.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:21.715]                         if (muffled) 
[17:40:21.715]                           invokeRestart("muffleWarning")
[17:40:21.715]                       }
[17:40:21.715]                       else if (inherits(cond, "condition")) {
[17:40:21.715]                         if (!is.null(pattern)) {
[17:40:21.715]                           computeRestarts <- base::computeRestarts
[17:40:21.715]                           grepl <- base::grepl
[17:40:21.715]                           restarts <- computeRestarts(cond)
[17:40:21.715]                           for (restart in restarts) {
[17:40:21.715]                             name <- restart$name
[17:40:21.715]                             if (is.null(name)) 
[17:40:21.715]                               next
[17:40:21.715]                             if (!grepl(pattern, name)) 
[17:40:21.715]                               next
[17:40:21.715]                             invokeRestart(restart)
[17:40:21.715]                             muffled <- TRUE
[17:40:21.715]                             break
[17:40:21.715]                           }
[17:40:21.715]                         }
[17:40:21.715]                       }
[17:40:21.715]                       invisible(muffled)
[17:40:21.715]                     }
[17:40:21.715]                     muffleCondition(cond, pattern = "^muffle")
[17:40:21.715]                   }
[17:40:21.715]                 }
[17:40:21.715]             }
[17:40:21.715]         }))
[17:40:21.715]     }, error = function(ex) {
[17:40:21.715]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:21.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:21.715]                 ...future.rng), started = ...future.startTime, 
[17:40:21.715]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:21.715]             version = "1.8"), class = "FutureResult")
[17:40:21.715]     }, finally = {
[17:40:21.715]         if (!identical(...future.workdir, getwd())) 
[17:40:21.715]             setwd(...future.workdir)
[17:40:21.715]         {
[17:40:21.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:21.715]                 ...future.oldOptions$nwarnings <- NULL
[17:40:21.715]             }
[17:40:21.715]             base::options(...future.oldOptions)
[17:40:21.715]             if (.Platform$OS.type == "windows") {
[17:40:21.715]                 old_names <- names(...future.oldEnvVars)
[17:40:21.715]                 envs <- base::Sys.getenv()
[17:40:21.715]                 names <- names(envs)
[17:40:21.715]                 common <- intersect(names, old_names)
[17:40:21.715]                 added <- setdiff(names, old_names)
[17:40:21.715]                 removed <- setdiff(old_names, names)
[17:40:21.715]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:21.715]                   envs[common]]
[17:40:21.715]                 NAMES <- toupper(changed)
[17:40:21.715]                 args <- list()
[17:40:21.715]                 for (kk in seq_along(NAMES)) {
[17:40:21.715]                   name <- changed[[kk]]
[17:40:21.715]                   NAME <- NAMES[[kk]]
[17:40:21.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.715]                     next
[17:40:21.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.715]                 }
[17:40:21.715]                 NAMES <- toupper(added)
[17:40:21.715]                 for (kk in seq_along(NAMES)) {
[17:40:21.715]                   name <- added[[kk]]
[17:40:21.715]                   NAME <- NAMES[[kk]]
[17:40:21.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.715]                     next
[17:40:21.715]                   args[[name]] <- ""
[17:40:21.715]                 }
[17:40:21.715]                 NAMES <- toupper(removed)
[17:40:21.715]                 for (kk in seq_along(NAMES)) {
[17:40:21.715]                   name <- removed[[kk]]
[17:40:21.715]                   NAME <- NAMES[[kk]]
[17:40:21.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:21.715]                     next
[17:40:21.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:21.715]                 }
[17:40:21.715]                 if (length(args) > 0) 
[17:40:21.715]                   base::do.call(base::Sys.setenv, args = args)
[17:40:21.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:21.715]             }
[17:40:21.715]             else {
[17:40:21.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:21.715]             }
[17:40:21.715]             {
[17:40:21.715]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:21.715]                   0L) {
[17:40:21.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:21.715]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:21.715]                   base::options(opts)
[17:40:21.715]                 }
[17:40:21.715]                 {
[17:40:21.715]                   {
[17:40:21.715]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:21.715]                     NULL
[17:40:21.715]                   }
[17:40:21.715]                   options(future.plan = NULL)
[17:40:21.715]                   if (is.na(NA_character_)) 
[17:40:21.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:21.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:21.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:21.715]                     .init = FALSE)
[17:40:21.715]                 }
[17:40:21.715]             }
[17:40:21.715]         }
[17:40:21.715]     })
[17:40:21.715]     if (TRUE) {
[17:40:21.715]         base::sink(type = "output", split = FALSE)
[17:40:21.715]         if (TRUE) {
[17:40:21.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:21.715]         }
[17:40:21.715]         else {
[17:40:21.715]             ...future.result["stdout"] <- base::list(NULL)
[17:40:21.715]         }
[17:40:21.715]         base::close(...future.stdout)
[17:40:21.715]         ...future.stdout <- NULL
[17:40:21.715]     }
[17:40:21.715]     ...future.result$conditions <- ...future.conditions
[17:40:21.715]     ...future.result$finished <- base::Sys.time()
[17:40:21.715]     ...future.result
[17:40:21.715] }
[17:40:21.717] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:40:21.718] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:40:21.718] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:40:21.718] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:40:21.719] MultisessionFuture started
[17:40:21.719] - Launch lazy future ... done
[17:40:21.719] run() for ‘MultisessionFuture’ ... done
[17:40:21.719] result() for ClusterFuture ...
[17:40:21.719] receiveMessageFromWorker() for ClusterFuture ...
[17:40:21.720] - Validating connection of MultisessionFuture
[17:40:21.766] - received message: FutureResult
[17:40:21.766] - Received FutureResult
[17:40:21.766] - Erased future from FutureRegistry
[17:40:21.767] result() for ClusterFuture ...
[17:40:21.767] - result already collected: FutureResult
[17:40:21.767] result() for ClusterFuture ... done
[17:40:21.767] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:21.767] result() for ClusterFuture ... done
[17:40:21.767] result() for ClusterFuture ...
[17:40:21.767] - result already collected: FutureResult
[17:40:21.767] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[17:40:21.768] plan(): Setting new future strategy stack:
[17:40:21.768] List of future strategies:
[17:40:21.768] 1. multisession:
[17:40:21.768]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.768]    - tweaked: FALSE
[17:40:21.768]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.768] 2. multicore:
[17:40:21.768]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:21.768]    - tweaked: FALSE
[17:40:21.768]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.769] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:21.769] multisession:
[17:40:21.769] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:21.769] - tweaked: FALSE
[17:40:21.769] - call: plan(list(a = strategy1, b = strategy2))
[17:40:21.774] getGlobalsAndPackages() ...
[17:40:21.774] Not searching for globals
[17:40:21.774] - globals: [0] <none>
[17:40:21.774] getGlobalsAndPackages() ... DONE
[17:40:21.775] [local output] makeClusterPSOCK() ...
[17:40:21.779] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:21.780] [local output] Base port: 11825
[17:40:21.780] [local output] Getting setup options for 2 cluster nodes ...
[17:40:21.781] [local output]  - Node 1 of 2 ...
[17:40:21.781] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:21.782] [local output] Rscript port: 11825

[17:40:21.783] [local output]  - Node 2 of 2 ...
[17:40:21.783] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:21.784] [local output] Rscript port: 11825

[17:40:21.784] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:21.784] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:21.785] [local output] Setting up PSOCK nodes in parallel
[17:40:21.785] List of 36
[17:40:21.785]  $ worker          : chr "localhost"
[17:40:21.785]   ..- attr(*, "localhost")= logi TRUE
[17:40:21.785]  $ master          : chr "localhost"
[17:40:21.785]  $ port            : int 11825
[17:40:21.785]  $ connectTimeout  : num 120
[17:40:21.785]  $ timeout         : num 2592000
[17:40:21.785]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:21.785]  $ homogeneous     : logi TRUE
[17:40:21.785]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:21.785]  $ rscript_envs    : NULL
[17:40:21.785]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:21.785]  $ rscript_startup : NULL
[17:40:21.785]  $ rscript_sh      : chr "sh"
[17:40:21.785]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:21.785]  $ methods         : logi TRUE
[17:40:21.785]  $ socketOptions   : chr "no-delay"
[17:40:21.785]  $ useXDR          : logi FALSE
[17:40:21.785]  $ outfile         : chr "/dev/null"
[17:40:21.785]  $ renice          : int NA
[17:40:21.785]  $ rshcmd          : NULL
[17:40:21.785]  $ user            : chr(0) 
[17:40:21.785]  $ revtunnel       : logi FALSE
[17:40:21.785]  $ rshlogfile      : NULL
[17:40:21.785]  $ rshopts         : chr(0) 
[17:40:21.785]  $ rank            : int 1
[17:40:21.785]  $ manual          : logi FALSE
[17:40:21.785]  $ dryrun          : logi FALSE
[17:40:21.785]  $ quiet           : logi FALSE
[17:40:21.785]  $ setup_strategy  : chr "parallel"
[17:40:21.785]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:21.785]  $ pidfile         : chr "/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b9197bdf4fec.pid"
[17:40:21.785]  $ rshcmd_label    : NULL
[17:40:21.785]  $ rsh_call        : NULL
[17:40:21.785]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:21.785]  $ localMachine    : logi TRUE
[17:40:21.785]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:21.785]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:21.785]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:21.785]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:21.785]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:21.785]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:21.785]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:21.785]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:21.785]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:21.785]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:21.785]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:21.785]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:21.785]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:21.785]  $ arguments       :List of 28
[17:40:21.785]   ..$ worker          : chr "localhost"
[17:40:21.785]   ..$ master          : NULL
[17:40:21.785]   ..$ port            : int 11825
[17:40:21.785]   ..$ connectTimeout  : num 120
[17:40:21.785]   ..$ timeout         : num 2592000
[17:40:21.785]   ..$ rscript         : NULL
[17:40:21.785]   ..$ homogeneous     : NULL
[17:40:21.785]   ..$ rscript_args    : NULL
[17:40:21.785]   ..$ rscript_envs    : NULL
[17:40:21.785]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:21.785]   ..$ rscript_startup : NULL
[17:40:21.785]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:21.785]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:21.785]   ..$ methods         : logi TRUE
[17:40:21.785]   ..$ socketOptions   : chr "no-delay"
[17:40:21.785]   ..$ useXDR          : logi FALSE
[17:40:21.785]   ..$ outfile         : chr "/dev/null"
[17:40:21.785]   ..$ renice          : int NA
[17:40:21.785]   ..$ rshcmd          : NULL
[17:40:21.785]   ..$ user            : NULL
[17:40:21.785]   ..$ revtunnel       : logi NA
[17:40:21.785]   ..$ rshlogfile      : NULL
[17:40:21.785]   ..$ rshopts         : NULL
[17:40:21.785]   ..$ rank            : int 1
[17:40:21.785]   ..$ manual          : logi FALSE
[17:40:21.785]   ..$ dryrun          : logi FALSE
[17:40:21.785]   ..$ quiet           : logi FALSE
[17:40:21.785]   ..$ setup_strategy  : chr "parallel"
[17:40:21.785]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:21.802] [local output] System call to launch all workers:
[17:40:21.802] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b9197bdf4fec.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11825 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:21.802] [local output] Starting PSOCK main server
[17:40:21.803] [local output] Workers launched
[17:40:21.804] [local output] Waiting for workers to connect back
[17:40:21.804]  - [local output] 0 workers out of 2 ready
[17:40:22.044]  - [local output] 0 workers out of 2 ready
[17:40:22.045]  - [local output] 1 workers out of 2 ready
[17:40:22.051]  - [local output] 1 workers out of 2 ready
[17:40:22.052]  - [local output] 2 workers out of 2 ready
[17:40:22.052] [local output] Launching of workers completed
[17:40:22.052] [local output] Collecting session information from workers
[17:40:22.053] [local output]  - Worker #1 of 2
[17:40:22.053] [local output]  - Worker #2 of 2
[17:40:22.053] [local output] makeClusterPSOCK() ... done
[17:40:22.064] Packages needed by the future expression (n = 0): <none>
[17:40:22.065] Packages needed by future strategies (n = 1): ‘future’
[17:40:22.065] {
[17:40:22.065]     {
[17:40:22.065]         {
[17:40:22.065]             ...future.startTime <- base::Sys.time()
[17:40:22.065]             {
[17:40:22.065]                 {
[17:40:22.065]                   {
[17:40:22.065]                     {
[17:40:22.065]                       {
[17:40:22.065]                         base::local({
[17:40:22.065]                           has_future <- base::requireNamespace("future", 
[17:40:22.065]                             quietly = TRUE)
[17:40:22.065]                           if (has_future) {
[17:40:22.065]                             ns <- base::getNamespace("future")
[17:40:22.065]                             version <- ns[[".package"]][["version"]]
[17:40:22.065]                             if (is.null(version)) 
[17:40:22.065]                               version <- utils::packageVersion("future")
[17:40:22.065]                           }
[17:40:22.065]                           else {
[17:40:22.065]                             version <- NULL
[17:40:22.065]                           }
[17:40:22.065]                           if (!has_future || version < "1.8.0") {
[17:40:22.065]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:22.065]                               "", base::R.version$version.string), 
[17:40:22.065]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:22.065]                                 base::R.version$platform, 8 * 
[17:40:22.065]                                   base::.Machine$sizeof.pointer), 
[17:40:22.065]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:22.065]                                 "release", "version")], collapse = " "), 
[17:40:22.065]                               hostname = base::Sys.info()[["nodename"]])
[17:40:22.065]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:22.065]                               info)
[17:40:22.065]                             info <- base::paste(info, collapse = "; ")
[17:40:22.065]                             if (!has_future) {
[17:40:22.065]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:22.065]                                 info)
[17:40:22.065]                             }
[17:40:22.065]                             else {
[17:40:22.065]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:22.065]                                 info, version)
[17:40:22.065]                             }
[17:40:22.065]                             base::stop(msg)
[17:40:22.065]                           }
[17:40:22.065]                         })
[17:40:22.065]                       }
[17:40:22.065]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:22.065]                       base::options(mc.cores = 1L)
[17:40:22.065]                     }
[17:40:22.065]                     base::local({
[17:40:22.065]                       for (pkg in "future") {
[17:40:22.065]                         base::loadNamespace(pkg)
[17:40:22.065]                         base::library(pkg, character.only = TRUE)
[17:40:22.065]                       }
[17:40:22.065]                     })
[17:40:22.065]                   }
[17:40:22.065]                   ...future.strategy.old <- future::plan("list")
[17:40:22.065]                   options(future.plan = NULL)
[17:40:22.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.065]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:22.065]                     envir = parent.frame()) 
[17:40:22.065]                   {
[17:40:22.065]                     default_workers <- missing(workers)
[17:40:22.065]                     if (is.function(workers)) 
[17:40:22.065]                       workers <- workers()
[17:40:22.065]                     workers <- structure(as.integer(workers), 
[17:40:22.065]                       class = class(workers))
[17:40:22.065]                     stop_if_not(is.finite(workers), workers >= 
[17:40:22.065]                       1L)
[17:40:22.065]                     if ((workers == 1L && !inherits(workers, 
[17:40:22.065]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:22.065]                       if (default_workers) 
[17:40:22.065]                         supportsMulticore(warn = TRUE)
[17:40:22.065]                       return(sequential(..., envir = envir))
[17:40:22.065]                     }
[17:40:22.065]                     oopts <- options(mc.cores = workers)
[17:40:22.065]                     on.exit(options(oopts))
[17:40:22.065]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:22.065]                       envir = envir)
[17:40:22.065]                     if (!future$lazy) 
[17:40:22.065]                       future <- run(future)
[17:40:22.065]                     invisible(future)
[17:40:22.065]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:22.065]                 }
[17:40:22.065]                 ...future.workdir <- getwd()
[17:40:22.065]             }
[17:40:22.065]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:22.065]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:22.065]         }
[17:40:22.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:22.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:22.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:22.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:22.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:22.065]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:22.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:22.065]             base::names(...future.oldOptions))
[17:40:22.065]     }
[17:40:22.065]     if (FALSE) {
[17:40:22.065]     }
[17:40:22.065]     else {
[17:40:22.065]         if (TRUE) {
[17:40:22.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:22.065]                 open = "w")
[17:40:22.065]         }
[17:40:22.065]         else {
[17:40:22.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:22.065]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:22.065]         }
[17:40:22.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:22.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:22.065]             base::sink(type = "output", split = FALSE)
[17:40:22.065]             base::close(...future.stdout)
[17:40:22.065]         }, add = TRUE)
[17:40:22.065]     }
[17:40:22.065]     ...future.frame <- base::sys.nframe()
[17:40:22.065]     ...future.conditions <- base::list()
[17:40:22.065]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:22.065]     if (FALSE) {
[17:40:22.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:22.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:22.065]     }
[17:40:22.065]     ...future.result <- base::tryCatch({
[17:40:22.065]         base::withCallingHandlers({
[17:40:22.065]             ...future.value <- base::withVisible(base::local({
[17:40:22.065]                 ...future.makeSendCondition <- base::local({
[17:40:22.065]                   sendCondition <- NULL
[17:40:22.065]                   function(frame = 1L) {
[17:40:22.065]                     if (is.function(sendCondition)) 
[17:40:22.065]                       return(sendCondition)
[17:40:22.065]                     ns <- getNamespace("parallel")
[17:40:22.065]                     if (exists("sendData", mode = "function", 
[17:40:22.065]                       envir = ns)) {
[17:40:22.065]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:22.065]                         envir = ns)
[17:40:22.065]                       envir <- sys.frame(frame)
[17:40:22.065]                       master <- NULL
[17:40:22.065]                       while (!identical(envir, .GlobalEnv) && 
[17:40:22.065]                         !identical(envir, emptyenv())) {
[17:40:22.065]                         if (exists("master", mode = "list", envir = envir, 
[17:40:22.065]                           inherits = FALSE)) {
[17:40:22.065]                           master <- get("master", mode = "list", 
[17:40:22.065]                             envir = envir, inherits = FALSE)
[17:40:22.065]                           if (inherits(master, c("SOCKnode", 
[17:40:22.065]                             "SOCK0node"))) {
[17:40:22.065]                             sendCondition <<- function(cond) {
[17:40:22.065]                               data <- list(type = "VALUE", value = cond, 
[17:40:22.065]                                 success = TRUE)
[17:40:22.065]                               parallel_sendData(master, data)
[17:40:22.065]                             }
[17:40:22.065]                             return(sendCondition)
[17:40:22.065]                           }
[17:40:22.065]                         }
[17:40:22.065]                         frame <- frame + 1L
[17:40:22.065]                         envir <- sys.frame(frame)
[17:40:22.065]                       }
[17:40:22.065]                     }
[17:40:22.065]                     sendCondition <<- function(cond) NULL
[17:40:22.065]                   }
[17:40:22.065]                 })
[17:40:22.065]                 withCallingHandlers({
[17:40:22.065]                   NA
[17:40:22.065]                 }, immediateCondition = function(cond) {
[17:40:22.065]                   sendCondition <- ...future.makeSendCondition()
[17:40:22.065]                   sendCondition(cond)
[17:40:22.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.065]                   {
[17:40:22.065]                     inherits <- base::inherits
[17:40:22.065]                     invokeRestart <- base::invokeRestart
[17:40:22.065]                     is.null <- base::is.null
[17:40:22.065]                     muffled <- FALSE
[17:40:22.065]                     if (inherits(cond, "message")) {
[17:40:22.065]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:22.065]                       if (muffled) 
[17:40:22.065]                         invokeRestart("muffleMessage")
[17:40:22.065]                     }
[17:40:22.065]                     else if (inherits(cond, "warning")) {
[17:40:22.065]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:22.065]                       if (muffled) 
[17:40:22.065]                         invokeRestart("muffleWarning")
[17:40:22.065]                     }
[17:40:22.065]                     else if (inherits(cond, "condition")) {
[17:40:22.065]                       if (!is.null(pattern)) {
[17:40:22.065]                         computeRestarts <- base::computeRestarts
[17:40:22.065]                         grepl <- base::grepl
[17:40:22.065]                         restarts <- computeRestarts(cond)
[17:40:22.065]                         for (restart in restarts) {
[17:40:22.065]                           name <- restart$name
[17:40:22.065]                           if (is.null(name)) 
[17:40:22.065]                             next
[17:40:22.065]                           if (!grepl(pattern, name)) 
[17:40:22.065]                             next
[17:40:22.065]                           invokeRestart(restart)
[17:40:22.065]                           muffled <- TRUE
[17:40:22.065]                           break
[17:40:22.065]                         }
[17:40:22.065]                       }
[17:40:22.065]                     }
[17:40:22.065]                     invisible(muffled)
[17:40:22.065]                   }
[17:40:22.065]                   muffleCondition(cond)
[17:40:22.065]                 })
[17:40:22.065]             }))
[17:40:22.065]             future::FutureResult(value = ...future.value$value, 
[17:40:22.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.065]                   ...future.rng), globalenv = if (FALSE) 
[17:40:22.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:22.065]                     ...future.globalenv.names))
[17:40:22.065]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:22.065]         }, condition = base::local({
[17:40:22.065]             c <- base::c
[17:40:22.065]             inherits <- base::inherits
[17:40:22.065]             invokeRestart <- base::invokeRestart
[17:40:22.065]             length <- base::length
[17:40:22.065]             list <- base::list
[17:40:22.065]             seq.int <- base::seq.int
[17:40:22.065]             signalCondition <- base::signalCondition
[17:40:22.065]             sys.calls <- base::sys.calls
[17:40:22.065]             `[[` <- base::`[[`
[17:40:22.065]             `+` <- base::`+`
[17:40:22.065]             `<<-` <- base::`<<-`
[17:40:22.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:22.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:22.065]                   3L)]
[17:40:22.065]             }
[17:40:22.065]             function(cond) {
[17:40:22.065]                 is_error <- inherits(cond, "error")
[17:40:22.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:22.065]                   NULL)
[17:40:22.065]                 if (is_error) {
[17:40:22.065]                   sessionInformation <- function() {
[17:40:22.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:22.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:22.065]                       search = base::search(), system = base::Sys.info())
[17:40:22.065]                   }
[17:40:22.065]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:22.065]                     cond$call), session = sessionInformation(), 
[17:40:22.065]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:22.065]                   signalCondition(cond)
[17:40:22.065]                 }
[17:40:22.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:22.065]                 "immediateCondition"))) {
[17:40:22.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:22.065]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:22.065]                   if (TRUE && !signal) {
[17:40:22.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.065]                     {
[17:40:22.065]                       inherits <- base::inherits
[17:40:22.065]                       invokeRestart <- base::invokeRestart
[17:40:22.065]                       is.null <- base::is.null
[17:40:22.065]                       muffled <- FALSE
[17:40:22.065]                       if (inherits(cond, "message")) {
[17:40:22.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.065]                         if (muffled) 
[17:40:22.065]                           invokeRestart("muffleMessage")
[17:40:22.065]                       }
[17:40:22.065]                       else if (inherits(cond, "warning")) {
[17:40:22.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.065]                         if (muffled) 
[17:40:22.065]                           invokeRestart("muffleWarning")
[17:40:22.065]                       }
[17:40:22.065]                       else if (inherits(cond, "condition")) {
[17:40:22.065]                         if (!is.null(pattern)) {
[17:40:22.065]                           computeRestarts <- base::computeRestarts
[17:40:22.065]                           grepl <- base::grepl
[17:40:22.065]                           restarts <- computeRestarts(cond)
[17:40:22.065]                           for (restart in restarts) {
[17:40:22.065]                             name <- restart$name
[17:40:22.065]                             if (is.null(name)) 
[17:40:22.065]                               next
[17:40:22.065]                             if (!grepl(pattern, name)) 
[17:40:22.065]                               next
[17:40:22.065]                             invokeRestart(restart)
[17:40:22.065]                             muffled <- TRUE
[17:40:22.065]                             break
[17:40:22.065]                           }
[17:40:22.065]                         }
[17:40:22.065]                       }
[17:40:22.065]                       invisible(muffled)
[17:40:22.065]                     }
[17:40:22.065]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.065]                   }
[17:40:22.065]                 }
[17:40:22.065]                 else {
[17:40:22.065]                   if (TRUE) {
[17:40:22.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.065]                     {
[17:40:22.065]                       inherits <- base::inherits
[17:40:22.065]                       invokeRestart <- base::invokeRestart
[17:40:22.065]                       is.null <- base::is.null
[17:40:22.065]                       muffled <- FALSE
[17:40:22.065]                       if (inherits(cond, "message")) {
[17:40:22.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.065]                         if (muffled) 
[17:40:22.065]                           invokeRestart("muffleMessage")
[17:40:22.065]                       }
[17:40:22.065]                       else if (inherits(cond, "warning")) {
[17:40:22.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.065]                         if (muffled) 
[17:40:22.065]                           invokeRestart("muffleWarning")
[17:40:22.065]                       }
[17:40:22.065]                       else if (inherits(cond, "condition")) {
[17:40:22.065]                         if (!is.null(pattern)) {
[17:40:22.065]                           computeRestarts <- base::computeRestarts
[17:40:22.065]                           grepl <- base::grepl
[17:40:22.065]                           restarts <- computeRestarts(cond)
[17:40:22.065]                           for (restart in restarts) {
[17:40:22.065]                             name <- restart$name
[17:40:22.065]                             if (is.null(name)) 
[17:40:22.065]                               next
[17:40:22.065]                             if (!grepl(pattern, name)) 
[17:40:22.065]                               next
[17:40:22.065]                             invokeRestart(restart)
[17:40:22.065]                             muffled <- TRUE
[17:40:22.065]                             break
[17:40:22.065]                           }
[17:40:22.065]                         }
[17:40:22.065]                       }
[17:40:22.065]                       invisible(muffled)
[17:40:22.065]                     }
[17:40:22.065]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.065]                   }
[17:40:22.065]                 }
[17:40:22.065]             }
[17:40:22.065]         }))
[17:40:22.065]     }, error = function(ex) {
[17:40:22.065]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:22.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.065]                 ...future.rng), started = ...future.startTime, 
[17:40:22.065]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:22.065]             version = "1.8"), class = "FutureResult")
[17:40:22.065]     }, finally = {
[17:40:22.065]         if (!identical(...future.workdir, getwd())) 
[17:40:22.065]             setwd(...future.workdir)
[17:40:22.065]         {
[17:40:22.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:22.065]                 ...future.oldOptions$nwarnings <- NULL
[17:40:22.065]             }
[17:40:22.065]             base::options(...future.oldOptions)
[17:40:22.065]             if (.Platform$OS.type == "windows") {
[17:40:22.065]                 old_names <- names(...future.oldEnvVars)
[17:40:22.065]                 envs <- base::Sys.getenv()
[17:40:22.065]                 names <- names(envs)
[17:40:22.065]                 common <- intersect(names, old_names)
[17:40:22.065]                 added <- setdiff(names, old_names)
[17:40:22.065]                 removed <- setdiff(old_names, names)
[17:40:22.065]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:22.065]                   envs[common]]
[17:40:22.065]                 NAMES <- toupper(changed)
[17:40:22.065]                 args <- list()
[17:40:22.065]                 for (kk in seq_along(NAMES)) {
[17:40:22.065]                   name <- changed[[kk]]
[17:40:22.065]                   NAME <- NAMES[[kk]]
[17:40:22.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.065]                     next
[17:40:22.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.065]                 }
[17:40:22.065]                 NAMES <- toupper(added)
[17:40:22.065]                 for (kk in seq_along(NAMES)) {
[17:40:22.065]                   name <- added[[kk]]
[17:40:22.065]                   NAME <- NAMES[[kk]]
[17:40:22.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.065]                     next
[17:40:22.065]                   args[[name]] <- ""
[17:40:22.065]                 }
[17:40:22.065]                 NAMES <- toupper(removed)
[17:40:22.065]                 for (kk in seq_along(NAMES)) {
[17:40:22.065]                   name <- removed[[kk]]
[17:40:22.065]                   NAME <- NAMES[[kk]]
[17:40:22.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.065]                     next
[17:40:22.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.065]                 }
[17:40:22.065]                 if (length(args) > 0) 
[17:40:22.065]                   base::do.call(base::Sys.setenv, args = args)
[17:40:22.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:22.065]             }
[17:40:22.065]             else {
[17:40:22.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:22.065]             }
[17:40:22.065]             {
[17:40:22.065]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:22.065]                   0L) {
[17:40:22.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:22.065]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:22.065]                   base::options(opts)
[17:40:22.065]                 }
[17:40:22.065]                 {
[17:40:22.065]                   {
[17:40:22.065]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:22.065]                     NULL
[17:40:22.065]                   }
[17:40:22.065]                   options(future.plan = NULL)
[17:40:22.065]                   if (is.na(NA_character_)) 
[17:40:22.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:22.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:22.065]                     .init = FALSE)
[17:40:22.065]                 }
[17:40:22.065]             }
[17:40:22.065]         }
[17:40:22.065]     })
[17:40:22.065]     if (TRUE) {
[17:40:22.065]         base::sink(type = "output", split = FALSE)
[17:40:22.065]         if (TRUE) {
[17:40:22.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:22.065]         }
[17:40:22.065]         else {
[17:40:22.065]             ...future.result["stdout"] <- base::list(NULL)
[17:40:22.065]         }
[17:40:22.065]         base::close(...future.stdout)
[17:40:22.065]         ...future.stdout <- NULL
[17:40:22.065]     }
[17:40:22.065]     ...future.result$conditions <- ...future.conditions
[17:40:22.065]     ...future.result$finished <- base::Sys.time()
[17:40:22.065]     ...future.result
[17:40:22.065] }
[17:40:22.116] MultisessionFuture started
[17:40:22.116] result() for ClusterFuture ...
[17:40:22.116] receiveMessageFromWorker() for ClusterFuture ...
[17:40:22.117] - Validating connection of MultisessionFuture
[17:40:22.162] - received message: FutureResult
[17:40:22.162] - Received FutureResult
[17:40:22.162] - Erased future from FutureRegistry
[17:40:22.162] result() for ClusterFuture ...
[17:40:22.163] - result already collected: FutureResult
[17:40:22.163] result() for ClusterFuture ... done
[17:40:22.163] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:22.163] result() for ClusterFuture ... done
[17:40:22.163] result() for ClusterFuture ...
[17:40:22.163] - result already collected: FutureResult
[17:40:22.163] result() for ClusterFuture ... done
[17:40:22.163] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:22.167] plan(): nbrOfWorkers() = 2
[17:40:22.167] getGlobalsAndPackages() ...
[17:40:22.167] Searching for globals...
[17:40:22.184] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:22.185] Searching for globals ... DONE
[17:40:22.185] Resolving globals: FALSE
[17:40:22.186] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[17:40:22.186] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:22.186] - globals: [2] ‘nested’, ‘strategy2’
[17:40:22.186] - packages: [1] ‘future’
[17:40:22.186] getGlobalsAndPackages() ... DONE
[17:40:22.187] run() for ‘Future’ ...
[17:40:22.187] - state: ‘created’
[17:40:22.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:22.202] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:22.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:22.202]   - Field: ‘node’
[17:40:22.202]   - Field: ‘label’
[17:40:22.203]   - Field: ‘local’
[17:40:22.203]   - Field: ‘owner’
[17:40:22.203]   - Field: ‘envir’
[17:40:22.203]   - Field: ‘workers’
[17:40:22.203]   - Field: ‘packages’
[17:40:22.203]   - Field: ‘gc’
[17:40:22.203]   - Field: ‘conditions’
[17:40:22.203]   - Field: ‘persistent’
[17:40:22.203]   - Field: ‘expr’
[17:40:22.203]   - Field: ‘uuid’
[17:40:22.203]   - Field: ‘seed’
[17:40:22.203]   - Field: ‘version’
[17:40:22.204]   - Field: ‘result’
[17:40:22.204]   - Field: ‘asynchronous’
[17:40:22.204]   - Field: ‘calls’
[17:40:22.204]   - Field: ‘globals’
[17:40:22.204]   - Field: ‘stdout’
[17:40:22.204]   - Field: ‘earlySignal’
[17:40:22.204]   - Field: ‘lazy’
[17:40:22.204]   - Field: ‘state’
[17:40:22.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:22.204] - Launch lazy future ...
[17:40:22.205] Packages needed by the future expression (n = 1): ‘future’
[17:40:22.205] Packages needed by future strategies (n = 1): ‘future’
[17:40:22.205] {
[17:40:22.205]     {
[17:40:22.205]         {
[17:40:22.205]             ...future.startTime <- base::Sys.time()
[17:40:22.205]             {
[17:40:22.205]                 {
[17:40:22.205]                   {
[17:40:22.205]                     {
[17:40:22.205]                       {
[17:40:22.205]                         base::local({
[17:40:22.205]                           has_future <- base::requireNamespace("future", 
[17:40:22.205]                             quietly = TRUE)
[17:40:22.205]                           if (has_future) {
[17:40:22.205]                             ns <- base::getNamespace("future")
[17:40:22.205]                             version <- ns[[".package"]][["version"]]
[17:40:22.205]                             if (is.null(version)) 
[17:40:22.205]                               version <- utils::packageVersion("future")
[17:40:22.205]                           }
[17:40:22.205]                           else {
[17:40:22.205]                             version <- NULL
[17:40:22.205]                           }
[17:40:22.205]                           if (!has_future || version < "1.8.0") {
[17:40:22.205]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:22.205]                               "", base::R.version$version.string), 
[17:40:22.205]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:22.205]                                 base::R.version$platform, 8 * 
[17:40:22.205]                                   base::.Machine$sizeof.pointer), 
[17:40:22.205]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:22.205]                                 "release", "version")], collapse = " "), 
[17:40:22.205]                               hostname = base::Sys.info()[["nodename"]])
[17:40:22.205]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:22.205]                               info)
[17:40:22.205]                             info <- base::paste(info, collapse = "; ")
[17:40:22.205]                             if (!has_future) {
[17:40:22.205]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:22.205]                                 info)
[17:40:22.205]                             }
[17:40:22.205]                             else {
[17:40:22.205]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:22.205]                                 info, version)
[17:40:22.205]                             }
[17:40:22.205]                             base::stop(msg)
[17:40:22.205]                           }
[17:40:22.205]                         })
[17:40:22.205]                       }
[17:40:22.205]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:22.205]                       base::options(mc.cores = 1L)
[17:40:22.205]                     }
[17:40:22.205]                     base::local({
[17:40:22.205]                       for (pkg in "future") {
[17:40:22.205]                         base::loadNamespace(pkg)
[17:40:22.205]                         base::library(pkg, character.only = TRUE)
[17:40:22.205]                       }
[17:40:22.205]                     })
[17:40:22.205]                   }
[17:40:22.205]                   ...future.strategy.old <- future::plan("list")
[17:40:22.205]                   options(future.plan = NULL)
[17:40:22.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.205]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:22.205]                     envir = parent.frame()) 
[17:40:22.205]                   {
[17:40:22.205]                     default_workers <- missing(workers)
[17:40:22.205]                     if (is.function(workers)) 
[17:40:22.205]                       workers <- workers()
[17:40:22.205]                     workers <- structure(as.integer(workers), 
[17:40:22.205]                       class = class(workers))
[17:40:22.205]                     stop_if_not(is.finite(workers), workers >= 
[17:40:22.205]                       1L)
[17:40:22.205]                     if ((workers == 1L && !inherits(workers, 
[17:40:22.205]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:22.205]                       if (default_workers) 
[17:40:22.205]                         supportsMulticore(warn = TRUE)
[17:40:22.205]                       return(sequential(..., envir = envir))
[17:40:22.205]                     }
[17:40:22.205]                     oopts <- options(mc.cores = workers)
[17:40:22.205]                     on.exit(options(oopts))
[17:40:22.205]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:22.205]                       envir = envir)
[17:40:22.205]                     if (!future$lazy) 
[17:40:22.205]                       future <- run(future)
[17:40:22.205]                     invisible(future)
[17:40:22.205]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:22.205]                 }
[17:40:22.205]                 ...future.workdir <- getwd()
[17:40:22.205]             }
[17:40:22.205]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:22.205]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:22.205]         }
[17:40:22.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:22.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:22.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:22.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:22.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:22.205]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:22.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:22.205]             base::names(...future.oldOptions))
[17:40:22.205]     }
[17:40:22.205]     if (FALSE) {
[17:40:22.205]     }
[17:40:22.205]     else {
[17:40:22.205]         if (TRUE) {
[17:40:22.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:22.205]                 open = "w")
[17:40:22.205]         }
[17:40:22.205]         else {
[17:40:22.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:22.205]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:22.205]         }
[17:40:22.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:22.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:22.205]             base::sink(type = "output", split = FALSE)
[17:40:22.205]             base::close(...future.stdout)
[17:40:22.205]         }, add = TRUE)
[17:40:22.205]     }
[17:40:22.205]     ...future.frame <- base::sys.nframe()
[17:40:22.205]     ...future.conditions <- base::list()
[17:40:22.205]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:22.205]     if (FALSE) {
[17:40:22.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:22.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:22.205]     }
[17:40:22.205]     ...future.result <- base::tryCatch({
[17:40:22.205]         base::withCallingHandlers({
[17:40:22.205]             ...future.value <- base::withVisible(base::local({
[17:40:22.205]                 ...future.makeSendCondition <- base::local({
[17:40:22.205]                   sendCondition <- NULL
[17:40:22.205]                   function(frame = 1L) {
[17:40:22.205]                     if (is.function(sendCondition)) 
[17:40:22.205]                       return(sendCondition)
[17:40:22.205]                     ns <- getNamespace("parallel")
[17:40:22.205]                     if (exists("sendData", mode = "function", 
[17:40:22.205]                       envir = ns)) {
[17:40:22.205]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:22.205]                         envir = ns)
[17:40:22.205]                       envir <- sys.frame(frame)
[17:40:22.205]                       master <- NULL
[17:40:22.205]                       while (!identical(envir, .GlobalEnv) && 
[17:40:22.205]                         !identical(envir, emptyenv())) {
[17:40:22.205]                         if (exists("master", mode = "list", envir = envir, 
[17:40:22.205]                           inherits = FALSE)) {
[17:40:22.205]                           master <- get("master", mode = "list", 
[17:40:22.205]                             envir = envir, inherits = FALSE)
[17:40:22.205]                           if (inherits(master, c("SOCKnode", 
[17:40:22.205]                             "SOCK0node"))) {
[17:40:22.205]                             sendCondition <<- function(cond) {
[17:40:22.205]                               data <- list(type = "VALUE", value = cond, 
[17:40:22.205]                                 success = TRUE)
[17:40:22.205]                               parallel_sendData(master, data)
[17:40:22.205]                             }
[17:40:22.205]                             return(sendCondition)
[17:40:22.205]                           }
[17:40:22.205]                         }
[17:40:22.205]                         frame <- frame + 1L
[17:40:22.205]                         envir <- sys.frame(frame)
[17:40:22.205]                       }
[17:40:22.205]                     }
[17:40:22.205]                     sendCondition <<- function(cond) NULL
[17:40:22.205]                   }
[17:40:22.205]                 })
[17:40:22.205]                 withCallingHandlers({
[17:40:22.205]                   {
[17:40:22.205]                     a <- 1L
[17:40:22.205]                     plan_a <- unclass(future::plan("list"))
[17:40:22.205]                     nested_a <- nested[-1]
[17:40:22.205]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:22.205]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:22.205]                       strategy2))
[17:40:22.205]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:22.205]                       "init") <- NULL
[17:40:22.205]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:22.205]                       "init") <- NULL
[17:40:22.205]                     stopifnot(all.equal(plan_a, nested_a))
[17:40:22.205]                     y %<-% {
[17:40:22.205]                       b <- 2L
[17:40:22.205]                       plan_b <- future::plan("list")
[17:40:22.205]                       nested_b <- nested_a[-1]
[17:40:22.205]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:22.205]                         1L, inherits(plan_b[[1]], "future"), 
[17:40:22.205]                         inherits(future::plan("next"), "sequential"))
[17:40:22.205]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:22.205]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:22.205]                     }
[17:40:22.205]                     y
[17:40:22.205]                   }
[17:40:22.205]                 }, immediateCondition = function(cond) {
[17:40:22.205]                   sendCondition <- ...future.makeSendCondition()
[17:40:22.205]                   sendCondition(cond)
[17:40:22.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.205]                   {
[17:40:22.205]                     inherits <- base::inherits
[17:40:22.205]                     invokeRestart <- base::invokeRestart
[17:40:22.205]                     is.null <- base::is.null
[17:40:22.205]                     muffled <- FALSE
[17:40:22.205]                     if (inherits(cond, "message")) {
[17:40:22.205]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:22.205]                       if (muffled) 
[17:40:22.205]                         invokeRestart("muffleMessage")
[17:40:22.205]                     }
[17:40:22.205]                     else if (inherits(cond, "warning")) {
[17:40:22.205]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:22.205]                       if (muffled) 
[17:40:22.205]                         invokeRestart("muffleWarning")
[17:40:22.205]                     }
[17:40:22.205]                     else if (inherits(cond, "condition")) {
[17:40:22.205]                       if (!is.null(pattern)) {
[17:40:22.205]                         computeRestarts <- base::computeRestarts
[17:40:22.205]                         grepl <- base::grepl
[17:40:22.205]                         restarts <- computeRestarts(cond)
[17:40:22.205]                         for (restart in restarts) {
[17:40:22.205]                           name <- restart$name
[17:40:22.205]                           if (is.null(name)) 
[17:40:22.205]                             next
[17:40:22.205]                           if (!grepl(pattern, name)) 
[17:40:22.205]                             next
[17:40:22.205]                           invokeRestart(restart)
[17:40:22.205]                           muffled <- TRUE
[17:40:22.205]                           break
[17:40:22.205]                         }
[17:40:22.205]                       }
[17:40:22.205]                     }
[17:40:22.205]                     invisible(muffled)
[17:40:22.205]                   }
[17:40:22.205]                   muffleCondition(cond)
[17:40:22.205]                 })
[17:40:22.205]             }))
[17:40:22.205]             future::FutureResult(value = ...future.value$value, 
[17:40:22.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.205]                   ...future.rng), globalenv = if (FALSE) 
[17:40:22.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:22.205]                     ...future.globalenv.names))
[17:40:22.205]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:22.205]         }, condition = base::local({
[17:40:22.205]             c <- base::c
[17:40:22.205]             inherits <- base::inherits
[17:40:22.205]             invokeRestart <- base::invokeRestart
[17:40:22.205]             length <- base::length
[17:40:22.205]             list <- base::list
[17:40:22.205]             seq.int <- base::seq.int
[17:40:22.205]             signalCondition <- base::signalCondition
[17:40:22.205]             sys.calls <- base::sys.calls
[17:40:22.205]             `[[` <- base::`[[`
[17:40:22.205]             `+` <- base::`+`
[17:40:22.205]             `<<-` <- base::`<<-`
[17:40:22.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:22.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:22.205]                   3L)]
[17:40:22.205]             }
[17:40:22.205]             function(cond) {
[17:40:22.205]                 is_error <- inherits(cond, "error")
[17:40:22.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:22.205]                   NULL)
[17:40:22.205]                 if (is_error) {
[17:40:22.205]                   sessionInformation <- function() {
[17:40:22.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:22.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:22.205]                       search = base::search(), system = base::Sys.info())
[17:40:22.205]                   }
[17:40:22.205]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:22.205]                     cond$call), session = sessionInformation(), 
[17:40:22.205]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:22.205]                   signalCondition(cond)
[17:40:22.205]                 }
[17:40:22.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:22.205]                 "immediateCondition"))) {
[17:40:22.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:22.205]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:22.205]                   if (TRUE && !signal) {
[17:40:22.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.205]                     {
[17:40:22.205]                       inherits <- base::inherits
[17:40:22.205]                       invokeRestart <- base::invokeRestart
[17:40:22.205]                       is.null <- base::is.null
[17:40:22.205]                       muffled <- FALSE
[17:40:22.205]                       if (inherits(cond, "message")) {
[17:40:22.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.205]                         if (muffled) 
[17:40:22.205]                           invokeRestart("muffleMessage")
[17:40:22.205]                       }
[17:40:22.205]                       else if (inherits(cond, "warning")) {
[17:40:22.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.205]                         if (muffled) 
[17:40:22.205]                           invokeRestart("muffleWarning")
[17:40:22.205]                       }
[17:40:22.205]                       else if (inherits(cond, "condition")) {
[17:40:22.205]                         if (!is.null(pattern)) {
[17:40:22.205]                           computeRestarts <- base::computeRestarts
[17:40:22.205]                           grepl <- base::grepl
[17:40:22.205]                           restarts <- computeRestarts(cond)
[17:40:22.205]                           for (restart in restarts) {
[17:40:22.205]                             name <- restart$name
[17:40:22.205]                             if (is.null(name)) 
[17:40:22.205]                               next
[17:40:22.205]                             if (!grepl(pattern, name)) 
[17:40:22.205]                               next
[17:40:22.205]                             invokeRestart(restart)
[17:40:22.205]                             muffled <- TRUE
[17:40:22.205]                             break
[17:40:22.205]                           }
[17:40:22.205]                         }
[17:40:22.205]                       }
[17:40:22.205]                       invisible(muffled)
[17:40:22.205]                     }
[17:40:22.205]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.205]                   }
[17:40:22.205]                 }
[17:40:22.205]                 else {
[17:40:22.205]                   if (TRUE) {
[17:40:22.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.205]                     {
[17:40:22.205]                       inherits <- base::inherits
[17:40:22.205]                       invokeRestart <- base::invokeRestart
[17:40:22.205]                       is.null <- base::is.null
[17:40:22.205]                       muffled <- FALSE
[17:40:22.205]                       if (inherits(cond, "message")) {
[17:40:22.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.205]                         if (muffled) 
[17:40:22.205]                           invokeRestart("muffleMessage")
[17:40:22.205]                       }
[17:40:22.205]                       else if (inherits(cond, "warning")) {
[17:40:22.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.205]                         if (muffled) 
[17:40:22.205]                           invokeRestart("muffleWarning")
[17:40:22.205]                       }
[17:40:22.205]                       else if (inherits(cond, "condition")) {
[17:40:22.205]                         if (!is.null(pattern)) {
[17:40:22.205]                           computeRestarts <- base::computeRestarts
[17:40:22.205]                           grepl <- base::grepl
[17:40:22.205]                           restarts <- computeRestarts(cond)
[17:40:22.205]                           for (restart in restarts) {
[17:40:22.205]                             name <- restart$name
[17:40:22.205]                             if (is.null(name)) 
[17:40:22.205]                               next
[17:40:22.205]                             if (!grepl(pattern, name)) 
[17:40:22.205]                               next
[17:40:22.205]                             invokeRestart(restart)
[17:40:22.205]                             muffled <- TRUE
[17:40:22.205]                             break
[17:40:22.205]                           }
[17:40:22.205]                         }
[17:40:22.205]                       }
[17:40:22.205]                       invisible(muffled)
[17:40:22.205]                     }
[17:40:22.205]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.205]                   }
[17:40:22.205]                 }
[17:40:22.205]             }
[17:40:22.205]         }))
[17:40:22.205]     }, error = function(ex) {
[17:40:22.205]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:22.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.205]                 ...future.rng), started = ...future.startTime, 
[17:40:22.205]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:22.205]             version = "1.8"), class = "FutureResult")
[17:40:22.205]     }, finally = {
[17:40:22.205]         if (!identical(...future.workdir, getwd())) 
[17:40:22.205]             setwd(...future.workdir)
[17:40:22.205]         {
[17:40:22.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:22.205]                 ...future.oldOptions$nwarnings <- NULL
[17:40:22.205]             }
[17:40:22.205]             base::options(...future.oldOptions)
[17:40:22.205]             if (.Platform$OS.type == "windows") {
[17:40:22.205]                 old_names <- names(...future.oldEnvVars)
[17:40:22.205]                 envs <- base::Sys.getenv()
[17:40:22.205]                 names <- names(envs)
[17:40:22.205]                 common <- intersect(names, old_names)
[17:40:22.205]                 added <- setdiff(names, old_names)
[17:40:22.205]                 removed <- setdiff(old_names, names)
[17:40:22.205]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:22.205]                   envs[common]]
[17:40:22.205]                 NAMES <- toupper(changed)
[17:40:22.205]                 args <- list()
[17:40:22.205]                 for (kk in seq_along(NAMES)) {
[17:40:22.205]                   name <- changed[[kk]]
[17:40:22.205]                   NAME <- NAMES[[kk]]
[17:40:22.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.205]                     next
[17:40:22.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.205]                 }
[17:40:22.205]                 NAMES <- toupper(added)
[17:40:22.205]                 for (kk in seq_along(NAMES)) {
[17:40:22.205]                   name <- added[[kk]]
[17:40:22.205]                   NAME <- NAMES[[kk]]
[17:40:22.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.205]                     next
[17:40:22.205]                   args[[name]] <- ""
[17:40:22.205]                 }
[17:40:22.205]                 NAMES <- toupper(removed)
[17:40:22.205]                 for (kk in seq_along(NAMES)) {
[17:40:22.205]                   name <- removed[[kk]]
[17:40:22.205]                   NAME <- NAMES[[kk]]
[17:40:22.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.205]                     next
[17:40:22.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.205]                 }
[17:40:22.205]                 if (length(args) > 0) 
[17:40:22.205]                   base::do.call(base::Sys.setenv, args = args)
[17:40:22.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:22.205]             }
[17:40:22.205]             else {
[17:40:22.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:22.205]             }
[17:40:22.205]             {
[17:40:22.205]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:22.205]                   0L) {
[17:40:22.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:22.205]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:22.205]                   base::options(opts)
[17:40:22.205]                 }
[17:40:22.205]                 {
[17:40:22.205]                   {
[17:40:22.205]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:22.205]                     NULL
[17:40:22.205]                   }
[17:40:22.205]                   options(future.plan = NULL)
[17:40:22.205]                   if (is.na(NA_character_)) 
[17:40:22.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:22.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:22.205]                     .init = FALSE)
[17:40:22.205]                 }
[17:40:22.205]             }
[17:40:22.205]         }
[17:40:22.205]     })
[17:40:22.205]     if (TRUE) {
[17:40:22.205]         base::sink(type = "output", split = FALSE)
[17:40:22.205]         if (TRUE) {
[17:40:22.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:22.205]         }
[17:40:22.205]         else {
[17:40:22.205]             ...future.result["stdout"] <- base::list(NULL)
[17:40:22.205]         }
[17:40:22.205]         base::close(...future.stdout)
[17:40:22.205]         ...future.stdout <- NULL
[17:40:22.205]     }
[17:40:22.205]     ...future.result$conditions <- ...future.conditions
[17:40:22.205]     ...future.result$finished <- base::Sys.time()
[17:40:22.205]     ...future.result
[17:40:22.205] }
[17:40:22.209] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[17:40:22.209] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[17:40:22.253] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[17:40:22.253] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:40:22.253] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:40:22.253] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[17:40:22.254] MultisessionFuture started
[17:40:22.254] - Launch lazy future ... done
[17:40:22.254] run() for ‘MultisessionFuture’ ... done
[17:40:22.255] result() for ClusterFuture ...
[17:40:22.255] receiveMessageFromWorker() for ClusterFuture ...
[17:40:22.255] - Validating connection of MultisessionFuture
[17:40:22.326] - received message: FutureResult
[17:40:22.326] - Received FutureResult
[17:40:22.327] - Erased future from FutureRegistry
[17:40:22.327] result() for ClusterFuture ...
[17:40:22.327] - result already collected: FutureResult
[17:40:22.327] result() for ClusterFuture ... done
[17:40:22.327] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:22.327] result() for ClusterFuture ... done
[17:40:22.327] result() for ClusterFuture ...
[17:40:22.327] - result already collected: FutureResult
[17:40:22.327] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:22.332] getGlobalsAndPackages() ...
[17:40:22.333] Searching for globals...
[17:40:22.334] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:22.334] Searching for globals ... DONE
[17:40:22.334] Resolving globals: FALSE
[17:40:22.335] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:22.335] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:22.335] - globals: [1] ‘data’
[17:40:22.335] - packages: [1] ‘future’
[17:40:22.335] getGlobalsAndPackages() ... DONE
[17:40:22.336] run() for ‘Future’ ...
[17:40:22.336] - state: ‘created’
[17:40:22.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:22.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:22.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:22.350]   - Field: ‘node’
[17:40:22.350]   - Field: ‘label’
[17:40:22.350]   - Field: ‘local’
[17:40:22.350]   - Field: ‘owner’
[17:40:22.350]   - Field: ‘envir’
[17:40:22.350]   - Field: ‘workers’
[17:40:22.350]   - Field: ‘packages’
[17:40:22.350]   - Field: ‘gc’
[17:40:22.350]   - Field: ‘conditions’
[17:40:22.350]   - Field: ‘persistent’
[17:40:22.351]   - Field: ‘expr’
[17:40:22.351]   - Field: ‘uuid’
[17:40:22.351]   - Field: ‘seed’
[17:40:22.351]   - Field: ‘version’
[17:40:22.351]   - Field: ‘result’
[17:40:22.351]   - Field: ‘asynchronous’
[17:40:22.351]   - Field: ‘calls’
[17:40:22.351]   - Field: ‘globals’
[17:40:22.351]   - Field: ‘stdout’
[17:40:22.351]   - Field: ‘earlySignal’
[17:40:22.351]   - Field: ‘lazy’
[17:40:22.352]   - Field: ‘state’
[17:40:22.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:22.352] - Launch lazy future ...
[17:40:22.352] Packages needed by the future expression (n = 1): ‘future’
[17:40:22.352] Packages needed by future strategies (n = 1): ‘future’
[17:40:22.353] {
[17:40:22.353]     {
[17:40:22.353]         {
[17:40:22.353]             ...future.startTime <- base::Sys.time()
[17:40:22.353]             {
[17:40:22.353]                 {
[17:40:22.353]                   {
[17:40:22.353]                     {
[17:40:22.353]                       {
[17:40:22.353]                         base::local({
[17:40:22.353]                           has_future <- base::requireNamespace("future", 
[17:40:22.353]                             quietly = TRUE)
[17:40:22.353]                           if (has_future) {
[17:40:22.353]                             ns <- base::getNamespace("future")
[17:40:22.353]                             version <- ns[[".package"]][["version"]]
[17:40:22.353]                             if (is.null(version)) 
[17:40:22.353]                               version <- utils::packageVersion("future")
[17:40:22.353]                           }
[17:40:22.353]                           else {
[17:40:22.353]                             version <- NULL
[17:40:22.353]                           }
[17:40:22.353]                           if (!has_future || version < "1.8.0") {
[17:40:22.353]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:22.353]                               "", base::R.version$version.string), 
[17:40:22.353]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:22.353]                                 base::R.version$platform, 8 * 
[17:40:22.353]                                   base::.Machine$sizeof.pointer), 
[17:40:22.353]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:22.353]                                 "release", "version")], collapse = " "), 
[17:40:22.353]                               hostname = base::Sys.info()[["nodename"]])
[17:40:22.353]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:22.353]                               info)
[17:40:22.353]                             info <- base::paste(info, collapse = "; ")
[17:40:22.353]                             if (!has_future) {
[17:40:22.353]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:22.353]                                 info)
[17:40:22.353]                             }
[17:40:22.353]                             else {
[17:40:22.353]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:22.353]                                 info, version)
[17:40:22.353]                             }
[17:40:22.353]                             base::stop(msg)
[17:40:22.353]                           }
[17:40:22.353]                         })
[17:40:22.353]                       }
[17:40:22.353]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:22.353]                       base::options(mc.cores = 1L)
[17:40:22.353]                     }
[17:40:22.353]                     base::local({
[17:40:22.353]                       for (pkg in "future") {
[17:40:22.353]                         base::loadNamespace(pkg)
[17:40:22.353]                         base::library(pkg, character.only = TRUE)
[17:40:22.353]                       }
[17:40:22.353]                     })
[17:40:22.353]                   }
[17:40:22.353]                   ...future.strategy.old <- future::plan("list")
[17:40:22.353]                   options(future.plan = NULL)
[17:40:22.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.353]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[17:40:22.353]                     envir = parent.frame()) 
[17:40:22.353]                   {
[17:40:22.353]                     default_workers <- missing(workers)
[17:40:22.353]                     if (is.function(workers)) 
[17:40:22.353]                       workers <- workers()
[17:40:22.353]                     workers <- structure(as.integer(workers), 
[17:40:22.353]                       class = class(workers))
[17:40:22.353]                     stop_if_not(is.finite(workers), workers >= 
[17:40:22.353]                       1L)
[17:40:22.353]                     if ((workers == 1L && !inherits(workers, 
[17:40:22.353]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:40:22.353]                       if (default_workers) 
[17:40:22.353]                         supportsMulticore(warn = TRUE)
[17:40:22.353]                       return(sequential(..., envir = envir))
[17:40:22.353]                     }
[17:40:22.353]                     oopts <- options(mc.cores = workers)
[17:40:22.353]                     on.exit(options(oopts))
[17:40:22.353]                     future <- MulticoreFuture(..., workers = workers, 
[17:40:22.353]                       envir = envir)
[17:40:22.353]                     if (!future$lazy) 
[17:40:22.353]                       future <- run(future)
[17:40:22.353]                     invisible(future)
[17:40:22.353]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:22.353]                 }
[17:40:22.353]                 ...future.workdir <- getwd()
[17:40:22.353]             }
[17:40:22.353]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:22.353]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:22.353]         }
[17:40:22.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:22.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:22.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:22.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:22.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:22.353]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:22.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:22.353]             base::names(...future.oldOptions))
[17:40:22.353]     }
[17:40:22.353]     if (FALSE) {
[17:40:22.353]     }
[17:40:22.353]     else {
[17:40:22.353]         if (TRUE) {
[17:40:22.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:22.353]                 open = "w")
[17:40:22.353]         }
[17:40:22.353]         else {
[17:40:22.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:22.353]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:22.353]         }
[17:40:22.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:22.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:22.353]             base::sink(type = "output", split = FALSE)
[17:40:22.353]             base::close(...future.stdout)
[17:40:22.353]         }, add = TRUE)
[17:40:22.353]     }
[17:40:22.353]     ...future.frame <- base::sys.nframe()
[17:40:22.353]     ...future.conditions <- base::list()
[17:40:22.353]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:22.353]     if (FALSE) {
[17:40:22.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:22.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:22.353]     }
[17:40:22.353]     ...future.result <- base::tryCatch({
[17:40:22.353]         base::withCallingHandlers({
[17:40:22.353]             ...future.value <- base::withVisible(base::local({
[17:40:22.353]                 ...future.makeSendCondition <- base::local({
[17:40:22.353]                   sendCondition <- NULL
[17:40:22.353]                   function(frame = 1L) {
[17:40:22.353]                     if (is.function(sendCondition)) 
[17:40:22.353]                       return(sendCondition)
[17:40:22.353]                     ns <- getNamespace("parallel")
[17:40:22.353]                     if (exists("sendData", mode = "function", 
[17:40:22.353]                       envir = ns)) {
[17:40:22.353]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:22.353]                         envir = ns)
[17:40:22.353]                       envir <- sys.frame(frame)
[17:40:22.353]                       master <- NULL
[17:40:22.353]                       while (!identical(envir, .GlobalEnv) && 
[17:40:22.353]                         !identical(envir, emptyenv())) {
[17:40:22.353]                         if (exists("master", mode = "list", envir = envir, 
[17:40:22.353]                           inherits = FALSE)) {
[17:40:22.353]                           master <- get("master", mode = "list", 
[17:40:22.353]                             envir = envir, inherits = FALSE)
[17:40:22.353]                           if (inherits(master, c("SOCKnode", 
[17:40:22.353]                             "SOCK0node"))) {
[17:40:22.353]                             sendCondition <<- function(cond) {
[17:40:22.353]                               data <- list(type = "VALUE", value = cond, 
[17:40:22.353]                                 success = TRUE)
[17:40:22.353]                               parallel_sendData(master, data)
[17:40:22.353]                             }
[17:40:22.353]                             return(sendCondition)
[17:40:22.353]                           }
[17:40:22.353]                         }
[17:40:22.353]                         frame <- frame + 1L
[17:40:22.353]                         envir <- sys.frame(frame)
[17:40:22.353]                       }
[17:40:22.353]                     }
[17:40:22.353]                     sendCondition <<- function(cond) NULL
[17:40:22.353]                   }
[17:40:22.353]                 })
[17:40:22.353]                 withCallingHandlers({
[17:40:22.353]                   {
[17:40:22.353]                     value(future(subset(data, a == 2)))
[17:40:22.353]                   }
[17:40:22.353]                 }, immediateCondition = function(cond) {
[17:40:22.353]                   sendCondition <- ...future.makeSendCondition()
[17:40:22.353]                   sendCondition(cond)
[17:40:22.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.353]                   {
[17:40:22.353]                     inherits <- base::inherits
[17:40:22.353]                     invokeRestart <- base::invokeRestart
[17:40:22.353]                     is.null <- base::is.null
[17:40:22.353]                     muffled <- FALSE
[17:40:22.353]                     if (inherits(cond, "message")) {
[17:40:22.353]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:22.353]                       if (muffled) 
[17:40:22.353]                         invokeRestart("muffleMessage")
[17:40:22.353]                     }
[17:40:22.353]                     else if (inherits(cond, "warning")) {
[17:40:22.353]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:22.353]                       if (muffled) 
[17:40:22.353]                         invokeRestart("muffleWarning")
[17:40:22.353]                     }
[17:40:22.353]                     else if (inherits(cond, "condition")) {
[17:40:22.353]                       if (!is.null(pattern)) {
[17:40:22.353]                         computeRestarts <- base::computeRestarts
[17:40:22.353]                         grepl <- base::grepl
[17:40:22.353]                         restarts <- computeRestarts(cond)
[17:40:22.353]                         for (restart in restarts) {
[17:40:22.353]                           name <- restart$name
[17:40:22.353]                           if (is.null(name)) 
[17:40:22.353]                             next
[17:40:22.353]                           if (!grepl(pattern, name)) 
[17:40:22.353]                             next
[17:40:22.353]                           invokeRestart(restart)
[17:40:22.353]                           muffled <- TRUE
[17:40:22.353]                           break
[17:40:22.353]                         }
[17:40:22.353]                       }
[17:40:22.353]                     }
[17:40:22.353]                     invisible(muffled)
[17:40:22.353]                   }
[17:40:22.353]                   muffleCondition(cond)
[17:40:22.353]                 })
[17:40:22.353]             }))
[17:40:22.353]             future::FutureResult(value = ...future.value$value, 
[17:40:22.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.353]                   ...future.rng), globalenv = if (FALSE) 
[17:40:22.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:22.353]                     ...future.globalenv.names))
[17:40:22.353]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:22.353]         }, condition = base::local({
[17:40:22.353]             c <- base::c
[17:40:22.353]             inherits <- base::inherits
[17:40:22.353]             invokeRestart <- base::invokeRestart
[17:40:22.353]             length <- base::length
[17:40:22.353]             list <- base::list
[17:40:22.353]             seq.int <- base::seq.int
[17:40:22.353]             signalCondition <- base::signalCondition
[17:40:22.353]             sys.calls <- base::sys.calls
[17:40:22.353]             `[[` <- base::`[[`
[17:40:22.353]             `+` <- base::`+`
[17:40:22.353]             `<<-` <- base::`<<-`
[17:40:22.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:22.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:22.353]                   3L)]
[17:40:22.353]             }
[17:40:22.353]             function(cond) {
[17:40:22.353]                 is_error <- inherits(cond, "error")
[17:40:22.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:22.353]                   NULL)
[17:40:22.353]                 if (is_error) {
[17:40:22.353]                   sessionInformation <- function() {
[17:40:22.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:22.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:22.353]                       search = base::search(), system = base::Sys.info())
[17:40:22.353]                   }
[17:40:22.353]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:22.353]                     cond$call), session = sessionInformation(), 
[17:40:22.353]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:22.353]                   signalCondition(cond)
[17:40:22.353]                 }
[17:40:22.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:22.353]                 "immediateCondition"))) {
[17:40:22.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:22.353]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:22.353]                   if (TRUE && !signal) {
[17:40:22.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.353]                     {
[17:40:22.353]                       inherits <- base::inherits
[17:40:22.353]                       invokeRestart <- base::invokeRestart
[17:40:22.353]                       is.null <- base::is.null
[17:40:22.353]                       muffled <- FALSE
[17:40:22.353]                       if (inherits(cond, "message")) {
[17:40:22.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.353]                         if (muffled) 
[17:40:22.353]                           invokeRestart("muffleMessage")
[17:40:22.353]                       }
[17:40:22.353]                       else if (inherits(cond, "warning")) {
[17:40:22.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.353]                         if (muffled) 
[17:40:22.353]                           invokeRestart("muffleWarning")
[17:40:22.353]                       }
[17:40:22.353]                       else if (inherits(cond, "condition")) {
[17:40:22.353]                         if (!is.null(pattern)) {
[17:40:22.353]                           computeRestarts <- base::computeRestarts
[17:40:22.353]                           grepl <- base::grepl
[17:40:22.353]                           restarts <- computeRestarts(cond)
[17:40:22.353]                           for (restart in restarts) {
[17:40:22.353]                             name <- restart$name
[17:40:22.353]                             if (is.null(name)) 
[17:40:22.353]                               next
[17:40:22.353]                             if (!grepl(pattern, name)) 
[17:40:22.353]                               next
[17:40:22.353]                             invokeRestart(restart)
[17:40:22.353]                             muffled <- TRUE
[17:40:22.353]                             break
[17:40:22.353]                           }
[17:40:22.353]                         }
[17:40:22.353]                       }
[17:40:22.353]                       invisible(muffled)
[17:40:22.353]                     }
[17:40:22.353]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.353]                   }
[17:40:22.353]                 }
[17:40:22.353]                 else {
[17:40:22.353]                   if (TRUE) {
[17:40:22.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.353]                     {
[17:40:22.353]                       inherits <- base::inherits
[17:40:22.353]                       invokeRestart <- base::invokeRestart
[17:40:22.353]                       is.null <- base::is.null
[17:40:22.353]                       muffled <- FALSE
[17:40:22.353]                       if (inherits(cond, "message")) {
[17:40:22.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.353]                         if (muffled) 
[17:40:22.353]                           invokeRestart("muffleMessage")
[17:40:22.353]                       }
[17:40:22.353]                       else if (inherits(cond, "warning")) {
[17:40:22.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.353]                         if (muffled) 
[17:40:22.353]                           invokeRestart("muffleWarning")
[17:40:22.353]                       }
[17:40:22.353]                       else if (inherits(cond, "condition")) {
[17:40:22.353]                         if (!is.null(pattern)) {
[17:40:22.353]                           computeRestarts <- base::computeRestarts
[17:40:22.353]                           grepl <- base::grepl
[17:40:22.353]                           restarts <- computeRestarts(cond)
[17:40:22.353]                           for (restart in restarts) {
[17:40:22.353]                             name <- restart$name
[17:40:22.353]                             if (is.null(name)) 
[17:40:22.353]                               next
[17:40:22.353]                             if (!grepl(pattern, name)) 
[17:40:22.353]                               next
[17:40:22.353]                             invokeRestart(restart)
[17:40:22.353]                             muffled <- TRUE
[17:40:22.353]                             break
[17:40:22.353]                           }
[17:40:22.353]                         }
[17:40:22.353]                       }
[17:40:22.353]                       invisible(muffled)
[17:40:22.353]                     }
[17:40:22.353]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.353]                   }
[17:40:22.353]                 }
[17:40:22.353]             }
[17:40:22.353]         }))
[17:40:22.353]     }, error = function(ex) {
[17:40:22.353]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:22.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.353]                 ...future.rng), started = ...future.startTime, 
[17:40:22.353]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:22.353]             version = "1.8"), class = "FutureResult")
[17:40:22.353]     }, finally = {
[17:40:22.353]         if (!identical(...future.workdir, getwd())) 
[17:40:22.353]             setwd(...future.workdir)
[17:40:22.353]         {
[17:40:22.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:22.353]                 ...future.oldOptions$nwarnings <- NULL
[17:40:22.353]             }
[17:40:22.353]             base::options(...future.oldOptions)
[17:40:22.353]             if (.Platform$OS.type == "windows") {
[17:40:22.353]                 old_names <- names(...future.oldEnvVars)
[17:40:22.353]                 envs <- base::Sys.getenv()
[17:40:22.353]                 names <- names(envs)
[17:40:22.353]                 common <- intersect(names, old_names)
[17:40:22.353]                 added <- setdiff(names, old_names)
[17:40:22.353]                 removed <- setdiff(old_names, names)
[17:40:22.353]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:22.353]                   envs[common]]
[17:40:22.353]                 NAMES <- toupper(changed)
[17:40:22.353]                 args <- list()
[17:40:22.353]                 for (kk in seq_along(NAMES)) {
[17:40:22.353]                   name <- changed[[kk]]
[17:40:22.353]                   NAME <- NAMES[[kk]]
[17:40:22.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.353]                     next
[17:40:22.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.353]                 }
[17:40:22.353]                 NAMES <- toupper(added)
[17:40:22.353]                 for (kk in seq_along(NAMES)) {
[17:40:22.353]                   name <- added[[kk]]
[17:40:22.353]                   NAME <- NAMES[[kk]]
[17:40:22.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.353]                     next
[17:40:22.353]                   args[[name]] <- ""
[17:40:22.353]                 }
[17:40:22.353]                 NAMES <- toupper(removed)
[17:40:22.353]                 for (kk in seq_along(NAMES)) {
[17:40:22.353]                   name <- removed[[kk]]
[17:40:22.353]                   NAME <- NAMES[[kk]]
[17:40:22.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.353]                     next
[17:40:22.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.353]                 }
[17:40:22.353]                 if (length(args) > 0) 
[17:40:22.353]                   base::do.call(base::Sys.setenv, args = args)
[17:40:22.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:22.353]             }
[17:40:22.353]             else {
[17:40:22.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:22.353]             }
[17:40:22.353]             {
[17:40:22.353]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:22.353]                   0L) {
[17:40:22.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:22.353]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:22.353]                   base::options(opts)
[17:40:22.353]                 }
[17:40:22.353]                 {
[17:40:22.353]                   {
[17:40:22.353]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:22.353]                     NULL
[17:40:22.353]                   }
[17:40:22.353]                   options(future.plan = NULL)
[17:40:22.353]                   if (is.na(NA_character_)) 
[17:40:22.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:22.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:22.353]                     .init = FALSE)
[17:40:22.353]                 }
[17:40:22.353]             }
[17:40:22.353]         }
[17:40:22.353]     })
[17:40:22.353]     if (TRUE) {
[17:40:22.353]         base::sink(type = "output", split = FALSE)
[17:40:22.353]         if (TRUE) {
[17:40:22.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:22.353]         }
[17:40:22.353]         else {
[17:40:22.353]             ...future.result["stdout"] <- base::list(NULL)
[17:40:22.353]         }
[17:40:22.353]         base::close(...future.stdout)
[17:40:22.353]         ...future.stdout <- NULL
[17:40:22.353]     }
[17:40:22.353]     ...future.result$conditions <- ...future.conditions
[17:40:22.353]     ...future.result$finished <- base::Sys.time()
[17:40:22.353]     ...future.result
[17:40:22.353] }
[17:40:22.355] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:40:22.356] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:40:22.356] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:40:22.356] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:40:22.357] MultisessionFuture started
[17:40:22.357] - Launch lazy future ... done
[17:40:22.357] run() for ‘MultisessionFuture’ ... done
[17:40:22.357] result() for ClusterFuture ...
[17:40:22.357] receiveMessageFromWorker() for ClusterFuture ...
[17:40:22.357] - Validating connection of MultisessionFuture
[17:40:22.415] - received message: FutureResult
[17:40:22.416] - Received FutureResult
[17:40:22.416] - Erased future from FutureRegistry
[17:40:22.416] result() for ClusterFuture ...
[17:40:22.416] - result already collected: FutureResult
[17:40:22.416] result() for ClusterFuture ... done
[17:40:22.416] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:22.416] result() for ClusterFuture ... done
[17:40:22.416] result() for ClusterFuture ...
[17:40:22.417] - result already collected: FutureResult
[17:40:22.417] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[17:40:22.417] plan(): Setting new future strategy stack:
[17:40:22.417] List of future strategies:
[17:40:22.417] 1. multisession:
[17:40:22.417]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:22.417]    - tweaked: FALSE
[17:40:22.417]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:22.417] 2. multisession:
[17:40:22.417]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:22.417]    - tweaked: FALSE
[17:40:22.417]    - call: plan(list(a = strategy1, b = strategy2))
[17:40:22.418] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:22.418] multisession:
[17:40:22.418] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:22.418] - tweaked: FALSE
[17:40:22.418] - call: plan(list(a = strategy1, b = strategy2))
[17:40:22.422] getGlobalsAndPackages() ...
[17:40:22.422] Not searching for globals
[17:40:22.422] - globals: [0] <none>
[17:40:22.422] getGlobalsAndPackages() ... DONE
[17:40:22.422] [local output] makeClusterPSOCK() ...
[17:40:22.426] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:22.426] [local output] Base port: 11649
[17:40:22.426] [local output] Getting setup options for 2 cluster nodes ...
[17:40:22.426] [local output]  - Node 1 of 2 ...
[17:40:22.427] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:22.427] [local output] Rscript port: 11649

[17:40:22.427] [local output]  - Node 2 of 2 ...
[17:40:22.428] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:22.428] [local output] Rscript port: 11649

[17:40:22.429] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:22.429] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:22.429] [local output] Setting up PSOCK nodes in parallel
[17:40:22.429] List of 36
[17:40:22.429]  $ worker          : chr "localhost"
[17:40:22.429]   ..- attr(*, "localhost")= logi TRUE
[17:40:22.429]  $ master          : chr "localhost"
[17:40:22.429]  $ port            : int 11649
[17:40:22.429]  $ connectTimeout  : num 120
[17:40:22.429]  $ timeout         : num 2592000
[17:40:22.429]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:22.429]  $ homogeneous     : logi TRUE
[17:40:22.429]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:22.429]  $ rscript_envs    : NULL
[17:40:22.429]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:22.429]  $ rscript_startup : NULL
[17:40:22.429]  $ rscript_sh      : chr "sh"
[17:40:22.429]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:22.429]  $ methods         : logi TRUE
[17:40:22.429]  $ socketOptions   : chr "no-delay"
[17:40:22.429]  $ useXDR          : logi FALSE
[17:40:22.429]  $ outfile         : chr "/dev/null"
[17:40:22.429]  $ renice          : int NA
[17:40:22.429]  $ rshcmd          : NULL
[17:40:22.429]  $ user            : chr(0) 
[17:40:22.429]  $ revtunnel       : logi FALSE
[17:40:22.429]  $ rshlogfile      : NULL
[17:40:22.429]  $ rshopts         : chr(0) 
[17:40:22.429]  $ rank            : int 1
[17:40:22.429]  $ manual          : logi FALSE
[17:40:22.429]  $ dryrun          : logi FALSE
[17:40:22.429]  $ quiet           : logi FALSE
[17:40:22.429]  $ setup_strategy  : chr "parallel"
[17:40:22.429]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:22.429]  $ pidfile         : chr "/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b9197bcd67c8.pid"
[17:40:22.429]  $ rshcmd_label    : NULL
[17:40:22.429]  $ rsh_call        : NULL
[17:40:22.429]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:22.429]  $ localMachine    : logi TRUE
[17:40:22.429]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:22.429]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:22.429]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:22.429]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:22.429]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:22.429]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:22.429]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:22.429]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:22.429]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:22.429]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:22.429]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:22.429]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:22.429]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:22.429]  $ arguments       :List of 28
[17:40:22.429]   ..$ worker          : chr "localhost"
[17:40:22.429]   ..$ master          : NULL
[17:40:22.429]   ..$ port            : int 11649
[17:40:22.429]   ..$ connectTimeout  : num 120
[17:40:22.429]   ..$ timeout         : num 2592000
[17:40:22.429]   ..$ rscript         : NULL
[17:40:22.429]   ..$ homogeneous     : NULL
[17:40:22.429]   ..$ rscript_args    : NULL
[17:40:22.429]   ..$ rscript_envs    : NULL
[17:40:22.429]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:22.429]   ..$ rscript_startup : NULL
[17:40:22.429]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:22.429]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:22.429]   ..$ methods         : logi TRUE
[17:40:22.429]   ..$ socketOptions   : chr "no-delay"
[17:40:22.429]   ..$ useXDR          : logi FALSE
[17:40:22.429]   ..$ outfile         : chr "/dev/null"
[17:40:22.429]   ..$ renice          : int NA
[17:40:22.429]   ..$ rshcmd          : NULL
[17:40:22.429]   ..$ user            : NULL
[17:40:22.429]   ..$ revtunnel       : logi NA
[17:40:22.429]   ..$ rshlogfile      : NULL
[17:40:22.429]   ..$ rshopts         : NULL
[17:40:22.429]   ..$ rank            : int 1
[17:40:22.429]   ..$ manual          : logi FALSE
[17:40:22.429]   ..$ dryrun          : logi FALSE
[17:40:22.429]   ..$ quiet           : logi FALSE
[17:40:22.429]   ..$ setup_strategy  : chr "parallel"
[17:40:22.429]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:22.450] [local output] System call to launch all workers:
[17:40:22.450] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp7aEZT3/worker.rank=1.parallelly.parent=47385.b9197bcd67c8.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11649 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:22.450] [local output] Starting PSOCK main server
[17:40:22.452] [local output] Workers launched
[17:40:22.452] [local output] Waiting for workers to connect back
[17:40:22.452]  - [local output] 0 workers out of 2 ready
[17:40:22.708]  - [local output] 0 workers out of 2 ready
[17:40:22.708]  - [local output] 1 workers out of 2 ready
[17:40:22.709]  - [local output] 1 workers out of 2 ready
[17:40:22.710]  - [local output] 2 workers out of 2 ready
[17:40:22.710] [local output] Launching of workers completed
[17:40:22.710] [local output] Collecting session information from workers
[17:40:22.710] [local output]  - Worker #1 of 2
[17:40:22.711] [local output]  - Worker #2 of 2
[17:40:22.711] [local output] makeClusterPSOCK() ... done
[17:40:22.721] Packages needed by the future expression (n = 0): <none>
[17:40:22.722] Packages needed by future strategies (n = 1): ‘future’
[17:40:22.722] {
[17:40:22.722]     {
[17:40:22.722]         {
[17:40:22.722]             ...future.startTime <- base::Sys.time()
[17:40:22.722]             {
[17:40:22.722]                 {
[17:40:22.722]                   {
[17:40:22.722]                     {
[17:40:22.722]                       {
[17:40:22.722]                         base::local({
[17:40:22.722]                           has_future <- base::requireNamespace("future", 
[17:40:22.722]                             quietly = TRUE)
[17:40:22.722]                           if (has_future) {
[17:40:22.722]                             ns <- base::getNamespace("future")
[17:40:22.722]                             version <- ns[[".package"]][["version"]]
[17:40:22.722]                             if (is.null(version)) 
[17:40:22.722]                               version <- utils::packageVersion("future")
[17:40:22.722]                           }
[17:40:22.722]                           else {
[17:40:22.722]                             version <- NULL
[17:40:22.722]                           }
[17:40:22.722]                           if (!has_future || version < "1.8.0") {
[17:40:22.722]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:22.722]                               "", base::R.version$version.string), 
[17:40:22.722]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:22.722]                                 base::R.version$platform, 8 * 
[17:40:22.722]                                   base::.Machine$sizeof.pointer), 
[17:40:22.722]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:22.722]                                 "release", "version")], collapse = " "), 
[17:40:22.722]                               hostname = base::Sys.info()[["nodename"]])
[17:40:22.722]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:22.722]                               info)
[17:40:22.722]                             info <- base::paste(info, collapse = "; ")
[17:40:22.722]                             if (!has_future) {
[17:40:22.722]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:22.722]                                 info)
[17:40:22.722]                             }
[17:40:22.722]                             else {
[17:40:22.722]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:22.722]                                 info, version)
[17:40:22.722]                             }
[17:40:22.722]                             base::stop(msg)
[17:40:22.722]                           }
[17:40:22.722]                         })
[17:40:22.722]                       }
[17:40:22.722]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:22.722]                       base::options(mc.cores = 1L)
[17:40:22.722]                     }
[17:40:22.722]                     base::local({
[17:40:22.722]                       for (pkg in "future") {
[17:40:22.722]                         base::loadNamespace(pkg)
[17:40:22.722]                         base::library(pkg, character.only = TRUE)
[17:40:22.722]                       }
[17:40:22.722]                     })
[17:40:22.722]                   }
[17:40:22.722]                   ...future.strategy.old <- future::plan("list")
[17:40:22.722]                   options(future.plan = NULL)
[17:40:22.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.722]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:22.722]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:22.722]                     envir = parent.frame()) 
[17:40:22.722]                   {
[17:40:22.722]                     if (is.function(workers)) 
[17:40:22.722]                       workers <- workers()
[17:40:22.722]                     workers <- structure(as.integer(workers), 
[17:40:22.722]                       class = class(workers))
[17:40:22.722]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:22.722]                       workers >= 1)
[17:40:22.722]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:22.722]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:22.722]                     }
[17:40:22.722]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:22.722]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:22.722]                       envir = envir)
[17:40:22.722]                     if (!future$lazy) 
[17:40:22.722]                       future <- run(future)
[17:40:22.722]                     invisible(future)
[17:40:22.722]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:22.722]                 }
[17:40:22.722]                 ...future.workdir <- getwd()
[17:40:22.722]             }
[17:40:22.722]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:22.722]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:22.722]         }
[17:40:22.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:22.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:22.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:22.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:22.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:22.722]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:22.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:22.722]             base::names(...future.oldOptions))
[17:40:22.722]     }
[17:40:22.722]     if (FALSE) {
[17:40:22.722]     }
[17:40:22.722]     else {
[17:40:22.722]         if (TRUE) {
[17:40:22.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:22.722]                 open = "w")
[17:40:22.722]         }
[17:40:22.722]         else {
[17:40:22.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:22.722]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:22.722]         }
[17:40:22.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:22.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:22.722]             base::sink(type = "output", split = FALSE)
[17:40:22.722]             base::close(...future.stdout)
[17:40:22.722]         }, add = TRUE)
[17:40:22.722]     }
[17:40:22.722]     ...future.frame <- base::sys.nframe()
[17:40:22.722]     ...future.conditions <- base::list()
[17:40:22.722]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:22.722]     if (FALSE) {
[17:40:22.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:22.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:22.722]     }
[17:40:22.722]     ...future.result <- base::tryCatch({
[17:40:22.722]         base::withCallingHandlers({
[17:40:22.722]             ...future.value <- base::withVisible(base::local({
[17:40:22.722]                 ...future.makeSendCondition <- base::local({
[17:40:22.722]                   sendCondition <- NULL
[17:40:22.722]                   function(frame = 1L) {
[17:40:22.722]                     if (is.function(sendCondition)) 
[17:40:22.722]                       return(sendCondition)
[17:40:22.722]                     ns <- getNamespace("parallel")
[17:40:22.722]                     if (exists("sendData", mode = "function", 
[17:40:22.722]                       envir = ns)) {
[17:40:22.722]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:22.722]                         envir = ns)
[17:40:22.722]                       envir <- sys.frame(frame)
[17:40:22.722]                       master <- NULL
[17:40:22.722]                       while (!identical(envir, .GlobalEnv) && 
[17:40:22.722]                         !identical(envir, emptyenv())) {
[17:40:22.722]                         if (exists("master", mode = "list", envir = envir, 
[17:40:22.722]                           inherits = FALSE)) {
[17:40:22.722]                           master <- get("master", mode = "list", 
[17:40:22.722]                             envir = envir, inherits = FALSE)
[17:40:22.722]                           if (inherits(master, c("SOCKnode", 
[17:40:22.722]                             "SOCK0node"))) {
[17:40:22.722]                             sendCondition <<- function(cond) {
[17:40:22.722]                               data <- list(type = "VALUE", value = cond, 
[17:40:22.722]                                 success = TRUE)
[17:40:22.722]                               parallel_sendData(master, data)
[17:40:22.722]                             }
[17:40:22.722]                             return(sendCondition)
[17:40:22.722]                           }
[17:40:22.722]                         }
[17:40:22.722]                         frame <- frame + 1L
[17:40:22.722]                         envir <- sys.frame(frame)
[17:40:22.722]                       }
[17:40:22.722]                     }
[17:40:22.722]                     sendCondition <<- function(cond) NULL
[17:40:22.722]                   }
[17:40:22.722]                 })
[17:40:22.722]                 withCallingHandlers({
[17:40:22.722]                   NA
[17:40:22.722]                 }, immediateCondition = function(cond) {
[17:40:22.722]                   sendCondition <- ...future.makeSendCondition()
[17:40:22.722]                   sendCondition(cond)
[17:40:22.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.722]                   {
[17:40:22.722]                     inherits <- base::inherits
[17:40:22.722]                     invokeRestart <- base::invokeRestart
[17:40:22.722]                     is.null <- base::is.null
[17:40:22.722]                     muffled <- FALSE
[17:40:22.722]                     if (inherits(cond, "message")) {
[17:40:22.722]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:22.722]                       if (muffled) 
[17:40:22.722]                         invokeRestart("muffleMessage")
[17:40:22.722]                     }
[17:40:22.722]                     else if (inherits(cond, "warning")) {
[17:40:22.722]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:22.722]                       if (muffled) 
[17:40:22.722]                         invokeRestart("muffleWarning")
[17:40:22.722]                     }
[17:40:22.722]                     else if (inherits(cond, "condition")) {
[17:40:22.722]                       if (!is.null(pattern)) {
[17:40:22.722]                         computeRestarts <- base::computeRestarts
[17:40:22.722]                         grepl <- base::grepl
[17:40:22.722]                         restarts <- computeRestarts(cond)
[17:40:22.722]                         for (restart in restarts) {
[17:40:22.722]                           name <- restart$name
[17:40:22.722]                           if (is.null(name)) 
[17:40:22.722]                             next
[17:40:22.722]                           if (!grepl(pattern, name)) 
[17:40:22.722]                             next
[17:40:22.722]                           invokeRestart(restart)
[17:40:22.722]                           muffled <- TRUE
[17:40:22.722]                           break
[17:40:22.722]                         }
[17:40:22.722]                       }
[17:40:22.722]                     }
[17:40:22.722]                     invisible(muffled)
[17:40:22.722]                   }
[17:40:22.722]                   muffleCondition(cond)
[17:40:22.722]                 })
[17:40:22.722]             }))
[17:40:22.722]             future::FutureResult(value = ...future.value$value, 
[17:40:22.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.722]                   ...future.rng), globalenv = if (FALSE) 
[17:40:22.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:22.722]                     ...future.globalenv.names))
[17:40:22.722]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:22.722]         }, condition = base::local({
[17:40:22.722]             c <- base::c
[17:40:22.722]             inherits <- base::inherits
[17:40:22.722]             invokeRestart <- base::invokeRestart
[17:40:22.722]             length <- base::length
[17:40:22.722]             list <- base::list
[17:40:22.722]             seq.int <- base::seq.int
[17:40:22.722]             signalCondition <- base::signalCondition
[17:40:22.722]             sys.calls <- base::sys.calls
[17:40:22.722]             `[[` <- base::`[[`
[17:40:22.722]             `+` <- base::`+`
[17:40:22.722]             `<<-` <- base::`<<-`
[17:40:22.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:22.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:22.722]                   3L)]
[17:40:22.722]             }
[17:40:22.722]             function(cond) {
[17:40:22.722]                 is_error <- inherits(cond, "error")
[17:40:22.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:22.722]                   NULL)
[17:40:22.722]                 if (is_error) {
[17:40:22.722]                   sessionInformation <- function() {
[17:40:22.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:22.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:22.722]                       search = base::search(), system = base::Sys.info())
[17:40:22.722]                   }
[17:40:22.722]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:22.722]                     cond$call), session = sessionInformation(), 
[17:40:22.722]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:22.722]                   signalCondition(cond)
[17:40:22.722]                 }
[17:40:22.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:22.722]                 "immediateCondition"))) {
[17:40:22.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:22.722]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:22.722]                   if (TRUE && !signal) {
[17:40:22.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.722]                     {
[17:40:22.722]                       inherits <- base::inherits
[17:40:22.722]                       invokeRestart <- base::invokeRestart
[17:40:22.722]                       is.null <- base::is.null
[17:40:22.722]                       muffled <- FALSE
[17:40:22.722]                       if (inherits(cond, "message")) {
[17:40:22.722]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.722]                         if (muffled) 
[17:40:22.722]                           invokeRestart("muffleMessage")
[17:40:22.722]                       }
[17:40:22.722]                       else if (inherits(cond, "warning")) {
[17:40:22.722]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.722]                         if (muffled) 
[17:40:22.722]                           invokeRestart("muffleWarning")
[17:40:22.722]                       }
[17:40:22.722]                       else if (inherits(cond, "condition")) {
[17:40:22.722]                         if (!is.null(pattern)) {
[17:40:22.722]                           computeRestarts <- base::computeRestarts
[17:40:22.722]                           grepl <- base::grepl
[17:40:22.722]                           restarts <- computeRestarts(cond)
[17:40:22.722]                           for (restart in restarts) {
[17:40:22.722]                             name <- restart$name
[17:40:22.722]                             if (is.null(name)) 
[17:40:22.722]                               next
[17:40:22.722]                             if (!grepl(pattern, name)) 
[17:40:22.722]                               next
[17:40:22.722]                             invokeRestart(restart)
[17:40:22.722]                             muffled <- TRUE
[17:40:22.722]                             break
[17:40:22.722]                           }
[17:40:22.722]                         }
[17:40:22.722]                       }
[17:40:22.722]                       invisible(muffled)
[17:40:22.722]                     }
[17:40:22.722]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.722]                   }
[17:40:22.722]                 }
[17:40:22.722]                 else {
[17:40:22.722]                   if (TRUE) {
[17:40:22.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.722]                     {
[17:40:22.722]                       inherits <- base::inherits
[17:40:22.722]                       invokeRestart <- base::invokeRestart
[17:40:22.722]                       is.null <- base::is.null
[17:40:22.722]                       muffled <- FALSE
[17:40:22.722]                       if (inherits(cond, "message")) {
[17:40:22.722]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.722]                         if (muffled) 
[17:40:22.722]                           invokeRestart("muffleMessage")
[17:40:22.722]                       }
[17:40:22.722]                       else if (inherits(cond, "warning")) {
[17:40:22.722]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.722]                         if (muffled) 
[17:40:22.722]                           invokeRestart("muffleWarning")
[17:40:22.722]                       }
[17:40:22.722]                       else if (inherits(cond, "condition")) {
[17:40:22.722]                         if (!is.null(pattern)) {
[17:40:22.722]                           computeRestarts <- base::computeRestarts
[17:40:22.722]                           grepl <- base::grepl
[17:40:22.722]                           restarts <- computeRestarts(cond)
[17:40:22.722]                           for (restart in restarts) {
[17:40:22.722]                             name <- restart$name
[17:40:22.722]                             if (is.null(name)) 
[17:40:22.722]                               next
[17:40:22.722]                             if (!grepl(pattern, name)) 
[17:40:22.722]                               next
[17:40:22.722]                             invokeRestart(restart)
[17:40:22.722]                             muffled <- TRUE
[17:40:22.722]                             break
[17:40:22.722]                           }
[17:40:22.722]                         }
[17:40:22.722]                       }
[17:40:22.722]                       invisible(muffled)
[17:40:22.722]                     }
[17:40:22.722]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.722]                   }
[17:40:22.722]                 }
[17:40:22.722]             }
[17:40:22.722]         }))
[17:40:22.722]     }, error = function(ex) {
[17:40:22.722]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:22.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.722]                 ...future.rng), started = ...future.startTime, 
[17:40:22.722]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:22.722]             version = "1.8"), class = "FutureResult")
[17:40:22.722]     }, finally = {
[17:40:22.722]         if (!identical(...future.workdir, getwd())) 
[17:40:22.722]             setwd(...future.workdir)
[17:40:22.722]         {
[17:40:22.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:22.722]                 ...future.oldOptions$nwarnings <- NULL
[17:40:22.722]             }
[17:40:22.722]             base::options(...future.oldOptions)
[17:40:22.722]             if (.Platform$OS.type == "windows") {
[17:40:22.722]                 old_names <- names(...future.oldEnvVars)
[17:40:22.722]                 envs <- base::Sys.getenv()
[17:40:22.722]                 names <- names(envs)
[17:40:22.722]                 common <- intersect(names, old_names)
[17:40:22.722]                 added <- setdiff(names, old_names)
[17:40:22.722]                 removed <- setdiff(old_names, names)
[17:40:22.722]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:22.722]                   envs[common]]
[17:40:22.722]                 NAMES <- toupper(changed)
[17:40:22.722]                 args <- list()
[17:40:22.722]                 for (kk in seq_along(NAMES)) {
[17:40:22.722]                   name <- changed[[kk]]
[17:40:22.722]                   NAME <- NAMES[[kk]]
[17:40:22.722]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.722]                     next
[17:40:22.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.722]                 }
[17:40:22.722]                 NAMES <- toupper(added)
[17:40:22.722]                 for (kk in seq_along(NAMES)) {
[17:40:22.722]                   name <- added[[kk]]
[17:40:22.722]                   NAME <- NAMES[[kk]]
[17:40:22.722]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.722]                     next
[17:40:22.722]                   args[[name]] <- ""
[17:40:22.722]                 }
[17:40:22.722]                 NAMES <- toupper(removed)
[17:40:22.722]                 for (kk in seq_along(NAMES)) {
[17:40:22.722]                   name <- removed[[kk]]
[17:40:22.722]                   NAME <- NAMES[[kk]]
[17:40:22.722]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.722]                     next
[17:40:22.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.722]                 }
[17:40:22.722]                 if (length(args) > 0) 
[17:40:22.722]                   base::do.call(base::Sys.setenv, args = args)
[17:40:22.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:22.722]             }
[17:40:22.722]             else {
[17:40:22.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:22.722]             }
[17:40:22.722]             {
[17:40:22.722]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:22.722]                   0L) {
[17:40:22.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:22.722]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:22.722]                   base::options(opts)
[17:40:22.722]                 }
[17:40:22.722]                 {
[17:40:22.722]                   {
[17:40:22.722]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:22.722]                     NULL
[17:40:22.722]                   }
[17:40:22.722]                   options(future.plan = NULL)
[17:40:22.722]                   if (is.na(NA_character_)) 
[17:40:22.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:22.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:22.722]                     .init = FALSE)
[17:40:22.722]                 }
[17:40:22.722]             }
[17:40:22.722]         }
[17:40:22.722]     })
[17:40:22.722]     if (TRUE) {
[17:40:22.722]         base::sink(type = "output", split = FALSE)
[17:40:22.722]         if (TRUE) {
[17:40:22.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:22.722]         }
[17:40:22.722]         else {
[17:40:22.722]             ...future.result["stdout"] <- base::list(NULL)
[17:40:22.722]         }
[17:40:22.722]         base::close(...future.stdout)
[17:40:22.722]         ...future.stdout <- NULL
[17:40:22.722]     }
[17:40:22.722]     ...future.result$conditions <- ...future.conditions
[17:40:22.722]     ...future.result$finished <- base::Sys.time()
[17:40:22.722]     ...future.result
[17:40:22.722] }
[17:40:22.774] MultisessionFuture started
[17:40:22.774] result() for ClusterFuture ...
[17:40:22.774] receiveMessageFromWorker() for ClusterFuture ...
[17:40:22.775] - Validating connection of MultisessionFuture
[17:40:22.819] - received message: FutureResult
[17:40:22.819] - Received FutureResult
[17:40:22.819] - Erased future from FutureRegistry
[17:40:22.820] result() for ClusterFuture ...
[17:40:22.820] - result already collected: FutureResult
[17:40:22.820] result() for ClusterFuture ... done
[17:40:22.820] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:22.820] result() for ClusterFuture ... done
[17:40:22.820] result() for ClusterFuture ...
[17:40:22.820] - result already collected: FutureResult
[17:40:22.820] result() for ClusterFuture ... done
[17:40:22.820] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:22.824] plan(): nbrOfWorkers() = 2
[17:40:22.824] getGlobalsAndPackages() ...
[17:40:22.824] Searching for globals...
[17:40:22.839] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[17:40:22.840] Searching for globals ... DONE
[17:40:22.840] Resolving globals: FALSE
[17:40:22.841] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[17:40:22.841] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[17:40:22.841] - globals: [2] ‘nested’, ‘strategy2’
[17:40:22.841] - packages: [1] ‘future’
[17:40:22.842] getGlobalsAndPackages() ... DONE
[17:40:22.842] run() for ‘Future’ ...
[17:40:22.842] - state: ‘created’
[17:40:22.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:22.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:22.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:22.856]   - Field: ‘node’
[17:40:22.856]   - Field: ‘label’
[17:40:22.856]   - Field: ‘local’
[17:40:22.856]   - Field: ‘owner’
[17:40:22.856]   - Field: ‘envir’
[17:40:22.856]   - Field: ‘workers’
[17:40:22.857]   - Field: ‘packages’
[17:40:22.857]   - Field: ‘gc’
[17:40:22.857]   - Field: ‘conditions’
[17:40:22.857]   - Field: ‘persistent’
[17:40:22.857]   - Field: ‘expr’
[17:40:22.857]   - Field: ‘uuid’
[17:40:22.857]   - Field: ‘seed’
[17:40:22.857]   - Field: ‘version’
[17:40:22.857]   - Field: ‘result’
[17:40:22.857]   - Field: ‘asynchronous’
[17:40:22.857]   - Field: ‘calls’
[17:40:22.858]   - Field: ‘globals’
[17:40:22.858]   - Field: ‘stdout’
[17:40:22.858]   - Field: ‘earlySignal’
[17:40:22.858]   - Field: ‘lazy’
[17:40:22.858]   - Field: ‘state’
[17:40:22.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:22.858] - Launch lazy future ...
[17:40:22.858] Packages needed by the future expression (n = 1): ‘future’
[17:40:22.858] Packages needed by future strategies (n = 1): ‘future’
[17:40:22.859] {
[17:40:22.859]     {
[17:40:22.859]         {
[17:40:22.859]             ...future.startTime <- base::Sys.time()
[17:40:22.859]             {
[17:40:22.859]                 {
[17:40:22.859]                   {
[17:40:22.859]                     {
[17:40:22.859]                       {
[17:40:22.859]                         base::local({
[17:40:22.859]                           has_future <- base::requireNamespace("future", 
[17:40:22.859]                             quietly = TRUE)
[17:40:22.859]                           if (has_future) {
[17:40:22.859]                             ns <- base::getNamespace("future")
[17:40:22.859]                             version <- ns[[".package"]][["version"]]
[17:40:22.859]                             if (is.null(version)) 
[17:40:22.859]                               version <- utils::packageVersion("future")
[17:40:22.859]                           }
[17:40:22.859]                           else {
[17:40:22.859]                             version <- NULL
[17:40:22.859]                           }
[17:40:22.859]                           if (!has_future || version < "1.8.0") {
[17:40:22.859]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:22.859]                               "", base::R.version$version.string), 
[17:40:22.859]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:22.859]                                 base::R.version$platform, 8 * 
[17:40:22.859]                                   base::.Machine$sizeof.pointer), 
[17:40:22.859]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:22.859]                                 "release", "version")], collapse = " "), 
[17:40:22.859]                               hostname = base::Sys.info()[["nodename"]])
[17:40:22.859]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:22.859]                               info)
[17:40:22.859]                             info <- base::paste(info, collapse = "; ")
[17:40:22.859]                             if (!has_future) {
[17:40:22.859]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:22.859]                                 info)
[17:40:22.859]                             }
[17:40:22.859]                             else {
[17:40:22.859]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:22.859]                                 info, version)
[17:40:22.859]                             }
[17:40:22.859]                             base::stop(msg)
[17:40:22.859]                           }
[17:40:22.859]                         })
[17:40:22.859]                       }
[17:40:22.859]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:22.859]                       base::options(mc.cores = 1L)
[17:40:22.859]                     }
[17:40:22.859]                     base::local({
[17:40:22.859]                       for (pkg in "future") {
[17:40:22.859]                         base::loadNamespace(pkg)
[17:40:22.859]                         base::library(pkg, character.only = TRUE)
[17:40:22.859]                       }
[17:40:22.859]                     })
[17:40:22.859]                   }
[17:40:22.859]                   ...future.strategy.old <- future::plan("list")
[17:40:22.859]                   options(future.plan = NULL)
[17:40:22.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.859]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:22.859]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:22.859]                     envir = parent.frame()) 
[17:40:22.859]                   {
[17:40:22.859]                     if (is.function(workers)) 
[17:40:22.859]                       workers <- workers()
[17:40:22.859]                     workers <- structure(as.integer(workers), 
[17:40:22.859]                       class = class(workers))
[17:40:22.859]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:22.859]                       workers >= 1)
[17:40:22.859]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:22.859]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:22.859]                     }
[17:40:22.859]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:22.859]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:22.859]                       envir = envir)
[17:40:22.859]                     if (!future$lazy) 
[17:40:22.859]                       future <- run(future)
[17:40:22.859]                     invisible(future)
[17:40:22.859]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:22.859]                 }
[17:40:22.859]                 ...future.workdir <- getwd()
[17:40:22.859]             }
[17:40:22.859]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:22.859]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:22.859]         }
[17:40:22.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:22.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:22.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:22.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:22.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:22.859]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:22.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:22.859]             base::names(...future.oldOptions))
[17:40:22.859]     }
[17:40:22.859]     if (FALSE) {
[17:40:22.859]     }
[17:40:22.859]     else {
[17:40:22.859]         if (TRUE) {
[17:40:22.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:22.859]                 open = "w")
[17:40:22.859]         }
[17:40:22.859]         else {
[17:40:22.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:22.859]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:22.859]         }
[17:40:22.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:22.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:22.859]             base::sink(type = "output", split = FALSE)
[17:40:22.859]             base::close(...future.stdout)
[17:40:22.859]         }, add = TRUE)
[17:40:22.859]     }
[17:40:22.859]     ...future.frame <- base::sys.nframe()
[17:40:22.859]     ...future.conditions <- base::list()
[17:40:22.859]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:22.859]     if (FALSE) {
[17:40:22.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:22.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:22.859]     }
[17:40:22.859]     ...future.result <- base::tryCatch({
[17:40:22.859]         base::withCallingHandlers({
[17:40:22.859]             ...future.value <- base::withVisible(base::local({
[17:40:22.859]                 ...future.makeSendCondition <- base::local({
[17:40:22.859]                   sendCondition <- NULL
[17:40:22.859]                   function(frame = 1L) {
[17:40:22.859]                     if (is.function(sendCondition)) 
[17:40:22.859]                       return(sendCondition)
[17:40:22.859]                     ns <- getNamespace("parallel")
[17:40:22.859]                     if (exists("sendData", mode = "function", 
[17:40:22.859]                       envir = ns)) {
[17:40:22.859]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:22.859]                         envir = ns)
[17:40:22.859]                       envir <- sys.frame(frame)
[17:40:22.859]                       master <- NULL
[17:40:22.859]                       while (!identical(envir, .GlobalEnv) && 
[17:40:22.859]                         !identical(envir, emptyenv())) {
[17:40:22.859]                         if (exists("master", mode = "list", envir = envir, 
[17:40:22.859]                           inherits = FALSE)) {
[17:40:22.859]                           master <- get("master", mode = "list", 
[17:40:22.859]                             envir = envir, inherits = FALSE)
[17:40:22.859]                           if (inherits(master, c("SOCKnode", 
[17:40:22.859]                             "SOCK0node"))) {
[17:40:22.859]                             sendCondition <<- function(cond) {
[17:40:22.859]                               data <- list(type = "VALUE", value = cond, 
[17:40:22.859]                                 success = TRUE)
[17:40:22.859]                               parallel_sendData(master, data)
[17:40:22.859]                             }
[17:40:22.859]                             return(sendCondition)
[17:40:22.859]                           }
[17:40:22.859]                         }
[17:40:22.859]                         frame <- frame + 1L
[17:40:22.859]                         envir <- sys.frame(frame)
[17:40:22.859]                       }
[17:40:22.859]                     }
[17:40:22.859]                     sendCondition <<- function(cond) NULL
[17:40:22.859]                   }
[17:40:22.859]                 })
[17:40:22.859]                 withCallingHandlers({
[17:40:22.859]                   {
[17:40:22.859]                     a <- 1L
[17:40:22.859]                     plan_a <- unclass(future::plan("list"))
[17:40:22.859]                     nested_a <- nested[-1]
[17:40:22.859]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[17:40:22.859]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[17:40:22.859]                       strategy2))
[17:40:22.859]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[17:40:22.859]                       "init") <- NULL
[17:40:22.859]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[17:40:22.859]                       "init") <- NULL
[17:40:22.859]                     stopifnot(all.equal(plan_a, nested_a))
[17:40:22.859]                     y %<-% {
[17:40:22.859]                       b <- 2L
[17:40:22.859]                       plan_b <- future::plan("list")
[17:40:22.859]                       nested_b <- nested_a[-1]
[17:40:22.859]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[17:40:22.859]                         1L, inherits(plan_b[[1]], "future"), 
[17:40:22.859]                         inherits(future::plan("next"), "sequential"))
[17:40:22.859]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[17:40:22.859]                         b = b, nested_b = nested_b, plan_b = plan_b)
[17:40:22.859]                     }
[17:40:22.859]                     y
[17:40:22.859]                   }
[17:40:22.859]                 }, immediateCondition = function(cond) {
[17:40:22.859]                   sendCondition <- ...future.makeSendCondition()
[17:40:22.859]                   sendCondition(cond)
[17:40:22.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.859]                   {
[17:40:22.859]                     inherits <- base::inherits
[17:40:22.859]                     invokeRestart <- base::invokeRestart
[17:40:22.859]                     is.null <- base::is.null
[17:40:22.859]                     muffled <- FALSE
[17:40:22.859]                     if (inherits(cond, "message")) {
[17:40:22.859]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:22.859]                       if (muffled) 
[17:40:22.859]                         invokeRestart("muffleMessage")
[17:40:22.859]                     }
[17:40:22.859]                     else if (inherits(cond, "warning")) {
[17:40:22.859]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:22.859]                       if (muffled) 
[17:40:22.859]                         invokeRestart("muffleWarning")
[17:40:22.859]                     }
[17:40:22.859]                     else if (inherits(cond, "condition")) {
[17:40:22.859]                       if (!is.null(pattern)) {
[17:40:22.859]                         computeRestarts <- base::computeRestarts
[17:40:22.859]                         grepl <- base::grepl
[17:40:22.859]                         restarts <- computeRestarts(cond)
[17:40:22.859]                         for (restart in restarts) {
[17:40:22.859]                           name <- restart$name
[17:40:22.859]                           if (is.null(name)) 
[17:40:22.859]                             next
[17:40:22.859]                           if (!grepl(pattern, name)) 
[17:40:22.859]                             next
[17:40:22.859]                           invokeRestart(restart)
[17:40:22.859]                           muffled <- TRUE
[17:40:22.859]                           break
[17:40:22.859]                         }
[17:40:22.859]                       }
[17:40:22.859]                     }
[17:40:22.859]                     invisible(muffled)
[17:40:22.859]                   }
[17:40:22.859]                   muffleCondition(cond)
[17:40:22.859]                 })
[17:40:22.859]             }))
[17:40:22.859]             future::FutureResult(value = ...future.value$value, 
[17:40:22.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.859]                   ...future.rng), globalenv = if (FALSE) 
[17:40:22.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:22.859]                     ...future.globalenv.names))
[17:40:22.859]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:22.859]         }, condition = base::local({
[17:40:22.859]             c <- base::c
[17:40:22.859]             inherits <- base::inherits
[17:40:22.859]             invokeRestart <- base::invokeRestart
[17:40:22.859]             length <- base::length
[17:40:22.859]             list <- base::list
[17:40:22.859]             seq.int <- base::seq.int
[17:40:22.859]             signalCondition <- base::signalCondition
[17:40:22.859]             sys.calls <- base::sys.calls
[17:40:22.859]             `[[` <- base::`[[`
[17:40:22.859]             `+` <- base::`+`
[17:40:22.859]             `<<-` <- base::`<<-`
[17:40:22.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:22.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:22.859]                   3L)]
[17:40:22.859]             }
[17:40:22.859]             function(cond) {
[17:40:22.859]                 is_error <- inherits(cond, "error")
[17:40:22.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:22.859]                   NULL)
[17:40:22.859]                 if (is_error) {
[17:40:22.859]                   sessionInformation <- function() {
[17:40:22.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:22.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:22.859]                       search = base::search(), system = base::Sys.info())
[17:40:22.859]                   }
[17:40:22.859]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:22.859]                     cond$call), session = sessionInformation(), 
[17:40:22.859]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:22.859]                   signalCondition(cond)
[17:40:22.859]                 }
[17:40:22.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:22.859]                 "immediateCondition"))) {
[17:40:22.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:22.859]                   ...future.conditions[[length(...future.conditions) + 
[17:40:22.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:22.859]                   if (TRUE && !signal) {
[17:40:22.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.859]                     {
[17:40:22.859]                       inherits <- base::inherits
[17:40:22.859]                       invokeRestart <- base::invokeRestart
[17:40:22.859]                       is.null <- base::is.null
[17:40:22.859]                       muffled <- FALSE
[17:40:22.859]                       if (inherits(cond, "message")) {
[17:40:22.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.859]                         if (muffled) 
[17:40:22.859]                           invokeRestart("muffleMessage")
[17:40:22.859]                       }
[17:40:22.859]                       else if (inherits(cond, "warning")) {
[17:40:22.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.859]                         if (muffled) 
[17:40:22.859]                           invokeRestart("muffleWarning")
[17:40:22.859]                       }
[17:40:22.859]                       else if (inherits(cond, "condition")) {
[17:40:22.859]                         if (!is.null(pattern)) {
[17:40:22.859]                           computeRestarts <- base::computeRestarts
[17:40:22.859]                           grepl <- base::grepl
[17:40:22.859]                           restarts <- computeRestarts(cond)
[17:40:22.859]                           for (restart in restarts) {
[17:40:22.859]                             name <- restart$name
[17:40:22.859]                             if (is.null(name)) 
[17:40:22.859]                               next
[17:40:22.859]                             if (!grepl(pattern, name)) 
[17:40:22.859]                               next
[17:40:22.859]                             invokeRestart(restart)
[17:40:22.859]                             muffled <- TRUE
[17:40:22.859]                             break
[17:40:22.859]                           }
[17:40:22.859]                         }
[17:40:22.859]                       }
[17:40:22.859]                       invisible(muffled)
[17:40:22.859]                     }
[17:40:22.859]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.859]                   }
[17:40:22.859]                 }
[17:40:22.859]                 else {
[17:40:22.859]                   if (TRUE) {
[17:40:22.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:22.859]                     {
[17:40:22.859]                       inherits <- base::inherits
[17:40:22.859]                       invokeRestart <- base::invokeRestart
[17:40:22.859]                       is.null <- base::is.null
[17:40:22.859]                       muffled <- FALSE
[17:40:22.859]                       if (inherits(cond, "message")) {
[17:40:22.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:22.859]                         if (muffled) 
[17:40:22.859]                           invokeRestart("muffleMessage")
[17:40:22.859]                       }
[17:40:22.859]                       else if (inherits(cond, "warning")) {
[17:40:22.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:22.859]                         if (muffled) 
[17:40:22.859]                           invokeRestart("muffleWarning")
[17:40:22.859]                       }
[17:40:22.859]                       else if (inherits(cond, "condition")) {
[17:40:22.859]                         if (!is.null(pattern)) {
[17:40:22.859]                           computeRestarts <- base::computeRestarts
[17:40:22.859]                           grepl <- base::grepl
[17:40:22.859]                           restarts <- computeRestarts(cond)
[17:40:22.859]                           for (restart in restarts) {
[17:40:22.859]                             name <- restart$name
[17:40:22.859]                             if (is.null(name)) 
[17:40:22.859]                               next
[17:40:22.859]                             if (!grepl(pattern, name)) 
[17:40:22.859]                               next
[17:40:22.859]                             invokeRestart(restart)
[17:40:22.859]                             muffled <- TRUE
[17:40:22.859]                             break
[17:40:22.859]                           }
[17:40:22.859]                         }
[17:40:22.859]                       }
[17:40:22.859]                       invisible(muffled)
[17:40:22.859]                     }
[17:40:22.859]                     muffleCondition(cond, pattern = "^muffle")
[17:40:22.859]                   }
[17:40:22.859]                 }
[17:40:22.859]             }
[17:40:22.859]         }))
[17:40:22.859]     }, error = function(ex) {
[17:40:22.859]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:22.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:22.859]                 ...future.rng), started = ...future.startTime, 
[17:40:22.859]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:22.859]             version = "1.8"), class = "FutureResult")
[17:40:22.859]     }, finally = {
[17:40:22.859]         if (!identical(...future.workdir, getwd())) 
[17:40:22.859]             setwd(...future.workdir)
[17:40:22.859]         {
[17:40:22.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:22.859]                 ...future.oldOptions$nwarnings <- NULL
[17:40:22.859]             }
[17:40:22.859]             base::options(...future.oldOptions)
[17:40:22.859]             if (.Platform$OS.type == "windows") {
[17:40:22.859]                 old_names <- names(...future.oldEnvVars)
[17:40:22.859]                 envs <- base::Sys.getenv()
[17:40:22.859]                 names <- names(envs)
[17:40:22.859]                 common <- intersect(names, old_names)
[17:40:22.859]                 added <- setdiff(names, old_names)
[17:40:22.859]                 removed <- setdiff(old_names, names)
[17:40:22.859]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:22.859]                   envs[common]]
[17:40:22.859]                 NAMES <- toupper(changed)
[17:40:22.859]                 args <- list()
[17:40:22.859]                 for (kk in seq_along(NAMES)) {
[17:40:22.859]                   name <- changed[[kk]]
[17:40:22.859]                   NAME <- NAMES[[kk]]
[17:40:22.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.859]                     next
[17:40:22.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.859]                 }
[17:40:22.859]                 NAMES <- toupper(added)
[17:40:22.859]                 for (kk in seq_along(NAMES)) {
[17:40:22.859]                   name <- added[[kk]]
[17:40:22.859]                   NAME <- NAMES[[kk]]
[17:40:22.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.859]                     next
[17:40:22.859]                   args[[name]] <- ""
[17:40:22.859]                 }
[17:40:22.859]                 NAMES <- toupper(removed)
[17:40:22.859]                 for (kk in seq_along(NAMES)) {
[17:40:22.859]                   name <- removed[[kk]]
[17:40:22.859]                   NAME <- NAMES[[kk]]
[17:40:22.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:22.859]                     next
[17:40:22.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:22.859]                 }
[17:40:22.859]                 if (length(args) > 0) 
[17:40:22.859]                   base::do.call(base::Sys.setenv, args = args)
[17:40:22.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:22.859]             }
[17:40:22.859]             else {
[17:40:22.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:22.859]             }
[17:40:22.859]             {
[17:40:22.859]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:22.859]                   0L) {
[17:40:22.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:22.859]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:22.859]                   base::options(opts)
[17:40:22.859]                 }
[17:40:22.859]                 {
[17:40:22.859]                   {
[17:40:22.859]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:22.859]                     NULL
[17:40:22.859]                   }
[17:40:22.859]                   options(future.plan = NULL)
[17:40:22.859]                   if (is.na(NA_character_)) 
[17:40:22.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:22.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:22.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:22.859]                     .init = FALSE)
[17:40:22.859]                 }
[17:40:22.859]             }
[17:40:22.859]         }
[17:40:22.859]     })
[17:40:22.859]     if (TRUE) {
[17:40:22.859]         base::sink(type = "output", split = FALSE)
[17:40:22.859]         if (TRUE) {
[17:40:22.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:22.859]         }
[17:40:22.859]         else {
[17:40:22.859]             ...future.result["stdout"] <- base::list(NULL)
[17:40:22.859]         }
[17:40:22.859]         base::close(...future.stdout)
[17:40:22.859]         ...future.stdout <- NULL
[17:40:22.859]     }
[17:40:22.859]     ...future.result$conditions <- ...future.conditions
[17:40:22.859]     ...future.result$finished <- base::Sys.time()
[17:40:22.859]     ...future.result
[17:40:22.859] }
[17:40:22.862] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[17:40:22.862] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[17:40:22.905] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[17:40:22.905] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[17:40:22.905] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[17:40:22.905] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[17:40:22.906] MultisessionFuture started
[17:40:22.906] - Launch lazy future ... done
[17:40:22.906] run() for ‘MultisessionFuture’ ... done
[17:40:22.906] result() for ClusterFuture ...
[17:40:22.907] receiveMessageFromWorker() for ClusterFuture ...
[17:40:22.907] - Validating connection of MultisessionFuture
[17:40:22.978] - received message: FutureResult
[17:40:22.978] - Received FutureResult
[17:40:22.978] - Erased future from FutureRegistry
[17:40:22.978] result() for ClusterFuture ...
[17:40:22.978] - result already collected: FutureResult
[17:40:22.978] result() for ClusterFuture ... done
[17:40:22.978] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:22.978] result() for ClusterFuture ... done
[17:40:22.979] result() for ClusterFuture ...
[17:40:22.979] - result already collected: FutureResult
[17:40:22.979] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[17:40:22.984] getGlobalsAndPackages() ...
[17:40:22.984] Searching for globals...
[17:40:22.986] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[17:40:22.986] Searching for globals ... DONE
[17:40:22.986] Resolving globals: FALSE
[17:40:22.986] The total size of the 1 globals is 128 bytes (128 bytes)
[17:40:22.987] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[17:40:22.987] - globals: [1] ‘data’
[17:40:22.987] - packages: [1] ‘future’
[17:40:22.987] getGlobalsAndPackages() ... DONE
[17:40:22.987] run() for ‘Future’ ...
[17:40:22.988] - state: ‘created’
[17:40:22.988] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:23.001] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:23.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:23.002]   - Field: ‘node’
[17:40:23.002]   - Field: ‘label’
[17:40:23.002]   - Field: ‘local’
[17:40:23.002]   - Field: ‘owner’
[17:40:23.002]   - Field: ‘envir’
[17:40:23.002]   - Field: ‘workers’
[17:40:23.002]   - Field: ‘packages’
[17:40:23.002]   - Field: ‘gc’
[17:40:23.002]   - Field: ‘conditions’
[17:40:23.002]   - Field: ‘persistent’
[17:40:23.002]   - Field: ‘expr’
[17:40:23.003]   - Field: ‘uuid’
[17:40:23.003]   - Field: ‘seed’
[17:40:23.003]   - Field: ‘version’
[17:40:23.003]   - Field: ‘result’
[17:40:23.003]   - Field: ‘asynchronous’
[17:40:23.003]   - Field: ‘calls’
[17:40:23.003]   - Field: ‘globals’
[17:40:23.003]   - Field: ‘stdout’
[17:40:23.003]   - Field: ‘earlySignal’
[17:40:23.003]   - Field: ‘lazy’
[17:40:23.003]   - Field: ‘state’
[17:40:23.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:23.004] - Launch lazy future ...
[17:40:23.004] Packages needed by the future expression (n = 1): ‘future’
[17:40:23.004] Packages needed by future strategies (n = 1): ‘future’
[17:40:23.005] {
[17:40:23.005]     {
[17:40:23.005]         {
[17:40:23.005]             ...future.startTime <- base::Sys.time()
[17:40:23.005]             {
[17:40:23.005]                 {
[17:40:23.005]                   {
[17:40:23.005]                     {
[17:40:23.005]                       {
[17:40:23.005]                         base::local({
[17:40:23.005]                           has_future <- base::requireNamespace("future", 
[17:40:23.005]                             quietly = TRUE)
[17:40:23.005]                           if (has_future) {
[17:40:23.005]                             ns <- base::getNamespace("future")
[17:40:23.005]                             version <- ns[[".package"]][["version"]]
[17:40:23.005]                             if (is.null(version)) 
[17:40:23.005]                               version <- utils::packageVersion("future")
[17:40:23.005]                           }
[17:40:23.005]                           else {
[17:40:23.005]                             version <- NULL
[17:40:23.005]                           }
[17:40:23.005]                           if (!has_future || version < "1.8.0") {
[17:40:23.005]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:23.005]                               "", base::R.version$version.string), 
[17:40:23.005]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:23.005]                                 base::R.version$platform, 8 * 
[17:40:23.005]                                   base::.Machine$sizeof.pointer), 
[17:40:23.005]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:23.005]                                 "release", "version")], collapse = " "), 
[17:40:23.005]                               hostname = base::Sys.info()[["nodename"]])
[17:40:23.005]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:23.005]                               info)
[17:40:23.005]                             info <- base::paste(info, collapse = "; ")
[17:40:23.005]                             if (!has_future) {
[17:40:23.005]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:23.005]                                 info)
[17:40:23.005]                             }
[17:40:23.005]                             else {
[17:40:23.005]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:23.005]                                 info, version)
[17:40:23.005]                             }
[17:40:23.005]                             base::stop(msg)
[17:40:23.005]                           }
[17:40:23.005]                         })
[17:40:23.005]                       }
[17:40:23.005]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:23.005]                       base::options(mc.cores = 1L)
[17:40:23.005]                     }
[17:40:23.005]                     base::local({
[17:40:23.005]                       for (pkg in "future") {
[17:40:23.005]                         base::loadNamespace(pkg)
[17:40:23.005]                         base::library(pkg, character.only = TRUE)
[17:40:23.005]                       }
[17:40:23.005]                     })
[17:40:23.005]                   }
[17:40:23.005]                   ...future.strategy.old <- future::plan("list")
[17:40:23.005]                   options(future.plan = NULL)
[17:40:23.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:23.005]                   future::plan(list(b = function (..., workers = availableCores(), 
[17:40:23.005]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:40:23.005]                     envir = parent.frame()) 
[17:40:23.005]                   {
[17:40:23.005]                     if (is.function(workers)) 
[17:40:23.005]                       workers <- workers()
[17:40:23.005]                     workers <- structure(as.integer(workers), 
[17:40:23.005]                       class = class(workers))
[17:40:23.005]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:40:23.005]                       workers >= 1)
[17:40:23.005]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:40:23.005]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:40:23.005]                     }
[17:40:23.005]                     future <- MultisessionFuture(..., workers = workers, 
[17:40:23.005]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:40:23.005]                       envir = envir)
[17:40:23.005]                     if (!future$lazy) 
[17:40:23.005]                       future <- run(future)
[17:40:23.005]                     invisible(future)
[17:40:23.005]                   }), .cleanup = FALSE, .init = FALSE)
[17:40:23.005]                 }
[17:40:23.005]                 ...future.workdir <- getwd()
[17:40:23.005]             }
[17:40:23.005]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:23.005]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:23.005]         }
[17:40:23.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:23.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:23.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:23.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:23.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:23.005]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:23.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:23.005]             base::names(...future.oldOptions))
[17:40:23.005]     }
[17:40:23.005]     if (FALSE) {
[17:40:23.005]     }
[17:40:23.005]     else {
[17:40:23.005]         if (TRUE) {
[17:40:23.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:23.005]                 open = "w")
[17:40:23.005]         }
[17:40:23.005]         else {
[17:40:23.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:23.005]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:23.005]         }
[17:40:23.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:23.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:23.005]             base::sink(type = "output", split = FALSE)
[17:40:23.005]             base::close(...future.stdout)
[17:40:23.005]         }, add = TRUE)
[17:40:23.005]     }
[17:40:23.005]     ...future.frame <- base::sys.nframe()
[17:40:23.005]     ...future.conditions <- base::list()
[17:40:23.005]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:23.005]     if (FALSE) {
[17:40:23.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:23.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:23.005]     }
[17:40:23.005]     ...future.result <- base::tryCatch({
[17:40:23.005]         base::withCallingHandlers({
[17:40:23.005]             ...future.value <- base::withVisible(base::local({
[17:40:23.005]                 ...future.makeSendCondition <- base::local({
[17:40:23.005]                   sendCondition <- NULL
[17:40:23.005]                   function(frame = 1L) {
[17:40:23.005]                     if (is.function(sendCondition)) 
[17:40:23.005]                       return(sendCondition)
[17:40:23.005]                     ns <- getNamespace("parallel")
[17:40:23.005]                     if (exists("sendData", mode = "function", 
[17:40:23.005]                       envir = ns)) {
[17:40:23.005]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:23.005]                         envir = ns)
[17:40:23.005]                       envir <- sys.frame(frame)
[17:40:23.005]                       master <- NULL
[17:40:23.005]                       while (!identical(envir, .GlobalEnv) && 
[17:40:23.005]                         !identical(envir, emptyenv())) {
[17:40:23.005]                         if (exists("master", mode = "list", envir = envir, 
[17:40:23.005]                           inherits = FALSE)) {
[17:40:23.005]                           master <- get("master", mode = "list", 
[17:40:23.005]                             envir = envir, inherits = FALSE)
[17:40:23.005]                           if (inherits(master, c("SOCKnode", 
[17:40:23.005]                             "SOCK0node"))) {
[17:40:23.005]                             sendCondition <<- function(cond) {
[17:40:23.005]                               data <- list(type = "VALUE", value = cond, 
[17:40:23.005]                                 success = TRUE)
[17:40:23.005]                               parallel_sendData(master, data)
[17:40:23.005]                             }
[17:40:23.005]                             return(sendCondition)
[17:40:23.005]                           }
[17:40:23.005]                         }
[17:40:23.005]                         frame <- frame + 1L
[17:40:23.005]                         envir <- sys.frame(frame)
[17:40:23.005]                       }
[17:40:23.005]                     }
[17:40:23.005]                     sendCondition <<- function(cond) NULL
[17:40:23.005]                   }
[17:40:23.005]                 })
[17:40:23.005]                 withCallingHandlers({
[17:40:23.005]                   {
[17:40:23.005]                     value(future(subset(data, a == 2)))
[17:40:23.005]                   }
[17:40:23.005]                 }, immediateCondition = function(cond) {
[17:40:23.005]                   sendCondition <- ...future.makeSendCondition()
[17:40:23.005]                   sendCondition(cond)
[17:40:23.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:23.005]                   {
[17:40:23.005]                     inherits <- base::inherits
[17:40:23.005]                     invokeRestart <- base::invokeRestart
[17:40:23.005]                     is.null <- base::is.null
[17:40:23.005]                     muffled <- FALSE
[17:40:23.005]                     if (inherits(cond, "message")) {
[17:40:23.005]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:23.005]                       if (muffled) 
[17:40:23.005]                         invokeRestart("muffleMessage")
[17:40:23.005]                     }
[17:40:23.005]                     else if (inherits(cond, "warning")) {
[17:40:23.005]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:23.005]                       if (muffled) 
[17:40:23.005]                         invokeRestart("muffleWarning")
[17:40:23.005]                     }
[17:40:23.005]                     else if (inherits(cond, "condition")) {
[17:40:23.005]                       if (!is.null(pattern)) {
[17:40:23.005]                         computeRestarts <- base::computeRestarts
[17:40:23.005]                         grepl <- base::grepl
[17:40:23.005]                         restarts <- computeRestarts(cond)
[17:40:23.005]                         for (restart in restarts) {
[17:40:23.005]                           name <- restart$name
[17:40:23.005]                           if (is.null(name)) 
[17:40:23.005]                             next
[17:40:23.005]                           if (!grepl(pattern, name)) 
[17:40:23.005]                             next
[17:40:23.005]                           invokeRestart(restart)
[17:40:23.005]                           muffled <- TRUE
[17:40:23.005]                           break
[17:40:23.005]                         }
[17:40:23.005]                       }
[17:40:23.005]                     }
[17:40:23.005]                     invisible(muffled)
[17:40:23.005]                   }
[17:40:23.005]                   muffleCondition(cond)
[17:40:23.005]                 })
[17:40:23.005]             }))
[17:40:23.005]             future::FutureResult(value = ...future.value$value, 
[17:40:23.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:23.005]                   ...future.rng), globalenv = if (FALSE) 
[17:40:23.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:23.005]                     ...future.globalenv.names))
[17:40:23.005]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:23.005]         }, condition = base::local({
[17:40:23.005]             c <- base::c
[17:40:23.005]             inherits <- base::inherits
[17:40:23.005]             invokeRestart <- base::invokeRestart
[17:40:23.005]             length <- base::length
[17:40:23.005]             list <- base::list
[17:40:23.005]             seq.int <- base::seq.int
[17:40:23.005]             signalCondition <- base::signalCondition
[17:40:23.005]             sys.calls <- base::sys.calls
[17:40:23.005]             `[[` <- base::`[[`
[17:40:23.005]             `+` <- base::`+`
[17:40:23.005]             `<<-` <- base::`<<-`
[17:40:23.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:23.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:23.005]                   3L)]
[17:40:23.005]             }
[17:40:23.005]             function(cond) {
[17:40:23.005]                 is_error <- inherits(cond, "error")
[17:40:23.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:23.005]                   NULL)
[17:40:23.005]                 if (is_error) {
[17:40:23.005]                   sessionInformation <- function() {
[17:40:23.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:23.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:23.005]                       search = base::search(), system = base::Sys.info())
[17:40:23.005]                   }
[17:40:23.005]                   ...future.conditions[[length(...future.conditions) + 
[17:40:23.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:23.005]                     cond$call), session = sessionInformation(), 
[17:40:23.005]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:23.005]                   signalCondition(cond)
[17:40:23.005]                 }
[17:40:23.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:23.005]                 "immediateCondition"))) {
[17:40:23.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:23.005]                   ...future.conditions[[length(...future.conditions) + 
[17:40:23.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:23.005]                   if (TRUE && !signal) {
[17:40:23.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:23.005]                     {
[17:40:23.005]                       inherits <- base::inherits
[17:40:23.005]                       invokeRestart <- base::invokeRestart
[17:40:23.005]                       is.null <- base::is.null
[17:40:23.005]                       muffled <- FALSE
[17:40:23.005]                       if (inherits(cond, "message")) {
[17:40:23.005]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:23.005]                         if (muffled) 
[17:40:23.005]                           invokeRestart("muffleMessage")
[17:40:23.005]                       }
[17:40:23.005]                       else if (inherits(cond, "warning")) {
[17:40:23.005]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:23.005]                         if (muffled) 
[17:40:23.005]                           invokeRestart("muffleWarning")
[17:40:23.005]                       }
[17:40:23.005]                       else if (inherits(cond, "condition")) {
[17:40:23.005]                         if (!is.null(pattern)) {
[17:40:23.005]                           computeRestarts <- base::computeRestarts
[17:40:23.005]                           grepl <- base::grepl
[17:40:23.005]                           restarts <- computeRestarts(cond)
[17:40:23.005]                           for (restart in restarts) {
[17:40:23.005]                             name <- restart$name
[17:40:23.005]                             if (is.null(name)) 
[17:40:23.005]                               next
[17:40:23.005]                             if (!grepl(pattern, name)) 
[17:40:23.005]                               next
[17:40:23.005]                             invokeRestart(restart)
[17:40:23.005]                             muffled <- TRUE
[17:40:23.005]                             break
[17:40:23.005]                           }
[17:40:23.005]                         }
[17:40:23.005]                       }
[17:40:23.005]                       invisible(muffled)
[17:40:23.005]                     }
[17:40:23.005]                     muffleCondition(cond, pattern = "^muffle")
[17:40:23.005]                   }
[17:40:23.005]                 }
[17:40:23.005]                 else {
[17:40:23.005]                   if (TRUE) {
[17:40:23.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:23.005]                     {
[17:40:23.005]                       inherits <- base::inherits
[17:40:23.005]                       invokeRestart <- base::invokeRestart
[17:40:23.005]                       is.null <- base::is.null
[17:40:23.005]                       muffled <- FALSE
[17:40:23.005]                       if (inherits(cond, "message")) {
[17:40:23.005]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:23.005]                         if (muffled) 
[17:40:23.005]                           invokeRestart("muffleMessage")
[17:40:23.005]                       }
[17:40:23.005]                       else if (inherits(cond, "warning")) {
[17:40:23.005]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:23.005]                         if (muffled) 
[17:40:23.005]                           invokeRestart("muffleWarning")
[17:40:23.005]                       }
[17:40:23.005]                       else if (inherits(cond, "condition")) {
[17:40:23.005]                         if (!is.null(pattern)) {
[17:40:23.005]                           computeRestarts <- base::computeRestarts
[17:40:23.005]                           grepl <- base::grepl
[17:40:23.005]                           restarts <- computeRestarts(cond)
[17:40:23.005]                           for (restart in restarts) {
[17:40:23.005]                             name <- restart$name
[17:40:23.005]                             if (is.null(name)) 
[17:40:23.005]                               next
[17:40:23.005]                             if (!grepl(pattern, name)) 
[17:40:23.005]                               next
[17:40:23.005]                             invokeRestart(restart)
[17:40:23.005]                             muffled <- TRUE
[17:40:23.005]                             break
[17:40:23.005]                           }
[17:40:23.005]                         }
[17:40:23.005]                       }
[17:40:23.005]                       invisible(muffled)
[17:40:23.005]                     }
[17:40:23.005]                     muffleCondition(cond, pattern = "^muffle")
[17:40:23.005]                   }
[17:40:23.005]                 }
[17:40:23.005]             }
[17:40:23.005]         }))
[17:40:23.005]     }, error = function(ex) {
[17:40:23.005]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:23.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:23.005]                 ...future.rng), started = ...future.startTime, 
[17:40:23.005]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:23.005]             version = "1.8"), class = "FutureResult")
[17:40:23.005]     }, finally = {
[17:40:23.005]         if (!identical(...future.workdir, getwd())) 
[17:40:23.005]             setwd(...future.workdir)
[17:40:23.005]         {
[17:40:23.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:23.005]                 ...future.oldOptions$nwarnings <- NULL
[17:40:23.005]             }
[17:40:23.005]             base::options(...future.oldOptions)
[17:40:23.005]             if (.Platform$OS.type == "windows") {
[17:40:23.005]                 old_names <- names(...future.oldEnvVars)
[17:40:23.005]                 envs <- base::Sys.getenv()
[17:40:23.005]                 names <- names(envs)
[17:40:23.005]                 common <- intersect(names, old_names)
[17:40:23.005]                 added <- setdiff(names, old_names)
[17:40:23.005]                 removed <- setdiff(old_names, names)
[17:40:23.005]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:23.005]                   envs[common]]
[17:40:23.005]                 NAMES <- toupper(changed)
[17:40:23.005]                 args <- list()
[17:40:23.005]                 for (kk in seq_along(NAMES)) {
[17:40:23.005]                   name <- changed[[kk]]
[17:40:23.005]                   NAME <- NAMES[[kk]]
[17:40:23.005]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:23.005]                     next
[17:40:23.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:23.005]                 }
[17:40:23.005]                 NAMES <- toupper(added)
[17:40:23.005]                 for (kk in seq_along(NAMES)) {
[17:40:23.005]                   name <- added[[kk]]
[17:40:23.005]                   NAME <- NAMES[[kk]]
[17:40:23.005]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:23.005]                     next
[17:40:23.005]                   args[[name]] <- ""
[17:40:23.005]                 }
[17:40:23.005]                 NAMES <- toupper(removed)
[17:40:23.005]                 for (kk in seq_along(NAMES)) {
[17:40:23.005]                   name <- removed[[kk]]
[17:40:23.005]                   NAME <- NAMES[[kk]]
[17:40:23.005]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:23.005]                     next
[17:40:23.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:23.005]                 }
[17:40:23.005]                 if (length(args) > 0) 
[17:40:23.005]                   base::do.call(base::Sys.setenv, args = args)
[17:40:23.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:23.005]             }
[17:40:23.005]             else {
[17:40:23.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:23.005]             }
[17:40:23.005]             {
[17:40:23.005]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:23.005]                   0L) {
[17:40:23.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:23.005]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:23.005]                   base::options(opts)
[17:40:23.005]                 }
[17:40:23.005]                 {
[17:40:23.005]                   {
[17:40:23.005]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:23.005]                     NULL
[17:40:23.005]                   }
[17:40:23.005]                   options(future.plan = NULL)
[17:40:23.005]                   if (is.na(NA_character_)) 
[17:40:23.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:23.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:23.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:23.005]                     .init = FALSE)
[17:40:23.005]                 }
[17:40:23.005]             }
[17:40:23.005]         }
[17:40:23.005]     })
[17:40:23.005]     if (TRUE) {
[17:40:23.005]         base::sink(type = "output", split = FALSE)
[17:40:23.005]         if (TRUE) {
[17:40:23.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:23.005]         }
[17:40:23.005]         else {
[17:40:23.005]             ...future.result["stdout"] <- base::list(NULL)
[17:40:23.005]         }
[17:40:23.005]         base::close(...future.stdout)
[17:40:23.005]         ...future.stdout <- NULL
[17:40:23.005]     }
[17:40:23.005]     ...future.result$conditions <- ...future.conditions
[17:40:23.005]     ...future.result$finished <- base::Sys.time()
[17:40:23.005]     ...future.result
[17:40:23.005] }
[17:40:23.007] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[17:40:23.008] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[17:40:23.008] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[17:40:23.008] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[17:40:23.009] MultisessionFuture started
[17:40:23.009] - Launch lazy future ... done
[17:40:23.009] run() for ‘MultisessionFuture’ ... done
[17:40:23.009] result() for ClusterFuture ...
[17:40:23.009] receiveMessageFromWorker() for ClusterFuture ...
[17:40:23.009] - Validating connection of MultisessionFuture
[17:40:23.067] - received message: FutureResult
[17:40:23.067] - Received FutureResult
[17:40:23.067] - Erased future from FutureRegistry
[17:40:23.067] result() for ClusterFuture ...
[17:40:23.067] - result already collected: FutureResult
[17:40:23.067] result() for ClusterFuture ... done
[17:40:23.067] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:23.067] result() for ClusterFuture ... done
[17:40:23.068] result() for ClusterFuture ...
[17:40:23.068] - result already collected: FutureResult
[17:40:23.068] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[17:40:23.068] plan(): Setting new future strategy stack:
[17:40:23.069] List of future strategies:
[17:40:23.069] 1. FutureStrategy:
[17:40:23.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:23.069]    - tweaked: FALSE
[17:40:23.069]    - call: future::plan(oplan)
[17:40:23.069] plan(): nbrOfWorkers() = 1
> 
