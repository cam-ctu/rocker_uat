
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:31:56.545] plan(): Setting new future strategy stack:
[09:31:56.545] List of future strategies:
[09:31:56.545] 1. sequential:
[09:31:56.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.545]    - tweaked: FALSE
[09:31:56.545]    - call: future::plan("sequential")
[09:31:56.556] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[09:31:56.608] plan(): Setting new future strategy stack:
[09:31:56.608] List of future strategies:
[09:31:56.608] 1. sequential:
[09:31:56.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.608]    - tweaked: FALSE
[09:31:56.608]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.608] 2. sequential:
[09:31:56.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.608]    - tweaked: FALSE
[09:31:56.608]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.618] plan(): nbrOfWorkers() = 1
[09:31:56.621] getGlobalsAndPackages() ...
[09:31:56.621] Searching for globals...
[09:31:56.641] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:56.641] Searching for globals ... DONE
[09:31:56.641] Resolving globals: FALSE
[09:31:56.642] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[09:31:56.643] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:56.644] - globals: [2] ‘nested’, ‘strategy2’
[09:31:56.644] - packages: [1] ‘future’
[09:31:56.644] getGlobalsAndPackages() ... DONE
[09:31:56.645] run() for ‘Future’ ...
[09:31:56.645] - state: ‘created’
[09:31:56.645] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.646] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.646]   - Field: ‘label’
[09:31:56.646]   - Field: ‘local’
[09:31:56.646]   - Field: ‘owner’
[09:31:56.646]   - Field: ‘envir’
[09:31:56.646]   - Field: ‘packages’
[09:31:56.646]   - Field: ‘gc’
[09:31:56.646]   - Field: ‘conditions’
[09:31:56.646]   - Field: ‘expr’
[09:31:56.647]   - Field: ‘uuid’
[09:31:56.647]   - Field: ‘seed’
[09:31:56.647]   - Field: ‘version’
[09:31:56.647]   - Field: ‘result’
[09:31:56.647]   - Field: ‘asynchronous’
[09:31:56.647]   - Field: ‘calls’
[09:31:56.647]   - Field: ‘globals’
[09:31:56.647]   - Field: ‘stdout’
[09:31:56.647]   - Field: ‘earlySignal’
[09:31:56.647]   - Field: ‘lazy’
[09:31:56.647]   - Field: ‘state’
[09:31:56.647] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.648] - Launch lazy future ...
[09:31:56.648] Packages needed by the future expression (n = 1): ‘future’
[09:31:56.648] Packages needed by future strategies (n = 1): ‘future’
[09:31:56.649] {
[09:31:56.649]     {
[09:31:56.649]         {
[09:31:56.649]             ...future.startTime <- base::Sys.time()
[09:31:56.649]             {
[09:31:56.649]                 {
[09:31:56.649]                   {
[09:31:56.649]                     {
[09:31:56.649]                       base::local({
[09:31:56.649]                         has_future <- base::requireNamespace("future", 
[09:31:56.649]                           quietly = TRUE)
[09:31:56.649]                         if (has_future) {
[09:31:56.649]                           ns <- base::getNamespace("future")
[09:31:56.649]                           version <- ns[[".package"]][["version"]]
[09:31:56.649]                           if (is.null(version)) 
[09:31:56.649]                             version <- utils::packageVersion("future")
[09:31:56.649]                         }
[09:31:56.649]                         else {
[09:31:56.649]                           version <- NULL
[09:31:56.649]                         }
[09:31:56.649]                         if (!has_future || version < "1.8.0") {
[09:31:56.649]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.649]                             "", base::R.version$version.string), 
[09:31:56.649]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.649]                               "release", "version")], collapse = " "), 
[09:31:56.649]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.649]                             info)
[09:31:56.649]                           info <- base::paste(info, collapse = "; ")
[09:31:56.649]                           if (!has_future) {
[09:31:56.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.649]                               info)
[09:31:56.649]                           }
[09:31:56.649]                           else {
[09:31:56.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.649]                               info, version)
[09:31:56.649]                           }
[09:31:56.649]                           base::stop(msg)
[09:31:56.649]                         }
[09:31:56.649]                       })
[09:31:56.649]                     }
[09:31:56.649]                     base::local({
[09:31:56.649]                       for (pkg in "future") {
[09:31:56.649]                         base::loadNamespace(pkg)
[09:31:56.649]                         base::library(pkg, character.only = TRUE)
[09:31:56.649]                       }
[09:31:56.649]                     })
[09:31:56.649]                   }
[09:31:56.649]                   ...future.strategy.old <- future::plan("list")
[09:31:56.649]                   options(future.plan = NULL)
[09:31:56.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.649]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:56.649]                   {
[09:31:56.649]                     future <- SequentialFuture(..., envir = envir)
[09:31:56.649]                     if (!future$lazy) 
[09:31:56.649]                       future <- run(future)
[09:31:56.649]                     invisible(future)
[09:31:56.649]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:56.649]                 }
[09:31:56.649]                 ...future.workdir <- getwd()
[09:31:56.649]             }
[09:31:56.649]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.649]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.649]         }
[09:31:56.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.649]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.649]             base::names(...future.oldOptions))
[09:31:56.649]     }
[09:31:56.649]     if (FALSE) {
[09:31:56.649]     }
[09:31:56.649]     else {
[09:31:56.649]         if (TRUE) {
[09:31:56.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.649]                 open = "w")
[09:31:56.649]         }
[09:31:56.649]         else {
[09:31:56.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.649]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.649]         }
[09:31:56.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.649]             base::sink(type = "output", split = FALSE)
[09:31:56.649]             base::close(...future.stdout)
[09:31:56.649]         }, add = TRUE)
[09:31:56.649]     }
[09:31:56.649]     ...future.frame <- base::sys.nframe()
[09:31:56.649]     ...future.conditions <- base::list()
[09:31:56.649]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.649]     if (FALSE) {
[09:31:56.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.649]     }
[09:31:56.649]     ...future.result <- base::tryCatch({
[09:31:56.649]         base::withCallingHandlers({
[09:31:56.649]             ...future.value <- base::withVisible(base::local({
[09:31:56.649]                 a <- 1L
[09:31:56.649]                 plan_a <- unclass(future::plan("list"))
[09:31:56.649]                 nested_a <- nested[-1]
[09:31:56.649]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:56.649]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.649]                   strategy2))
[09:31:56.649]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:56.649]                   "init") <- NULL
[09:31:56.649]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:56.649]                   "init") <- NULL
[09:31:56.649]                 stopifnot(all.equal(plan_a, nested_a))
[09:31:56.649]                 y %<-% {
[09:31:56.649]                   b <- 2L
[09:31:56.649]                   plan_b <- future::plan("list")
[09:31:56.649]                   nested_b <- nested_a[-1]
[09:31:56.649]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:56.649]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.649]                     "sequential"))
[09:31:56.649]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:56.649]                     b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:56.649]                 }
[09:31:56.649]                 y
[09:31:56.649]             }))
[09:31:56.649]             future::FutureResult(value = ...future.value$value, 
[09:31:56.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.649]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.649]                     ...future.globalenv.names))
[09:31:56.649]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.649]         }, condition = base::local({
[09:31:56.649]             c <- base::c
[09:31:56.649]             inherits <- base::inherits
[09:31:56.649]             invokeRestart <- base::invokeRestart
[09:31:56.649]             length <- base::length
[09:31:56.649]             list <- base::list
[09:31:56.649]             seq.int <- base::seq.int
[09:31:56.649]             signalCondition <- base::signalCondition
[09:31:56.649]             sys.calls <- base::sys.calls
[09:31:56.649]             `[[` <- base::`[[`
[09:31:56.649]             `+` <- base::`+`
[09:31:56.649]             `<<-` <- base::`<<-`
[09:31:56.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.649]                   3L)]
[09:31:56.649]             }
[09:31:56.649]             function(cond) {
[09:31:56.649]                 is_error <- inherits(cond, "error")
[09:31:56.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.649]                   NULL)
[09:31:56.649]                 if (is_error) {
[09:31:56.649]                   sessionInformation <- function() {
[09:31:56.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.649]                       search = base::search(), system = base::Sys.info())
[09:31:56.649]                   }
[09:31:56.649]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.649]                     cond$call), session = sessionInformation(), 
[09:31:56.649]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.649]                   signalCondition(cond)
[09:31:56.649]                 }
[09:31:56.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.649]                 "immediateCondition"))) {
[09:31:56.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.649]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.649]                   if (TRUE && !signal) {
[09:31:56.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.649]                     {
[09:31:56.649]                       inherits <- base::inherits
[09:31:56.649]                       invokeRestart <- base::invokeRestart
[09:31:56.649]                       is.null <- base::is.null
[09:31:56.649]                       muffled <- FALSE
[09:31:56.649]                       if (inherits(cond, "message")) {
[09:31:56.649]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.649]                         if (muffled) 
[09:31:56.649]                           invokeRestart("muffleMessage")
[09:31:56.649]                       }
[09:31:56.649]                       else if (inherits(cond, "warning")) {
[09:31:56.649]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.649]                         if (muffled) 
[09:31:56.649]                           invokeRestart("muffleWarning")
[09:31:56.649]                       }
[09:31:56.649]                       else if (inherits(cond, "condition")) {
[09:31:56.649]                         if (!is.null(pattern)) {
[09:31:56.649]                           computeRestarts <- base::computeRestarts
[09:31:56.649]                           grepl <- base::grepl
[09:31:56.649]                           restarts <- computeRestarts(cond)
[09:31:56.649]                           for (restart in restarts) {
[09:31:56.649]                             name <- restart$name
[09:31:56.649]                             if (is.null(name)) 
[09:31:56.649]                               next
[09:31:56.649]                             if (!grepl(pattern, name)) 
[09:31:56.649]                               next
[09:31:56.649]                             invokeRestart(restart)
[09:31:56.649]                             muffled <- TRUE
[09:31:56.649]                             break
[09:31:56.649]                           }
[09:31:56.649]                         }
[09:31:56.649]                       }
[09:31:56.649]                       invisible(muffled)
[09:31:56.649]                     }
[09:31:56.649]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.649]                   }
[09:31:56.649]                 }
[09:31:56.649]                 else {
[09:31:56.649]                   if (TRUE) {
[09:31:56.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.649]                     {
[09:31:56.649]                       inherits <- base::inherits
[09:31:56.649]                       invokeRestart <- base::invokeRestart
[09:31:56.649]                       is.null <- base::is.null
[09:31:56.649]                       muffled <- FALSE
[09:31:56.649]                       if (inherits(cond, "message")) {
[09:31:56.649]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.649]                         if (muffled) 
[09:31:56.649]                           invokeRestart("muffleMessage")
[09:31:56.649]                       }
[09:31:56.649]                       else if (inherits(cond, "warning")) {
[09:31:56.649]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.649]                         if (muffled) 
[09:31:56.649]                           invokeRestart("muffleWarning")
[09:31:56.649]                       }
[09:31:56.649]                       else if (inherits(cond, "condition")) {
[09:31:56.649]                         if (!is.null(pattern)) {
[09:31:56.649]                           computeRestarts <- base::computeRestarts
[09:31:56.649]                           grepl <- base::grepl
[09:31:56.649]                           restarts <- computeRestarts(cond)
[09:31:56.649]                           for (restart in restarts) {
[09:31:56.649]                             name <- restart$name
[09:31:56.649]                             if (is.null(name)) 
[09:31:56.649]                               next
[09:31:56.649]                             if (!grepl(pattern, name)) 
[09:31:56.649]                               next
[09:31:56.649]                             invokeRestart(restart)
[09:31:56.649]                             muffled <- TRUE
[09:31:56.649]                             break
[09:31:56.649]                           }
[09:31:56.649]                         }
[09:31:56.649]                       }
[09:31:56.649]                       invisible(muffled)
[09:31:56.649]                     }
[09:31:56.649]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.649]                   }
[09:31:56.649]                 }
[09:31:56.649]             }
[09:31:56.649]         }))
[09:31:56.649]     }, error = function(ex) {
[09:31:56.649]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.649]                 ...future.rng), started = ...future.startTime, 
[09:31:56.649]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.649]             version = "1.8"), class = "FutureResult")
[09:31:56.649]     }, finally = {
[09:31:56.649]         if (!identical(...future.workdir, getwd())) 
[09:31:56.649]             setwd(...future.workdir)
[09:31:56.649]         {
[09:31:56.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.649]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.649]             }
[09:31:56.649]             base::options(...future.oldOptions)
[09:31:56.649]             if (.Platform$OS.type == "windows") {
[09:31:56.649]                 old_names <- names(...future.oldEnvVars)
[09:31:56.649]                 envs <- base::Sys.getenv()
[09:31:56.649]                 names <- names(envs)
[09:31:56.649]                 common <- intersect(names, old_names)
[09:31:56.649]                 added <- setdiff(names, old_names)
[09:31:56.649]                 removed <- setdiff(old_names, names)
[09:31:56.649]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.649]                   envs[common]]
[09:31:56.649]                 NAMES <- toupper(changed)
[09:31:56.649]                 args <- list()
[09:31:56.649]                 for (kk in seq_along(NAMES)) {
[09:31:56.649]                   name <- changed[[kk]]
[09:31:56.649]                   NAME <- NAMES[[kk]]
[09:31:56.649]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.649]                     next
[09:31:56.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.649]                 }
[09:31:56.649]                 NAMES <- toupper(added)
[09:31:56.649]                 for (kk in seq_along(NAMES)) {
[09:31:56.649]                   name <- added[[kk]]
[09:31:56.649]                   NAME <- NAMES[[kk]]
[09:31:56.649]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.649]                     next
[09:31:56.649]                   args[[name]] <- ""
[09:31:56.649]                 }
[09:31:56.649]                 NAMES <- toupper(removed)
[09:31:56.649]                 for (kk in seq_along(NAMES)) {
[09:31:56.649]                   name <- removed[[kk]]
[09:31:56.649]                   NAME <- NAMES[[kk]]
[09:31:56.649]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.649]                     next
[09:31:56.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.649]                 }
[09:31:56.649]                 if (length(args) > 0) 
[09:31:56.649]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.649]             }
[09:31:56.649]             else {
[09:31:56.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.649]             }
[09:31:56.649]             {
[09:31:56.649]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.649]                   0L) {
[09:31:56.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.649]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.649]                   base::options(opts)
[09:31:56.649]                 }
[09:31:56.649]                 {
[09:31:56.649]                   {
[09:31:56.649]                     NULL
[09:31:56.649]                     RNGkind("Mersenne-Twister")
[09:31:56.649]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.649]                       inherits = FALSE)
[09:31:56.649]                   }
[09:31:56.649]                   options(future.plan = NULL)
[09:31:56.649]                   if (is.na(NA_character_)) 
[09:31:56.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.649]                     .init = FALSE)
[09:31:56.649]                 }
[09:31:56.649]             }
[09:31:56.649]         }
[09:31:56.649]     })
[09:31:56.649]     if (TRUE) {
[09:31:56.649]         base::sink(type = "output", split = FALSE)
[09:31:56.649]         if (TRUE) {
[09:31:56.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.649]         }
[09:31:56.649]         else {
[09:31:56.649]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.649]         }
[09:31:56.649]         base::close(...future.stdout)
[09:31:56.649]         ...future.stdout <- NULL
[09:31:56.649]     }
[09:31:56.649]     ...future.result$conditions <- ...future.conditions
[09:31:56.649]     ...future.result$finished <- base::Sys.time()
[09:31:56.649]     ...future.result
[09:31:56.649] }
[09:31:56.651] assign_globals() ...
[09:31:56.651] List of 2
[09:31:56.651]  $ nested   :List of 2
[09:31:56.651]   ..$ a:function (..., envir = parent.frame())  
[09:31:56.651]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:56.651]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.651]   ..$ b:function (..., envir = parent.frame())  
[09:31:56.651]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:56.651]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.651]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:56.651]  $ strategy2: chr "sequential"
[09:31:56.651]  - attr(*, "where")=List of 2
[09:31:56.651]   ..$ nested   :<environment: R_EmptyEnv> 
[09:31:56.651]   ..$ strategy2:<environment: R_EmptyEnv> 
[09:31:56.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.651]  - attr(*, "resolved")= logi FALSE
[09:31:56.651]  - attr(*, "total_size")= num 23144
[09:31:56.651]  - attr(*, "already-done")= logi TRUE
[09:31:56.657] - copied ‘nested’ to environment
[09:31:56.657] - copied ‘strategy2’ to environment
[09:31:56.658] assign_globals() ... done
[09:31:56.658] plan(): Setting new future strategy stack:
[09:31:56.658] List of future strategies:
[09:31:56.658] 1. sequential:
[09:31:56.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.658]    - tweaked: FALSE
[09:31:56.658]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.658] plan(): nbrOfWorkers() = 1
[09:31:56.693] plan(): Setting new future strategy stack:
[09:31:56.693] List of future strategies:
[09:31:56.693] 1. sequential:
[09:31:56.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.693]    - tweaked: FALSE
[09:31:56.693]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.693] 2. sequential:
[09:31:56.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.693]    - tweaked: FALSE
[09:31:56.693]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.693] plan(): nbrOfWorkers() = 1
[09:31:56.694] SequentialFuture started (and completed)
[09:31:56.695] signalConditions() ...
[09:31:56.695]  - include = ‘immediateCondition’
[09:31:56.695]  - exclude = 
[09:31:56.695]  - resignal = FALSE
[09:31:56.695]  - Number of conditions: 54
[09:31:56.695] signalConditions() ... done
[09:31:56.695] - Launch lazy future ... done
[09:31:56.695] run() for ‘SequentialFuture’ ... done
[09:31:56.695] signalConditions() ...
[09:31:56.695]  - include = ‘immediateCondition’
[09:31:56.696]  - exclude = 
[09:31:56.696]  - resignal = FALSE
[09:31:56.696]  - Number of conditions: 54
[09:31:56.696] signalConditions() ... done
[09:31:56.696] Future state: ‘finished’
[09:31:56.696] signalConditions() ...
[09:31:56.696]  - include = ‘condition’
[09:31:56.696]  - exclude = ‘immediateCondition’
[09:31:56.696]  - resignal = TRUE
[09:31:56.696]  - Number of conditions: 54
[09:31:56.696]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.660] getGlobalsAndPackages() ...
[09:31:56.697]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.660] Searching for globals...
[09:31:56.697]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.677] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[09:31:56.697]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.677] Searching for globals ... DONE
[09:31:56.697]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.677] Resolving globals: FALSE
[09:31:56.697]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.678] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[09:31:56.697]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.678] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[09:31:56.697]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.678] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[09:31:56.697]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.678] 
[09:31:56.698]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679] getGlobalsAndPackages() ... DONE
[09:31:56.698]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679] run() for ‘Future’ ...
[09:31:56.698]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679] - state: ‘created’
[09:31:56.698]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.698]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.698]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.698]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.679]   - Field: ‘label’
[09:31:56.698]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘local’
[09:31:56.699]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘owner’
[09:31:56.699]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘envir’
[09:31:56.699]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘packages’
[09:31:56.699]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘gc’
[09:31:56.699]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘conditions’
[09:31:56.699]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘expr’
[09:31:56.699]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘uuid’
[09:31:56.699]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘seed’
[09:31:56.700]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.680]   - Field: ‘version’
[09:31:56.700]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘result’
[09:31:56.700]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘asynchronous’
[09:31:56.700]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘calls’
[09:31:56.700]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘globals’
[09:31:56.700]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘stdout’
[09:31:56.700]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘earlySignal’
[09:31:56.700]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘lazy’
[09:31:56.701]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681]   - Field: ‘state’
[09:31:56.701]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.701]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.681] - Launch lazy future ...
[09:31:56.701]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.682] Packages needed by the future expression (n = 0): <none>
[09:31:56.701]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.682] Packages needed by future strategies (n = 0): <none>
[09:31:56.701]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.682] {
[09:31:56.682]     {
[09:31:56.682]         {
[09:31:56.682]             ...future.startTime <- base::Sys.time()
[09:31:56.682]             {
[09:31:56.682]                 {
[09:31:56.682]                   {
[09:31:56.682]                     base::local({
[09:31:56.682]                       has_future <- base::requireNamespace("future", 
[09:31:56.682]                         quietly = TRUE)
[09:31:56.682]                       if (has_future) {
[09:31:56.682]                         ns <- base::getNamespace("future")
[09:31:56.682]                         version <- ns[[".package"]][["version"]]
[09:31:56.682]                         if (is.null(version)) 
[09:31:56.682]                           version <- utils::packageVersion("future")
[09:31:56.682]                       }
[09:31:56.682]                       else {
[09:31:56.682]                         version <- NULL
[09:31:56.682]                       }
[09:31:56.682]                       if (!has_future || version < "1.8.0") {
[09:31:56.682]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.682]                           "", base::R.version$version.string), 
[09:31:56.682]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:56.682]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.682]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.682]                             "release", "version")], collapse = " "), 
[09:31:56.682]                           hostname = base::Sys.info()[["nodename"]])
[09:31:56.682]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.682]                           info)
[09:31:56.682]                         info <- base::paste(info, collapse = "; ")
[09:31:56.682]                         if (!has_future) {
[09:31:56.682]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.682]                             info)
[09:31:56.682]                         }
[09:31:56.682]                         else {
[09:31:56.682]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.682]                             info, version)
[09:31:56.682]                         }
[09:31:56.682]                         base::stop(msg)
[09:31:56.682]                       }
[09:31:56.682]                     })
[09:31:56.682]                   }
[09:31:56.682]                   ...future.strategy.old <- future::plan("list")
[09:31:56.682]                   options(future.plan = NULL)
[09:31:56.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:56.682]                 }
[09:31:56.682]                 ...future.workdir <- getwd()
[09:31:56.682]             }
[09:31:56.682]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.682]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.682]         }
[09:31:56.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.682]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.682]             base::names(...future.oldOptions))
[09:31:56.682]     }
[09:31:56.682]     if (FALSE) {
[09:31:56.682]     }
[09:31:56.682]     else {
[09:31:56.682]         if (TRUE) {
[09:31:56.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.682]                 open = "w")
[09:31:56.682]         }
[09:31:56.682]         else {
[09:31:56.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.682]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.682]         }
[09:31:56.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.682]             base::sink(type = "output", split = FALSE)
[09:31:56.682]             base::close(...future.stdout)
[09:31:56.682]         }, add = TRUE)
[09:31:56.682]     }
[09:31:56.682]     ...future.frame <- base::sys.nframe()
[09:31:56.682]     ...future.conditions <- base::list()
[09:31:56.682]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.682]     if (FALSE) {
[09:31:56.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.682]     }
[09:31:56.682]     ...future.result <- base::tryCatch({
[09:31:56.682]         base::withCallingHandlers({
[09:31:56.682]             ...future.value <- base::withVisible(base::local({
[09:31:56.682]                 b <- 2L
[09:31:56.682]                 plan_b <- future::plan("list")
[09:31:56.682]                 nested_b <- nested_a[-1]
[09:31:56.682]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:56.682]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.682]                   "sequential"))
[09:31:56.682]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:56.682]                   b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:56.682]             }))
[09:31:56.682]             future::FutureResult(value = ...future.value$value, 
[09:31:56.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.682]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.682]                     ...future.globalenv.names))
[09:31:56.682]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.682]         }, condition = base::local({
[09:31:56.682]             c <- base::c
[09:31:56.682]             inherits <- base::inherits
[09:31:56.682]             invokeRestart <- base::invokeRestart
[09:31:56.682]             length <- base::length
[09:31:56.682]             list <- base::list
[09:31:56.682]             seq.int <- base::seq.int
[09:31:56.682]             signalCondition <- base::signalCondition
[09:31:56.682]             sys.calls <- base::sys.calls
[09:31:56.682]             `[[` <- base::`[[`
[09:31:56.682]             `+` <- base::`+`
[09:31:56.682]             `<<-` <- base::`<<-`
[09:31:56.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.682]                   3L)]
[09:31:56.682]             }
[09:31:56.682]             function(cond) {
[09:31:56.682]                 is_error <- inherits(cond, "error")
[09:31:56.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.682]                   NULL)
[09:31:56.682]                 if (is_error) {
[09:31:56.682]                   sessionInformation <- function() {
[09:31:56.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.682]                       search = base::search(), system = base::Sys.info())
[09:31:56.682]                   }
[09:31:56.682]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.682]                     cond$call), session = sessionInformation(), 
[09:31:56.682]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.682]                   signalCondition(cond)
[09:31:56.682]                 }
[09:31:56.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.682]                 "immediateCondition"))) {
[09:31:56.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.682]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.682]                   if (TRUE && !signal) {
[09:31:56.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.682]                     {
[09:31:56.682]                       inherits <- base::inherits
[09:31:56.682]                       invokeRestart <- base::invokeRestart
[09:31:56.682]                       is.null <- base::is.null
[09:31:56.682]                       muffled <- FALSE
[09:31:56.682]                       if (inherits(cond, "message")) {
[09:31:56.682]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.682]                         if (muffled) 
[09:31:56.682]                           invokeRestart("muffleMessage")
[09:31:56.682]                       }
[09:31:56.682]                       else if (inherits(cond, "warning")) {
[09:31:56.682]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.682]                         if (muffled) 
[09:31:56.682]                           invokeRestart("muffleWarning")
[09:31:56.682]                       }
[09:31:56.682]                       else if (inherits(cond, "condition")) {
[09:31:56.682]                         if (!is.null(pattern)) {
[09:31:56.682]                           computeRestarts <- base::computeRestarts
[09:31:56.682]                           grepl <- base::grepl
[09:31:56.682]                           restarts <- computeRestarts(cond)
[09:31:56.682]                           for (restart in restarts) {
[09:31:56.682]                             name <- restart$name
[09:31:56.682]                             if (is.null(name)) 
[09:31:56.682]                               next
[09:31:56.682]                             if (!grepl(pattern, name)) 
[09:31:56.682]                               next
[09:31:56.682]                             invokeRestart(restart)
[09:31:56.682]                             muffled <- TRUE
[09:31:56.682]                             break
[09:31:56.682]                           }
[09:31:56.682]                         }
[09:31:56.682]                       }
[09:31:56.682]                       invisible(muffled)
[09:31:56.682]                     }
[09:31:56.682]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.682]                   }
[09:31:56.682]                 }
[09:31:56.682]                 else {
[09:31:56.682]                   if (TRUE) {
[09:31:56.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.682]                     {
[09:31:56.682]                       inherits <- base::inherits
[09:31:56.682]                       invokeRestart <- base::invokeRestart
[09:31:56.682]                       is.null <- base::is.null
[09:31:56.682]                       muffled <- FALSE
[09:31:56.682]                       if (inherits(cond, "message")) {
[09:31:56.682]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.682]                         if (muffled) 
[09:31:56.682]                           invokeRestart("muffleMessage")
[09:31:56.682]                       }
[09:31:56.682]                       else if (inherits(cond, "warning")) {
[09:31:56.682]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.682]                         if (muffled) 
[09:31:56.682]                           invokeRestart("muffleWarning")
[09:31:56.682]                       }
[09:31:56.682]                       else if (inherits(cond, "condition")) {
[09:31:56.682]                         if (!is.null(pattern)) {
[09:31:56.682]                           computeRestarts <- base::computeRestarts
[09:31:56.682]                           grepl <- base::grepl
[09:31:56.682]                           restarts <- computeRestarts(cond)
[09:31:56.682]                           for (restart in restarts) {
[09:31:56.682]                             name <- restart$name
[09:31:56.682]                             if (is.null(name)) 
[09:31:56.682]                               next
[09:31:56.682]                             if (!grepl(pattern, name)) 
[09:31:56.682]                               next
[09:31:56.682]                             invokeRestart(restart)
[09:31:56.682]                             muffled <- TRUE
[09:31:56.682]                             break
[09:31:56.682]                           }
[09:31:56.682]                         }
[09:31:56.682]                       }
[09:31:56.682]                       invisible(muffled)
[09:31:56.682]                     }
[09:31:56.682]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.682]                   }
[09:31:56.682]                 }
[09:31:56.682]             }
[09:31:56.682]         }))
[09:31:56.682]     }, error = function(ex) {
[09:31:56.682]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.682]                 ...future.rng), started = ...future.startTime, 
[09:31:56.682]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.682]             version = "1.8"), class = "FutureResult")
[09:31:56.682]     }, finally = {
[09:31:56.682]         if (!identical(...future.workdir, getwd())) 
[09:31:56.682]             setwd(...future.workdir)
[09:31:56.682]         {
[09:31:56.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.682]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.682]             }
[09:31:56.682]             base::options(...future.oldOptions)
[09:31:56.682]             if (.Platform$OS.type == "windows") {
[09:31:56.682]                 old_names <- names(...future.oldEnvVars)
[09:31:56.682]                 envs <- base::Sys.getenv()
[09:31:56.682]                 names <- names(envs)
[09:31:56.682]                 common <- intersect(names, old_names)
[09:31:56.682]                 added <- setdiff(names, old_names)
[09:31:56.682]                 removed <- setdiff(old_names, names)
[09:31:56.682]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.682]                   envs[common]]
[09:31:56.682]                 NAMES <- toupper(changed)
[09:31:56.682]                 args <- list()
[09:31:56.682]                 for (kk in seq_along(NAMES)) {
[09:31:56.682]                   name <- changed[[kk]]
[09:31:56.682]                   NAME <- NAMES[[kk]]
[09:31:56.682]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.682]                     next
[09:31:56.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.682]                 }
[09:31:56.682]                 NAMES <- toupper(added)
[09:31:56.682]                 for (kk in seq_along(NAMES)) {
[09:31:56.682]                   name <- added[[kk]]
[09:31:56.682]                   NAME <- NAMES[[kk]]
[09:31:56.682]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.682]                     next
[09:31:56.682]                   args[[name]] <- ""
[09:31:56.682]                 }
[09:31:56.682]                 NAMES <- toupper(removed)
[09:31:56.682]                 for (kk in seq_along(NAMES)) {
[09:31:56.682]                   name <- removed[[kk]]
[09:31:56.682]                   NAME <- NAMES[[kk]]
[09:31:56.682]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.682]                     next
[09:31:56.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.682]                 }
[09:31:56.682]                 if (length(args) > 0) 
[09:31:56.682]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.682]             }
[09:31:56.682]             else {
[09:31:56.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.682]             }
[09:31:56.682]             {
[09:31:56.682]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.682]                   0L) {
[09:31:56.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.682]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.682]                   base::options(opts)
[09:31:56.682]                 }
[09:31:56.682]                 {
[09:31:56.682]                   {
[09:31:56.682]                     NULL
[09:31:56.682]                     RNGkind("Mersenne-Twister")
[09:31:56.682]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.682]                       inherits = FALSE)
[09:31:56.682]                   }
[09:31:56.682]                   options(future.plan = NULL)
[09:31:56.682]                   if (is.na(NA_character_)) 
[09:31:56.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.682]                     .init = FALSE)
[09:31:56.682]                 }
[09:31:56.682]             }
[09:31:56.682]         }
[09:31:56.682]     })
[09:31:56.682]     if (TRUE) {
[09:31:56.682]         base::sink(type = "output", split = FALSE)
[09:31:56.682]         if (TRUE) {
[09:31:56.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.682]         }
[09:31:56.682]         else {
[09:31:56.682]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.682]         }
[09:31:56.682]         base::close(...future.stdout)
[09:31:56.682]         ...future.stdout <- NULL
[09:31:56.682]     }
[09:31:56.682]     ...future.result$conditions <- ...future.conditions
[09:31:56.682]     ...future.result$finished <- base::Sys.time()
[09:31:56.682]     ...future.result
[09:31:56.682] }
[09:31:56.701]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.684] assign_globals() ...
[09:31:56.701]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.684] List of 3
[09:31:56.684]  $ nested_a:List of 1
[09:31:56.684]   ..$ b:function (..., envir = parent.frame())  
[09:31:56.684]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:56.684]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.684]  $ a       : int 1
[09:31:56.684]  $ plan_a  :List of 1
[09:31:56.684]   ..$ b:function (..., envir = parent.frame())  
[09:31:56.684]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:56.684]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.684]  - attr(*, "where")=List of 3
[09:31:56.684]   ..$ nested_a:<environment: R_EmptyEnv> 
[09:31:56.684]   ..$ a       :<environment: R_EmptyEnv> 
[09:31:56.684]   ..$ plan_a  :<environment: R_EmptyEnv> 
[09:31:56.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.684]  - attr(*, "resolved")= logi FALSE
[09:31:56.684]  - attr(*, "total_size")= num 23080
[09:31:56.684]  - attr(*, "already-done")= logi TRUE
[09:31:56.702]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.688] - copied ‘nested_a’ to environment
[09:31:56.702]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.689] - copied ‘a’ to environment
[09:31:56.702]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.689] - copied ‘plan_a’ to environment
[09:31:56.702]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.689] assign_globals() ... done
[09:31:56.702]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.689] plan(): Setting new future strategy stack:
[09:31:56.702]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.689] List of future strategies:
[09:31:56.689] 1. sequential:
[09:31:56.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.689]    - tweaked: FALSE
[09:31:56.689]    - call: NULL
[09:31:56.702]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.690] plan(): nbrOfWorkers() = 1
[09:31:56.702]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.691] plan(): Setting new future strategy stack:
[09:31:56.703]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.691] List of future strategies:
[09:31:56.691] 1. sequential:
[09:31:56.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.691]    - tweaked: FALSE
[09:31:56.691]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.703]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.691] plan(): nbrOfWorkers() = 1
[09:31:56.703]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.691] SequentialFuture started (and completed)
[09:31:56.703]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.692] - Launch lazy future ... done
[09:31:56.703]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.692] run() for ‘SequentialFuture’ ... done
[09:31:56.703] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:56.708] getGlobalsAndPackages() ...
[09:31:56.708] Searching for globals...
[09:31:56.709] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:56.709] Searching for globals ... DONE
[09:31:56.709] Resolving globals: FALSE
[09:31:56.710] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:56.710] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:56.710] - globals: [1] ‘data’
[09:31:56.710] - packages: [1] ‘future’
[09:31:56.710] getGlobalsAndPackages() ... DONE
[09:31:56.710] run() for ‘Future’ ...
[09:31:56.711] - state: ‘created’
[09:31:56.711] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.711] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.711] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.711]   - Field: ‘label’
[09:31:56.711]   - Field: ‘local’
[09:31:56.711]   - Field: ‘owner’
[09:31:56.711]   - Field: ‘envir’
[09:31:56.712]   - Field: ‘packages’
[09:31:56.712]   - Field: ‘gc’
[09:31:56.712]   - Field: ‘conditions’
[09:31:56.712]   - Field: ‘expr’
[09:31:56.712]   - Field: ‘uuid’
[09:31:56.712]   - Field: ‘seed’
[09:31:56.712]   - Field: ‘version’
[09:31:56.712]   - Field: ‘result’
[09:31:56.712]   - Field: ‘asynchronous’
[09:31:56.712]   - Field: ‘calls’
[09:31:56.712]   - Field: ‘globals’
[09:31:56.713]   - Field: ‘stdout’
[09:31:56.713]   - Field: ‘earlySignal’
[09:31:56.713]   - Field: ‘lazy’
[09:31:56.713]   - Field: ‘state’
[09:31:56.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.713] - Launch lazy future ...
[09:31:56.713] Packages needed by the future expression (n = 1): ‘future’
[09:31:56.713] Packages needed by future strategies (n = 1): ‘future’
[09:31:56.714] {
[09:31:56.714]     {
[09:31:56.714]         {
[09:31:56.714]             ...future.startTime <- base::Sys.time()
[09:31:56.714]             {
[09:31:56.714]                 {
[09:31:56.714]                   {
[09:31:56.714]                     {
[09:31:56.714]                       base::local({
[09:31:56.714]                         has_future <- base::requireNamespace("future", 
[09:31:56.714]                           quietly = TRUE)
[09:31:56.714]                         if (has_future) {
[09:31:56.714]                           ns <- base::getNamespace("future")
[09:31:56.714]                           version <- ns[[".package"]][["version"]]
[09:31:56.714]                           if (is.null(version)) 
[09:31:56.714]                             version <- utils::packageVersion("future")
[09:31:56.714]                         }
[09:31:56.714]                         else {
[09:31:56.714]                           version <- NULL
[09:31:56.714]                         }
[09:31:56.714]                         if (!has_future || version < "1.8.0") {
[09:31:56.714]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.714]                             "", base::R.version$version.string), 
[09:31:56.714]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.714]                               "release", "version")], collapse = " "), 
[09:31:56.714]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.714]                             info)
[09:31:56.714]                           info <- base::paste(info, collapse = "; ")
[09:31:56.714]                           if (!has_future) {
[09:31:56.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.714]                               info)
[09:31:56.714]                           }
[09:31:56.714]                           else {
[09:31:56.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.714]                               info, version)
[09:31:56.714]                           }
[09:31:56.714]                           base::stop(msg)
[09:31:56.714]                         }
[09:31:56.714]                       })
[09:31:56.714]                     }
[09:31:56.714]                     base::local({
[09:31:56.714]                       for (pkg in "future") {
[09:31:56.714]                         base::loadNamespace(pkg)
[09:31:56.714]                         base::library(pkg, character.only = TRUE)
[09:31:56.714]                       }
[09:31:56.714]                     })
[09:31:56.714]                   }
[09:31:56.714]                   ...future.strategy.old <- future::plan("list")
[09:31:56.714]                   options(future.plan = NULL)
[09:31:56.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.714]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:56.714]                   {
[09:31:56.714]                     future <- SequentialFuture(..., envir = envir)
[09:31:56.714]                     if (!future$lazy) 
[09:31:56.714]                       future <- run(future)
[09:31:56.714]                     invisible(future)
[09:31:56.714]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:56.714]                 }
[09:31:56.714]                 ...future.workdir <- getwd()
[09:31:56.714]             }
[09:31:56.714]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.714]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.714]         }
[09:31:56.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.714]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.714]             base::names(...future.oldOptions))
[09:31:56.714]     }
[09:31:56.714]     if (FALSE) {
[09:31:56.714]     }
[09:31:56.714]     else {
[09:31:56.714]         if (TRUE) {
[09:31:56.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.714]                 open = "w")
[09:31:56.714]         }
[09:31:56.714]         else {
[09:31:56.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.714]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.714]         }
[09:31:56.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.714]             base::sink(type = "output", split = FALSE)
[09:31:56.714]             base::close(...future.stdout)
[09:31:56.714]         }, add = TRUE)
[09:31:56.714]     }
[09:31:56.714]     ...future.frame <- base::sys.nframe()
[09:31:56.714]     ...future.conditions <- base::list()
[09:31:56.714]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.714]     if (FALSE) {
[09:31:56.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.714]     }
[09:31:56.714]     ...future.result <- base::tryCatch({
[09:31:56.714]         base::withCallingHandlers({
[09:31:56.714]             ...future.value <- base::withVisible(base::local({
[09:31:56.714]                 value(future(subset(data, a == 2)))
[09:31:56.714]             }))
[09:31:56.714]             future::FutureResult(value = ...future.value$value, 
[09:31:56.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.714]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.714]                     ...future.globalenv.names))
[09:31:56.714]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.714]         }, condition = base::local({
[09:31:56.714]             c <- base::c
[09:31:56.714]             inherits <- base::inherits
[09:31:56.714]             invokeRestart <- base::invokeRestart
[09:31:56.714]             length <- base::length
[09:31:56.714]             list <- base::list
[09:31:56.714]             seq.int <- base::seq.int
[09:31:56.714]             signalCondition <- base::signalCondition
[09:31:56.714]             sys.calls <- base::sys.calls
[09:31:56.714]             `[[` <- base::`[[`
[09:31:56.714]             `+` <- base::`+`
[09:31:56.714]             `<<-` <- base::`<<-`
[09:31:56.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.714]                   3L)]
[09:31:56.714]             }
[09:31:56.714]             function(cond) {
[09:31:56.714]                 is_error <- inherits(cond, "error")
[09:31:56.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.714]                   NULL)
[09:31:56.714]                 if (is_error) {
[09:31:56.714]                   sessionInformation <- function() {
[09:31:56.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.714]                       search = base::search(), system = base::Sys.info())
[09:31:56.714]                   }
[09:31:56.714]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.714]                     cond$call), session = sessionInformation(), 
[09:31:56.714]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.714]                   signalCondition(cond)
[09:31:56.714]                 }
[09:31:56.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.714]                 "immediateCondition"))) {
[09:31:56.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.714]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.714]                   if (TRUE && !signal) {
[09:31:56.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.714]                     {
[09:31:56.714]                       inherits <- base::inherits
[09:31:56.714]                       invokeRestart <- base::invokeRestart
[09:31:56.714]                       is.null <- base::is.null
[09:31:56.714]                       muffled <- FALSE
[09:31:56.714]                       if (inherits(cond, "message")) {
[09:31:56.714]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.714]                         if (muffled) 
[09:31:56.714]                           invokeRestart("muffleMessage")
[09:31:56.714]                       }
[09:31:56.714]                       else if (inherits(cond, "warning")) {
[09:31:56.714]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.714]                         if (muffled) 
[09:31:56.714]                           invokeRestart("muffleWarning")
[09:31:56.714]                       }
[09:31:56.714]                       else if (inherits(cond, "condition")) {
[09:31:56.714]                         if (!is.null(pattern)) {
[09:31:56.714]                           computeRestarts <- base::computeRestarts
[09:31:56.714]                           grepl <- base::grepl
[09:31:56.714]                           restarts <- computeRestarts(cond)
[09:31:56.714]                           for (restart in restarts) {
[09:31:56.714]                             name <- restart$name
[09:31:56.714]                             if (is.null(name)) 
[09:31:56.714]                               next
[09:31:56.714]                             if (!grepl(pattern, name)) 
[09:31:56.714]                               next
[09:31:56.714]                             invokeRestart(restart)
[09:31:56.714]                             muffled <- TRUE
[09:31:56.714]                             break
[09:31:56.714]                           }
[09:31:56.714]                         }
[09:31:56.714]                       }
[09:31:56.714]                       invisible(muffled)
[09:31:56.714]                     }
[09:31:56.714]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.714]                   }
[09:31:56.714]                 }
[09:31:56.714]                 else {
[09:31:56.714]                   if (TRUE) {
[09:31:56.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.714]                     {
[09:31:56.714]                       inherits <- base::inherits
[09:31:56.714]                       invokeRestart <- base::invokeRestart
[09:31:56.714]                       is.null <- base::is.null
[09:31:56.714]                       muffled <- FALSE
[09:31:56.714]                       if (inherits(cond, "message")) {
[09:31:56.714]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.714]                         if (muffled) 
[09:31:56.714]                           invokeRestart("muffleMessage")
[09:31:56.714]                       }
[09:31:56.714]                       else if (inherits(cond, "warning")) {
[09:31:56.714]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.714]                         if (muffled) 
[09:31:56.714]                           invokeRestart("muffleWarning")
[09:31:56.714]                       }
[09:31:56.714]                       else if (inherits(cond, "condition")) {
[09:31:56.714]                         if (!is.null(pattern)) {
[09:31:56.714]                           computeRestarts <- base::computeRestarts
[09:31:56.714]                           grepl <- base::grepl
[09:31:56.714]                           restarts <- computeRestarts(cond)
[09:31:56.714]                           for (restart in restarts) {
[09:31:56.714]                             name <- restart$name
[09:31:56.714]                             if (is.null(name)) 
[09:31:56.714]                               next
[09:31:56.714]                             if (!grepl(pattern, name)) 
[09:31:56.714]                               next
[09:31:56.714]                             invokeRestart(restart)
[09:31:56.714]                             muffled <- TRUE
[09:31:56.714]                             break
[09:31:56.714]                           }
[09:31:56.714]                         }
[09:31:56.714]                       }
[09:31:56.714]                       invisible(muffled)
[09:31:56.714]                     }
[09:31:56.714]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.714]                   }
[09:31:56.714]                 }
[09:31:56.714]             }
[09:31:56.714]         }))
[09:31:56.714]     }, error = function(ex) {
[09:31:56.714]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.714]                 ...future.rng), started = ...future.startTime, 
[09:31:56.714]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.714]             version = "1.8"), class = "FutureResult")
[09:31:56.714]     }, finally = {
[09:31:56.714]         if (!identical(...future.workdir, getwd())) 
[09:31:56.714]             setwd(...future.workdir)
[09:31:56.714]         {
[09:31:56.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.714]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.714]             }
[09:31:56.714]             base::options(...future.oldOptions)
[09:31:56.714]             if (.Platform$OS.type == "windows") {
[09:31:56.714]                 old_names <- names(...future.oldEnvVars)
[09:31:56.714]                 envs <- base::Sys.getenv()
[09:31:56.714]                 names <- names(envs)
[09:31:56.714]                 common <- intersect(names, old_names)
[09:31:56.714]                 added <- setdiff(names, old_names)
[09:31:56.714]                 removed <- setdiff(old_names, names)
[09:31:56.714]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.714]                   envs[common]]
[09:31:56.714]                 NAMES <- toupper(changed)
[09:31:56.714]                 args <- list()
[09:31:56.714]                 for (kk in seq_along(NAMES)) {
[09:31:56.714]                   name <- changed[[kk]]
[09:31:56.714]                   NAME <- NAMES[[kk]]
[09:31:56.714]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.714]                     next
[09:31:56.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.714]                 }
[09:31:56.714]                 NAMES <- toupper(added)
[09:31:56.714]                 for (kk in seq_along(NAMES)) {
[09:31:56.714]                   name <- added[[kk]]
[09:31:56.714]                   NAME <- NAMES[[kk]]
[09:31:56.714]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.714]                     next
[09:31:56.714]                   args[[name]] <- ""
[09:31:56.714]                 }
[09:31:56.714]                 NAMES <- toupper(removed)
[09:31:56.714]                 for (kk in seq_along(NAMES)) {
[09:31:56.714]                   name <- removed[[kk]]
[09:31:56.714]                   NAME <- NAMES[[kk]]
[09:31:56.714]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.714]                     next
[09:31:56.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.714]                 }
[09:31:56.714]                 if (length(args) > 0) 
[09:31:56.714]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.714]             }
[09:31:56.714]             else {
[09:31:56.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.714]             }
[09:31:56.714]             {
[09:31:56.714]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.714]                   0L) {
[09:31:56.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.714]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.714]                   base::options(opts)
[09:31:56.714]                 }
[09:31:56.714]                 {
[09:31:56.714]                   {
[09:31:56.714]                     NULL
[09:31:56.714]                     RNGkind("Mersenne-Twister")
[09:31:56.714]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.714]                       inherits = FALSE)
[09:31:56.714]                   }
[09:31:56.714]                   options(future.plan = NULL)
[09:31:56.714]                   if (is.na(NA_character_)) 
[09:31:56.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.714]                     .init = FALSE)
[09:31:56.714]                 }
[09:31:56.714]             }
[09:31:56.714]         }
[09:31:56.714]     })
[09:31:56.714]     if (TRUE) {
[09:31:56.714]         base::sink(type = "output", split = FALSE)
[09:31:56.714]         if (TRUE) {
[09:31:56.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.714]         }
[09:31:56.714]         else {
[09:31:56.714]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.714]         }
[09:31:56.714]         base::close(...future.stdout)
[09:31:56.714]         ...future.stdout <- NULL
[09:31:56.714]     }
[09:31:56.714]     ...future.result$conditions <- ...future.conditions
[09:31:56.714]     ...future.result$finished <- base::Sys.time()
[09:31:56.714]     ...future.result
[09:31:56.714] }
[09:31:56.715] assign_globals() ...
[09:31:56.715] List of 1
[09:31:56.715]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:56.715]   ..$ a: int [1:3] 1 2 3
[09:31:56.715]   ..$ b: int [1:3] 3 2 1
[09:31:56.715]  - attr(*, "where")=List of 1
[09:31:56.715]   ..$ data:<environment: R_EmptyEnv> 
[09:31:56.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.715]  - attr(*, "resolved")= logi FALSE
[09:31:56.715]  - attr(*, "total_size")= num 128
[09:31:56.715]  - attr(*, "already-done")= logi TRUE
[09:31:56.719] - copied ‘data’ to environment
[09:31:56.719] assign_globals() ... done
[09:31:56.720] plan(): Setting new future strategy stack:
[09:31:56.720] List of future strategies:
[09:31:56.720] 1. sequential:
[09:31:56.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.720]    - tweaked: FALSE
[09:31:56.720]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.720] plan(): nbrOfWorkers() = 1
[09:31:56.747] plan(): Setting new future strategy stack:
[09:31:56.747] List of future strategies:
[09:31:56.747] 1. sequential:
[09:31:56.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.747]    - tweaked: FALSE
[09:31:56.747]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.747] 2. sequential:
[09:31:56.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.747]    - tweaked: FALSE
[09:31:56.747]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.747] plan(): nbrOfWorkers() = 1
[09:31:56.748] SequentialFuture started (and completed)
[09:31:56.748] signalConditions() ...
[09:31:56.748]  - include = ‘immediateCondition’
[09:31:56.748]  - exclude = 
[09:31:56.748]  - resignal = FALSE
[09:31:56.748]  - Number of conditions: 52
[09:31:56.748] signalConditions() ... done
[09:31:56.748] - Launch lazy future ... done
[09:31:56.748] run() for ‘SequentialFuture’ ... done
[09:31:56.748] signalConditions() ...
[09:31:56.749]  - include = ‘immediateCondition’
[09:31:56.749]  - exclude = 
[09:31:56.749]  - resignal = FALSE
[09:31:56.749]  - Number of conditions: 52
[09:31:56.749] signalConditions() ... done
[09:31:56.749] Future state: ‘finished’
[09:31:56.749] signalConditions() ...
[09:31:56.749]  - include = ‘condition’
[09:31:56.749]  - exclude = ‘immediateCondition’
[09:31:56.749]  - resignal = TRUE
[09:31:56.749]  - Number of conditions: 52
[09:31:56.749]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.721] getGlobalsAndPackages() ...
[09:31:56.750]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.721] Searching for globals...
[09:31:56.750]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.733] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:56.750]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.734] Searching for globals ... DONE
[09:31:56.750]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.734] Resolving globals: FALSE
[09:31:56.750]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.734] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:56.750]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.734] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:56.750]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] - globals: [1] ‘data’
[09:31:56.750]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] 
[09:31:56.751]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] getGlobalsAndPackages() ... DONE
[09:31:56.751]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] run() for ‘Future’ ...
[09:31:56.751]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] - state: ‘created’
[09:31:56.751]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.751]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.735] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.751]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.751]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736]   - Field: ‘label’
[09:31:56.751]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736]   - Field: ‘local’
[09:31:56.752]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736]   - Field: ‘owner’
[09:31:56.752]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736]   - Field: ‘envir’
[09:31:56.752]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736]   - Field: ‘packages’
[09:31:56.752]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.736]   - Field: ‘gc’
[09:31:56.752]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘conditions’
[09:31:56.752]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘expr’
[09:31:56.752]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘uuid’
[09:31:56.752]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘seed’
[09:31:56.753]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘version’
[09:31:56.753]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘result’
[09:31:56.753]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘asynchronous’
[09:31:56.753]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘calls’
[09:31:56.753]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘globals’
[09:31:56.753]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘stdout’
[09:31:56.753]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.737]   - Field: ‘earlySignal’
[09:31:56.753]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.738]   - Field: ‘lazy’
[09:31:56.753]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.738]   - Field: ‘state’
[09:31:56.754]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.754]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.739] - Launch lazy future ...
[09:31:56.754]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.739] Packages needed by the future expression (n = 0): <none>
[09:31:56.754]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.739] Packages needed by future strategies (n = 0): <none>
[09:31:56.754]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.739] {
[09:31:56.739]     {
[09:31:56.739]         {
[09:31:56.739]             ...future.startTime <- base::Sys.time()
[09:31:56.739]             {
[09:31:56.739]                 {
[09:31:56.739]                   {
[09:31:56.739]                     base::local({
[09:31:56.739]                       has_future <- base::requireNamespace("future", 
[09:31:56.739]                         quietly = TRUE)
[09:31:56.739]                       if (has_future) {
[09:31:56.739]                         ns <- base::getNamespace("future")
[09:31:56.739]                         version <- ns[[".package"]][["version"]]
[09:31:56.739]                         if (is.null(version)) 
[09:31:56.739]                           version <- utils::packageVersion("future")
[09:31:56.739]                       }
[09:31:56.739]                       else {
[09:31:56.739]                         version <- NULL
[09:31:56.739]                       }
[09:31:56.739]                       if (!has_future || version < "1.8.0") {
[09:31:56.739]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.739]                           "", base::R.version$version.string), 
[09:31:56.739]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:56.739]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.739]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.739]                             "release", "version")], collapse = " "), 
[09:31:56.739]                           hostname = base::Sys.info()[["nodename"]])
[09:31:56.739]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.739]                           info)
[09:31:56.739]                         info <- base::paste(info, collapse = "; ")
[09:31:56.739]                         if (!has_future) {
[09:31:56.739]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.739]                             info)
[09:31:56.739]                         }
[09:31:56.739]                         else {
[09:31:56.739]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.739]                             info, version)
[09:31:56.739]                         }
[09:31:56.739]                         base::stop(msg)
[09:31:56.739]                       }
[09:31:56.739]                     })
[09:31:56.739]                   }
[09:31:56.739]                   ...future.strategy.old <- future::plan("list")
[09:31:56.739]                   options(future.plan = NULL)
[09:31:56.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:56.739]                 }
[09:31:56.739]                 ...future.workdir <- getwd()
[09:31:56.739]             }
[09:31:56.739]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.739]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.739]         }
[09:31:56.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.739]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.739]             base::names(...future.oldOptions))
[09:31:56.739]     }
[09:31:56.739]     if (FALSE) {
[09:31:56.739]     }
[09:31:56.739]     else {
[09:31:56.739]         if (TRUE) {
[09:31:56.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.739]                 open = "w")
[09:31:56.739]         }
[09:31:56.739]         else {
[09:31:56.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.739]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.739]         }
[09:31:56.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.739]             base::sink(type = "output", split = FALSE)
[09:31:56.739]             base::close(...future.stdout)
[09:31:56.739]         }, add = TRUE)
[09:31:56.739]     }
[09:31:56.739]     ...future.frame <- base::sys.nframe()
[09:31:56.739]     ...future.conditions <- base::list()
[09:31:56.739]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.739]     if (FALSE) {
[09:31:56.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.739]     }
[09:31:56.739]     ...future.result <- base::tryCatch({
[09:31:56.739]         base::withCallingHandlers({
[09:31:56.739]             ...future.value <- base::withVisible(base::local(subset(data, 
[09:31:56.739]                 a == 2)))
[09:31:56.739]             future::FutureResult(value = ...future.value$value, 
[09:31:56.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.739]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.739]                     ...future.globalenv.names))
[09:31:56.739]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.739]         }, condition = base::local({
[09:31:56.739]             c <- base::c
[09:31:56.739]             inherits <- base::inherits
[09:31:56.739]             invokeRestart <- base::invokeRestart
[09:31:56.739]             length <- base::length
[09:31:56.739]             list <- base::list
[09:31:56.739]             seq.int <- base::seq.int
[09:31:56.739]             signalCondition <- base::signalCondition
[09:31:56.739]             sys.calls <- base::sys.calls
[09:31:56.739]             `[[` <- base::`[[`
[09:31:56.739]             `+` <- base::`+`
[09:31:56.739]             `<<-` <- base::`<<-`
[09:31:56.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.739]                   3L)]
[09:31:56.739]             }
[09:31:56.739]             function(cond) {
[09:31:56.739]                 is_error <- inherits(cond, "error")
[09:31:56.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.739]                   NULL)
[09:31:56.739]                 if (is_error) {
[09:31:56.739]                   sessionInformation <- function() {
[09:31:56.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.739]                       search = base::search(), system = base::Sys.info())
[09:31:56.739]                   }
[09:31:56.739]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.739]                     cond$call), session = sessionInformation(), 
[09:31:56.739]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.739]                   signalCondition(cond)
[09:31:56.739]                 }
[09:31:56.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.739]                 "immediateCondition"))) {
[09:31:56.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.739]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.739]                   if (TRUE && !signal) {
[09:31:56.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.739]                     {
[09:31:56.739]                       inherits <- base::inherits
[09:31:56.739]                       invokeRestart <- base::invokeRestart
[09:31:56.739]                       is.null <- base::is.null
[09:31:56.739]                       muffled <- FALSE
[09:31:56.739]                       if (inherits(cond, "message")) {
[09:31:56.739]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.739]                         if (muffled) 
[09:31:56.739]                           invokeRestart("muffleMessage")
[09:31:56.739]                       }
[09:31:56.739]                       else if (inherits(cond, "warning")) {
[09:31:56.739]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.739]                         if (muffled) 
[09:31:56.739]                           invokeRestart("muffleWarning")
[09:31:56.739]                       }
[09:31:56.739]                       else if (inherits(cond, "condition")) {
[09:31:56.739]                         if (!is.null(pattern)) {
[09:31:56.739]                           computeRestarts <- base::computeRestarts
[09:31:56.739]                           grepl <- base::grepl
[09:31:56.739]                           restarts <- computeRestarts(cond)
[09:31:56.739]                           for (restart in restarts) {
[09:31:56.739]                             name <- restart$name
[09:31:56.739]                             if (is.null(name)) 
[09:31:56.739]                               next
[09:31:56.739]                             if (!grepl(pattern, name)) 
[09:31:56.739]                               next
[09:31:56.739]                             invokeRestart(restart)
[09:31:56.739]                             muffled <- TRUE
[09:31:56.739]                             break
[09:31:56.739]                           }
[09:31:56.739]                         }
[09:31:56.739]                       }
[09:31:56.739]                       invisible(muffled)
[09:31:56.739]                     }
[09:31:56.739]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.739]                   }
[09:31:56.739]                 }
[09:31:56.739]                 else {
[09:31:56.739]                   if (TRUE) {
[09:31:56.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.739]                     {
[09:31:56.739]                       inherits <- base::inherits
[09:31:56.739]                       invokeRestart <- base::invokeRestart
[09:31:56.739]                       is.null <- base::is.null
[09:31:56.739]                       muffled <- FALSE
[09:31:56.739]                       if (inherits(cond, "message")) {
[09:31:56.739]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.739]                         if (muffled) 
[09:31:56.739]                           invokeRestart("muffleMessage")
[09:31:56.739]                       }
[09:31:56.739]                       else if (inherits(cond, "warning")) {
[09:31:56.739]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.739]                         if (muffled) 
[09:31:56.739]                           invokeRestart("muffleWarning")
[09:31:56.739]                       }
[09:31:56.739]                       else if (inherits(cond, "condition")) {
[09:31:56.739]                         if (!is.null(pattern)) {
[09:31:56.739]                           computeRestarts <- base::computeRestarts
[09:31:56.739]                           grepl <- base::grepl
[09:31:56.739]                           restarts <- computeRestarts(cond)
[09:31:56.739]                           for (restart in restarts) {
[09:31:56.739]                             name <- restart$name
[09:31:56.739]                             if (is.null(name)) 
[09:31:56.739]                               next
[09:31:56.739]                             if (!grepl(pattern, name)) 
[09:31:56.739]                               next
[09:31:56.739]                             invokeRestart(restart)
[09:31:56.739]                             muffled <- TRUE
[09:31:56.739]                             break
[09:31:56.739]                           }
[09:31:56.739]                         }
[09:31:56.739]                       }
[09:31:56.739]                       invisible(muffled)
[09:31:56.739]                     }
[09:31:56.739]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.739]                   }
[09:31:56.739]                 }
[09:31:56.739]             }
[09:31:56.739]         }))
[09:31:56.739]     }, error = function(ex) {
[09:31:56.739]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.739]                 ...future.rng), started = ...future.startTime, 
[09:31:56.739]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.739]             version = "1.8"), class = "FutureResult")
[09:31:56.739]     }, finally = {
[09:31:56.739]         if (!identical(...future.workdir, getwd())) 
[09:31:56.739]             setwd(...future.workdir)
[09:31:56.739]         {
[09:31:56.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.739]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.739]             }
[09:31:56.739]             base::options(...future.oldOptions)
[09:31:56.739]             if (.Platform$OS.type == "windows") {
[09:31:56.739]                 old_names <- names(...future.oldEnvVars)
[09:31:56.739]                 envs <- base::Sys.getenv()
[09:31:56.739]                 names <- names(envs)
[09:31:56.739]                 common <- intersect(names, old_names)
[09:31:56.739]                 added <- setdiff(names, old_names)
[09:31:56.739]                 removed <- setdiff(old_names, names)
[09:31:56.739]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.739]                   envs[common]]
[09:31:56.739]                 NAMES <- toupper(changed)
[09:31:56.739]                 args <- list()
[09:31:56.739]                 for (kk in seq_along(NAMES)) {
[09:31:56.739]                   name <- changed[[kk]]
[09:31:56.739]                   NAME <- NAMES[[kk]]
[09:31:56.739]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.739]                     next
[09:31:56.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.739]                 }
[09:31:56.739]                 NAMES <- toupper(added)
[09:31:56.739]                 for (kk in seq_along(NAMES)) {
[09:31:56.739]                   name <- added[[kk]]
[09:31:56.739]                   NAME <- NAMES[[kk]]
[09:31:56.739]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.739]                     next
[09:31:56.739]                   args[[name]] <- ""
[09:31:56.739]                 }
[09:31:56.739]                 NAMES <- toupper(removed)
[09:31:56.739]                 for (kk in seq_along(NAMES)) {
[09:31:56.739]                   name <- removed[[kk]]
[09:31:56.739]                   NAME <- NAMES[[kk]]
[09:31:56.739]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.739]                     next
[09:31:56.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.739]                 }
[09:31:56.739]                 if (length(args) > 0) 
[09:31:56.739]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.739]             }
[09:31:56.739]             else {
[09:31:56.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.739]             }
[09:31:56.739]             {
[09:31:56.739]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.739]                   0L) {
[09:31:56.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.739]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.739]                   base::options(opts)
[09:31:56.739]                 }
[09:31:56.739]                 {
[09:31:56.739]                   {
[09:31:56.739]                     NULL
[09:31:56.739]                     RNGkind("Mersenne-Twister")
[09:31:56.739]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.739]                       inherits = FALSE)
[09:31:56.739]                   }
[09:31:56.739]                   options(future.plan = NULL)
[09:31:56.739]                   if (is.na(NA_character_)) 
[09:31:56.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.739]                     .init = FALSE)
[09:31:56.739]                 }
[09:31:56.739]             }
[09:31:56.739]         }
[09:31:56.739]     })
[09:31:56.739]     if (TRUE) {
[09:31:56.739]         base::sink(type = "output", split = FALSE)
[09:31:56.739]         if (TRUE) {
[09:31:56.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.739]         }
[09:31:56.739]         else {
[09:31:56.739]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.739]         }
[09:31:56.739]         base::close(...future.stdout)
[09:31:56.739]         ...future.stdout <- NULL
[09:31:56.739]     }
[09:31:56.739]     ...future.result$conditions <- ...future.conditions
[09:31:56.739]     ...future.result$finished <- base::Sys.time()
[09:31:56.739]     ...future.result
[09:31:56.739] }
[09:31:56.754]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.741] assign_globals() ...
[09:31:56.754]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.741] List of 1
[09:31:56.741]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:56.741]   ..$ a: int [1:3] 1 2 3
[09:31:56.741]   ..$ b: int [1:3] 3 2 1
[09:31:56.741]  - attr(*, "where")=List of 1
[09:31:56.741]   ..$ data:<environment: R_EmptyEnv> 
[09:31:56.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.741]  - attr(*, "resolved")= logi FALSE
[09:31:56.741]  - attr(*, "total_size")= num 128
[09:31:56.741]  - attr(*, "already-done")= logi TRUE
[09:31:56.754]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.744] - copied ‘data’ to environment
[09:31:56.755]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.744] assign_globals() ... done
[09:31:56.755]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.744] plan(): Setting new future strategy stack:
[09:31:56.755]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.744] List of future strategies:
[09:31:56.744] 1. sequential:
[09:31:56.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.744]    - tweaked: FALSE
[09:31:56.744]    - call: NULL
[09:31:56.755]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.745] plan(): nbrOfWorkers() = 1
[09:31:56.755]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.745] plan(): Setting new future strategy stack:
[09:31:56.755]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.746] List of future strategies:
[09:31:56.746] 1. sequential:
[09:31:56.746]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.746]    - tweaked: FALSE
[09:31:56.746]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.755]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.746] plan(): nbrOfWorkers() = 1
[09:31:56.755]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.746] SequentialFuture started (and completed)
[09:31:56.755]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.746] - Launch lazy future ... done
[09:31:56.756]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.746] run() for ‘SequentialFuture’ ... done
[09:31:56.756] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[09:31:56.756] plan(): Setting new future strategy stack:
[09:31:56.756] List of future strategies:
[09:31:56.756] 1. sequential:
[09:31:56.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.756]    - tweaked: FALSE
[09:31:56.756]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.756] 2. multicore:
[09:31:56.756]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:56.756]    - tweaked: FALSE
[09:31:56.756]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.757] plan(): nbrOfWorkers() = 1
[09:31:56.757] getGlobalsAndPackages() ...
[09:31:56.757] Searching for globals...
[09:31:56.772] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:56.772] Searching for globals ... DONE
[09:31:56.772] Resolving globals: FALSE
[09:31:56.773] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[09:31:56.774] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:56.774] - globals: [2] ‘nested’, ‘strategy2’
[09:31:56.774] - packages: [1] ‘future’
[09:31:56.774] getGlobalsAndPackages() ... DONE
[09:31:56.774] run() for ‘Future’ ...
[09:31:56.774] - state: ‘created’
[09:31:56.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.775] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.775]   - Field: ‘label’
[09:31:56.775]   - Field: ‘local’
[09:31:56.775]   - Field: ‘owner’
[09:31:56.775]   - Field: ‘envir’
[09:31:56.775]   - Field: ‘packages’
[09:31:56.775]   - Field: ‘gc’
[09:31:56.775]   - Field: ‘conditions’
[09:31:56.775]   - Field: ‘expr’
[09:31:56.776]   - Field: ‘uuid’
[09:31:56.776]   - Field: ‘seed’
[09:31:56.776]   - Field: ‘version’
[09:31:56.776]   - Field: ‘result’
[09:31:56.776]   - Field: ‘asynchronous’
[09:31:56.776]   - Field: ‘calls’
[09:31:56.776]   - Field: ‘globals’
[09:31:56.776]   - Field: ‘stdout’
[09:31:56.776]   - Field: ‘earlySignal’
[09:31:56.776]   - Field: ‘lazy’
[09:31:56.776]   - Field: ‘state’
[09:31:56.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.777] - Launch lazy future ...
[09:31:56.777] Packages needed by the future expression (n = 1): ‘future’
[09:31:56.777] Packages needed by future strategies (n = 1): ‘future’
[09:31:56.778] {
[09:31:56.778]     {
[09:31:56.778]         {
[09:31:56.778]             ...future.startTime <- base::Sys.time()
[09:31:56.778]             {
[09:31:56.778]                 {
[09:31:56.778]                   {
[09:31:56.778]                     {
[09:31:56.778]                       base::local({
[09:31:56.778]                         has_future <- base::requireNamespace("future", 
[09:31:56.778]                           quietly = TRUE)
[09:31:56.778]                         if (has_future) {
[09:31:56.778]                           ns <- base::getNamespace("future")
[09:31:56.778]                           version <- ns[[".package"]][["version"]]
[09:31:56.778]                           if (is.null(version)) 
[09:31:56.778]                             version <- utils::packageVersion("future")
[09:31:56.778]                         }
[09:31:56.778]                         else {
[09:31:56.778]                           version <- NULL
[09:31:56.778]                         }
[09:31:56.778]                         if (!has_future || version < "1.8.0") {
[09:31:56.778]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.778]                             "", base::R.version$version.string), 
[09:31:56.778]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.778]                               "release", "version")], collapse = " "), 
[09:31:56.778]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.778]                             info)
[09:31:56.778]                           info <- base::paste(info, collapse = "; ")
[09:31:56.778]                           if (!has_future) {
[09:31:56.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.778]                               info)
[09:31:56.778]                           }
[09:31:56.778]                           else {
[09:31:56.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.778]                               info, version)
[09:31:56.778]                           }
[09:31:56.778]                           base::stop(msg)
[09:31:56.778]                         }
[09:31:56.778]                       })
[09:31:56.778]                     }
[09:31:56.778]                     base::local({
[09:31:56.778]                       for (pkg in "future") {
[09:31:56.778]                         base::loadNamespace(pkg)
[09:31:56.778]                         base::library(pkg, character.only = TRUE)
[09:31:56.778]                       }
[09:31:56.778]                     })
[09:31:56.778]                   }
[09:31:56.778]                   ...future.strategy.old <- future::plan("list")
[09:31:56.778]                   options(future.plan = NULL)
[09:31:56.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.778]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:56.778]                     envir = parent.frame()) 
[09:31:56.778]                   {
[09:31:56.778]                     default_workers <- missing(workers)
[09:31:56.778]                     if (is.function(workers)) 
[09:31:56.778]                       workers <- workers()
[09:31:56.778]                     workers <- structure(as.integer(workers), 
[09:31:56.778]                       class = class(workers))
[09:31:56.778]                     stop_if_not(is.finite(workers), workers >= 
[09:31:56.778]                       1L)
[09:31:56.778]                     if ((workers == 1L && !inherits(workers, 
[09:31:56.778]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:56.778]                       if (default_workers) 
[09:31:56.778]                         supportsMulticore(warn = TRUE)
[09:31:56.778]                       return(sequential(..., envir = envir))
[09:31:56.778]                     }
[09:31:56.778]                     oopts <- options(mc.cores = workers)
[09:31:56.778]                     on.exit(options(oopts))
[09:31:56.778]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:56.778]                       envir = envir)
[09:31:56.778]                     if (!future$lazy) 
[09:31:56.778]                       future <- run(future)
[09:31:56.778]                     invisible(future)
[09:31:56.778]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:56.778]                 }
[09:31:56.778]                 ...future.workdir <- getwd()
[09:31:56.778]             }
[09:31:56.778]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.778]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.778]         }
[09:31:56.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.778]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.778]             base::names(...future.oldOptions))
[09:31:56.778]     }
[09:31:56.778]     if (FALSE) {
[09:31:56.778]     }
[09:31:56.778]     else {
[09:31:56.778]         if (TRUE) {
[09:31:56.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.778]                 open = "w")
[09:31:56.778]         }
[09:31:56.778]         else {
[09:31:56.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.778]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.778]         }
[09:31:56.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.778]             base::sink(type = "output", split = FALSE)
[09:31:56.778]             base::close(...future.stdout)
[09:31:56.778]         }, add = TRUE)
[09:31:56.778]     }
[09:31:56.778]     ...future.frame <- base::sys.nframe()
[09:31:56.778]     ...future.conditions <- base::list()
[09:31:56.778]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.778]     if (FALSE) {
[09:31:56.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.778]     }
[09:31:56.778]     ...future.result <- base::tryCatch({
[09:31:56.778]         base::withCallingHandlers({
[09:31:56.778]             ...future.value <- base::withVisible(base::local({
[09:31:56.778]                 a <- 1L
[09:31:56.778]                 plan_a <- unclass(future::plan("list"))
[09:31:56.778]                 nested_a <- nested[-1]
[09:31:56.778]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:56.778]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.778]                   strategy2))
[09:31:56.778]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:56.778]                   "init") <- NULL
[09:31:56.778]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:56.778]                   "init") <- NULL
[09:31:56.778]                 stopifnot(all.equal(plan_a, nested_a))
[09:31:56.778]                 y %<-% {
[09:31:56.778]                   b <- 2L
[09:31:56.778]                   plan_b <- future::plan("list")
[09:31:56.778]                   nested_b <- nested_a[-1]
[09:31:56.778]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:56.778]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.778]                     "sequential"))
[09:31:56.778]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:56.778]                     b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:56.778]                 }
[09:31:56.778]                 y
[09:31:56.778]             }))
[09:31:56.778]             future::FutureResult(value = ...future.value$value, 
[09:31:56.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.778]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.778]                     ...future.globalenv.names))
[09:31:56.778]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.778]         }, condition = base::local({
[09:31:56.778]             c <- base::c
[09:31:56.778]             inherits <- base::inherits
[09:31:56.778]             invokeRestart <- base::invokeRestart
[09:31:56.778]             length <- base::length
[09:31:56.778]             list <- base::list
[09:31:56.778]             seq.int <- base::seq.int
[09:31:56.778]             signalCondition <- base::signalCondition
[09:31:56.778]             sys.calls <- base::sys.calls
[09:31:56.778]             `[[` <- base::`[[`
[09:31:56.778]             `+` <- base::`+`
[09:31:56.778]             `<<-` <- base::`<<-`
[09:31:56.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.778]                   3L)]
[09:31:56.778]             }
[09:31:56.778]             function(cond) {
[09:31:56.778]                 is_error <- inherits(cond, "error")
[09:31:56.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.778]                   NULL)
[09:31:56.778]                 if (is_error) {
[09:31:56.778]                   sessionInformation <- function() {
[09:31:56.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.778]                       search = base::search(), system = base::Sys.info())
[09:31:56.778]                   }
[09:31:56.778]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.778]                     cond$call), session = sessionInformation(), 
[09:31:56.778]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.778]                   signalCondition(cond)
[09:31:56.778]                 }
[09:31:56.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.778]                 "immediateCondition"))) {
[09:31:56.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.778]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.778]                   if (TRUE && !signal) {
[09:31:56.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.778]                     {
[09:31:56.778]                       inherits <- base::inherits
[09:31:56.778]                       invokeRestart <- base::invokeRestart
[09:31:56.778]                       is.null <- base::is.null
[09:31:56.778]                       muffled <- FALSE
[09:31:56.778]                       if (inherits(cond, "message")) {
[09:31:56.778]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.778]                         if (muffled) 
[09:31:56.778]                           invokeRestart("muffleMessage")
[09:31:56.778]                       }
[09:31:56.778]                       else if (inherits(cond, "warning")) {
[09:31:56.778]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.778]                         if (muffled) 
[09:31:56.778]                           invokeRestart("muffleWarning")
[09:31:56.778]                       }
[09:31:56.778]                       else if (inherits(cond, "condition")) {
[09:31:56.778]                         if (!is.null(pattern)) {
[09:31:56.778]                           computeRestarts <- base::computeRestarts
[09:31:56.778]                           grepl <- base::grepl
[09:31:56.778]                           restarts <- computeRestarts(cond)
[09:31:56.778]                           for (restart in restarts) {
[09:31:56.778]                             name <- restart$name
[09:31:56.778]                             if (is.null(name)) 
[09:31:56.778]                               next
[09:31:56.778]                             if (!grepl(pattern, name)) 
[09:31:56.778]                               next
[09:31:56.778]                             invokeRestart(restart)
[09:31:56.778]                             muffled <- TRUE
[09:31:56.778]                             break
[09:31:56.778]                           }
[09:31:56.778]                         }
[09:31:56.778]                       }
[09:31:56.778]                       invisible(muffled)
[09:31:56.778]                     }
[09:31:56.778]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.778]                   }
[09:31:56.778]                 }
[09:31:56.778]                 else {
[09:31:56.778]                   if (TRUE) {
[09:31:56.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.778]                     {
[09:31:56.778]                       inherits <- base::inherits
[09:31:56.778]                       invokeRestart <- base::invokeRestart
[09:31:56.778]                       is.null <- base::is.null
[09:31:56.778]                       muffled <- FALSE
[09:31:56.778]                       if (inherits(cond, "message")) {
[09:31:56.778]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.778]                         if (muffled) 
[09:31:56.778]                           invokeRestart("muffleMessage")
[09:31:56.778]                       }
[09:31:56.778]                       else if (inherits(cond, "warning")) {
[09:31:56.778]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.778]                         if (muffled) 
[09:31:56.778]                           invokeRestart("muffleWarning")
[09:31:56.778]                       }
[09:31:56.778]                       else if (inherits(cond, "condition")) {
[09:31:56.778]                         if (!is.null(pattern)) {
[09:31:56.778]                           computeRestarts <- base::computeRestarts
[09:31:56.778]                           grepl <- base::grepl
[09:31:56.778]                           restarts <- computeRestarts(cond)
[09:31:56.778]                           for (restart in restarts) {
[09:31:56.778]                             name <- restart$name
[09:31:56.778]                             if (is.null(name)) 
[09:31:56.778]                               next
[09:31:56.778]                             if (!grepl(pattern, name)) 
[09:31:56.778]                               next
[09:31:56.778]                             invokeRestart(restart)
[09:31:56.778]                             muffled <- TRUE
[09:31:56.778]                             break
[09:31:56.778]                           }
[09:31:56.778]                         }
[09:31:56.778]                       }
[09:31:56.778]                       invisible(muffled)
[09:31:56.778]                     }
[09:31:56.778]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.778]                   }
[09:31:56.778]                 }
[09:31:56.778]             }
[09:31:56.778]         }))
[09:31:56.778]     }, error = function(ex) {
[09:31:56.778]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.778]                 ...future.rng), started = ...future.startTime, 
[09:31:56.778]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.778]             version = "1.8"), class = "FutureResult")
[09:31:56.778]     }, finally = {
[09:31:56.778]         if (!identical(...future.workdir, getwd())) 
[09:31:56.778]             setwd(...future.workdir)
[09:31:56.778]         {
[09:31:56.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.778]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.778]             }
[09:31:56.778]             base::options(...future.oldOptions)
[09:31:56.778]             if (.Platform$OS.type == "windows") {
[09:31:56.778]                 old_names <- names(...future.oldEnvVars)
[09:31:56.778]                 envs <- base::Sys.getenv()
[09:31:56.778]                 names <- names(envs)
[09:31:56.778]                 common <- intersect(names, old_names)
[09:31:56.778]                 added <- setdiff(names, old_names)
[09:31:56.778]                 removed <- setdiff(old_names, names)
[09:31:56.778]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.778]                   envs[common]]
[09:31:56.778]                 NAMES <- toupper(changed)
[09:31:56.778]                 args <- list()
[09:31:56.778]                 for (kk in seq_along(NAMES)) {
[09:31:56.778]                   name <- changed[[kk]]
[09:31:56.778]                   NAME <- NAMES[[kk]]
[09:31:56.778]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.778]                     next
[09:31:56.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.778]                 }
[09:31:56.778]                 NAMES <- toupper(added)
[09:31:56.778]                 for (kk in seq_along(NAMES)) {
[09:31:56.778]                   name <- added[[kk]]
[09:31:56.778]                   NAME <- NAMES[[kk]]
[09:31:56.778]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.778]                     next
[09:31:56.778]                   args[[name]] <- ""
[09:31:56.778]                 }
[09:31:56.778]                 NAMES <- toupper(removed)
[09:31:56.778]                 for (kk in seq_along(NAMES)) {
[09:31:56.778]                   name <- removed[[kk]]
[09:31:56.778]                   NAME <- NAMES[[kk]]
[09:31:56.778]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.778]                     next
[09:31:56.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.778]                 }
[09:31:56.778]                 if (length(args) > 0) 
[09:31:56.778]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.778]             }
[09:31:56.778]             else {
[09:31:56.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.778]             }
[09:31:56.778]             {
[09:31:56.778]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.778]                   0L) {
[09:31:56.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.778]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.778]                   base::options(opts)
[09:31:56.778]                 }
[09:31:56.778]                 {
[09:31:56.778]                   {
[09:31:56.778]                     NULL
[09:31:56.778]                     RNGkind("Mersenne-Twister")
[09:31:56.778]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.778]                       inherits = FALSE)
[09:31:56.778]                   }
[09:31:56.778]                   options(future.plan = NULL)
[09:31:56.778]                   if (is.na(NA_character_)) 
[09:31:56.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.778]                     .init = FALSE)
[09:31:56.778]                 }
[09:31:56.778]             }
[09:31:56.778]         }
[09:31:56.778]     })
[09:31:56.778]     if (TRUE) {
[09:31:56.778]         base::sink(type = "output", split = FALSE)
[09:31:56.778]         if (TRUE) {
[09:31:56.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.778]         }
[09:31:56.778]         else {
[09:31:56.778]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.778]         }
[09:31:56.778]         base::close(...future.stdout)
[09:31:56.778]         ...future.stdout <- NULL
[09:31:56.778]     }
[09:31:56.778]     ...future.result$conditions <- ...future.conditions
[09:31:56.778]     ...future.result$finished <- base::Sys.time()
[09:31:56.778]     ...future.result
[09:31:56.778] }
[09:31:56.780] assign_globals() ...
[09:31:56.780] List of 2
[09:31:56.780]  $ nested   :List of 2
[09:31:56.780]   ..$ a:function (..., envir = parent.frame())  
[09:31:56.780]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:56.780]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.780]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:56.780]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:56.780]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.780]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:56.780]  $ strategy2: chr "multicore"
[09:31:56.780]  - attr(*, "where")=List of 2
[09:31:56.780]   ..$ nested   :<environment: R_EmptyEnv> 
[09:31:56.780]   ..$ strategy2:<environment: R_EmptyEnv> 
[09:31:56.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.780]  - attr(*, "resolved")= logi FALSE
[09:31:56.780]  - attr(*, "total_size")= num 59224
[09:31:56.780]  - attr(*, "already-done")= logi TRUE
[09:31:56.784] - copied ‘nested’ to environment
[09:31:56.784] - copied ‘strategy2’ to environment
[09:31:56.784] assign_globals() ... done
[09:31:56.785] plan(): Setting new future strategy stack:
[09:31:56.785] List of future strategies:
[09:31:56.785] 1. multicore:
[09:31:56.785]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:56.785]    - tweaked: FALSE
[09:31:56.785]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.788] plan(): nbrOfWorkers() = 2
[09:31:56.848] plan(): Setting new future strategy stack:
[09:31:56.848] List of future strategies:
[09:31:56.848] 1. sequential:
[09:31:56.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.848]    - tweaked: FALSE
[09:31:56.848]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.848] 2. multicore:
[09:31:56.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:56.848]    - tweaked: FALSE
[09:31:56.848]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.849] plan(): nbrOfWorkers() = 1
[09:31:56.849] SequentialFuture started (and completed)
[09:31:56.849] signalConditions() ...
[09:31:56.849]  - include = ‘immediateCondition’
[09:31:56.849]  - exclude = 
[09:31:56.850]  - resignal = FALSE
[09:31:56.850]  - Number of conditions: 57
[09:31:56.850] signalConditions() ... done
[09:31:56.850] - Launch lazy future ... done
[09:31:56.850] run() for ‘SequentialFuture’ ... done
[09:31:56.850] signalConditions() ...
[09:31:56.850]  - include = ‘immediateCondition’
[09:31:56.851]  - exclude = 
[09:31:56.851]  - resignal = FALSE
[09:31:56.851]  - Number of conditions: 57
[09:31:56.851] signalConditions() ... done
[09:31:56.851] Future state: ‘finished’
[09:31:56.851] signalConditions() ...
[09:31:56.851]  - include = ‘condition’
[09:31:56.851]  - exclude = ‘immediateCondition’
[09:31:56.851]  - resignal = TRUE
[09:31:56.852]  - Number of conditions: 57
[09:31:56.852]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.789] getGlobalsAndPackages() ...
[09:31:56.852]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.789] Searching for globals...
[09:31:56.852]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.806] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[09:31:56.852]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.806] Searching for globals ... DONE
[09:31:56.852]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.807] Resolving globals: FALSE
[09:31:56.852]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.807] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[09:31:56.853]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[09:31:56.853]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[09:31:56.853]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] 
[09:31:56.853]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] getGlobalsAndPackages() ... DONE
[09:31:56.853]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] run() for ‘Future’ ...
[09:31:56.853]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] - state: ‘created’
[09:31:56.853]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.808] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:56.854]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:56.854]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:56.854]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812]   - Field: ‘label’
[09:31:56.854]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812]   - Field: ‘local’
[09:31:56.854]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812]   - Field: ‘owner’
[09:31:56.854]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812]   - Field: ‘envir’
[09:31:56.854]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.812]   - Field: ‘workers’
[09:31:56.855]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘packages’
[09:31:56.855]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘gc’
[09:31:56.855]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘job’
[09:31:56.855]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘conditions’
[09:31:56.855]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘expr’
[09:31:56.855]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘uuid’
[09:31:56.856]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘seed’
[09:31:56.856]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘version’
[09:31:56.856]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘result’
[09:31:56.856]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.813]   - Field: ‘asynchronous’
[09:31:56.856]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814]   - Field: ‘calls’
[09:31:56.856]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814]   - Field: ‘globals’
[09:31:56.856]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814]   - Field: ‘stdout’
[09:31:56.857]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814]   - Field: ‘earlySignal’
[09:31:56.857]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814]   - Field: ‘lazy’
[09:31:56.857]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814]   - Field: ‘state’
[09:31:56.857]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:56.857]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.814] - Launch lazy future ...
[09:31:56.857]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.815] Packages needed by the future expression (n = 0): <none>
[09:31:56.857]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.815] Packages needed by future strategies (n = 0): <none>
[09:31:56.858]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.816] {
[09:31:56.816]     {
[09:31:56.816]         {
[09:31:56.816]             ...future.startTime <- base::Sys.time()
[09:31:56.816]             {
[09:31:56.816]                 {
[09:31:56.816]                   {
[09:31:56.816]                     {
[09:31:56.816]                       base::local({
[09:31:56.816]                         has_future <- base::requireNamespace("future", 
[09:31:56.816]                           quietly = TRUE)
[09:31:56.816]                         if (has_future) {
[09:31:56.816]                           ns <- base::getNamespace("future")
[09:31:56.816]                           version <- ns[[".package"]][["version"]]
[09:31:56.816]                           if (is.null(version)) 
[09:31:56.816]                             version <- utils::packageVersion("future")
[09:31:56.816]                         }
[09:31:56.816]                         else {
[09:31:56.816]                           version <- NULL
[09:31:56.816]                         }
[09:31:56.816]                         if (!has_future || version < "1.8.0") {
[09:31:56.816]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.816]                             "", base::R.version$version.string), 
[09:31:56.816]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.816]                               "release", "version")], collapse = " "), 
[09:31:56.816]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.816]                             info)
[09:31:56.816]                           info <- base::paste(info, collapse = "; ")
[09:31:56.816]                           if (!has_future) {
[09:31:56.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.816]                               info)
[09:31:56.816]                           }
[09:31:56.816]                           else {
[09:31:56.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.816]                               info, version)
[09:31:56.816]                           }
[09:31:56.816]                           base::stop(msg)
[09:31:56.816]                         }
[09:31:56.816]                       })
[09:31:56.816]                     }
[09:31:56.816]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:56.816]                     base::options(mc.cores = 1L)
[09:31:56.816]                   }
[09:31:56.816]                   ...future.strategy.old <- future::plan("list")
[09:31:56.816]                   options(future.plan = NULL)
[09:31:56.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:56.816]                 }
[09:31:56.816]                 ...future.workdir <- getwd()
[09:31:56.816]             }
[09:31:56.816]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.816]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.816]         }
[09:31:56.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.816]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.816]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.816]             base::names(...future.oldOptions))
[09:31:56.816]     }
[09:31:56.816]     if (FALSE) {
[09:31:56.816]     }
[09:31:56.816]     else {
[09:31:56.816]         if (TRUE) {
[09:31:56.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.816]                 open = "w")
[09:31:56.816]         }
[09:31:56.816]         else {
[09:31:56.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.816]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.816]         }
[09:31:56.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.816]             base::sink(type = "output", split = FALSE)
[09:31:56.816]             base::close(...future.stdout)
[09:31:56.816]         }, add = TRUE)
[09:31:56.816]     }
[09:31:56.816]     ...future.frame <- base::sys.nframe()
[09:31:56.816]     ...future.conditions <- base::list()
[09:31:56.816]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.816]     if (FALSE) {
[09:31:56.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.816]     }
[09:31:56.816]     ...future.result <- base::tryCatch({
[09:31:56.816]         base::withCallingHandlers({
[09:31:56.816]             ...future.value <- base::withVisible(base::local({
[09:31:56.816]                 withCallingHandlers({
[09:31:56.816]                   {
[09:31:56.816]                     b <- 2L
[09:31:56.816]                     plan_b <- future::plan("list")
[09:31:56.816]                     nested_b <- nested_a[-1]
[09:31:56.816]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:56.816]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.816]                       "sequential"))
[09:31:56.816]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:56.816]                       b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:56.816]                   }
[09:31:56.816]                 }, immediateCondition = function(cond) {
[09:31:56.816]                   save_rds <- function (object, pathname, ...) 
[09:31:56.816]                   {
[09:31:56.816]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:56.816]                     if (file_test("-f", pathname_tmp)) {
[09:31:56.816]                       fi_tmp <- file.info(pathname_tmp)
[09:31:56.816]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:56.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:56.816]                         fi_tmp[["mtime"]])
[09:31:56.816]                     }
[09:31:56.816]                     tryCatch({
[09:31:56.816]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:56.816]                     }, error = function(ex) {
[09:31:56.816]                       msg <- conditionMessage(ex)
[09:31:56.816]                       fi_tmp <- file.info(pathname_tmp)
[09:31:56.816]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:56.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:56.816]                         fi_tmp[["mtime"]], msg)
[09:31:56.816]                       ex$message <- msg
[09:31:56.816]                       stop(ex)
[09:31:56.816]                     })
[09:31:56.816]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:56.816]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:56.816]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:56.816]                       fi_tmp <- file.info(pathname_tmp)
[09:31:56.816]                       fi <- file.info(pathname)
[09:31:56.816]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:56.816]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:56.816]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:56.816]                         fi[["size"]], fi[["mtime"]])
[09:31:56.816]                       stop(msg)
[09:31:56.816]                     }
[09:31:56.816]                     invisible(pathname)
[09:31:56.816]                   }
[09:31:56.816]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:56.816]                     rootPath = tempdir()) 
[09:31:56.816]                   {
[09:31:56.816]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:56.816]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:56.816]                       tmpdir = path, fileext = ".rds")
[09:31:56.816]                     save_rds(obj, file)
[09:31:56.816]                   }
[09:31:56.816]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:56.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.816]                   {
[09:31:56.816]                     inherits <- base::inherits
[09:31:56.816]                     invokeRestart <- base::invokeRestart
[09:31:56.816]                     is.null <- base::is.null
[09:31:56.816]                     muffled <- FALSE
[09:31:56.816]                     if (inherits(cond, "message")) {
[09:31:56.816]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:56.816]                       if (muffled) 
[09:31:56.816]                         invokeRestart("muffleMessage")
[09:31:56.816]                     }
[09:31:56.816]                     else if (inherits(cond, "warning")) {
[09:31:56.816]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:56.816]                       if (muffled) 
[09:31:56.816]                         invokeRestart("muffleWarning")
[09:31:56.816]                     }
[09:31:56.816]                     else if (inherits(cond, "condition")) {
[09:31:56.816]                       if (!is.null(pattern)) {
[09:31:56.816]                         computeRestarts <- base::computeRestarts
[09:31:56.816]                         grepl <- base::grepl
[09:31:56.816]                         restarts <- computeRestarts(cond)
[09:31:56.816]                         for (restart in restarts) {
[09:31:56.816]                           name <- restart$name
[09:31:56.816]                           if (is.null(name)) 
[09:31:56.816]                             next
[09:31:56.816]                           if (!grepl(pattern, name)) 
[09:31:56.816]                             next
[09:31:56.816]                           invokeRestart(restart)
[09:31:56.816]                           muffled <- TRUE
[09:31:56.816]                           break
[09:31:56.816]                         }
[09:31:56.816]                       }
[09:31:56.816]                     }
[09:31:56.816]                     invisible(muffled)
[09:31:56.816]                   }
[09:31:56.816]                   muffleCondition(cond)
[09:31:56.816]                 })
[09:31:56.816]             }))
[09:31:56.816]             future::FutureResult(value = ...future.value$value, 
[09:31:56.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.816]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.816]                     ...future.globalenv.names))
[09:31:56.816]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.816]         }, condition = base::local({
[09:31:56.816]             c <- base::c
[09:31:56.816]             inherits <- base::inherits
[09:31:56.816]             invokeRestart <- base::invokeRestart
[09:31:56.816]             length <- base::length
[09:31:56.816]             list <- base::list
[09:31:56.816]             seq.int <- base::seq.int
[09:31:56.816]             signalCondition <- base::signalCondition
[09:31:56.816]             sys.calls <- base::sys.calls
[09:31:56.816]             `[[` <- base::`[[`
[09:31:56.816]             `+` <- base::`+`
[09:31:56.816]             `<<-` <- base::`<<-`
[09:31:56.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.816]                   3L)]
[09:31:56.816]             }
[09:31:56.816]             function(cond) {
[09:31:56.816]                 is_error <- inherits(cond, "error")
[09:31:56.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.816]                   NULL)
[09:31:56.816]                 if (is_error) {
[09:31:56.816]                   sessionInformation <- function() {
[09:31:56.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.816]                       search = base::search(), system = base::Sys.info())
[09:31:56.816]                   }
[09:31:56.816]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.816]                     cond$call), session = sessionInformation(), 
[09:31:56.816]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.816]                   signalCondition(cond)
[09:31:56.816]                 }
[09:31:56.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.816]                 "immediateCondition"))) {
[09:31:56.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.816]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.816]                   if (TRUE && !signal) {
[09:31:56.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.816]                     {
[09:31:56.816]                       inherits <- base::inherits
[09:31:56.816]                       invokeRestart <- base::invokeRestart
[09:31:56.816]                       is.null <- base::is.null
[09:31:56.816]                       muffled <- FALSE
[09:31:56.816]                       if (inherits(cond, "message")) {
[09:31:56.816]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.816]                         if (muffled) 
[09:31:56.816]                           invokeRestart("muffleMessage")
[09:31:56.816]                       }
[09:31:56.816]                       else if (inherits(cond, "warning")) {
[09:31:56.816]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.816]                         if (muffled) 
[09:31:56.816]                           invokeRestart("muffleWarning")
[09:31:56.816]                       }
[09:31:56.816]                       else if (inherits(cond, "condition")) {
[09:31:56.816]                         if (!is.null(pattern)) {
[09:31:56.816]                           computeRestarts <- base::computeRestarts
[09:31:56.816]                           grepl <- base::grepl
[09:31:56.816]                           restarts <- computeRestarts(cond)
[09:31:56.816]                           for (restart in restarts) {
[09:31:56.816]                             name <- restart$name
[09:31:56.816]                             if (is.null(name)) 
[09:31:56.816]                               next
[09:31:56.816]                             if (!grepl(pattern, name)) 
[09:31:56.816]                               next
[09:31:56.816]                             invokeRestart(restart)
[09:31:56.816]                             muffled <- TRUE
[09:31:56.816]                             break
[09:31:56.816]                           }
[09:31:56.816]                         }
[09:31:56.816]                       }
[09:31:56.816]                       invisible(muffled)
[09:31:56.816]                     }
[09:31:56.816]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.816]                   }
[09:31:56.816]                 }
[09:31:56.816]                 else {
[09:31:56.816]                   if (TRUE) {
[09:31:56.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.816]                     {
[09:31:56.816]                       inherits <- base::inherits
[09:31:56.816]                       invokeRestart <- base::invokeRestart
[09:31:56.816]                       is.null <- base::is.null
[09:31:56.816]                       muffled <- FALSE
[09:31:56.816]                       if (inherits(cond, "message")) {
[09:31:56.816]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.816]                         if (muffled) 
[09:31:56.816]                           invokeRestart("muffleMessage")
[09:31:56.816]                       }
[09:31:56.816]                       else if (inherits(cond, "warning")) {
[09:31:56.816]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.816]                         if (muffled) 
[09:31:56.816]                           invokeRestart("muffleWarning")
[09:31:56.816]                       }
[09:31:56.816]                       else if (inherits(cond, "condition")) {
[09:31:56.816]                         if (!is.null(pattern)) {
[09:31:56.816]                           computeRestarts <- base::computeRestarts
[09:31:56.816]                           grepl <- base::grepl
[09:31:56.816]                           restarts <- computeRestarts(cond)
[09:31:56.816]                           for (restart in restarts) {
[09:31:56.816]                             name <- restart$name
[09:31:56.816]                             if (is.null(name)) 
[09:31:56.816]                               next
[09:31:56.816]                             if (!grepl(pattern, name)) 
[09:31:56.816]                               next
[09:31:56.816]                             invokeRestart(restart)
[09:31:56.816]                             muffled <- TRUE
[09:31:56.816]                             break
[09:31:56.816]                           }
[09:31:56.816]                         }
[09:31:56.816]                       }
[09:31:56.816]                       invisible(muffled)
[09:31:56.816]                     }
[09:31:56.816]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.816]                   }
[09:31:56.816]                 }
[09:31:56.816]             }
[09:31:56.816]         }))
[09:31:56.816]     }, error = function(ex) {
[09:31:56.816]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.816]                 ...future.rng), started = ...future.startTime, 
[09:31:56.816]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.816]             version = "1.8"), class = "FutureResult")
[09:31:56.816]     }, finally = {
[09:31:56.816]         if (!identical(...future.workdir, getwd())) 
[09:31:56.816]             setwd(...future.workdir)
[09:31:56.816]         {
[09:31:56.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.816]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.816]             }
[09:31:56.816]             base::options(...future.oldOptions)
[09:31:56.816]             if (.Platform$OS.type == "windows") {
[09:31:56.816]                 old_names <- names(...future.oldEnvVars)
[09:31:56.816]                 envs <- base::Sys.getenv()
[09:31:56.816]                 names <- names(envs)
[09:31:56.816]                 common <- intersect(names, old_names)
[09:31:56.816]                 added <- setdiff(names, old_names)
[09:31:56.816]                 removed <- setdiff(old_names, names)
[09:31:56.816]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.816]                   envs[common]]
[09:31:56.816]                 NAMES <- toupper(changed)
[09:31:56.816]                 args <- list()
[09:31:56.816]                 for (kk in seq_along(NAMES)) {
[09:31:56.816]                   name <- changed[[kk]]
[09:31:56.816]                   NAME <- NAMES[[kk]]
[09:31:56.816]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.816]                     next
[09:31:56.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.816]                 }
[09:31:56.816]                 NAMES <- toupper(added)
[09:31:56.816]                 for (kk in seq_along(NAMES)) {
[09:31:56.816]                   name <- added[[kk]]
[09:31:56.816]                   NAME <- NAMES[[kk]]
[09:31:56.816]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.816]                     next
[09:31:56.816]                   args[[name]] <- ""
[09:31:56.816]                 }
[09:31:56.816]                 NAMES <- toupper(removed)
[09:31:56.816]                 for (kk in seq_along(NAMES)) {
[09:31:56.816]                   name <- removed[[kk]]
[09:31:56.816]                   NAME <- NAMES[[kk]]
[09:31:56.816]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.816]                     next
[09:31:56.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.816]                 }
[09:31:56.816]                 if (length(args) > 0) 
[09:31:56.816]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.816]             }
[09:31:56.816]             else {
[09:31:56.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.816]             }
[09:31:56.816]             {
[09:31:56.816]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.816]                   0L) {
[09:31:56.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.816]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.816]                   base::options(opts)
[09:31:56.816]                 }
[09:31:56.816]                 {
[09:31:56.816]                   {
[09:31:56.816]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:56.816]                     NULL
[09:31:56.816]                   }
[09:31:56.816]                   options(future.plan = NULL)
[09:31:56.816]                   if (is.na(NA_character_)) 
[09:31:56.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.816]                     .init = FALSE)
[09:31:56.816]                 }
[09:31:56.816]             }
[09:31:56.816]         }
[09:31:56.816]     })
[09:31:56.816]     if (TRUE) {
[09:31:56.816]         base::sink(type = "output", split = FALSE)
[09:31:56.816]         if (TRUE) {
[09:31:56.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.816]         }
[09:31:56.816]         else {
[09:31:56.816]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.816]         }
[09:31:56.816]         base::close(...future.stdout)
[09:31:56.816]         ...future.stdout <- NULL
[09:31:56.816]     }
[09:31:56.816]     ...future.result$conditions <- ...future.conditions
[09:31:56.816]     ...future.result$finished <- base::Sys.time()
[09:31:56.816]     ...future.result
[09:31:56.816] }
[09:31:56.858]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.818] assign_globals() ...
[09:31:56.858]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.818] List of 3
[09:31:56.818]  $ nested_a:List of 1
[09:31:56.818]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:56.818]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:56.818]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.818]  $ a       : int 1
[09:31:56.818]  $ plan_a  :List of 1
[09:31:56.818]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:56.818]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:56.818]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.818]  - attr(*, "where")=List of 3
[09:31:56.818]   ..$ nested_a:<environment: R_EmptyEnv> 
[09:31:56.818]   ..$ a       :<environment: R_EmptyEnv> 
[09:31:56.818]   ..$ plan_a  :<environment: R_EmptyEnv> 
[09:31:56.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.818]  - attr(*, "resolved")= logi FALSE
[09:31:56.818]  - attr(*, "total_size")= num 95240
[09:31:56.818]  - attr(*, "already-done")= logi TRUE
[09:31:56.858]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.822] - copied ‘nested_a’ to environment
[09:31:56.858]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.822] - copied ‘a’ to environment
[09:31:56.858]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.822] - copied ‘plan_a’ to environment
[09:31:56.858]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.823] assign_globals() ... done
[09:31:56.859]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.823] requestCore(): workers = 2
[09:31:56.859]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.826] MulticoreFuture started
[09:31:56.859]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.826] - Launch lazy future ... done
[09:31:56.859]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.826] run() for ‘MulticoreFuture’ ... done
[09:31:56.859]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.828] result() for MulticoreFuture ...
[09:31:56.859]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.847] result() for MulticoreFuture ...
[09:31:56.859]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.847] result() for MulticoreFuture ... done
[09:31:56.860]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.847] result() for MulticoreFuture ... done
[09:31:56.860]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.847] result() for MulticoreFuture ...
[09:31:56.860]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.847] result() for MulticoreFuture ... done
[09:31:56.860] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:56.865] getGlobalsAndPackages() ...
[09:31:56.866] Searching for globals...
[09:31:56.867] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:56.867] Searching for globals ... DONE
[09:31:56.867] Resolving globals: FALSE
[09:31:56.868] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:56.868] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:56.868] - globals: [1] ‘data’
[09:31:56.868] - packages: [1] ‘future’
[09:31:56.869] getGlobalsAndPackages() ... DONE
[09:31:56.869] run() for ‘Future’ ...
[09:31:56.869] - state: ‘created’
[09:31:56.869] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.869] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.870]   - Field: ‘label’
[09:31:56.871]   - Field: ‘local’
[09:31:56.871]   - Field: ‘owner’
[09:31:56.871]   - Field: ‘envir’
[09:31:56.871]   - Field: ‘packages’
[09:31:56.871]   - Field: ‘gc’
[09:31:56.871]   - Field: ‘conditions’
[09:31:56.871]   - Field: ‘expr’
[09:31:56.871]   - Field: ‘uuid’
[09:31:56.871]   - Field: ‘seed’
[09:31:56.871]   - Field: ‘version’
[09:31:56.871]   - Field: ‘result’
[09:31:56.871]   - Field: ‘asynchronous’
[09:31:56.872]   - Field: ‘calls’
[09:31:56.872]   - Field: ‘globals’
[09:31:56.872]   - Field: ‘stdout’
[09:31:56.872]   - Field: ‘earlySignal’
[09:31:56.872]   - Field: ‘lazy’
[09:31:56.872]   - Field: ‘state’
[09:31:56.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.872] - Launch lazy future ...
[09:31:56.872] Packages needed by the future expression (n = 1): ‘future’
[09:31:56.873] Packages needed by future strategies (n = 1): ‘future’
[09:31:56.873] {
[09:31:56.873]     {
[09:31:56.873]         {
[09:31:56.873]             ...future.startTime <- base::Sys.time()
[09:31:56.873]             {
[09:31:56.873]                 {
[09:31:56.873]                   {
[09:31:56.873]                     {
[09:31:56.873]                       base::local({
[09:31:56.873]                         has_future <- base::requireNamespace("future", 
[09:31:56.873]                           quietly = TRUE)
[09:31:56.873]                         if (has_future) {
[09:31:56.873]                           ns <- base::getNamespace("future")
[09:31:56.873]                           version <- ns[[".package"]][["version"]]
[09:31:56.873]                           if (is.null(version)) 
[09:31:56.873]                             version <- utils::packageVersion("future")
[09:31:56.873]                         }
[09:31:56.873]                         else {
[09:31:56.873]                           version <- NULL
[09:31:56.873]                         }
[09:31:56.873]                         if (!has_future || version < "1.8.0") {
[09:31:56.873]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.873]                             "", base::R.version$version.string), 
[09:31:56.873]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.873]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.873]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.873]                               "release", "version")], collapse = " "), 
[09:31:56.873]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.873]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.873]                             info)
[09:31:56.873]                           info <- base::paste(info, collapse = "; ")
[09:31:56.873]                           if (!has_future) {
[09:31:56.873]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.873]                               info)
[09:31:56.873]                           }
[09:31:56.873]                           else {
[09:31:56.873]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.873]                               info, version)
[09:31:56.873]                           }
[09:31:56.873]                           base::stop(msg)
[09:31:56.873]                         }
[09:31:56.873]                       })
[09:31:56.873]                     }
[09:31:56.873]                     base::local({
[09:31:56.873]                       for (pkg in "future") {
[09:31:56.873]                         base::loadNamespace(pkg)
[09:31:56.873]                         base::library(pkg, character.only = TRUE)
[09:31:56.873]                       }
[09:31:56.873]                     })
[09:31:56.873]                   }
[09:31:56.873]                   ...future.strategy.old <- future::plan("list")
[09:31:56.873]                   options(future.plan = NULL)
[09:31:56.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.873]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:56.873]                     envir = parent.frame()) 
[09:31:56.873]                   {
[09:31:56.873]                     default_workers <- missing(workers)
[09:31:56.873]                     if (is.function(workers)) 
[09:31:56.873]                       workers <- workers()
[09:31:56.873]                     workers <- structure(as.integer(workers), 
[09:31:56.873]                       class = class(workers))
[09:31:56.873]                     stop_if_not(is.finite(workers), workers >= 
[09:31:56.873]                       1L)
[09:31:56.873]                     if ((workers == 1L && !inherits(workers, 
[09:31:56.873]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:56.873]                       if (default_workers) 
[09:31:56.873]                         supportsMulticore(warn = TRUE)
[09:31:56.873]                       return(sequential(..., envir = envir))
[09:31:56.873]                     }
[09:31:56.873]                     oopts <- options(mc.cores = workers)
[09:31:56.873]                     on.exit(options(oopts))
[09:31:56.873]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:56.873]                       envir = envir)
[09:31:56.873]                     if (!future$lazy) 
[09:31:56.873]                       future <- run(future)
[09:31:56.873]                     invisible(future)
[09:31:56.873]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:56.873]                 }
[09:31:56.873]                 ...future.workdir <- getwd()
[09:31:56.873]             }
[09:31:56.873]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.873]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.873]         }
[09:31:56.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.873]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.873]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.873]             base::names(...future.oldOptions))
[09:31:56.873]     }
[09:31:56.873]     if (FALSE) {
[09:31:56.873]     }
[09:31:56.873]     else {
[09:31:56.873]         if (TRUE) {
[09:31:56.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.873]                 open = "w")
[09:31:56.873]         }
[09:31:56.873]         else {
[09:31:56.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.873]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.873]         }
[09:31:56.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.873]             base::sink(type = "output", split = FALSE)
[09:31:56.873]             base::close(...future.stdout)
[09:31:56.873]         }, add = TRUE)
[09:31:56.873]     }
[09:31:56.873]     ...future.frame <- base::sys.nframe()
[09:31:56.873]     ...future.conditions <- base::list()
[09:31:56.873]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.873]     if (FALSE) {
[09:31:56.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.873]     }
[09:31:56.873]     ...future.result <- base::tryCatch({
[09:31:56.873]         base::withCallingHandlers({
[09:31:56.873]             ...future.value <- base::withVisible(base::local({
[09:31:56.873]                 value(future(subset(data, a == 2)))
[09:31:56.873]             }))
[09:31:56.873]             future::FutureResult(value = ...future.value$value, 
[09:31:56.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.873]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.873]                     ...future.globalenv.names))
[09:31:56.873]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.873]         }, condition = base::local({
[09:31:56.873]             c <- base::c
[09:31:56.873]             inherits <- base::inherits
[09:31:56.873]             invokeRestart <- base::invokeRestart
[09:31:56.873]             length <- base::length
[09:31:56.873]             list <- base::list
[09:31:56.873]             seq.int <- base::seq.int
[09:31:56.873]             signalCondition <- base::signalCondition
[09:31:56.873]             sys.calls <- base::sys.calls
[09:31:56.873]             `[[` <- base::`[[`
[09:31:56.873]             `+` <- base::`+`
[09:31:56.873]             `<<-` <- base::`<<-`
[09:31:56.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.873]                   3L)]
[09:31:56.873]             }
[09:31:56.873]             function(cond) {
[09:31:56.873]                 is_error <- inherits(cond, "error")
[09:31:56.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.873]                   NULL)
[09:31:56.873]                 if (is_error) {
[09:31:56.873]                   sessionInformation <- function() {
[09:31:56.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.873]                       search = base::search(), system = base::Sys.info())
[09:31:56.873]                   }
[09:31:56.873]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.873]                     cond$call), session = sessionInformation(), 
[09:31:56.873]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.873]                   signalCondition(cond)
[09:31:56.873]                 }
[09:31:56.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.873]                 "immediateCondition"))) {
[09:31:56.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.873]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.873]                   if (TRUE && !signal) {
[09:31:56.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.873]                     {
[09:31:56.873]                       inherits <- base::inherits
[09:31:56.873]                       invokeRestart <- base::invokeRestart
[09:31:56.873]                       is.null <- base::is.null
[09:31:56.873]                       muffled <- FALSE
[09:31:56.873]                       if (inherits(cond, "message")) {
[09:31:56.873]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.873]                         if (muffled) 
[09:31:56.873]                           invokeRestart("muffleMessage")
[09:31:56.873]                       }
[09:31:56.873]                       else if (inherits(cond, "warning")) {
[09:31:56.873]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.873]                         if (muffled) 
[09:31:56.873]                           invokeRestart("muffleWarning")
[09:31:56.873]                       }
[09:31:56.873]                       else if (inherits(cond, "condition")) {
[09:31:56.873]                         if (!is.null(pattern)) {
[09:31:56.873]                           computeRestarts <- base::computeRestarts
[09:31:56.873]                           grepl <- base::grepl
[09:31:56.873]                           restarts <- computeRestarts(cond)
[09:31:56.873]                           for (restart in restarts) {
[09:31:56.873]                             name <- restart$name
[09:31:56.873]                             if (is.null(name)) 
[09:31:56.873]                               next
[09:31:56.873]                             if (!grepl(pattern, name)) 
[09:31:56.873]                               next
[09:31:56.873]                             invokeRestart(restart)
[09:31:56.873]                             muffled <- TRUE
[09:31:56.873]                             break
[09:31:56.873]                           }
[09:31:56.873]                         }
[09:31:56.873]                       }
[09:31:56.873]                       invisible(muffled)
[09:31:56.873]                     }
[09:31:56.873]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.873]                   }
[09:31:56.873]                 }
[09:31:56.873]                 else {
[09:31:56.873]                   if (TRUE) {
[09:31:56.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.873]                     {
[09:31:56.873]                       inherits <- base::inherits
[09:31:56.873]                       invokeRestart <- base::invokeRestart
[09:31:56.873]                       is.null <- base::is.null
[09:31:56.873]                       muffled <- FALSE
[09:31:56.873]                       if (inherits(cond, "message")) {
[09:31:56.873]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.873]                         if (muffled) 
[09:31:56.873]                           invokeRestart("muffleMessage")
[09:31:56.873]                       }
[09:31:56.873]                       else if (inherits(cond, "warning")) {
[09:31:56.873]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.873]                         if (muffled) 
[09:31:56.873]                           invokeRestart("muffleWarning")
[09:31:56.873]                       }
[09:31:56.873]                       else if (inherits(cond, "condition")) {
[09:31:56.873]                         if (!is.null(pattern)) {
[09:31:56.873]                           computeRestarts <- base::computeRestarts
[09:31:56.873]                           grepl <- base::grepl
[09:31:56.873]                           restarts <- computeRestarts(cond)
[09:31:56.873]                           for (restart in restarts) {
[09:31:56.873]                             name <- restart$name
[09:31:56.873]                             if (is.null(name)) 
[09:31:56.873]                               next
[09:31:56.873]                             if (!grepl(pattern, name)) 
[09:31:56.873]                               next
[09:31:56.873]                             invokeRestart(restart)
[09:31:56.873]                             muffled <- TRUE
[09:31:56.873]                             break
[09:31:56.873]                           }
[09:31:56.873]                         }
[09:31:56.873]                       }
[09:31:56.873]                       invisible(muffled)
[09:31:56.873]                     }
[09:31:56.873]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.873]                   }
[09:31:56.873]                 }
[09:31:56.873]             }
[09:31:56.873]         }))
[09:31:56.873]     }, error = function(ex) {
[09:31:56.873]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.873]                 ...future.rng), started = ...future.startTime, 
[09:31:56.873]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.873]             version = "1.8"), class = "FutureResult")
[09:31:56.873]     }, finally = {
[09:31:56.873]         if (!identical(...future.workdir, getwd())) 
[09:31:56.873]             setwd(...future.workdir)
[09:31:56.873]         {
[09:31:56.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.873]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.873]             }
[09:31:56.873]             base::options(...future.oldOptions)
[09:31:56.873]             if (.Platform$OS.type == "windows") {
[09:31:56.873]                 old_names <- names(...future.oldEnvVars)
[09:31:56.873]                 envs <- base::Sys.getenv()
[09:31:56.873]                 names <- names(envs)
[09:31:56.873]                 common <- intersect(names, old_names)
[09:31:56.873]                 added <- setdiff(names, old_names)
[09:31:56.873]                 removed <- setdiff(old_names, names)
[09:31:56.873]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.873]                   envs[common]]
[09:31:56.873]                 NAMES <- toupper(changed)
[09:31:56.873]                 args <- list()
[09:31:56.873]                 for (kk in seq_along(NAMES)) {
[09:31:56.873]                   name <- changed[[kk]]
[09:31:56.873]                   NAME <- NAMES[[kk]]
[09:31:56.873]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.873]                     next
[09:31:56.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.873]                 }
[09:31:56.873]                 NAMES <- toupper(added)
[09:31:56.873]                 for (kk in seq_along(NAMES)) {
[09:31:56.873]                   name <- added[[kk]]
[09:31:56.873]                   NAME <- NAMES[[kk]]
[09:31:56.873]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.873]                     next
[09:31:56.873]                   args[[name]] <- ""
[09:31:56.873]                 }
[09:31:56.873]                 NAMES <- toupper(removed)
[09:31:56.873]                 for (kk in seq_along(NAMES)) {
[09:31:56.873]                   name <- removed[[kk]]
[09:31:56.873]                   NAME <- NAMES[[kk]]
[09:31:56.873]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.873]                     next
[09:31:56.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.873]                 }
[09:31:56.873]                 if (length(args) > 0) 
[09:31:56.873]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.873]             }
[09:31:56.873]             else {
[09:31:56.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.873]             }
[09:31:56.873]             {
[09:31:56.873]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.873]                   0L) {
[09:31:56.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.873]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.873]                   base::options(opts)
[09:31:56.873]                 }
[09:31:56.873]                 {
[09:31:56.873]                   {
[09:31:56.873]                     NULL
[09:31:56.873]                     RNGkind("Mersenne-Twister")
[09:31:56.873]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.873]                       inherits = FALSE)
[09:31:56.873]                   }
[09:31:56.873]                   options(future.plan = NULL)
[09:31:56.873]                   if (is.na(NA_character_)) 
[09:31:56.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.873]                     .init = FALSE)
[09:31:56.873]                 }
[09:31:56.873]             }
[09:31:56.873]         }
[09:31:56.873]     })
[09:31:56.873]     if (TRUE) {
[09:31:56.873]         base::sink(type = "output", split = FALSE)
[09:31:56.873]         if (TRUE) {
[09:31:56.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.873]         }
[09:31:56.873]         else {
[09:31:56.873]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.873]         }
[09:31:56.873]         base::close(...future.stdout)
[09:31:56.873]         ...future.stdout <- NULL
[09:31:56.873]     }
[09:31:56.873]     ...future.result$conditions <- ...future.conditions
[09:31:56.873]     ...future.result$finished <- base::Sys.time()
[09:31:56.873]     ...future.result
[09:31:56.873] }
[09:31:56.875] assign_globals() ...
[09:31:56.875] List of 1
[09:31:56.875]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:56.875]   ..$ a: int [1:3] 1 2 3
[09:31:56.875]   ..$ b: int [1:3] 3 2 1
[09:31:56.875]  - attr(*, "where")=List of 1
[09:31:56.875]   ..$ data:<environment: R_EmptyEnv> 
[09:31:56.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.875]  - attr(*, "resolved")= logi FALSE
[09:31:56.875]  - attr(*, "total_size")= num 128
[09:31:56.875]  - attr(*, "already-done")= logi TRUE
[09:31:56.878] - copied ‘data’ to environment
[09:31:56.878] assign_globals() ... done
[09:31:56.878] plan(): Setting new future strategy stack:
[09:31:56.878] List of future strategies:
[09:31:56.878] 1. multicore:
[09:31:56.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:56.878]    - tweaked: FALSE
[09:31:56.878]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.882] plan(): nbrOfWorkers() = 2
[09:31:56.924] plan(): Setting new future strategy stack:
[09:31:56.924] List of future strategies:
[09:31:56.924] 1. sequential:
[09:31:56.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.924]    - tweaked: FALSE
[09:31:56.924]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.924] 2. multicore:
[09:31:56.924]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:56.924]    - tweaked: FALSE
[09:31:56.924]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.925] plan(): nbrOfWorkers() = 1
[09:31:56.925] SequentialFuture started (and completed)
[09:31:56.925] signalConditions() ...
[09:31:56.925]  - include = ‘immediateCondition’
[09:31:56.925]  - exclude = 
[09:31:56.925]  - resignal = FALSE
[09:31:56.926]  - Number of conditions: 55
[09:31:56.926] signalConditions() ... done
[09:31:56.926] - Launch lazy future ... done
[09:31:56.926] run() for ‘SequentialFuture’ ... done
[09:31:56.926] signalConditions() ...
[09:31:56.926]  - include = ‘immediateCondition’
[09:31:56.926]  - exclude = 
[09:31:56.926]  - resignal = FALSE
[09:31:56.927]  - Number of conditions: 55
[09:31:56.927] signalConditions() ... done
[09:31:56.927] Future state: ‘finished’
[09:31:56.927] signalConditions() ...
[09:31:56.927]  - include = ‘condition’
[09:31:56.927]  - exclude = ‘immediateCondition’
[09:31:56.927]  - resignal = TRUE
[09:31:56.927]  - Number of conditions: 55
[09:31:56.927]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.882] getGlobalsAndPackages() ...
[09:31:56.928]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.882] Searching for globals...
[09:31:56.928]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.897] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:56.928]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.897] Searching for globals ... DONE
[09:31:56.928]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.897] Resolving globals: FALSE
[09:31:56.928]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.897] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:56.928]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:56.929]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] - globals: [1] ‘data’
[09:31:56.929]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] 
[09:31:56.929]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] getGlobalsAndPackages() ... DONE
[09:31:56.929]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] run() for ‘Future’ ...
[09:31:56.929]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] - state: ‘created’
[09:31:56.929]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:56.930]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:56.930]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:56.930]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902]   - Field: ‘label’
[09:31:56.930]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902]   - Field: ‘local’
[09:31:56.930]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902]   - Field: ‘owner’
[09:31:56.930]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902]   - Field: ‘envir’
[09:31:56.932]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.902]   - Field: ‘workers’
[09:31:56.933]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘packages’
[09:31:56.933]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘gc’
[09:31:56.933]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘job’
[09:31:56.933]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘conditions’
[09:31:56.933]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘expr’
[09:31:56.933]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘uuid’
[09:31:56.934]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘seed’
[09:31:56.934]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘version’
[09:31:56.934]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘result’
[09:31:56.934]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.903]   - Field: ‘asynchronous’
[09:31:56.934]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904]   - Field: ‘calls’
[09:31:56.934]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904]   - Field: ‘globals’
[09:31:56.935]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904]   - Field: ‘stdout’
[09:31:56.935]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904]   - Field: ‘earlySignal’
[09:31:56.935]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904]   - Field: ‘lazy’
[09:31:56.935]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904]   - Field: ‘state’
[09:31:56.935]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:56.935]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.904] - Launch lazy future ...
[09:31:56.936]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.905] Packages needed by the future expression (n = 0): <none>
[09:31:56.936]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.905] Packages needed by future strategies (n = 0): <none>
[09:31:56.936]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.905] {
[09:31:56.905]     {
[09:31:56.905]         {
[09:31:56.905]             ...future.startTime <- base::Sys.time()
[09:31:56.905]             {
[09:31:56.905]                 {
[09:31:56.905]                   {
[09:31:56.905]                     {
[09:31:56.905]                       base::local({
[09:31:56.905]                         has_future <- base::requireNamespace("future", 
[09:31:56.905]                           quietly = TRUE)
[09:31:56.905]                         if (has_future) {
[09:31:56.905]                           ns <- base::getNamespace("future")
[09:31:56.905]                           version <- ns[[".package"]][["version"]]
[09:31:56.905]                           if (is.null(version)) 
[09:31:56.905]                             version <- utils::packageVersion("future")
[09:31:56.905]                         }
[09:31:56.905]                         else {
[09:31:56.905]                           version <- NULL
[09:31:56.905]                         }
[09:31:56.905]                         if (!has_future || version < "1.8.0") {
[09:31:56.905]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.905]                             "", base::R.version$version.string), 
[09:31:56.905]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.905]                               "release", "version")], collapse = " "), 
[09:31:56.905]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.905]                             info)
[09:31:56.905]                           info <- base::paste(info, collapse = "; ")
[09:31:56.905]                           if (!has_future) {
[09:31:56.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.905]                               info)
[09:31:56.905]                           }
[09:31:56.905]                           else {
[09:31:56.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.905]                               info, version)
[09:31:56.905]                           }
[09:31:56.905]                           base::stop(msg)
[09:31:56.905]                         }
[09:31:56.905]                       })
[09:31:56.905]                     }
[09:31:56.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:56.905]                     base::options(mc.cores = 1L)
[09:31:56.905]                   }
[09:31:56.905]                   ...future.strategy.old <- future::plan("list")
[09:31:56.905]                   options(future.plan = NULL)
[09:31:56.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:56.905]                 }
[09:31:56.905]                 ...future.workdir <- getwd()
[09:31:56.905]             }
[09:31:56.905]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.905]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.905]         }
[09:31:56.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.905]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.905]             base::names(...future.oldOptions))
[09:31:56.905]     }
[09:31:56.905]     if (FALSE) {
[09:31:56.905]     }
[09:31:56.905]     else {
[09:31:56.905]         if (TRUE) {
[09:31:56.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.905]                 open = "w")
[09:31:56.905]         }
[09:31:56.905]         else {
[09:31:56.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.905]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.905]         }
[09:31:56.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.905]             base::sink(type = "output", split = FALSE)
[09:31:56.905]             base::close(...future.stdout)
[09:31:56.905]         }, add = TRUE)
[09:31:56.905]     }
[09:31:56.905]     ...future.frame <- base::sys.nframe()
[09:31:56.905]     ...future.conditions <- base::list()
[09:31:56.905]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.905]     if (FALSE) {
[09:31:56.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.905]     }
[09:31:56.905]     ...future.result <- base::tryCatch({
[09:31:56.905]         base::withCallingHandlers({
[09:31:56.905]             ...future.value <- base::withVisible(base::local({
[09:31:56.905]                 withCallingHandlers({
[09:31:56.905]                   subset(data, a == 2)
[09:31:56.905]                 }, immediateCondition = function(cond) {
[09:31:56.905]                   save_rds <- function (object, pathname, ...) 
[09:31:56.905]                   {
[09:31:56.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:56.905]                     if (file_test("-f", pathname_tmp)) {
[09:31:56.905]                       fi_tmp <- file.info(pathname_tmp)
[09:31:56.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:56.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:56.905]                         fi_tmp[["mtime"]])
[09:31:56.905]                     }
[09:31:56.905]                     tryCatch({
[09:31:56.905]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:56.905]                     }, error = function(ex) {
[09:31:56.905]                       msg <- conditionMessage(ex)
[09:31:56.905]                       fi_tmp <- file.info(pathname_tmp)
[09:31:56.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:56.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:56.905]                         fi_tmp[["mtime"]], msg)
[09:31:56.905]                       ex$message <- msg
[09:31:56.905]                       stop(ex)
[09:31:56.905]                     })
[09:31:56.905]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:56.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:56.905]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:56.905]                       fi_tmp <- file.info(pathname_tmp)
[09:31:56.905]                       fi <- file.info(pathname)
[09:31:56.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:56.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:56.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:56.905]                         fi[["size"]], fi[["mtime"]])
[09:31:56.905]                       stop(msg)
[09:31:56.905]                     }
[09:31:56.905]                     invisible(pathname)
[09:31:56.905]                   }
[09:31:56.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:56.905]                     rootPath = tempdir()) 
[09:31:56.905]                   {
[09:31:56.905]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:56.905]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:56.905]                       tmpdir = path, fileext = ".rds")
[09:31:56.905]                     save_rds(obj, file)
[09:31:56.905]                   }
[09:31:56.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:56.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.905]                   {
[09:31:56.905]                     inherits <- base::inherits
[09:31:56.905]                     invokeRestart <- base::invokeRestart
[09:31:56.905]                     is.null <- base::is.null
[09:31:56.905]                     muffled <- FALSE
[09:31:56.905]                     if (inherits(cond, "message")) {
[09:31:56.905]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:56.905]                       if (muffled) 
[09:31:56.905]                         invokeRestart("muffleMessage")
[09:31:56.905]                     }
[09:31:56.905]                     else if (inherits(cond, "warning")) {
[09:31:56.905]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:56.905]                       if (muffled) 
[09:31:56.905]                         invokeRestart("muffleWarning")
[09:31:56.905]                     }
[09:31:56.905]                     else if (inherits(cond, "condition")) {
[09:31:56.905]                       if (!is.null(pattern)) {
[09:31:56.905]                         computeRestarts <- base::computeRestarts
[09:31:56.905]                         grepl <- base::grepl
[09:31:56.905]                         restarts <- computeRestarts(cond)
[09:31:56.905]                         for (restart in restarts) {
[09:31:56.905]                           name <- restart$name
[09:31:56.905]                           if (is.null(name)) 
[09:31:56.905]                             next
[09:31:56.905]                           if (!grepl(pattern, name)) 
[09:31:56.905]                             next
[09:31:56.905]                           invokeRestart(restart)
[09:31:56.905]                           muffled <- TRUE
[09:31:56.905]                           break
[09:31:56.905]                         }
[09:31:56.905]                       }
[09:31:56.905]                     }
[09:31:56.905]                     invisible(muffled)
[09:31:56.905]                   }
[09:31:56.905]                   muffleCondition(cond)
[09:31:56.905]                 })
[09:31:56.905]             }))
[09:31:56.905]             future::FutureResult(value = ...future.value$value, 
[09:31:56.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.905]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.905]                     ...future.globalenv.names))
[09:31:56.905]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.905]         }, condition = base::local({
[09:31:56.905]             c <- base::c
[09:31:56.905]             inherits <- base::inherits
[09:31:56.905]             invokeRestart <- base::invokeRestart
[09:31:56.905]             length <- base::length
[09:31:56.905]             list <- base::list
[09:31:56.905]             seq.int <- base::seq.int
[09:31:56.905]             signalCondition <- base::signalCondition
[09:31:56.905]             sys.calls <- base::sys.calls
[09:31:56.905]             `[[` <- base::`[[`
[09:31:56.905]             `+` <- base::`+`
[09:31:56.905]             `<<-` <- base::`<<-`
[09:31:56.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.905]                   3L)]
[09:31:56.905]             }
[09:31:56.905]             function(cond) {
[09:31:56.905]                 is_error <- inherits(cond, "error")
[09:31:56.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.905]                   NULL)
[09:31:56.905]                 if (is_error) {
[09:31:56.905]                   sessionInformation <- function() {
[09:31:56.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.905]                       search = base::search(), system = base::Sys.info())
[09:31:56.905]                   }
[09:31:56.905]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.905]                     cond$call), session = sessionInformation(), 
[09:31:56.905]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.905]                   signalCondition(cond)
[09:31:56.905]                 }
[09:31:56.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.905]                 "immediateCondition"))) {
[09:31:56.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.905]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.905]                   if (TRUE && !signal) {
[09:31:56.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.905]                     {
[09:31:56.905]                       inherits <- base::inherits
[09:31:56.905]                       invokeRestart <- base::invokeRestart
[09:31:56.905]                       is.null <- base::is.null
[09:31:56.905]                       muffled <- FALSE
[09:31:56.905]                       if (inherits(cond, "message")) {
[09:31:56.905]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.905]                         if (muffled) 
[09:31:56.905]                           invokeRestart("muffleMessage")
[09:31:56.905]                       }
[09:31:56.905]                       else if (inherits(cond, "warning")) {
[09:31:56.905]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.905]                         if (muffled) 
[09:31:56.905]                           invokeRestart("muffleWarning")
[09:31:56.905]                       }
[09:31:56.905]                       else if (inherits(cond, "condition")) {
[09:31:56.905]                         if (!is.null(pattern)) {
[09:31:56.905]                           computeRestarts <- base::computeRestarts
[09:31:56.905]                           grepl <- base::grepl
[09:31:56.905]                           restarts <- computeRestarts(cond)
[09:31:56.905]                           for (restart in restarts) {
[09:31:56.905]                             name <- restart$name
[09:31:56.905]                             if (is.null(name)) 
[09:31:56.905]                               next
[09:31:56.905]                             if (!grepl(pattern, name)) 
[09:31:56.905]                               next
[09:31:56.905]                             invokeRestart(restart)
[09:31:56.905]                             muffled <- TRUE
[09:31:56.905]                             break
[09:31:56.905]                           }
[09:31:56.905]                         }
[09:31:56.905]                       }
[09:31:56.905]                       invisible(muffled)
[09:31:56.905]                     }
[09:31:56.905]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.905]                   }
[09:31:56.905]                 }
[09:31:56.905]                 else {
[09:31:56.905]                   if (TRUE) {
[09:31:56.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.905]                     {
[09:31:56.905]                       inherits <- base::inherits
[09:31:56.905]                       invokeRestart <- base::invokeRestart
[09:31:56.905]                       is.null <- base::is.null
[09:31:56.905]                       muffled <- FALSE
[09:31:56.905]                       if (inherits(cond, "message")) {
[09:31:56.905]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.905]                         if (muffled) 
[09:31:56.905]                           invokeRestart("muffleMessage")
[09:31:56.905]                       }
[09:31:56.905]                       else if (inherits(cond, "warning")) {
[09:31:56.905]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.905]                         if (muffled) 
[09:31:56.905]                           invokeRestart("muffleWarning")
[09:31:56.905]                       }
[09:31:56.905]                       else if (inherits(cond, "condition")) {
[09:31:56.905]                         if (!is.null(pattern)) {
[09:31:56.905]                           computeRestarts <- base::computeRestarts
[09:31:56.905]                           grepl <- base::grepl
[09:31:56.905]                           restarts <- computeRestarts(cond)
[09:31:56.905]                           for (restart in restarts) {
[09:31:56.905]                             name <- restart$name
[09:31:56.905]                             if (is.null(name)) 
[09:31:56.905]                               next
[09:31:56.905]                             if (!grepl(pattern, name)) 
[09:31:56.905]                               next
[09:31:56.905]                             invokeRestart(restart)
[09:31:56.905]                             muffled <- TRUE
[09:31:56.905]                             break
[09:31:56.905]                           }
[09:31:56.905]                         }
[09:31:56.905]                       }
[09:31:56.905]                       invisible(muffled)
[09:31:56.905]                     }
[09:31:56.905]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.905]                   }
[09:31:56.905]                 }
[09:31:56.905]             }
[09:31:56.905]         }))
[09:31:56.905]     }, error = function(ex) {
[09:31:56.905]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.905]                 ...future.rng), started = ...future.startTime, 
[09:31:56.905]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.905]             version = "1.8"), class = "FutureResult")
[09:31:56.905]     }, finally = {
[09:31:56.905]         if (!identical(...future.workdir, getwd())) 
[09:31:56.905]             setwd(...future.workdir)
[09:31:56.905]         {
[09:31:56.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.905]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.905]             }
[09:31:56.905]             base::options(...future.oldOptions)
[09:31:56.905]             if (.Platform$OS.type == "windows") {
[09:31:56.905]                 old_names <- names(...future.oldEnvVars)
[09:31:56.905]                 envs <- base::Sys.getenv()
[09:31:56.905]                 names <- names(envs)
[09:31:56.905]                 common <- intersect(names, old_names)
[09:31:56.905]                 added <- setdiff(names, old_names)
[09:31:56.905]                 removed <- setdiff(old_names, names)
[09:31:56.905]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.905]                   envs[common]]
[09:31:56.905]                 NAMES <- toupper(changed)
[09:31:56.905]                 args <- list()
[09:31:56.905]                 for (kk in seq_along(NAMES)) {
[09:31:56.905]                   name <- changed[[kk]]
[09:31:56.905]                   NAME <- NAMES[[kk]]
[09:31:56.905]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.905]                     next
[09:31:56.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.905]                 }
[09:31:56.905]                 NAMES <- toupper(added)
[09:31:56.905]                 for (kk in seq_along(NAMES)) {
[09:31:56.905]                   name <- added[[kk]]
[09:31:56.905]                   NAME <- NAMES[[kk]]
[09:31:56.905]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.905]                     next
[09:31:56.905]                   args[[name]] <- ""
[09:31:56.905]                 }
[09:31:56.905]                 NAMES <- toupper(removed)
[09:31:56.905]                 for (kk in seq_along(NAMES)) {
[09:31:56.905]                   name <- removed[[kk]]
[09:31:56.905]                   NAME <- NAMES[[kk]]
[09:31:56.905]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.905]                     next
[09:31:56.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.905]                 }
[09:31:56.905]                 if (length(args) > 0) 
[09:31:56.905]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.905]             }
[09:31:56.905]             else {
[09:31:56.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.905]             }
[09:31:56.905]             {
[09:31:56.905]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.905]                   0L) {
[09:31:56.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.905]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.905]                   base::options(opts)
[09:31:56.905]                 }
[09:31:56.905]                 {
[09:31:56.905]                   {
[09:31:56.905]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:56.905]                     NULL
[09:31:56.905]                   }
[09:31:56.905]                   options(future.plan = NULL)
[09:31:56.905]                   if (is.na(NA_character_)) 
[09:31:56.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.905]                     .init = FALSE)
[09:31:56.905]                 }
[09:31:56.905]             }
[09:31:56.905]         }
[09:31:56.905]     })
[09:31:56.905]     if (TRUE) {
[09:31:56.905]         base::sink(type = "output", split = FALSE)
[09:31:56.905]         if (TRUE) {
[09:31:56.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.905]         }
[09:31:56.905]         else {
[09:31:56.905]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.905]         }
[09:31:56.905]         base::close(...future.stdout)
[09:31:56.905]         ...future.stdout <- NULL
[09:31:56.905]     }
[09:31:56.905]     ...future.result$conditions <- ...future.conditions
[09:31:56.905]     ...future.result$finished <- base::Sys.time()
[09:31:56.905]     ...future.result
[09:31:56.905] }
[09:31:56.936]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.907] assign_globals() ...
[09:31:56.936]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.907] List of 1
[09:31:56.907]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:56.907]   ..$ a: int [1:3] 1 2 3
[09:31:56.907]   ..$ b: int [1:3] 3 2 1
[09:31:56.907]  - attr(*, "where")=List of 1
[09:31:56.907]   ..$ data:<environment: R_EmptyEnv> 
[09:31:56.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.907]  - attr(*, "resolved")= logi FALSE
[09:31:56.907]  - attr(*, "total_size")= num 128
[09:31:56.907]  - attr(*, "already-done")= logi TRUE
[09:31:56.936]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.910] - copied ‘data’ to environment
[09:31:56.937]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.910] assign_globals() ... done
[09:31:56.937]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.910] requestCore(): workers = 2
[09:31:56.937]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.912] MulticoreFuture started
[09:31:56.937]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.913] - Launch lazy future ... done
[09:31:56.937]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.913] run() for ‘MulticoreFuture’ ... done
[09:31:56.937]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.913] result() for MulticoreFuture ...
[09:31:56.938]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.922] result() for MulticoreFuture ...
[09:31:56.938]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.923] result() for MulticoreFuture ... done
[09:31:56.938]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.923] result() for MulticoreFuture ... done
[09:31:56.938]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.923] result() for MulticoreFuture ...
[09:31:56.938]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.923] result() for MulticoreFuture ... done
[09:31:56.938] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[09:31:56.939] plan(): Setting new future strategy stack:
[09:31:56.939] List of future strategies:
[09:31:56.939] 1. sequential:
[09:31:56.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:56.939]    - tweaked: FALSE
[09:31:56.939]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.939] 2. multisession:
[09:31:56.939]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:56.939]    - tweaked: FALSE
[09:31:56.939]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.939] plan(): nbrOfWorkers() = 1
[09:31:56.940] getGlobalsAndPackages() ...
[09:31:56.940] Searching for globals...
[09:31:56.957] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:56.957] Searching for globals ... DONE
[09:31:56.957] Resolving globals: FALSE
[09:31:56.958] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[09:31:56.959] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:56.959] - globals: [2] ‘nested’, ‘strategy2’
[09:31:56.959] - packages: [1] ‘future’
[09:31:56.959] getGlobalsAndPackages() ... DONE
[09:31:56.959] run() for ‘Future’ ...
[09:31:56.959] - state: ‘created’
[09:31:56.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:56.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:56.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:56.960]   - Field: ‘label’
[09:31:56.960]   - Field: ‘local’
[09:31:56.960]   - Field: ‘owner’
[09:31:56.960]   - Field: ‘envir’
[09:31:56.960]   - Field: ‘packages’
[09:31:56.961]   - Field: ‘gc’
[09:31:56.961]   - Field: ‘conditions’
[09:31:56.961]   - Field: ‘expr’
[09:31:56.961]   - Field: ‘uuid’
[09:31:56.961]   - Field: ‘seed’
[09:31:56.961]   - Field: ‘version’
[09:31:56.961]   - Field: ‘result’
[09:31:56.961]   - Field: ‘asynchronous’
[09:31:56.961]   - Field: ‘calls’
[09:31:56.961]   - Field: ‘globals’
[09:31:56.961]   - Field: ‘stdout’
[09:31:56.961]   - Field: ‘earlySignal’
[09:31:56.962]   - Field: ‘lazy’
[09:31:56.962]   - Field: ‘state’
[09:31:56.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:56.962] - Launch lazy future ...
[09:31:56.962] Packages needed by the future expression (n = 1): ‘future’
[09:31:56.962] Packages needed by future strategies (n = 1): ‘future’
[09:31:56.963] {
[09:31:56.963]     {
[09:31:56.963]         {
[09:31:56.963]             ...future.startTime <- base::Sys.time()
[09:31:56.963]             {
[09:31:56.963]                 {
[09:31:56.963]                   {
[09:31:56.963]                     {
[09:31:56.963]                       base::local({
[09:31:56.963]                         has_future <- base::requireNamespace("future", 
[09:31:56.963]                           quietly = TRUE)
[09:31:56.963]                         if (has_future) {
[09:31:56.963]                           ns <- base::getNamespace("future")
[09:31:56.963]                           version <- ns[[".package"]][["version"]]
[09:31:56.963]                           if (is.null(version)) 
[09:31:56.963]                             version <- utils::packageVersion("future")
[09:31:56.963]                         }
[09:31:56.963]                         else {
[09:31:56.963]                           version <- NULL
[09:31:56.963]                         }
[09:31:56.963]                         if (!has_future || version < "1.8.0") {
[09:31:56.963]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:56.963]                             "", base::R.version$version.string), 
[09:31:56.963]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:56.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:56.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:56.963]                               "release", "version")], collapse = " "), 
[09:31:56.963]                             hostname = base::Sys.info()[["nodename"]])
[09:31:56.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:56.963]                             info)
[09:31:56.963]                           info <- base::paste(info, collapse = "; ")
[09:31:56.963]                           if (!has_future) {
[09:31:56.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:56.963]                               info)
[09:31:56.963]                           }
[09:31:56.963]                           else {
[09:31:56.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:56.963]                               info, version)
[09:31:56.963]                           }
[09:31:56.963]                           base::stop(msg)
[09:31:56.963]                         }
[09:31:56.963]                       })
[09:31:56.963]                     }
[09:31:56.963]                     base::local({
[09:31:56.963]                       for (pkg in "future") {
[09:31:56.963]                         base::loadNamespace(pkg)
[09:31:56.963]                         base::library(pkg, character.only = TRUE)
[09:31:56.963]                       }
[09:31:56.963]                     })
[09:31:56.963]                   }
[09:31:56.963]                   ...future.strategy.old <- future::plan("list")
[09:31:56.963]                   options(future.plan = NULL)
[09:31:56.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.963]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:31:56.963]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:56.963]                     envir = parent.frame()) 
[09:31:56.963]                   {
[09:31:56.963]                     if (is.function(workers)) 
[09:31:56.963]                       workers <- workers()
[09:31:56.963]                     workers <- structure(as.integer(workers), 
[09:31:56.963]                       class = class(workers))
[09:31:56.963]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:31:56.963]                       workers >= 1)
[09:31:56.963]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:31:56.963]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:31:56.963]                     }
[09:31:56.963]                     future <- MultisessionFuture(..., workers = workers, 
[09:31:56.963]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:31:56.963]                       envir = envir)
[09:31:56.963]                     if (!future$lazy) 
[09:31:56.963]                       future <- run(future)
[09:31:56.963]                     invisible(future)
[09:31:56.963]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:56.963]                 }
[09:31:56.963]                 ...future.workdir <- getwd()
[09:31:56.963]             }
[09:31:56.963]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:56.963]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:56.963]         }
[09:31:56.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:56.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:56.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:56.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:56.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:56.963]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:56.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:56.963]             base::names(...future.oldOptions))
[09:31:56.963]     }
[09:31:56.963]     if (FALSE) {
[09:31:56.963]     }
[09:31:56.963]     else {
[09:31:56.963]         if (TRUE) {
[09:31:56.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:56.963]                 open = "w")
[09:31:56.963]         }
[09:31:56.963]         else {
[09:31:56.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:56.963]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:56.963]         }
[09:31:56.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:56.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:56.963]             base::sink(type = "output", split = FALSE)
[09:31:56.963]             base::close(...future.stdout)
[09:31:56.963]         }, add = TRUE)
[09:31:56.963]     }
[09:31:56.963]     ...future.frame <- base::sys.nframe()
[09:31:56.963]     ...future.conditions <- base::list()
[09:31:56.963]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:56.963]     if (FALSE) {
[09:31:56.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:56.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:56.963]     }
[09:31:56.963]     ...future.result <- base::tryCatch({
[09:31:56.963]         base::withCallingHandlers({
[09:31:56.963]             ...future.value <- base::withVisible(base::local({
[09:31:56.963]                 a <- 1L
[09:31:56.963]                 plan_a <- unclass(future::plan("list"))
[09:31:56.963]                 nested_a <- nested[-1]
[09:31:56.963]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:56.963]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.963]                   strategy2))
[09:31:56.963]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:56.963]                   "init") <- NULL
[09:31:56.963]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:56.963]                   "init") <- NULL
[09:31:56.963]                 stopifnot(all.equal(plan_a, nested_a))
[09:31:56.963]                 y %<-% {
[09:31:56.963]                   b <- 2L
[09:31:56.963]                   plan_b <- future::plan("list")
[09:31:56.963]                   nested_b <- nested_a[-1]
[09:31:56.963]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:56.963]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:56.963]                     "sequential"))
[09:31:56.963]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:56.963]                     b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:56.963]                 }
[09:31:56.963]                 y
[09:31:56.963]             }))
[09:31:56.963]             future::FutureResult(value = ...future.value$value, 
[09:31:56.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.963]                   ...future.rng), globalenv = if (FALSE) 
[09:31:56.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:56.963]                     ...future.globalenv.names))
[09:31:56.963]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:56.963]         }, condition = base::local({
[09:31:56.963]             c <- base::c
[09:31:56.963]             inherits <- base::inherits
[09:31:56.963]             invokeRestart <- base::invokeRestart
[09:31:56.963]             length <- base::length
[09:31:56.963]             list <- base::list
[09:31:56.963]             seq.int <- base::seq.int
[09:31:56.963]             signalCondition <- base::signalCondition
[09:31:56.963]             sys.calls <- base::sys.calls
[09:31:56.963]             `[[` <- base::`[[`
[09:31:56.963]             `+` <- base::`+`
[09:31:56.963]             `<<-` <- base::`<<-`
[09:31:56.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:56.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:56.963]                   3L)]
[09:31:56.963]             }
[09:31:56.963]             function(cond) {
[09:31:56.963]                 is_error <- inherits(cond, "error")
[09:31:56.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:56.963]                   NULL)
[09:31:56.963]                 if (is_error) {
[09:31:56.963]                   sessionInformation <- function() {
[09:31:56.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:56.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:56.963]                       search = base::search(), system = base::Sys.info())
[09:31:56.963]                   }
[09:31:56.963]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:56.963]                     cond$call), session = sessionInformation(), 
[09:31:56.963]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:56.963]                   signalCondition(cond)
[09:31:56.963]                 }
[09:31:56.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:56.963]                 "immediateCondition"))) {
[09:31:56.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:56.963]                   ...future.conditions[[length(...future.conditions) + 
[09:31:56.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:56.963]                   if (TRUE && !signal) {
[09:31:56.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.963]                     {
[09:31:56.963]                       inherits <- base::inherits
[09:31:56.963]                       invokeRestart <- base::invokeRestart
[09:31:56.963]                       is.null <- base::is.null
[09:31:56.963]                       muffled <- FALSE
[09:31:56.963]                       if (inherits(cond, "message")) {
[09:31:56.963]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.963]                         if (muffled) 
[09:31:56.963]                           invokeRestart("muffleMessage")
[09:31:56.963]                       }
[09:31:56.963]                       else if (inherits(cond, "warning")) {
[09:31:56.963]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.963]                         if (muffled) 
[09:31:56.963]                           invokeRestart("muffleWarning")
[09:31:56.963]                       }
[09:31:56.963]                       else if (inherits(cond, "condition")) {
[09:31:56.963]                         if (!is.null(pattern)) {
[09:31:56.963]                           computeRestarts <- base::computeRestarts
[09:31:56.963]                           grepl <- base::grepl
[09:31:56.963]                           restarts <- computeRestarts(cond)
[09:31:56.963]                           for (restart in restarts) {
[09:31:56.963]                             name <- restart$name
[09:31:56.963]                             if (is.null(name)) 
[09:31:56.963]                               next
[09:31:56.963]                             if (!grepl(pattern, name)) 
[09:31:56.963]                               next
[09:31:56.963]                             invokeRestart(restart)
[09:31:56.963]                             muffled <- TRUE
[09:31:56.963]                             break
[09:31:56.963]                           }
[09:31:56.963]                         }
[09:31:56.963]                       }
[09:31:56.963]                       invisible(muffled)
[09:31:56.963]                     }
[09:31:56.963]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.963]                   }
[09:31:56.963]                 }
[09:31:56.963]                 else {
[09:31:56.963]                   if (TRUE) {
[09:31:56.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:56.963]                     {
[09:31:56.963]                       inherits <- base::inherits
[09:31:56.963]                       invokeRestart <- base::invokeRestart
[09:31:56.963]                       is.null <- base::is.null
[09:31:56.963]                       muffled <- FALSE
[09:31:56.963]                       if (inherits(cond, "message")) {
[09:31:56.963]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:56.963]                         if (muffled) 
[09:31:56.963]                           invokeRestart("muffleMessage")
[09:31:56.963]                       }
[09:31:56.963]                       else if (inherits(cond, "warning")) {
[09:31:56.963]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:56.963]                         if (muffled) 
[09:31:56.963]                           invokeRestart("muffleWarning")
[09:31:56.963]                       }
[09:31:56.963]                       else if (inherits(cond, "condition")) {
[09:31:56.963]                         if (!is.null(pattern)) {
[09:31:56.963]                           computeRestarts <- base::computeRestarts
[09:31:56.963]                           grepl <- base::grepl
[09:31:56.963]                           restarts <- computeRestarts(cond)
[09:31:56.963]                           for (restart in restarts) {
[09:31:56.963]                             name <- restart$name
[09:31:56.963]                             if (is.null(name)) 
[09:31:56.963]                               next
[09:31:56.963]                             if (!grepl(pattern, name)) 
[09:31:56.963]                               next
[09:31:56.963]                             invokeRestart(restart)
[09:31:56.963]                             muffled <- TRUE
[09:31:56.963]                             break
[09:31:56.963]                           }
[09:31:56.963]                         }
[09:31:56.963]                       }
[09:31:56.963]                       invisible(muffled)
[09:31:56.963]                     }
[09:31:56.963]                     muffleCondition(cond, pattern = "^muffle")
[09:31:56.963]                   }
[09:31:56.963]                 }
[09:31:56.963]             }
[09:31:56.963]         }))
[09:31:56.963]     }, error = function(ex) {
[09:31:56.963]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:56.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:56.963]                 ...future.rng), started = ...future.startTime, 
[09:31:56.963]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:56.963]             version = "1.8"), class = "FutureResult")
[09:31:56.963]     }, finally = {
[09:31:56.963]         if (!identical(...future.workdir, getwd())) 
[09:31:56.963]             setwd(...future.workdir)
[09:31:56.963]         {
[09:31:56.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:56.963]                 ...future.oldOptions$nwarnings <- NULL
[09:31:56.963]             }
[09:31:56.963]             base::options(...future.oldOptions)
[09:31:56.963]             if (.Platform$OS.type == "windows") {
[09:31:56.963]                 old_names <- names(...future.oldEnvVars)
[09:31:56.963]                 envs <- base::Sys.getenv()
[09:31:56.963]                 names <- names(envs)
[09:31:56.963]                 common <- intersect(names, old_names)
[09:31:56.963]                 added <- setdiff(names, old_names)
[09:31:56.963]                 removed <- setdiff(old_names, names)
[09:31:56.963]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:56.963]                   envs[common]]
[09:31:56.963]                 NAMES <- toupper(changed)
[09:31:56.963]                 args <- list()
[09:31:56.963]                 for (kk in seq_along(NAMES)) {
[09:31:56.963]                   name <- changed[[kk]]
[09:31:56.963]                   NAME <- NAMES[[kk]]
[09:31:56.963]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.963]                     next
[09:31:56.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.963]                 }
[09:31:56.963]                 NAMES <- toupper(added)
[09:31:56.963]                 for (kk in seq_along(NAMES)) {
[09:31:56.963]                   name <- added[[kk]]
[09:31:56.963]                   NAME <- NAMES[[kk]]
[09:31:56.963]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.963]                     next
[09:31:56.963]                   args[[name]] <- ""
[09:31:56.963]                 }
[09:31:56.963]                 NAMES <- toupper(removed)
[09:31:56.963]                 for (kk in seq_along(NAMES)) {
[09:31:56.963]                   name <- removed[[kk]]
[09:31:56.963]                   NAME <- NAMES[[kk]]
[09:31:56.963]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:56.963]                     next
[09:31:56.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:56.963]                 }
[09:31:56.963]                 if (length(args) > 0) 
[09:31:56.963]                   base::do.call(base::Sys.setenv, args = args)
[09:31:56.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:56.963]             }
[09:31:56.963]             else {
[09:31:56.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:56.963]             }
[09:31:56.963]             {
[09:31:56.963]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:56.963]                   0L) {
[09:31:56.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:56.963]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:56.963]                   base::options(opts)
[09:31:56.963]                 }
[09:31:56.963]                 {
[09:31:56.963]                   {
[09:31:56.963]                     NULL
[09:31:56.963]                     RNGkind("Mersenne-Twister")
[09:31:56.963]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:56.963]                       inherits = FALSE)
[09:31:56.963]                   }
[09:31:56.963]                   options(future.plan = NULL)
[09:31:56.963]                   if (is.na(NA_character_)) 
[09:31:56.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:56.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:56.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:56.963]                     .init = FALSE)
[09:31:56.963]                 }
[09:31:56.963]             }
[09:31:56.963]         }
[09:31:56.963]     })
[09:31:56.963]     if (TRUE) {
[09:31:56.963]         base::sink(type = "output", split = FALSE)
[09:31:56.963]         if (TRUE) {
[09:31:56.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:56.963]         }
[09:31:56.963]         else {
[09:31:56.963]             ...future.result["stdout"] <- base::list(NULL)
[09:31:56.963]         }
[09:31:56.963]         base::close(...future.stdout)
[09:31:56.963]         ...future.stdout <- NULL
[09:31:56.963]     }
[09:31:56.963]     ...future.result$conditions <- ...future.conditions
[09:31:56.963]     ...future.result$finished <- base::Sys.time()
[09:31:56.963]     ...future.result
[09:31:56.963] }
[09:31:56.964] assign_globals() ...
[09:31:56.965] List of 2
[09:31:56.965]  $ nested   :List of 2
[09:31:56.965]   ..$ a:function (..., envir = parent.frame())  
[09:31:56.965]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:56.965]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.965]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:56.965]     envir = parent.frame())  
[09:31:56.965]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[09:31:56.965]   .. ..- attr(*, "init")= logi TRUE
[09:31:56.965]   .. ..- attr(*, "untweakable")= chr "persistent"
[09:31:56.965]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:56.965]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:56.965]  $ strategy2: chr "multisession"
[09:31:56.965]  - attr(*, "where")=List of 2
[09:31:56.965]   ..$ nested   :<environment: R_EmptyEnv> 
[09:31:56.965]   ..$ strategy2:<environment: R_EmptyEnv> 
[09:31:56.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:56.965]  - attr(*, "resolved")= logi FALSE
[09:31:56.965]  - attr(*, "total_size")= num 56736
[09:31:56.965]  - attr(*, "already-done")= logi TRUE
[09:31:56.969] - copied ‘nested’ to environment
[09:31:56.970] - copied ‘strategy2’ to environment
[09:31:56.970] assign_globals() ... done
[09:31:56.970] plan(): Setting new future strategy stack:
[09:31:56.970] List of future strategies:
[09:31:56.970] 1. multisession:
[09:31:56.970]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:56.970]    - tweaked: FALSE
[09:31:56.970]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:56.974] plan(): nbrOfWorkers() = 2
[09:31:57.690] plan(): Setting new future strategy stack:
[09:31:57.691] List of future strategies:
[09:31:57.691] 1. sequential:
[09:31:57.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.691]    - tweaked: FALSE
[09:31:57.691]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.691] 2. multisession:
[09:31:57.691]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:57.691]    - tweaked: FALSE
[09:31:57.691]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.692] plan(): nbrOfWorkers() = 1
[09:31:57.692] SequentialFuture started (and completed)
[09:31:57.692] signalConditions() ...
[09:31:57.692]  - include = ‘immediateCondition’
[09:31:57.692]  - exclude = 
[09:31:57.692]  - resignal = FALSE
[09:31:57.693]  - Number of conditions: 98
[09:31:57.693] signalConditions() ... done
[09:31:57.693] - Launch lazy future ... done
[09:31:57.693] run() for ‘SequentialFuture’ ... done
[09:31:57.693] signalConditions() ...
[09:31:57.693]  - include = ‘immediateCondition’
[09:31:57.694]  - exclude = 
[09:31:57.694]  - resignal = FALSE
[09:31:57.694]  - Number of conditions: 98
[09:31:57.694] signalConditions() ... done
[09:31:57.694] Future state: ‘finished’
[09:31:57.694] signalConditions() ...
[09:31:57.694]  - include = ‘condition’
[09:31:57.695]  - exclude = ‘immediateCondition’
[09:31:57.695]  - resignal = TRUE
[09:31:57.695]  - Number of conditions: 98
[09:31:57.695]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.976] getGlobalsAndPackages() ...
[09:31:57.695]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.976] Searching for globals...
[09:31:57.695]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.993] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[09:31:57.695]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.993] Searching for globals ... DONE
[09:31:57.696]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.993] Resolving globals: FALSE
[09:31:57.696]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.994] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[09:31:57.696]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.994] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[09:31:57.696]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.995] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[09:31:57.696]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.995] 
[09:31:57.696]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.995] getGlobalsAndPackages() ... DONE
[09:31:57.697]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.995] run() for ‘Future’ ...
[09:31:57.697]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.995] - state: ‘created’
[09:31:57.697]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:56.995] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:57.697]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.001] [local output] makeClusterPSOCK() ...
[09:31:57.697]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.039] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:57.697]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.040] [local output] Base port: 11545
[09:31:57.698]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.040] [local output] Getting setup options for 2 cluster nodes ...
[09:31:57.698]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.041] [local output]  - Node 1 of 2 ...
[09:31:57.698]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.041] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:57.698]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.042] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b91622223eba.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b91622223eba.pid")'’
[09:31:57.698]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.229] - Possible to infer worker's PID: TRUE
[09:31:57.698]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.230] [local output] Rscript port: 11545

[09:31:57.699]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.230] [local output]  - Node 2 of 2 ...
[09:31:57.699]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.230] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:57.699]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.231] [local output] Rscript port: 11545

[09:31:57.699]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.231] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:57.699]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.231] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:57.699]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.232] [local output] Setting up PSOCK nodes in parallel
[09:31:57.699]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.232] List of 36
[09:31:57.232]  $ worker          : chr "localhost"
[09:31:57.232]   ..- attr(*, "localhost")= logi TRUE
[09:31:57.232]  $ master          : chr "localhost"
[09:31:57.232]  $ port            : int 11545
[09:31:57.232]  $ connectTimeout  : num 120
[09:31:57.232]  $ timeout         : num 2592000
[09:31:57.232]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:57.232]  $ homogeneous     : logi TRUE
[09:31:57.232]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:57.232]  $ rscript_envs    : NULL
[09:31:57.232]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:57.232]  $ rscript_startup : NULL
[09:31:57.232]  $ rscript_sh      : chr "sh"
[09:31:57.232]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:57.232]  $ methods         : logi TRUE
[09:31:57.232]  $ socketOptions   : chr "no-delay"
[09:31:57.232]  $ useXDR          : logi FALSE
[09:31:57.232]  $ outfile         : chr "/dev/null"
[09:31:57.232]  $ renice          : int NA
[09:31:57.232]  $ rshcmd          : NULL
[09:31:57.232]  $ user            : chr(0) 
[09:31:57.232]  $ revtunnel       : logi FALSE
[09:31:57.232]  $ rshlogfile      : NULL
[09:31:57.232]  $ rshopts         : chr(0) 
[09:31:57.232]  $ rank            : int 1
[09:31:57.232]  $ manual          : logi FALSE
[09:31:57.232]  $ dryrun          : logi FALSE
[09:31:57.232]  $ quiet           : logi FALSE
[09:31:57.232]  $ setup_strategy  : chr "parallel"
[09:31:57.232]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:57.232]  $ pidfile         : chr "/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b91622223eba.pid"
[09:31:57.232]  $ rshcmd_label    : NULL
[09:31:57.232]  $ rsh_call        : NULL
[09:31:57.232]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:57.232]  $ localMachine    : logi TRUE
[09:31:57.232]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:57.232]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:57.232]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:57.232]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:57.232]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:57.232]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:57.232]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:57.232]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:57.232]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:57.232]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:57.232]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:57.232]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:57.232]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:57.232]  $ arguments       :List of 28
[09:31:57.232]   ..$ worker          : chr "localhost"
[09:31:57.232]   ..$ master          : NULL
[09:31:57.232]   ..$ port            : int 11545
[09:31:57.232]   ..$ connectTimeout  : num 120
[09:31:57.232]   ..$ timeout         : num 2592000
[09:31:57.232]   ..$ rscript         : NULL
[09:31:57.232]   ..$ homogeneous     : NULL
[09:31:57.232]   ..$ rscript_args    : NULL
[09:31:57.232]   ..$ rscript_envs    : NULL
[09:31:57.232]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:57.232]   ..$ rscript_startup : NULL
[09:31:57.232]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:57.232]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:57.232]   ..$ methods         : logi TRUE
[09:31:57.232]   ..$ socketOptions   : chr "no-delay"
[09:31:57.232]   ..$ useXDR          : logi FALSE
[09:31:57.232]   ..$ outfile         : chr "/dev/null"
[09:31:57.232]   ..$ renice          : int NA
[09:31:57.232]   ..$ rshcmd          : NULL
[09:31:57.232]   ..$ user            : NULL
[09:31:57.232]   ..$ revtunnel       : logi NA
[09:31:57.232]   ..$ rshlogfile      : NULL
[09:31:57.232]   ..$ rshopts         : NULL
[09:31:57.232]   ..$ rank            : int 1
[09:31:57.232]   ..$ manual          : logi FALSE
[09:31:57.232]   ..$ dryrun          : logi FALSE
[09:31:57.232]   ..$ quiet           : logi FALSE
[09:31:57.232]   ..$ setup_strategy  : chr "parallel"
[09:31:57.232]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:57.700]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.248] [local output] System call to launch all workers:
[09:31:57.700]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.248] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b91622223eba.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11545 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:57.700]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.249] [local output] Starting PSOCK main server
[09:31:57.700]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.254] [local output] Workers launched
[09:31:57.700]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.254] [local output] Waiting for workers to connect back
[09:31:57.701]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.254]  - [local output] 0 workers out of 2 ready
[09:31:57.701]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.486]  - [local output] 0 workers out of 2 ready
[09:31:57.701]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.486]  - [local output] 1 workers out of 2 ready
[09:31:57.701]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.498]  - [local output] 1 workers out of 2 ready
[09:31:57.701]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.499]  - [local output] 2 workers out of 2 ready
[09:31:57.701]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.499] [local output] Launching of workers completed
[09:31:57.701]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.499] [local output] Collecting session information from workers
[09:31:57.702]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.500] [local output]  - Worker #1 of 2
[09:31:57.702]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.501] [local output]  - Worker #2 of 2
[09:31:57.702]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.501] [local output] makeClusterPSOCK() ... done
[09:31:57.702]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:57.702]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:57.702]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘node’
[09:31:57.703]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘label’
[09:31:57.703]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘local’
[09:31:57.703]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘owner’
[09:31:57.703]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘envir’
[09:31:57.703]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘workers’
[09:31:57.703]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘packages’
[09:31:57.704]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘gc’
[09:31:57.704]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.512]   - Field: ‘conditions’
[09:31:57.704]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘persistent’
[09:31:57.704]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘expr’
[09:31:57.704]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘uuid’
[09:31:57.704]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘seed’
[09:31:57.705]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘version’
[09:31:57.705]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘result’
[09:31:57.705]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘asynchronous’
[09:31:57.705]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.513]   - Field: ‘calls’
[09:31:57.705]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514]   - Field: ‘globals’
[09:31:57.705]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514]   - Field: ‘stdout’
[09:31:57.706]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514]   - Field: ‘earlySignal’
[09:31:57.706]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514]   - Field: ‘lazy’
[09:31:57.706]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514]   - Field: ‘state’
[09:31:57.706]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:57.706]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.514] - Launch lazy future ...
[09:31:57.706]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.515] Packages needed by the future expression (n = 0): <none>
[09:31:57.707]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.515] Packages needed by future strategies (n = 0): <none>
[09:31:57.707]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.516] {
[09:31:57.516]     {
[09:31:57.516]         {
[09:31:57.516]             ...future.startTime <- base::Sys.time()
[09:31:57.516]             {
[09:31:57.516]                 {
[09:31:57.516]                   {
[09:31:57.516]                     {
[09:31:57.516]                       base::local({
[09:31:57.516]                         has_future <- base::requireNamespace("future", 
[09:31:57.516]                           quietly = TRUE)
[09:31:57.516]                         if (has_future) {
[09:31:57.516]                           ns <- base::getNamespace("future")
[09:31:57.516]                           version <- ns[[".package"]][["version"]]
[09:31:57.516]                           if (is.null(version)) 
[09:31:57.516]                             version <- utils::packageVersion("future")
[09:31:57.516]                         }
[09:31:57.516]                         else {
[09:31:57.516]                           version <- NULL
[09:31:57.516]                         }
[09:31:57.516]                         if (!has_future || version < "1.8.0") {
[09:31:57.516]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.516]                             "", base::R.version$version.string), 
[09:31:57.516]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:57.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:57.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.516]                               "release", "version")], collapse = " "), 
[09:31:57.516]                             hostname = base::Sys.info()[["nodename"]])
[09:31:57.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.516]                             info)
[09:31:57.516]                           info <- base::paste(info, collapse = "; ")
[09:31:57.516]                           if (!has_future) {
[09:31:57.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.516]                               info)
[09:31:57.516]                           }
[09:31:57.516]                           else {
[09:31:57.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.516]                               info, version)
[09:31:57.516]                           }
[09:31:57.516]                           base::stop(msg)
[09:31:57.516]                         }
[09:31:57.516]                       })
[09:31:57.516]                     }
[09:31:57.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:57.516]                     base::options(mc.cores = 1L)
[09:31:57.516]                   }
[09:31:57.516]                   ...future.strategy.old <- future::plan("list")
[09:31:57.516]                   options(future.plan = NULL)
[09:31:57.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:57.516]                 }
[09:31:57.516]                 ...future.workdir <- getwd()
[09:31:57.516]             }
[09:31:57.516]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.516]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.516]         }
[09:31:57.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.516]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.516]             base::names(...future.oldOptions))
[09:31:57.516]     }
[09:31:57.516]     if (FALSE) {
[09:31:57.516]     }
[09:31:57.516]     else {
[09:31:57.516]         if (TRUE) {
[09:31:57.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.516]                 open = "w")
[09:31:57.516]         }
[09:31:57.516]         else {
[09:31:57.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.516]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.516]         }
[09:31:57.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.516]             base::sink(type = "output", split = FALSE)
[09:31:57.516]             base::close(...future.stdout)
[09:31:57.516]         }, add = TRUE)
[09:31:57.516]     }
[09:31:57.516]     ...future.frame <- base::sys.nframe()
[09:31:57.516]     ...future.conditions <- base::list()
[09:31:57.516]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.516]     if (FALSE) {
[09:31:57.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.516]     }
[09:31:57.516]     ...future.result <- base::tryCatch({
[09:31:57.516]         base::withCallingHandlers({
[09:31:57.516]             ...future.value <- base::withVisible(base::local({
[09:31:57.516]                 ...future.makeSendCondition <- base::local({
[09:31:57.516]                   sendCondition <- NULL
[09:31:57.516]                   function(frame = 1L) {
[09:31:57.516]                     if (is.function(sendCondition)) 
[09:31:57.516]                       return(sendCondition)
[09:31:57.516]                     ns <- getNamespace("parallel")
[09:31:57.516]                     if (exists("sendData", mode = "function", 
[09:31:57.516]                       envir = ns)) {
[09:31:57.516]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:57.516]                         envir = ns)
[09:31:57.516]                       envir <- sys.frame(frame)
[09:31:57.516]                       master <- NULL
[09:31:57.516]                       while (!identical(envir, .GlobalEnv) && 
[09:31:57.516]                         !identical(envir, emptyenv())) {
[09:31:57.516]                         if (exists("master", mode = "list", envir = envir, 
[09:31:57.516]                           inherits = FALSE)) {
[09:31:57.516]                           master <- get("master", mode = "list", 
[09:31:57.516]                             envir = envir, inherits = FALSE)
[09:31:57.516]                           if (inherits(master, c("SOCKnode", 
[09:31:57.516]                             "SOCK0node"))) {
[09:31:57.516]                             sendCondition <<- function(cond) {
[09:31:57.516]                               data <- list(type = "VALUE", value = cond, 
[09:31:57.516]                                 success = TRUE)
[09:31:57.516]                               parallel_sendData(master, data)
[09:31:57.516]                             }
[09:31:57.516]                             return(sendCondition)
[09:31:57.516]                           }
[09:31:57.516]                         }
[09:31:57.516]                         frame <- frame + 1L
[09:31:57.516]                         envir <- sys.frame(frame)
[09:31:57.516]                       }
[09:31:57.516]                     }
[09:31:57.516]                     sendCondition <<- function(cond) NULL
[09:31:57.516]                   }
[09:31:57.516]                 })
[09:31:57.516]                 withCallingHandlers({
[09:31:57.516]                   {
[09:31:57.516]                     b <- 2L
[09:31:57.516]                     plan_b <- future::plan("list")
[09:31:57.516]                     nested_b <- nested_a[-1]
[09:31:57.516]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:57.516]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:57.516]                       "sequential"))
[09:31:57.516]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:57.516]                       b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:57.516]                   }
[09:31:57.516]                 }, immediateCondition = function(cond) {
[09:31:57.516]                   sendCondition <- ...future.makeSendCondition()
[09:31:57.516]                   sendCondition(cond)
[09:31:57.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.516]                   {
[09:31:57.516]                     inherits <- base::inherits
[09:31:57.516]                     invokeRestart <- base::invokeRestart
[09:31:57.516]                     is.null <- base::is.null
[09:31:57.516]                     muffled <- FALSE
[09:31:57.516]                     if (inherits(cond, "message")) {
[09:31:57.516]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:57.516]                       if (muffled) 
[09:31:57.516]                         invokeRestart("muffleMessage")
[09:31:57.516]                     }
[09:31:57.516]                     else if (inherits(cond, "warning")) {
[09:31:57.516]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:57.516]                       if (muffled) 
[09:31:57.516]                         invokeRestart("muffleWarning")
[09:31:57.516]                     }
[09:31:57.516]                     else if (inherits(cond, "condition")) {
[09:31:57.516]                       if (!is.null(pattern)) {
[09:31:57.516]                         computeRestarts <- base::computeRestarts
[09:31:57.516]                         grepl <- base::grepl
[09:31:57.516]                         restarts <- computeRestarts(cond)
[09:31:57.516]                         for (restart in restarts) {
[09:31:57.516]                           name <- restart$name
[09:31:57.516]                           if (is.null(name)) 
[09:31:57.516]                             next
[09:31:57.516]                           if (!grepl(pattern, name)) 
[09:31:57.516]                             next
[09:31:57.516]                           invokeRestart(restart)
[09:31:57.516]                           muffled <- TRUE
[09:31:57.516]                           break
[09:31:57.516]                         }
[09:31:57.516]                       }
[09:31:57.516]                     }
[09:31:57.516]                     invisible(muffled)
[09:31:57.516]                   }
[09:31:57.516]                   muffleCondition(cond)
[09:31:57.516]                 })
[09:31:57.516]             }))
[09:31:57.516]             future::FutureResult(value = ...future.value$value, 
[09:31:57.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.516]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.516]                     ...future.globalenv.names))
[09:31:57.516]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.516]         }, condition = base::local({
[09:31:57.516]             c <- base::c
[09:31:57.516]             inherits <- base::inherits
[09:31:57.516]             invokeRestart <- base::invokeRestart
[09:31:57.516]             length <- base::length
[09:31:57.516]             list <- base::list
[09:31:57.516]             seq.int <- base::seq.int
[09:31:57.516]             signalCondition <- base::signalCondition
[09:31:57.516]             sys.calls <- base::sys.calls
[09:31:57.516]             `[[` <- base::`[[`
[09:31:57.516]             `+` <- base::`+`
[09:31:57.516]             `<<-` <- base::`<<-`
[09:31:57.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.516]                   3L)]
[09:31:57.516]             }
[09:31:57.516]             function(cond) {
[09:31:57.516]                 is_error <- inherits(cond, "error")
[09:31:57.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.516]                   NULL)
[09:31:57.516]                 if (is_error) {
[09:31:57.516]                   sessionInformation <- function() {
[09:31:57.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.516]                       search = base::search(), system = base::Sys.info())
[09:31:57.516]                   }
[09:31:57.516]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.516]                     cond$call), session = sessionInformation(), 
[09:31:57.516]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.516]                   signalCondition(cond)
[09:31:57.516]                 }
[09:31:57.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.516]                 "immediateCondition"))) {
[09:31:57.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.516]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.516]                   if (TRUE && !signal) {
[09:31:57.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.516]                     {
[09:31:57.516]                       inherits <- base::inherits
[09:31:57.516]                       invokeRestart <- base::invokeRestart
[09:31:57.516]                       is.null <- base::is.null
[09:31:57.516]                       muffled <- FALSE
[09:31:57.516]                       if (inherits(cond, "message")) {
[09:31:57.516]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.516]                         if (muffled) 
[09:31:57.516]                           invokeRestart("muffleMessage")
[09:31:57.516]                       }
[09:31:57.516]                       else if (inherits(cond, "warning")) {
[09:31:57.516]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.516]                         if (muffled) 
[09:31:57.516]                           invokeRestart("muffleWarning")
[09:31:57.516]                       }
[09:31:57.516]                       else if (inherits(cond, "condition")) {
[09:31:57.516]                         if (!is.null(pattern)) {
[09:31:57.516]                           computeRestarts <- base::computeRestarts
[09:31:57.516]                           grepl <- base::grepl
[09:31:57.516]                           restarts <- computeRestarts(cond)
[09:31:57.516]                           for (restart in restarts) {
[09:31:57.516]                             name <- restart$name
[09:31:57.516]                             if (is.null(name)) 
[09:31:57.516]                               next
[09:31:57.516]                             if (!grepl(pattern, name)) 
[09:31:57.516]                               next
[09:31:57.516]                             invokeRestart(restart)
[09:31:57.516]                             muffled <- TRUE
[09:31:57.516]                             break
[09:31:57.516]                           }
[09:31:57.516]                         }
[09:31:57.516]                       }
[09:31:57.516]                       invisible(muffled)
[09:31:57.516]                     }
[09:31:57.516]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.516]                   }
[09:31:57.516]                 }
[09:31:57.516]                 else {
[09:31:57.516]                   if (TRUE) {
[09:31:57.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.516]                     {
[09:31:57.516]                       inherits <- base::inherits
[09:31:57.516]                       invokeRestart <- base::invokeRestart
[09:31:57.516]                       is.null <- base::is.null
[09:31:57.516]                       muffled <- FALSE
[09:31:57.516]                       if (inherits(cond, "message")) {
[09:31:57.516]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.516]                         if (muffled) 
[09:31:57.516]                           invokeRestart("muffleMessage")
[09:31:57.516]                       }
[09:31:57.516]                       else if (inherits(cond, "warning")) {
[09:31:57.516]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.516]                         if (muffled) 
[09:31:57.516]                           invokeRestart("muffleWarning")
[09:31:57.516]                       }
[09:31:57.516]                       else if (inherits(cond, "condition")) {
[09:31:57.516]                         if (!is.null(pattern)) {
[09:31:57.516]                           computeRestarts <- base::computeRestarts
[09:31:57.516]                           grepl <- base::grepl
[09:31:57.516]                           restarts <- computeRestarts(cond)
[09:31:57.516]                           for (restart in restarts) {
[09:31:57.516]                             name <- restart$name
[09:31:57.516]                             if (is.null(name)) 
[09:31:57.516]                               next
[09:31:57.516]                             if (!grepl(pattern, name)) 
[09:31:57.516]                               next
[09:31:57.516]                             invokeRestart(restart)
[09:31:57.516]                             muffled <- TRUE
[09:31:57.516]                             break
[09:31:57.516]                           }
[09:31:57.516]                         }
[09:31:57.516]                       }
[09:31:57.516]                       invisible(muffled)
[09:31:57.516]                     }
[09:31:57.516]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.516]                   }
[09:31:57.516]                 }
[09:31:57.516]             }
[09:31:57.516]         }))
[09:31:57.516]     }, error = function(ex) {
[09:31:57.516]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.516]                 ...future.rng), started = ...future.startTime, 
[09:31:57.516]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.516]             version = "1.8"), class = "FutureResult")
[09:31:57.516]     }, finally = {
[09:31:57.516]         if (!identical(...future.workdir, getwd())) 
[09:31:57.516]             setwd(...future.workdir)
[09:31:57.516]         {
[09:31:57.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.516]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.516]             }
[09:31:57.516]             base::options(...future.oldOptions)
[09:31:57.516]             if (.Platform$OS.type == "windows") {
[09:31:57.516]                 old_names <- names(...future.oldEnvVars)
[09:31:57.516]                 envs <- base::Sys.getenv()
[09:31:57.516]                 names <- names(envs)
[09:31:57.516]                 common <- intersect(names, old_names)
[09:31:57.516]                 added <- setdiff(names, old_names)
[09:31:57.516]                 removed <- setdiff(old_names, names)
[09:31:57.516]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.516]                   envs[common]]
[09:31:57.516]                 NAMES <- toupper(changed)
[09:31:57.516]                 args <- list()
[09:31:57.516]                 for (kk in seq_along(NAMES)) {
[09:31:57.516]                   name <- changed[[kk]]
[09:31:57.516]                   NAME <- NAMES[[kk]]
[09:31:57.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.516]                     next
[09:31:57.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.516]                 }
[09:31:57.516]                 NAMES <- toupper(added)
[09:31:57.516]                 for (kk in seq_along(NAMES)) {
[09:31:57.516]                   name <- added[[kk]]
[09:31:57.516]                   NAME <- NAMES[[kk]]
[09:31:57.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.516]                     next
[09:31:57.516]                   args[[name]] <- ""
[09:31:57.516]                 }
[09:31:57.516]                 NAMES <- toupper(removed)
[09:31:57.516]                 for (kk in seq_along(NAMES)) {
[09:31:57.516]                   name <- removed[[kk]]
[09:31:57.516]                   NAME <- NAMES[[kk]]
[09:31:57.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.516]                     next
[09:31:57.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.516]                 }
[09:31:57.516]                 if (length(args) > 0) 
[09:31:57.516]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.516]             }
[09:31:57.516]             else {
[09:31:57.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.516]             }
[09:31:57.516]             {
[09:31:57.516]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.516]                   0L) {
[09:31:57.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.516]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.516]                   base::options(opts)
[09:31:57.516]                 }
[09:31:57.516]                 {
[09:31:57.516]                   {
[09:31:57.516]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:57.516]                     NULL
[09:31:57.516]                   }
[09:31:57.516]                   options(future.plan = NULL)
[09:31:57.516]                   if (is.na(NA_character_)) 
[09:31:57.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.516]                     .init = FALSE)
[09:31:57.516]                 }
[09:31:57.516]             }
[09:31:57.516]         }
[09:31:57.516]     })
[09:31:57.516]     if (TRUE) {
[09:31:57.516]         base::sink(type = "output", split = FALSE)
[09:31:57.516]         if (TRUE) {
[09:31:57.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.516]         }
[09:31:57.516]         else {
[09:31:57.516]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.516]         }
[09:31:57.516]         base::close(...future.stdout)
[09:31:57.516]         ...future.stdout <- NULL
[09:31:57.516]     }
[09:31:57.516]     ...future.result$conditions <- ...future.conditions
[09:31:57.516]     ...future.result$finished <- base::Sys.time()
[09:31:57.516]     ...future.result
[09:31:57.516] }
[09:31:57.707]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.566] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[09:31:57.707]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.567] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[09:31:57.707]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.567] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[09:31:57.707]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.567] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[09:31:57.708]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.568] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[09:31:57.708]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.568] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[09:31:57.708]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.612] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[09:31:57.708]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.612] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[09:31:57.708]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.613] MultisessionFuture started
[09:31:57.708]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.613] - Launch lazy future ... done
[09:31:57.709]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.614] run() for ‘MultisessionFuture’ ... done
[09:31:57.709]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.614] result() for ClusterFuture ...
[09:31:57.709]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.614] receiveMessageFromWorker() for ClusterFuture ...
[09:31:57.709]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.615] - Validating connection of MultisessionFuture
[09:31:57.709]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.688] - received message: FutureResult
[09:31:57.709]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] - Received FutureResult
[09:31:57.710]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] - Erased future from FutureRegistry
[09:31:57.710]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] result() for ClusterFuture ...
[09:31:57.710]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] - result already collected: FutureResult
[09:31:57.710]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] result() for ClusterFuture ... done
[09:31:57.710]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:57.710]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.689] result() for ClusterFuture ... done
[09:31:57.711]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.690] result() for ClusterFuture ...
[09:31:57.711]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.690] - result already collected: FutureResult
[09:31:57.711]  - Condition #98: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.690] result() for ClusterFuture ... done
[09:31:57.711] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:57.718] getGlobalsAndPackages() ...
[09:31:57.718] Searching for globals...
[09:31:57.720] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:57.720] Searching for globals ... DONE
[09:31:57.720] Resolving globals: FALSE
[09:31:57.721] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:57.721] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:57.721] - globals: [1] ‘data’
[09:31:57.721] - packages: [1] ‘future’
[09:31:57.721] getGlobalsAndPackages() ... DONE
[09:31:57.722] run() for ‘Future’ ...
[09:31:57.722] - state: ‘created’
[09:31:57.722] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:57.722] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:57.722] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:57.723]   - Field: ‘label’
[09:31:57.723]   - Field: ‘local’
[09:31:57.723]   - Field: ‘owner’
[09:31:57.723]   - Field: ‘envir’
[09:31:57.723]   - Field: ‘packages’
[09:31:57.723]   - Field: ‘gc’
[09:31:57.723]   - Field: ‘conditions’
[09:31:57.723]   - Field: ‘expr’
[09:31:57.724]   - Field: ‘uuid’
[09:31:57.724]   - Field: ‘seed’
[09:31:57.724]   - Field: ‘version’
[09:31:57.724]   - Field: ‘result’
[09:31:57.724]   - Field: ‘asynchronous’
[09:31:57.724]   - Field: ‘calls’
[09:31:57.724]   - Field: ‘globals’
[09:31:57.724]   - Field: ‘stdout’
[09:31:57.724]   - Field: ‘earlySignal’
[09:31:57.725]   - Field: ‘lazy’
[09:31:57.725]   - Field: ‘state’
[09:31:57.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:57.725] - Launch lazy future ...
[09:31:57.725] Packages needed by the future expression (n = 1): ‘future’
[09:31:57.725] Packages needed by future strategies (n = 1): ‘future’
[09:31:57.726] {
[09:31:57.726]     {
[09:31:57.726]         {
[09:31:57.726]             ...future.startTime <- base::Sys.time()
[09:31:57.726]             {
[09:31:57.726]                 {
[09:31:57.726]                   {
[09:31:57.726]                     {
[09:31:57.726]                       base::local({
[09:31:57.726]                         has_future <- base::requireNamespace("future", 
[09:31:57.726]                           quietly = TRUE)
[09:31:57.726]                         if (has_future) {
[09:31:57.726]                           ns <- base::getNamespace("future")
[09:31:57.726]                           version <- ns[[".package"]][["version"]]
[09:31:57.726]                           if (is.null(version)) 
[09:31:57.726]                             version <- utils::packageVersion("future")
[09:31:57.726]                         }
[09:31:57.726]                         else {
[09:31:57.726]                           version <- NULL
[09:31:57.726]                         }
[09:31:57.726]                         if (!has_future || version < "1.8.0") {
[09:31:57.726]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.726]                             "", base::R.version$version.string), 
[09:31:57.726]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:57.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:57.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.726]                               "release", "version")], collapse = " "), 
[09:31:57.726]                             hostname = base::Sys.info()[["nodename"]])
[09:31:57.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.726]                             info)
[09:31:57.726]                           info <- base::paste(info, collapse = "; ")
[09:31:57.726]                           if (!has_future) {
[09:31:57.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.726]                               info)
[09:31:57.726]                           }
[09:31:57.726]                           else {
[09:31:57.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.726]                               info, version)
[09:31:57.726]                           }
[09:31:57.726]                           base::stop(msg)
[09:31:57.726]                         }
[09:31:57.726]                       })
[09:31:57.726]                     }
[09:31:57.726]                     base::local({
[09:31:57.726]                       for (pkg in "future") {
[09:31:57.726]                         base::loadNamespace(pkg)
[09:31:57.726]                         base::library(pkg, character.only = TRUE)
[09:31:57.726]                       }
[09:31:57.726]                     })
[09:31:57.726]                   }
[09:31:57.726]                   ...future.strategy.old <- future::plan("list")
[09:31:57.726]                   options(future.plan = NULL)
[09:31:57.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.726]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:31:57.726]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:57.726]                     envir = parent.frame()) 
[09:31:57.726]                   {
[09:31:57.726]                     if (is.function(workers)) 
[09:31:57.726]                       workers <- workers()
[09:31:57.726]                     workers <- structure(as.integer(workers), 
[09:31:57.726]                       class = class(workers))
[09:31:57.726]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:31:57.726]                       workers >= 1)
[09:31:57.726]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:31:57.726]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:31:57.726]                     }
[09:31:57.726]                     future <- MultisessionFuture(..., workers = workers, 
[09:31:57.726]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:31:57.726]                       envir = envir)
[09:31:57.726]                     if (!future$lazy) 
[09:31:57.726]                       future <- run(future)
[09:31:57.726]                     invisible(future)
[09:31:57.726]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:57.726]                 }
[09:31:57.726]                 ...future.workdir <- getwd()
[09:31:57.726]             }
[09:31:57.726]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.726]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.726]         }
[09:31:57.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.726]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.726]             base::names(...future.oldOptions))
[09:31:57.726]     }
[09:31:57.726]     if (FALSE) {
[09:31:57.726]     }
[09:31:57.726]     else {
[09:31:57.726]         if (TRUE) {
[09:31:57.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.726]                 open = "w")
[09:31:57.726]         }
[09:31:57.726]         else {
[09:31:57.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.726]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.726]         }
[09:31:57.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.726]             base::sink(type = "output", split = FALSE)
[09:31:57.726]             base::close(...future.stdout)
[09:31:57.726]         }, add = TRUE)
[09:31:57.726]     }
[09:31:57.726]     ...future.frame <- base::sys.nframe()
[09:31:57.726]     ...future.conditions <- base::list()
[09:31:57.726]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.726]     if (FALSE) {
[09:31:57.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.726]     }
[09:31:57.726]     ...future.result <- base::tryCatch({
[09:31:57.726]         base::withCallingHandlers({
[09:31:57.726]             ...future.value <- base::withVisible(base::local({
[09:31:57.726]                 value(future(subset(data, a == 2)))
[09:31:57.726]             }))
[09:31:57.726]             future::FutureResult(value = ...future.value$value, 
[09:31:57.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.726]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.726]                     ...future.globalenv.names))
[09:31:57.726]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.726]         }, condition = base::local({
[09:31:57.726]             c <- base::c
[09:31:57.726]             inherits <- base::inherits
[09:31:57.726]             invokeRestart <- base::invokeRestart
[09:31:57.726]             length <- base::length
[09:31:57.726]             list <- base::list
[09:31:57.726]             seq.int <- base::seq.int
[09:31:57.726]             signalCondition <- base::signalCondition
[09:31:57.726]             sys.calls <- base::sys.calls
[09:31:57.726]             `[[` <- base::`[[`
[09:31:57.726]             `+` <- base::`+`
[09:31:57.726]             `<<-` <- base::`<<-`
[09:31:57.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.726]                   3L)]
[09:31:57.726]             }
[09:31:57.726]             function(cond) {
[09:31:57.726]                 is_error <- inherits(cond, "error")
[09:31:57.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.726]                   NULL)
[09:31:57.726]                 if (is_error) {
[09:31:57.726]                   sessionInformation <- function() {
[09:31:57.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.726]                       search = base::search(), system = base::Sys.info())
[09:31:57.726]                   }
[09:31:57.726]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.726]                     cond$call), session = sessionInformation(), 
[09:31:57.726]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.726]                   signalCondition(cond)
[09:31:57.726]                 }
[09:31:57.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.726]                 "immediateCondition"))) {
[09:31:57.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.726]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.726]                   if (TRUE && !signal) {
[09:31:57.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.726]                     {
[09:31:57.726]                       inherits <- base::inherits
[09:31:57.726]                       invokeRestart <- base::invokeRestart
[09:31:57.726]                       is.null <- base::is.null
[09:31:57.726]                       muffled <- FALSE
[09:31:57.726]                       if (inherits(cond, "message")) {
[09:31:57.726]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.726]                         if (muffled) 
[09:31:57.726]                           invokeRestart("muffleMessage")
[09:31:57.726]                       }
[09:31:57.726]                       else if (inherits(cond, "warning")) {
[09:31:57.726]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.726]                         if (muffled) 
[09:31:57.726]                           invokeRestart("muffleWarning")
[09:31:57.726]                       }
[09:31:57.726]                       else if (inherits(cond, "condition")) {
[09:31:57.726]                         if (!is.null(pattern)) {
[09:31:57.726]                           computeRestarts <- base::computeRestarts
[09:31:57.726]                           grepl <- base::grepl
[09:31:57.726]                           restarts <- computeRestarts(cond)
[09:31:57.726]                           for (restart in restarts) {
[09:31:57.726]                             name <- restart$name
[09:31:57.726]                             if (is.null(name)) 
[09:31:57.726]                               next
[09:31:57.726]                             if (!grepl(pattern, name)) 
[09:31:57.726]                               next
[09:31:57.726]                             invokeRestart(restart)
[09:31:57.726]                             muffled <- TRUE
[09:31:57.726]                             break
[09:31:57.726]                           }
[09:31:57.726]                         }
[09:31:57.726]                       }
[09:31:57.726]                       invisible(muffled)
[09:31:57.726]                     }
[09:31:57.726]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.726]                   }
[09:31:57.726]                 }
[09:31:57.726]                 else {
[09:31:57.726]                   if (TRUE) {
[09:31:57.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.726]                     {
[09:31:57.726]                       inherits <- base::inherits
[09:31:57.726]                       invokeRestart <- base::invokeRestart
[09:31:57.726]                       is.null <- base::is.null
[09:31:57.726]                       muffled <- FALSE
[09:31:57.726]                       if (inherits(cond, "message")) {
[09:31:57.726]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.726]                         if (muffled) 
[09:31:57.726]                           invokeRestart("muffleMessage")
[09:31:57.726]                       }
[09:31:57.726]                       else if (inherits(cond, "warning")) {
[09:31:57.726]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.726]                         if (muffled) 
[09:31:57.726]                           invokeRestart("muffleWarning")
[09:31:57.726]                       }
[09:31:57.726]                       else if (inherits(cond, "condition")) {
[09:31:57.726]                         if (!is.null(pattern)) {
[09:31:57.726]                           computeRestarts <- base::computeRestarts
[09:31:57.726]                           grepl <- base::grepl
[09:31:57.726]                           restarts <- computeRestarts(cond)
[09:31:57.726]                           for (restart in restarts) {
[09:31:57.726]                             name <- restart$name
[09:31:57.726]                             if (is.null(name)) 
[09:31:57.726]                               next
[09:31:57.726]                             if (!grepl(pattern, name)) 
[09:31:57.726]                               next
[09:31:57.726]                             invokeRestart(restart)
[09:31:57.726]                             muffled <- TRUE
[09:31:57.726]                             break
[09:31:57.726]                           }
[09:31:57.726]                         }
[09:31:57.726]                       }
[09:31:57.726]                       invisible(muffled)
[09:31:57.726]                     }
[09:31:57.726]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.726]                   }
[09:31:57.726]                 }
[09:31:57.726]             }
[09:31:57.726]         }))
[09:31:57.726]     }, error = function(ex) {
[09:31:57.726]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.726]                 ...future.rng), started = ...future.startTime, 
[09:31:57.726]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.726]             version = "1.8"), class = "FutureResult")
[09:31:57.726]     }, finally = {
[09:31:57.726]         if (!identical(...future.workdir, getwd())) 
[09:31:57.726]             setwd(...future.workdir)
[09:31:57.726]         {
[09:31:57.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.726]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.726]             }
[09:31:57.726]             base::options(...future.oldOptions)
[09:31:57.726]             if (.Platform$OS.type == "windows") {
[09:31:57.726]                 old_names <- names(...future.oldEnvVars)
[09:31:57.726]                 envs <- base::Sys.getenv()
[09:31:57.726]                 names <- names(envs)
[09:31:57.726]                 common <- intersect(names, old_names)
[09:31:57.726]                 added <- setdiff(names, old_names)
[09:31:57.726]                 removed <- setdiff(old_names, names)
[09:31:57.726]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.726]                   envs[common]]
[09:31:57.726]                 NAMES <- toupper(changed)
[09:31:57.726]                 args <- list()
[09:31:57.726]                 for (kk in seq_along(NAMES)) {
[09:31:57.726]                   name <- changed[[kk]]
[09:31:57.726]                   NAME <- NAMES[[kk]]
[09:31:57.726]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.726]                     next
[09:31:57.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.726]                 }
[09:31:57.726]                 NAMES <- toupper(added)
[09:31:57.726]                 for (kk in seq_along(NAMES)) {
[09:31:57.726]                   name <- added[[kk]]
[09:31:57.726]                   NAME <- NAMES[[kk]]
[09:31:57.726]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.726]                     next
[09:31:57.726]                   args[[name]] <- ""
[09:31:57.726]                 }
[09:31:57.726]                 NAMES <- toupper(removed)
[09:31:57.726]                 for (kk in seq_along(NAMES)) {
[09:31:57.726]                   name <- removed[[kk]]
[09:31:57.726]                   NAME <- NAMES[[kk]]
[09:31:57.726]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.726]                     next
[09:31:57.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.726]                 }
[09:31:57.726]                 if (length(args) > 0) 
[09:31:57.726]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.726]             }
[09:31:57.726]             else {
[09:31:57.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.726]             }
[09:31:57.726]             {
[09:31:57.726]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.726]                   0L) {
[09:31:57.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.726]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.726]                   base::options(opts)
[09:31:57.726]                 }
[09:31:57.726]                 {
[09:31:57.726]                   {
[09:31:57.726]                     NULL
[09:31:57.726]                     RNGkind("Mersenne-Twister")
[09:31:57.726]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:57.726]                       inherits = FALSE)
[09:31:57.726]                   }
[09:31:57.726]                   options(future.plan = NULL)
[09:31:57.726]                   if (is.na(NA_character_)) 
[09:31:57.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.726]                     .init = FALSE)
[09:31:57.726]                 }
[09:31:57.726]             }
[09:31:57.726]         }
[09:31:57.726]     })
[09:31:57.726]     if (TRUE) {
[09:31:57.726]         base::sink(type = "output", split = FALSE)
[09:31:57.726]         if (TRUE) {
[09:31:57.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.726]         }
[09:31:57.726]         else {
[09:31:57.726]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.726]         }
[09:31:57.726]         base::close(...future.stdout)
[09:31:57.726]         ...future.stdout <- NULL
[09:31:57.726]     }
[09:31:57.726]     ...future.result$conditions <- ...future.conditions
[09:31:57.726]     ...future.result$finished <- base::Sys.time()
[09:31:57.726]     ...future.result
[09:31:57.726] }
[09:31:57.728] assign_globals() ...
[09:31:57.728] List of 1
[09:31:57.728]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:57.728]   ..$ a: int [1:3] 1 2 3
[09:31:57.728]   ..$ b: int [1:3] 3 2 1
[09:31:57.728]  - attr(*, "where")=List of 1
[09:31:57.728]   ..$ data:<environment: R_EmptyEnv> 
[09:31:57.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:57.728]  - attr(*, "resolved")= logi FALSE
[09:31:57.728]  - attr(*, "total_size")= num 128
[09:31:57.728]  - attr(*, "already-done")= logi TRUE
[09:31:57.734] - copied ‘data’ to environment
[09:31:57.734] assign_globals() ... done
[09:31:57.734] plan(): Setting new future strategy stack:
[09:31:57.735] List of future strategies:
[09:31:57.735] 1. multisession:
[09:31:57.735]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:57.735]    - tweaked: FALSE
[09:31:57.735]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.738] plan(): nbrOfWorkers() = 2
[09:31:57.780] plan(): Setting new future strategy stack:
[09:31:57.780] List of future strategies:
[09:31:57.780] 1. sequential:
[09:31:57.780]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.780]    - tweaked: FALSE
[09:31:57.780]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.780] 2. multisession:
[09:31:57.780]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:57.780]    - tweaked: FALSE
[09:31:57.780]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.781] plan(): nbrOfWorkers() = 1
[09:31:57.781] SequentialFuture started (and completed)
[09:31:57.781] signalConditions() ...
[09:31:57.781]  - include = ‘immediateCondition’
[09:31:57.781]  - exclude = 
[09:31:57.781]  - resignal = FALSE
[09:31:57.781]  - Number of conditions: 63
[09:31:57.781] signalConditions() ... done
[09:31:57.782] - Launch lazy future ... done
[09:31:57.782] run() for ‘SequentialFuture’ ... done
[09:31:57.782] signalConditions() ...
[09:31:57.782]  - include = ‘immediateCondition’
[09:31:57.782]  - exclude = 
[09:31:57.782]  - resignal = FALSE
[09:31:57.782]  - Number of conditions: 63
[09:31:57.782] signalConditions() ... done
[09:31:57.782] Future state: ‘finished’
[09:31:57.782] signalConditions() ...
[09:31:57.782]  - include = ‘condition’
[09:31:57.783]  - exclude = ‘immediateCondition’
[09:31:57.783]  - resignal = TRUE
[09:31:57.783]  - Number of conditions: 63
[09:31:57.783]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.739] getGlobalsAndPackages() ...
[09:31:57.783]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.739] Searching for globals...
[09:31:57.783]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.752] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:57.783]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.752] Searching for globals ... DONE
[09:31:57.783]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.752] Resolving globals: FALSE
[09:31:57.783]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.753] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:57.784]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.753] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:57.784]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.753] - globals: [1] ‘data’
[09:31:57.784]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.753] 
[09:31:57.784]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.753] getGlobalsAndPackages() ... DONE
[09:31:57.784]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.754] run() for ‘Future’ ...
[09:31:57.784]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.754] - state: ‘created’
[09:31:57.784]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.754] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:57.785]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.769] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:57.785]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:57.785]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.769]   - Field: ‘node’
[09:31:57.785]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.769]   - Field: ‘label’
[09:31:57.785]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.769]   - Field: ‘local’
[09:31:57.785]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘owner’
[09:31:57.785]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘envir’
[09:31:57.785]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘workers’
[09:31:57.786]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘packages’
[09:31:57.786]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘gc’
[09:31:57.786]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘conditions’
[09:31:57.786]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘persistent’
[09:31:57.786]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘expr’
[09:31:57.786]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘uuid’
[09:31:57.786]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.770]   - Field: ‘seed’
[09:31:57.786]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘version’
[09:31:57.786]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘result’
[09:31:57.787]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘asynchronous’
[09:31:57.787]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘calls’
[09:31:57.787]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘globals’
[09:31:57.787]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘stdout’
[09:31:57.787]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘earlySignal’
[09:31:57.787]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘lazy’
[09:31:57.787]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771]   - Field: ‘state’
[09:31:57.787]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:57.788]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.772] - Launch lazy future ...
[09:31:57.788]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.772] Packages needed by the future expression (n = 0): <none>
[09:31:57.788]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.772] Packages needed by future strategies (n = 0): <none>
[09:31:57.788]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.772] {
[09:31:57.772]     {
[09:31:57.772]         {
[09:31:57.772]             ...future.startTime <- base::Sys.time()
[09:31:57.772]             {
[09:31:57.772]                 {
[09:31:57.772]                   {
[09:31:57.772]                     {
[09:31:57.772]                       base::local({
[09:31:57.772]                         has_future <- base::requireNamespace("future", 
[09:31:57.772]                           quietly = TRUE)
[09:31:57.772]                         if (has_future) {
[09:31:57.772]                           ns <- base::getNamespace("future")
[09:31:57.772]                           version <- ns[[".package"]][["version"]]
[09:31:57.772]                           if (is.null(version)) 
[09:31:57.772]                             version <- utils::packageVersion("future")
[09:31:57.772]                         }
[09:31:57.772]                         else {
[09:31:57.772]                           version <- NULL
[09:31:57.772]                         }
[09:31:57.772]                         if (!has_future || version < "1.8.0") {
[09:31:57.772]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.772]                             "", base::R.version$version.string), 
[09:31:57.772]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:57.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:57.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.772]                               "release", "version")], collapse = " "), 
[09:31:57.772]                             hostname = base::Sys.info()[["nodename"]])
[09:31:57.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.772]                             info)
[09:31:57.772]                           info <- base::paste(info, collapse = "; ")
[09:31:57.772]                           if (!has_future) {
[09:31:57.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.772]                               info)
[09:31:57.772]                           }
[09:31:57.772]                           else {
[09:31:57.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.772]                               info, version)
[09:31:57.772]                           }
[09:31:57.772]                           base::stop(msg)
[09:31:57.772]                         }
[09:31:57.772]                       })
[09:31:57.772]                     }
[09:31:57.772]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:57.772]                     base::options(mc.cores = 1L)
[09:31:57.772]                   }
[09:31:57.772]                   ...future.strategy.old <- future::plan("list")
[09:31:57.772]                   options(future.plan = NULL)
[09:31:57.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:57.772]                 }
[09:31:57.772]                 ...future.workdir <- getwd()
[09:31:57.772]             }
[09:31:57.772]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.772]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.772]         }
[09:31:57.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.772]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.772]             base::names(...future.oldOptions))
[09:31:57.772]     }
[09:31:57.772]     if (FALSE) {
[09:31:57.772]     }
[09:31:57.772]     else {
[09:31:57.772]         if (TRUE) {
[09:31:57.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.772]                 open = "w")
[09:31:57.772]         }
[09:31:57.772]         else {
[09:31:57.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.772]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.772]         }
[09:31:57.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.772]             base::sink(type = "output", split = FALSE)
[09:31:57.772]             base::close(...future.stdout)
[09:31:57.772]         }, add = TRUE)
[09:31:57.772]     }
[09:31:57.772]     ...future.frame <- base::sys.nframe()
[09:31:57.772]     ...future.conditions <- base::list()
[09:31:57.772]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.772]     if (FALSE) {
[09:31:57.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.772]     }
[09:31:57.772]     ...future.result <- base::tryCatch({
[09:31:57.772]         base::withCallingHandlers({
[09:31:57.772]             ...future.value <- base::withVisible(base::local({
[09:31:57.772]                 ...future.makeSendCondition <- base::local({
[09:31:57.772]                   sendCondition <- NULL
[09:31:57.772]                   function(frame = 1L) {
[09:31:57.772]                     if (is.function(sendCondition)) 
[09:31:57.772]                       return(sendCondition)
[09:31:57.772]                     ns <- getNamespace("parallel")
[09:31:57.772]                     if (exists("sendData", mode = "function", 
[09:31:57.772]                       envir = ns)) {
[09:31:57.772]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:57.772]                         envir = ns)
[09:31:57.772]                       envir <- sys.frame(frame)
[09:31:57.772]                       master <- NULL
[09:31:57.772]                       while (!identical(envir, .GlobalEnv) && 
[09:31:57.772]                         !identical(envir, emptyenv())) {
[09:31:57.772]                         if (exists("master", mode = "list", envir = envir, 
[09:31:57.772]                           inherits = FALSE)) {
[09:31:57.772]                           master <- get("master", mode = "list", 
[09:31:57.772]                             envir = envir, inherits = FALSE)
[09:31:57.772]                           if (inherits(master, c("SOCKnode", 
[09:31:57.772]                             "SOCK0node"))) {
[09:31:57.772]                             sendCondition <<- function(cond) {
[09:31:57.772]                               data <- list(type = "VALUE", value = cond, 
[09:31:57.772]                                 success = TRUE)
[09:31:57.772]                               parallel_sendData(master, data)
[09:31:57.772]                             }
[09:31:57.772]                             return(sendCondition)
[09:31:57.772]                           }
[09:31:57.772]                         }
[09:31:57.772]                         frame <- frame + 1L
[09:31:57.772]                         envir <- sys.frame(frame)
[09:31:57.772]                       }
[09:31:57.772]                     }
[09:31:57.772]                     sendCondition <<- function(cond) NULL
[09:31:57.772]                   }
[09:31:57.772]                 })
[09:31:57.772]                 withCallingHandlers({
[09:31:57.772]                   subset(data, a == 2)
[09:31:57.772]                 }, immediateCondition = function(cond) {
[09:31:57.772]                   sendCondition <- ...future.makeSendCondition()
[09:31:57.772]                   sendCondition(cond)
[09:31:57.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.772]                   {
[09:31:57.772]                     inherits <- base::inherits
[09:31:57.772]                     invokeRestart <- base::invokeRestart
[09:31:57.772]                     is.null <- base::is.null
[09:31:57.772]                     muffled <- FALSE
[09:31:57.772]                     if (inherits(cond, "message")) {
[09:31:57.772]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:57.772]                       if (muffled) 
[09:31:57.772]                         invokeRestart("muffleMessage")
[09:31:57.772]                     }
[09:31:57.772]                     else if (inherits(cond, "warning")) {
[09:31:57.772]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:57.772]                       if (muffled) 
[09:31:57.772]                         invokeRestart("muffleWarning")
[09:31:57.772]                     }
[09:31:57.772]                     else if (inherits(cond, "condition")) {
[09:31:57.772]                       if (!is.null(pattern)) {
[09:31:57.772]                         computeRestarts <- base::computeRestarts
[09:31:57.772]                         grepl <- base::grepl
[09:31:57.772]                         restarts <- computeRestarts(cond)
[09:31:57.772]                         for (restart in restarts) {
[09:31:57.772]                           name <- restart$name
[09:31:57.772]                           if (is.null(name)) 
[09:31:57.772]                             next
[09:31:57.772]                           if (!grepl(pattern, name)) 
[09:31:57.772]                             next
[09:31:57.772]                           invokeRestart(restart)
[09:31:57.772]                           muffled <- TRUE
[09:31:57.772]                           break
[09:31:57.772]                         }
[09:31:57.772]                       }
[09:31:57.772]                     }
[09:31:57.772]                     invisible(muffled)
[09:31:57.772]                   }
[09:31:57.772]                   muffleCondition(cond)
[09:31:57.772]                 })
[09:31:57.772]             }))
[09:31:57.772]             future::FutureResult(value = ...future.value$value, 
[09:31:57.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.772]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.772]                     ...future.globalenv.names))
[09:31:57.772]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.772]         }, condition = base::local({
[09:31:57.772]             c <- base::c
[09:31:57.772]             inherits <- base::inherits
[09:31:57.772]             invokeRestart <- base::invokeRestart
[09:31:57.772]             length <- base::length
[09:31:57.772]             list <- base::list
[09:31:57.772]             seq.int <- base::seq.int
[09:31:57.772]             signalCondition <- base::signalCondition
[09:31:57.772]             sys.calls <- base::sys.calls
[09:31:57.772]             `[[` <- base::`[[`
[09:31:57.772]             `+` <- base::`+`
[09:31:57.772]             `<<-` <- base::`<<-`
[09:31:57.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.772]                   3L)]
[09:31:57.772]             }
[09:31:57.772]             function(cond) {
[09:31:57.772]                 is_error <- inherits(cond, "error")
[09:31:57.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.772]                   NULL)
[09:31:57.772]                 if (is_error) {
[09:31:57.772]                   sessionInformation <- function() {
[09:31:57.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.772]                       search = base::search(), system = base::Sys.info())
[09:31:57.772]                   }
[09:31:57.772]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.772]                     cond$call), session = sessionInformation(), 
[09:31:57.772]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.772]                   signalCondition(cond)
[09:31:57.772]                 }
[09:31:57.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.772]                 "immediateCondition"))) {
[09:31:57.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.772]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.772]                   if (TRUE && !signal) {
[09:31:57.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.772]                     {
[09:31:57.772]                       inherits <- base::inherits
[09:31:57.772]                       invokeRestart <- base::invokeRestart
[09:31:57.772]                       is.null <- base::is.null
[09:31:57.772]                       muffled <- FALSE
[09:31:57.772]                       if (inherits(cond, "message")) {
[09:31:57.772]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.772]                         if (muffled) 
[09:31:57.772]                           invokeRestart("muffleMessage")
[09:31:57.772]                       }
[09:31:57.772]                       else if (inherits(cond, "warning")) {
[09:31:57.772]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.772]                         if (muffled) 
[09:31:57.772]                           invokeRestart("muffleWarning")
[09:31:57.772]                       }
[09:31:57.772]                       else if (inherits(cond, "condition")) {
[09:31:57.772]                         if (!is.null(pattern)) {
[09:31:57.772]                           computeRestarts <- base::computeRestarts
[09:31:57.772]                           grepl <- base::grepl
[09:31:57.772]                           restarts <- computeRestarts(cond)
[09:31:57.772]                           for (restart in restarts) {
[09:31:57.772]                             name <- restart$name
[09:31:57.772]                             if (is.null(name)) 
[09:31:57.772]                               next
[09:31:57.772]                             if (!grepl(pattern, name)) 
[09:31:57.772]                               next
[09:31:57.772]                             invokeRestart(restart)
[09:31:57.772]                             muffled <- TRUE
[09:31:57.772]                             break
[09:31:57.772]                           }
[09:31:57.772]                         }
[09:31:57.772]                       }
[09:31:57.772]                       invisible(muffled)
[09:31:57.772]                     }
[09:31:57.772]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.772]                   }
[09:31:57.772]                 }
[09:31:57.772]                 else {
[09:31:57.772]                   if (TRUE) {
[09:31:57.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.772]                     {
[09:31:57.772]                       inherits <- base::inherits
[09:31:57.772]                       invokeRestart <- base::invokeRestart
[09:31:57.772]                       is.null <- base::is.null
[09:31:57.772]                       muffled <- FALSE
[09:31:57.772]                       if (inherits(cond, "message")) {
[09:31:57.772]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.772]                         if (muffled) 
[09:31:57.772]                           invokeRestart("muffleMessage")
[09:31:57.772]                       }
[09:31:57.772]                       else if (inherits(cond, "warning")) {
[09:31:57.772]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.772]                         if (muffled) 
[09:31:57.772]                           invokeRestart("muffleWarning")
[09:31:57.772]                       }
[09:31:57.772]                       else if (inherits(cond, "condition")) {
[09:31:57.772]                         if (!is.null(pattern)) {
[09:31:57.772]                           computeRestarts <- base::computeRestarts
[09:31:57.772]                           grepl <- base::grepl
[09:31:57.772]                           restarts <- computeRestarts(cond)
[09:31:57.772]                           for (restart in restarts) {
[09:31:57.772]                             name <- restart$name
[09:31:57.772]                             if (is.null(name)) 
[09:31:57.772]                               next
[09:31:57.772]                             if (!grepl(pattern, name)) 
[09:31:57.772]                               next
[09:31:57.772]                             invokeRestart(restart)
[09:31:57.772]                             muffled <- TRUE
[09:31:57.772]                             break
[09:31:57.772]                           }
[09:31:57.772]                         }
[09:31:57.772]                       }
[09:31:57.772]                       invisible(muffled)
[09:31:57.772]                     }
[09:31:57.772]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.772]                   }
[09:31:57.772]                 }
[09:31:57.772]             }
[09:31:57.772]         }))
[09:31:57.772]     }, error = function(ex) {
[09:31:57.772]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.772]                 ...future.rng), started = ...future.startTime, 
[09:31:57.772]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.772]             version = "1.8"), class = "FutureResult")
[09:31:57.772]     }, finally = {
[09:31:57.772]         if (!identical(...future.workdir, getwd())) 
[09:31:57.772]             setwd(...future.workdir)
[09:31:57.772]         {
[09:31:57.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.772]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.772]             }
[09:31:57.772]             base::options(...future.oldOptions)
[09:31:57.772]             if (.Platform$OS.type == "windows") {
[09:31:57.772]                 old_names <- names(...future.oldEnvVars)
[09:31:57.772]                 envs <- base::Sys.getenv()
[09:31:57.772]                 names <- names(envs)
[09:31:57.772]                 common <- intersect(names, old_names)
[09:31:57.772]                 added <- setdiff(names, old_names)
[09:31:57.772]                 removed <- setdiff(old_names, names)
[09:31:57.772]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.772]                   envs[common]]
[09:31:57.772]                 NAMES <- toupper(changed)
[09:31:57.772]                 args <- list()
[09:31:57.772]                 for (kk in seq_along(NAMES)) {
[09:31:57.772]                   name <- changed[[kk]]
[09:31:57.772]                   NAME <- NAMES[[kk]]
[09:31:57.772]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.772]                     next
[09:31:57.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.772]                 }
[09:31:57.772]                 NAMES <- toupper(added)
[09:31:57.772]                 for (kk in seq_along(NAMES)) {
[09:31:57.772]                   name <- added[[kk]]
[09:31:57.772]                   NAME <- NAMES[[kk]]
[09:31:57.772]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.772]                     next
[09:31:57.772]                   args[[name]] <- ""
[09:31:57.772]                 }
[09:31:57.772]                 NAMES <- toupper(removed)
[09:31:57.772]                 for (kk in seq_along(NAMES)) {
[09:31:57.772]                   name <- removed[[kk]]
[09:31:57.772]                   NAME <- NAMES[[kk]]
[09:31:57.772]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.772]                     next
[09:31:57.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.772]                 }
[09:31:57.772]                 if (length(args) > 0) 
[09:31:57.772]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.772]             }
[09:31:57.772]             else {
[09:31:57.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.772]             }
[09:31:57.772]             {
[09:31:57.772]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.772]                   0L) {
[09:31:57.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.772]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.772]                   base::options(opts)
[09:31:57.772]                 }
[09:31:57.772]                 {
[09:31:57.772]                   {
[09:31:57.772]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:57.772]                     NULL
[09:31:57.772]                   }
[09:31:57.772]                   options(future.plan = NULL)
[09:31:57.772]                   if (is.na(NA_character_)) 
[09:31:57.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.772]                     .init = FALSE)
[09:31:57.772]                 }
[09:31:57.772]             }
[09:31:57.772]         }
[09:31:57.772]     })
[09:31:57.772]     if (TRUE) {
[09:31:57.772]         base::sink(type = "output", split = FALSE)
[09:31:57.772]         if (TRUE) {
[09:31:57.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.772]         }
[09:31:57.772]         else {
[09:31:57.772]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.772]         }
[09:31:57.772]         base::close(...future.stdout)
[09:31:57.772]         ...future.stdout <- NULL
[09:31:57.772]     }
[09:31:57.772]     ...future.result$conditions <- ...future.conditions
[09:31:57.772]     ...future.result$finished <- base::Sys.time()
[09:31:57.772]     ...future.result
[09:31:57.772] }
[09:31:57.788]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.775] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[09:31:57.788]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.775] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[09:31:57.788]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.775] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[09:31:57.789]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.776] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[09:31:57.789]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.776] MultisessionFuture started
[09:31:57.789]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.776] - Launch lazy future ... done
[09:31:57.789]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.777] run() for ‘MultisessionFuture’ ... done
[09:31:57.789]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.777] result() for ClusterFuture ...
[09:31:57.789]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.777] receiveMessageFromWorker() for ClusterFuture ...
[09:31:57.789]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.777] - Validating connection of MultisessionFuture
[09:31:57.789]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.778] - received message: FutureResult
[09:31:57.790]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] - Received FutureResult
[09:31:57.790]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] - Erased future from FutureRegistry
[09:31:57.790]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] result() for ClusterFuture ...
[09:31:57.790]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] - result already collected: FutureResult
[09:31:57.790]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] result() for ClusterFuture ... done
[09:31:57.790]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:57.790]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] result() for ClusterFuture ... done
[09:31:57.790]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] result() for ClusterFuture ...
[09:31:57.791]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.779] - result already collected: FutureResult
[09:31:57.791]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.780] result() for ClusterFuture ... done
[09:31:57.791] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[09:31:57.791] plan(): Setting new future strategy stack:
[09:31:57.791] List of future strategies:
[09:31:57.791] 1. multicore:
[09:31:57.791]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:57.791]    - tweaked: FALSE
[09:31:57.791]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.791] 2. sequential:
[09:31:57.791]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.791]    - tweaked: FALSE
[09:31:57.791]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.796] plan(): nbrOfWorkers() = 2
[09:31:57.796] getGlobalsAndPackages() ...
[09:31:57.796] Searching for globals...
[09:31:57.822] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:57.822] Searching for globals ... DONE
[09:31:57.822] Resolving globals: FALSE
[09:31:57.823] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[09:31:57.824] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:57.824] - globals: [2] ‘nested’, ‘strategy2’
[09:31:57.824] - packages: [1] ‘future’
[09:31:57.824] getGlobalsAndPackages() ... DONE
[09:31:57.825] run() for ‘Future’ ...
[09:31:57.825] - state: ‘created’
[09:31:57.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:57.828] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:57.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:57.829]   - Field: ‘label’
[09:31:57.829]   - Field: ‘local’
[09:31:57.829]   - Field: ‘owner’
[09:31:57.829]   - Field: ‘envir’
[09:31:57.829]   - Field: ‘workers’
[09:31:57.829]   - Field: ‘packages’
[09:31:57.829]   - Field: ‘gc’
[09:31:57.829]   - Field: ‘job’
[09:31:57.829]   - Field: ‘conditions’
[09:31:57.829]   - Field: ‘expr’
[09:31:57.830]   - Field: ‘uuid’
[09:31:57.830]   - Field: ‘seed’
[09:31:57.830]   - Field: ‘version’
[09:31:57.830]   - Field: ‘result’
[09:31:57.830]   - Field: ‘asynchronous’
[09:31:57.830]   - Field: ‘calls’
[09:31:57.830]   - Field: ‘globals’
[09:31:57.830]   - Field: ‘stdout’
[09:31:57.830]   - Field: ‘earlySignal’
[09:31:57.830]   - Field: ‘lazy’
[09:31:57.830]   - Field: ‘state’
[09:31:57.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:57.831] - Launch lazy future ...
[09:31:57.831] Packages needed by the future expression (n = 1): ‘future’
[09:31:57.831] Packages needed by future strategies (n = 1): ‘future’
[09:31:57.831] {
[09:31:57.831]     {
[09:31:57.831]         {
[09:31:57.831]             ...future.startTime <- base::Sys.time()
[09:31:57.831]             {
[09:31:57.831]                 {
[09:31:57.831]                   {
[09:31:57.831]                     {
[09:31:57.831]                       {
[09:31:57.831]                         base::local({
[09:31:57.831]                           has_future <- base::requireNamespace("future", 
[09:31:57.831]                             quietly = TRUE)
[09:31:57.831]                           if (has_future) {
[09:31:57.831]                             ns <- base::getNamespace("future")
[09:31:57.831]                             version <- ns[[".package"]][["version"]]
[09:31:57.831]                             if (is.null(version)) 
[09:31:57.831]                               version <- utils::packageVersion("future")
[09:31:57.831]                           }
[09:31:57.831]                           else {
[09:31:57.831]                             version <- NULL
[09:31:57.831]                           }
[09:31:57.831]                           if (!has_future || version < "1.8.0") {
[09:31:57.831]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.831]                               "", base::R.version$version.string), 
[09:31:57.831]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:57.831]                                 base::R.version$platform, 8 * 
[09:31:57.831]                                   base::.Machine$sizeof.pointer), 
[09:31:57.831]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.831]                                 "release", "version")], collapse = " "), 
[09:31:57.831]                               hostname = base::Sys.info()[["nodename"]])
[09:31:57.831]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.831]                               info)
[09:31:57.831]                             info <- base::paste(info, collapse = "; ")
[09:31:57.831]                             if (!has_future) {
[09:31:57.831]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.831]                                 info)
[09:31:57.831]                             }
[09:31:57.831]                             else {
[09:31:57.831]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.831]                                 info, version)
[09:31:57.831]                             }
[09:31:57.831]                             base::stop(msg)
[09:31:57.831]                           }
[09:31:57.831]                         })
[09:31:57.831]                       }
[09:31:57.831]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:57.831]                       base::options(mc.cores = 1L)
[09:31:57.831]                     }
[09:31:57.831]                     base::local({
[09:31:57.831]                       for (pkg in "future") {
[09:31:57.831]                         base::loadNamespace(pkg)
[09:31:57.831]                         base::library(pkg, character.only = TRUE)
[09:31:57.831]                       }
[09:31:57.831]                     })
[09:31:57.831]                   }
[09:31:57.831]                   ...future.strategy.old <- future::plan("list")
[09:31:57.831]                   options(future.plan = NULL)
[09:31:57.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.831]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:57.831]                   {
[09:31:57.831]                     future <- SequentialFuture(..., envir = envir)
[09:31:57.831]                     if (!future$lazy) 
[09:31:57.831]                       future <- run(future)
[09:31:57.831]                     invisible(future)
[09:31:57.831]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:57.831]                 }
[09:31:57.831]                 ...future.workdir <- getwd()
[09:31:57.831]             }
[09:31:57.831]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.831]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.831]         }
[09:31:57.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.831]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.831]             base::names(...future.oldOptions))
[09:31:57.831]     }
[09:31:57.831]     if (FALSE) {
[09:31:57.831]     }
[09:31:57.831]     else {
[09:31:57.831]         if (TRUE) {
[09:31:57.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.831]                 open = "w")
[09:31:57.831]         }
[09:31:57.831]         else {
[09:31:57.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.831]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.831]         }
[09:31:57.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.831]             base::sink(type = "output", split = FALSE)
[09:31:57.831]             base::close(...future.stdout)
[09:31:57.831]         }, add = TRUE)
[09:31:57.831]     }
[09:31:57.831]     ...future.frame <- base::sys.nframe()
[09:31:57.831]     ...future.conditions <- base::list()
[09:31:57.831]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.831]     if (FALSE) {
[09:31:57.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.831]     }
[09:31:57.831]     ...future.result <- base::tryCatch({
[09:31:57.831]         base::withCallingHandlers({
[09:31:57.831]             ...future.value <- base::withVisible(base::local({
[09:31:57.831]                 withCallingHandlers({
[09:31:57.831]                   {
[09:31:57.831]                     a <- 1L
[09:31:57.831]                     plan_a <- unclass(future::plan("list"))
[09:31:57.831]                     nested_a <- nested[-1]
[09:31:57.831]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:57.831]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:57.831]                       strategy2))
[09:31:57.831]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:57.831]                       "init") <- NULL
[09:31:57.831]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:57.831]                       "init") <- NULL
[09:31:57.831]                     stopifnot(all.equal(plan_a, nested_a))
[09:31:57.831]                     y %<-% {
[09:31:57.831]                       b <- 2L
[09:31:57.831]                       plan_b <- future::plan("list")
[09:31:57.831]                       nested_b <- nested_a[-1]
[09:31:57.831]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:57.831]                         1L, inherits(plan_b[[1]], "future"), 
[09:31:57.831]                         inherits(future::plan("next"), "sequential"))
[09:31:57.831]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:57.831]                         b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:57.831]                     }
[09:31:57.831]                     y
[09:31:57.831]                   }
[09:31:57.831]                 }, immediateCondition = function(cond) {
[09:31:57.831]                   save_rds <- function (object, pathname, ...) 
[09:31:57.831]                   {
[09:31:57.831]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:57.831]                     if (file_test("-f", pathname_tmp)) {
[09:31:57.831]                       fi_tmp <- file.info(pathname_tmp)
[09:31:57.831]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:57.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:57.831]                         fi_tmp[["mtime"]])
[09:31:57.831]                     }
[09:31:57.831]                     tryCatch({
[09:31:57.831]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:57.831]                     }, error = function(ex) {
[09:31:57.831]                       msg <- conditionMessage(ex)
[09:31:57.831]                       fi_tmp <- file.info(pathname_tmp)
[09:31:57.831]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:57.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:57.831]                         fi_tmp[["mtime"]], msg)
[09:31:57.831]                       ex$message <- msg
[09:31:57.831]                       stop(ex)
[09:31:57.831]                     })
[09:31:57.831]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:57.831]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:57.831]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:57.831]                       fi_tmp <- file.info(pathname_tmp)
[09:31:57.831]                       fi <- file.info(pathname)
[09:31:57.831]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:57.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:57.831]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:57.831]                         fi[["size"]], fi[["mtime"]])
[09:31:57.831]                       stop(msg)
[09:31:57.831]                     }
[09:31:57.831]                     invisible(pathname)
[09:31:57.831]                   }
[09:31:57.831]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:57.831]                     rootPath = tempdir()) 
[09:31:57.831]                   {
[09:31:57.831]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:57.831]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:57.831]                       tmpdir = path, fileext = ".rds")
[09:31:57.831]                     save_rds(obj, file)
[09:31:57.831]                   }
[09:31:57.831]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:57.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.831]                   {
[09:31:57.831]                     inherits <- base::inherits
[09:31:57.831]                     invokeRestart <- base::invokeRestart
[09:31:57.831]                     is.null <- base::is.null
[09:31:57.831]                     muffled <- FALSE
[09:31:57.831]                     if (inherits(cond, "message")) {
[09:31:57.831]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:57.831]                       if (muffled) 
[09:31:57.831]                         invokeRestart("muffleMessage")
[09:31:57.831]                     }
[09:31:57.831]                     else if (inherits(cond, "warning")) {
[09:31:57.831]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:57.831]                       if (muffled) 
[09:31:57.831]                         invokeRestart("muffleWarning")
[09:31:57.831]                     }
[09:31:57.831]                     else if (inherits(cond, "condition")) {
[09:31:57.831]                       if (!is.null(pattern)) {
[09:31:57.831]                         computeRestarts <- base::computeRestarts
[09:31:57.831]                         grepl <- base::grepl
[09:31:57.831]                         restarts <- computeRestarts(cond)
[09:31:57.831]                         for (restart in restarts) {
[09:31:57.831]                           name <- restart$name
[09:31:57.831]                           if (is.null(name)) 
[09:31:57.831]                             next
[09:31:57.831]                           if (!grepl(pattern, name)) 
[09:31:57.831]                             next
[09:31:57.831]                           invokeRestart(restart)
[09:31:57.831]                           muffled <- TRUE
[09:31:57.831]                           break
[09:31:57.831]                         }
[09:31:57.831]                       }
[09:31:57.831]                     }
[09:31:57.831]                     invisible(muffled)
[09:31:57.831]                   }
[09:31:57.831]                   muffleCondition(cond)
[09:31:57.831]                 })
[09:31:57.831]             }))
[09:31:57.831]             future::FutureResult(value = ...future.value$value, 
[09:31:57.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.831]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.831]                     ...future.globalenv.names))
[09:31:57.831]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.831]         }, condition = base::local({
[09:31:57.831]             c <- base::c
[09:31:57.831]             inherits <- base::inherits
[09:31:57.831]             invokeRestart <- base::invokeRestart
[09:31:57.831]             length <- base::length
[09:31:57.831]             list <- base::list
[09:31:57.831]             seq.int <- base::seq.int
[09:31:57.831]             signalCondition <- base::signalCondition
[09:31:57.831]             sys.calls <- base::sys.calls
[09:31:57.831]             `[[` <- base::`[[`
[09:31:57.831]             `+` <- base::`+`
[09:31:57.831]             `<<-` <- base::`<<-`
[09:31:57.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.831]                   3L)]
[09:31:57.831]             }
[09:31:57.831]             function(cond) {
[09:31:57.831]                 is_error <- inherits(cond, "error")
[09:31:57.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.831]                   NULL)
[09:31:57.831]                 if (is_error) {
[09:31:57.831]                   sessionInformation <- function() {
[09:31:57.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.831]                       search = base::search(), system = base::Sys.info())
[09:31:57.831]                   }
[09:31:57.831]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.831]                     cond$call), session = sessionInformation(), 
[09:31:57.831]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.831]                   signalCondition(cond)
[09:31:57.831]                 }
[09:31:57.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.831]                 "immediateCondition"))) {
[09:31:57.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.831]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.831]                   if (TRUE && !signal) {
[09:31:57.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.831]                     {
[09:31:57.831]                       inherits <- base::inherits
[09:31:57.831]                       invokeRestart <- base::invokeRestart
[09:31:57.831]                       is.null <- base::is.null
[09:31:57.831]                       muffled <- FALSE
[09:31:57.831]                       if (inherits(cond, "message")) {
[09:31:57.831]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.831]                         if (muffled) 
[09:31:57.831]                           invokeRestart("muffleMessage")
[09:31:57.831]                       }
[09:31:57.831]                       else if (inherits(cond, "warning")) {
[09:31:57.831]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.831]                         if (muffled) 
[09:31:57.831]                           invokeRestart("muffleWarning")
[09:31:57.831]                       }
[09:31:57.831]                       else if (inherits(cond, "condition")) {
[09:31:57.831]                         if (!is.null(pattern)) {
[09:31:57.831]                           computeRestarts <- base::computeRestarts
[09:31:57.831]                           grepl <- base::grepl
[09:31:57.831]                           restarts <- computeRestarts(cond)
[09:31:57.831]                           for (restart in restarts) {
[09:31:57.831]                             name <- restart$name
[09:31:57.831]                             if (is.null(name)) 
[09:31:57.831]                               next
[09:31:57.831]                             if (!grepl(pattern, name)) 
[09:31:57.831]                               next
[09:31:57.831]                             invokeRestart(restart)
[09:31:57.831]                             muffled <- TRUE
[09:31:57.831]                             break
[09:31:57.831]                           }
[09:31:57.831]                         }
[09:31:57.831]                       }
[09:31:57.831]                       invisible(muffled)
[09:31:57.831]                     }
[09:31:57.831]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.831]                   }
[09:31:57.831]                 }
[09:31:57.831]                 else {
[09:31:57.831]                   if (TRUE) {
[09:31:57.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.831]                     {
[09:31:57.831]                       inherits <- base::inherits
[09:31:57.831]                       invokeRestart <- base::invokeRestart
[09:31:57.831]                       is.null <- base::is.null
[09:31:57.831]                       muffled <- FALSE
[09:31:57.831]                       if (inherits(cond, "message")) {
[09:31:57.831]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.831]                         if (muffled) 
[09:31:57.831]                           invokeRestart("muffleMessage")
[09:31:57.831]                       }
[09:31:57.831]                       else if (inherits(cond, "warning")) {
[09:31:57.831]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.831]                         if (muffled) 
[09:31:57.831]                           invokeRestart("muffleWarning")
[09:31:57.831]                       }
[09:31:57.831]                       else if (inherits(cond, "condition")) {
[09:31:57.831]                         if (!is.null(pattern)) {
[09:31:57.831]                           computeRestarts <- base::computeRestarts
[09:31:57.831]                           grepl <- base::grepl
[09:31:57.831]                           restarts <- computeRestarts(cond)
[09:31:57.831]                           for (restart in restarts) {
[09:31:57.831]                             name <- restart$name
[09:31:57.831]                             if (is.null(name)) 
[09:31:57.831]                               next
[09:31:57.831]                             if (!grepl(pattern, name)) 
[09:31:57.831]                               next
[09:31:57.831]                             invokeRestart(restart)
[09:31:57.831]                             muffled <- TRUE
[09:31:57.831]                             break
[09:31:57.831]                           }
[09:31:57.831]                         }
[09:31:57.831]                       }
[09:31:57.831]                       invisible(muffled)
[09:31:57.831]                     }
[09:31:57.831]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.831]                   }
[09:31:57.831]                 }
[09:31:57.831]             }
[09:31:57.831]         }))
[09:31:57.831]     }, error = function(ex) {
[09:31:57.831]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.831]                 ...future.rng), started = ...future.startTime, 
[09:31:57.831]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.831]             version = "1.8"), class = "FutureResult")
[09:31:57.831]     }, finally = {
[09:31:57.831]         if (!identical(...future.workdir, getwd())) 
[09:31:57.831]             setwd(...future.workdir)
[09:31:57.831]         {
[09:31:57.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.831]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.831]             }
[09:31:57.831]             base::options(...future.oldOptions)
[09:31:57.831]             if (.Platform$OS.type == "windows") {
[09:31:57.831]                 old_names <- names(...future.oldEnvVars)
[09:31:57.831]                 envs <- base::Sys.getenv()
[09:31:57.831]                 names <- names(envs)
[09:31:57.831]                 common <- intersect(names, old_names)
[09:31:57.831]                 added <- setdiff(names, old_names)
[09:31:57.831]                 removed <- setdiff(old_names, names)
[09:31:57.831]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.831]                   envs[common]]
[09:31:57.831]                 NAMES <- toupper(changed)
[09:31:57.831]                 args <- list()
[09:31:57.831]                 for (kk in seq_along(NAMES)) {
[09:31:57.831]                   name <- changed[[kk]]
[09:31:57.831]                   NAME <- NAMES[[kk]]
[09:31:57.831]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.831]                     next
[09:31:57.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.831]                 }
[09:31:57.831]                 NAMES <- toupper(added)
[09:31:57.831]                 for (kk in seq_along(NAMES)) {
[09:31:57.831]                   name <- added[[kk]]
[09:31:57.831]                   NAME <- NAMES[[kk]]
[09:31:57.831]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.831]                     next
[09:31:57.831]                   args[[name]] <- ""
[09:31:57.831]                 }
[09:31:57.831]                 NAMES <- toupper(removed)
[09:31:57.831]                 for (kk in seq_along(NAMES)) {
[09:31:57.831]                   name <- removed[[kk]]
[09:31:57.831]                   NAME <- NAMES[[kk]]
[09:31:57.831]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.831]                     next
[09:31:57.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.831]                 }
[09:31:57.831]                 if (length(args) > 0) 
[09:31:57.831]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.831]             }
[09:31:57.831]             else {
[09:31:57.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.831]             }
[09:31:57.831]             {
[09:31:57.831]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.831]                   0L) {
[09:31:57.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.831]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.831]                   base::options(opts)
[09:31:57.831]                 }
[09:31:57.831]                 {
[09:31:57.831]                   {
[09:31:57.831]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:57.831]                     NULL
[09:31:57.831]                   }
[09:31:57.831]                   options(future.plan = NULL)
[09:31:57.831]                   if (is.na(NA_character_)) 
[09:31:57.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.831]                     .init = FALSE)
[09:31:57.831]                 }
[09:31:57.831]             }
[09:31:57.831]         }
[09:31:57.831]     })
[09:31:57.831]     if (TRUE) {
[09:31:57.831]         base::sink(type = "output", split = FALSE)
[09:31:57.831]         if (TRUE) {
[09:31:57.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.831]         }
[09:31:57.831]         else {
[09:31:57.831]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.831]         }
[09:31:57.831]         base::close(...future.stdout)
[09:31:57.831]         ...future.stdout <- NULL
[09:31:57.831]     }
[09:31:57.831]     ...future.result$conditions <- ...future.conditions
[09:31:57.831]     ...future.result$finished <- base::Sys.time()
[09:31:57.831]     ...future.result
[09:31:57.831] }
[09:31:57.834] assign_globals() ...
[09:31:57.834] List of 2
[09:31:57.834]  $ nested   :List of 2
[09:31:57.834]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:57.834]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:57.834]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:57.834]   ..$ b:function (..., envir = parent.frame())  
[09:31:57.834]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:57.834]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:57.834]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:57.834]  $ strategy2: chr "sequential"
[09:31:57.834]  - attr(*, "where")=List of 2
[09:31:57.834]   ..$ nested   :<environment: R_EmptyEnv> 
[09:31:57.834]   ..$ strategy2:<environment: R_EmptyEnv> 
[09:31:57.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:57.834]  - attr(*, "resolved")= logi FALSE
[09:31:57.834]  - attr(*, "total_size")= num 59224
[09:31:57.834]  - attr(*, "already-done")= logi TRUE
[09:31:57.838] - copied ‘nested’ to environment
[09:31:57.838] - copied ‘strategy2’ to environment
[09:31:57.838] assign_globals() ... done
[09:31:57.838] requestCore(): workers = 2
[09:31:57.841] MulticoreFuture started
[09:31:57.841] - Launch lazy future ... done
[09:31:57.842] run() for ‘MulticoreFuture’ ... done
[09:31:57.842] result() for MulticoreFuture ...
[09:31:57.842] plan(): Setting new future strategy stack:
[09:31:57.843] List of future strategies:
[09:31:57.843] 1. sequential:
[09:31:57.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.843]    - tweaked: FALSE
[09:31:57.843]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.844] plan(): nbrOfWorkers() = 1
[09:31:57.880] plan(): Setting new future strategy stack:
[09:31:57.880] List of future strategies:
[09:31:57.880] 1. multicore:
[09:31:57.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:57.880]    - tweaked: FALSE
[09:31:57.880]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.880] 2. sequential:
[09:31:57.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.880]    - tweaked: FALSE
[09:31:57.880]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.885] plan(): nbrOfWorkers() = 2
[09:31:57.887] result() for MulticoreFuture ...
[09:31:57.887] result() for MulticoreFuture ... done
[09:31:57.887] signalConditions() ...
[09:31:57.887]  - include = ‘immediateCondition’
[09:31:57.887]  - exclude = 
[09:31:57.887]  - resignal = FALSE
[09:31:57.888]  - Number of conditions: 54
[09:31:57.888] signalConditions() ... done
[09:31:57.888] result() for MulticoreFuture ... done
[09:31:57.888] result() for MulticoreFuture ...
[09:31:57.888] result() for MulticoreFuture ... done
[09:31:57.889] signalConditions() ...
[09:31:57.889]  - include = ‘immediateCondition’
[09:31:57.889]  - exclude = 
[09:31:57.889]  - resignal = FALSE
[09:31:57.889]  - Number of conditions: 54
[09:31:57.889] signalConditions() ... done
[09:31:57.890] Future state: ‘finished’
[09:31:57.890] result() for MulticoreFuture ...
[09:31:57.890] result() for MulticoreFuture ... done
[09:31:57.890] signalConditions() ...
[09:31:57.890]  - include = ‘condition’
[09:31:57.890]  - exclude = ‘immediateCondition’
[09:31:57.891]  - resignal = TRUE
[09:31:57.891]  - Number of conditions: 54
[09:31:57.891]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.845] getGlobalsAndPackages() ...
[09:31:57.891]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.846] Searching for globals...
[09:31:57.891]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.855] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[09:31:57.892]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.855] Searching for globals ... DONE
[09:31:57.892]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.856] Resolving globals: FALSE
[09:31:57.892]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.857] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[09:31:57.892]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.858] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[09:31:57.893]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.858] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[09:31:57.893]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.858] 
[09:31:57.893]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.858] getGlobalsAndPackages() ... DONE
[09:31:57.893]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.859] run() for ‘Future’ ...
[09:31:57.893]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.859] - state: ‘created’
[09:31:57.893]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.859] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:57.894]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:57.894]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:57.894]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.860]   - Field: ‘label’
[09:31:57.894]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.861]   - Field: ‘local’
[09:31:57.894]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.861]   - Field: ‘owner’
[09:31:57.894]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.861]   - Field: ‘envir’
[09:31:57.895]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.861]   - Field: ‘packages’
[09:31:57.895]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.861]   - Field: ‘gc’
[09:31:57.895]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.861]   - Field: ‘conditions’
[09:31:57.895]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.862]   - Field: ‘expr’
[09:31:57.895]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.862]   - Field: ‘uuid’
[09:31:57.896]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.862]   - Field: ‘seed’
[09:31:57.896]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.862]   - Field: ‘version’
[09:31:57.896]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.862]   - Field: ‘result’
[09:31:57.896]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.863]   - Field: ‘asynchronous’
[09:31:57.896]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.863]   - Field: ‘calls’
[09:31:57.896]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.863]   - Field: ‘globals’
[09:31:57.897]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.863]   - Field: ‘stdout’
[09:31:57.897]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.863]   - Field: ‘earlySignal’
[09:31:57.897]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.863]   - Field: ‘lazy’
[09:31:57.897]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.864]   - Field: ‘state’
[09:31:57.897]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:57.897]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.864] - Launch lazy future ...
[09:31:57.898]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.864] Packages needed by the future expression (n = 0): <none>
[09:31:57.898]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.864] Packages needed by future strategies (n = 0): <none>
[09:31:57.898]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.865] {
[09:31:57.865]     {
[09:31:57.865]         {
[09:31:57.865]             ...future.startTime <- base::Sys.time()
[09:31:57.865]             {
[09:31:57.865]                 {
[09:31:57.865]                   {
[09:31:57.865]                     base::local({
[09:31:57.865]                       has_future <- base::requireNamespace("future", 
[09:31:57.865]                         quietly = TRUE)
[09:31:57.865]                       if (has_future) {
[09:31:57.865]                         ns <- base::getNamespace("future")
[09:31:57.865]                         version <- ns[[".package"]][["version"]]
[09:31:57.865]                         if (is.null(version)) 
[09:31:57.865]                           version <- utils::packageVersion("future")
[09:31:57.865]                       }
[09:31:57.865]                       else {
[09:31:57.865]                         version <- NULL
[09:31:57.865]                       }
[09:31:57.865]                       if (!has_future || version < "1.8.0") {
[09:31:57.865]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.865]                           "", base::R.version$version.string), 
[09:31:57.865]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:57.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:57.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.865]                             "release", "version")], collapse = " "), 
[09:31:57.865]                           hostname = base::Sys.info()[["nodename"]])
[09:31:57.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.865]                           info)
[09:31:57.865]                         info <- base::paste(info, collapse = "; ")
[09:31:57.865]                         if (!has_future) {
[09:31:57.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.865]                             info)
[09:31:57.865]                         }
[09:31:57.865]                         else {
[09:31:57.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.865]                             info, version)
[09:31:57.865]                         }
[09:31:57.865]                         base::stop(msg)
[09:31:57.865]                       }
[09:31:57.865]                     })
[09:31:57.865]                   }
[09:31:57.865]                   ...future.strategy.old <- future::plan("list")
[09:31:57.865]                   options(future.plan = NULL)
[09:31:57.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:57.865]                 }
[09:31:57.865]                 ...future.workdir <- getwd()
[09:31:57.865]             }
[09:31:57.865]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.865]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.865]         }
[09:31:57.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.865]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.865]             base::names(...future.oldOptions))
[09:31:57.865]     }
[09:31:57.865]     if (FALSE) {
[09:31:57.865]     }
[09:31:57.865]     else {
[09:31:57.865]         if (TRUE) {
[09:31:57.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.865]                 open = "w")
[09:31:57.865]         }
[09:31:57.865]         else {
[09:31:57.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.865]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.865]         }
[09:31:57.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.865]             base::sink(type = "output", split = FALSE)
[09:31:57.865]             base::close(...future.stdout)
[09:31:57.865]         }, add = TRUE)
[09:31:57.865]     }
[09:31:57.865]     ...future.frame <- base::sys.nframe()
[09:31:57.865]     ...future.conditions <- base::list()
[09:31:57.865]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.865]     if (FALSE) {
[09:31:57.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.865]     }
[09:31:57.865]     ...future.result <- base::tryCatch({
[09:31:57.865]         base::withCallingHandlers({
[09:31:57.865]             ...future.value <- base::withVisible(base::local({
[09:31:57.865]                 b <- 2L
[09:31:57.865]                 plan_b <- future::plan("list")
[09:31:57.865]                 nested_b <- nested_a[-1]
[09:31:57.865]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:57.865]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:57.865]                   "sequential"))
[09:31:57.865]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:57.865]                   b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:57.865]             }))
[09:31:57.865]             future::FutureResult(value = ...future.value$value, 
[09:31:57.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.865]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.865]                     ...future.globalenv.names))
[09:31:57.865]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.865]         }, condition = base::local({
[09:31:57.865]             c <- base::c
[09:31:57.865]             inherits <- base::inherits
[09:31:57.865]             invokeRestart <- base::invokeRestart
[09:31:57.865]             length <- base::length
[09:31:57.865]             list <- base::list
[09:31:57.865]             seq.int <- base::seq.int
[09:31:57.865]             signalCondition <- base::signalCondition
[09:31:57.865]             sys.calls <- base::sys.calls
[09:31:57.865]             `[[` <- base::`[[`
[09:31:57.865]             `+` <- base::`+`
[09:31:57.865]             `<<-` <- base::`<<-`
[09:31:57.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.865]                   3L)]
[09:31:57.865]             }
[09:31:57.865]             function(cond) {
[09:31:57.865]                 is_error <- inherits(cond, "error")
[09:31:57.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.865]                   NULL)
[09:31:57.865]                 if (is_error) {
[09:31:57.865]                   sessionInformation <- function() {
[09:31:57.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.865]                       search = base::search(), system = base::Sys.info())
[09:31:57.865]                   }
[09:31:57.865]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.865]                     cond$call), session = sessionInformation(), 
[09:31:57.865]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.865]                   signalCondition(cond)
[09:31:57.865]                 }
[09:31:57.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.865]                 "immediateCondition"))) {
[09:31:57.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.865]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.865]                   if (TRUE && !signal) {
[09:31:57.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.865]                     {
[09:31:57.865]                       inherits <- base::inherits
[09:31:57.865]                       invokeRestart <- base::invokeRestart
[09:31:57.865]                       is.null <- base::is.null
[09:31:57.865]                       muffled <- FALSE
[09:31:57.865]                       if (inherits(cond, "message")) {
[09:31:57.865]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.865]                         if (muffled) 
[09:31:57.865]                           invokeRestart("muffleMessage")
[09:31:57.865]                       }
[09:31:57.865]                       else if (inherits(cond, "warning")) {
[09:31:57.865]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.865]                         if (muffled) 
[09:31:57.865]                           invokeRestart("muffleWarning")
[09:31:57.865]                       }
[09:31:57.865]                       else if (inherits(cond, "condition")) {
[09:31:57.865]                         if (!is.null(pattern)) {
[09:31:57.865]                           computeRestarts <- base::computeRestarts
[09:31:57.865]                           grepl <- base::grepl
[09:31:57.865]                           restarts <- computeRestarts(cond)
[09:31:57.865]                           for (restart in restarts) {
[09:31:57.865]                             name <- restart$name
[09:31:57.865]                             if (is.null(name)) 
[09:31:57.865]                               next
[09:31:57.865]                             if (!grepl(pattern, name)) 
[09:31:57.865]                               next
[09:31:57.865]                             invokeRestart(restart)
[09:31:57.865]                             muffled <- TRUE
[09:31:57.865]                             break
[09:31:57.865]                           }
[09:31:57.865]                         }
[09:31:57.865]                       }
[09:31:57.865]                       invisible(muffled)
[09:31:57.865]                     }
[09:31:57.865]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.865]                   }
[09:31:57.865]                 }
[09:31:57.865]                 else {
[09:31:57.865]                   if (TRUE) {
[09:31:57.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.865]                     {
[09:31:57.865]                       inherits <- base::inherits
[09:31:57.865]                       invokeRestart <- base::invokeRestart
[09:31:57.865]                       is.null <- base::is.null
[09:31:57.865]                       muffled <- FALSE
[09:31:57.865]                       if (inherits(cond, "message")) {
[09:31:57.865]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.865]                         if (muffled) 
[09:31:57.865]                           invokeRestart("muffleMessage")
[09:31:57.865]                       }
[09:31:57.865]                       else if (inherits(cond, "warning")) {
[09:31:57.865]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.865]                         if (muffled) 
[09:31:57.865]                           invokeRestart("muffleWarning")
[09:31:57.865]                       }
[09:31:57.865]                       else if (inherits(cond, "condition")) {
[09:31:57.865]                         if (!is.null(pattern)) {
[09:31:57.865]                           computeRestarts <- base::computeRestarts
[09:31:57.865]                           grepl <- base::grepl
[09:31:57.865]                           restarts <- computeRestarts(cond)
[09:31:57.865]                           for (restart in restarts) {
[09:31:57.865]                             name <- restart$name
[09:31:57.865]                             if (is.null(name)) 
[09:31:57.865]                               next
[09:31:57.865]                             if (!grepl(pattern, name)) 
[09:31:57.865]                               next
[09:31:57.865]                             invokeRestart(restart)
[09:31:57.865]                             muffled <- TRUE
[09:31:57.865]                             break
[09:31:57.865]                           }
[09:31:57.865]                         }
[09:31:57.865]                       }
[09:31:57.865]                       invisible(muffled)
[09:31:57.865]                     }
[09:31:57.865]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.865]                   }
[09:31:57.865]                 }
[09:31:57.865]             }
[09:31:57.865]         }))
[09:31:57.865]     }, error = function(ex) {
[09:31:57.865]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.865]                 ...future.rng), started = ...future.startTime, 
[09:31:57.865]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.865]             version = "1.8"), class = "FutureResult")
[09:31:57.865]     }, finally = {
[09:31:57.865]         if (!identical(...future.workdir, getwd())) 
[09:31:57.865]             setwd(...future.workdir)
[09:31:57.865]         {
[09:31:57.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.865]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.865]             }
[09:31:57.865]             base::options(...future.oldOptions)
[09:31:57.865]             if (.Platform$OS.type == "windows") {
[09:31:57.865]                 old_names <- names(...future.oldEnvVars)
[09:31:57.865]                 envs <- base::Sys.getenv()
[09:31:57.865]                 names <- names(envs)
[09:31:57.865]                 common <- intersect(names, old_names)
[09:31:57.865]                 added <- setdiff(names, old_names)
[09:31:57.865]                 removed <- setdiff(old_names, names)
[09:31:57.865]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.865]                   envs[common]]
[09:31:57.865]                 NAMES <- toupper(changed)
[09:31:57.865]                 args <- list()
[09:31:57.865]                 for (kk in seq_along(NAMES)) {
[09:31:57.865]                   name <- changed[[kk]]
[09:31:57.865]                   NAME <- NAMES[[kk]]
[09:31:57.865]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.865]                     next
[09:31:57.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.865]                 }
[09:31:57.865]                 NAMES <- toupper(added)
[09:31:57.865]                 for (kk in seq_along(NAMES)) {
[09:31:57.865]                   name <- added[[kk]]
[09:31:57.865]                   NAME <- NAMES[[kk]]
[09:31:57.865]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.865]                     next
[09:31:57.865]                   args[[name]] <- ""
[09:31:57.865]                 }
[09:31:57.865]                 NAMES <- toupper(removed)
[09:31:57.865]                 for (kk in seq_along(NAMES)) {
[09:31:57.865]                   name <- removed[[kk]]
[09:31:57.865]                   NAME <- NAMES[[kk]]
[09:31:57.865]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.865]                     next
[09:31:57.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.865]                 }
[09:31:57.865]                 if (length(args) > 0) 
[09:31:57.865]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.865]             }
[09:31:57.865]             else {
[09:31:57.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.865]             }
[09:31:57.865]             {
[09:31:57.865]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.865]                   0L) {
[09:31:57.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.865]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.865]                   base::options(opts)
[09:31:57.865]                 }
[09:31:57.865]                 {
[09:31:57.865]                   {
[09:31:57.865]                     NULL
[09:31:57.865]                     RNGkind("Mersenne-Twister")
[09:31:57.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:57.865]                       inherits = FALSE)
[09:31:57.865]                   }
[09:31:57.865]                   options(future.plan = NULL)
[09:31:57.865]                   if (is.na(NA_character_)) 
[09:31:57.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.865]                     .init = FALSE)
[09:31:57.865]                 }
[09:31:57.865]             }
[09:31:57.865]         }
[09:31:57.865]     })
[09:31:57.865]     if (TRUE) {
[09:31:57.865]         base::sink(type = "output", split = FALSE)
[09:31:57.865]         if (TRUE) {
[09:31:57.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.865]         }
[09:31:57.865]         else {
[09:31:57.865]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.865]         }
[09:31:57.865]         base::close(...future.stdout)
[09:31:57.865]         ...future.stdout <- NULL
[09:31:57.865]     }
[09:31:57.865]     ...future.result$conditions <- ...future.conditions
[09:31:57.865]     ...future.result$finished <- base::Sys.time()
[09:31:57.865]     ...future.result
[09:31:57.865] }
[09:31:57.898]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.867] assign_globals() ...
[09:31:57.898]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.868] List of 3
[09:31:57.868]  $ nested_a:List of 1
[09:31:57.868]   ..$ b:function (..., envir = parent.frame())  
[09:31:57.868]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:57.868]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:57.868]  $ a       : int 1
[09:31:57.868]  $ plan_a  :List of 1
[09:31:57.868]   ..$ b:function (..., envir = parent.frame())  
[09:31:57.868]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[09:31:57.868]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:57.868]  - attr(*, "where")=List of 3
[09:31:57.868]   ..$ nested_a:<environment: R_EmptyEnv> 
[09:31:57.868]   ..$ a       :<environment: R_EmptyEnv> 
[09:31:57.868]   ..$ plan_a  :<environment: R_EmptyEnv> 
[09:31:57.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:57.868]  - attr(*, "resolved")= logi FALSE
[09:31:57.868]  - attr(*, "total_size")= num 23080
[09:31:57.868]  - attr(*, "already-done")= logi TRUE
[09:31:57.898]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.875] - copied ‘nested_a’ to environment
[09:31:57.899]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.875] - copied ‘a’ to environment
[09:31:57.899]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.875] - copied ‘plan_a’ to environment
[09:31:57.899]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.875] assign_globals() ... done
[09:31:57.899]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.876] plan(): Setting new future strategy stack:
[09:31:57.899]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.876] List of future strategies:
[09:31:57.876] 1. sequential:
[09:31:57.876]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.876]    - tweaked: FALSE
[09:31:57.876]    - call: NULL
[09:31:57.899]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.877] plan(): nbrOfWorkers() = 1
[09:31:57.900]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.878] plan(): Setting new future strategy stack:
[09:31:57.900]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.878] List of future strategies:
[09:31:57.878] 1. sequential:
[09:31:57.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.878]    - tweaked: FALSE
[09:31:57.878]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.900]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.879] plan(): nbrOfWorkers() = 1
[09:31:57.900]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.879] SequentialFuture started (and completed)
[09:31:57.900]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.879] - Launch lazy future ... done
[09:31:57.900]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.879] run() for ‘SequentialFuture’ ... done
[09:31:57.901] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:57.907] getGlobalsAndPackages() ...
[09:31:57.907] Searching for globals...
[09:31:57.909] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:57.909] Searching for globals ... DONE
[09:31:57.909] Resolving globals: FALSE
[09:31:57.910] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:57.910] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:57.910] - globals: [1] ‘data’
[09:31:57.911] - packages: [1] ‘future’
[09:31:57.911] getGlobalsAndPackages() ... DONE
[09:31:57.911] run() for ‘Future’ ...
[09:31:57.911] - state: ‘created’
[09:31:57.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:57.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:57.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:57.916]   - Field: ‘label’
[09:31:57.916]   - Field: ‘local’
[09:31:57.916]   - Field: ‘owner’
[09:31:57.916]   - Field: ‘envir’
[09:31:57.916]   - Field: ‘workers’
[09:31:57.916]   - Field: ‘packages’
[09:31:57.916]   - Field: ‘gc’
[09:31:57.917]   - Field: ‘job’
[09:31:57.917]   - Field: ‘conditions’
[09:31:57.917]   - Field: ‘expr’
[09:31:57.917]   - Field: ‘uuid’
[09:31:57.917]   - Field: ‘seed’
[09:31:57.917]   - Field: ‘version’
[09:31:57.917]   - Field: ‘result’
[09:31:57.917]   - Field: ‘asynchronous’
[09:31:57.917]   - Field: ‘calls’
[09:31:57.918]   - Field: ‘globals’
[09:31:57.918]   - Field: ‘stdout’
[09:31:57.918]   - Field: ‘earlySignal’
[09:31:57.918]   - Field: ‘lazy’
[09:31:57.918]   - Field: ‘state’
[09:31:57.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:57.918] - Launch lazy future ...
[09:31:57.918] Packages needed by the future expression (n = 1): ‘future’
[09:31:57.919] Packages needed by future strategies (n = 1): ‘future’
[09:31:57.919] {
[09:31:57.919]     {
[09:31:57.919]         {
[09:31:57.919]             ...future.startTime <- base::Sys.time()
[09:31:57.919]             {
[09:31:57.919]                 {
[09:31:57.919]                   {
[09:31:57.919]                     {
[09:31:57.919]                       {
[09:31:57.919]                         base::local({
[09:31:57.919]                           has_future <- base::requireNamespace("future", 
[09:31:57.919]                             quietly = TRUE)
[09:31:57.919]                           if (has_future) {
[09:31:57.919]                             ns <- base::getNamespace("future")
[09:31:57.919]                             version <- ns[[".package"]][["version"]]
[09:31:57.919]                             if (is.null(version)) 
[09:31:57.919]                               version <- utils::packageVersion("future")
[09:31:57.919]                           }
[09:31:57.919]                           else {
[09:31:57.919]                             version <- NULL
[09:31:57.919]                           }
[09:31:57.919]                           if (!has_future || version < "1.8.0") {
[09:31:57.919]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.919]                               "", base::R.version$version.string), 
[09:31:57.919]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:57.919]                                 base::R.version$platform, 8 * 
[09:31:57.919]                                   base::.Machine$sizeof.pointer), 
[09:31:57.919]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.919]                                 "release", "version")], collapse = " "), 
[09:31:57.919]                               hostname = base::Sys.info()[["nodename"]])
[09:31:57.919]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.919]                               info)
[09:31:57.919]                             info <- base::paste(info, collapse = "; ")
[09:31:57.919]                             if (!has_future) {
[09:31:57.919]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.919]                                 info)
[09:31:57.919]                             }
[09:31:57.919]                             else {
[09:31:57.919]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.919]                                 info, version)
[09:31:57.919]                             }
[09:31:57.919]                             base::stop(msg)
[09:31:57.919]                           }
[09:31:57.919]                         })
[09:31:57.919]                       }
[09:31:57.919]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:57.919]                       base::options(mc.cores = 1L)
[09:31:57.919]                     }
[09:31:57.919]                     base::local({
[09:31:57.919]                       for (pkg in "future") {
[09:31:57.919]                         base::loadNamespace(pkg)
[09:31:57.919]                         base::library(pkg, character.only = TRUE)
[09:31:57.919]                       }
[09:31:57.919]                     })
[09:31:57.919]                   }
[09:31:57.919]                   ...future.strategy.old <- future::plan("list")
[09:31:57.919]                   options(future.plan = NULL)
[09:31:57.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.919]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:57.919]                   {
[09:31:57.919]                     future <- SequentialFuture(..., envir = envir)
[09:31:57.919]                     if (!future$lazy) 
[09:31:57.919]                       future <- run(future)
[09:31:57.919]                     invisible(future)
[09:31:57.919]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:57.919]                 }
[09:31:57.919]                 ...future.workdir <- getwd()
[09:31:57.919]             }
[09:31:57.919]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.919]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.919]         }
[09:31:57.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.919]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.919]             base::names(...future.oldOptions))
[09:31:57.919]     }
[09:31:57.919]     if (FALSE) {
[09:31:57.919]     }
[09:31:57.919]     else {
[09:31:57.919]         if (TRUE) {
[09:31:57.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.919]                 open = "w")
[09:31:57.919]         }
[09:31:57.919]         else {
[09:31:57.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.919]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.919]         }
[09:31:57.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.919]             base::sink(type = "output", split = FALSE)
[09:31:57.919]             base::close(...future.stdout)
[09:31:57.919]         }, add = TRUE)
[09:31:57.919]     }
[09:31:57.919]     ...future.frame <- base::sys.nframe()
[09:31:57.919]     ...future.conditions <- base::list()
[09:31:57.919]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.919]     if (FALSE) {
[09:31:57.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.919]     }
[09:31:57.919]     ...future.result <- base::tryCatch({
[09:31:57.919]         base::withCallingHandlers({
[09:31:57.919]             ...future.value <- base::withVisible(base::local({
[09:31:57.919]                 withCallingHandlers({
[09:31:57.919]                   {
[09:31:57.919]                     value(future(subset(data, a == 2)))
[09:31:57.919]                   }
[09:31:57.919]                 }, immediateCondition = function(cond) {
[09:31:57.919]                   save_rds <- function (object, pathname, ...) 
[09:31:57.919]                   {
[09:31:57.919]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:57.919]                     if (file_test("-f", pathname_tmp)) {
[09:31:57.919]                       fi_tmp <- file.info(pathname_tmp)
[09:31:57.919]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:57.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:57.919]                         fi_tmp[["mtime"]])
[09:31:57.919]                     }
[09:31:57.919]                     tryCatch({
[09:31:57.919]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:57.919]                     }, error = function(ex) {
[09:31:57.919]                       msg <- conditionMessage(ex)
[09:31:57.919]                       fi_tmp <- file.info(pathname_tmp)
[09:31:57.919]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:57.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:57.919]                         fi_tmp[["mtime"]], msg)
[09:31:57.919]                       ex$message <- msg
[09:31:57.919]                       stop(ex)
[09:31:57.919]                     })
[09:31:57.919]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:57.919]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:57.919]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:57.919]                       fi_tmp <- file.info(pathname_tmp)
[09:31:57.919]                       fi <- file.info(pathname)
[09:31:57.919]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:57.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:57.919]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:57.919]                         fi[["size"]], fi[["mtime"]])
[09:31:57.919]                       stop(msg)
[09:31:57.919]                     }
[09:31:57.919]                     invisible(pathname)
[09:31:57.919]                   }
[09:31:57.919]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:57.919]                     rootPath = tempdir()) 
[09:31:57.919]                   {
[09:31:57.919]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:57.919]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:57.919]                       tmpdir = path, fileext = ".rds")
[09:31:57.919]                     save_rds(obj, file)
[09:31:57.919]                   }
[09:31:57.919]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:57.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.919]                   {
[09:31:57.919]                     inherits <- base::inherits
[09:31:57.919]                     invokeRestart <- base::invokeRestart
[09:31:57.919]                     is.null <- base::is.null
[09:31:57.919]                     muffled <- FALSE
[09:31:57.919]                     if (inherits(cond, "message")) {
[09:31:57.919]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:57.919]                       if (muffled) 
[09:31:57.919]                         invokeRestart("muffleMessage")
[09:31:57.919]                     }
[09:31:57.919]                     else if (inherits(cond, "warning")) {
[09:31:57.919]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:57.919]                       if (muffled) 
[09:31:57.919]                         invokeRestart("muffleWarning")
[09:31:57.919]                     }
[09:31:57.919]                     else if (inherits(cond, "condition")) {
[09:31:57.919]                       if (!is.null(pattern)) {
[09:31:57.919]                         computeRestarts <- base::computeRestarts
[09:31:57.919]                         grepl <- base::grepl
[09:31:57.919]                         restarts <- computeRestarts(cond)
[09:31:57.919]                         for (restart in restarts) {
[09:31:57.919]                           name <- restart$name
[09:31:57.919]                           if (is.null(name)) 
[09:31:57.919]                             next
[09:31:57.919]                           if (!grepl(pattern, name)) 
[09:31:57.919]                             next
[09:31:57.919]                           invokeRestart(restart)
[09:31:57.919]                           muffled <- TRUE
[09:31:57.919]                           break
[09:31:57.919]                         }
[09:31:57.919]                       }
[09:31:57.919]                     }
[09:31:57.919]                     invisible(muffled)
[09:31:57.919]                   }
[09:31:57.919]                   muffleCondition(cond)
[09:31:57.919]                 })
[09:31:57.919]             }))
[09:31:57.919]             future::FutureResult(value = ...future.value$value, 
[09:31:57.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.919]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.919]                     ...future.globalenv.names))
[09:31:57.919]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.919]         }, condition = base::local({
[09:31:57.919]             c <- base::c
[09:31:57.919]             inherits <- base::inherits
[09:31:57.919]             invokeRestart <- base::invokeRestart
[09:31:57.919]             length <- base::length
[09:31:57.919]             list <- base::list
[09:31:57.919]             seq.int <- base::seq.int
[09:31:57.919]             signalCondition <- base::signalCondition
[09:31:57.919]             sys.calls <- base::sys.calls
[09:31:57.919]             `[[` <- base::`[[`
[09:31:57.919]             `+` <- base::`+`
[09:31:57.919]             `<<-` <- base::`<<-`
[09:31:57.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.919]                   3L)]
[09:31:57.919]             }
[09:31:57.919]             function(cond) {
[09:31:57.919]                 is_error <- inherits(cond, "error")
[09:31:57.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.919]                   NULL)
[09:31:57.919]                 if (is_error) {
[09:31:57.919]                   sessionInformation <- function() {
[09:31:57.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.919]                       search = base::search(), system = base::Sys.info())
[09:31:57.919]                   }
[09:31:57.919]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.919]                     cond$call), session = sessionInformation(), 
[09:31:57.919]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.919]                   signalCondition(cond)
[09:31:57.919]                 }
[09:31:57.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.919]                 "immediateCondition"))) {
[09:31:57.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.919]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.919]                   if (TRUE && !signal) {
[09:31:57.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.919]                     {
[09:31:57.919]                       inherits <- base::inherits
[09:31:57.919]                       invokeRestart <- base::invokeRestart
[09:31:57.919]                       is.null <- base::is.null
[09:31:57.919]                       muffled <- FALSE
[09:31:57.919]                       if (inherits(cond, "message")) {
[09:31:57.919]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.919]                         if (muffled) 
[09:31:57.919]                           invokeRestart("muffleMessage")
[09:31:57.919]                       }
[09:31:57.919]                       else if (inherits(cond, "warning")) {
[09:31:57.919]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.919]                         if (muffled) 
[09:31:57.919]                           invokeRestart("muffleWarning")
[09:31:57.919]                       }
[09:31:57.919]                       else if (inherits(cond, "condition")) {
[09:31:57.919]                         if (!is.null(pattern)) {
[09:31:57.919]                           computeRestarts <- base::computeRestarts
[09:31:57.919]                           grepl <- base::grepl
[09:31:57.919]                           restarts <- computeRestarts(cond)
[09:31:57.919]                           for (restart in restarts) {
[09:31:57.919]                             name <- restart$name
[09:31:57.919]                             if (is.null(name)) 
[09:31:57.919]                               next
[09:31:57.919]                             if (!grepl(pattern, name)) 
[09:31:57.919]                               next
[09:31:57.919]                             invokeRestart(restart)
[09:31:57.919]                             muffled <- TRUE
[09:31:57.919]                             break
[09:31:57.919]                           }
[09:31:57.919]                         }
[09:31:57.919]                       }
[09:31:57.919]                       invisible(muffled)
[09:31:57.919]                     }
[09:31:57.919]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.919]                   }
[09:31:57.919]                 }
[09:31:57.919]                 else {
[09:31:57.919]                   if (TRUE) {
[09:31:57.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.919]                     {
[09:31:57.919]                       inherits <- base::inherits
[09:31:57.919]                       invokeRestart <- base::invokeRestart
[09:31:57.919]                       is.null <- base::is.null
[09:31:57.919]                       muffled <- FALSE
[09:31:57.919]                       if (inherits(cond, "message")) {
[09:31:57.919]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.919]                         if (muffled) 
[09:31:57.919]                           invokeRestart("muffleMessage")
[09:31:57.919]                       }
[09:31:57.919]                       else if (inherits(cond, "warning")) {
[09:31:57.919]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.919]                         if (muffled) 
[09:31:57.919]                           invokeRestart("muffleWarning")
[09:31:57.919]                       }
[09:31:57.919]                       else if (inherits(cond, "condition")) {
[09:31:57.919]                         if (!is.null(pattern)) {
[09:31:57.919]                           computeRestarts <- base::computeRestarts
[09:31:57.919]                           grepl <- base::grepl
[09:31:57.919]                           restarts <- computeRestarts(cond)
[09:31:57.919]                           for (restart in restarts) {
[09:31:57.919]                             name <- restart$name
[09:31:57.919]                             if (is.null(name)) 
[09:31:57.919]                               next
[09:31:57.919]                             if (!grepl(pattern, name)) 
[09:31:57.919]                               next
[09:31:57.919]                             invokeRestart(restart)
[09:31:57.919]                             muffled <- TRUE
[09:31:57.919]                             break
[09:31:57.919]                           }
[09:31:57.919]                         }
[09:31:57.919]                       }
[09:31:57.919]                       invisible(muffled)
[09:31:57.919]                     }
[09:31:57.919]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.919]                   }
[09:31:57.919]                 }
[09:31:57.919]             }
[09:31:57.919]         }))
[09:31:57.919]     }, error = function(ex) {
[09:31:57.919]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.919]                 ...future.rng), started = ...future.startTime, 
[09:31:57.919]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.919]             version = "1.8"), class = "FutureResult")
[09:31:57.919]     }, finally = {
[09:31:57.919]         if (!identical(...future.workdir, getwd())) 
[09:31:57.919]             setwd(...future.workdir)
[09:31:57.919]         {
[09:31:57.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.919]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.919]             }
[09:31:57.919]             base::options(...future.oldOptions)
[09:31:57.919]             if (.Platform$OS.type == "windows") {
[09:31:57.919]                 old_names <- names(...future.oldEnvVars)
[09:31:57.919]                 envs <- base::Sys.getenv()
[09:31:57.919]                 names <- names(envs)
[09:31:57.919]                 common <- intersect(names, old_names)
[09:31:57.919]                 added <- setdiff(names, old_names)
[09:31:57.919]                 removed <- setdiff(old_names, names)
[09:31:57.919]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.919]                   envs[common]]
[09:31:57.919]                 NAMES <- toupper(changed)
[09:31:57.919]                 args <- list()
[09:31:57.919]                 for (kk in seq_along(NAMES)) {
[09:31:57.919]                   name <- changed[[kk]]
[09:31:57.919]                   NAME <- NAMES[[kk]]
[09:31:57.919]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.919]                     next
[09:31:57.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.919]                 }
[09:31:57.919]                 NAMES <- toupper(added)
[09:31:57.919]                 for (kk in seq_along(NAMES)) {
[09:31:57.919]                   name <- added[[kk]]
[09:31:57.919]                   NAME <- NAMES[[kk]]
[09:31:57.919]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.919]                     next
[09:31:57.919]                   args[[name]] <- ""
[09:31:57.919]                 }
[09:31:57.919]                 NAMES <- toupper(removed)
[09:31:57.919]                 for (kk in seq_along(NAMES)) {
[09:31:57.919]                   name <- removed[[kk]]
[09:31:57.919]                   NAME <- NAMES[[kk]]
[09:31:57.919]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.919]                     next
[09:31:57.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.919]                 }
[09:31:57.919]                 if (length(args) > 0) 
[09:31:57.919]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.919]             }
[09:31:57.919]             else {
[09:31:57.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.919]             }
[09:31:57.919]             {
[09:31:57.919]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.919]                   0L) {
[09:31:57.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.919]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.919]                   base::options(opts)
[09:31:57.919]                 }
[09:31:57.919]                 {
[09:31:57.919]                   {
[09:31:57.919]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:57.919]                     NULL
[09:31:57.919]                   }
[09:31:57.919]                   options(future.plan = NULL)
[09:31:57.919]                   if (is.na(NA_character_)) 
[09:31:57.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.919]                     .init = FALSE)
[09:31:57.919]                 }
[09:31:57.919]             }
[09:31:57.919]         }
[09:31:57.919]     })
[09:31:57.919]     if (TRUE) {
[09:31:57.919]         base::sink(type = "output", split = FALSE)
[09:31:57.919]         if (TRUE) {
[09:31:57.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.919]         }
[09:31:57.919]         else {
[09:31:57.919]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.919]         }
[09:31:57.919]         base::close(...future.stdout)
[09:31:57.919]         ...future.stdout <- NULL
[09:31:57.919]     }
[09:31:57.919]     ...future.result$conditions <- ...future.conditions
[09:31:57.919]     ...future.result$finished <- base::Sys.time()
[09:31:57.919]     ...future.result
[09:31:57.919] }
[09:31:57.922] assign_globals() ...
[09:31:57.922] List of 1
[09:31:57.922]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:57.922]   ..$ a: int [1:3] 1 2 3
[09:31:57.922]   ..$ b: int [1:3] 3 2 1
[09:31:57.922]  - attr(*, "where")=List of 1
[09:31:57.922]   ..$ data:<environment: R_EmptyEnv> 
[09:31:57.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:57.922]  - attr(*, "resolved")= logi FALSE
[09:31:57.922]  - attr(*, "total_size")= num 128
[09:31:57.922]  - attr(*, "already-done")= logi TRUE
[09:31:57.925] - copied ‘data’ to environment
[09:31:57.926] assign_globals() ... done
[09:31:57.926] requestCore(): workers = 2
[09:31:57.928] MulticoreFuture started
[09:31:57.929] - Launch lazy future ... done
[09:31:57.929] run() for ‘MulticoreFuture’ ... done
[09:31:57.929] result() for MulticoreFuture ...
[09:31:57.930] plan(): Setting new future strategy stack:
[09:31:57.930] List of future strategies:
[09:31:57.930] 1. sequential:
[09:31:57.930]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.930]    - tweaked: FALSE
[09:31:57.930]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.931] plan(): nbrOfWorkers() = 1
[09:31:57.955] plan(): Setting new future strategy stack:
[09:31:57.955] List of future strategies:
[09:31:57.955] 1. multicore:
[09:31:57.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:57.955]    - tweaked: FALSE
[09:31:57.955]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.955] 2. sequential:
[09:31:57.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.955]    - tweaked: FALSE
[09:31:57.955]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.960] plan(): nbrOfWorkers() = 2
[09:31:57.961] result() for MulticoreFuture ...
[09:31:57.961] result() for MulticoreFuture ... done
[09:31:57.961] signalConditions() ...
[09:31:57.961]  - include = ‘immediateCondition’
[09:31:57.961]  - exclude = 
[09:31:57.962]  - resignal = FALSE
[09:31:57.962]  - Number of conditions: 52
[09:31:57.962] signalConditions() ... done
[09:31:57.962] result() for MulticoreFuture ... done
[09:31:57.962] result() for MulticoreFuture ...
[09:31:57.962] result() for MulticoreFuture ... done
[09:31:57.962] signalConditions() ...
[09:31:57.962]  - include = ‘immediateCondition’
[09:31:57.963]  - exclude = 
[09:31:57.963]  - resignal = FALSE
[09:31:57.963]  - Number of conditions: 52
[09:31:57.963] signalConditions() ... done
[09:31:57.963] Future state: ‘finished’
[09:31:57.963] result() for MulticoreFuture ...
[09:31:57.963] result() for MulticoreFuture ... done
[09:31:57.963] signalConditions() ...
[09:31:57.963]  - include = ‘condition’
[09:31:57.964]  - exclude = ‘immediateCondition’
[09:31:57.964]  - resignal = TRUE
[09:31:57.964]  - Number of conditions: 52
[09:31:57.964]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.932] getGlobalsAndPackages() ...
[09:31:57.964]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.932] Searching for globals...
[09:31:57.964]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.934] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:57.964]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.934] Searching for globals ... DONE
[09:31:57.965]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.935] Resolving globals: FALSE
[09:31:57.965]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.936] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:57.965]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.936] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:57.965]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.937] - globals: [1] ‘data’
[09:31:57.965]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.937] 
[09:31:57.965]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.937] getGlobalsAndPackages() ... DONE
[09:31:57.966]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.938] run() for ‘Future’ ...
[09:31:57.966]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.938] - state: ‘created’
[09:31:57.966]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.938] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:57.966]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.939] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:57.966]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:57.966]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.939]   - Field: ‘label’
[09:31:57.966]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.939]   - Field: ‘local’
[09:31:57.967]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.939]   - Field: ‘owner’
[09:31:57.967]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.940]   - Field: ‘envir’
[09:31:57.967]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.940]   - Field: ‘packages’
[09:31:57.967]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.940]   - Field: ‘gc’
[09:31:57.967]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.940]   - Field: ‘conditions’
[09:31:57.967]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.940]   - Field: ‘expr’
[09:31:57.968]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.940]   - Field: ‘uuid’
[09:31:57.968]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.941]   - Field: ‘seed’
[09:31:57.968]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.941]   - Field: ‘version’
[09:31:57.968]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.941]   - Field: ‘result’
[09:31:57.968]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.941]   - Field: ‘asynchronous’
[09:31:57.968]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.941]   - Field: ‘calls’
[09:31:57.968]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.941]   - Field: ‘globals’
[09:31:57.969]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.942]   - Field: ‘stdout’
[09:31:57.969]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.942]   - Field: ‘earlySignal’
[09:31:57.969]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.942]   - Field: ‘lazy’
[09:31:57.969]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.942]   - Field: ‘state’
[09:31:57.969]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:57.969]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.942] - Launch lazy future ...
[09:31:57.970]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.943] Packages needed by the future expression (n = 0): <none>
[09:31:57.970]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.943] Packages needed by future strategies (n = 0): <none>
[09:31:57.970]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.944] {
[09:31:57.944]     {
[09:31:57.944]         {
[09:31:57.944]             ...future.startTime <- base::Sys.time()
[09:31:57.944]             {
[09:31:57.944]                 {
[09:31:57.944]                   {
[09:31:57.944]                     base::local({
[09:31:57.944]                       has_future <- base::requireNamespace("future", 
[09:31:57.944]                         quietly = TRUE)
[09:31:57.944]                       if (has_future) {
[09:31:57.944]                         ns <- base::getNamespace("future")
[09:31:57.944]                         version <- ns[[".package"]][["version"]]
[09:31:57.944]                         if (is.null(version)) 
[09:31:57.944]                           version <- utils::packageVersion("future")
[09:31:57.944]                       }
[09:31:57.944]                       else {
[09:31:57.944]                         version <- NULL
[09:31:57.944]                       }
[09:31:57.944]                       if (!has_future || version < "1.8.0") {
[09:31:57.944]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:57.944]                           "", base::R.version$version.string), 
[09:31:57.944]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:57.944]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:57.944]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:57.944]                             "release", "version")], collapse = " "), 
[09:31:57.944]                           hostname = base::Sys.info()[["nodename"]])
[09:31:57.944]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:57.944]                           info)
[09:31:57.944]                         info <- base::paste(info, collapse = "; ")
[09:31:57.944]                         if (!has_future) {
[09:31:57.944]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:57.944]                             info)
[09:31:57.944]                         }
[09:31:57.944]                         else {
[09:31:57.944]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:57.944]                             info, version)
[09:31:57.944]                         }
[09:31:57.944]                         base::stop(msg)
[09:31:57.944]                       }
[09:31:57.944]                     })
[09:31:57.944]                   }
[09:31:57.944]                   ...future.strategy.old <- future::plan("list")
[09:31:57.944]                   options(future.plan = NULL)
[09:31:57.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:57.944]                 }
[09:31:57.944]                 ...future.workdir <- getwd()
[09:31:57.944]             }
[09:31:57.944]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:57.944]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:57.944]         }
[09:31:57.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:57.944]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:57.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:57.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:57.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:57.944]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:57.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:57.944]             base::names(...future.oldOptions))
[09:31:57.944]     }
[09:31:57.944]     if (FALSE) {
[09:31:57.944]     }
[09:31:57.944]     else {
[09:31:57.944]         if (TRUE) {
[09:31:57.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:57.944]                 open = "w")
[09:31:57.944]         }
[09:31:57.944]         else {
[09:31:57.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:57.944]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:57.944]         }
[09:31:57.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:57.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:57.944]             base::sink(type = "output", split = FALSE)
[09:31:57.944]             base::close(...future.stdout)
[09:31:57.944]         }, add = TRUE)
[09:31:57.944]     }
[09:31:57.944]     ...future.frame <- base::sys.nframe()
[09:31:57.944]     ...future.conditions <- base::list()
[09:31:57.944]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:57.944]     if (FALSE) {
[09:31:57.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:57.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:57.944]     }
[09:31:57.944]     ...future.result <- base::tryCatch({
[09:31:57.944]         base::withCallingHandlers({
[09:31:57.944]             ...future.value <- base::withVisible(base::local(subset(data, 
[09:31:57.944]                 a == 2)))
[09:31:57.944]             future::FutureResult(value = ...future.value$value, 
[09:31:57.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.944]                   ...future.rng), globalenv = if (FALSE) 
[09:31:57.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:57.944]                     ...future.globalenv.names))
[09:31:57.944]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:57.944]         }, condition = base::local({
[09:31:57.944]             c <- base::c
[09:31:57.944]             inherits <- base::inherits
[09:31:57.944]             invokeRestart <- base::invokeRestart
[09:31:57.944]             length <- base::length
[09:31:57.944]             list <- base::list
[09:31:57.944]             seq.int <- base::seq.int
[09:31:57.944]             signalCondition <- base::signalCondition
[09:31:57.944]             sys.calls <- base::sys.calls
[09:31:57.944]             `[[` <- base::`[[`
[09:31:57.944]             `+` <- base::`+`
[09:31:57.944]             `<<-` <- base::`<<-`
[09:31:57.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:57.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:57.944]                   3L)]
[09:31:57.944]             }
[09:31:57.944]             function(cond) {
[09:31:57.944]                 is_error <- inherits(cond, "error")
[09:31:57.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:57.944]                   NULL)
[09:31:57.944]                 if (is_error) {
[09:31:57.944]                   sessionInformation <- function() {
[09:31:57.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:57.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:57.944]                       search = base::search(), system = base::Sys.info())
[09:31:57.944]                   }
[09:31:57.944]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:57.944]                     cond$call), session = sessionInformation(), 
[09:31:57.944]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:57.944]                   signalCondition(cond)
[09:31:57.944]                 }
[09:31:57.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:57.944]                 "immediateCondition"))) {
[09:31:57.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:57.944]                   ...future.conditions[[length(...future.conditions) + 
[09:31:57.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:57.944]                   if (TRUE && !signal) {
[09:31:57.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.944]                     {
[09:31:57.944]                       inherits <- base::inherits
[09:31:57.944]                       invokeRestart <- base::invokeRestart
[09:31:57.944]                       is.null <- base::is.null
[09:31:57.944]                       muffled <- FALSE
[09:31:57.944]                       if (inherits(cond, "message")) {
[09:31:57.944]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.944]                         if (muffled) 
[09:31:57.944]                           invokeRestart("muffleMessage")
[09:31:57.944]                       }
[09:31:57.944]                       else if (inherits(cond, "warning")) {
[09:31:57.944]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.944]                         if (muffled) 
[09:31:57.944]                           invokeRestart("muffleWarning")
[09:31:57.944]                       }
[09:31:57.944]                       else if (inherits(cond, "condition")) {
[09:31:57.944]                         if (!is.null(pattern)) {
[09:31:57.944]                           computeRestarts <- base::computeRestarts
[09:31:57.944]                           grepl <- base::grepl
[09:31:57.944]                           restarts <- computeRestarts(cond)
[09:31:57.944]                           for (restart in restarts) {
[09:31:57.944]                             name <- restart$name
[09:31:57.944]                             if (is.null(name)) 
[09:31:57.944]                               next
[09:31:57.944]                             if (!grepl(pattern, name)) 
[09:31:57.944]                               next
[09:31:57.944]                             invokeRestart(restart)
[09:31:57.944]                             muffled <- TRUE
[09:31:57.944]                             break
[09:31:57.944]                           }
[09:31:57.944]                         }
[09:31:57.944]                       }
[09:31:57.944]                       invisible(muffled)
[09:31:57.944]                     }
[09:31:57.944]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.944]                   }
[09:31:57.944]                 }
[09:31:57.944]                 else {
[09:31:57.944]                   if (TRUE) {
[09:31:57.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:57.944]                     {
[09:31:57.944]                       inherits <- base::inherits
[09:31:57.944]                       invokeRestart <- base::invokeRestart
[09:31:57.944]                       is.null <- base::is.null
[09:31:57.944]                       muffled <- FALSE
[09:31:57.944]                       if (inherits(cond, "message")) {
[09:31:57.944]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:57.944]                         if (muffled) 
[09:31:57.944]                           invokeRestart("muffleMessage")
[09:31:57.944]                       }
[09:31:57.944]                       else if (inherits(cond, "warning")) {
[09:31:57.944]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:57.944]                         if (muffled) 
[09:31:57.944]                           invokeRestart("muffleWarning")
[09:31:57.944]                       }
[09:31:57.944]                       else if (inherits(cond, "condition")) {
[09:31:57.944]                         if (!is.null(pattern)) {
[09:31:57.944]                           computeRestarts <- base::computeRestarts
[09:31:57.944]                           grepl <- base::grepl
[09:31:57.944]                           restarts <- computeRestarts(cond)
[09:31:57.944]                           for (restart in restarts) {
[09:31:57.944]                             name <- restart$name
[09:31:57.944]                             if (is.null(name)) 
[09:31:57.944]                               next
[09:31:57.944]                             if (!grepl(pattern, name)) 
[09:31:57.944]                               next
[09:31:57.944]                             invokeRestart(restart)
[09:31:57.944]                             muffled <- TRUE
[09:31:57.944]                             break
[09:31:57.944]                           }
[09:31:57.944]                         }
[09:31:57.944]                       }
[09:31:57.944]                       invisible(muffled)
[09:31:57.944]                     }
[09:31:57.944]                     muffleCondition(cond, pattern = "^muffle")
[09:31:57.944]                   }
[09:31:57.944]                 }
[09:31:57.944]             }
[09:31:57.944]         }))
[09:31:57.944]     }, error = function(ex) {
[09:31:57.944]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:57.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:57.944]                 ...future.rng), started = ...future.startTime, 
[09:31:57.944]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:57.944]             version = "1.8"), class = "FutureResult")
[09:31:57.944]     }, finally = {
[09:31:57.944]         if (!identical(...future.workdir, getwd())) 
[09:31:57.944]             setwd(...future.workdir)
[09:31:57.944]         {
[09:31:57.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:57.944]                 ...future.oldOptions$nwarnings <- NULL
[09:31:57.944]             }
[09:31:57.944]             base::options(...future.oldOptions)
[09:31:57.944]             if (.Platform$OS.type == "windows") {
[09:31:57.944]                 old_names <- names(...future.oldEnvVars)
[09:31:57.944]                 envs <- base::Sys.getenv()
[09:31:57.944]                 names <- names(envs)
[09:31:57.944]                 common <- intersect(names, old_names)
[09:31:57.944]                 added <- setdiff(names, old_names)
[09:31:57.944]                 removed <- setdiff(old_names, names)
[09:31:57.944]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:57.944]                   envs[common]]
[09:31:57.944]                 NAMES <- toupper(changed)
[09:31:57.944]                 args <- list()
[09:31:57.944]                 for (kk in seq_along(NAMES)) {
[09:31:57.944]                   name <- changed[[kk]]
[09:31:57.944]                   NAME <- NAMES[[kk]]
[09:31:57.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.944]                     next
[09:31:57.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.944]                 }
[09:31:57.944]                 NAMES <- toupper(added)
[09:31:57.944]                 for (kk in seq_along(NAMES)) {
[09:31:57.944]                   name <- added[[kk]]
[09:31:57.944]                   NAME <- NAMES[[kk]]
[09:31:57.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.944]                     next
[09:31:57.944]                   args[[name]] <- ""
[09:31:57.944]                 }
[09:31:57.944]                 NAMES <- toupper(removed)
[09:31:57.944]                 for (kk in seq_along(NAMES)) {
[09:31:57.944]                   name <- removed[[kk]]
[09:31:57.944]                   NAME <- NAMES[[kk]]
[09:31:57.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:57.944]                     next
[09:31:57.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:57.944]                 }
[09:31:57.944]                 if (length(args) > 0) 
[09:31:57.944]                   base::do.call(base::Sys.setenv, args = args)
[09:31:57.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:57.944]             }
[09:31:57.944]             else {
[09:31:57.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:57.944]             }
[09:31:57.944]             {
[09:31:57.944]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:57.944]                   0L) {
[09:31:57.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:57.944]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:57.944]                   base::options(opts)
[09:31:57.944]                 }
[09:31:57.944]                 {
[09:31:57.944]                   {
[09:31:57.944]                     NULL
[09:31:57.944]                     RNGkind("Mersenne-Twister")
[09:31:57.944]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:57.944]                       inherits = FALSE)
[09:31:57.944]                   }
[09:31:57.944]                   options(future.plan = NULL)
[09:31:57.944]                   if (is.na(NA_character_)) 
[09:31:57.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:57.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:57.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:57.944]                     .init = FALSE)
[09:31:57.944]                 }
[09:31:57.944]             }
[09:31:57.944]         }
[09:31:57.944]     })
[09:31:57.944]     if (TRUE) {
[09:31:57.944]         base::sink(type = "output", split = FALSE)
[09:31:57.944]         if (TRUE) {
[09:31:57.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:57.944]         }
[09:31:57.944]         else {
[09:31:57.944]             ...future.result["stdout"] <- base::list(NULL)
[09:31:57.944]         }
[09:31:57.944]         base::close(...future.stdout)
[09:31:57.944]         ...future.stdout <- NULL
[09:31:57.944]     }
[09:31:57.944]     ...future.result$conditions <- ...future.conditions
[09:31:57.944]     ...future.result$finished <- base::Sys.time()
[09:31:57.944]     ...future.result
[09:31:57.944] }
[09:31:57.970]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.946] assign_globals() ...
[09:31:57.970]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.946] List of 1
[09:31:57.946]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:57.946]   ..$ a: int [1:3] 1 2 3
[09:31:57.946]   ..$ b: int [1:3] 3 2 1
[09:31:57.946]  - attr(*, "where")=List of 1
[09:31:57.946]   ..$ data:<environment: R_EmptyEnv> 
[09:31:57.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:57.946]  - attr(*, "resolved")= logi FALSE
[09:31:57.946]  - attr(*, "total_size")= num 128
[09:31:57.946]  - attr(*, "already-done")= logi TRUE
[09:31:57.970]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.951] - copied ‘data’ to environment
[09:31:57.970]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.951] assign_globals() ... done
[09:31:57.971]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.951] plan(): Setting new future strategy stack:
[09:31:57.971]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.951] List of future strategies:
[09:31:57.951] 1. sequential:
[09:31:57.951]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.951]    - tweaked: FALSE
[09:31:57.951]    - call: NULL
[09:31:57.971]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.952] plan(): nbrOfWorkers() = 1
[09:31:57.971]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.953] plan(): Setting new future strategy stack:
[09:31:57.971]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.953] List of future strategies:
[09:31:57.953] 1. sequential:
[09:31:57.953]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:57.953]    - tweaked: FALSE
[09:31:57.953]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.971]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.954] plan(): nbrOfWorkers() = 1
[09:31:57.971]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.954] SequentialFuture started (and completed)
[09:31:57.972]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.954] - Launch lazy future ... done
[09:31:57.972]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:57.955] run() for ‘SequentialFuture’ ... done
[09:31:57.972] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[09:31:57.972] plan(): Setting new future strategy stack:
[09:31:57.972] List of future strategies:
[09:31:57.972] 1. multicore:
[09:31:57.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:57.972]    - tweaked: FALSE
[09:31:57.972]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.972] 2. multicore:
[09:31:57.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:57.972]    - tweaked: FALSE
[09:31:57.972]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:57.977] plan(): nbrOfWorkers() = 2
[09:31:57.978] getGlobalsAndPackages() ...
[09:31:57.978] Searching for globals...
[09:31:58.000] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:58.000] Searching for globals ... DONE
[09:31:58.000] Resolving globals: FALSE
[09:31:58.001] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[09:31:58.001] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:58.002] - globals: [2] ‘nested’, ‘strategy2’
[09:31:58.002] - packages: [1] ‘future’
[09:31:58.002] getGlobalsAndPackages() ... DONE
[09:31:58.002] run() for ‘Future’ ...
[09:31:58.002] - state: ‘created’
[09:31:58.002] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.006] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:58.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:58.006]   - Field: ‘label’
[09:31:58.007]   - Field: ‘local’
[09:31:58.007]   - Field: ‘owner’
[09:31:58.007]   - Field: ‘envir’
[09:31:58.007]   - Field: ‘workers’
[09:31:58.007]   - Field: ‘packages’
[09:31:58.007]   - Field: ‘gc’
[09:31:58.007]   - Field: ‘job’
[09:31:58.008]   - Field: ‘conditions’
[09:31:58.008]   - Field: ‘expr’
[09:31:58.008]   - Field: ‘uuid’
[09:31:58.008]   - Field: ‘seed’
[09:31:58.008]   - Field: ‘version’
[09:31:58.008]   - Field: ‘result’
[09:31:58.008]   - Field: ‘asynchronous’
[09:31:58.008]   - Field: ‘calls’
[09:31:58.009]   - Field: ‘globals’
[09:31:58.009]   - Field: ‘stdout’
[09:31:58.009]   - Field: ‘earlySignal’
[09:31:58.009]   - Field: ‘lazy’
[09:31:58.009]   - Field: ‘state’
[09:31:58.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:58.009] - Launch lazy future ...
[09:31:58.009] Packages needed by the future expression (n = 1): ‘future’
[09:31:58.010] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.010] {
[09:31:58.010]     {
[09:31:58.010]         {
[09:31:58.010]             ...future.startTime <- base::Sys.time()
[09:31:58.010]             {
[09:31:58.010]                 {
[09:31:58.010]                   {
[09:31:58.010]                     {
[09:31:58.010]                       {
[09:31:58.010]                         base::local({
[09:31:58.010]                           has_future <- base::requireNamespace("future", 
[09:31:58.010]                             quietly = TRUE)
[09:31:58.010]                           if (has_future) {
[09:31:58.010]                             ns <- base::getNamespace("future")
[09:31:58.010]                             version <- ns[[".package"]][["version"]]
[09:31:58.010]                             if (is.null(version)) 
[09:31:58.010]                               version <- utils::packageVersion("future")
[09:31:58.010]                           }
[09:31:58.010]                           else {
[09:31:58.010]                             version <- NULL
[09:31:58.010]                           }
[09:31:58.010]                           if (!has_future || version < "1.8.0") {
[09:31:58.010]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.010]                               "", base::R.version$version.string), 
[09:31:58.010]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.010]                                 base::R.version$platform, 8 * 
[09:31:58.010]                                   base::.Machine$sizeof.pointer), 
[09:31:58.010]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.010]                                 "release", "version")], collapse = " "), 
[09:31:58.010]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.010]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.010]                               info)
[09:31:58.010]                             info <- base::paste(info, collapse = "; ")
[09:31:58.010]                             if (!has_future) {
[09:31:58.010]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.010]                                 info)
[09:31:58.010]                             }
[09:31:58.010]                             else {
[09:31:58.010]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.010]                                 info, version)
[09:31:58.010]                             }
[09:31:58.010]                             base::stop(msg)
[09:31:58.010]                           }
[09:31:58.010]                         })
[09:31:58.010]                       }
[09:31:58.010]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.010]                       base::options(mc.cores = 1L)
[09:31:58.010]                     }
[09:31:58.010]                     base::local({
[09:31:58.010]                       for (pkg in "future") {
[09:31:58.010]                         base::loadNamespace(pkg)
[09:31:58.010]                         base::library(pkg, character.only = TRUE)
[09:31:58.010]                       }
[09:31:58.010]                     })
[09:31:58.010]                   }
[09:31:58.010]                   ...future.strategy.old <- future::plan("list")
[09:31:58.010]                   options(future.plan = NULL)
[09:31:58.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.010]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:58.010]                     envir = parent.frame()) 
[09:31:58.010]                   {
[09:31:58.010]                     default_workers <- missing(workers)
[09:31:58.010]                     if (is.function(workers)) 
[09:31:58.010]                       workers <- workers()
[09:31:58.010]                     workers <- structure(as.integer(workers), 
[09:31:58.010]                       class = class(workers))
[09:31:58.010]                     stop_if_not(is.finite(workers), workers >= 
[09:31:58.010]                       1L)
[09:31:58.010]                     if ((workers == 1L && !inherits(workers, 
[09:31:58.010]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:58.010]                       if (default_workers) 
[09:31:58.010]                         supportsMulticore(warn = TRUE)
[09:31:58.010]                       return(sequential(..., envir = envir))
[09:31:58.010]                     }
[09:31:58.010]                     oopts <- options(mc.cores = workers)
[09:31:58.010]                     on.exit(options(oopts))
[09:31:58.010]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:58.010]                       envir = envir)
[09:31:58.010]                     if (!future$lazy) 
[09:31:58.010]                       future <- run(future)
[09:31:58.010]                     invisible(future)
[09:31:58.010]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.010]                 }
[09:31:58.010]                 ...future.workdir <- getwd()
[09:31:58.010]             }
[09:31:58.010]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.010]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.010]         }
[09:31:58.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.010]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.010]             base::names(...future.oldOptions))
[09:31:58.010]     }
[09:31:58.010]     if (FALSE) {
[09:31:58.010]     }
[09:31:58.010]     else {
[09:31:58.010]         if (TRUE) {
[09:31:58.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.010]                 open = "w")
[09:31:58.010]         }
[09:31:58.010]         else {
[09:31:58.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.010]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.010]         }
[09:31:58.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.010]             base::sink(type = "output", split = FALSE)
[09:31:58.010]             base::close(...future.stdout)
[09:31:58.010]         }, add = TRUE)
[09:31:58.010]     }
[09:31:58.010]     ...future.frame <- base::sys.nframe()
[09:31:58.010]     ...future.conditions <- base::list()
[09:31:58.010]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.010]     if (FALSE) {
[09:31:58.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.010]     }
[09:31:58.010]     ...future.result <- base::tryCatch({
[09:31:58.010]         base::withCallingHandlers({
[09:31:58.010]             ...future.value <- base::withVisible(base::local({
[09:31:58.010]                 withCallingHandlers({
[09:31:58.010]                   {
[09:31:58.010]                     a <- 1L
[09:31:58.010]                     plan_a <- unclass(future::plan("list"))
[09:31:58.010]                     nested_a <- nested[-1]
[09:31:58.010]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:58.010]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:58.010]                       strategy2))
[09:31:58.010]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:58.010]                       "init") <- NULL
[09:31:58.010]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:58.010]                       "init") <- NULL
[09:31:58.010]                     stopifnot(all.equal(plan_a, nested_a))
[09:31:58.010]                     y %<-% {
[09:31:58.010]                       b <- 2L
[09:31:58.010]                       plan_b <- future::plan("list")
[09:31:58.010]                       nested_b <- nested_a[-1]
[09:31:58.010]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:58.010]                         1L, inherits(plan_b[[1]], "future"), 
[09:31:58.010]                         inherits(future::plan("next"), "sequential"))
[09:31:58.010]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:58.010]                         b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:58.010]                     }
[09:31:58.010]                     y
[09:31:58.010]                   }
[09:31:58.010]                 }, immediateCondition = function(cond) {
[09:31:58.010]                   save_rds <- function (object, pathname, ...) 
[09:31:58.010]                   {
[09:31:58.010]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:58.010]                     if (file_test("-f", pathname_tmp)) {
[09:31:58.010]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.010]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:58.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.010]                         fi_tmp[["mtime"]])
[09:31:58.010]                     }
[09:31:58.010]                     tryCatch({
[09:31:58.010]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:58.010]                     }, error = function(ex) {
[09:31:58.010]                       msg <- conditionMessage(ex)
[09:31:58.010]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.010]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:58.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.010]                         fi_tmp[["mtime"]], msg)
[09:31:58.010]                       ex$message <- msg
[09:31:58.010]                       stop(ex)
[09:31:58.010]                     })
[09:31:58.010]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:58.010]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:58.010]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:58.010]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.010]                       fi <- file.info(pathname)
[09:31:58.010]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:58.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.010]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:58.010]                         fi[["size"]], fi[["mtime"]])
[09:31:58.010]                       stop(msg)
[09:31:58.010]                     }
[09:31:58.010]                     invisible(pathname)
[09:31:58.010]                   }
[09:31:58.010]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:58.010]                     rootPath = tempdir()) 
[09:31:58.010]                   {
[09:31:58.010]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:58.010]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:58.010]                       tmpdir = path, fileext = ".rds")
[09:31:58.010]                     save_rds(obj, file)
[09:31:58.010]                   }
[09:31:58.010]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:58.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.010]                   {
[09:31:58.010]                     inherits <- base::inherits
[09:31:58.010]                     invokeRestart <- base::invokeRestart
[09:31:58.010]                     is.null <- base::is.null
[09:31:58.010]                     muffled <- FALSE
[09:31:58.010]                     if (inherits(cond, "message")) {
[09:31:58.010]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.010]                       if (muffled) 
[09:31:58.010]                         invokeRestart("muffleMessage")
[09:31:58.010]                     }
[09:31:58.010]                     else if (inherits(cond, "warning")) {
[09:31:58.010]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.010]                       if (muffled) 
[09:31:58.010]                         invokeRestart("muffleWarning")
[09:31:58.010]                     }
[09:31:58.010]                     else if (inherits(cond, "condition")) {
[09:31:58.010]                       if (!is.null(pattern)) {
[09:31:58.010]                         computeRestarts <- base::computeRestarts
[09:31:58.010]                         grepl <- base::grepl
[09:31:58.010]                         restarts <- computeRestarts(cond)
[09:31:58.010]                         for (restart in restarts) {
[09:31:58.010]                           name <- restart$name
[09:31:58.010]                           if (is.null(name)) 
[09:31:58.010]                             next
[09:31:58.010]                           if (!grepl(pattern, name)) 
[09:31:58.010]                             next
[09:31:58.010]                           invokeRestart(restart)
[09:31:58.010]                           muffled <- TRUE
[09:31:58.010]                           break
[09:31:58.010]                         }
[09:31:58.010]                       }
[09:31:58.010]                     }
[09:31:58.010]                     invisible(muffled)
[09:31:58.010]                   }
[09:31:58.010]                   muffleCondition(cond)
[09:31:58.010]                 })
[09:31:58.010]             }))
[09:31:58.010]             future::FutureResult(value = ...future.value$value, 
[09:31:58.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.010]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.010]                     ...future.globalenv.names))
[09:31:58.010]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.010]         }, condition = base::local({
[09:31:58.010]             c <- base::c
[09:31:58.010]             inherits <- base::inherits
[09:31:58.010]             invokeRestart <- base::invokeRestart
[09:31:58.010]             length <- base::length
[09:31:58.010]             list <- base::list
[09:31:58.010]             seq.int <- base::seq.int
[09:31:58.010]             signalCondition <- base::signalCondition
[09:31:58.010]             sys.calls <- base::sys.calls
[09:31:58.010]             `[[` <- base::`[[`
[09:31:58.010]             `+` <- base::`+`
[09:31:58.010]             `<<-` <- base::`<<-`
[09:31:58.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.010]                   3L)]
[09:31:58.010]             }
[09:31:58.010]             function(cond) {
[09:31:58.010]                 is_error <- inherits(cond, "error")
[09:31:58.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.010]                   NULL)
[09:31:58.010]                 if (is_error) {
[09:31:58.010]                   sessionInformation <- function() {
[09:31:58.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.010]                       search = base::search(), system = base::Sys.info())
[09:31:58.010]                   }
[09:31:58.010]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.010]                     cond$call), session = sessionInformation(), 
[09:31:58.010]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.010]                   signalCondition(cond)
[09:31:58.010]                 }
[09:31:58.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.010]                 "immediateCondition"))) {
[09:31:58.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.010]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.010]                   if (TRUE && !signal) {
[09:31:58.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.010]                     {
[09:31:58.010]                       inherits <- base::inherits
[09:31:58.010]                       invokeRestart <- base::invokeRestart
[09:31:58.010]                       is.null <- base::is.null
[09:31:58.010]                       muffled <- FALSE
[09:31:58.010]                       if (inherits(cond, "message")) {
[09:31:58.010]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.010]                         if (muffled) 
[09:31:58.010]                           invokeRestart("muffleMessage")
[09:31:58.010]                       }
[09:31:58.010]                       else if (inherits(cond, "warning")) {
[09:31:58.010]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.010]                         if (muffled) 
[09:31:58.010]                           invokeRestart("muffleWarning")
[09:31:58.010]                       }
[09:31:58.010]                       else if (inherits(cond, "condition")) {
[09:31:58.010]                         if (!is.null(pattern)) {
[09:31:58.010]                           computeRestarts <- base::computeRestarts
[09:31:58.010]                           grepl <- base::grepl
[09:31:58.010]                           restarts <- computeRestarts(cond)
[09:31:58.010]                           for (restart in restarts) {
[09:31:58.010]                             name <- restart$name
[09:31:58.010]                             if (is.null(name)) 
[09:31:58.010]                               next
[09:31:58.010]                             if (!grepl(pattern, name)) 
[09:31:58.010]                               next
[09:31:58.010]                             invokeRestart(restart)
[09:31:58.010]                             muffled <- TRUE
[09:31:58.010]                             break
[09:31:58.010]                           }
[09:31:58.010]                         }
[09:31:58.010]                       }
[09:31:58.010]                       invisible(muffled)
[09:31:58.010]                     }
[09:31:58.010]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.010]                   }
[09:31:58.010]                 }
[09:31:58.010]                 else {
[09:31:58.010]                   if (TRUE) {
[09:31:58.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.010]                     {
[09:31:58.010]                       inherits <- base::inherits
[09:31:58.010]                       invokeRestart <- base::invokeRestart
[09:31:58.010]                       is.null <- base::is.null
[09:31:58.010]                       muffled <- FALSE
[09:31:58.010]                       if (inherits(cond, "message")) {
[09:31:58.010]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.010]                         if (muffled) 
[09:31:58.010]                           invokeRestart("muffleMessage")
[09:31:58.010]                       }
[09:31:58.010]                       else if (inherits(cond, "warning")) {
[09:31:58.010]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.010]                         if (muffled) 
[09:31:58.010]                           invokeRestart("muffleWarning")
[09:31:58.010]                       }
[09:31:58.010]                       else if (inherits(cond, "condition")) {
[09:31:58.010]                         if (!is.null(pattern)) {
[09:31:58.010]                           computeRestarts <- base::computeRestarts
[09:31:58.010]                           grepl <- base::grepl
[09:31:58.010]                           restarts <- computeRestarts(cond)
[09:31:58.010]                           for (restart in restarts) {
[09:31:58.010]                             name <- restart$name
[09:31:58.010]                             if (is.null(name)) 
[09:31:58.010]                               next
[09:31:58.010]                             if (!grepl(pattern, name)) 
[09:31:58.010]                               next
[09:31:58.010]                             invokeRestart(restart)
[09:31:58.010]                             muffled <- TRUE
[09:31:58.010]                             break
[09:31:58.010]                           }
[09:31:58.010]                         }
[09:31:58.010]                       }
[09:31:58.010]                       invisible(muffled)
[09:31:58.010]                     }
[09:31:58.010]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.010]                   }
[09:31:58.010]                 }
[09:31:58.010]             }
[09:31:58.010]         }))
[09:31:58.010]     }, error = function(ex) {
[09:31:58.010]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.010]                 ...future.rng), started = ...future.startTime, 
[09:31:58.010]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.010]             version = "1.8"), class = "FutureResult")
[09:31:58.010]     }, finally = {
[09:31:58.010]         if (!identical(...future.workdir, getwd())) 
[09:31:58.010]             setwd(...future.workdir)
[09:31:58.010]         {
[09:31:58.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.010]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.010]             }
[09:31:58.010]             base::options(...future.oldOptions)
[09:31:58.010]             if (.Platform$OS.type == "windows") {
[09:31:58.010]                 old_names <- names(...future.oldEnvVars)
[09:31:58.010]                 envs <- base::Sys.getenv()
[09:31:58.010]                 names <- names(envs)
[09:31:58.010]                 common <- intersect(names, old_names)
[09:31:58.010]                 added <- setdiff(names, old_names)
[09:31:58.010]                 removed <- setdiff(old_names, names)
[09:31:58.010]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.010]                   envs[common]]
[09:31:58.010]                 NAMES <- toupper(changed)
[09:31:58.010]                 args <- list()
[09:31:58.010]                 for (kk in seq_along(NAMES)) {
[09:31:58.010]                   name <- changed[[kk]]
[09:31:58.010]                   NAME <- NAMES[[kk]]
[09:31:58.010]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.010]                     next
[09:31:58.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.010]                 }
[09:31:58.010]                 NAMES <- toupper(added)
[09:31:58.010]                 for (kk in seq_along(NAMES)) {
[09:31:58.010]                   name <- added[[kk]]
[09:31:58.010]                   NAME <- NAMES[[kk]]
[09:31:58.010]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.010]                     next
[09:31:58.010]                   args[[name]] <- ""
[09:31:58.010]                 }
[09:31:58.010]                 NAMES <- toupper(removed)
[09:31:58.010]                 for (kk in seq_along(NAMES)) {
[09:31:58.010]                   name <- removed[[kk]]
[09:31:58.010]                   NAME <- NAMES[[kk]]
[09:31:58.010]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.010]                     next
[09:31:58.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.010]                 }
[09:31:58.010]                 if (length(args) > 0) 
[09:31:58.010]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.010]             }
[09:31:58.010]             else {
[09:31:58.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.010]             }
[09:31:58.010]             {
[09:31:58.010]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.010]                   0L) {
[09:31:58.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.010]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.010]                   base::options(opts)
[09:31:58.010]                 }
[09:31:58.010]                 {
[09:31:58.010]                   {
[09:31:58.010]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.010]                     NULL
[09:31:58.010]                   }
[09:31:58.010]                   options(future.plan = NULL)
[09:31:58.010]                   if (is.na(NA_character_)) 
[09:31:58.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.010]                     .init = FALSE)
[09:31:58.010]                 }
[09:31:58.010]             }
[09:31:58.010]         }
[09:31:58.010]     })
[09:31:58.010]     if (TRUE) {
[09:31:58.010]         base::sink(type = "output", split = FALSE)
[09:31:58.010]         if (TRUE) {
[09:31:58.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.010]         }
[09:31:58.010]         else {
[09:31:58.010]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.010]         }
[09:31:58.010]         base::close(...future.stdout)
[09:31:58.010]         ...future.stdout <- NULL
[09:31:58.010]     }
[09:31:58.010]     ...future.result$conditions <- ...future.conditions
[09:31:58.010]     ...future.result$finished <- base::Sys.time()
[09:31:58.010]     ...future.result
[09:31:58.010] }
[09:31:58.013] assign_globals() ...
[09:31:58.013] List of 2
[09:31:58.013]  $ nested   :List of 2
[09:31:58.013]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:58.013]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:58.013]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.013]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:58.013]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:58.013]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.013]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:58.013]  $ strategy2: chr "multicore"
[09:31:58.013]  - attr(*, "where")=List of 2
[09:31:58.013]   ..$ nested   :<environment: R_EmptyEnv> 
[09:31:58.013]   ..$ strategy2:<environment: R_EmptyEnv> 
[09:31:58.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.013]  - attr(*, "resolved")= logi FALSE
[09:31:58.013]  - attr(*, "total_size")= num 95304
[09:31:58.013]  - attr(*, "already-done")= logi TRUE
[09:31:58.018] - copied ‘nested’ to environment
[09:31:58.019] - copied ‘strategy2’ to environment
[09:31:58.019] assign_globals() ... done
[09:31:58.019] requestCore(): workers = 2
[09:31:58.021] MulticoreFuture started
[09:31:58.021] - Launch lazy future ... done
[09:31:58.022] run() for ‘MulticoreFuture’ ... done
[09:31:58.022] result() for MulticoreFuture ...
[09:31:58.022] plan(): Setting new future strategy stack:
[09:31:58.023] List of future strategies:
[09:31:58.023] 1. multicore:
[09:31:58.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.023]    - tweaked: FALSE
[09:31:58.023]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.028] plan(): nbrOfWorkers() = 1
[09:31:58.074] plan(): Setting new future strategy stack:
[09:31:58.074] List of future strategies:
[09:31:58.074] 1. multicore:
[09:31:58.074]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.074]    - tweaked: FALSE
[09:31:58.074]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.074] 2. multicore:
[09:31:58.074]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.074]    - tweaked: FALSE
[09:31:58.074]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.079] plan(): nbrOfWorkers() = 2
[09:31:58.081] result() for MulticoreFuture ...
[09:31:58.081] result() for MulticoreFuture ... done
[09:31:58.081] signalConditions() ...
[09:31:58.082]  - include = ‘immediateCondition’
[09:31:58.082]  - exclude = 
[09:31:58.082]  - resignal = FALSE
[09:31:58.082]  - Number of conditions: 54
[09:31:58.083] signalConditions() ... done
[09:31:58.083] result() for MulticoreFuture ... done
[09:31:58.083] result() for MulticoreFuture ...
[09:31:58.083] result() for MulticoreFuture ... done
[09:31:58.083] signalConditions() ...
[09:31:58.084]  - include = ‘immediateCondition’
[09:31:58.084]  - exclude = 
[09:31:58.084]  - resignal = FALSE
[09:31:58.084]  - Number of conditions: 54
[09:31:58.085] signalConditions() ... done
[09:31:58.085] Future state: ‘finished’
[09:31:58.085] result() for MulticoreFuture ...
[09:31:58.085] result() for MulticoreFuture ... done
[09:31:58.085] signalConditions() ...
[09:31:58.086]  - include = ‘condition’
[09:31:58.086]  - exclude = ‘immediateCondition’
[09:31:58.086]  - resignal = TRUE
[09:31:58.086]  - Number of conditions: 54
[09:31:58.086]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.030] getGlobalsAndPackages() ...
[09:31:58.087]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.030] Searching for globals...
[09:31:58.087]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.038] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[09:31:58.087]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.039] Searching for globals ... DONE
[09:31:58.088]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.039] Resolving globals: FALSE
[09:31:58.088]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.040] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[09:31:58.088]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.041] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[09:31:58.088]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.041] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[09:31:58.089]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.041] 
[09:31:58.089]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.041] getGlobalsAndPackages() ... DONE
[09:31:58.089]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.042] run() for ‘Future’ ...
[09:31:58.090]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.042] - state: ‘created’
[09:31:58.090]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.042] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.090]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.046] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:58.090]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:58.091]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.047]   - Field: ‘label’
[09:31:58.091]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.047]   - Field: ‘local’
[09:31:58.091]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.047]   - Field: ‘owner’
[09:31:58.092]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.047]   - Field: ‘envir’
[09:31:58.092]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.048]   - Field: ‘packages’
[09:31:58.092]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.048]   - Field: ‘gc’
[09:31:58.093]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.048]   - Field: ‘conditions’
[09:31:58.093]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.048]   - Field: ‘expr’
[09:31:58.093]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.048]   - Field: ‘uuid’
[09:31:58.093]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.048]   - Field: ‘seed’
[09:31:58.094]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘version’
[09:31:58.094]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘result’
[09:31:58.094]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘asynchronous’
[09:31:58.094]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘calls’
[09:31:58.095]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘globals’
[09:31:58.095]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘stdout’
[09:31:58.095]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.049]   - Field: ‘earlySignal’
[09:31:58.095]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.050]   - Field: ‘lazy’
[09:31:58.096]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.050]   - Field: ‘state’
[09:31:58.096]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:58.096]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.050] - Launch lazy future ...
[09:31:58.096]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.050] Packages needed by the future expression (n = 0): <none>
[09:31:58.097]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.051] Packages needed by future strategies (n = 0): <none>
[09:31:58.097]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.051] {
[09:31:58.051]     {
[09:31:58.051]         {
[09:31:58.051]             ...future.startTime <- base::Sys.time()
[09:31:58.051]             {
[09:31:58.051]                 {
[09:31:58.051]                   {
[09:31:58.051]                     base::local({
[09:31:58.051]                       has_future <- base::requireNamespace("future", 
[09:31:58.051]                         quietly = TRUE)
[09:31:58.051]                       if (has_future) {
[09:31:58.051]                         ns <- base::getNamespace("future")
[09:31:58.051]                         version <- ns[[".package"]][["version"]]
[09:31:58.051]                         if (is.null(version)) 
[09:31:58.051]                           version <- utils::packageVersion("future")
[09:31:58.051]                       }
[09:31:58.051]                       else {
[09:31:58.051]                         version <- NULL
[09:31:58.051]                       }
[09:31:58.051]                       if (!has_future || version < "1.8.0") {
[09:31:58.051]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.051]                           "", base::R.version$version.string), 
[09:31:58.051]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:58.051]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:58.051]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.051]                             "release", "version")], collapse = " "), 
[09:31:58.051]                           hostname = base::Sys.info()[["nodename"]])
[09:31:58.051]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.051]                           info)
[09:31:58.051]                         info <- base::paste(info, collapse = "; ")
[09:31:58.051]                         if (!has_future) {
[09:31:58.051]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.051]                             info)
[09:31:58.051]                         }
[09:31:58.051]                         else {
[09:31:58.051]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.051]                             info, version)
[09:31:58.051]                         }
[09:31:58.051]                         base::stop(msg)
[09:31:58.051]                       }
[09:31:58.051]                     })
[09:31:58.051]                   }
[09:31:58.051]                   ...future.strategy.old <- future::plan("list")
[09:31:58.051]                   options(future.plan = NULL)
[09:31:58.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:58.051]                 }
[09:31:58.051]                 ...future.workdir <- getwd()
[09:31:58.051]             }
[09:31:58.051]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.051]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.051]         }
[09:31:58.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.051]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.051]             base::names(...future.oldOptions))
[09:31:58.051]     }
[09:31:58.051]     if (FALSE) {
[09:31:58.051]     }
[09:31:58.051]     else {
[09:31:58.051]         if (TRUE) {
[09:31:58.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.051]                 open = "w")
[09:31:58.051]         }
[09:31:58.051]         else {
[09:31:58.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.051]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.051]         }
[09:31:58.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.051]             base::sink(type = "output", split = FALSE)
[09:31:58.051]             base::close(...future.stdout)
[09:31:58.051]         }, add = TRUE)
[09:31:58.051]     }
[09:31:58.051]     ...future.frame <- base::sys.nframe()
[09:31:58.051]     ...future.conditions <- base::list()
[09:31:58.051]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.051]     if (FALSE) {
[09:31:58.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.051]     }
[09:31:58.051]     ...future.result <- base::tryCatch({
[09:31:58.051]         base::withCallingHandlers({
[09:31:58.051]             ...future.value <- base::withVisible(base::local({
[09:31:58.051]                 b <- 2L
[09:31:58.051]                 plan_b <- future::plan("list")
[09:31:58.051]                 nested_b <- nested_a[-1]
[09:31:58.051]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:58.051]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:58.051]                   "sequential"))
[09:31:58.051]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:58.051]                   b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:58.051]             }))
[09:31:58.051]             future::FutureResult(value = ...future.value$value, 
[09:31:58.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.051]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.051]                     ...future.globalenv.names))
[09:31:58.051]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.051]         }, condition = base::local({
[09:31:58.051]             c <- base::c
[09:31:58.051]             inherits <- base::inherits
[09:31:58.051]             invokeRestart <- base::invokeRestart
[09:31:58.051]             length <- base::length
[09:31:58.051]             list <- base::list
[09:31:58.051]             seq.int <- base::seq.int
[09:31:58.051]             signalCondition <- base::signalCondition
[09:31:58.051]             sys.calls <- base::sys.calls
[09:31:58.051]             `[[` <- base::`[[`
[09:31:58.051]             `+` <- base::`+`
[09:31:58.051]             `<<-` <- base::`<<-`
[09:31:58.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.051]                   3L)]
[09:31:58.051]             }
[09:31:58.051]             function(cond) {
[09:31:58.051]                 is_error <- inherits(cond, "error")
[09:31:58.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.051]                   NULL)
[09:31:58.051]                 if (is_error) {
[09:31:58.051]                   sessionInformation <- function() {
[09:31:58.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.051]                       search = base::search(), system = base::Sys.info())
[09:31:58.051]                   }
[09:31:58.051]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.051]                     cond$call), session = sessionInformation(), 
[09:31:58.051]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.051]                   signalCondition(cond)
[09:31:58.051]                 }
[09:31:58.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.051]                 "immediateCondition"))) {
[09:31:58.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.051]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.051]                   if (TRUE && !signal) {
[09:31:58.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.051]                     {
[09:31:58.051]                       inherits <- base::inherits
[09:31:58.051]                       invokeRestart <- base::invokeRestart
[09:31:58.051]                       is.null <- base::is.null
[09:31:58.051]                       muffled <- FALSE
[09:31:58.051]                       if (inherits(cond, "message")) {
[09:31:58.051]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.051]                         if (muffled) 
[09:31:58.051]                           invokeRestart("muffleMessage")
[09:31:58.051]                       }
[09:31:58.051]                       else if (inherits(cond, "warning")) {
[09:31:58.051]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.051]                         if (muffled) 
[09:31:58.051]                           invokeRestart("muffleWarning")
[09:31:58.051]                       }
[09:31:58.051]                       else if (inherits(cond, "condition")) {
[09:31:58.051]                         if (!is.null(pattern)) {
[09:31:58.051]                           computeRestarts <- base::computeRestarts
[09:31:58.051]                           grepl <- base::grepl
[09:31:58.051]                           restarts <- computeRestarts(cond)
[09:31:58.051]                           for (restart in restarts) {
[09:31:58.051]                             name <- restart$name
[09:31:58.051]                             if (is.null(name)) 
[09:31:58.051]                               next
[09:31:58.051]                             if (!grepl(pattern, name)) 
[09:31:58.051]                               next
[09:31:58.051]                             invokeRestart(restart)
[09:31:58.051]                             muffled <- TRUE
[09:31:58.051]                             break
[09:31:58.051]                           }
[09:31:58.051]                         }
[09:31:58.051]                       }
[09:31:58.051]                       invisible(muffled)
[09:31:58.051]                     }
[09:31:58.051]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.051]                   }
[09:31:58.051]                 }
[09:31:58.051]                 else {
[09:31:58.051]                   if (TRUE) {
[09:31:58.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.051]                     {
[09:31:58.051]                       inherits <- base::inherits
[09:31:58.051]                       invokeRestart <- base::invokeRestart
[09:31:58.051]                       is.null <- base::is.null
[09:31:58.051]                       muffled <- FALSE
[09:31:58.051]                       if (inherits(cond, "message")) {
[09:31:58.051]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.051]                         if (muffled) 
[09:31:58.051]                           invokeRestart("muffleMessage")
[09:31:58.051]                       }
[09:31:58.051]                       else if (inherits(cond, "warning")) {
[09:31:58.051]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.051]                         if (muffled) 
[09:31:58.051]                           invokeRestart("muffleWarning")
[09:31:58.051]                       }
[09:31:58.051]                       else if (inherits(cond, "condition")) {
[09:31:58.051]                         if (!is.null(pattern)) {
[09:31:58.051]                           computeRestarts <- base::computeRestarts
[09:31:58.051]                           grepl <- base::grepl
[09:31:58.051]                           restarts <- computeRestarts(cond)
[09:31:58.051]                           for (restart in restarts) {
[09:31:58.051]                             name <- restart$name
[09:31:58.051]                             if (is.null(name)) 
[09:31:58.051]                               next
[09:31:58.051]                             if (!grepl(pattern, name)) 
[09:31:58.051]                               next
[09:31:58.051]                             invokeRestart(restart)
[09:31:58.051]                             muffled <- TRUE
[09:31:58.051]                             break
[09:31:58.051]                           }
[09:31:58.051]                         }
[09:31:58.051]                       }
[09:31:58.051]                       invisible(muffled)
[09:31:58.051]                     }
[09:31:58.051]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.051]                   }
[09:31:58.051]                 }
[09:31:58.051]             }
[09:31:58.051]         }))
[09:31:58.051]     }, error = function(ex) {
[09:31:58.051]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.051]                 ...future.rng), started = ...future.startTime, 
[09:31:58.051]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.051]             version = "1.8"), class = "FutureResult")
[09:31:58.051]     }, finally = {
[09:31:58.051]         if (!identical(...future.workdir, getwd())) 
[09:31:58.051]             setwd(...future.workdir)
[09:31:58.051]         {
[09:31:58.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.051]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.051]             }
[09:31:58.051]             base::options(...future.oldOptions)
[09:31:58.051]             if (.Platform$OS.type == "windows") {
[09:31:58.051]                 old_names <- names(...future.oldEnvVars)
[09:31:58.051]                 envs <- base::Sys.getenv()
[09:31:58.051]                 names <- names(envs)
[09:31:58.051]                 common <- intersect(names, old_names)
[09:31:58.051]                 added <- setdiff(names, old_names)
[09:31:58.051]                 removed <- setdiff(old_names, names)
[09:31:58.051]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.051]                   envs[common]]
[09:31:58.051]                 NAMES <- toupper(changed)
[09:31:58.051]                 args <- list()
[09:31:58.051]                 for (kk in seq_along(NAMES)) {
[09:31:58.051]                   name <- changed[[kk]]
[09:31:58.051]                   NAME <- NAMES[[kk]]
[09:31:58.051]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.051]                     next
[09:31:58.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.051]                 }
[09:31:58.051]                 NAMES <- toupper(added)
[09:31:58.051]                 for (kk in seq_along(NAMES)) {
[09:31:58.051]                   name <- added[[kk]]
[09:31:58.051]                   NAME <- NAMES[[kk]]
[09:31:58.051]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.051]                     next
[09:31:58.051]                   args[[name]] <- ""
[09:31:58.051]                 }
[09:31:58.051]                 NAMES <- toupper(removed)
[09:31:58.051]                 for (kk in seq_along(NAMES)) {
[09:31:58.051]                   name <- removed[[kk]]
[09:31:58.051]                   NAME <- NAMES[[kk]]
[09:31:58.051]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.051]                     next
[09:31:58.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.051]                 }
[09:31:58.051]                 if (length(args) > 0) 
[09:31:58.051]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.051]             }
[09:31:58.051]             else {
[09:31:58.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.051]             }
[09:31:58.051]             {
[09:31:58.051]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.051]                   0L) {
[09:31:58.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.051]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.051]                   base::options(opts)
[09:31:58.051]                 }
[09:31:58.051]                 {
[09:31:58.051]                   {
[09:31:58.051]                     NULL
[09:31:58.051]                     RNGkind("Mersenne-Twister")
[09:31:58.051]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:58.051]                       inherits = FALSE)
[09:31:58.051]                   }
[09:31:58.051]                   options(future.plan = NULL)
[09:31:58.051]                   if (is.na(NA_character_)) 
[09:31:58.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.051]                     .init = FALSE)
[09:31:58.051]                 }
[09:31:58.051]             }
[09:31:58.051]         }
[09:31:58.051]     })
[09:31:58.051]     if (TRUE) {
[09:31:58.051]         base::sink(type = "output", split = FALSE)
[09:31:58.051]         if (TRUE) {
[09:31:58.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.051]         }
[09:31:58.051]         else {
[09:31:58.051]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.051]         }
[09:31:58.051]         base::close(...future.stdout)
[09:31:58.051]         ...future.stdout <- NULL
[09:31:58.051]     }
[09:31:58.051]     ...future.result$conditions <- ...future.conditions
[09:31:58.051]     ...future.result$finished <- base::Sys.time()
[09:31:58.051]     ...future.result
[09:31:58.051] }
[09:31:58.097]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.054] assign_globals() ...
[09:31:58.097]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.054] List of 3
[09:31:58.054]  $ nested_a:List of 1
[09:31:58.054]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:58.054]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:58.054]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.054]  $ a       : int 1
[09:31:58.054]  $ plan_a  :List of 1
[09:31:58.054]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:58.054]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:58.054]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.054]  - attr(*, "where")=List of 3
[09:31:58.054]   ..$ nested_a:<environment: R_EmptyEnv> 
[09:31:58.054]   ..$ a       :<environment: R_EmptyEnv> 
[09:31:58.054]   ..$ plan_a  :<environment: R_EmptyEnv> 
[09:31:58.054]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.054]  - attr(*, "resolved")= logi FALSE
[09:31:58.054]  - attr(*, "total_size")= num 95240
[09:31:58.054]  - attr(*, "already-done")= logi TRUE
[09:31:58.098]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.064] - copied ‘nested_a’ to environment
[09:31:58.098]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.064] - copied ‘a’ to environment
[09:31:58.098]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.065] - copied ‘plan_a’ to environment
[09:31:58.098]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.065] assign_globals() ... done
[09:31:58.098]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.065] plan(): Setting new future strategy stack:
[09:31:58.099]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.065] List of future strategies:
[09:31:58.065] 1. sequential:
[09:31:58.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:58.065]    - tweaked: FALSE
[09:31:58.065]    - call: NULL
[09:31:58.099]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.066] plan(): nbrOfWorkers() = 1
[09:31:58.099]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.067] plan(): Setting new future strategy stack:
[09:31:58.099]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.068] List of future strategies:
[09:31:58.068] 1. multicore:
[09:31:58.068]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.068]    - tweaked: FALSE
[09:31:58.068]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.100]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.072] plan(): nbrOfWorkers() = 1
[09:31:58.100]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.073] SequentialFuture started (and completed)
[09:31:58.100]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.073] - Launch lazy future ... done
[09:31:58.100]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.073] run() for ‘SequentialFuture’ ... done
[09:31:58.101] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:58.109] getGlobalsAndPackages() ...
[09:31:58.109] Searching for globals...
[09:31:58.111] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:58.111] Searching for globals ... DONE
[09:31:58.111] Resolving globals: FALSE
[09:31:58.112] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:58.112] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:58.112] - globals: [1] ‘data’
[09:31:58.113] - packages: [1] ‘future’
[09:31:58.113] getGlobalsAndPackages() ... DONE
[09:31:58.113] run() for ‘Future’ ...
[09:31:58.113] - state: ‘created’
[09:31:58.113] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.117] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:58.117] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:58.118]   - Field: ‘label’
[09:31:58.118]   - Field: ‘local’
[09:31:58.118]   - Field: ‘owner’
[09:31:58.118]   - Field: ‘envir’
[09:31:58.118]   - Field: ‘workers’
[09:31:58.118]   - Field: ‘packages’
[09:31:58.118]   - Field: ‘gc’
[09:31:58.118]   - Field: ‘job’
[09:31:58.118]   - Field: ‘conditions’
[09:31:58.119]   - Field: ‘expr’
[09:31:58.119]   - Field: ‘uuid’
[09:31:58.119]   - Field: ‘seed’
[09:31:58.119]   - Field: ‘version’
[09:31:58.119]   - Field: ‘result’
[09:31:58.119]   - Field: ‘asynchronous’
[09:31:58.119]   - Field: ‘calls’
[09:31:58.119]   - Field: ‘globals’
[09:31:58.119]   - Field: ‘stdout’
[09:31:58.119]   - Field: ‘earlySignal’
[09:31:58.120]   - Field: ‘lazy’
[09:31:58.120]   - Field: ‘state’
[09:31:58.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:58.120] - Launch lazy future ...
[09:31:58.120] Packages needed by the future expression (n = 1): ‘future’
[09:31:58.120] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.121] {
[09:31:58.121]     {
[09:31:58.121]         {
[09:31:58.121]             ...future.startTime <- base::Sys.time()
[09:31:58.121]             {
[09:31:58.121]                 {
[09:31:58.121]                   {
[09:31:58.121]                     {
[09:31:58.121]                       {
[09:31:58.121]                         base::local({
[09:31:58.121]                           has_future <- base::requireNamespace("future", 
[09:31:58.121]                             quietly = TRUE)
[09:31:58.121]                           if (has_future) {
[09:31:58.121]                             ns <- base::getNamespace("future")
[09:31:58.121]                             version <- ns[[".package"]][["version"]]
[09:31:58.121]                             if (is.null(version)) 
[09:31:58.121]                               version <- utils::packageVersion("future")
[09:31:58.121]                           }
[09:31:58.121]                           else {
[09:31:58.121]                             version <- NULL
[09:31:58.121]                           }
[09:31:58.121]                           if (!has_future || version < "1.8.0") {
[09:31:58.121]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.121]                               "", base::R.version$version.string), 
[09:31:58.121]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.121]                                 base::R.version$platform, 8 * 
[09:31:58.121]                                   base::.Machine$sizeof.pointer), 
[09:31:58.121]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.121]                                 "release", "version")], collapse = " "), 
[09:31:58.121]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.121]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.121]                               info)
[09:31:58.121]                             info <- base::paste(info, collapse = "; ")
[09:31:58.121]                             if (!has_future) {
[09:31:58.121]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.121]                                 info)
[09:31:58.121]                             }
[09:31:58.121]                             else {
[09:31:58.121]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.121]                                 info, version)
[09:31:58.121]                             }
[09:31:58.121]                             base::stop(msg)
[09:31:58.121]                           }
[09:31:58.121]                         })
[09:31:58.121]                       }
[09:31:58.121]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.121]                       base::options(mc.cores = 1L)
[09:31:58.121]                     }
[09:31:58.121]                     base::local({
[09:31:58.121]                       for (pkg in "future") {
[09:31:58.121]                         base::loadNamespace(pkg)
[09:31:58.121]                         base::library(pkg, character.only = TRUE)
[09:31:58.121]                       }
[09:31:58.121]                     })
[09:31:58.121]                   }
[09:31:58.121]                   ...future.strategy.old <- future::plan("list")
[09:31:58.121]                   options(future.plan = NULL)
[09:31:58.121]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.121]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:58.121]                     envir = parent.frame()) 
[09:31:58.121]                   {
[09:31:58.121]                     default_workers <- missing(workers)
[09:31:58.121]                     if (is.function(workers)) 
[09:31:58.121]                       workers <- workers()
[09:31:58.121]                     workers <- structure(as.integer(workers), 
[09:31:58.121]                       class = class(workers))
[09:31:58.121]                     stop_if_not(is.finite(workers), workers >= 
[09:31:58.121]                       1L)
[09:31:58.121]                     if ((workers == 1L && !inherits(workers, 
[09:31:58.121]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:58.121]                       if (default_workers) 
[09:31:58.121]                         supportsMulticore(warn = TRUE)
[09:31:58.121]                       return(sequential(..., envir = envir))
[09:31:58.121]                     }
[09:31:58.121]                     oopts <- options(mc.cores = workers)
[09:31:58.121]                     on.exit(options(oopts))
[09:31:58.121]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:58.121]                       envir = envir)
[09:31:58.121]                     if (!future$lazy) 
[09:31:58.121]                       future <- run(future)
[09:31:58.121]                     invisible(future)
[09:31:58.121]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.121]                 }
[09:31:58.121]                 ...future.workdir <- getwd()
[09:31:58.121]             }
[09:31:58.121]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.121]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.121]         }
[09:31:58.121]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.121]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.121]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.121]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.121]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.121]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.121]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.121]             base::names(...future.oldOptions))
[09:31:58.121]     }
[09:31:58.121]     if (FALSE) {
[09:31:58.121]     }
[09:31:58.121]     else {
[09:31:58.121]         if (TRUE) {
[09:31:58.121]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.121]                 open = "w")
[09:31:58.121]         }
[09:31:58.121]         else {
[09:31:58.121]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.121]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.121]         }
[09:31:58.121]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.121]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.121]             base::sink(type = "output", split = FALSE)
[09:31:58.121]             base::close(...future.stdout)
[09:31:58.121]         }, add = TRUE)
[09:31:58.121]     }
[09:31:58.121]     ...future.frame <- base::sys.nframe()
[09:31:58.121]     ...future.conditions <- base::list()
[09:31:58.121]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.121]     if (FALSE) {
[09:31:58.121]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.121]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.121]     }
[09:31:58.121]     ...future.result <- base::tryCatch({
[09:31:58.121]         base::withCallingHandlers({
[09:31:58.121]             ...future.value <- base::withVisible(base::local({
[09:31:58.121]                 withCallingHandlers({
[09:31:58.121]                   {
[09:31:58.121]                     value(future(subset(data, a == 2)))
[09:31:58.121]                   }
[09:31:58.121]                 }, immediateCondition = function(cond) {
[09:31:58.121]                   save_rds <- function (object, pathname, ...) 
[09:31:58.121]                   {
[09:31:58.121]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:58.121]                     if (file_test("-f", pathname_tmp)) {
[09:31:58.121]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.121]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:58.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.121]                         fi_tmp[["mtime"]])
[09:31:58.121]                     }
[09:31:58.121]                     tryCatch({
[09:31:58.121]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:58.121]                     }, error = function(ex) {
[09:31:58.121]                       msg <- conditionMessage(ex)
[09:31:58.121]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.121]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:58.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.121]                         fi_tmp[["mtime"]], msg)
[09:31:58.121]                       ex$message <- msg
[09:31:58.121]                       stop(ex)
[09:31:58.121]                     })
[09:31:58.121]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:58.121]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:58.121]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:58.121]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.121]                       fi <- file.info(pathname)
[09:31:58.121]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:58.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.121]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:58.121]                         fi[["size"]], fi[["mtime"]])
[09:31:58.121]                       stop(msg)
[09:31:58.121]                     }
[09:31:58.121]                     invisible(pathname)
[09:31:58.121]                   }
[09:31:58.121]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:58.121]                     rootPath = tempdir()) 
[09:31:58.121]                   {
[09:31:58.121]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:58.121]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:58.121]                       tmpdir = path, fileext = ".rds")
[09:31:58.121]                     save_rds(obj, file)
[09:31:58.121]                   }
[09:31:58.121]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:58.121]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.121]                   {
[09:31:58.121]                     inherits <- base::inherits
[09:31:58.121]                     invokeRestart <- base::invokeRestart
[09:31:58.121]                     is.null <- base::is.null
[09:31:58.121]                     muffled <- FALSE
[09:31:58.121]                     if (inherits(cond, "message")) {
[09:31:58.121]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.121]                       if (muffled) 
[09:31:58.121]                         invokeRestart("muffleMessage")
[09:31:58.121]                     }
[09:31:58.121]                     else if (inherits(cond, "warning")) {
[09:31:58.121]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.121]                       if (muffled) 
[09:31:58.121]                         invokeRestart("muffleWarning")
[09:31:58.121]                     }
[09:31:58.121]                     else if (inherits(cond, "condition")) {
[09:31:58.121]                       if (!is.null(pattern)) {
[09:31:58.121]                         computeRestarts <- base::computeRestarts
[09:31:58.121]                         grepl <- base::grepl
[09:31:58.121]                         restarts <- computeRestarts(cond)
[09:31:58.121]                         for (restart in restarts) {
[09:31:58.121]                           name <- restart$name
[09:31:58.121]                           if (is.null(name)) 
[09:31:58.121]                             next
[09:31:58.121]                           if (!grepl(pattern, name)) 
[09:31:58.121]                             next
[09:31:58.121]                           invokeRestart(restart)
[09:31:58.121]                           muffled <- TRUE
[09:31:58.121]                           break
[09:31:58.121]                         }
[09:31:58.121]                       }
[09:31:58.121]                     }
[09:31:58.121]                     invisible(muffled)
[09:31:58.121]                   }
[09:31:58.121]                   muffleCondition(cond)
[09:31:58.121]                 })
[09:31:58.121]             }))
[09:31:58.121]             future::FutureResult(value = ...future.value$value, 
[09:31:58.121]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.121]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.121]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.121]                     ...future.globalenv.names))
[09:31:58.121]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.121]         }, condition = base::local({
[09:31:58.121]             c <- base::c
[09:31:58.121]             inherits <- base::inherits
[09:31:58.121]             invokeRestart <- base::invokeRestart
[09:31:58.121]             length <- base::length
[09:31:58.121]             list <- base::list
[09:31:58.121]             seq.int <- base::seq.int
[09:31:58.121]             signalCondition <- base::signalCondition
[09:31:58.121]             sys.calls <- base::sys.calls
[09:31:58.121]             `[[` <- base::`[[`
[09:31:58.121]             `+` <- base::`+`
[09:31:58.121]             `<<-` <- base::`<<-`
[09:31:58.121]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.121]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.121]                   3L)]
[09:31:58.121]             }
[09:31:58.121]             function(cond) {
[09:31:58.121]                 is_error <- inherits(cond, "error")
[09:31:58.121]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.121]                   NULL)
[09:31:58.121]                 if (is_error) {
[09:31:58.121]                   sessionInformation <- function() {
[09:31:58.121]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.121]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.121]                       search = base::search(), system = base::Sys.info())
[09:31:58.121]                   }
[09:31:58.121]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.121]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.121]                     cond$call), session = sessionInformation(), 
[09:31:58.121]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.121]                   signalCondition(cond)
[09:31:58.121]                 }
[09:31:58.121]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.121]                 "immediateCondition"))) {
[09:31:58.121]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.121]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.121]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.121]                   if (TRUE && !signal) {
[09:31:58.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.121]                     {
[09:31:58.121]                       inherits <- base::inherits
[09:31:58.121]                       invokeRestart <- base::invokeRestart
[09:31:58.121]                       is.null <- base::is.null
[09:31:58.121]                       muffled <- FALSE
[09:31:58.121]                       if (inherits(cond, "message")) {
[09:31:58.121]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.121]                         if (muffled) 
[09:31:58.121]                           invokeRestart("muffleMessage")
[09:31:58.121]                       }
[09:31:58.121]                       else if (inherits(cond, "warning")) {
[09:31:58.121]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.121]                         if (muffled) 
[09:31:58.121]                           invokeRestart("muffleWarning")
[09:31:58.121]                       }
[09:31:58.121]                       else if (inherits(cond, "condition")) {
[09:31:58.121]                         if (!is.null(pattern)) {
[09:31:58.121]                           computeRestarts <- base::computeRestarts
[09:31:58.121]                           grepl <- base::grepl
[09:31:58.121]                           restarts <- computeRestarts(cond)
[09:31:58.121]                           for (restart in restarts) {
[09:31:58.121]                             name <- restart$name
[09:31:58.121]                             if (is.null(name)) 
[09:31:58.121]                               next
[09:31:58.121]                             if (!grepl(pattern, name)) 
[09:31:58.121]                               next
[09:31:58.121]                             invokeRestart(restart)
[09:31:58.121]                             muffled <- TRUE
[09:31:58.121]                             break
[09:31:58.121]                           }
[09:31:58.121]                         }
[09:31:58.121]                       }
[09:31:58.121]                       invisible(muffled)
[09:31:58.121]                     }
[09:31:58.121]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.121]                   }
[09:31:58.121]                 }
[09:31:58.121]                 else {
[09:31:58.121]                   if (TRUE) {
[09:31:58.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.121]                     {
[09:31:58.121]                       inherits <- base::inherits
[09:31:58.121]                       invokeRestart <- base::invokeRestart
[09:31:58.121]                       is.null <- base::is.null
[09:31:58.121]                       muffled <- FALSE
[09:31:58.121]                       if (inherits(cond, "message")) {
[09:31:58.121]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.121]                         if (muffled) 
[09:31:58.121]                           invokeRestart("muffleMessage")
[09:31:58.121]                       }
[09:31:58.121]                       else if (inherits(cond, "warning")) {
[09:31:58.121]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.121]                         if (muffled) 
[09:31:58.121]                           invokeRestart("muffleWarning")
[09:31:58.121]                       }
[09:31:58.121]                       else if (inherits(cond, "condition")) {
[09:31:58.121]                         if (!is.null(pattern)) {
[09:31:58.121]                           computeRestarts <- base::computeRestarts
[09:31:58.121]                           grepl <- base::grepl
[09:31:58.121]                           restarts <- computeRestarts(cond)
[09:31:58.121]                           for (restart in restarts) {
[09:31:58.121]                             name <- restart$name
[09:31:58.121]                             if (is.null(name)) 
[09:31:58.121]                               next
[09:31:58.121]                             if (!grepl(pattern, name)) 
[09:31:58.121]                               next
[09:31:58.121]                             invokeRestart(restart)
[09:31:58.121]                             muffled <- TRUE
[09:31:58.121]                             break
[09:31:58.121]                           }
[09:31:58.121]                         }
[09:31:58.121]                       }
[09:31:58.121]                       invisible(muffled)
[09:31:58.121]                     }
[09:31:58.121]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.121]                   }
[09:31:58.121]                 }
[09:31:58.121]             }
[09:31:58.121]         }))
[09:31:58.121]     }, error = function(ex) {
[09:31:58.121]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.121]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.121]                 ...future.rng), started = ...future.startTime, 
[09:31:58.121]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.121]             version = "1.8"), class = "FutureResult")
[09:31:58.121]     }, finally = {
[09:31:58.121]         if (!identical(...future.workdir, getwd())) 
[09:31:58.121]             setwd(...future.workdir)
[09:31:58.121]         {
[09:31:58.121]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.121]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.121]             }
[09:31:58.121]             base::options(...future.oldOptions)
[09:31:58.121]             if (.Platform$OS.type == "windows") {
[09:31:58.121]                 old_names <- names(...future.oldEnvVars)
[09:31:58.121]                 envs <- base::Sys.getenv()
[09:31:58.121]                 names <- names(envs)
[09:31:58.121]                 common <- intersect(names, old_names)
[09:31:58.121]                 added <- setdiff(names, old_names)
[09:31:58.121]                 removed <- setdiff(old_names, names)
[09:31:58.121]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.121]                   envs[common]]
[09:31:58.121]                 NAMES <- toupper(changed)
[09:31:58.121]                 args <- list()
[09:31:58.121]                 for (kk in seq_along(NAMES)) {
[09:31:58.121]                   name <- changed[[kk]]
[09:31:58.121]                   NAME <- NAMES[[kk]]
[09:31:58.121]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.121]                     next
[09:31:58.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.121]                 }
[09:31:58.121]                 NAMES <- toupper(added)
[09:31:58.121]                 for (kk in seq_along(NAMES)) {
[09:31:58.121]                   name <- added[[kk]]
[09:31:58.121]                   NAME <- NAMES[[kk]]
[09:31:58.121]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.121]                     next
[09:31:58.121]                   args[[name]] <- ""
[09:31:58.121]                 }
[09:31:58.121]                 NAMES <- toupper(removed)
[09:31:58.121]                 for (kk in seq_along(NAMES)) {
[09:31:58.121]                   name <- removed[[kk]]
[09:31:58.121]                   NAME <- NAMES[[kk]]
[09:31:58.121]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.121]                     next
[09:31:58.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.121]                 }
[09:31:58.121]                 if (length(args) > 0) 
[09:31:58.121]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.121]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.121]             }
[09:31:58.121]             else {
[09:31:58.121]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.121]             }
[09:31:58.121]             {
[09:31:58.121]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.121]                   0L) {
[09:31:58.121]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.121]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.121]                   base::options(opts)
[09:31:58.121]                 }
[09:31:58.121]                 {
[09:31:58.121]                   {
[09:31:58.121]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.121]                     NULL
[09:31:58.121]                   }
[09:31:58.121]                   options(future.plan = NULL)
[09:31:58.121]                   if (is.na(NA_character_)) 
[09:31:58.121]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.121]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.121]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.121]                     .init = FALSE)
[09:31:58.121]                 }
[09:31:58.121]             }
[09:31:58.121]         }
[09:31:58.121]     })
[09:31:58.121]     if (TRUE) {
[09:31:58.121]         base::sink(type = "output", split = FALSE)
[09:31:58.121]         if (TRUE) {
[09:31:58.121]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.121]         }
[09:31:58.121]         else {
[09:31:58.121]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.121]         }
[09:31:58.121]         base::close(...future.stdout)
[09:31:58.121]         ...future.stdout <- NULL
[09:31:58.121]     }
[09:31:58.121]     ...future.result$conditions <- ...future.conditions
[09:31:58.121]     ...future.result$finished <- base::Sys.time()
[09:31:58.121]     ...future.result
[09:31:58.121] }
[09:31:58.124] assign_globals() ...
[09:31:58.124] List of 1
[09:31:58.124]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:58.124]   ..$ a: int [1:3] 1 2 3
[09:31:58.124]   ..$ b: int [1:3] 3 2 1
[09:31:58.124]  - attr(*, "where")=List of 1
[09:31:58.124]   ..$ data:<environment: R_EmptyEnv> 
[09:31:58.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.124]  - attr(*, "resolved")= logi FALSE
[09:31:58.124]  - attr(*, "total_size")= num 128
[09:31:58.124]  - attr(*, "already-done")= logi TRUE
[09:31:58.128] - copied ‘data’ to environment
[09:31:58.128] assign_globals() ... done
[09:31:58.128] requestCore(): workers = 2
[09:31:58.130] MulticoreFuture started
[09:31:58.131] - Launch lazy future ... done
[09:31:58.131] run() for ‘MulticoreFuture’ ... done
[09:31:58.131] result() for MulticoreFuture ...
[09:31:58.132] plan(): Setting new future strategy stack:
[09:31:58.132] List of future strategies:
[09:31:58.132] 1. multicore:
[09:31:58.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.132]    - tweaked: FALSE
[09:31:58.132]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.137] plan(): nbrOfWorkers() = 1
[09:31:58.173] plan(): Setting new future strategy stack:
[09:31:58.173] List of future strategies:
[09:31:58.173] 1. multicore:
[09:31:58.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.173]    - tweaked: FALSE
[09:31:58.173]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.173] 2. multicore:
[09:31:58.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.173]    - tweaked: FALSE
[09:31:58.173]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.177] plan(): nbrOfWorkers() = 2
[09:31:58.178] result() for MulticoreFuture ...
[09:31:58.178] result() for MulticoreFuture ... done
[09:31:58.178] signalConditions() ...
[09:31:58.179]  - include = ‘immediateCondition’
[09:31:58.179]  - exclude = 
[09:31:58.179]  - resignal = FALSE
[09:31:58.179]  - Number of conditions: 52
[09:31:58.179] signalConditions() ... done
[09:31:58.179] result() for MulticoreFuture ... done
[09:31:58.179] result() for MulticoreFuture ...
[09:31:58.179] result() for MulticoreFuture ... done
[09:31:58.180] signalConditions() ...
[09:31:58.180]  - include = ‘immediateCondition’
[09:31:58.180]  - exclude = 
[09:31:58.180]  - resignal = FALSE
[09:31:58.180]  - Number of conditions: 52
[09:31:58.180] signalConditions() ... done
[09:31:58.180] Future state: ‘finished’
[09:31:58.180] result() for MulticoreFuture ...
[09:31:58.181] result() for MulticoreFuture ... done
[09:31:58.181] signalConditions() ...
[09:31:58.181]  - include = ‘condition’
[09:31:58.181]  - exclude = ‘immediateCondition’
[09:31:58.181]  - resignal = TRUE
[09:31:58.181]  - Number of conditions: 52
[09:31:58.181]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.138] getGlobalsAndPackages() ...
[09:31:58.181]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.138] Searching for globals...
[09:31:58.181]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.140] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:58.182]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.140] Searching for globals ... DONE
[09:31:58.182]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.141] Resolving globals: FALSE
[09:31:58.182]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.142] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:58.182]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.142] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:58.182]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.142] - globals: [1] ‘data’
[09:31:58.182]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.142] 
[09:31:58.183]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.143] getGlobalsAndPackages() ... DONE
[09:31:58.183]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.143] run() for ‘Future’ ...
[09:31:58.183]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.144] - state: ‘created’
[09:31:58.183]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.183]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.148] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:58.183]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:58.183]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.148]   - Field: ‘label’
[09:31:58.184]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.148]   - Field: ‘local’
[09:31:58.184]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.148]   - Field: ‘owner’
[09:31:58.184]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘envir’
[09:31:58.184]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘packages’
[09:31:58.184]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘gc’
[09:31:58.184]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘conditions’
[09:31:58.185]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘expr’
[09:31:58.185]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘uuid’
[09:31:58.185]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.149]   - Field: ‘seed’
[09:31:58.185]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘version’
[09:31:58.185]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘result’
[09:31:58.185]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘asynchronous’
[09:31:58.185]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘calls’
[09:31:58.186]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘globals’
[09:31:58.186]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘stdout’
[09:31:58.186]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.150]   - Field: ‘earlySignal’
[09:31:58.186]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.151]   - Field: ‘lazy’
[09:31:58.186]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.151]   - Field: ‘state’
[09:31:58.186]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:58.187]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.151] - Launch lazy future ...
[09:31:58.187]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.151] Packages needed by the future expression (n = 0): <none>
[09:31:58.187]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.152] Packages needed by future strategies (n = 0): <none>
[09:31:58.187]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.152] {
[09:31:58.152]     {
[09:31:58.152]         {
[09:31:58.152]             ...future.startTime <- base::Sys.time()
[09:31:58.152]             {
[09:31:58.152]                 {
[09:31:58.152]                   {
[09:31:58.152]                     base::local({
[09:31:58.152]                       has_future <- base::requireNamespace("future", 
[09:31:58.152]                         quietly = TRUE)
[09:31:58.152]                       if (has_future) {
[09:31:58.152]                         ns <- base::getNamespace("future")
[09:31:58.152]                         version <- ns[[".package"]][["version"]]
[09:31:58.152]                         if (is.null(version)) 
[09:31:58.152]                           version <- utils::packageVersion("future")
[09:31:58.152]                       }
[09:31:58.152]                       else {
[09:31:58.152]                         version <- NULL
[09:31:58.152]                       }
[09:31:58.152]                       if (!has_future || version < "1.8.0") {
[09:31:58.152]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.152]                           "", base::R.version$version.string), 
[09:31:58.152]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:58.152]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:58.152]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.152]                             "release", "version")], collapse = " "), 
[09:31:58.152]                           hostname = base::Sys.info()[["nodename"]])
[09:31:58.152]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.152]                           info)
[09:31:58.152]                         info <- base::paste(info, collapse = "; ")
[09:31:58.152]                         if (!has_future) {
[09:31:58.152]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.152]                             info)
[09:31:58.152]                         }
[09:31:58.152]                         else {
[09:31:58.152]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.152]                             info, version)
[09:31:58.152]                         }
[09:31:58.152]                         base::stop(msg)
[09:31:58.152]                       }
[09:31:58.152]                     })
[09:31:58.152]                   }
[09:31:58.152]                   ...future.strategy.old <- future::plan("list")
[09:31:58.152]                   options(future.plan = NULL)
[09:31:58.152]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.152]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:58.152]                 }
[09:31:58.152]                 ...future.workdir <- getwd()
[09:31:58.152]             }
[09:31:58.152]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.152]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.152]         }
[09:31:58.152]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.152]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.152]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.152]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.152]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.152]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.152]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.152]             base::names(...future.oldOptions))
[09:31:58.152]     }
[09:31:58.152]     if (FALSE) {
[09:31:58.152]     }
[09:31:58.152]     else {
[09:31:58.152]         if (TRUE) {
[09:31:58.152]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.152]                 open = "w")
[09:31:58.152]         }
[09:31:58.152]         else {
[09:31:58.152]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.152]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.152]         }
[09:31:58.152]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.152]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.152]             base::sink(type = "output", split = FALSE)
[09:31:58.152]             base::close(...future.stdout)
[09:31:58.152]         }, add = TRUE)
[09:31:58.152]     }
[09:31:58.152]     ...future.frame <- base::sys.nframe()
[09:31:58.152]     ...future.conditions <- base::list()
[09:31:58.152]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.152]     if (FALSE) {
[09:31:58.152]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.152]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.152]     }
[09:31:58.152]     ...future.result <- base::tryCatch({
[09:31:58.152]         base::withCallingHandlers({
[09:31:58.152]             ...future.value <- base::withVisible(base::local(subset(data, 
[09:31:58.152]                 a == 2)))
[09:31:58.152]             future::FutureResult(value = ...future.value$value, 
[09:31:58.152]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.152]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.152]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.152]                     ...future.globalenv.names))
[09:31:58.152]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.152]         }, condition = base::local({
[09:31:58.152]             c <- base::c
[09:31:58.152]             inherits <- base::inherits
[09:31:58.152]             invokeRestart <- base::invokeRestart
[09:31:58.152]             length <- base::length
[09:31:58.152]             list <- base::list
[09:31:58.152]             seq.int <- base::seq.int
[09:31:58.152]             signalCondition <- base::signalCondition
[09:31:58.152]             sys.calls <- base::sys.calls
[09:31:58.152]             `[[` <- base::`[[`
[09:31:58.152]             `+` <- base::`+`
[09:31:58.152]             `<<-` <- base::`<<-`
[09:31:58.152]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.152]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.152]                   3L)]
[09:31:58.152]             }
[09:31:58.152]             function(cond) {
[09:31:58.152]                 is_error <- inherits(cond, "error")
[09:31:58.152]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.152]                   NULL)
[09:31:58.152]                 if (is_error) {
[09:31:58.152]                   sessionInformation <- function() {
[09:31:58.152]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.152]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.152]                       search = base::search(), system = base::Sys.info())
[09:31:58.152]                   }
[09:31:58.152]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.152]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.152]                     cond$call), session = sessionInformation(), 
[09:31:58.152]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.152]                   signalCondition(cond)
[09:31:58.152]                 }
[09:31:58.152]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.152]                 "immediateCondition"))) {
[09:31:58.152]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.152]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.152]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.152]                   if (TRUE && !signal) {
[09:31:58.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.152]                     {
[09:31:58.152]                       inherits <- base::inherits
[09:31:58.152]                       invokeRestart <- base::invokeRestart
[09:31:58.152]                       is.null <- base::is.null
[09:31:58.152]                       muffled <- FALSE
[09:31:58.152]                       if (inherits(cond, "message")) {
[09:31:58.152]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.152]                         if (muffled) 
[09:31:58.152]                           invokeRestart("muffleMessage")
[09:31:58.152]                       }
[09:31:58.152]                       else if (inherits(cond, "warning")) {
[09:31:58.152]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.152]                         if (muffled) 
[09:31:58.152]                           invokeRestart("muffleWarning")
[09:31:58.152]                       }
[09:31:58.152]                       else if (inherits(cond, "condition")) {
[09:31:58.152]                         if (!is.null(pattern)) {
[09:31:58.152]                           computeRestarts <- base::computeRestarts
[09:31:58.152]                           grepl <- base::grepl
[09:31:58.152]                           restarts <- computeRestarts(cond)
[09:31:58.152]                           for (restart in restarts) {
[09:31:58.152]                             name <- restart$name
[09:31:58.152]                             if (is.null(name)) 
[09:31:58.152]                               next
[09:31:58.152]                             if (!grepl(pattern, name)) 
[09:31:58.152]                               next
[09:31:58.152]                             invokeRestart(restart)
[09:31:58.152]                             muffled <- TRUE
[09:31:58.152]                             break
[09:31:58.152]                           }
[09:31:58.152]                         }
[09:31:58.152]                       }
[09:31:58.152]                       invisible(muffled)
[09:31:58.152]                     }
[09:31:58.152]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.152]                   }
[09:31:58.152]                 }
[09:31:58.152]                 else {
[09:31:58.152]                   if (TRUE) {
[09:31:58.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.152]                     {
[09:31:58.152]                       inherits <- base::inherits
[09:31:58.152]                       invokeRestart <- base::invokeRestart
[09:31:58.152]                       is.null <- base::is.null
[09:31:58.152]                       muffled <- FALSE
[09:31:58.152]                       if (inherits(cond, "message")) {
[09:31:58.152]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.152]                         if (muffled) 
[09:31:58.152]                           invokeRestart("muffleMessage")
[09:31:58.152]                       }
[09:31:58.152]                       else if (inherits(cond, "warning")) {
[09:31:58.152]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.152]                         if (muffled) 
[09:31:58.152]                           invokeRestart("muffleWarning")
[09:31:58.152]                       }
[09:31:58.152]                       else if (inherits(cond, "condition")) {
[09:31:58.152]                         if (!is.null(pattern)) {
[09:31:58.152]                           computeRestarts <- base::computeRestarts
[09:31:58.152]                           grepl <- base::grepl
[09:31:58.152]                           restarts <- computeRestarts(cond)
[09:31:58.152]                           for (restart in restarts) {
[09:31:58.152]                             name <- restart$name
[09:31:58.152]                             if (is.null(name)) 
[09:31:58.152]                               next
[09:31:58.152]                             if (!grepl(pattern, name)) 
[09:31:58.152]                               next
[09:31:58.152]                             invokeRestart(restart)
[09:31:58.152]                             muffled <- TRUE
[09:31:58.152]                             break
[09:31:58.152]                           }
[09:31:58.152]                         }
[09:31:58.152]                       }
[09:31:58.152]                       invisible(muffled)
[09:31:58.152]                     }
[09:31:58.152]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.152]                   }
[09:31:58.152]                 }
[09:31:58.152]             }
[09:31:58.152]         }))
[09:31:58.152]     }, error = function(ex) {
[09:31:58.152]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.152]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.152]                 ...future.rng), started = ...future.startTime, 
[09:31:58.152]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.152]             version = "1.8"), class = "FutureResult")
[09:31:58.152]     }, finally = {
[09:31:58.152]         if (!identical(...future.workdir, getwd())) 
[09:31:58.152]             setwd(...future.workdir)
[09:31:58.152]         {
[09:31:58.152]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.152]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.152]             }
[09:31:58.152]             base::options(...future.oldOptions)
[09:31:58.152]             if (.Platform$OS.type == "windows") {
[09:31:58.152]                 old_names <- names(...future.oldEnvVars)
[09:31:58.152]                 envs <- base::Sys.getenv()
[09:31:58.152]                 names <- names(envs)
[09:31:58.152]                 common <- intersect(names, old_names)
[09:31:58.152]                 added <- setdiff(names, old_names)
[09:31:58.152]                 removed <- setdiff(old_names, names)
[09:31:58.152]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.152]                   envs[common]]
[09:31:58.152]                 NAMES <- toupper(changed)
[09:31:58.152]                 args <- list()
[09:31:58.152]                 for (kk in seq_along(NAMES)) {
[09:31:58.152]                   name <- changed[[kk]]
[09:31:58.152]                   NAME <- NAMES[[kk]]
[09:31:58.152]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.152]                     next
[09:31:58.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.152]                 }
[09:31:58.152]                 NAMES <- toupper(added)
[09:31:58.152]                 for (kk in seq_along(NAMES)) {
[09:31:58.152]                   name <- added[[kk]]
[09:31:58.152]                   NAME <- NAMES[[kk]]
[09:31:58.152]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.152]                     next
[09:31:58.152]                   args[[name]] <- ""
[09:31:58.152]                 }
[09:31:58.152]                 NAMES <- toupper(removed)
[09:31:58.152]                 for (kk in seq_along(NAMES)) {
[09:31:58.152]                   name <- removed[[kk]]
[09:31:58.152]                   NAME <- NAMES[[kk]]
[09:31:58.152]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.152]                     next
[09:31:58.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.152]                 }
[09:31:58.152]                 if (length(args) > 0) 
[09:31:58.152]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.152]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.152]             }
[09:31:58.152]             else {
[09:31:58.152]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.152]             }
[09:31:58.152]             {
[09:31:58.152]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.152]                   0L) {
[09:31:58.152]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.152]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.152]                   base::options(opts)
[09:31:58.152]                 }
[09:31:58.152]                 {
[09:31:58.152]                   {
[09:31:58.152]                     NULL
[09:31:58.152]                     RNGkind("Mersenne-Twister")
[09:31:58.152]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:58.152]                       inherits = FALSE)
[09:31:58.152]                   }
[09:31:58.152]                   options(future.plan = NULL)
[09:31:58.152]                   if (is.na(NA_character_)) 
[09:31:58.152]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.152]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.152]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.152]                     .init = FALSE)
[09:31:58.152]                 }
[09:31:58.152]             }
[09:31:58.152]         }
[09:31:58.152]     })
[09:31:58.152]     if (TRUE) {
[09:31:58.152]         base::sink(type = "output", split = FALSE)
[09:31:58.152]         if (TRUE) {
[09:31:58.152]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.152]         }
[09:31:58.152]         else {
[09:31:58.152]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.152]         }
[09:31:58.152]         base::close(...future.stdout)
[09:31:58.152]         ...future.stdout <- NULL
[09:31:58.152]     }
[09:31:58.152]     ...future.result$conditions <- ...future.conditions
[09:31:58.152]     ...future.result$finished <- base::Sys.time()
[09:31:58.152]     ...future.result
[09:31:58.152] }
[09:31:58.187]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.154] assign_globals() ...
[09:31:58.187]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.155] List of 1
[09:31:58.155]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:58.155]   ..$ a: int [1:3] 1 2 3
[09:31:58.155]   ..$ b: int [1:3] 3 2 1
[09:31:58.155]  - attr(*, "where")=List of 1
[09:31:58.155]   ..$ data:<environment: R_EmptyEnv> 
[09:31:58.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.155]  - attr(*, "resolved")= logi FALSE
[09:31:58.155]  - attr(*, "total_size")= num 128
[09:31:58.155]  - attr(*, "already-done")= logi TRUE
[09:31:58.187]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.159] - copied ‘data’ to environment
[09:31:58.188]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.159] assign_globals() ... done
[09:31:58.188]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.159] plan(): Setting new future strategy stack:
[09:31:58.188]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.160] List of future strategies:
[09:31:58.160] 1. sequential:
[09:31:58.160]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:58.160]    - tweaked: FALSE
[09:31:58.160]    - call: NULL
[09:31:58.188]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.160] plan(): nbrOfWorkers() = 1
[09:31:58.188]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.161] plan(): Setting new future strategy stack:
[09:31:58.188]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.162] List of future strategies:
[09:31:58.162] 1. multicore:
[09:31:58.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.162]    - tweaked: FALSE
[09:31:58.162]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.188]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.165] plan(): nbrOfWorkers() = 1
[09:31:58.189]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.166] SequentialFuture started (and completed)
[09:31:58.189]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.166] - Launch lazy future ... done
[09:31:58.189]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.171] run() for ‘SequentialFuture’ ... done
[09:31:58.189] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[09:31:58.190] plan(): Setting new future strategy stack:
[09:31:58.190] List of future strategies:
[09:31:58.190] 1. multicore:
[09:31:58.190]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.190]    - tweaked: FALSE
[09:31:58.190]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.190] 2. multisession:
[09:31:58.190]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.190]    - tweaked: FALSE
[09:31:58.190]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.194] plan(): nbrOfWorkers() = 2
[09:31:58.194] getGlobalsAndPackages() ...
[09:31:58.195] Searching for globals...
[09:31:58.239] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:58.240] Searching for globals ... DONE
[09:31:58.240] Resolving globals: FALSE
[09:31:58.243] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[09:31:58.244] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:58.244] - globals: [2] ‘nested’, ‘strategy2’
[09:31:58.244] - packages: [1] ‘future’
[09:31:58.245] getGlobalsAndPackages() ... DONE
[09:31:58.245] run() for ‘Future’ ...
[09:31:58.245] - state: ‘created’
[09:31:58.246] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.252] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:58.252] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:58.252]   - Field: ‘label’
[09:31:58.252]   - Field: ‘local’
[09:31:58.252]   - Field: ‘owner’
[09:31:58.252]   - Field: ‘envir’
[09:31:58.252]   - Field: ‘workers’
[09:31:58.252]   - Field: ‘packages’
[09:31:58.253]   - Field: ‘gc’
[09:31:58.253]   - Field: ‘job’
[09:31:58.253]   - Field: ‘conditions’
[09:31:58.253]   - Field: ‘expr’
[09:31:58.253]   - Field: ‘uuid’
[09:31:58.253]   - Field: ‘seed’
[09:31:58.253]   - Field: ‘version’
[09:31:58.253]   - Field: ‘result’
[09:31:58.253]   - Field: ‘asynchronous’
[09:31:58.253]   - Field: ‘calls’
[09:31:58.254]   - Field: ‘globals’
[09:31:58.254]   - Field: ‘stdout’
[09:31:58.254]   - Field: ‘earlySignal’
[09:31:58.254]   - Field: ‘lazy’
[09:31:58.254]   - Field: ‘state’
[09:31:58.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:58.254] - Launch lazy future ...
[09:31:58.255] Packages needed by the future expression (n = 1): ‘future’
[09:31:58.255] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.255] {
[09:31:58.255]     {
[09:31:58.255]         {
[09:31:58.255]             ...future.startTime <- base::Sys.time()
[09:31:58.255]             {
[09:31:58.255]                 {
[09:31:58.255]                   {
[09:31:58.255]                     {
[09:31:58.255]                       {
[09:31:58.255]                         base::local({
[09:31:58.255]                           has_future <- base::requireNamespace("future", 
[09:31:58.255]                             quietly = TRUE)
[09:31:58.255]                           if (has_future) {
[09:31:58.255]                             ns <- base::getNamespace("future")
[09:31:58.255]                             version <- ns[[".package"]][["version"]]
[09:31:58.255]                             if (is.null(version)) 
[09:31:58.255]                               version <- utils::packageVersion("future")
[09:31:58.255]                           }
[09:31:58.255]                           else {
[09:31:58.255]                             version <- NULL
[09:31:58.255]                           }
[09:31:58.255]                           if (!has_future || version < "1.8.0") {
[09:31:58.255]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.255]                               "", base::R.version$version.string), 
[09:31:58.255]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.255]                                 base::R.version$platform, 8 * 
[09:31:58.255]                                   base::.Machine$sizeof.pointer), 
[09:31:58.255]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.255]                                 "release", "version")], collapse = " "), 
[09:31:58.255]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.255]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.255]                               info)
[09:31:58.255]                             info <- base::paste(info, collapse = "; ")
[09:31:58.255]                             if (!has_future) {
[09:31:58.255]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.255]                                 info)
[09:31:58.255]                             }
[09:31:58.255]                             else {
[09:31:58.255]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.255]                                 info, version)
[09:31:58.255]                             }
[09:31:58.255]                             base::stop(msg)
[09:31:58.255]                           }
[09:31:58.255]                         })
[09:31:58.255]                       }
[09:31:58.255]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.255]                       base::options(mc.cores = 1L)
[09:31:58.255]                     }
[09:31:58.255]                     base::local({
[09:31:58.255]                       for (pkg in "future") {
[09:31:58.255]                         base::loadNamespace(pkg)
[09:31:58.255]                         base::library(pkg, character.only = TRUE)
[09:31:58.255]                       }
[09:31:58.255]                     })
[09:31:58.255]                   }
[09:31:58.255]                   ...future.strategy.old <- future::plan("list")
[09:31:58.255]                   options(future.plan = NULL)
[09:31:58.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.255]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:31:58.255]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:58.255]                     envir = parent.frame()) 
[09:31:58.255]                   {
[09:31:58.255]                     if (is.function(workers)) 
[09:31:58.255]                       workers <- workers()
[09:31:58.255]                     workers <- structure(as.integer(workers), 
[09:31:58.255]                       class = class(workers))
[09:31:58.255]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:31:58.255]                       workers >= 1)
[09:31:58.255]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:31:58.255]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:31:58.255]                     }
[09:31:58.255]                     future <- MultisessionFuture(..., workers = workers, 
[09:31:58.255]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:31:58.255]                       envir = envir)
[09:31:58.255]                     if (!future$lazy) 
[09:31:58.255]                       future <- run(future)
[09:31:58.255]                     invisible(future)
[09:31:58.255]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.255]                 }
[09:31:58.255]                 ...future.workdir <- getwd()
[09:31:58.255]             }
[09:31:58.255]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.255]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.255]         }
[09:31:58.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.255]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.255]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.255]             base::names(...future.oldOptions))
[09:31:58.255]     }
[09:31:58.255]     if (FALSE) {
[09:31:58.255]     }
[09:31:58.255]     else {
[09:31:58.255]         if (TRUE) {
[09:31:58.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.255]                 open = "w")
[09:31:58.255]         }
[09:31:58.255]         else {
[09:31:58.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.255]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.255]         }
[09:31:58.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.255]             base::sink(type = "output", split = FALSE)
[09:31:58.255]             base::close(...future.stdout)
[09:31:58.255]         }, add = TRUE)
[09:31:58.255]     }
[09:31:58.255]     ...future.frame <- base::sys.nframe()
[09:31:58.255]     ...future.conditions <- base::list()
[09:31:58.255]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.255]     if (FALSE) {
[09:31:58.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.255]     }
[09:31:58.255]     ...future.result <- base::tryCatch({
[09:31:58.255]         base::withCallingHandlers({
[09:31:58.255]             ...future.value <- base::withVisible(base::local({
[09:31:58.255]                 withCallingHandlers({
[09:31:58.255]                   {
[09:31:58.255]                     a <- 1L
[09:31:58.255]                     plan_a <- unclass(future::plan("list"))
[09:31:58.255]                     nested_a <- nested[-1]
[09:31:58.255]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:58.255]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:58.255]                       strategy2))
[09:31:58.255]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:58.255]                       "init") <- NULL
[09:31:58.255]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:58.255]                       "init") <- NULL
[09:31:58.255]                     stopifnot(all.equal(plan_a, nested_a))
[09:31:58.255]                     y %<-% {
[09:31:58.255]                       b <- 2L
[09:31:58.255]                       plan_b <- future::plan("list")
[09:31:58.255]                       nested_b <- nested_a[-1]
[09:31:58.255]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:58.255]                         1L, inherits(plan_b[[1]], "future"), 
[09:31:58.255]                         inherits(future::plan("next"), "sequential"))
[09:31:58.255]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:58.255]                         b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:58.255]                     }
[09:31:58.255]                     y
[09:31:58.255]                   }
[09:31:58.255]                 }, immediateCondition = function(cond) {
[09:31:58.255]                   save_rds <- function (object, pathname, ...) 
[09:31:58.255]                   {
[09:31:58.255]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:58.255]                     if (file_test("-f", pathname_tmp)) {
[09:31:58.255]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.255]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:58.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.255]                         fi_tmp[["mtime"]])
[09:31:58.255]                     }
[09:31:58.255]                     tryCatch({
[09:31:58.255]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:58.255]                     }, error = function(ex) {
[09:31:58.255]                       msg <- conditionMessage(ex)
[09:31:58.255]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.255]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:58.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.255]                         fi_tmp[["mtime"]], msg)
[09:31:58.255]                       ex$message <- msg
[09:31:58.255]                       stop(ex)
[09:31:58.255]                     })
[09:31:58.255]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:58.255]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:58.255]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:58.255]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.255]                       fi <- file.info(pathname)
[09:31:58.255]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:58.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.255]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:58.255]                         fi[["size"]], fi[["mtime"]])
[09:31:58.255]                       stop(msg)
[09:31:58.255]                     }
[09:31:58.255]                     invisible(pathname)
[09:31:58.255]                   }
[09:31:58.255]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:58.255]                     rootPath = tempdir()) 
[09:31:58.255]                   {
[09:31:58.255]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:58.255]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:58.255]                       tmpdir = path, fileext = ".rds")
[09:31:58.255]                     save_rds(obj, file)
[09:31:58.255]                   }
[09:31:58.255]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:58.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.255]                   {
[09:31:58.255]                     inherits <- base::inherits
[09:31:58.255]                     invokeRestart <- base::invokeRestart
[09:31:58.255]                     is.null <- base::is.null
[09:31:58.255]                     muffled <- FALSE
[09:31:58.255]                     if (inherits(cond, "message")) {
[09:31:58.255]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.255]                       if (muffled) 
[09:31:58.255]                         invokeRestart("muffleMessage")
[09:31:58.255]                     }
[09:31:58.255]                     else if (inherits(cond, "warning")) {
[09:31:58.255]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.255]                       if (muffled) 
[09:31:58.255]                         invokeRestart("muffleWarning")
[09:31:58.255]                     }
[09:31:58.255]                     else if (inherits(cond, "condition")) {
[09:31:58.255]                       if (!is.null(pattern)) {
[09:31:58.255]                         computeRestarts <- base::computeRestarts
[09:31:58.255]                         grepl <- base::grepl
[09:31:58.255]                         restarts <- computeRestarts(cond)
[09:31:58.255]                         for (restart in restarts) {
[09:31:58.255]                           name <- restart$name
[09:31:58.255]                           if (is.null(name)) 
[09:31:58.255]                             next
[09:31:58.255]                           if (!grepl(pattern, name)) 
[09:31:58.255]                             next
[09:31:58.255]                           invokeRestart(restart)
[09:31:58.255]                           muffled <- TRUE
[09:31:58.255]                           break
[09:31:58.255]                         }
[09:31:58.255]                       }
[09:31:58.255]                     }
[09:31:58.255]                     invisible(muffled)
[09:31:58.255]                   }
[09:31:58.255]                   muffleCondition(cond)
[09:31:58.255]                 })
[09:31:58.255]             }))
[09:31:58.255]             future::FutureResult(value = ...future.value$value, 
[09:31:58.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.255]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.255]                     ...future.globalenv.names))
[09:31:58.255]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.255]         }, condition = base::local({
[09:31:58.255]             c <- base::c
[09:31:58.255]             inherits <- base::inherits
[09:31:58.255]             invokeRestart <- base::invokeRestart
[09:31:58.255]             length <- base::length
[09:31:58.255]             list <- base::list
[09:31:58.255]             seq.int <- base::seq.int
[09:31:58.255]             signalCondition <- base::signalCondition
[09:31:58.255]             sys.calls <- base::sys.calls
[09:31:58.255]             `[[` <- base::`[[`
[09:31:58.255]             `+` <- base::`+`
[09:31:58.255]             `<<-` <- base::`<<-`
[09:31:58.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.255]                   3L)]
[09:31:58.255]             }
[09:31:58.255]             function(cond) {
[09:31:58.255]                 is_error <- inherits(cond, "error")
[09:31:58.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.255]                   NULL)
[09:31:58.255]                 if (is_error) {
[09:31:58.255]                   sessionInformation <- function() {
[09:31:58.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.255]                       search = base::search(), system = base::Sys.info())
[09:31:58.255]                   }
[09:31:58.255]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.255]                     cond$call), session = sessionInformation(), 
[09:31:58.255]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.255]                   signalCondition(cond)
[09:31:58.255]                 }
[09:31:58.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.255]                 "immediateCondition"))) {
[09:31:58.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.255]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.255]                   if (TRUE && !signal) {
[09:31:58.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.255]                     {
[09:31:58.255]                       inherits <- base::inherits
[09:31:58.255]                       invokeRestart <- base::invokeRestart
[09:31:58.255]                       is.null <- base::is.null
[09:31:58.255]                       muffled <- FALSE
[09:31:58.255]                       if (inherits(cond, "message")) {
[09:31:58.255]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.255]                         if (muffled) 
[09:31:58.255]                           invokeRestart("muffleMessage")
[09:31:58.255]                       }
[09:31:58.255]                       else if (inherits(cond, "warning")) {
[09:31:58.255]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.255]                         if (muffled) 
[09:31:58.255]                           invokeRestart("muffleWarning")
[09:31:58.255]                       }
[09:31:58.255]                       else if (inherits(cond, "condition")) {
[09:31:58.255]                         if (!is.null(pattern)) {
[09:31:58.255]                           computeRestarts <- base::computeRestarts
[09:31:58.255]                           grepl <- base::grepl
[09:31:58.255]                           restarts <- computeRestarts(cond)
[09:31:58.255]                           for (restart in restarts) {
[09:31:58.255]                             name <- restart$name
[09:31:58.255]                             if (is.null(name)) 
[09:31:58.255]                               next
[09:31:58.255]                             if (!grepl(pattern, name)) 
[09:31:58.255]                               next
[09:31:58.255]                             invokeRestart(restart)
[09:31:58.255]                             muffled <- TRUE
[09:31:58.255]                             break
[09:31:58.255]                           }
[09:31:58.255]                         }
[09:31:58.255]                       }
[09:31:58.255]                       invisible(muffled)
[09:31:58.255]                     }
[09:31:58.255]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.255]                   }
[09:31:58.255]                 }
[09:31:58.255]                 else {
[09:31:58.255]                   if (TRUE) {
[09:31:58.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.255]                     {
[09:31:58.255]                       inherits <- base::inherits
[09:31:58.255]                       invokeRestart <- base::invokeRestart
[09:31:58.255]                       is.null <- base::is.null
[09:31:58.255]                       muffled <- FALSE
[09:31:58.255]                       if (inherits(cond, "message")) {
[09:31:58.255]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.255]                         if (muffled) 
[09:31:58.255]                           invokeRestart("muffleMessage")
[09:31:58.255]                       }
[09:31:58.255]                       else if (inherits(cond, "warning")) {
[09:31:58.255]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.255]                         if (muffled) 
[09:31:58.255]                           invokeRestart("muffleWarning")
[09:31:58.255]                       }
[09:31:58.255]                       else if (inherits(cond, "condition")) {
[09:31:58.255]                         if (!is.null(pattern)) {
[09:31:58.255]                           computeRestarts <- base::computeRestarts
[09:31:58.255]                           grepl <- base::grepl
[09:31:58.255]                           restarts <- computeRestarts(cond)
[09:31:58.255]                           for (restart in restarts) {
[09:31:58.255]                             name <- restart$name
[09:31:58.255]                             if (is.null(name)) 
[09:31:58.255]                               next
[09:31:58.255]                             if (!grepl(pattern, name)) 
[09:31:58.255]                               next
[09:31:58.255]                             invokeRestart(restart)
[09:31:58.255]                             muffled <- TRUE
[09:31:58.255]                             break
[09:31:58.255]                           }
[09:31:58.255]                         }
[09:31:58.255]                       }
[09:31:58.255]                       invisible(muffled)
[09:31:58.255]                     }
[09:31:58.255]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.255]                   }
[09:31:58.255]                 }
[09:31:58.255]             }
[09:31:58.255]         }))
[09:31:58.255]     }, error = function(ex) {
[09:31:58.255]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.255]                 ...future.rng), started = ...future.startTime, 
[09:31:58.255]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.255]             version = "1.8"), class = "FutureResult")
[09:31:58.255]     }, finally = {
[09:31:58.255]         if (!identical(...future.workdir, getwd())) 
[09:31:58.255]             setwd(...future.workdir)
[09:31:58.255]         {
[09:31:58.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.255]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.255]             }
[09:31:58.255]             base::options(...future.oldOptions)
[09:31:58.255]             if (.Platform$OS.type == "windows") {
[09:31:58.255]                 old_names <- names(...future.oldEnvVars)
[09:31:58.255]                 envs <- base::Sys.getenv()
[09:31:58.255]                 names <- names(envs)
[09:31:58.255]                 common <- intersect(names, old_names)
[09:31:58.255]                 added <- setdiff(names, old_names)
[09:31:58.255]                 removed <- setdiff(old_names, names)
[09:31:58.255]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.255]                   envs[common]]
[09:31:58.255]                 NAMES <- toupper(changed)
[09:31:58.255]                 args <- list()
[09:31:58.255]                 for (kk in seq_along(NAMES)) {
[09:31:58.255]                   name <- changed[[kk]]
[09:31:58.255]                   NAME <- NAMES[[kk]]
[09:31:58.255]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.255]                     next
[09:31:58.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.255]                 }
[09:31:58.255]                 NAMES <- toupper(added)
[09:31:58.255]                 for (kk in seq_along(NAMES)) {
[09:31:58.255]                   name <- added[[kk]]
[09:31:58.255]                   NAME <- NAMES[[kk]]
[09:31:58.255]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.255]                     next
[09:31:58.255]                   args[[name]] <- ""
[09:31:58.255]                 }
[09:31:58.255]                 NAMES <- toupper(removed)
[09:31:58.255]                 for (kk in seq_along(NAMES)) {
[09:31:58.255]                   name <- removed[[kk]]
[09:31:58.255]                   NAME <- NAMES[[kk]]
[09:31:58.255]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.255]                     next
[09:31:58.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.255]                 }
[09:31:58.255]                 if (length(args) > 0) 
[09:31:58.255]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.255]             }
[09:31:58.255]             else {
[09:31:58.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.255]             }
[09:31:58.255]             {
[09:31:58.255]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.255]                   0L) {
[09:31:58.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.255]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.255]                   base::options(opts)
[09:31:58.255]                 }
[09:31:58.255]                 {
[09:31:58.255]                   {
[09:31:58.255]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.255]                     NULL
[09:31:58.255]                   }
[09:31:58.255]                   options(future.plan = NULL)
[09:31:58.255]                   if (is.na(NA_character_)) 
[09:31:58.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.255]                     .init = FALSE)
[09:31:58.255]                 }
[09:31:58.255]             }
[09:31:58.255]         }
[09:31:58.255]     })
[09:31:58.255]     if (TRUE) {
[09:31:58.255]         base::sink(type = "output", split = FALSE)
[09:31:58.255]         if (TRUE) {
[09:31:58.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.255]         }
[09:31:58.255]         else {
[09:31:58.255]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.255]         }
[09:31:58.255]         base::close(...future.stdout)
[09:31:58.255]         ...future.stdout <- NULL
[09:31:58.255]     }
[09:31:58.255]     ...future.result$conditions <- ...future.conditions
[09:31:58.255]     ...future.result$finished <- base::Sys.time()
[09:31:58.255]     ...future.result
[09:31:58.255] }
[09:31:58.258] assign_globals() ...
[09:31:58.258] List of 2
[09:31:58.258]  $ nested   :List of 2
[09:31:58.258]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[09:31:58.258]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[09:31:58.258]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.258]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:58.258]     envir = parent.frame())  
[09:31:58.258]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[09:31:58.258]   .. ..- attr(*, "init")= logi TRUE
[09:31:58.258]   .. ..- attr(*, "untweakable")= chr "persistent"
[09:31:58.258]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.258]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:58.258]  $ strategy2: chr "multisession"
[09:31:58.258]  - attr(*, "where")=List of 2
[09:31:58.258]   ..$ nested   :<environment: R_EmptyEnv> 
[09:31:58.258]   ..$ strategy2:<environment: R_EmptyEnv> 
[09:31:58.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.258]  - attr(*, "resolved")= logi FALSE
[09:31:58.258]  - attr(*, "total_size")= num 92816
[09:31:58.258]  - attr(*, "already-done")= logi TRUE
[09:31:58.264] - copied ‘nested’ to environment
[09:31:58.264] - copied ‘strategy2’ to environment
[09:31:58.264] assign_globals() ... done
[09:31:58.264] requestCore(): workers = 2
[09:31:58.267] MulticoreFuture started
[09:31:58.267] - Launch lazy future ... done
[09:31:58.267] run() for ‘MulticoreFuture’ ... done
[09:31:58.268] result() for MulticoreFuture ...
[09:31:58.268] plan(): Setting new future strategy stack:
[09:31:58.268] List of future strategies:
[09:31:58.268] 1. multisession:
[09:31:58.268]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.268]    - tweaked: FALSE
[09:31:58.268]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.274] plan(): nbrOfWorkers() = 1
[09:31:58.315] plan(): Setting new future strategy stack:
[09:31:58.315] List of future strategies:
[09:31:58.315] 1. multicore:
[09:31:58.315]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.315]    - tweaked: FALSE
[09:31:58.315]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.315] 2. multisession:
[09:31:58.315]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.315]    - tweaked: FALSE
[09:31:58.315]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.319] plan(): nbrOfWorkers() = 2
[09:31:58.320] result() for MulticoreFuture ...
[09:31:58.321] result() for MulticoreFuture ... done
[09:31:58.321] signalConditions() ...
[09:31:58.321]  - include = ‘immediateCondition’
[09:31:58.321]  - exclude = 
[09:31:58.321]  - resignal = FALSE
[09:31:58.321]  - Number of conditions: 54
[09:31:58.322] signalConditions() ... done
[09:31:58.322] result() for MulticoreFuture ... done
[09:31:58.322] result() for MulticoreFuture ...
[09:31:58.322] result() for MulticoreFuture ... done
[09:31:58.322] signalConditions() ...
[09:31:58.322]  - include = ‘immediateCondition’
[09:31:58.323]  - exclude = 
[09:31:58.323]  - resignal = FALSE
[09:31:58.323]  - Number of conditions: 54
[09:31:58.323] signalConditions() ... done
[09:31:58.323] Future state: ‘finished’
[09:31:58.323] result() for MulticoreFuture ...
[09:31:58.324] result() for MulticoreFuture ... done
[09:31:58.324] signalConditions() ...
[09:31:58.324]  - include = ‘condition’
[09:31:58.324]  - exclude = ‘immediateCondition’
[09:31:58.324]  - resignal = TRUE
[09:31:58.324]  - Number of conditions: 54
[09:31:58.325]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.276] getGlobalsAndPackages() ...
[09:31:58.325]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.276] Searching for globals...
[09:31:58.325]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.284] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[09:31:58.325]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.284] Searching for globals ... DONE
[09:31:58.325]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.284] Resolving globals: FALSE
[09:31:58.326]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.285] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[09:31:58.326]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.286] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[09:31:58.326]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.286] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[09:31:58.326]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.286] 
[09:31:58.326]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.286] getGlobalsAndPackages() ... DONE
[09:31:58.326]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.287] run() for ‘Future’ ...
[09:31:58.326]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.287] - state: ‘created’
[09:31:58.327]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.327]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.291] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:58.327]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:58.327]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.292]   - Field: ‘label’
[09:31:58.327]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.292]   - Field: ‘local’
[09:31:58.327]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.292]   - Field: ‘owner’
[09:31:58.328]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.292]   - Field: ‘envir’
[09:31:58.328]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.292]   - Field: ‘packages’
[09:31:58.328]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.293]   - Field: ‘gc’
[09:31:58.328]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.293]   - Field: ‘conditions’
[09:31:58.328]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.293]   - Field: ‘expr’
[09:31:58.328]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.293]   - Field: ‘uuid’
[09:31:58.329]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.293]   - Field: ‘seed’
[09:31:58.329]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.293]   - Field: ‘version’
[09:31:58.329]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘result’
[09:31:58.329]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘asynchronous’
[09:31:58.329]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘calls’
[09:31:58.329]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘globals’
[09:31:58.330]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘stdout’
[09:31:58.330]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘earlySignal’
[09:31:58.330]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.294]   - Field: ‘lazy’
[09:31:58.330]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.295]   - Field: ‘state’
[09:31:58.330]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:58.330]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.295] - Launch lazy future ...
[09:31:58.331]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.295] Packages needed by the future expression (n = 0): <none>
[09:31:58.331]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.295] Packages needed by future strategies (n = 0): <none>
[09:31:58.331]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.296] {
[09:31:58.296]     {
[09:31:58.296]         {
[09:31:58.296]             ...future.startTime <- base::Sys.time()
[09:31:58.296]             {
[09:31:58.296]                 {
[09:31:58.296]                   {
[09:31:58.296]                     base::local({
[09:31:58.296]                       has_future <- base::requireNamespace("future", 
[09:31:58.296]                         quietly = TRUE)
[09:31:58.296]                       if (has_future) {
[09:31:58.296]                         ns <- base::getNamespace("future")
[09:31:58.296]                         version <- ns[[".package"]][["version"]]
[09:31:58.296]                         if (is.null(version)) 
[09:31:58.296]                           version <- utils::packageVersion("future")
[09:31:58.296]                       }
[09:31:58.296]                       else {
[09:31:58.296]                         version <- NULL
[09:31:58.296]                       }
[09:31:58.296]                       if (!has_future || version < "1.8.0") {
[09:31:58.296]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.296]                           "", base::R.version$version.string), 
[09:31:58.296]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:58.296]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:58.296]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.296]                             "release", "version")], collapse = " "), 
[09:31:58.296]                           hostname = base::Sys.info()[["nodename"]])
[09:31:58.296]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.296]                           info)
[09:31:58.296]                         info <- base::paste(info, collapse = "; ")
[09:31:58.296]                         if (!has_future) {
[09:31:58.296]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.296]                             info)
[09:31:58.296]                         }
[09:31:58.296]                         else {
[09:31:58.296]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.296]                             info, version)
[09:31:58.296]                         }
[09:31:58.296]                         base::stop(msg)
[09:31:58.296]                       }
[09:31:58.296]                     })
[09:31:58.296]                   }
[09:31:58.296]                   ...future.strategy.old <- future::plan("list")
[09:31:58.296]                   options(future.plan = NULL)
[09:31:58.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:58.296]                 }
[09:31:58.296]                 ...future.workdir <- getwd()
[09:31:58.296]             }
[09:31:58.296]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.296]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.296]         }
[09:31:58.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.296]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.296]             base::names(...future.oldOptions))
[09:31:58.296]     }
[09:31:58.296]     if (FALSE) {
[09:31:58.296]     }
[09:31:58.296]     else {
[09:31:58.296]         if (TRUE) {
[09:31:58.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.296]                 open = "w")
[09:31:58.296]         }
[09:31:58.296]         else {
[09:31:58.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.296]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.296]         }
[09:31:58.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.296]             base::sink(type = "output", split = FALSE)
[09:31:58.296]             base::close(...future.stdout)
[09:31:58.296]         }, add = TRUE)
[09:31:58.296]     }
[09:31:58.296]     ...future.frame <- base::sys.nframe()
[09:31:58.296]     ...future.conditions <- base::list()
[09:31:58.296]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.296]     if (FALSE) {
[09:31:58.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.296]     }
[09:31:58.296]     ...future.result <- base::tryCatch({
[09:31:58.296]         base::withCallingHandlers({
[09:31:58.296]             ...future.value <- base::withVisible(base::local({
[09:31:58.296]                 b <- 2L
[09:31:58.296]                 plan_b <- future::plan("list")
[09:31:58.296]                 nested_b <- nested_a[-1]
[09:31:58.296]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:58.296]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[09:31:58.296]                   "sequential"))
[09:31:58.296]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:58.296]                   b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:58.296]             }))
[09:31:58.296]             future::FutureResult(value = ...future.value$value, 
[09:31:58.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.296]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.296]                     ...future.globalenv.names))
[09:31:58.296]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.296]         }, condition = base::local({
[09:31:58.296]             c <- base::c
[09:31:58.296]             inherits <- base::inherits
[09:31:58.296]             invokeRestart <- base::invokeRestart
[09:31:58.296]             length <- base::length
[09:31:58.296]             list <- base::list
[09:31:58.296]             seq.int <- base::seq.int
[09:31:58.296]             signalCondition <- base::signalCondition
[09:31:58.296]             sys.calls <- base::sys.calls
[09:31:58.296]             `[[` <- base::`[[`
[09:31:58.296]             `+` <- base::`+`
[09:31:58.296]             `<<-` <- base::`<<-`
[09:31:58.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.296]                   3L)]
[09:31:58.296]             }
[09:31:58.296]             function(cond) {
[09:31:58.296]                 is_error <- inherits(cond, "error")
[09:31:58.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.296]                   NULL)
[09:31:58.296]                 if (is_error) {
[09:31:58.296]                   sessionInformation <- function() {
[09:31:58.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.296]                       search = base::search(), system = base::Sys.info())
[09:31:58.296]                   }
[09:31:58.296]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.296]                     cond$call), session = sessionInformation(), 
[09:31:58.296]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.296]                   signalCondition(cond)
[09:31:58.296]                 }
[09:31:58.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.296]                 "immediateCondition"))) {
[09:31:58.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.296]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.296]                   if (TRUE && !signal) {
[09:31:58.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.296]                     {
[09:31:58.296]                       inherits <- base::inherits
[09:31:58.296]                       invokeRestart <- base::invokeRestart
[09:31:58.296]                       is.null <- base::is.null
[09:31:58.296]                       muffled <- FALSE
[09:31:58.296]                       if (inherits(cond, "message")) {
[09:31:58.296]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.296]                         if (muffled) 
[09:31:58.296]                           invokeRestart("muffleMessage")
[09:31:58.296]                       }
[09:31:58.296]                       else if (inherits(cond, "warning")) {
[09:31:58.296]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.296]                         if (muffled) 
[09:31:58.296]                           invokeRestart("muffleWarning")
[09:31:58.296]                       }
[09:31:58.296]                       else if (inherits(cond, "condition")) {
[09:31:58.296]                         if (!is.null(pattern)) {
[09:31:58.296]                           computeRestarts <- base::computeRestarts
[09:31:58.296]                           grepl <- base::grepl
[09:31:58.296]                           restarts <- computeRestarts(cond)
[09:31:58.296]                           for (restart in restarts) {
[09:31:58.296]                             name <- restart$name
[09:31:58.296]                             if (is.null(name)) 
[09:31:58.296]                               next
[09:31:58.296]                             if (!grepl(pattern, name)) 
[09:31:58.296]                               next
[09:31:58.296]                             invokeRestart(restart)
[09:31:58.296]                             muffled <- TRUE
[09:31:58.296]                             break
[09:31:58.296]                           }
[09:31:58.296]                         }
[09:31:58.296]                       }
[09:31:58.296]                       invisible(muffled)
[09:31:58.296]                     }
[09:31:58.296]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.296]                   }
[09:31:58.296]                 }
[09:31:58.296]                 else {
[09:31:58.296]                   if (TRUE) {
[09:31:58.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.296]                     {
[09:31:58.296]                       inherits <- base::inherits
[09:31:58.296]                       invokeRestart <- base::invokeRestart
[09:31:58.296]                       is.null <- base::is.null
[09:31:58.296]                       muffled <- FALSE
[09:31:58.296]                       if (inherits(cond, "message")) {
[09:31:58.296]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.296]                         if (muffled) 
[09:31:58.296]                           invokeRestart("muffleMessage")
[09:31:58.296]                       }
[09:31:58.296]                       else if (inherits(cond, "warning")) {
[09:31:58.296]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.296]                         if (muffled) 
[09:31:58.296]                           invokeRestart("muffleWarning")
[09:31:58.296]                       }
[09:31:58.296]                       else if (inherits(cond, "condition")) {
[09:31:58.296]                         if (!is.null(pattern)) {
[09:31:58.296]                           computeRestarts <- base::computeRestarts
[09:31:58.296]                           grepl <- base::grepl
[09:31:58.296]                           restarts <- computeRestarts(cond)
[09:31:58.296]                           for (restart in restarts) {
[09:31:58.296]                             name <- restart$name
[09:31:58.296]                             if (is.null(name)) 
[09:31:58.296]                               next
[09:31:58.296]                             if (!grepl(pattern, name)) 
[09:31:58.296]                               next
[09:31:58.296]                             invokeRestart(restart)
[09:31:58.296]                             muffled <- TRUE
[09:31:58.296]                             break
[09:31:58.296]                           }
[09:31:58.296]                         }
[09:31:58.296]                       }
[09:31:58.296]                       invisible(muffled)
[09:31:58.296]                     }
[09:31:58.296]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.296]                   }
[09:31:58.296]                 }
[09:31:58.296]             }
[09:31:58.296]         }))
[09:31:58.296]     }, error = function(ex) {
[09:31:58.296]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.296]                 ...future.rng), started = ...future.startTime, 
[09:31:58.296]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.296]             version = "1.8"), class = "FutureResult")
[09:31:58.296]     }, finally = {
[09:31:58.296]         if (!identical(...future.workdir, getwd())) 
[09:31:58.296]             setwd(...future.workdir)
[09:31:58.296]         {
[09:31:58.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.296]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.296]             }
[09:31:58.296]             base::options(...future.oldOptions)
[09:31:58.296]             if (.Platform$OS.type == "windows") {
[09:31:58.296]                 old_names <- names(...future.oldEnvVars)
[09:31:58.296]                 envs <- base::Sys.getenv()
[09:31:58.296]                 names <- names(envs)
[09:31:58.296]                 common <- intersect(names, old_names)
[09:31:58.296]                 added <- setdiff(names, old_names)
[09:31:58.296]                 removed <- setdiff(old_names, names)
[09:31:58.296]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.296]                   envs[common]]
[09:31:58.296]                 NAMES <- toupper(changed)
[09:31:58.296]                 args <- list()
[09:31:58.296]                 for (kk in seq_along(NAMES)) {
[09:31:58.296]                   name <- changed[[kk]]
[09:31:58.296]                   NAME <- NAMES[[kk]]
[09:31:58.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.296]                     next
[09:31:58.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.296]                 }
[09:31:58.296]                 NAMES <- toupper(added)
[09:31:58.296]                 for (kk in seq_along(NAMES)) {
[09:31:58.296]                   name <- added[[kk]]
[09:31:58.296]                   NAME <- NAMES[[kk]]
[09:31:58.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.296]                     next
[09:31:58.296]                   args[[name]] <- ""
[09:31:58.296]                 }
[09:31:58.296]                 NAMES <- toupper(removed)
[09:31:58.296]                 for (kk in seq_along(NAMES)) {
[09:31:58.296]                   name <- removed[[kk]]
[09:31:58.296]                   NAME <- NAMES[[kk]]
[09:31:58.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.296]                     next
[09:31:58.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.296]                 }
[09:31:58.296]                 if (length(args) > 0) 
[09:31:58.296]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.296]             }
[09:31:58.296]             else {
[09:31:58.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.296]             }
[09:31:58.296]             {
[09:31:58.296]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.296]                   0L) {
[09:31:58.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.296]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.296]                   base::options(opts)
[09:31:58.296]                 }
[09:31:58.296]                 {
[09:31:58.296]                   {
[09:31:58.296]                     NULL
[09:31:58.296]                     RNGkind("Mersenne-Twister")
[09:31:58.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:58.296]                       inherits = FALSE)
[09:31:58.296]                   }
[09:31:58.296]                   options(future.plan = NULL)
[09:31:58.296]                   if (is.na(NA_character_)) 
[09:31:58.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.296]                     .init = FALSE)
[09:31:58.296]                 }
[09:31:58.296]             }
[09:31:58.296]         }
[09:31:58.296]     })
[09:31:58.296]     if (TRUE) {
[09:31:58.296]         base::sink(type = "output", split = FALSE)
[09:31:58.296]         if (TRUE) {
[09:31:58.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.296]         }
[09:31:58.296]         else {
[09:31:58.296]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.296]         }
[09:31:58.296]         base::close(...future.stdout)
[09:31:58.296]         ...future.stdout <- NULL
[09:31:58.296]     }
[09:31:58.296]     ...future.result$conditions <- ...future.conditions
[09:31:58.296]     ...future.result$finished <- base::Sys.time()
[09:31:58.296]     ...future.result
[09:31:58.296] }
[09:31:58.331]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.299] assign_globals() ...
[09:31:58.331]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.299] List of 3
[09:31:58.299]  $ nested_a:List of 1
[09:31:58.299]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:58.299]     envir = parent.frame())  
[09:31:58.299]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[09:31:58.299]   .. ..- attr(*, "untweakable")= chr "persistent"
[09:31:58.299]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.299]  $ a       : int 1
[09:31:58.299]  $ plan_a  :List of 1
[09:31:58.299]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:58.299]     envir = parent.frame())  
[09:31:58.299]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[09:31:58.299]   .. ..- attr(*, "untweakable")= chr "persistent"
[09:31:58.299]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[09:31:58.299]  - attr(*, "where")=List of 3
[09:31:58.299]   ..$ nested_a:<environment: R_EmptyEnv> 
[09:31:58.299]   ..$ a       :<environment: R_EmptyEnv> 
[09:31:58.299]   ..$ plan_a  :<environment: R_EmptyEnv> 
[09:31:58.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.299]  - attr(*, "resolved")= logi FALSE
[09:31:58.299]  - attr(*, "total_size")= num 89928
[09:31:58.299]  - attr(*, "already-done")= logi TRUE
[09:31:58.331]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.307] - copied ‘nested_a’ to environment
[09:31:58.331]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.307] - copied ‘a’ to environment
[09:31:58.332]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.307] - copied ‘plan_a’ to environment
[09:31:58.332]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.307] assign_globals() ... done
[09:31:58.332]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.307] plan(): Setting new future strategy stack:
[09:31:58.332]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.308] List of future strategies:
[09:31:58.308] 1. sequential:
[09:31:58.308]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:58.308]    - tweaked: FALSE
[09:31:58.308]    - call: NULL
[09:31:58.332]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.308] plan(): nbrOfWorkers() = 1
[09:31:58.332]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.309] plan(): Setting new future strategy stack:
[09:31:58.333]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.309] List of future strategies:
[09:31:58.309] 1. multisession:
[09:31:58.309]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.309]    - tweaked: FALSE
[09:31:58.309]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.333]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.313] plan(): nbrOfWorkers() = 1
[09:31:58.333]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.314] SequentialFuture started (and completed)
[09:31:58.333]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.314] - Launch lazy future ... done
[09:31:58.333]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.314] run() for ‘SequentialFuture’ ... done
[09:31:58.333] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:58.340] getGlobalsAndPackages() ...
[09:31:58.340] Searching for globals...
[09:31:58.342] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:58.342] Searching for globals ... DONE
[09:31:58.342] Resolving globals: FALSE
[09:31:58.343] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:58.343] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:58.343] - globals: [1] ‘data’
[09:31:58.343] - packages: [1] ‘future’
[09:31:58.343] getGlobalsAndPackages() ... DONE
[09:31:58.344] run() for ‘Future’ ...
[09:31:58.344] - state: ‘created’
[09:31:58.344] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.348] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:58.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:58.348]   - Field: ‘label’
[09:31:58.348]   - Field: ‘local’
[09:31:58.348]   - Field: ‘owner’
[09:31:58.349]   - Field: ‘envir’
[09:31:58.349]   - Field: ‘workers’
[09:31:58.349]   - Field: ‘packages’
[09:31:58.349]   - Field: ‘gc’
[09:31:58.349]   - Field: ‘job’
[09:31:58.349]   - Field: ‘conditions’
[09:31:58.349]   - Field: ‘expr’
[09:31:58.349]   - Field: ‘uuid’
[09:31:58.349]   - Field: ‘seed’
[09:31:58.350]   - Field: ‘version’
[09:31:58.350]   - Field: ‘result’
[09:31:58.350]   - Field: ‘asynchronous’
[09:31:58.350]   - Field: ‘calls’
[09:31:58.350]   - Field: ‘globals’
[09:31:58.350]   - Field: ‘stdout’
[09:31:58.350]   - Field: ‘earlySignal’
[09:31:58.350]   - Field: ‘lazy’
[09:31:58.350]   - Field: ‘state’
[09:31:58.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:58.351] - Launch lazy future ...
[09:31:58.351] Packages needed by the future expression (n = 1): ‘future’
[09:31:58.351] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.352] {
[09:31:58.352]     {
[09:31:58.352]         {
[09:31:58.352]             ...future.startTime <- base::Sys.time()
[09:31:58.352]             {
[09:31:58.352]                 {
[09:31:58.352]                   {
[09:31:58.352]                     {
[09:31:58.352]                       {
[09:31:58.352]                         base::local({
[09:31:58.352]                           has_future <- base::requireNamespace("future", 
[09:31:58.352]                             quietly = TRUE)
[09:31:58.352]                           if (has_future) {
[09:31:58.352]                             ns <- base::getNamespace("future")
[09:31:58.352]                             version <- ns[[".package"]][["version"]]
[09:31:58.352]                             if (is.null(version)) 
[09:31:58.352]                               version <- utils::packageVersion("future")
[09:31:58.352]                           }
[09:31:58.352]                           else {
[09:31:58.352]                             version <- NULL
[09:31:58.352]                           }
[09:31:58.352]                           if (!has_future || version < "1.8.0") {
[09:31:58.352]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.352]                               "", base::R.version$version.string), 
[09:31:58.352]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.352]                                 base::R.version$platform, 8 * 
[09:31:58.352]                                   base::.Machine$sizeof.pointer), 
[09:31:58.352]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.352]                                 "release", "version")], collapse = " "), 
[09:31:58.352]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.352]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.352]                               info)
[09:31:58.352]                             info <- base::paste(info, collapse = "; ")
[09:31:58.352]                             if (!has_future) {
[09:31:58.352]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.352]                                 info)
[09:31:58.352]                             }
[09:31:58.352]                             else {
[09:31:58.352]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.352]                                 info, version)
[09:31:58.352]                             }
[09:31:58.352]                             base::stop(msg)
[09:31:58.352]                           }
[09:31:58.352]                         })
[09:31:58.352]                       }
[09:31:58.352]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.352]                       base::options(mc.cores = 1L)
[09:31:58.352]                     }
[09:31:58.352]                     base::local({
[09:31:58.352]                       for (pkg in "future") {
[09:31:58.352]                         base::loadNamespace(pkg)
[09:31:58.352]                         base::library(pkg, character.only = TRUE)
[09:31:58.352]                       }
[09:31:58.352]                     })
[09:31:58.352]                   }
[09:31:58.352]                   ...future.strategy.old <- future::plan("list")
[09:31:58.352]                   options(future.plan = NULL)
[09:31:58.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.352]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:31:58.352]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:58.352]                     envir = parent.frame()) 
[09:31:58.352]                   {
[09:31:58.352]                     if (is.function(workers)) 
[09:31:58.352]                       workers <- workers()
[09:31:58.352]                     workers <- structure(as.integer(workers), 
[09:31:58.352]                       class = class(workers))
[09:31:58.352]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:31:58.352]                       workers >= 1)
[09:31:58.352]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:31:58.352]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:31:58.352]                     }
[09:31:58.352]                     future <- MultisessionFuture(..., workers = workers, 
[09:31:58.352]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:31:58.352]                       envir = envir)
[09:31:58.352]                     if (!future$lazy) 
[09:31:58.352]                       future <- run(future)
[09:31:58.352]                     invisible(future)
[09:31:58.352]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.352]                 }
[09:31:58.352]                 ...future.workdir <- getwd()
[09:31:58.352]             }
[09:31:58.352]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.352]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.352]         }
[09:31:58.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.352]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.352]             base::names(...future.oldOptions))
[09:31:58.352]     }
[09:31:58.352]     if (FALSE) {
[09:31:58.352]     }
[09:31:58.352]     else {
[09:31:58.352]         if (TRUE) {
[09:31:58.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.352]                 open = "w")
[09:31:58.352]         }
[09:31:58.352]         else {
[09:31:58.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.352]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.352]         }
[09:31:58.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.352]             base::sink(type = "output", split = FALSE)
[09:31:58.352]             base::close(...future.stdout)
[09:31:58.352]         }, add = TRUE)
[09:31:58.352]     }
[09:31:58.352]     ...future.frame <- base::sys.nframe()
[09:31:58.352]     ...future.conditions <- base::list()
[09:31:58.352]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.352]     if (FALSE) {
[09:31:58.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.352]     }
[09:31:58.352]     ...future.result <- base::tryCatch({
[09:31:58.352]         base::withCallingHandlers({
[09:31:58.352]             ...future.value <- base::withVisible(base::local({
[09:31:58.352]                 withCallingHandlers({
[09:31:58.352]                   {
[09:31:58.352]                     value(future(subset(data, a == 2)))
[09:31:58.352]                   }
[09:31:58.352]                 }, immediateCondition = function(cond) {
[09:31:58.352]                   save_rds <- function (object, pathname, ...) 
[09:31:58.352]                   {
[09:31:58.352]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:58.352]                     if (file_test("-f", pathname_tmp)) {
[09:31:58.352]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.352]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:58.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.352]                         fi_tmp[["mtime"]])
[09:31:58.352]                     }
[09:31:58.352]                     tryCatch({
[09:31:58.352]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:58.352]                     }, error = function(ex) {
[09:31:58.352]                       msg <- conditionMessage(ex)
[09:31:58.352]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.352]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:58.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.352]                         fi_tmp[["mtime"]], msg)
[09:31:58.352]                       ex$message <- msg
[09:31:58.352]                       stop(ex)
[09:31:58.352]                     })
[09:31:58.352]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:58.352]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:58.352]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:58.352]                       fi_tmp <- file.info(pathname_tmp)
[09:31:58.352]                       fi <- file.info(pathname)
[09:31:58.352]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:58.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:58.352]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:58.352]                         fi[["size"]], fi[["mtime"]])
[09:31:58.352]                       stop(msg)
[09:31:58.352]                     }
[09:31:58.352]                     invisible(pathname)
[09:31:58.352]                   }
[09:31:58.352]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:58.352]                     rootPath = tempdir()) 
[09:31:58.352]                   {
[09:31:58.352]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:58.352]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:58.352]                       tmpdir = path, fileext = ".rds")
[09:31:58.352]                     save_rds(obj, file)
[09:31:58.352]                   }
[09:31:58.352]                   saveImmediateCondition(cond, path = "/tmp/RtmpuDppLD/.future/immediateConditions")
[09:31:58.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.352]                   {
[09:31:58.352]                     inherits <- base::inherits
[09:31:58.352]                     invokeRestart <- base::invokeRestart
[09:31:58.352]                     is.null <- base::is.null
[09:31:58.352]                     muffled <- FALSE
[09:31:58.352]                     if (inherits(cond, "message")) {
[09:31:58.352]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.352]                       if (muffled) 
[09:31:58.352]                         invokeRestart("muffleMessage")
[09:31:58.352]                     }
[09:31:58.352]                     else if (inherits(cond, "warning")) {
[09:31:58.352]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.352]                       if (muffled) 
[09:31:58.352]                         invokeRestart("muffleWarning")
[09:31:58.352]                     }
[09:31:58.352]                     else if (inherits(cond, "condition")) {
[09:31:58.352]                       if (!is.null(pattern)) {
[09:31:58.352]                         computeRestarts <- base::computeRestarts
[09:31:58.352]                         grepl <- base::grepl
[09:31:58.352]                         restarts <- computeRestarts(cond)
[09:31:58.352]                         for (restart in restarts) {
[09:31:58.352]                           name <- restart$name
[09:31:58.352]                           if (is.null(name)) 
[09:31:58.352]                             next
[09:31:58.352]                           if (!grepl(pattern, name)) 
[09:31:58.352]                             next
[09:31:58.352]                           invokeRestart(restart)
[09:31:58.352]                           muffled <- TRUE
[09:31:58.352]                           break
[09:31:58.352]                         }
[09:31:58.352]                       }
[09:31:58.352]                     }
[09:31:58.352]                     invisible(muffled)
[09:31:58.352]                   }
[09:31:58.352]                   muffleCondition(cond)
[09:31:58.352]                 })
[09:31:58.352]             }))
[09:31:58.352]             future::FutureResult(value = ...future.value$value, 
[09:31:58.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.352]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.352]                     ...future.globalenv.names))
[09:31:58.352]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.352]         }, condition = base::local({
[09:31:58.352]             c <- base::c
[09:31:58.352]             inherits <- base::inherits
[09:31:58.352]             invokeRestart <- base::invokeRestart
[09:31:58.352]             length <- base::length
[09:31:58.352]             list <- base::list
[09:31:58.352]             seq.int <- base::seq.int
[09:31:58.352]             signalCondition <- base::signalCondition
[09:31:58.352]             sys.calls <- base::sys.calls
[09:31:58.352]             `[[` <- base::`[[`
[09:31:58.352]             `+` <- base::`+`
[09:31:58.352]             `<<-` <- base::`<<-`
[09:31:58.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.352]                   3L)]
[09:31:58.352]             }
[09:31:58.352]             function(cond) {
[09:31:58.352]                 is_error <- inherits(cond, "error")
[09:31:58.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.352]                   NULL)
[09:31:58.352]                 if (is_error) {
[09:31:58.352]                   sessionInformation <- function() {
[09:31:58.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.352]                       search = base::search(), system = base::Sys.info())
[09:31:58.352]                   }
[09:31:58.352]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.352]                     cond$call), session = sessionInformation(), 
[09:31:58.352]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.352]                   signalCondition(cond)
[09:31:58.352]                 }
[09:31:58.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.352]                 "immediateCondition"))) {
[09:31:58.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.352]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.352]                   if (TRUE && !signal) {
[09:31:58.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.352]                     {
[09:31:58.352]                       inherits <- base::inherits
[09:31:58.352]                       invokeRestart <- base::invokeRestart
[09:31:58.352]                       is.null <- base::is.null
[09:31:58.352]                       muffled <- FALSE
[09:31:58.352]                       if (inherits(cond, "message")) {
[09:31:58.352]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.352]                         if (muffled) 
[09:31:58.352]                           invokeRestart("muffleMessage")
[09:31:58.352]                       }
[09:31:58.352]                       else if (inherits(cond, "warning")) {
[09:31:58.352]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.352]                         if (muffled) 
[09:31:58.352]                           invokeRestart("muffleWarning")
[09:31:58.352]                       }
[09:31:58.352]                       else if (inherits(cond, "condition")) {
[09:31:58.352]                         if (!is.null(pattern)) {
[09:31:58.352]                           computeRestarts <- base::computeRestarts
[09:31:58.352]                           grepl <- base::grepl
[09:31:58.352]                           restarts <- computeRestarts(cond)
[09:31:58.352]                           for (restart in restarts) {
[09:31:58.352]                             name <- restart$name
[09:31:58.352]                             if (is.null(name)) 
[09:31:58.352]                               next
[09:31:58.352]                             if (!grepl(pattern, name)) 
[09:31:58.352]                               next
[09:31:58.352]                             invokeRestart(restart)
[09:31:58.352]                             muffled <- TRUE
[09:31:58.352]                             break
[09:31:58.352]                           }
[09:31:58.352]                         }
[09:31:58.352]                       }
[09:31:58.352]                       invisible(muffled)
[09:31:58.352]                     }
[09:31:58.352]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.352]                   }
[09:31:58.352]                 }
[09:31:58.352]                 else {
[09:31:58.352]                   if (TRUE) {
[09:31:58.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.352]                     {
[09:31:58.352]                       inherits <- base::inherits
[09:31:58.352]                       invokeRestart <- base::invokeRestart
[09:31:58.352]                       is.null <- base::is.null
[09:31:58.352]                       muffled <- FALSE
[09:31:58.352]                       if (inherits(cond, "message")) {
[09:31:58.352]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.352]                         if (muffled) 
[09:31:58.352]                           invokeRestart("muffleMessage")
[09:31:58.352]                       }
[09:31:58.352]                       else if (inherits(cond, "warning")) {
[09:31:58.352]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.352]                         if (muffled) 
[09:31:58.352]                           invokeRestart("muffleWarning")
[09:31:58.352]                       }
[09:31:58.352]                       else if (inherits(cond, "condition")) {
[09:31:58.352]                         if (!is.null(pattern)) {
[09:31:58.352]                           computeRestarts <- base::computeRestarts
[09:31:58.352]                           grepl <- base::grepl
[09:31:58.352]                           restarts <- computeRestarts(cond)
[09:31:58.352]                           for (restart in restarts) {
[09:31:58.352]                             name <- restart$name
[09:31:58.352]                             if (is.null(name)) 
[09:31:58.352]                               next
[09:31:58.352]                             if (!grepl(pattern, name)) 
[09:31:58.352]                               next
[09:31:58.352]                             invokeRestart(restart)
[09:31:58.352]                             muffled <- TRUE
[09:31:58.352]                             break
[09:31:58.352]                           }
[09:31:58.352]                         }
[09:31:58.352]                       }
[09:31:58.352]                       invisible(muffled)
[09:31:58.352]                     }
[09:31:58.352]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.352]                   }
[09:31:58.352]                 }
[09:31:58.352]             }
[09:31:58.352]         }))
[09:31:58.352]     }, error = function(ex) {
[09:31:58.352]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.352]                 ...future.rng), started = ...future.startTime, 
[09:31:58.352]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.352]             version = "1.8"), class = "FutureResult")
[09:31:58.352]     }, finally = {
[09:31:58.352]         if (!identical(...future.workdir, getwd())) 
[09:31:58.352]             setwd(...future.workdir)
[09:31:58.352]         {
[09:31:58.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.352]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.352]             }
[09:31:58.352]             base::options(...future.oldOptions)
[09:31:58.352]             if (.Platform$OS.type == "windows") {
[09:31:58.352]                 old_names <- names(...future.oldEnvVars)
[09:31:58.352]                 envs <- base::Sys.getenv()
[09:31:58.352]                 names <- names(envs)
[09:31:58.352]                 common <- intersect(names, old_names)
[09:31:58.352]                 added <- setdiff(names, old_names)
[09:31:58.352]                 removed <- setdiff(old_names, names)
[09:31:58.352]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.352]                   envs[common]]
[09:31:58.352]                 NAMES <- toupper(changed)
[09:31:58.352]                 args <- list()
[09:31:58.352]                 for (kk in seq_along(NAMES)) {
[09:31:58.352]                   name <- changed[[kk]]
[09:31:58.352]                   NAME <- NAMES[[kk]]
[09:31:58.352]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.352]                     next
[09:31:58.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.352]                 }
[09:31:58.352]                 NAMES <- toupper(added)
[09:31:58.352]                 for (kk in seq_along(NAMES)) {
[09:31:58.352]                   name <- added[[kk]]
[09:31:58.352]                   NAME <- NAMES[[kk]]
[09:31:58.352]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.352]                     next
[09:31:58.352]                   args[[name]] <- ""
[09:31:58.352]                 }
[09:31:58.352]                 NAMES <- toupper(removed)
[09:31:58.352]                 for (kk in seq_along(NAMES)) {
[09:31:58.352]                   name <- removed[[kk]]
[09:31:58.352]                   NAME <- NAMES[[kk]]
[09:31:58.352]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.352]                     next
[09:31:58.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.352]                 }
[09:31:58.352]                 if (length(args) > 0) 
[09:31:58.352]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.352]             }
[09:31:58.352]             else {
[09:31:58.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.352]             }
[09:31:58.352]             {
[09:31:58.352]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.352]                   0L) {
[09:31:58.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.352]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.352]                   base::options(opts)
[09:31:58.352]                 }
[09:31:58.352]                 {
[09:31:58.352]                   {
[09:31:58.352]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.352]                     NULL
[09:31:58.352]                   }
[09:31:58.352]                   options(future.plan = NULL)
[09:31:58.352]                   if (is.na(NA_character_)) 
[09:31:58.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.352]                     .init = FALSE)
[09:31:58.352]                 }
[09:31:58.352]             }
[09:31:58.352]         }
[09:31:58.352]     })
[09:31:58.352]     if (TRUE) {
[09:31:58.352]         base::sink(type = "output", split = FALSE)
[09:31:58.352]         if (TRUE) {
[09:31:58.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.352]         }
[09:31:58.352]         else {
[09:31:58.352]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.352]         }
[09:31:58.352]         base::close(...future.stdout)
[09:31:58.352]         ...future.stdout <- NULL
[09:31:58.352]     }
[09:31:58.352]     ...future.result$conditions <- ...future.conditions
[09:31:58.352]     ...future.result$finished <- base::Sys.time()
[09:31:58.352]     ...future.result
[09:31:58.352] }
[09:31:58.354] assign_globals() ...
[09:31:58.354] List of 1
[09:31:58.354]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:58.354]   ..$ a: int [1:3] 1 2 3
[09:31:58.354]   ..$ b: int [1:3] 3 2 1
[09:31:58.354]  - attr(*, "where")=List of 1
[09:31:58.354]   ..$ data:<environment: R_EmptyEnv> 
[09:31:58.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.354]  - attr(*, "resolved")= logi FALSE
[09:31:58.354]  - attr(*, "total_size")= num 128
[09:31:58.354]  - attr(*, "already-done")= logi TRUE
[09:31:58.358] - copied ‘data’ to environment
[09:31:58.358] assign_globals() ... done
[09:31:58.358] requestCore(): workers = 2
[09:31:58.361] MulticoreFuture started
[09:31:58.361] - Launch lazy future ... done
[09:31:58.361] run() for ‘MulticoreFuture’ ... done
[09:31:58.361] result() for MulticoreFuture ...
[09:31:58.362] plan(): Setting new future strategy stack:
[09:31:58.362] List of future strategies:
[09:31:58.362] 1. multisession:
[09:31:58.362]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.362]    - tweaked: FALSE
[09:31:58.362]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.367] plan(): nbrOfWorkers() = 1
[09:31:58.404] plan(): Setting new future strategy stack:
[09:31:58.404] List of future strategies:
[09:31:58.404] 1. multicore:
[09:31:58.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:58.404]    - tweaked: FALSE
[09:31:58.404]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.404] 2. multisession:
[09:31:58.404]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.404]    - tweaked: FALSE
[09:31:58.404]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.408] plan(): nbrOfWorkers() = 2
[09:31:58.409] result() for MulticoreFuture ...
[09:31:58.409] result() for MulticoreFuture ... done
[09:31:58.409] signalConditions() ...
[09:31:58.409]  - include = ‘immediateCondition’
[09:31:58.409]  - exclude = 
[09:31:58.409]  - resignal = FALSE
[09:31:58.410]  - Number of conditions: 52
[09:31:58.410] signalConditions() ... done
[09:31:58.410] result() for MulticoreFuture ... done
[09:31:58.410] result() for MulticoreFuture ...
[09:31:58.410] result() for MulticoreFuture ... done
[09:31:58.410] signalConditions() ...
[09:31:58.410]  - include = ‘immediateCondition’
[09:31:58.410]  - exclude = 
[09:31:58.410]  - resignal = FALSE
[09:31:58.411]  - Number of conditions: 52
[09:31:58.411] signalConditions() ... done
[09:31:58.411] Future state: ‘finished’
[09:31:58.411] result() for MulticoreFuture ...
[09:31:58.411] result() for MulticoreFuture ... done
[09:31:58.411] signalConditions() ...
[09:31:58.411]  - include = ‘condition’
[09:31:58.411]  - exclude = ‘immediateCondition’
[09:31:58.412]  - resignal = TRUE
[09:31:58.412]  - Number of conditions: 52
[09:31:58.412]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.368] getGlobalsAndPackages() ...
[09:31:58.412]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.369] Searching for globals...
[09:31:58.412]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.370] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:58.412]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.371] Searching for globals ... DONE
[09:31:58.412]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.371] Resolving globals: FALSE
[09:31:58.413]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.372] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:58.413]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.372] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:58.413]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.372] - globals: [1] ‘data’
[09:31:58.413]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.373] 
[09:31:58.413]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.373] getGlobalsAndPackages() ... DONE
[09:31:58.413]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.374] run() for ‘Future’ ...
[09:31:58.414]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.374] - state: ‘created’
[09:31:58.414]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.374] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.414]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.384] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:58.414]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:58.414]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.385]   - Field: ‘label’
[09:31:58.418]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.385]   - Field: ‘local’
[09:31:58.418]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.385]   - Field: ‘owner’
[09:31:58.419]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.385]   - Field: ‘envir’
[09:31:58.419]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.385]   - Field: ‘packages’
[09:31:58.419]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.385]   - Field: ‘gc’
[09:31:58.419]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.386]   - Field: ‘conditions’
[09:31:58.419]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.386]   - Field: ‘expr’
[09:31:58.419]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.386]   - Field: ‘uuid’
[09:31:58.419]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.386]   - Field: ‘seed’
[09:31:58.420]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.386]   - Field: ‘version’
[09:31:58.420]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.386]   - Field: ‘result’
[09:31:58.420]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.387]   - Field: ‘asynchronous’
[09:31:58.420]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.387]   - Field: ‘calls’
[09:31:58.420]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.387]   - Field: ‘globals’
[09:31:58.420]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.387]   - Field: ‘stdout’
[09:31:58.421]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.387]   - Field: ‘earlySignal’
[09:31:58.421]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.387]   - Field: ‘lazy’
[09:31:58.421]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.388]   - Field: ‘state’
[09:31:58.421]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:58.421]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.388] - Launch lazy future ...
[09:31:58.421]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.388] Packages needed by the future expression (n = 0): <none>
[09:31:58.421]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.388] Packages needed by future strategies (n = 0): <none>
[09:31:58.422]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.389] {
[09:31:58.389]     {
[09:31:58.389]         {
[09:31:58.389]             ...future.startTime <- base::Sys.time()
[09:31:58.389]             {
[09:31:58.389]                 {
[09:31:58.389]                   {
[09:31:58.389]                     base::local({
[09:31:58.389]                       has_future <- base::requireNamespace("future", 
[09:31:58.389]                         quietly = TRUE)
[09:31:58.389]                       if (has_future) {
[09:31:58.389]                         ns <- base::getNamespace("future")
[09:31:58.389]                         version <- ns[[".package"]][["version"]]
[09:31:58.389]                         if (is.null(version)) 
[09:31:58.389]                           version <- utils::packageVersion("future")
[09:31:58.389]                       }
[09:31:58.389]                       else {
[09:31:58.389]                         version <- NULL
[09:31:58.389]                       }
[09:31:58.389]                       if (!has_future || version < "1.8.0") {
[09:31:58.389]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.389]                           "", base::R.version$version.string), 
[09:31:58.389]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:58.389]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:58.389]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.389]                             "release", "version")], collapse = " "), 
[09:31:58.389]                           hostname = base::Sys.info()[["nodename"]])
[09:31:58.389]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.389]                           info)
[09:31:58.389]                         info <- base::paste(info, collapse = "; ")
[09:31:58.389]                         if (!has_future) {
[09:31:58.389]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.389]                             info)
[09:31:58.389]                         }
[09:31:58.389]                         else {
[09:31:58.389]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.389]                             info, version)
[09:31:58.389]                         }
[09:31:58.389]                         base::stop(msg)
[09:31:58.389]                       }
[09:31:58.389]                     })
[09:31:58.389]                   }
[09:31:58.389]                   ...future.strategy.old <- future::plan("list")
[09:31:58.389]                   options(future.plan = NULL)
[09:31:58.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:58.389]                 }
[09:31:58.389]                 ...future.workdir <- getwd()
[09:31:58.389]             }
[09:31:58.389]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.389]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.389]         }
[09:31:58.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.389]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.389]             base::names(...future.oldOptions))
[09:31:58.389]     }
[09:31:58.389]     if (FALSE) {
[09:31:58.389]     }
[09:31:58.389]     else {
[09:31:58.389]         if (TRUE) {
[09:31:58.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.389]                 open = "w")
[09:31:58.389]         }
[09:31:58.389]         else {
[09:31:58.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.389]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.389]         }
[09:31:58.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.389]             base::sink(type = "output", split = FALSE)
[09:31:58.389]             base::close(...future.stdout)
[09:31:58.389]         }, add = TRUE)
[09:31:58.389]     }
[09:31:58.389]     ...future.frame <- base::sys.nframe()
[09:31:58.389]     ...future.conditions <- base::list()
[09:31:58.389]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.389]     if (FALSE) {
[09:31:58.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.389]     }
[09:31:58.389]     ...future.result <- base::tryCatch({
[09:31:58.389]         base::withCallingHandlers({
[09:31:58.389]             ...future.value <- base::withVisible(base::local(subset(data, 
[09:31:58.389]                 a == 2)))
[09:31:58.389]             future::FutureResult(value = ...future.value$value, 
[09:31:58.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.389]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.389]                     ...future.globalenv.names))
[09:31:58.389]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.389]         }, condition = base::local({
[09:31:58.389]             c <- base::c
[09:31:58.389]             inherits <- base::inherits
[09:31:58.389]             invokeRestart <- base::invokeRestart
[09:31:58.389]             length <- base::length
[09:31:58.389]             list <- base::list
[09:31:58.389]             seq.int <- base::seq.int
[09:31:58.389]             signalCondition <- base::signalCondition
[09:31:58.389]             sys.calls <- base::sys.calls
[09:31:58.389]             `[[` <- base::`[[`
[09:31:58.389]             `+` <- base::`+`
[09:31:58.389]             `<<-` <- base::`<<-`
[09:31:58.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.389]                   3L)]
[09:31:58.389]             }
[09:31:58.389]             function(cond) {
[09:31:58.389]                 is_error <- inherits(cond, "error")
[09:31:58.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.389]                   NULL)
[09:31:58.389]                 if (is_error) {
[09:31:58.389]                   sessionInformation <- function() {
[09:31:58.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.389]                       search = base::search(), system = base::Sys.info())
[09:31:58.389]                   }
[09:31:58.389]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.389]                     cond$call), session = sessionInformation(), 
[09:31:58.389]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.389]                   signalCondition(cond)
[09:31:58.389]                 }
[09:31:58.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.389]                 "immediateCondition"))) {
[09:31:58.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.389]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.389]                   if (TRUE && !signal) {
[09:31:58.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.389]                     {
[09:31:58.389]                       inherits <- base::inherits
[09:31:58.389]                       invokeRestart <- base::invokeRestart
[09:31:58.389]                       is.null <- base::is.null
[09:31:58.389]                       muffled <- FALSE
[09:31:58.389]                       if (inherits(cond, "message")) {
[09:31:58.389]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.389]                         if (muffled) 
[09:31:58.389]                           invokeRestart("muffleMessage")
[09:31:58.389]                       }
[09:31:58.389]                       else if (inherits(cond, "warning")) {
[09:31:58.389]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.389]                         if (muffled) 
[09:31:58.389]                           invokeRestart("muffleWarning")
[09:31:58.389]                       }
[09:31:58.389]                       else if (inherits(cond, "condition")) {
[09:31:58.389]                         if (!is.null(pattern)) {
[09:31:58.389]                           computeRestarts <- base::computeRestarts
[09:31:58.389]                           grepl <- base::grepl
[09:31:58.389]                           restarts <- computeRestarts(cond)
[09:31:58.389]                           for (restart in restarts) {
[09:31:58.389]                             name <- restart$name
[09:31:58.389]                             if (is.null(name)) 
[09:31:58.389]                               next
[09:31:58.389]                             if (!grepl(pattern, name)) 
[09:31:58.389]                               next
[09:31:58.389]                             invokeRestart(restart)
[09:31:58.389]                             muffled <- TRUE
[09:31:58.389]                             break
[09:31:58.389]                           }
[09:31:58.389]                         }
[09:31:58.389]                       }
[09:31:58.389]                       invisible(muffled)
[09:31:58.389]                     }
[09:31:58.389]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.389]                   }
[09:31:58.389]                 }
[09:31:58.389]                 else {
[09:31:58.389]                   if (TRUE) {
[09:31:58.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.389]                     {
[09:31:58.389]                       inherits <- base::inherits
[09:31:58.389]                       invokeRestart <- base::invokeRestart
[09:31:58.389]                       is.null <- base::is.null
[09:31:58.389]                       muffled <- FALSE
[09:31:58.389]                       if (inherits(cond, "message")) {
[09:31:58.389]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.389]                         if (muffled) 
[09:31:58.389]                           invokeRestart("muffleMessage")
[09:31:58.389]                       }
[09:31:58.389]                       else if (inherits(cond, "warning")) {
[09:31:58.389]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.389]                         if (muffled) 
[09:31:58.389]                           invokeRestart("muffleWarning")
[09:31:58.389]                       }
[09:31:58.389]                       else if (inherits(cond, "condition")) {
[09:31:58.389]                         if (!is.null(pattern)) {
[09:31:58.389]                           computeRestarts <- base::computeRestarts
[09:31:58.389]                           grepl <- base::grepl
[09:31:58.389]                           restarts <- computeRestarts(cond)
[09:31:58.389]                           for (restart in restarts) {
[09:31:58.389]                             name <- restart$name
[09:31:58.389]                             if (is.null(name)) 
[09:31:58.389]                               next
[09:31:58.389]                             if (!grepl(pattern, name)) 
[09:31:58.389]                               next
[09:31:58.389]                             invokeRestart(restart)
[09:31:58.389]                             muffled <- TRUE
[09:31:58.389]                             break
[09:31:58.389]                           }
[09:31:58.389]                         }
[09:31:58.389]                       }
[09:31:58.389]                       invisible(muffled)
[09:31:58.389]                     }
[09:31:58.389]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.389]                   }
[09:31:58.389]                 }
[09:31:58.389]             }
[09:31:58.389]         }))
[09:31:58.389]     }, error = function(ex) {
[09:31:58.389]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.389]                 ...future.rng), started = ...future.startTime, 
[09:31:58.389]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.389]             version = "1.8"), class = "FutureResult")
[09:31:58.389]     }, finally = {
[09:31:58.389]         if (!identical(...future.workdir, getwd())) 
[09:31:58.389]             setwd(...future.workdir)
[09:31:58.389]         {
[09:31:58.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.389]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.389]             }
[09:31:58.389]             base::options(...future.oldOptions)
[09:31:58.389]             if (.Platform$OS.type == "windows") {
[09:31:58.389]                 old_names <- names(...future.oldEnvVars)
[09:31:58.389]                 envs <- base::Sys.getenv()
[09:31:58.389]                 names <- names(envs)
[09:31:58.389]                 common <- intersect(names, old_names)
[09:31:58.389]                 added <- setdiff(names, old_names)
[09:31:58.389]                 removed <- setdiff(old_names, names)
[09:31:58.389]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.389]                   envs[common]]
[09:31:58.389]                 NAMES <- toupper(changed)
[09:31:58.389]                 args <- list()
[09:31:58.389]                 for (kk in seq_along(NAMES)) {
[09:31:58.389]                   name <- changed[[kk]]
[09:31:58.389]                   NAME <- NAMES[[kk]]
[09:31:58.389]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.389]                     next
[09:31:58.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.389]                 }
[09:31:58.389]                 NAMES <- toupper(added)
[09:31:58.389]                 for (kk in seq_along(NAMES)) {
[09:31:58.389]                   name <- added[[kk]]
[09:31:58.389]                   NAME <- NAMES[[kk]]
[09:31:58.389]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.389]                     next
[09:31:58.389]                   args[[name]] <- ""
[09:31:58.389]                 }
[09:31:58.389]                 NAMES <- toupper(removed)
[09:31:58.389]                 for (kk in seq_along(NAMES)) {
[09:31:58.389]                   name <- removed[[kk]]
[09:31:58.389]                   NAME <- NAMES[[kk]]
[09:31:58.389]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.389]                     next
[09:31:58.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.389]                 }
[09:31:58.389]                 if (length(args) > 0) 
[09:31:58.389]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.389]             }
[09:31:58.389]             else {
[09:31:58.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.389]             }
[09:31:58.389]             {
[09:31:58.389]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.389]                   0L) {
[09:31:58.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.389]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.389]                   base::options(opts)
[09:31:58.389]                 }
[09:31:58.389]                 {
[09:31:58.389]                   {
[09:31:58.389]                     NULL
[09:31:58.389]                     RNGkind("Mersenne-Twister")
[09:31:58.389]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:58.389]                       inherits = FALSE)
[09:31:58.389]                   }
[09:31:58.389]                   options(future.plan = NULL)
[09:31:58.389]                   if (is.na(NA_character_)) 
[09:31:58.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.389]                     .init = FALSE)
[09:31:58.389]                 }
[09:31:58.389]             }
[09:31:58.389]         }
[09:31:58.389]     })
[09:31:58.389]     if (TRUE) {
[09:31:58.389]         base::sink(type = "output", split = FALSE)
[09:31:58.389]         if (TRUE) {
[09:31:58.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.389]         }
[09:31:58.389]         else {
[09:31:58.389]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.389]         }
[09:31:58.389]         base::close(...future.stdout)
[09:31:58.389]         ...future.stdout <- NULL
[09:31:58.389]     }
[09:31:58.389]     ...future.result$conditions <- ...future.conditions
[09:31:58.389]     ...future.result$finished <- base::Sys.time()
[09:31:58.389]     ...future.result
[09:31:58.389] }
[09:31:58.422]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.391] assign_globals() ...
[09:31:58.422]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.391] List of 1
[09:31:58.391]  $ data:'data.frame':	3 obs. of  2 variables:
[09:31:58.391]   ..$ a: int [1:3] 1 2 3
[09:31:58.391]   ..$ b: int [1:3] 3 2 1
[09:31:58.391]  - attr(*, "where")=List of 1
[09:31:58.391]   ..$ data:<environment: R_EmptyEnv> 
[09:31:58.391]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:58.391]  - attr(*, "resolved")= logi FALSE
[09:31:58.391]  - attr(*, "total_size")= num 128
[09:31:58.391]  - attr(*, "already-done")= logi TRUE
[09:31:58.422]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.396] - copied ‘data’ to environment
[09:31:58.422]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.396] assign_globals() ... done
[09:31:58.422]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.397] plan(): Setting new future strategy stack:
[09:31:58.423]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.397] List of future strategies:
[09:31:58.397] 1. sequential:
[09:31:58.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:58.397]    - tweaked: FALSE
[09:31:58.397]    - call: NULL
[09:31:58.423]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.397] plan(): nbrOfWorkers() = 1
[09:31:58.423]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.398] plan(): Setting new future strategy stack:
[09:31:58.423]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.399] List of future strategies:
[09:31:58.399] 1. multisession:
[09:31:58.399]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.399]    - tweaked: FALSE
[09:31:58.399]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.423]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.403] plan(): nbrOfWorkers() = 1
[09:31:58.423]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.403] SequentialFuture started (and completed)
[09:31:58.423]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.403] - Launch lazy future ... done
[09:31:58.424]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:58.403] run() for ‘SequentialFuture’ ... done
[09:31:58.424] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[09:31:58.424] plan(): Setting new future strategy stack:
[09:31:58.424] List of future strategies:
[09:31:58.424] 1. multisession:
[09:31:58.424]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.424]    - tweaked: FALSE
[09:31:58.424]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.424] 2. sequential:
[09:31:58.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:58.424]    - tweaked: FALSE
[09:31:58.424]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.425] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:58.425] multisession:
[09:31:58.425] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:58.425] - tweaked: FALSE
[09:31:58.425] - call: plan(list(a = strategy1, b = strategy2))
[09:31:58.429] getGlobalsAndPackages() ...
[09:31:58.430] Not searching for globals
[09:31:58.430] - globals: [0] <none>
[09:31:58.430] getGlobalsAndPackages() ... DONE
[09:31:58.430] [local output] makeClusterPSOCK() ...
[09:31:58.434] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:58.434] [local output] Base port: 11674
[09:31:58.435] [local output] Getting setup options for 2 cluster nodes ...
[09:31:58.435] [local output]  - Node 1 of 2 ...
[09:31:58.435] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:58.436] [local output] Rscript port: 11674

[09:31:58.436] [local output]  - Node 2 of 2 ...
[09:31:58.437] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:58.437] [local output] Rscript port: 11674

[09:31:58.437] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:58.438] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:58.438] [local output] Setting up PSOCK nodes in parallel
[09:31:58.438] List of 36
[09:31:58.438]  $ worker          : chr "localhost"
[09:31:58.438]   ..- attr(*, "localhost")= logi TRUE
[09:31:58.438]  $ master          : chr "localhost"
[09:31:58.438]  $ port            : int 11674
[09:31:58.438]  $ connectTimeout  : num 120
[09:31:58.438]  $ timeout         : num 2592000
[09:31:58.438]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:58.438]  $ homogeneous     : logi TRUE
[09:31:58.438]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:58.438]  $ rscript_envs    : NULL
[09:31:58.438]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:58.438]  $ rscript_startup : NULL
[09:31:58.438]  $ rscript_sh      : chr "sh"
[09:31:58.438]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:58.438]  $ methods         : logi TRUE
[09:31:58.438]  $ socketOptions   : chr "no-delay"
[09:31:58.438]  $ useXDR          : logi FALSE
[09:31:58.438]  $ outfile         : chr "/dev/null"
[09:31:58.438]  $ renice          : int NA
[09:31:58.438]  $ rshcmd          : NULL
[09:31:58.438]  $ user            : chr(0) 
[09:31:58.438]  $ revtunnel       : logi FALSE
[09:31:58.438]  $ rshlogfile      : NULL
[09:31:58.438]  $ rshopts         : chr(0) 
[09:31:58.438]  $ rank            : int 1
[09:31:58.438]  $ manual          : logi FALSE
[09:31:58.438]  $ dryrun          : logi FALSE
[09:31:58.438]  $ quiet           : logi FALSE
[09:31:58.438]  $ setup_strategy  : chr "parallel"
[09:31:58.438]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:58.438]  $ pidfile         : chr "/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b9167cb7c822.pid"
[09:31:58.438]  $ rshcmd_label    : NULL
[09:31:58.438]  $ rsh_call        : NULL
[09:31:58.438]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:58.438]  $ localMachine    : logi TRUE
[09:31:58.438]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:58.438]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:58.438]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:58.438]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:58.438]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:58.438]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:58.438]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:58.438]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:58.438]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:58.438]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:58.438]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:58.438]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:58.438]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:58.438]  $ arguments       :List of 28
[09:31:58.438]   ..$ worker          : chr "localhost"
[09:31:58.438]   ..$ master          : NULL
[09:31:58.438]   ..$ port            : int 11674
[09:31:58.438]   ..$ connectTimeout  : num 120
[09:31:58.438]   ..$ timeout         : num 2592000
[09:31:58.438]   ..$ rscript         : NULL
[09:31:58.438]   ..$ homogeneous     : NULL
[09:31:58.438]   ..$ rscript_args    : NULL
[09:31:58.438]   ..$ rscript_envs    : NULL
[09:31:58.438]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:58.438]   ..$ rscript_startup : NULL
[09:31:58.438]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:58.438]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:58.438]   ..$ methods         : logi TRUE
[09:31:58.438]   ..$ socketOptions   : chr "no-delay"
[09:31:58.438]   ..$ useXDR          : logi FALSE
[09:31:58.438]   ..$ outfile         : chr "/dev/null"
[09:31:58.438]   ..$ renice          : int NA
[09:31:58.438]   ..$ rshcmd          : NULL
[09:31:58.438]   ..$ user            : NULL
[09:31:58.438]   ..$ revtunnel       : logi NA
[09:31:58.438]   ..$ rshlogfile      : NULL
[09:31:58.438]   ..$ rshopts         : NULL
[09:31:58.438]   ..$ rank            : int 1
[09:31:58.438]   ..$ manual          : logi FALSE
[09:31:58.438]   ..$ dryrun          : logi FALSE
[09:31:58.438]   ..$ quiet           : logi FALSE
[09:31:58.438]   ..$ setup_strategy  : chr "parallel"
[09:31:58.438]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:58.458] [local output] System call to launch all workers:
[09:31:58.458] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b9167cb7c822.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11674 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:58.458] [local output] Starting PSOCK main server
[09:31:58.459] [local output] Workers launched
[09:31:58.460] [local output] Waiting for workers to connect back
[09:31:58.460]  - [local output] 0 workers out of 2 ready
[09:31:58.694]  - [local output] 0 workers out of 2 ready
[09:31:58.695]  - [local output] 1 workers out of 2 ready
[09:31:58.701]  - [local output] 1 workers out of 2 ready
[09:31:58.701]  - [local output] 2 workers out of 2 ready
[09:31:58.701] [local output] Launching of workers completed
[09:31:58.701] [local output] Collecting session information from workers
[09:31:58.702] [local output]  - Worker #1 of 2
[09:31:58.702] [local output]  - Worker #2 of 2
[09:31:58.703] [local output] makeClusterPSOCK() ... done
[09:31:58.714] Packages needed by the future expression (n = 0): <none>
[09:31:58.714] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.715] {
[09:31:58.715]     {
[09:31:58.715]         {
[09:31:58.715]             ...future.startTime <- base::Sys.time()
[09:31:58.715]             {
[09:31:58.715]                 {
[09:31:58.715]                   {
[09:31:58.715]                     {
[09:31:58.715]                       {
[09:31:58.715]                         base::local({
[09:31:58.715]                           has_future <- base::requireNamespace("future", 
[09:31:58.715]                             quietly = TRUE)
[09:31:58.715]                           if (has_future) {
[09:31:58.715]                             ns <- base::getNamespace("future")
[09:31:58.715]                             version <- ns[[".package"]][["version"]]
[09:31:58.715]                             if (is.null(version)) 
[09:31:58.715]                               version <- utils::packageVersion("future")
[09:31:58.715]                           }
[09:31:58.715]                           else {
[09:31:58.715]                             version <- NULL
[09:31:58.715]                           }
[09:31:58.715]                           if (!has_future || version < "1.8.0") {
[09:31:58.715]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.715]                               "", base::R.version$version.string), 
[09:31:58.715]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.715]                                 base::R.version$platform, 8 * 
[09:31:58.715]                                   base::.Machine$sizeof.pointer), 
[09:31:58.715]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.715]                                 "release", "version")], collapse = " "), 
[09:31:58.715]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.715]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.715]                               info)
[09:31:58.715]                             info <- base::paste(info, collapse = "; ")
[09:31:58.715]                             if (!has_future) {
[09:31:58.715]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.715]                                 info)
[09:31:58.715]                             }
[09:31:58.715]                             else {
[09:31:58.715]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.715]                                 info, version)
[09:31:58.715]                             }
[09:31:58.715]                             base::stop(msg)
[09:31:58.715]                           }
[09:31:58.715]                         })
[09:31:58.715]                       }
[09:31:58.715]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.715]                       base::options(mc.cores = 1L)
[09:31:58.715]                     }
[09:31:58.715]                     base::local({
[09:31:58.715]                       for (pkg in "future") {
[09:31:58.715]                         base::loadNamespace(pkg)
[09:31:58.715]                         base::library(pkg, character.only = TRUE)
[09:31:58.715]                       }
[09:31:58.715]                     })
[09:31:58.715]                   }
[09:31:58.715]                   ...future.strategy.old <- future::plan("list")
[09:31:58.715]                   options(future.plan = NULL)
[09:31:58.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.715]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:58.715]                   {
[09:31:58.715]                     future <- SequentialFuture(..., envir = envir)
[09:31:58.715]                     if (!future$lazy) 
[09:31:58.715]                       future <- run(future)
[09:31:58.715]                     invisible(future)
[09:31:58.715]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.715]                 }
[09:31:58.715]                 ...future.workdir <- getwd()
[09:31:58.715]             }
[09:31:58.715]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.715]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.715]         }
[09:31:58.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.715]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.715]             base::names(...future.oldOptions))
[09:31:58.715]     }
[09:31:58.715]     if (FALSE) {
[09:31:58.715]     }
[09:31:58.715]     else {
[09:31:58.715]         if (TRUE) {
[09:31:58.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.715]                 open = "w")
[09:31:58.715]         }
[09:31:58.715]         else {
[09:31:58.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.715]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.715]         }
[09:31:58.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.715]             base::sink(type = "output", split = FALSE)
[09:31:58.715]             base::close(...future.stdout)
[09:31:58.715]         }, add = TRUE)
[09:31:58.715]     }
[09:31:58.715]     ...future.frame <- base::sys.nframe()
[09:31:58.715]     ...future.conditions <- base::list()
[09:31:58.715]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.715]     if (FALSE) {
[09:31:58.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.715]     }
[09:31:58.715]     ...future.result <- base::tryCatch({
[09:31:58.715]         base::withCallingHandlers({
[09:31:58.715]             ...future.value <- base::withVisible(base::local({
[09:31:58.715]                 ...future.makeSendCondition <- base::local({
[09:31:58.715]                   sendCondition <- NULL
[09:31:58.715]                   function(frame = 1L) {
[09:31:58.715]                     if (is.function(sendCondition)) 
[09:31:58.715]                       return(sendCondition)
[09:31:58.715]                     ns <- getNamespace("parallel")
[09:31:58.715]                     if (exists("sendData", mode = "function", 
[09:31:58.715]                       envir = ns)) {
[09:31:58.715]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:58.715]                         envir = ns)
[09:31:58.715]                       envir <- sys.frame(frame)
[09:31:58.715]                       master <- NULL
[09:31:58.715]                       while (!identical(envir, .GlobalEnv) && 
[09:31:58.715]                         !identical(envir, emptyenv())) {
[09:31:58.715]                         if (exists("master", mode = "list", envir = envir, 
[09:31:58.715]                           inherits = FALSE)) {
[09:31:58.715]                           master <- get("master", mode = "list", 
[09:31:58.715]                             envir = envir, inherits = FALSE)
[09:31:58.715]                           if (inherits(master, c("SOCKnode", 
[09:31:58.715]                             "SOCK0node"))) {
[09:31:58.715]                             sendCondition <<- function(cond) {
[09:31:58.715]                               data <- list(type = "VALUE", value = cond, 
[09:31:58.715]                                 success = TRUE)
[09:31:58.715]                               parallel_sendData(master, data)
[09:31:58.715]                             }
[09:31:58.715]                             return(sendCondition)
[09:31:58.715]                           }
[09:31:58.715]                         }
[09:31:58.715]                         frame <- frame + 1L
[09:31:58.715]                         envir <- sys.frame(frame)
[09:31:58.715]                       }
[09:31:58.715]                     }
[09:31:58.715]                     sendCondition <<- function(cond) NULL
[09:31:58.715]                   }
[09:31:58.715]                 })
[09:31:58.715]                 withCallingHandlers({
[09:31:58.715]                   NA
[09:31:58.715]                 }, immediateCondition = function(cond) {
[09:31:58.715]                   sendCondition <- ...future.makeSendCondition()
[09:31:58.715]                   sendCondition(cond)
[09:31:58.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.715]                   {
[09:31:58.715]                     inherits <- base::inherits
[09:31:58.715]                     invokeRestart <- base::invokeRestart
[09:31:58.715]                     is.null <- base::is.null
[09:31:58.715]                     muffled <- FALSE
[09:31:58.715]                     if (inherits(cond, "message")) {
[09:31:58.715]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.715]                       if (muffled) 
[09:31:58.715]                         invokeRestart("muffleMessage")
[09:31:58.715]                     }
[09:31:58.715]                     else if (inherits(cond, "warning")) {
[09:31:58.715]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.715]                       if (muffled) 
[09:31:58.715]                         invokeRestart("muffleWarning")
[09:31:58.715]                     }
[09:31:58.715]                     else if (inherits(cond, "condition")) {
[09:31:58.715]                       if (!is.null(pattern)) {
[09:31:58.715]                         computeRestarts <- base::computeRestarts
[09:31:58.715]                         grepl <- base::grepl
[09:31:58.715]                         restarts <- computeRestarts(cond)
[09:31:58.715]                         for (restart in restarts) {
[09:31:58.715]                           name <- restart$name
[09:31:58.715]                           if (is.null(name)) 
[09:31:58.715]                             next
[09:31:58.715]                           if (!grepl(pattern, name)) 
[09:31:58.715]                             next
[09:31:58.715]                           invokeRestart(restart)
[09:31:58.715]                           muffled <- TRUE
[09:31:58.715]                           break
[09:31:58.715]                         }
[09:31:58.715]                       }
[09:31:58.715]                     }
[09:31:58.715]                     invisible(muffled)
[09:31:58.715]                   }
[09:31:58.715]                   muffleCondition(cond)
[09:31:58.715]                 })
[09:31:58.715]             }))
[09:31:58.715]             future::FutureResult(value = ...future.value$value, 
[09:31:58.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.715]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.715]                     ...future.globalenv.names))
[09:31:58.715]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.715]         }, condition = base::local({
[09:31:58.715]             c <- base::c
[09:31:58.715]             inherits <- base::inherits
[09:31:58.715]             invokeRestart <- base::invokeRestart
[09:31:58.715]             length <- base::length
[09:31:58.715]             list <- base::list
[09:31:58.715]             seq.int <- base::seq.int
[09:31:58.715]             signalCondition <- base::signalCondition
[09:31:58.715]             sys.calls <- base::sys.calls
[09:31:58.715]             `[[` <- base::`[[`
[09:31:58.715]             `+` <- base::`+`
[09:31:58.715]             `<<-` <- base::`<<-`
[09:31:58.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.715]                   3L)]
[09:31:58.715]             }
[09:31:58.715]             function(cond) {
[09:31:58.715]                 is_error <- inherits(cond, "error")
[09:31:58.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.715]                   NULL)
[09:31:58.715]                 if (is_error) {
[09:31:58.715]                   sessionInformation <- function() {
[09:31:58.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.715]                       search = base::search(), system = base::Sys.info())
[09:31:58.715]                   }
[09:31:58.715]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.715]                     cond$call), session = sessionInformation(), 
[09:31:58.715]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.715]                   signalCondition(cond)
[09:31:58.715]                 }
[09:31:58.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.715]                 "immediateCondition"))) {
[09:31:58.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.715]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.715]                   if (TRUE && !signal) {
[09:31:58.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.715]                     {
[09:31:58.715]                       inherits <- base::inherits
[09:31:58.715]                       invokeRestart <- base::invokeRestart
[09:31:58.715]                       is.null <- base::is.null
[09:31:58.715]                       muffled <- FALSE
[09:31:58.715]                       if (inherits(cond, "message")) {
[09:31:58.715]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.715]                         if (muffled) 
[09:31:58.715]                           invokeRestart("muffleMessage")
[09:31:58.715]                       }
[09:31:58.715]                       else if (inherits(cond, "warning")) {
[09:31:58.715]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.715]                         if (muffled) 
[09:31:58.715]                           invokeRestart("muffleWarning")
[09:31:58.715]                       }
[09:31:58.715]                       else if (inherits(cond, "condition")) {
[09:31:58.715]                         if (!is.null(pattern)) {
[09:31:58.715]                           computeRestarts <- base::computeRestarts
[09:31:58.715]                           grepl <- base::grepl
[09:31:58.715]                           restarts <- computeRestarts(cond)
[09:31:58.715]                           for (restart in restarts) {
[09:31:58.715]                             name <- restart$name
[09:31:58.715]                             if (is.null(name)) 
[09:31:58.715]                               next
[09:31:58.715]                             if (!grepl(pattern, name)) 
[09:31:58.715]                               next
[09:31:58.715]                             invokeRestart(restart)
[09:31:58.715]                             muffled <- TRUE
[09:31:58.715]                             break
[09:31:58.715]                           }
[09:31:58.715]                         }
[09:31:58.715]                       }
[09:31:58.715]                       invisible(muffled)
[09:31:58.715]                     }
[09:31:58.715]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.715]                   }
[09:31:58.715]                 }
[09:31:58.715]                 else {
[09:31:58.715]                   if (TRUE) {
[09:31:58.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.715]                     {
[09:31:58.715]                       inherits <- base::inherits
[09:31:58.715]                       invokeRestart <- base::invokeRestart
[09:31:58.715]                       is.null <- base::is.null
[09:31:58.715]                       muffled <- FALSE
[09:31:58.715]                       if (inherits(cond, "message")) {
[09:31:58.715]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.715]                         if (muffled) 
[09:31:58.715]                           invokeRestart("muffleMessage")
[09:31:58.715]                       }
[09:31:58.715]                       else if (inherits(cond, "warning")) {
[09:31:58.715]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.715]                         if (muffled) 
[09:31:58.715]                           invokeRestart("muffleWarning")
[09:31:58.715]                       }
[09:31:58.715]                       else if (inherits(cond, "condition")) {
[09:31:58.715]                         if (!is.null(pattern)) {
[09:31:58.715]                           computeRestarts <- base::computeRestarts
[09:31:58.715]                           grepl <- base::grepl
[09:31:58.715]                           restarts <- computeRestarts(cond)
[09:31:58.715]                           for (restart in restarts) {
[09:31:58.715]                             name <- restart$name
[09:31:58.715]                             if (is.null(name)) 
[09:31:58.715]                               next
[09:31:58.715]                             if (!grepl(pattern, name)) 
[09:31:58.715]                               next
[09:31:58.715]                             invokeRestart(restart)
[09:31:58.715]                             muffled <- TRUE
[09:31:58.715]                             break
[09:31:58.715]                           }
[09:31:58.715]                         }
[09:31:58.715]                       }
[09:31:58.715]                       invisible(muffled)
[09:31:58.715]                     }
[09:31:58.715]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.715]                   }
[09:31:58.715]                 }
[09:31:58.715]             }
[09:31:58.715]         }))
[09:31:58.715]     }, error = function(ex) {
[09:31:58.715]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.715]                 ...future.rng), started = ...future.startTime, 
[09:31:58.715]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.715]             version = "1.8"), class = "FutureResult")
[09:31:58.715]     }, finally = {
[09:31:58.715]         if (!identical(...future.workdir, getwd())) 
[09:31:58.715]             setwd(...future.workdir)
[09:31:58.715]         {
[09:31:58.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.715]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.715]             }
[09:31:58.715]             base::options(...future.oldOptions)
[09:31:58.715]             if (.Platform$OS.type == "windows") {
[09:31:58.715]                 old_names <- names(...future.oldEnvVars)
[09:31:58.715]                 envs <- base::Sys.getenv()
[09:31:58.715]                 names <- names(envs)
[09:31:58.715]                 common <- intersect(names, old_names)
[09:31:58.715]                 added <- setdiff(names, old_names)
[09:31:58.715]                 removed <- setdiff(old_names, names)
[09:31:58.715]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.715]                   envs[common]]
[09:31:58.715]                 NAMES <- toupper(changed)
[09:31:58.715]                 args <- list()
[09:31:58.715]                 for (kk in seq_along(NAMES)) {
[09:31:58.715]                   name <- changed[[kk]]
[09:31:58.715]                   NAME <- NAMES[[kk]]
[09:31:58.715]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.715]                     next
[09:31:58.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.715]                 }
[09:31:58.715]                 NAMES <- toupper(added)
[09:31:58.715]                 for (kk in seq_along(NAMES)) {
[09:31:58.715]                   name <- added[[kk]]
[09:31:58.715]                   NAME <- NAMES[[kk]]
[09:31:58.715]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.715]                     next
[09:31:58.715]                   args[[name]] <- ""
[09:31:58.715]                 }
[09:31:58.715]                 NAMES <- toupper(removed)
[09:31:58.715]                 for (kk in seq_along(NAMES)) {
[09:31:58.715]                   name <- removed[[kk]]
[09:31:58.715]                   NAME <- NAMES[[kk]]
[09:31:58.715]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.715]                     next
[09:31:58.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.715]                 }
[09:31:58.715]                 if (length(args) > 0) 
[09:31:58.715]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.715]             }
[09:31:58.715]             else {
[09:31:58.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.715]             }
[09:31:58.715]             {
[09:31:58.715]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.715]                   0L) {
[09:31:58.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.715]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.715]                   base::options(opts)
[09:31:58.715]                 }
[09:31:58.715]                 {
[09:31:58.715]                   {
[09:31:58.715]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.715]                     NULL
[09:31:58.715]                   }
[09:31:58.715]                   options(future.plan = NULL)
[09:31:58.715]                   if (is.na(NA_character_)) 
[09:31:58.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.715]                     .init = FALSE)
[09:31:58.715]                 }
[09:31:58.715]             }
[09:31:58.715]         }
[09:31:58.715]     })
[09:31:58.715]     if (TRUE) {
[09:31:58.715]         base::sink(type = "output", split = FALSE)
[09:31:58.715]         if (TRUE) {
[09:31:58.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.715]         }
[09:31:58.715]         else {
[09:31:58.715]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.715]         }
[09:31:58.715]         base::close(...future.stdout)
[09:31:58.715]         ...future.stdout <- NULL
[09:31:58.715]     }
[09:31:58.715]     ...future.result$conditions <- ...future.conditions
[09:31:58.715]     ...future.result$finished <- base::Sys.time()
[09:31:58.715]     ...future.result
[09:31:58.715] }
[09:31:58.765] MultisessionFuture started
[09:31:58.765] result() for ClusterFuture ...
[09:31:58.765] receiveMessageFromWorker() for ClusterFuture ...
[09:31:58.765] - Validating connection of MultisessionFuture
[09:31:58.799] - received message: FutureResult
[09:31:58.799] - Received FutureResult
[09:31:58.799] - Erased future from FutureRegistry
[09:31:58.799] result() for ClusterFuture ...
[09:31:58.799] - result already collected: FutureResult
[09:31:58.800] result() for ClusterFuture ... done
[09:31:58.800] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:58.800] result() for ClusterFuture ... done
[09:31:58.800] result() for ClusterFuture ...
[09:31:58.800] - result already collected: FutureResult
[09:31:58.800] result() for ClusterFuture ... done
[09:31:58.800] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:58.804] plan(): nbrOfWorkers() = 2
[09:31:58.804] getGlobalsAndPackages() ...
[09:31:58.804] Searching for globals...
[09:31:58.822] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:58.822] Searching for globals ... DONE
[09:31:58.822] Resolving globals: FALSE
[09:31:58.823] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[09:31:58.824] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:58.824] - globals: [2] ‘nested’, ‘strategy2’
[09:31:58.824] - packages: [1] ‘future’
[09:31:58.824] getGlobalsAndPackages() ... DONE
[09:31:58.824] run() for ‘Future’ ...
[09:31:58.825] - state: ‘created’
[09:31:58.825] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:58.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:58.844]   - Field: ‘node’
[09:31:58.844]   - Field: ‘label’
[09:31:58.844]   - Field: ‘local’
[09:31:58.844]   - Field: ‘owner’
[09:31:58.844]   - Field: ‘envir’
[09:31:58.844]   - Field: ‘workers’
[09:31:58.844]   - Field: ‘packages’
[09:31:58.845]   - Field: ‘gc’
[09:31:58.845]   - Field: ‘conditions’
[09:31:58.845]   - Field: ‘persistent’
[09:31:58.845]   - Field: ‘expr’
[09:31:58.845]   - Field: ‘uuid’
[09:31:58.845]   - Field: ‘seed’
[09:31:58.845]   - Field: ‘version’
[09:31:58.845]   - Field: ‘result’
[09:31:58.845]   - Field: ‘asynchronous’
[09:31:58.845]   - Field: ‘calls’
[09:31:58.845]   - Field: ‘globals’
[09:31:58.846]   - Field: ‘stdout’
[09:31:58.846]   - Field: ‘earlySignal’
[09:31:58.846]   - Field: ‘lazy’
[09:31:58.846]   - Field: ‘state’
[09:31:58.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:58.846] - Launch lazy future ...
[09:31:58.846] Packages needed by the future expression (n = 1): ‘future’
[09:31:58.846] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.847] {
[09:31:58.847]     {
[09:31:58.847]         {
[09:31:58.847]             ...future.startTime <- base::Sys.time()
[09:31:58.847]             {
[09:31:58.847]                 {
[09:31:58.847]                   {
[09:31:58.847]                     {
[09:31:58.847]                       {
[09:31:58.847]                         base::local({
[09:31:58.847]                           has_future <- base::requireNamespace("future", 
[09:31:58.847]                             quietly = TRUE)
[09:31:58.847]                           if (has_future) {
[09:31:58.847]                             ns <- base::getNamespace("future")
[09:31:58.847]                             version <- ns[[".package"]][["version"]]
[09:31:58.847]                             if (is.null(version)) 
[09:31:58.847]                               version <- utils::packageVersion("future")
[09:31:58.847]                           }
[09:31:58.847]                           else {
[09:31:58.847]                             version <- NULL
[09:31:58.847]                           }
[09:31:58.847]                           if (!has_future || version < "1.8.0") {
[09:31:58.847]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.847]                               "", base::R.version$version.string), 
[09:31:58.847]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.847]                                 base::R.version$platform, 8 * 
[09:31:58.847]                                   base::.Machine$sizeof.pointer), 
[09:31:58.847]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.847]                                 "release", "version")], collapse = " "), 
[09:31:58.847]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.847]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.847]                               info)
[09:31:58.847]                             info <- base::paste(info, collapse = "; ")
[09:31:58.847]                             if (!has_future) {
[09:31:58.847]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.847]                                 info)
[09:31:58.847]                             }
[09:31:58.847]                             else {
[09:31:58.847]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.847]                                 info, version)
[09:31:58.847]                             }
[09:31:58.847]                             base::stop(msg)
[09:31:58.847]                           }
[09:31:58.847]                         })
[09:31:58.847]                       }
[09:31:58.847]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.847]                       base::options(mc.cores = 1L)
[09:31:58.847]                     }
[09:31:58.847]                     base::local({
[09:31:58.847]                       for (pkg in "future") {
[09:31:58.847]                         base::loadNamespace(pkg)
[09:31:58.847]                         base::library(pkg, character.only = TRUE)
[09:31:58.847]                       }
[09:31:58.847]                     })
[09:31:58.847]                   }
[09:31:58.847]                   ...future.strategy.old <- future::plan("list")
[09:31:58.847]                   options(future.plan = NULL)
[09:31:58.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.847]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:58.847]                   {
[09:31:58.847]                     future <- SequentialFuture(..., envir = envir)
[09:31:58.847]                     if (!future$lazy) 
[09:31:58.847]                       future <- run(future)
[09:31:58.847]                     invisible(future)
[09:31:58.847]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.847]                 }
[09:31:58.847]                 ...future.workdir <- getwd()
[09:31:58.847]             }
[09:31:58.847]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.847]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.847]         }
[09:31:58.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.847]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.847]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.847]             base::names(...future.oldOptions))
[09:31:58.847]     }
[09:31:58.847]     if (FALSE) {
[09:31:58.847]     }
[09:31:58.847]     else {
[09:31:58.847]         if (TRUE) {
[09:31:58.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.847]                 open = "w")
[09:31:58.847]         }
[09:31:58.847]         else {
[09:31:58.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.847]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.847]         }
[09:31:58.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.847]             base::sink(type = "output", split = FALSE)
[09:31:58.847]             base::close(...future.stdout)
[09:31:58.847]         }, add = TRUE)
[09:31:58.847]     }
[09:31:58.847]     ...future.frame <- base::sys.nframe()
[09:31:58.847]     ...future.conditions <- base::list()
[09:31:58.847]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.847]     if (FALSE) {
[09:31:58.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.847]     }
[09:31:58.847]     ...future.result <- base::tryCatch({
[09:31:58.847]         base::withCallingHandlers({
[09:31:58.847]             ...future.value <- base::withVisible(base::local({
[09:31:58.847]                 ...future.makeSendCondition <- base::local({
[09:31:58.847]                   sendCondition <- NULL
[09:31:58.847]                   function(frame = 1L) {
[09:31:58.847]                     if (is.function(sendCondition)) 
[09:31:58.847]                       return(sendCondition)
[09:31:58.847]                     ns <- getNamespace("parallel")
[09:31:58.847]                     if (exists("sendData", mode = "function", 
[09:31:58.847]                       envir = ns)) {
[09:31:58.847]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:58.847]                         envir = ns)
[09:31:58.847]                       envir <- sys.frame(frame)
[09:31:58.847]                       master <- NULL
[09:31:58.847]                       while (!identical(envir, .GlobalEnv) && 
[09:31:58.847]                         !identical(envir, emptyenv())) {
[09:31:58.847]                         if (exists("master", mode = "list", envir = envir, 
[09:31:58.847]                           inherits = FALSE)) {
[09:31:58.847]                           master <- get("master", mode = "list", 
[09:31:58.847]                             envir = envir, inherits = FALSE)
[09:31:58.847]                           if (inherits(master, c("SOCKnode", 
[09:31:58.847]                             "SOCK0node"))) {
[09:31:58.847]                             sendCondition <<- function(cond) {
[09:31:58.847]                               data <- list(type = "VALUE", value = cond, 
[09:31:58.847]                                 success = TRUE)
[09:31:58.847]                               parallel_sendData(master, data)
[09:31:58.847]                             }
[09:31:58.847]                             return(sendCondition)
[09:31:58.847]                           }
[09:31:58.847]                         }
[09:31:58.847]                         frame <- frame + 1L
[09:31:58.847]                         envir <- sys.frame(frame)
[09:31:58.847]                       }
[09:31:58.847]                     }
[09:31:58.847]                     sendCondition <<- function(cond) NULL
[09:31:58.847]                   }
[09:31:58.847]                 })
[09:31:58.847]                 withCallingHandlers({
[09:31:58.847]                   {
[09:31:58.847]                     a <- 1L
[09:31:58.847]                     plan_a <- unclass(future::plan("list"))
[09:31:58.847]                     nested_a <- nested[-1]
[09:31:58.847]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:58.847]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:58.847]                       strategy2))
[09:31:58.847]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:58.847]                       "init") <- NULL
[09:31:58.847]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:58.847]                       "init") <- NULL
[09:31:58.847]                     stopifnot(all.equal(plan_a, nested_a))
[09:31:58.847]                     y %<-% {
[09:31:58.847]                       b <- 2L
[09:31:58.847]                       plan_b <- future::plan("list")
[09:31:58.847]                       nested_b <- nested_a[-1]
[09:31:58.847]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:58.847]                         1L, inherits(plan_b[[1]], "future"), 
[09:31:58.847]                         inherits(future::plan("next"), "sequential"))
[09:31:58.847]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:58.847]                         b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:58.847]                     }
[09:31:58.847]                     y
[09:31:58.847]                   }
[09:31:58.847]                 }, immediateCondition = function(cond) {
[09:31:58.847]                   sendCondition <- ...future.makeSendCondition()
[09:31:58.847]                   sendCondition(cond)
[09:31:58.847]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.847]                   {
[09:31:58.847]                     inherits <- base::inherits
[09:31:58.847]                     invokeRestart <- base::invokeRestart
[09:31:58.847]                     is.null <- base::is.null
[09:31:58.847]                     muffled <- FALSE
[09:31:58.847]                     if (inherits(cond, "message")) {
[09:31:58.847]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.847]                       if (muffled) 
[09:31:58.847]                         invokeRestart("muffleMessage")
[09:31:58.847]                     }
[09:31:58.847]                     else if (inherits(cond, "warning")) {
[09:31:58.847]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.847]                       if (muffled) 
[09:31:58.847]                         invokeRestart("muffleWarning")
[09:31:58.847]                     }
[09:31:58.847]                     else if (inherits(cond, "condition")) {
[09:31:58.847]                       if (!is.null(pattern)) {
[09:31:58.847]                         computeRestarts <- base::computeRestarts
[09:31:58.847]                         grepl <- base::grepl
[09:31:58.847]                         restarts <- computeRestarts(cond)
[09:31:58.847]                         for (restart in restarts) {
[09:31:58.847]                           name <- restart$name
[09:31:58.847]                           if (is.null(name)) 
[09:31:58.847]                             next
[09:31:58.847]                           if (!grepl(pattern, name)) 
[09:31:58.847]                             next
[09:31:58.847]                           invokeRestart(restart)
[09:31:58.847]                           muffled <- TRUE
[09:31:58.847]                           break
[09:31:58.847]                         }
[09:31:58.847]                       }
[09:31:58.847]                     }
[09:31:58.847]                     invisible(muffled)
[09:31:58.847]                   }
[09:31:58.847]                   muffleCondition(cond)
[09:31:58.847]                 })
[09:31:58.847]             }))
[09:31:58.847]             future::FutureResult(value = ...future.value$value, 
[09:31:58.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.847]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.847]                     ...future.globalenv.names))
[09:31:58.847]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.847]         }, condition = base::local({
[09:31:58.847]             c <- base::c
[09:31:58.847]             inherits <- base::inherits
[09:31:58.847]             invokeRestart <- base::invokeRestart
[09:31:58.847]             length <- base::length
[09:31:58.847]             list <- base::list
[09:31:58.847]             seq.int <- base::seq.int
[09:31:58.847]             signalCondition <- base::signalCondition
[09:31:58.847]             sys.calls <- base::sys.calls
[09:31:58.847]             `[[` <- base::`[[`
[09:31:58.847]             `+` <- base::`+`
[09:31:58.847]             `<<-` <- base::`<<-`
[09:31:58.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.847]                   3L)]
[09:31:58.847]             }
[09:31:58.847]             function(cond) {
[09:31:58.847]                 is_error <- inherits(cond, "error")
[09:31:58.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.847]                   NULL)
[09:31:58.847]                 if (is_error) {
[09:31:58.847]                   sessionInformation <- function() {
[09:31:58.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.847]                       search = base::search(), system = base::Sys.info())
[09:31:58.847]                   }
[09:31:58.847]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.847]                     cond$call), session = sessionInformation(), 
[09:31:58.847]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.847]                   signalCondition(cond)
[09:31:58.847]                 }
[09:31:58.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.847]                 "immediateCondition"))) {
[09:31:58.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.847]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.847]                   if (TRUE && !signal) {
[09:31:58.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.847]                     {
[09:31:58.847]                       inherits <- base::inherits
[09:31:58.847]                       invokeRestart <- base::invokeRestart
[09:31:58.847]                       is.null <- base::is.null
[09:31:58.847]                       muffled <- FALSE
[09:31:58.847]                       if (inherits(cond, "message")) {
[09:31:58.847]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.847]                         if (muffled) 
[09:31:58.847]                           invokeRestart("muffleMessage")
[09:31:58.847]                       }
[09:31:58.847]                       else if (inherits(cond, "warning")) {
[09:31:58.847]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.847]                         if (muffled) 
[09:31:58.847]                           invokeRestart("muffleWarning")
[09:31:58.847]                       }
[09:31:58.847]                       else if (inherits(cond, "condition")) {
[09:31:58.847]                         if (!is.null(pattern)) {
[09:31:58.847]                           computeRestarts <- base::computeRestarts
[09:31:58.847]                           grepl <- base::grepl
[09:31:58.847]                           restarts <- computeRestarts(cond)
[09:31:58.847]                           for (restart in restarts) {
[09:31:58.847]                             name <- restart$name
[09:31:58.847]                             if (is.null(name)) 
[09:31:58.847]                               next
[09:31:58.847]                             if (!grepl(pattern, name)) 
[09:31:58.847]                               next
[09:31:58.847]                             invokeRestart(restart)
[09:31:58.847]                             muffled <- TRUE
[09:31:58.847]                             break
[09:31:58.847]                           }
[09:31:58.847]                         }
[09:31:58.847]                       }
[09:31:58.847]                       invisible(muffled)
[09:31:58.847]                     }
[09:31:58.847]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.847]                   }
[09:31:58.847]                 }
[09:31:58.847]                 else {
[09:31:58.847]                   if (TRUE) {
[09:31:58.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.847]                     {
[09:31:58.847]                       inherits <- base::inherits
[09:31:58.847]                       invokeRestart <- base::invokeRestart
[09:31:58.847]                       is.null <- base::is.null
[09:31:58.847]                       muffled <- FALSE
[09:31:58.847]                       if (inherits(cond, "message")) {
[09:31:58.847]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.847]                         if (muffled) 
[09:31:58.847]                           invokeRestart("muffleMessage")
[09:31:58.847]                       }
[09:31:58.847]                       else if (inherits(cond, "warning")) {
[09:31:58.847]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.847]                         if (muffled) 
[09:31:58.847]                           invokeRestart("muffleWarning")
[09:31:58.847]                       }
[09:31:58.847]                       else if (inherits(cond, "condition")) {
[09:31:58.847]                         if (!is.null(pattern)) {
[09:31:58.847]                           computeRestarts <- base::computeRestarts
[09:31:58.847]                           grepl <- base::grepl
[09:31:58.847]                           restarts <- computeRestarts(cond)
[09:31:58.847]                           for (restart in restarts) {
[09:31:58.847]                             name <- restart$name
[09:31:58.847]                             if (is.null(name)) 
[09:31:58.847]                               next
[09:31:58.847]                             if (!grepl(pattern, name)) 
[09:31:58.847]                               next
[09:31:58.847]                             invokeRestart(restart)
[09:31:58.847]                             muffled <- TRUE
[09:31:58.847]                             break
[09:31:58.847]                           }
[09:31:58.847]                         }
[09:31:58.847]                       }
[09:31:58.847]                       invisible(muffled)
[09:31:58.847]                     }
[09:31:58.847]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.847]                   }
[09:31:58.847]                 }
[09:31:58.847]             }
[09:31:58.847]         }))
[09:31:58.847]     }, error = function(ex) {
[09:31:58.847]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.847]                 ...future.rng), started = ...future.startTime, 
[09:31:58.847]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.847]             version = "1.8"), class = "FutureResult")
[09:31:58.847]     }, finally = {
[09:31:58.847]         if (!identical(...future.workdir, getwd())) 
[09:31:58.847]             setwd(...future.workdir)
[09:31:58.847]         {
[09:31:58.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.847]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.847]             }
[09:31:58.847]             base::options(...future.oldOptions)
[09:31:58.847]             if (.Platform$OS.type == "windows") {
[09:31:58.847]                 old_names <- names(...future.oldEnvVars)
[09:31:58.847]                 envs <- base::Sys.getenv()
[09:31:58.847]                 names <- names(envs)
[09:31:58.847]                 common <- intersect(names, old_names)
[09:31:58.847]                 added <- setdiff(names, old_names)
[09:31:58.847]                 removed <- setdiff(old_names, names)
[09:31:58.847]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.847]                   envs[common]]
[09:31:58.847]                 NAMES <- toupper(changed)
[09:31:58.847]                 args <- list()
[09:31:58.847]                 for (kk in seq_along(NAMES)) {
[09:31:58.847]                   name <- changed[[kk]]
[09:31:58.847]                   NAME <- NAMES[[kk]]
[09:31:58.847]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.847]                     next
[09:31:58.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.847]                 }
[09:31:58.847]                 NAMES <- toupper(added)
[09:31:58.847]                 for (kk in seq_along(NAMES)) {
[09:31:58.847]                   name <- added[[kk]]
[09:31:58.847]                   NAME <- NAMES[[kk]]
[09:31:58.847]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.847]                     next
[09:31:58.847]                   args[[name]] <- ""
[09:31:58.847]                 }
[09:31:58.847]                 NAMES <- toupper(removed)
[09:31:58.847]                 for (kk in seq_along(NAMES)) {
[09:31:58.847]                   name <- removed[[kk]]
[09:31:58.847]                   NAME <- NAMES[[kk]]
[09:31:58.847]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.847]                     next
[09:31:58.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.847]                 }
[09:31:58.847]                 if (length(args) > 0) 
[09:31:58.847]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.847]             }
[09:31:58.847]             else {
[09:31:58.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.847]             }
[09:31:58.847]             {
[09:31:58.847]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.847]                   0L) {
[09:31:58.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.847]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.847]                   base::options(opts)
[09:31:58.847]                 }
[09:31:58.847]                 {
[09:31:58.847]                   {
[09:31:58.847]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.847]                     NULL
[09:31:58.847]                   }
[09:31:58.847]                   options(future.plan = NULL)
[09:31:58.847]                   if (is.na(NA_character_)) 
[09:31:58.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.847]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.847]                     .init = FALSE)
[09:31:58.847]                 }
[09:31:58.847]             }
[09:31:58.847]         }
[09:31:58.847]     })
[09:31:58.847]     if (TRUE) {
[09:31:58.847]         base::sink(type = "output", split = FALSE)
[09:31:58.847]         if (TRUE) {
[09:31:58.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.847]         }
[09:31:58.847]         else {
[09:31:58.847]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.847]         }
[09:31:58.847]         base::close(...future.stdout)
[09:31:58.847]         ...future.stdout <- NULL
[09:31:58.847]     }
[09:31:58.847]     ...future.result$conditions <- ...future.conditions
[09:31:58.847]     ...future.result$finished <- base::Sys.time()
[09:31:58.847]     ...future.result
[09:31:58.847] }
[09:31:58.850] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[09:31:58.850] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[09:31:58.892] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[09:31:58.892] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[09:31:58.893] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[09:31:58.893] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[09:31:58.893] MultisessionFuture started
[09:31:58.893] - Launch lazy future ... done
[09:31:58.893] run() for ‘MultisessionFuture’ ... done
[09:31:58.894] result() for ClusterFuture ...
[09:31:58.894] receiveMessageFromWorker() for ClusterFuture ...
[09:31:58.894] - Validating connection of MultisessionFuture
[09:31:58.958] - received message: FutureResult
[09:31:58.958] - Received FutureResult
[09:31:58.958] - Erased future from FutureRegistry
[09:31:58.959] result() for ClusterFuture ...
[09:31:58.959] - result already collected: FutureResult
[09:31:58.959] result() for ClusterFuture ... done
[09:31:58.959] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:58.959] result() for ClusterFuture ... done
[09:31:58.959] result() for ClusterFuture ...
[09:31:58.959] - result already collected: FutureResult
[09:31:58.959] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:58.964] getGlobalsAndPackages() ...
[09:31:58.964] Searching for globals...
[09:31:58.965] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:58.965] Searching for globals ... DONE
[09:31:58.966] Resolving globals: FALSE
[09:31:58.966] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:58.966] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:58.967] - globals: [1] ‘data’
[09:31:58.967] - packages: [1] ‘future’
[09:31:58.967] getGlobalsAndPackages() ... DONE
[09:31:58.967] run() for ‘Future’ ...
[09:31:58.967] - state: ‘created’
[09:31:58.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:58.981] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:58.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:58.982]   - Field: ‘node’
[09:31:58.982]   - Field: ‘label’
[09:31:58.982]   - Field: ‘local’
[09:31:58.982]   - Field: ‘owner’
[09:31:58.982]   - Field: ‘envir’
[09:31:58.982]   - Field: ‘workers’
[09:31:58.982]   - Field: ‘packages’
[09:31:58.982]   - Field: ‘gc’
[09:31:58.982]   - Field: ‘conditions’
[09:31:58.982]   - Field: ‘persistent’
[09:31:58.983]   - Field: ‘expr’
[09:31:58.983]   - Field: ‘uuid’
[09:31:58.983]   - Field: ‘seed’
[09:31:58.983]   - Field: ‘version’
[09:31:58.983]   - Field: ‘result’
[09:31:58.983]   - Field: ‘asynchronous’
[09:31:58.983]   - Field: ‘calls’
[09:31:58.983]   - Field: ‘globals’
[09:31:58.983]   - Field: ‘stdout’
[09:31:58.983]   - Field: ‘earlySignal’
[09:31:58.983]   - Field: ‘lazy’
[09:31:58.984]   - Field: ‘state’
[09:31:58.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:58.984] - Launch lazy future ...
[09:31:58.984] Packages needed by the future expression (n = 1): ‘future’
[09:31:58.984] Packages needed by future strategies (n = 1): ‘future’
[09:31:58.985] {
[09:31:58.985]     {
[09:31:58.985]         {
[09:31:58.985]             ...future.startTime <- base::Sys.time()
[09:31:58.985]             {
[09:31:58.985]                 {
[09:31:58.985]                   {
[09:31:58.985]                     {
[09:31:58.985]                       {
[09:31:58.985]                         base::local({
[09:31:58.985]                           has_future <- base::requireNamespace("future", 
[09:31:58.985]                             quietly = TRUE)
[09:31:58.985]                           if (has_future) {
[09:31:58.985]                             ns <- base::getNamespace("future")
[09:31:58.985]                             version <- ns[[".package"]][["version"]]
[09:31:58.985]                             if (is.null(version)) 
[09:31:58.985]                               version <- utils::packageVersion("future")
[09:31:58.985]                           }
[09:31:58.985]                           else {
[09:31:58.985]                             version <- NULL
[09:31:58.985]                           }
[09:31:58.985]                           if (!has_future || version < "1.8.0") {
[09:31:58.985]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:58.985]                               "", base::R.version$version.string), 
[09:31:58.985]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:58.985]                                 base::R.version$platform, 8 * 
[09:31:58.985]                                   base::.Machine$sizeof.pointer), 
[09:31:58.985]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:58.985]                                 "release", "version")], collapse = " "), 
[09:31:58.985]                               hostname = base::Sys.info()[["nodename"]])
[09:31:58.985]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:58.985]                               info)
[09:31:58.985]                             info <- base::paste(info, collapse = "; ")
[09:31:58.985]                             if (!has_future) {
[09:31:58.985]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:58.985]                                 info)
[09:31:58.985]                             }
[09:31:58.985]                             else {
[09:31:58.985]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:58.985]                                 info, version)
[09:31:58.985]                             }
[09:31:58.985]                             base::stop(msg)
[09:31:58.985]                           }
[09:31:58.985]                         })
[09:31:58.985]                       }
[09:31:58.985]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:58.985]                       base::options(mc.cores = 1L)
[09:31:58.985]                     }
[09:31:58.985]                     base::local({
[09:31:58.985]                       for (pkg in "future") {
[09:31:58.985]                         base::loadNamespace(pkg)
[09:31:58.985]                         base::library(pkg, character.only = TRUE)
[09:31:58.985]                       }
[09:31:58.985]                     })
[09:31:58.985]                   }
[09:31:58.985]                   ...future.strategy.old <- future::plan("list")
[09:31:58.985]                   options(future.plan = NULL)
[09:31:58.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.985]                   future::plan(list(b = function (..., envir = parent.frame()) 
[09:31:58.985]                   {
[09:31:58.985]                     future <- SequentialFuture(..., envir = envir)
[09:31:58.985]                     if (!future$lazy) 
[09:31:58.985]                       future <- run(future)
[09:31:58.985]                     invisible(future)
[09:31:58.985]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:58.985]                 }
[09:31:58.985]                 ...future.workdir <- getwd()
[09:31:58.985]             }
[09:31:58.985]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:58.985]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:58.985]         }
[09:31:58.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:58.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:58.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:58.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:58.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:58.985]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:58.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:58.985]             base::names(...future.oldOptions))
[09:31:58.985]     }
[09:31:58.985]     if (FALSE) {
[09:31:58.985]     }
[09:31:58.985]     else {
[09:31:58.985]         if (TRUE) {
[09:31:58.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:58.985]                 open = "w")
[09:31:58.985]         }
[09:31:58.985]         else {
[09:31:58.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:58.985]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:58.985]         }
[09:31:58.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:58.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:58.985]             base::sink(type = "output", split = FALSE)
[09:31:58.985]             base::close(...future.stdout)
[09:31:58.985]         }, add = TRUE)
[09:31:58.985]     }
[09:31:58.985]     ...future.frame <- base::sys.nframe()
[09:31:58.985]     ...future.conditions <- base::list()
[09:31:58.985]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:58.985]     if (FALSE) {
[09:31:58.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:58.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:58.985]     }
[09:31:58.985]     ...future.result <- base::tryCatch({
[09:31:58.985]         base::withCallingHandlers({
[09:31:58.985]             ...future.value <- base::withVisible(base::local({
[09:31:58.985]                 ...future.makeSendCondition <- base::local({
[09:31:58.985]                   sendCondition <- NULL
[09:31:58.985]                   function(frame = 1L) {
[09:31:58.985]                     if (is.function(sendCondition)) 
[09:31:58.985]                       return(sendCondition)
[09:31:58.985]                     ns <- getNamespace("parallel")
[09:31:58.985]                     if (exists("sendData", mode = "function", 
[09:31:58.985]                       envir = ns)) {
[09:31:58.985]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:58.985]                         envir = ns)
[09:31:58.985]                       envir <- sys.frame(frame)
[09:31:58.985]                       master <- NULL
[09:31:58.985]                       while (!identical(envir, .GlobalEnv) && 
[09:31:58.985]                         !identical(envir, emptyenv())) {
[09:31:58.985]                         if (exists("master", mode = "list", envir = envir, 
[09:31:58.985]                           inherits = FALSE)) {
[09:31:58.985]                           master <- get("master", mode = "list", 
[09:31:58.985]                             envir = envir, inherits = FALSE)
[09:31:58.985]                           if (inherits(master, c("SOCKnode", 
[09:31:58.985]                             "SOCK0node"))) {
[09:31:58.985]                             sendCondition <<- function(cond) {
[09:31:58.985]                               data <- list(type = "VALUE", value = cond, 
[09:31:58.985]                                 success = TRUE)
[09:31:58.985]                               parallel_sendData(master, data)
[09:31:58.985]                             }
[09:31:58.985]                             return(sendCondition)
[09:31:58.985]                           }
[09:31:58.985]                         }
[09:31:58.985]                         frame <- frame + 1L
[09:31:58.985]                         envir <- sys.frame(frame)
[09:31:58.985]                       }
[09:31:58.985]                     }
[09:31:58.985]                     sendCondition <<- function(cond) NULL
[09:31:58.985]                   }
[09:31:58.985]                 })
[09:31:58.985]                 withCallingHandlers({
[09:31:58.985]                   {
[09:31:58.985]                     value(future(subset(data, a == 2)))
[09:31:58.985]                   }
[09:31:58.985]                 }, immediateCondition = function(cond) {
[09:31:58.985]                   sendCondition <- ...future.makeSendCondition()
[09:31:58.985]                   sendCondition(cond)
[09:31:58.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.985]                   {
[09:31:58.985]                     inherits <- base::inherits
[09:31:58.985]                     invokeRestart <- base::invokeRestart
[09:31:58.985]                     is.null <- base::is.null
[09:31:58.985]                     muffled <- FALSE
[09:31:58.985]                     if (inherits(cond, "message")) {
[09:31:58.985]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:58.985]                       if (muffled) 
[09:31:58.985]                         invokeRestart("muffleMessage")
[09:31:58.985]                     }
[09:31:58.985]                     else if (inherits(cond, "warning")) {
[09:31:58.985]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:58.985]                       if (muffled) 
[09:31:58.985]                         invokeRestart("muffleWarning")
[09:31:58.985]                     }
[09:31:58.985]                     else if (inherits(cond, "condition")) {
[09:31:58.985]                       if (!is.null(pattern)) {
[09:31:58.985]                         computeRestarts <- base::computeRestarts
[09:31:58.985]                         grepl <- base::grepl
[09:31:58.985]                         restarts <- computeRestarts(cond)
[09:31:58.985]                         for (restart in restarts) {
[09:31:58.985]                           name <- restart$name
[09:31:58.985]                           if (is.null(name)) 
[09:31:58.985]                             next
[09:31:58.985]                           if (!grepl(pattern, name)) 
[09:31:58.985]                             next
[09:31:58.985]                           invokeRestart(restart)
[09:31:58.985]                           muffled <- TRUE
[09:31:58.985]                           break
[09:31:58.985]                         }
[09:31:58.985]                       }
[09:31:58.985]                     }
[09:31:58.985]                     invisible(muffled)
[09:31:58.985]                   }
[09:31:58.985]                   muffleCondition(cond)
[09:31:58.985]                 })
[09:31:58.985]             }))
[09:31:58.985]             future::FutureResult(value = ...future.value$value, 
[09:31:58.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.985]                   ...future.rng), globalenv = if (FALSE) 
[09:31:58.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:58.985]                     ...future.globalenv.names))
[09:31:58.985]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:58.985]         }, condition = base::local({
[09:31:58.985]             c <- base::c
[09:31:58.985]             inherits <- base::inherits
[09:31:58.985]             invokeRestart <- base::invokeRestart
[09:31:58.985]             length <- base::length
[09:31:58.985]             list <- base::list
[09:31:58.985]             seq.int <- base::seq.int
[09:31:58.985]             signalCondition <- base::signalCondition
[09:31:58.985]             sys.calls <- base::sys.calls
[09:31:58.985]             `[[` <- base::`[[`
[09:31:58.985]             `+` <- base::`+`
[09:31:58.985]             `<<-` <- base::`<<-`
[09:31:58.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:58.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:58.985]                   3L)]
[09:31:58.985]             }
[09:31:58.985]             function(cond) {
[09:31:58.985]                 is_error <- inherits(cond, "error")
[09:31:58.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:58.985]                   NULL)
[09:31:58.985]                 if (is_error) {
[09:31:58.985]                   sessionInformation <- function() {
[09:31:58.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:58.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:58.985]                       search = base::search(), system = base::Sys.info())
[09:31:58.985]                   }
[09:31:58.985]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:58.985]                     cond$call), session = sessionInformation(), 
[09:31:58.985]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:58.985]                   signalCondition(cond)
[09:31:58.985]                 }
[09:31:58.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:58.985]                 "immediateCondition"))) {
[09:31:58.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:58.985]                   ...future.conditions[[length(...future.conditions) + 
[09:31:58.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:58.985]                   if (TRUE && !signal) {
[09:31:58.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.985]                     {
[09:31:58.985]                       inherits <- base::inherits
[09:31:58.985]                       invokeRestart <- base::invokeRestart
[09:31:58.985]                       is.null <- base::is.null
[09:31:58.985]                       muffled <- FALSE
[09:31:58.985]                       if (inherits(cond, "message")) {
[09:31:58.985]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.985]                         if (muffled) 
[09:31:58.985]                           invokeRestart("muffleMessage")
[09:31:58.985]                       }
[09:31:58.985]                       else if (inherits(cond, "warning")) {
[09:31:58.985]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.985]                         if (muffled) 
[09:31:58.985]                           invokeRestart("muffleWarning")
[09:31:58.985]                       }
[09:31:58.985]                       else if (inherits(cond, "condition")) {
[09:31:58.985]                         if (!is.null(pattern)) {
[09:31:58.985]                           computeRestarts <- base::computeRestarts
[09:31:58.985]                           grepl <- base::grepl
[09:31:58.985]                           restarts <- computeRestarts(cond)
[09:31:58.985]                           for (restart in restarts) {
[09:31:58.985]                             name <- restart$name
[09:31:58.985]                             if (is.null(name)) 
[09:31:58.985]                               next
[09:31:58.985]                             if (!grepl(pattern, name)) 
[09:31:58.985]                               next
[09:31:58.985]                             invokeRestart(restart)
[09:31:58.985]                             muffled <- TRUE
[09:31:58.985]                             break
[09:31:58.985]                           }
[09:31:58.985]                         }
[09:31:58.985]                       }
[09:31:58.985]                       invisible(muffled)
[09:31:58.985]                     }
[09:31:58.985]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.985]                   }
[09:31:58.985]                 }
[09:31:58.985]                 else {
[09:31:58.985]                   if (TRUE) {
[09:31:58.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:58.985]                     {
[09:31:58.985]                       inherits <- base::inherits
[09:31:58.985]                       invokeRestart <- base::invokeRestart
[09:31:58.985]                       is.null <- base::is.null
[09:31:58.985]                       muffled <- FALSE
[09:31:58.985]                       if (inherits(cond, "message")) {
[09:31:58.985]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:58.985]                         if (muffled) 
[09:31:58.985]                           invokeRestart("muffleMessage")
[09:31:58.985]                       }
[09:31:58.985]                       else if (inherits(cond, "warning")) {
[09:31:58.985]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:58.985]                         if (muffled) 
[09:31:58.985]                           invokeRestart("muffleWarning")
[09:31:58.985]                       }
[09:31:58.985]                       else if (inherits(cond, "condition")) {
[09:31:58.985]                         if (!is.null(pattern)) {
[09:31:58.985]                           computeRestarts <- base::computeRestarts
[09:31:58.985]                           grepl <- base::grepl
[09:31:58.985]                           restarts <- computeRestarts(cond)
[09:31:58.985]                           for (restart in restarts) {
[09:31:58.985]                             name <- restart$name
[09:31:58.985]                             if (is.null(name)) 
[09:31:58.985]                               next
[09:31:58.985]                             if (!grepl(pattern, name)) 
[09:31:58.985]                               next
[09:31:58.985]                             invokeRestart(restart)
[09:31:58.985]                             muffled <- TRUE
[09:31:58.985]                             break
[09:31:58.985]                           }
[09:31:58.985]                         }
[09:31:58.985]                       }
[09:31:58.985]                       invisible(muffled)
[09:31:58.985]                     }
[09:31:58.985]                     muffleCondition(cond, pattern = "^muffle")
[09:31:58.985]                   }
[09:31:58.985]                 }
[09:31:58.985]             }
[09:31:58.985]         }))
[09:31:58.985]     }, error = function(ex) {
[09:31:58.985]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:58.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:58.985]                 ...future.rng), started = ...future.startTime, 
[09:31:58.985]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:58.985]             version = "1.8"), class = "FutureResult")
[09:31:58.985]     }, finally = {
[09:31:58.985]         if (!identical(...future.workdir, getwd())) 
[09:31:58.985]             setwd(...future.workdir)
[09:31:58.985]         {
[09:31:58.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:58.985]                 ...future.oldOptions$nwarnings <- NULL
[09:31:58.985]             }
[09:31:58.985]             base::options(...future.oldOptions)
[09:31:58.985]             if (.Platform$OS.type == "windows") {
[09:31:58.985]                 old_names <- names(...future.oldEnvVars)
[09:31:58.985]                 envs <- base::Sys.getenv()
[09:31:58.985]                 names <- names(envs)
[09:31:58.985]                 common <- intersect(names, old_names)
[09:31:58.985]                 added <- setdiff(names, old_names)
[09:31:58.985]                 removed <- setdiff(old_names, names)
[09:31:58.985]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:58.985]                   envs[common]]
[09:31:58.985]                 NAMES <- toupper(changed)
[09:31:58.985]                 args <- list()
[09:31:58.985]                 for (kk in seq_along(NAMES)) {
[09:31:58.985]                   name <- changed[[kk]]
[09:31:58.985]                   NAME <- NAMES[[kk]]
[09:31:58.985]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.985]                     next
[09:31:58.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.985]                 }
[09:31:58.985]                 NAMES <- toupper(added)
[09:31:58.985]                 for (kk in seq_along(NAMES)) {
[09:31:58.985]                   name <- added[[kk]]
[09:31:58.985]                   NAME <- NAMES[[kk]]
[09:31:58.985]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.985]                     next
[09:31:58.985]                   args[[name]] <- ""
[09:31:58.985]                 }
[09:31:58.985]                 NAMES <- toupper(removed)
[09:31:58.985]                 for (kk in seq_along(NAMES)) {
[09:31:58.985]                   name <- removed[[kk]]
[09:31:58.985]                   NAME <- NAMES[[kk]]
[09:31:58.985]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:58.985]                     next
[09:31:58.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:58.985]                 }
[09:31:58.985]                 if (length(args) > 0) 
[09:31:58.985]                   base::do.call(base::Sys.setenv, args = args)
[09:31:58.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:58.985]             }
[09:31:58.985]             else {
[09:31:58.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:58.985]             }
[09:31:58.985]             {
[09:31:58.985]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:58.985]                   0L) {
[09:31:58.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:58.985]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:58.985]                   base::options(opts)
[09:31:58.985]                 }
[09:31:58.985]                 {
[09:31:58.985]                   {
[09:31:58.985]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:58.985]                     NULL
[09:31:58.985]                   }
[09:31:58.985]                   options(future.plan = NULL)
[09:31:58.985]                   if (is.na(NA_character_)) 
[09:31:58.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:58.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:58.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:58.985]                     .init = FALSE)
[09:31:58.985]                 }
[09:31:58.985]             }
[09:31:58.985]         }
[09:31:58.985]     })
[09:31:58.985]     if (TRUE) {
[09:31:58.985]         base::sink(type = "output", split = FALSE)
[09:31:58.985]         if (TRUE) {
[09:31:58.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:58.985]         }
[09:31:58.985]         else {
[09:31:58.985]             ...future.result["stdout"] <- base::list(NULL)
[09:31:58.985]         }
[09:31:58.985]         base::close(...future.stdout)
[09:31:58.985]         ...future.stdout <- NULL
[09:31:58.985]     }
[09:31:58.985]     ...future.result$conditions <- ...future.conditions
[09:31:58.985]     ...future.result$finished <- base::Sys.time()
[09:31:58.985]     ...future.result
[09:31:58.985] }
[09:31:58.987] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[09:31:58.987] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[09:31:58.988] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[09:31:58.988] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[09:31:58.988] MultisessionFuture started
[09:31:58.989] - Launch lazy future ... done
[09:31:58.989] run() for ‘MultisessionFuture’ ... done
[09:31:58.989] result() for ClusterFuture ...
[09:31:58.989] receiveMessageFromWorker() for ClusterFuture ...
[09:31:58.989] - Validating connection of MultisessionFuture
[09:31:59.037] - received message: FutureResult
[09:31:59.037] - Received FutureResult
[09:31:59.037] - Erased future from FutureRegistry
[09:31:59.037] result() for ClusterFuture ...
[09:31:59.037] - result already collected: FutureResult
[09:31:59.037] result() for ClusterFuture ... done
[09:31:59.037] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:59.037] result() for ClusterFuture ... done
[09:31:59.037] result() for ClusterFuture ...
[09:31:59.037] - result already collected: FutureResult
[09:31:59.038] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[09:31:59.038] plan(): Setting new future strategy stack:
[09:31:59.038] List of future strategies:
[09:31:59.038] 1. multisession:
[09:31:59.038]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:59.038]    - tweaked: FALSE
[09:31:59.038]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:59.038] 2. multicore:
[09:31:59.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:59.038]    - tweaked: FALSE
[09:31:59.038]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:59.039] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:59.039] multisession:
[09:31:59.039] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:59.039] - tweaked: FALSE
[09:31:59.039] - call: plan(list(a = strategy1, b = strategy2))
[09:31:59.043] getGlobalsAndPackages() ...
[09:31:59.043] Not searching for globals
[09:31:59.043] - globals: [0] <none>
[09:31:59.043] getGlobalsAndPackages() ... DONE
[09:31:59.044] [local output] makeClusterPSOCK() ...
[09:31:59.047] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:59.047] [local output] Base port: 11845
[09:31:59.048] [local output] Getting setup options for 2 cluster nodes ...
[09:31:59.048] [local output]  - Node 1 of 2 ...
[09:31:59.048] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:59.049] [local output] Rscript port: 11845

[09:31:59.049] [local output]  - Node 2 of 2 ...
[09:31:59.049] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:59.050] [local output] Rscript port: 11845

[09:31:59.050] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:59.050] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:59.050] [local output] Setting up PSOCK nodes in parallel
[09:31:59.051] List of 36
[09:31:59.051]  $ worker          : chr "localhost"
[09:31:59.051]   ..- attr(*, "localhost")= logi TRUE
[09:31:59.051]  $ master          : chr "localhost"
[09:31:59.051]  $ port            : int 11845
[09:31:59.051]  $ connectTimeout  : num 120
[09:31:59.051]  $ timeout         : num 2592000
[09:31:59.051]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:59.051]  $ homogeneous     : logi TRUE
[09:31:59.051]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:59.051]  $ rscript_envs    : NULL
[09:31:59.051]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:59.051]  $ rscript_startup : NULL
[09:31:59.051]  $ rscript_sh      : chr "sh"
[09:31:59.051]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:59.051]  $ methods         : logi TRUE
[09:31:59.051]  $ socketOptions   : chr "no-delay"
[09:31:59.051]  $ useXDR          : logi FALSE
[09:31:59.051]  $ outfile         : chr "/dev/null"
[09:31:59.051]  $ renice          : int NA
[09:31:59.051]  $ rshcmd          : NULL
[09:31:59.051]  $ user            : chr(0) 
[09:31:59.051]  $ revtunnel       : logi FALSE
[09:31:59.051]  $ rshlogfile      : NULL
[09:31:59.051]  $ rshopts         : chr(0) 
[09:31:59.051]  $ rank            : int 1
[09:31:59.051]  $ manual          : logi FALSE
[09:31:59.051]  $ dryrun          : logi FALSE
[09:31:59.051]  $ quiet           : logi FALSE
[09:31:59.051]  $ setup_strategy  : chr "parallel"
[09:31:59.051]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:59.051]  $ pidfile         : chr "/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b9166734499.pid"
[09:31:59.051]  $ rshcmd_label    : NULL
[09:31:59.051]  $ rsh_call        : NULL
[09:31:59.051]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:59.051]  $ localMachine    : logi TRUE
[09:31:59.051]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:59.051]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:59.051]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:59.051]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:59.051]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:59.051]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:59.051]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:59.051]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:59.051]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:59.051]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:59.051]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:59.051]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:59.051]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:59.051]  $ arguments       :List of 28
[09:31:59.051]   ..$ worker          : chr "localhost"
[09:31:59.051]   ..$ master          : NULL
[09:31:59.051]   ..$ port            : int 11845
[09:31:59.051]   ..$ connectTimeout  : num 120
[09:31:59.051]   ..$ timeout         : num 2592000
[09:31:59.051]   ..$ rscript         : NULL
[09:31:59.051]   ..$ homogeneous     : NULL
[09:31:59.051]   ..$ rscript_args    : NULL
[09:31:59.051]   ..$ rscript_envs    : NULL
[09:31:59.051]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:59.051]   ..$ rscript_startup : NULL
[09:31:59.051]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:59.051]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:59.051]   ..$ methods         : logi TRUE
[09:31:59.051]   ..$ socketOptions   : chr "no-delay"
[09:31:59.051]   ..$ useXDR          : logi FALSE
[09:31:59.051]   ..$ outfile         : chr "/dev/null"
[09:31:59.051]   ..$ renice          : int NA
[09:31:59.051]   ..$ rshcmd          : NULL
[09:31:59.051]   ..$ user            : NULL
[09:31:59.051]   ..$ revtunnel       : logi NA
[09:31:59.051]   ..$ rshlogfile      : NULL
[09:31:59.051]   ..$ rshopts         : NULL
[09:31:59.051]   ..$ rank            : int 1
[09:31:59.051]   ..$ manual          : logi FALSE
[09:31:59.051]   ..$ dryrun          : logi FALSE
[09:31:59.051]   ..$ quiet           : logi FALSE
[09:31:59.051]   ..$ setup_strategy  : chr "parallel"
[09:31:59.051]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:59.069] [local output] System call to launch all workers:
[09:31:59.069] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b9166734499.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11845 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:59.069] [local output] Starting PSOCK main server
[09:31:59.071] [local output] Workers launched
[09:31:59.071] [local output] Waiting for workers to connect back
[09:31:59.071]  - [local output] 0 workers out of 2 ready
[09:31:59.326]  - [local output] 0 workers out of 2 ready
[09:31:59.326]  - [local output] 1 workers out of 2 ready
[09:31:59.327]  - [local output] 1 workers out of 2 ready
[09:31:59.328]  - [local output] 2 workers out of 2 ready
[09:31:59.328] [local output] Launching of workers completed
[09:31:59.328] [local output] Collecting session information from workers
[09:31:59.329] [local output]  - Worker #1 of 2
[09:31:59.329] [local output]  - Worker #2 of 2
[09:31:59.329] [local output] makeClusterPSOCK() ... done
[09:31:59.340] Packages needed by the future expression (n = 0): <none>
[09:31:59.340] Packages needed by future strategies (n = 1): ‘future’
[09:31:59.341] {
[09:31:59.341]     {
[09:31:59.341]         {
[09:31:59.341]             ...future.startTime <- base::Sys.time()
[09:31:59.341]             {
[09:31:59.341]                 {
[09:31:59.341]                   {
[09:31:59.341]                     {
[09:31:59.341]                       {
[09:31:59.341]                         base::local({
[09:31:59.341]                           has_future <- base::requireNamespace("future", 
[09:31:59.341]                             quietly = TRUE)
[09:31:59.341]                           if (has_future) {
[09:31:59.341]                             ns <- base::getNamespace("future")
[09:31:59.341]                             version <- ns[[".package"]][["version"]]
[09:31:59.341]                             if (is.null(version)) 
[09:31:59.341]                               version <- utils::packageVersion("future")
[09:31:59.341]                           }
[09:31:59.341]                           else {
[09:31:59.341]                             version <- NULL
[09:31:59.341]                           }
[09:31:59.341]                           if (!has_future || version < "1.8.0") {
[09:31:59.341]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:59.341]                               "", base::R.version$version.string), 
[09:31:59.341]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:59.341]                                 base::R.version$platform, 8 * 
[09:31:59.341]                                   base::.Machine$sizeof.pointer), 
[09:31:59.341]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:59.341]                                 "release", "version")], collapse = " "), 
[09:31:59.341]                               hostname = base::Sys.info()[["nodename"]])
[09:31:59.341]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:59.341]                               info)
[09:31:59.341]                             info <- base::paste(info, collapse = "; ")
[09:31:59.341]                             if (!has_future) {
[09:31:59.341]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:59.341]                                 info)
[09:31:59.341]                             }
[09:31:59.341]                             else {
[09:31:59.341]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:59.341]                                 info, version)
[09:31:59.341]                             }
[09:31:59.341]                             base::stop(msg)
[09:31:59.341]                           }
[09:31:59.341]                         })
[09:31:59.341]                       }
[09:31:59.341]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:59.341]                       base::options(mc.cores = 1L)
[09:31:59.341]                     }
[09:31:59.341]                     base::local({
[09:31:59.341]                       for (pkg in "future") {
[09:31:59.341]                         base::loadNamespace(pkg)
[09:31:59.341]                         base::library(pkg, character.only = TRUE)
[09:31:59.341]                       }
[09:31:59.341]                     })
[09:31:59.341]                   }
[09:31:59.341]                   ...future.strategy.old <- future::plan("list")
[09:31:59.341]                   options(future.plan = NULL)
[09:31:59.341]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.341]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:59.341]                     envir = parent.frame()) 
[09:31:59.341]                   {
[09:31:59.341]                     default_workers <- missing(workers)
[09:31:59.341]                     if (is.function(workers)) 
[09:31:59.341]                       workers <- workers()
[09:31:59.341]                     workers <- structure(as.integer(workers), 
[09:31:59.341]                       class = class(workers))
[09:31:59.341]                     stop_if_not(is.finite(workers), workers >= 
[09:31:59.341]                       1L)
[09:31:59.341]                     if ((workers == 1L && !inherits(workers, 
[09:31:59.341]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:59.341]                       if (default_workers) 
[09:31:59.341]                         supportsMulticore(warn = TRUE)
[09:31:59.341]                       return(sequential(..., envir = envir))
[09:31:59.341]                     }
[09:31:59.341]                     oopts <- options(mc.cores = workers)
[09:31:59.341]                     on.exit(options(oopts))
[09:31:59.341]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:59.341]                       envir = envir)
[09:31:59.341]                     if (!future$lazy) 
[09:31:59.341]                       future <- run(future)
[09:31:59.341]                     invisible(future)
[09:31:59.341]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:59.341]                 }
[09:31:59.341]                 ...future.workdir <- getwd()
[09:31:59.341]             }
[09:31:59.341]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:59.341]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:59.341]         }
[09:31:59.341]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:59.341]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:59.341]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:59.341]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:59.341]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:59.341]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:59.341]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:59.341]             base::names(...future.oldOptions))
[09:31:59.341]     }
[09:31:59.341]     if (FALSE) {
[09:31:59.341]     }
[09:31:59.341]     else {
[09:31:59.341]         if (TRUE) {
[09:31:59.341]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:59.341]                 open = "w")
[09:31:59.341]         }
[09:31:59.341]         else {
[09:31:59.341]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:59.341]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:59.341]         }
[09:31:59.341]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:59.341]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:59.341]             base::sink(type = "output", split = FALSE)
[09:31:59.341]             base::close(...future.stdout)
[09:31:59.341]         }, add = TRUE)
[09:31:59.341]     }
[09:31:59.341]     ...future.frame <- base::sys.nframe()
[09:31:59.341]     ...future.conditions <- base::list()
[09:31:59.341]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:59.341]     if (FALSE) {
[09:31:59.341]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:59.341]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:59.341]     }
[09:31:59.341]     ...future.result <- base::tryCatch({
[09:31:59.341]         base::withCallingHandlers({
[09:31:59.341]             ...future.value <- base::withVisible(base::local({
[09:31:59.341]                 ...future.makeSendCondition <- base::local({
[09:31:59.341]                   sendCondition <- NULL
[09:31:59.341]                   function(frame = 1L) {
[09:31:59.341]                     if (is.function(sendCondition)) 
[09:31:59.341]                       return(sendCondition)
[09:31:59.341]                     ns <- getNamespace("parallel")
[09:31:59.341]                     if (exists("sendData", mode = "function", 
[09:31:59.341]                       envir = ns)) {
[09:31:59.341]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:59.341]                         envir = ns)
[09:31:59.341]                       envir <- sys.frame(frame)
[09:31:59.341]                       master <- NULL
[09:31:59.341]                       while (!identical(envir, .GlobalEnv) && 
[09:31:59.341]                         !identical(envir, emptyenv())) {
[09:31:59.341]                         if (exists("master", mode = "list", envir = envir, 
[09:31:59.341]                           inherits = FALSE)) {
[09:31:59.341]                           master <- get("master", mode = "list", 
[09:31:59.341]                             envir = envir, inherits = FALSE)
[09:31:59.341]                           if (inherits(master, c("SOCKnode", 
[09:31:59.341]                             "SOCK0node"))) {
[09:31:59.341]                             sendCondition <<- function(cond) {
[09:31:59.341]                               data <- list(type = "VALUE", value = cond, 
[09:31:59.341]                                 success = TRUE)
[09:31:59.341]                               parallel_sendData(master, data)
[09:31:59.341]                             }
[09:31:59.341]                             return(sendCondition)
[09:31:59.341]                           }
[09:31:59.341]                         }
[09:31:59.341]                         frame <- frame + 1L
[09:31:59.341]                         envir <- sys.frame(frame)
[09:31:59.341]                       }
[09:31:59.341]                     }
[09:31:59.341]                     sendCondition <<- function(cond) NULL
[09:31:59.341]                   }
[09:31:59.341]                 })
[09:31:59.341]                 withCallingHandlers({
[09:31:59.341]                   NA
[09:31:59.341]                 }, immediateCondition = function(cond) {
[09:31:59.341]                   sendCondition <- ...future.makeSendCondition()
[09:31:59.341]                   sendCondition(cond)
[09:31:59.341]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.341]                   {
[09:31:59.341]                     inherits <- base::inherits
[09:31:59.341]                     invokeRestart <- base::invokeRestart
[09:31:59.341]                     is.null <- base::is.null
[09:31:59.341]                     muffled <- FALSE
[09:31:59.341]                     if (inherits(cond, "message")) {
[09:31:59.341]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:59.341]                       if (muffled) 
[09:31:59.341]                         invokeRestart("muffleMessage")
[09:31:59.341]                     }
[09:31:59.341]                     else if (inherits(cond, "warning")) {
[09:31:59.341]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:59.341]                       if (muffled) 
[09:31:59.341]                         invokeRestart("muffleWarning")
[09:31:59.341]                     }
[09:31:59.341]                     else if (inherits(cond, "condition")) {
[09:31:59.341]                       if (!is.null(pattern)) {
[09:31:59.341]                         computeRestarts <- base::computeRestarts
[09:31:59.341]                         grepl <- base::grepl
[09:31:59.341]                         restarts <- computeRestarts(cond)
[09:31:59.341]                         for (restart in restarts) {
[09:31:59.341]                           name <- restart$name
[09:31:59.341]                           if (is.null(name)) 
[09:31:59.341]                             next
[09:31:59.341]                           if (!grepl(pattern, name)) 
[09:31:59.341]                             next
[09:31:59.341]                           invokeRestart(restart)
[09:31:59.341]                           muffled <- TRUE
[09:31:59.341]                           break
[09:31:59.341]                         }
[09:31:59.341]                       }
[09:31:59.341]                     }
[09:31:59.341]                     invisible(muffled)
[09:31:59.341]                   }
[09:31:59.341]                   muffleCondition(cond)
[09:31:59.341]                 })
[09:31:59.341]             }))
[09:31:59.341]             future::FutureResult(value = ...future.value$value, 
[09:31:59.341]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.341]                   ...future.rng), globalenv = if (FALSE) 
[09:31:59.341]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:59.341]                     ...future.globalenv.names))
[09:31:59.341]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:59.341]         }, condition = base::local({
[09:31:59.341]             c <- base::c
[09:31:59.341]             inherits <- base::inherits
[09:31:59.341]             invokeRestart <- base::invokeRestart
[09:31:59.341]             length <- base::length
[09:31:59.341]             list <- base::list
[09:31:59.341]             seq.int <- base::seq.int
[09:31:59.341]             signalCondition <- base::signalCondition
[09:31:59.341]             sys.calls <- base::sys.calls
[09:31:59.341]             `[[` <- base::`[[`
[09:31:59.341]             `+` <- base::`+`
[09:31:59.341]             `<<-` <- base::`<<-`
[09:31:59.341]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:59.341]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:59.341]                   3L)]
[09:31:59.341]             }
[09:31:59.341]             function(cond) {
[09:31:59.341]                 is_error <- inherits(cond, "error")
[09:31:59.341]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:59.341]                   NULL)
[09:31:59.341]                 if (is_error) {
[09:31:59.341]                   sessionInformation <- function() {
[09:31:59.341]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:59.341]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:59.341]                       search = base::search(), system = base::Sys.info())
[09:31:59.341]                   }
[09:31:59.341]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.341]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:59.341]                     cond$call), session = sessionInformation(), 
[09:31:59.341]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:59.341]                   signalCondition(cond)
[09:31:59.341]                 }
[09:31:59.341]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:59.341]                 "immediateCondition"))) {
[09:31:59.341]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:59.341]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.341]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:59.341]                   if (TRUE && !signal) {
[09:31:59.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.341]                     {
[09:31:59.341]                       inherits <- base::inherits
[09:31:59.341]                       invokeRestart <- base::invokeRestart
[09:31:59.341]                       is.null <- base::is.null
[09:31:59.341]                       muffled <- FALSE
[09:31:59.341]                       if (inherits(cond, "message")) {
[09:31:59.341]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.341]                         if (muffled) 
[09:31:59.341]                           invokeRestart("muffleMessage")
[09:31:59.341]                       }
[09:31:59.341]                       else if (inherits(cond, "warning")) {
[09:31:59.341]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.341]                         if (muffled) 
[09:31:59.341]                           invokeRestart("muffleWarning")
[09:31:59.341]                       }
[09:31:59.341]                       else if (inherits(cond, "condition")) {
[09:31:59.341]                         if (!is.null(pattern)) {
[09:31:59.341]                           computeRestarts <- base::computeRestarts
[09:31:59.341]                           grepl <- base::grepl
[09:31:59.341]                           restarts <- computeRestarts(cond)
[09:31:59.341]                           for (restart in restarts) {
[09:31:59.341]                             name <- restart$name
[09:31:59.341]                             if (is.null(name)) 
[09:31:59.341]                               next
[09:31:59.341]                             if (!grepl(pattern, name)) 
[09:31:59.341]                               next
[09:31:59.341]                             invokeRestart(restart)
[09:31:59.341]                             muffled <- TRUE
[09:31:59.341]                             break
[09:31:59.341]                           }
[09:31:59.341]                         }
[09:31:59.341]                       }
[09:31:59.341]                       invisible(muffled)
[09:31:59.341]                     }
[09:31:59.341]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.341]                   }
[09:31:59.341]                 }
[09:31:59.341]                 else {
[09:31:59.341]                   if (TRUE) {
[09:31:59.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.341]                     {
[09:31:59.341]                       inherits <- base::inherits
[09:31:59.341]                       invokeRestart <- base::invokeRestart
[09:31:59.341]                       is.null <- base::is.null
[09:31:59.341]                       muffled <- FALSE
[09:31:59.341]                       if (inherits(cond, "message")) {
[09:31:59.341]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.341]                         if (muffled) 
[09:31:59.341]                           invokeRestart("muffleMessage")
[09:31:59.341]                       }
[09:31:59.341]                       else if (inherits(cond, "warning")) {
[09:31:59.341]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.341]                         if (muffled) 
[09:31:59.341]                           invokeRestart("muffleWarning")
[09:31:59.341]                       }
[09:31:59.341]                       else if (inherits(cond, "condition")) {
[09:31:59.341]                         if (!is.null(pattern)) {
[09:31:59.341]                           computeRestarts <- base::computeRestarts
[09:31:59.341]                           grepl <- base::grepl
[09:31:59.341]                           restarts <- computeRestarts(cond)
[09:31:59.341]                           for (restart in restarts) {
[09:31:59.341]                             name <- restart$name
[09:31:59.341]                             if (is.null(name)) 
[09:31:59.341]                               next
[09:31:59.341]                             if (!grepl(pattern, name)) 
[09:31:59.341]                               next
[09:31:59.341]                             invokeRestart(restart)
[09:31:59.341]                             muffled <- TRUE
[09:31:59.341]                             break
[09:31:59.341]                           }
[09:31:59.341]                         }
[09:31:59.341]                       }
[09:31:59.341]                       invisible(muffled)
[09:31:59.341]                     }
[09:31:59.341]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.341]                   }
[09:31:59.341]                 }
[09:31:59.341]             }
[09:31:59.341]         }))
[09:31:59.341]     }, error = function(ex) {
[09:31:59.341]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:59.341]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.341]                 ...future.rng), started = ...future.startTime, 
[09:31:59.341]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:59.341]             version = "1.8"), class = "FutureResult")
[09:31:59.341]     }, finally = {
[09:31:59.341]         if (!identical(...future.workdir, getwd())) 
[09:31:59.341]             setwd(...future.workdir)
[09:31:59.341]         {
[09:31:59.341]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:59.341]                 ...future.oldOptions$nwarnings <- NULL
[09:31:59.341]             }
[09:31:59.341]             base::options(...future.oldOptions)
[09:31:59.341]             if (.Platform$OS.type == "windows") {
[09:31:59.341]                 old_names <- names(...future.oldEnvVars)
[09:31:59.341]                 envs <- base::Sys.getenv()
[09:31:59.341]                 names <- names(envs)
[09:31:59.341]                 common <- intersect(names, old_names)
[09:31:59.341]                 added <- setdiff(names, old_names)
[09:31:59.341]                 removed <- setdiff(old_names, names)
[09:31:59.341]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:59.341]                   envs[common]]
[09:31:59.341]                 NAMES <- toupper(changed)
[09:31:59.341]                 args <- list()
[09:31:59.341]                 for (kk in seq_along(NAMES)) {
[09:31:59.341]                   name <- changed[[kk]]
[09:31:59.341]                   NAME <- NAMES[[kk]]
[09:31:59.341]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.341]                     next
[09:31:59.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.341]                 }
[09:31:59.341]                 NAMES <- toupper(added)
[09:31:59.341]                 for (kk in seq_along(NAMES)) {
[09:31:59.341]                   name <- added[[kk]]
[09:31:59.341]                   NAME <- NAMES[[kk]]
[09:31:59.341]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.341]                     next
[09:31:59.341]                   args[[name]] <- ""
[09:31:59.341]                 }
[09:31:59.341]                 NAMES <- toupper(removed)
[09:31:59.341]                 for (kk in seq_along(NAMES)) {
[09:31:59.341]                   name <- removed[[kk]]
[09:31:59.341]                   NAME <- NAMES[[kk]]
[09:31:59.341]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.341]                     next
[09:31:59.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.341]                 }
[09:31:59.341]                 if (length(args) > 0) 
[09:31:59.341]                   base::do.call(base::Sys.setenv, args = args)
[09:31:59.341]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:59.341]             }
[09:31:59.341]             else {
[09:31:59.341]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:59.341]             }
[09:31:59.341]             {
[09:31:59.341]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:59.341]                   0L) {
[09:31:59.341]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:59.341]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:59.341]                   base::options(opts)
[09:31:59.341]                 }
[09:31:59.341]                 {
[09:31:59.341]                   {
[09:31:59.341]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:59.341]                     NULL
[09:31:59.341]                   }
[09:31:59.341]                   options(future.plan = NULL)
[09:31:59.341]                   if (is.na(NA_character_)) 
[09:31:59.341]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.341]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:59.341]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:59.341]                     .init = FALSE)
[09:31:59.341]                 }
[09:31:59.341]             }
[09:31:59.341]         }
[09:31:59.341]     })
[09:31:59.341]     if (TRUE) {
[09:31:59.341]         base::sink(type = "output", split = FALSE)
[09:31:59.341]         if (TRUE) {
[09:31:59.341]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:59.341]         }
[09:31:59.341]         else {
[09:31:59.341]             ...future.result["stdout"] <- base::list(NULL)
[09:31:59.341]         }
[09:31:59.341]         base::close(...future.stdout)
[09:31:59.341]         ...future.stdout <- NULL
[09:31:59.341]     }
[09:31:59.341]     ...future.result$conditions <- ...future.conditions
[09:31:59.341]     ...future.result$finished <- base::Sys.time()
[09:31:59.341]     ...future.result
[09:31:59.341] }
[09:31:59.392] MultisessionFuture started
[09:31:59.392] result() for ClusterFuture ...
[09:31:59.392] receiveMessageFromWorker() for ClusterFuture ...
[09:31:59.392] - Validating connection of MultisessionFuture
[09:31:59.436] - received message: FutureResult
[09:31:59.436] - Received FutureResult
[09:31:59.437] - Erased future from FutureRegistry
[09:31:59.437] result() for ClusterFuture ...
[09:31:59.437] - result already collected: FutureResult
[09:31:59.437] result() for ClusterFuture ... done
[09:31:59.437] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:59.437] result() for ClusterFuture ... done
[09:31:59.437] result() for ClusterFuture ...
[09:31:59.437] - result already collected: FutureResult
[09:31:59.437] result() for ClusterFuture ... done
[09:31:59.438] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:59.441] plan(): nbrOfWorkers() = 2
[09:31:59.441] getGlobalsAndPackages() ...
[09:31:59.441] Searching for globals...
[09:31:59.459] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:31:59.459] Searching for globals ... DONE
[09:31:59.459] Resolving globals: FALSE
[09:31:59.460] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[09:31:59.461] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:31:59.461] - globals: [2] ‘nested’, ‘strategy2’
[09:31:59.461] - packages: [1] ‘future’
[09:31:59.461] getGlobalsAndPackages() ... DONE
[09:31:59.461] run() for ‘Future’ ...
[09:31:59.461] - state: ‘created’
[09:31:59.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:59.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:59.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:59.476]   - Field: ‘node’
[09:31:59.476]   - Field: ‘label’
[09:31:59.476]   - Field: ‘local’
[09:31:59.476]   - Field: ‘owner’
[09:31:59.476]   - Field: ‘envir’
[09:31:59.477]   - Field: ‘workers’
[09:31:59.477]   - Field: ‘packages’
[09:31:59.477]   - Field: ‘gc’
[09:31:59.477]   - Field: ‘conditions’
[09:31:59.477]   - Field: ‘persistent’
[09:31:59.477]   - Field: ‘expr’
[09:31:59.477]   - Field: ‘uuid’
[09:31:59.477]   - Field: ‘seed’
[09:31:59.477]   - Field: ‘version’
[09:31:59.477]   - Field: ‘result’
[09:31:59.477]   - Field: ‘asynchronous’
[09:31:59.478]   - Field: ‘calls’
[09:31:59.478]   - Field: ‘globals’
[09:31:59.478]   - Field: ‘stdout’
[09:31:59.478]   - Field: ‘earlySignal’
[09:31:59.478]   - Field: ‘lazy’
[09:31:59.478]   - Field: ‘state’
[09:31:59.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:59.478] - Launch lazy future ...
[09:31:59.478] Packages needed by the future expression (n = 1): ‘future’
[09:31:59.479] Packages needed by future strategies (n = 1): ‘future’
[09:31:59.479] {
[09:31:59.479]     {
[09:31:59.479]         {
[09:31:59.479]             ...future.startTime <- base::Sys.time()
[09:31:59.479]             {
[09:31:59.479]                 {
[09:31:59.479]                   {
[09:31:59.479]                     {
[09:31:59.479]                       {
[09:31:59.479]                         base::local({
[09:31:59.479]                           has_future <- base::requireNamespace("future", 
[09:31:59.479]                             quietly = TRUE)
[09:31:59.479]                           if (has_future) {
[09:31:59.479]                             ns <- base::getNamespace("future")
[09:31:59.479]                             version <- ns[[".package"]][["version"]]
[09:31:59.479]                             if (is.null(version)) 
[09:31:59.479]                               version <- utils::packageVersion("future")
[09:31:59.479]                           }
[09:31:59.479]                           else {
[09:31:59.479]                             version <- NULL
[09:31:59.479]                           }
[09:31:59.479]                           if (!has_future || version < "1.8.0") {
[09:31:59.479]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:59.479]                               "", base::R.version$version.string), 
[09:31:59.479]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:59.479]                                 base::R.version$platform, 8 * 
[09:31:59.479]                                   base::.Machine$sizeof.pointer), 
[09:31:59.479]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:59.479]                                 "release", "version")], collapse = " "), 
[09:31:59.479]                               hostname = base::Sys.info()[["nodename"]])
[09:31:59.479]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:59.479]                               info)
[09:31:59.479]                             info <- base::paste(info, collapse = "; ")
[09:31:59.479]                             if (!has_future) {
[09:31:59.479]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:59.479]                                 info)
[09:31:59.479]                             }
[09:31:59.479]                             else {
[09:31:59.479]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:59.479]                                 info, version)
[09:31:59.479]                             }
[09:31:59.479]                             base::stop(msg)
[09:31:59.479]                           }
[09:31:59.479]                         })
[09:31:59.479]                       }
[09:31:59.479]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:59.479]                       base::options(mc.cores = 1L)
[09:31:59.479]                     }
[09:31:59.479]                     base::local({
[09:31:59.479]                       for (pkg in "future") {
[09:31:59.479]                         base::loadNamespace(pkg)
[09:31:59.479]                         base::library(pkg, character.only = TRUE)
[09:31:59.479]                       }
[09:31:59.479]                     })
[09:31:59.479]                   }
[09:31:59.479]                   ...future.strategy.old <- future::plan("list")
[09:31:59.479]                   options(future.plan = NULL)
[09:31:59.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.479]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:59.479]                     envir = parent.frame()) 
[09:31:59.479]                   {
[09:31:59.479]                     default_workers <- missing(workers)
[09:31:59.479]                     if (is.function(workers)) 
[09:31:59.479]                       workers <- workers()
[09:31:59.479]                     workers <- structure(as.integer(workers), 
[09:31:59.479]                       class = class(workers))
[09:31:59.479]                     stop_if_not(is.finite(workers), workers >= 
[09:31:59.479]                       1L)
[09:31:59.479]                     if ((workers == 1L && !inherits(workers, 
[09:31:59.479]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:59.479]                       if (default_workers) 
[09:31:59.479]                         supportsMulticore(warn = TRUE)
[09:31:59.479]                       return(sequential(..., envir = envir))
[09:31:59.479]                     }
[09:31:59.479]                     oopts <- options(mc.cores = workers)
[09:31:59.479]                     on.exit(options(oopts))
[09:31:59.479]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:59.479]                       envir = envir)
[09:31:59.479]                     if (!future$lazy) 
[09:31:59.479]                       future <- run(future)
[09:31:59.479]                     invisible(future)
[09:31:59.479]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:59.479]                 }
[09:31:59.479]                 ...future.workdir <- getwd()
[09:31:59.479]             }
[09:31:59.479]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:59.479]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:59.479]         }
[09:31:59.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:59.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:59.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:59.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:59.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:59.479]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:59.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:59.479]             base::names(...future.oldOptions))
[09:31:59.479]     }
[09:31:59.479]     if (FALSE) {
[09:31:59.479]     }
[09:31:59.479]     else {
[09:31:59.479]         if (TRUE) {
[09:31:59.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:59.479]                 open = "w")
[09:31:59.479]         }
[09:31:59.479]         else {
[09:31:59.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:59.479]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:59.479]         }
[09:31:59.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:59.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:59.479]             base::sink(type = "output", split = FALSE)
[09:31:59.479]             base::close(...future.stdout)
[09:31:59.479]         }, add = TRUE)
[09:31:59.479]     }
[09:31:59.479]     ...future.frame <- base::sys.nframe()
[09:31:59.479]     ...future.conditions <- base::list()
[09:31:59.479]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:59.479]     if (FALSE) {
[09:31:59.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:59.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:59.479]     }
[09:31:59.479]     ...future.result <- base::tryCatch({
[09:31:59.479]         base::withCallingHandlers({
[09:31:59.479]             ...future.value <- base::withVisible(base::local({
[09:31:59.479]                 ...future.makeSendCondition <- base::local({
[09:31:59.479]                   sendCondition <- NULL
[09:31:59.479]                   function(frame = 1L) {
[09:31:59.479]                     if (is.function(sendCondition)) 
[09:31:59.479]                       return(sendCondition)
[09:31:59.479]                     ns <- getNamespace("parallel")
[09:31:59.479]                     if (exists("sendData", mode = "function", 
[09:31:59.479]                       envir = ns)) {
[09:31:59.479]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:59.479]                         envir = ns)
[09:31:59.479]                       envir <- sys.frame(frame)
[09:31:59.479]                       master <- NULL
[09:31:59.479]                       while (!identical(envir, .GlobalEnv) && 
[09:31:59.479]                         !identical(envir, emptyenv())) {
[09:31:59.479]                         if (exists("master", mode = "list", envir = envir, 
[09:31:59.479]                           inherits = FALSE)) {
[09:31:59.479]                           master <- get("master", mode = "list", 
[09:31:59.479]                             envir = envir, inherits = FALSE)
[09:31:59.479]                           if (inherits(master, c("SOCKnode", 
[09:31:59.479]                             "SOCK0node"))) {
[09:31:59.479]                             sendCondition <<- function(cond) {
[09:31:59.479]                               data <- list(type = "VALUE", value = cond, 
[09:31:59.479]                                 success = TRUE)
[09:31:59.479]                               parallel_sendData(master, data)
[09:31:59.479]                             }
[09:31:59.479]                             return(sendCondition)
[09:31:59.479]                           }
[09:31:59.479]                         }
[09:31:59.479]                         frame <- frame + 1L
[09:31:59.479]                         envir <- sys.frame(frame)
[09:31:59.479]                       }
[09:31:59.479]                     }
[09:31:59.479]                     sendCondition <<- function(cond) NULL
[09:31:59.479]                   }
[09:31:59.479]                 })
[09:31:59.479]                 withCallingHandlers({
[09:31:59.479]                   {
[09:31:59.479]                     a <- 1L
[09:31:59.479]                     plan_a <- unclass(future::plan("list"))
[09:31:59.479]                     nested_a <- nested[-1]
[09:31:59.479]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:31:59.479]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:31:59.479]                       strategy2))
[09:31:59.479]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:31:59.479]                       "init") <- NULL
[09:31:59.479]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:31:59.479]                       "init") <- NULL
[09:31:59.479]                     stopifnot(all.equal(plan_a, nested_a))
[09:31:59.479]                     y %<-% {
[09:31:59.479]                       b <- 2L
[09:31:59.479]                       plan_b <- future::plan("list")
[09:31:59.479]                       nested_b <- nested_a[-1]
[09:31:59.479]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:31:59.479]                         1L, inherits(plan_b[[1]], "future"), 
[09:31:59.479]                         inherits(future::plan("next"), "sequential"))
[09:31:59.479]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:31:59.479]                         b = b, nested_b = nested_b, plan_b = plan_b)
[09:31:59.479]                     }
[09:31:59.479]                     y
[09:31:59.479]                   }
[09:31:59.479]                 }, immediateCondition = function(cond) {
[09:31:59.479]                   sendCondition <- ...future.makeSendCondition()
[09:31:59.479]                   sendCondition(cond)
[09:31:59.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.479]                   {
[09:31:59.479]                     inherits <- base::inherits
[09:31:59.479]                     invokeRestart <- base::invokeRestart
[09:31:59.479]                     is.null <- base::is.null
[09:31:59.479]                     muffled <- FALSE
[09:31:59.479]                     if (inherits(cond, "message")) {
[09:31:59.479]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:59.479]                       if (muffled) 
[09:31:59.479]                         invokeRestart("muffleMessage")
[09:31:59.479]                     }
[09:31:59.479]                     else if (inherits(cond, "warning")) {
[09:31:59.479]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:59.479]                       if (muffled) 
[09:31:59.479]                         invokeRestart("muffleWarning")
[09:31:59.479]                     }
[09:31:59.479]                     else if (inherits(cond, "condition")) {
[09:31:59.479]                       if (!is.null(pattern)) {
[09:31:59.479]                         computeRestarts <- base::computeRestarts
[09:31:59.479]                         grepl <- base::grepl
[09:31:59.479]                         restarts <- computeRestarts(cond)
[09:31:59.479]                         for (restart in restarts) {
[09:31:59.479]                           name <- restart$name
[09:31:59.479]                           if (is.null(name)) 
[09:31:59.479]                             next
[09:31:59.479]                           if (!grepl(pattern, name)) 
[09:31:59.479]                             next
[09:31:59.479]                           invokeRestart(restart)
[09:31:59.479]                           muffled <- TRUE
[09:31:59.479]                           break
[09:31:59.479]                         }
[09:31:59.479]                       }
[09:31:59.479]                     }
[09:31:59.479]                     invisible(muffled)
[09:31:59.479]                   }
[09:31:59.479]                   muffleCondition(cond)
[09:31:59.479]                 })
[09:31:59.479]             }))
[09:31:59.479]             future::FutureResult(value = ...future.value$value, 
[09:31:59.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.479]                   ...future.rng), globalenv = if (FALSE) 
[09:31:59.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:59.479]                     ...future.globalenv.names))
[09:31:59.479]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:59.479]         }, condition = base::local({
[09:31:59.479]             c <- base::c
[09:31:59.479]             inherits <- base::inherits
[09:31:59.479]             invokeRestart <- base::invokeRestart
[09:31:59.479]             length <- base::length
[09:31:59.479]             list <- base::list
[09:31:59.479]             seq.int <- base::seq.int
[09:31:59.479]             signalCondition <- base::signalCondition
[09:31:59.479]             sys.calls <- base::sys.calls
[09:31:59.479]             `[[` <- base::`[[`
[09:31:59.479]             `+` <- base::`+`
[09:31:59.479]             `<<-` <- base::`<<-`
[09:31:59.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:59.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:59.479]                   3L)]
[09:31:59.479]             }
[09:31:59.479]             function(cond) {
[09:31:59.479]                 is_error <- inherits(cond, "error")
[09:31:59.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:59.479]                   NULL)
[09:31:59.479]                 if (is_error) {
[09:31:59.479]                   sessionInformation <- function() {
[09:31:59.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:59.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:59.479]                       search = base::search(), system = base::Sys.info())
[09:31:59.479]                   }
[09:31:59.479]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:59.479]                     cond$call), session = sessionInformation(), 
[09:31:59.479]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:59.479]                   signalCondition(cond)
[09:31:59.479]                 }
[09:31:59.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:59.479]                 "immediateCondition"))) {
[09:31:59.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:59.479]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:59.479]                   if (TRUE && !signal) {
[09:31:59.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.479]                     {
[09:31:59.479]                       inherits <- base::inherits
[09:31:59.479]                       invokeRestart <- base::invokeRestart
[09:31:59.479]                       is.null <- base::is.null
[09:31:59.479]                       muffled <- FALSE
[09:31:59.479]                       if (inherits(cond, "message")) {
[09:31:59.479]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.479]                         if (muffled) 
[09:31:59.479]                           invokeRestart("muffleMessage")
[09:31:59.479]                       }
[09:31:59.479]                       else if (inherits(cond, "warning")) {
[09:31:59.479]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.479]                         if (muffled) 
[09:31:59.479]                           invokeRestart("muffleWarning")
[09:31:59.479]                       }
[09:31:59.479]                       else if (inherits(cond, "condition")) {
[09:31:59.479]                         if (!is.null(pattern)) {
[09:31:59.479]                           computeRestarts <- base::computeRestarts
[09:31:59.479]                           grepl <- base::grepl
[09:31:59.479]                           restarts <- computeRestarts(cond)
[09:31:59.479]                           for (restart in restarts) {
[09:31:59.479]                             name <- restart$name
[09:31:59.479]                             if (is.null(name)) 
[09:31:59.479]                               next
[09:31:59.479]                             if (!grepl(pattern, name)) 
[09:31:59.479]                               next
[09:31:59.479]                             invokeRestart(restart)
[09:31:59.479]                             muffled <- TRUE
[09:31:59.479]                             break
[09:31:59.479]                           }
[09:31:59.479]                         }
[09:31:59.479]                       }
[09:31:59.479]                       invisible(muffled)
[09:31:59.479]                     }
[09:31:59.479]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.479]                   }
[09:31:59.479]                 }
[09:31:59.479]                 else {
[09:31:59.479]                   if (TRUE) {
[09:31:59.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.479]                     {
[09:31:59.479]                       inherits <- base::inherits
[09:31:59.479]                       invokeRestart <- base::invokeRestart
[09:31:59.479]                       is.null <- base::is.null
[09:31:59.479]                       muffled <- FALSE
[09:31:59.479]                       if (inherits(cond, "message")) {
[09:31:59.479]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.479]                         if (muffled) 
[09:31:59.479]                           invokeRestart("muffleMessage")
[09:31:59.479]                       }
[09:31:59.479]                       else if (inherits(cond, "warning")) {
[09:31:59.479]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.479]                         if (muffled) 
[09:31:59.479]                           invokeRestart("muffleWarning")
[09:31:59.479]                       }
[09:31:59.479]                       else if (inherits(cond, "condition")) {
[09:31:59.479]                         if (!is.null(pattern)) {
[09:31:59.479]                           computeRestarts <- base::computeRestarts
[09:31:59.479]                           grepl <- base::grepl
[09:31:59.479]                           restarts <- computeRestarts(cond)
[09:31:59.479]                           for (restart in restarts) {
[09:31:59.479]                             name <- restart$name
[09:31:59.479]                             if (is.null(name)) 
[09:31:59.479]                               next
[09:31:59.479]                             if (!grepl(pattern, name)) 
[09:31:59.479]                               next
[09:31:59.479]                             invokeRestart(restart)
[09:31:59.479]                             muffled <- TRUE
[09:31:59.479]                             break
[09:31:59.479]                           }
[09:31:59.479]                         }
[09:31:59.479]                       }
[09:31:59.479]                       invisible(muffled)
[09:31:59.479]                     }
[09:31:59.479]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.479]                   }
[09:31:59.479]                 }
[09:31:59.479]             }
[09:31:59.479]         }))
[09:31:59.479]     }, error = function(ex) {
[09:31:59.479]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:59.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.479]                 ...future.rng), started = ...future.startTime, 
[09:31:59.479]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:59.479]             version = "1.8"), class = "FutureResult")
[09:31:59.479]     }, finally = {
[09:31:59.479]         if (!identical(...future.workdir, getwd())) 
[09:31:59.479]             setwd(...future.workdir)
[09:31:59.479]         {
[09:31:59.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:59.479]                 ...future.oldOptions$nwarnings <- NULL
[09:31:59.479]             }
[09:31:59.479]             base::options(...future.oldOptions)
[09:31:59.479]             if (.Platform$OS.type == "windows") {
[09:31:59.479]                 old_names <- names(...future.oldEnvVars)
[09:31:59.479]                 envs <- base::Sys.getenv()
[09:31:59.479]                 names <- names(envs)
[09:31:59.479]                 common <- intersect(names, old_names)
[09:31:59.479]                 added <- setdiff(names, old_names)
[09:31:59.479]                 removed <- setdiff(old_names, names)
[09:31:59.479]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:59.479]                   envs[common]]
[09:31:59.479]                 NAMES <- toupper(changed)
[09:31:59.479]                 args <- list()
[09:31:59.479]                 for (kk in seq_along(NAMES)) {
[09:31:59.479]                   name <- changed[[kk]]
[09:31:59.479]                   NAME <- NAMES[[kk]]
[09:31:59.479]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.479]                     next
[09:31:59.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.479]                 }
[09:31:59.479]                 NAMES <- toupper(added)
[09:31:59.479]                 for (kk in seq_along(NAMES)) {
[09:31:59.479]                   name <- added[[kk]]
[09:31:59.479]                   NAME <- NAMES[[kk]]
[09:31:59.479]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.479]                     next
[09:31:59.479]                   args[[name]] <- ""
[09:31:59.479]                 }
[09:31:59.479]                 NAMES <- toupper(removed)
[09:31:59.479]                 for (kk in seq_along(NAMES)) {
[09:31:59.479]                   name <- removed[[kk]]
[09:31:59.479]                   NAME <- NAMES[[kk]]
[09:31:59.479]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.479]                     next
[09:31:59.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.479]                 }
[09:31:59.479]                 if (length(args) > 0) 
[09:31:59.479]                   base::do.call(base::Sys.setenv, args = args)
[09:31:59.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:59.479]             }
[09:31:59.479]             else {
[09:31:59.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:59.479]             }
[09:31:59.479]             {
[09:31:59.479]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:59.479]                   0L) {
[09:31:59.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:59.479]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:59.479]                   base::options(opts)
[09:31:59.479]                 }
[09:31:59.479]                 {
[09:31:59.479]                   {
[09:31:59.479]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:59.479]                     NULL
[09:31:59.479]                   }
[09:31:59.479]                   options(future.plan = NULL)
[09:31:59.479]                   if (is.na(NA_character_)) 
[09:31:59.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:59.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:59.479]                     .init = FALSE)
[09:31:59.479]                 }
[09:31:59.479]             }
[09:31:59.479]         }
[09:31:59.479]     })
[09:31:59.479]     if (TRUE) {
[09:31:59.479]         base::sink(type = "output", split = FALSE)
[09:31:59.479]         if (TRUE) {
[09:31:59.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:59.479]         }
[09:31:59.479]         else {
[09:31:59.479]             ...future.result["stdout"] <- base::list(NULL)
[09:31:59.479]         }
[09:31:59.479]         base::close(...future.stdout)
[09:31:59.479]         ...future.stdout <- NULL
[09:31:59.479]     }
[09:31:59.479]     ...future.result$conditions <- ...future.conditions
[09:31:59.479]     ...future.result$finished <- base::Sys.time()
[09:31:59.479]     ...future.result
[09:31:59.479] }
[09:31:59.482] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[09:31:59.482] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[09:31:59.524] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[09:31:59.524] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[09:31:59.525] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[09:31:59.525] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[09:31:59.525] MultisessionFuture started
[09:31:59.525] - Launch lazy future ... done
[09:31:59.526] run() for ‘MultisessionFuture’ ... done
[09:31:59.526] result() for ClusterFuture ...
[09:31:59.526] receiveMessageFromWorker() for ClusterFuture ...
[09:31:59.526] - Validating connection of MultisessionFuture
[09:31:59.597] - received message: FutureResult
[09:31:59.597] - Received FutureResult
[09:31:59.597] - Erased future from FutureRegistry
[09:31:59.597] result() for ClusterFuture ...
[09:31:59.597] - result already collected: FutureResult
[09:31:59.597] result() for ClusterFuture ... done
[09:31:59.597] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:59.598] result() for ClusterFuture ... done
[09:31:59.598] result() for ClusterFuture ...
[09:31:59.598] - result already collected: FutureResult
[09:31:59.598] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:31:59.603] getGlobalsAndPackages() ...
[09:31:59.603] Searching for globals...
[09:31:59.604] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:31:59.604] Searching for globals ... DONE
[09:31:59.604] Resolving globals: FALSE
[09:31:59.605] The total size of the 1 globals is 128 bytes (128 bytes)
[09:31:59.605] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:31:59.605] - globals: [1] ‘data’
[09:31:59.606] - packages: [1] ‘future’
[09:31:59.606] getGlobalsAndPackages() ... DONE
[09:31:59.606] run() for ‘Future’ ...
[09:31:59.606] - state: ‘created’
[09:31:59.606] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:59.619] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:59.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:59.620]   - Field: ‘node’
[09:31:59.620]   - Field: ‘label’
[09:31:59.620]   - Field: ‘local’
[09:31:59.620]   - Field: ‘owner’
[09:31:59.620]   - Field: ‘envir’
[09:31:59.620]   - Field: ‘workers’
[09:31:59.620]   - Field: ‘packages’
[09:31:59.620]   - Field: ‘gc’
[09:31:59.621]   - Field: ‘conditions’
[09:31:59.621]   - Field: ‘persistent’
[09:31:59.621]   - Field: ‘expr’
[09:31:59.621]   - Field: ‘uuid’
[09:31:59.621]   - Field: ‘seed’
[09:31:59.621]   - Field: ‘version’
[09:31:59.621]   - Field: ‘result’
[09:31:59.621]   - Field: ‘asynchronous’
[09:31:59.621]   - Field: ‘calls’
[09:31:59.621]   - Field: ‘globals’
[09:31:59.621]   - Field: ‘stdout’
[09:31:59.621]   - Field: ‘earlySignal’
[09:31:59.622]   - Field: ‘lazy’
[09:31:59.622]   - Field: ‘state’
[09:31:59.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:59.622] - Launch lazy future ...
[09:31:59.622] Packages needed by the future expression (n = 1): ‘future’
[09:31:59.622] Packages needed by future strategies (n = 1): ‘future’
[09:31:59.623] {
[09:31:59.623]     {
[09:31:59.623]         {
[09:31:59.623]             ...future.startTime <- base::Sys.time()
[09:31:59.623]             {
[09:31:59.623]                 {
[09:31:59.623]                   {
[09:31:59.623]                     {
[09:31:59.623]                       {
[09:31:59.623]                         base::local({
[09:31:59.623]                           has_future <- base::requireNamespace("future", 
[09:31:59.623]                             quietly = TRUE)
[09:31:59.623]                           if (has_future) {
[09:31:59.623]                             ns <- base::getNamespace("future")
[09:31:59.623]                             version <- ns[[".package"]][["version"]]
[09:31:59.623]                             if (is.null(version)) 
[09:31:59.623]                               version <- utils::packageVersion("future")
[09:31:59.623]                           }
[09:31:59.623]                           else {
[09:31:59.623]                             version <- NULL
[09:31:59.623]                           }
[09:31:59.623]                           if (!has_future || version < "1.8.0") {
[09:31:59.623]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:59.623]                               "", base::R.version$version.string), 
[09:31:59.623]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:59.623]                                 base::R.version$platform, 8 * 
[09:31:59.623]                                   base::.Machine$sizeof.pointer), 
[09:31:59.623]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:59.623]                                 "release", "version")], collapse = " "), 
[09:31:59.623]                               hostname = base::Sys.info()[["nodename"]])
[09:31:59.623]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:59.623]                               info)
[09:31:59.623]                             info <- base::paste(info, collapse = "; ")
[09:31:59.623]                             if (!has_future) {
[09:31:59.623]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:59.623]                                 info)
[09:31:59.623]                             }
[09:31:59.623]                             else {
[09:31:59.623]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:59.623]                                 info, version)
[09:31:59.623]                             }
[09:31:59.623]                             base::stop(msg)
[09:31:59.623]                           }
[09:31:59.623]                         })
[09:31:59.623]                       }
[09:31:59.623]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:59.623]                       base::options(mc.cores = 1L)
[09:31:59.623]                     }
[09:31:59.623]                     base::local({
[09:31:59.623]                       for (pkg in "future") {
[09:31:59.623]                         base::loadNamespace(pkg)
[09:31:59.623]                         base::library(pkg, character.only = TRUE)
[09:31:59.623]                       }
[09:31:59.623]                     })
[09:31:59.623]                   }
[09:31:59.623]                   ...future.strategy.old <- future::plan("list")
[09:31:59.623]                   options(future.plan = NULL)
[09:31:59.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.623]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[09:31:59.623]                     envir = parent.frame()) 
[09:31:59.623]                   {
[09:31:59.623]                     default_workers <- missing(workers)
[09:31:59.623]                     if (is.function(workers)) 
[09:31:59.623]                       workers <- workers()
[09:31:59.623]                     workers <- structure(as.integer(workers), 
[09:31:59.623]                       class = class(workers))
[09:31:59.623]                     stop_if_not(is.finite(workers), workers >= 
[09:31:59.623]                       1L)
[09:31:59.623]                     if ((workers == 1L && !inherits(workers, 
[09:31:59.623]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[09:31:59.623]                       if (default_workers) 
[09:31:59.623]                         supportsMulticore(warn = TRUE)
[09:31:59.623]                       return(sequential(..., envir = envir))
[09:31:59.623]                     }
[09:31:59.623]                     oopts <- options(mc.cores = workers)
[09:31:59.623]                     on.exit(options(oopts))
[09:31:59.623]                     future <- MulticoreFuture(..., workers = workers, 
[09:31:59.623]                       envir = envir)
[09:31:59.623]                     if (!future$lazy) 
[09:31:59.623]                       future <- run(future)
[09:31:59.623]                     invisible(future)
[09:31:59.623]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:59.623]                 }
[09:31:59.623]                 ...future.workdir <- getwd()
[09:31:59.623]             }
[09:31:59.623]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:59.623]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:59.623]         }
[09:31:59.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:59.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:59.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:59.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:59.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:59.623]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:59.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:59.623]             base::names(...future.oldOptions))
[09:31:59.623]     }
[09:31:59.623]     if (FALSE) {
[09:31:59.623]     }
[09:31:59.623]     else {
[09:31:59.623]         if (TRUE) {
[09:31:59.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:59.623]                 open = "w")
[09:31:59.623]         }
[09:31:59.623]         else {
[09:31:59.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:59.623]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:59.623]         }
[09:31:59.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:59.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:59.623]             base::sink(type = "output", split = FALSE)
[09:31:59.623]             base::close(...future.stdout)
[09:31:59.623]         }, add = TRUE)
[09:31:59.623]     }
[09:31:59.623]     ...future.frame <- base::sys.nframe()
[09:31:59.623]     ...future.conditions <- base::list()
[09:31:59.623]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:59.623]     if (FALSE) {
[09:31:59.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:59.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:59.623]     }
[09:31:59.623]     ...future.result <- base::tryCatch({
[09:31:59.623]         base::withCallingHandlers({
[09:31:59.623]             ...future.value <- base::withVisible(base::local({
[09:31:59.623]                 ...future.makeSendCondition <- base::local({
[09:31:59.623]                   sendCondition <- NULL
[09:31:59.623]                   function(frame = 1L) {
[09:31:59.623]                     if (is.function(sendCondition)) 
[09:31:59.623]                       return(sendCondition)
[09:31:59.623]                     ns <- getNamespace("parallel")
[09:31:59.623]                     if (exists("sendData", mode = "function", 
[09:31:59.623]                       envir = ns)) {
[09:31:59.623]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:59.623]                         envir = ns)
[09:31:59.623]                       envir <- sys.frame(frame)
[09:31:59.623]                       master <- NULL
[09:31:59.623]                       while (!identical(envir, .GlobalEnv) && 
[09:31:59.623]                         !identical(envir, emptyenv())) {
[09:31:59.623]                         if (exists("master", mode = "list", envir = envir, 
[09:31:59.623]                           inherits = FALSE)) {
[09:31:59.623]                           master <- get("master", mode = "list", 
[09:31:59.623]                             envir = envir, inherits = FALSE)
[09:31:59.623]                           if (inherits(master, c("SOCKnode", 
[09:31:59.623]                             "SOCK0node"))) {
[09:31:59.623]                             sendCondition <<- function(cond) {
[09:31:59.623]                               data <- list(type = "VALUE", value = cond, 
[09:31:59.623]                                 success = TRUE)
[09:31:59.623]                               parallel_sendData(master, data)
[09:31:59.623]                             }
[09:31:59.623]                             return(sendCondition)
[09:31:59.623]                           }
[09:31:59.623]                         }
[09:31:59.623]                         frame <- frame + 1L
[09:31:59.623]                         envir <- sys.frame(frame)
[09:31:59.623]                       }
[09:31:59.623]                     }
[09:31:59.623]                     sendCondition <<- function(cond) NULL
[09:31:59.623]                   }
[09:31:59.623]                 })
[09:31:59.623]                 withCallingHandlers({
[09:31:59.623]                   {
[09:31:59.623]                     value(future(subset(data, a == 2)))
[09:31:59.623]                   }
[09:31:59.623]                 }, immediateCondition = function(cond) {
[09:31:59.623]                   sendCondition <- ...future.makeSendCondition()
[09:31:59.623]                   sendCondition(cond)
[09:31:59.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.623]                   {
[09:31:59.623]                     inherits <- base::inherits
[09:31:59.623]                     invokeRestart <- base::invokeRestart
[09:31:59.623]                     is.null <- base::is.null
[09:31:59.623]                     muffled <- FALSE
[09:31:59.623]                     if (inherits(cond, "message")) {
[09:31:59.623]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:59.623]                       if (muffled) 
[09:31:59.623]                         invokeRestart("muffleMessage")
[09:31:59.623]                     }
[09:31:59.623]                     else if (inherits(cond, "warning")) {
[09:31:59.623]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:59.623]                       if (muffled) 
[09:31:59.623]                         invokeRestart("muffleWarning")
[09:31:59.623]                     }
[09:31:59.623]                     else if (inherits(cond, "condition")) {
[09:31:59.623]                       if (!is.null(pattern)) {
[09:31:59.623]                         computeRestarts <- base::computeRestarts
[09:31:59.623]                         grepl <- base::grepl
[09:31:59.623]                         restarts <- computeRestarts(cond)
[09:31:59.623]                         for (restart in restarts) {
[09:31:59.623]                           name <- restart$name
[09:31:59.623]                           if (is.null(name)) 
[09:31:59.623]                             next
[09:31:59.623]                           if (!grepl(pattern, name)) 
[09:31:59.623]                             next
[09:31:59.623]                           invokeRestart(restart)
[09:31:59.623]                           muffled <- TRUE
[09:31:59.623]                           break
[09:31:59.623]                         }
[09:31:59.623]                       }
[09:31:59.623]                     }
[09:31:59.623]                     invisible(muffled)
[09:31:59.623]                   }
[09:31:59.623]                   muffleCondition(cond)
[09:31:59.623]                 })
[09:31:59.623]             }))
[09:31:59.623]             future::FutureResult(value = ...future.value$value, 
[09:31:59.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.623]                   ...future.rng), globalenv = if (FALSE) 
[09:31:59.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:59.623]                     ...future.globalenv.names))
[09:31:59.623]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:59.623]         }, condition = base::local({
[09:31:59.623]             c <- base::c
[09:31:59.623]             inherits <- base::inherits
[09:31:59.623]             invokeRestart <- base::invokeRestart
[09:31:59.623]             length <- base::length
[09:31:59.623]             list <- base::list
[09:31:59.623]             seq.int <- base::seq.int
[09:31:59.623]             signalCondition <- base::signalCondition
[09:31:59.623]             sys.calls <- base::sys.calls
[09:31:59.623]             `[[` <- base::`[[`
[09:31:59.623]             `+` <- base::`+`
[09:31:59.623]             `<<-` <- base::`<<-`
[09:31:59.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:59.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:59.623]                   3L)]
[09:31:59.623]             }
[09:31:59.623]             function(cond) {
[09:31:59.623]                 is_error <- inherits(cond, "error")
[09:31:59.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:59.623]                   NULL)
[09:31:59.623]                 if (is_error) {
[09:31:59.623]                   sessionInformation <- function() {
[09:31:59.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:59.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:59.623]                       search = base::search(), system = base::Sys.info())
[09:31:59.623]                   }
[09:31:59.623]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:59.623]                     cond$call), session = sessionInformation(), 
[09:31:59.623]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:59.623]                   signalCondition(cond)
[09:31:59.623]                 }
[09:31:59.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:59.623]                 "immediateCondition"))) {
[09:31:59.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:59.623]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:59.623]                   if (TRUE && !signal) {
[09:31:59.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.623]                     {
[09:31:59.623]                       inherits <- base::inherits
[09:31:59.623]                       invokeRestart <- base::invokeRestart
[09:31:59.623]                       is.null <- base::is.null
[09:31:59.623]                       muffled <- FALSE
[09:31:59.623]                       if (inherits(cond, "message")) {
[09:31:59.623]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.623]                         if (muffled) 
[09:31:59.623]                           invokeRestart("muffleMessage")
[09:31:59.623]                       }
[09:31:59.623]                       else if (inherits(cond, "warning")) {
[09:31:59.623]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.623]                         if (muffled) 
[09:31:59.623]                           invokeRestart("muffleWarning")
[09:31:59.623]                       }
[09:31:59.623]                       else if (inherits(cond, "condition")) {
[09:31:59.623]                         if (!is.null(pattern)) {
[09:31:59.623]                           computeRestarts <- base::computeRestarts
[09:31:59.623]                           grepl <- base::grepl
[09:31:59.623]                           restarts <- computeRestarts(cond)
[09:31:59.623]                           for (restart in restarts) {
[09:31:59.623]                             name <- restart$name
[09:31:59.623]                             if (is.null(name)) 
[09:31:59.623]                               next
[09:31:59.623]                             if (!grepl(pattern, name)) 
[09:31:59.623]                               next
[09:31:59.623]                             invokeRestart(restart)
[09:31:59.623]                             muffled <- TRUE
[09:31:59.623]                             break
[09:31:59.623]                           }
[09:31:59.623]                         }
[09:31:59.623]                       }
[09:31:59.623]                       invisible(muffled)
[09:31:59.623]                     }
[09:31:59.623]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.623]                   }
[09:31:59.623]                 }
[09:31:59.623]                 else {
[09:31:59.623]                   if (TRUE) {
[09:31:59.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.623]                     {
[09:31:59.623]                       inherits <- base::inherits
[09:31:59.623]                       invokeRestart <- base::invokeRestart
[09:31:59.623]                       is.null <- base::is.null
[09:31:59.623]                       muffled <- FALSE
[09:31:59.623]                       if (inherits(cond, "message")) {
[09:31:59.623]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.623]                         if (muffled) 
[09:31:59.623]                           invokeRestart("muffleMessage")
[09:31:59.623]                       }
[09:31:59.623]                       else if (inherits(cond, "warning")) {
[09:31:59.623]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.623]                         if (muffled) 
[09:31:59.623]                           invokeRestart("muffleWarning")
[09:31:59.623]                       }
[09:31:59.623]                       else if (inherits(cond, "condition")) {
[09:31:59.623]                         if (!is.null(pattern)) {
[09:31:59.623]                           computeRestarts <- base::computeRestarts
[09:31:59.623]                           grepl <- base::grepl
[09:31:59.623]                           restarts <- computeRestarts(cond)
[09:31:59.623]                           for (restart in restarts) {
[09:31:59.623]                             name <- restart$name
[09:31:59.623]                             if (is.null(name)) 
[09:31:59.623]                               next
[09:31:59.623]                             if (!grepl(pattern, name)) 
[09:31:59.623]                               next
[09:31:59.623]                             invokeRestart(restart)
[09:31:59.623]                             muffled <- TRUE
[09:31:59.623]                             break
[09:31:59.623]                           }
[09:31:59.623]                         }
[09:31:59.623]                       }
[09:31:59.623]                       invisible(muffled)
[09:31:59.623]                     }
[09:31:59.623]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.623]                   }
[09:31:59.623]                 }
[09:31:59.623]             }
[09:31:59.623]         }))
[09:31:59.623]     }, error = function(ex) {
[09:31:59.623]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:59.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.623]                 ...future.rng), started = ...future.startTime, 
[09:31:59.623]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:59.623]             version = "1.8"), class = "FutureResult")
[09:31:59.623]     }, finally = {
[09:31:59.623]         if (!identical(...future.workdir, getwd())) 
[09:31:59.623]             setwd(...future.workdir)
[09:31:59.623]         {
[09:31:59.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:59.623]                 ...future.oldOptions$nwarnings <- NULL
[09:31:59.623]             }
[09:31:59.623]             base::options(...future.oldOptions)
[09:31:59.623]             if (.Platform$OS.type == "windows") {
[09:31:59.623]                 old_names <- names(...future.oldEnvVars)
[09:31:59.623]                 envs <- base::Sys.getenv()
[09:31:59.623]                 names <- names(envs)
[09:31:59.623]                 common <- intersect(names, old_names)
[09:31:59.623]                 added <- setdiff(names, old_names)
[09:31:59.623]                 removed <- setdiff(old_names, names)
[09:31:59.623]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:59.623]                   envs[common]]
[09:31:59.623]                 NAMES <- toupper(changed)
[09:31:59.623]                 args <- list()
[09:31:59.623]                 for (kk in seq_along(NAMES)) {
[09:31:59.623]                   name <- changed[[kk]]
[09:31:59.623]                   NAME <- NAMES[[kk]]
[09:31:59.623]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.623]                     next
[09:31:59.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.623]                 }
[09:31:59.623]                 NAMES <- toupper(added)
[09:31:59.623]                 for (kk in seq_along(NAMES)) {
[09:31:59.623]                   name <- added[[kk]]
[09:31:59.623]                   NAME <- NAMES[[kk]]
[09:31:59.623]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.623]                     next
[09:31:59.623]                   args[[name]] <- ""
[09:31:59.623]                 }
[09:31:59.623]                 NAMES <- toupper(removed)
[09:31:59.623]                 for (kk in seq_along(NAMES)) {
[09:31:59.623]                   name <- removed[[kk]]
[09:31:59.623]                   NAME <- NAMES[[kk]]
[09:31:59.623]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.623]                     next
[09:31:59.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.623]                 }
[09:31:59.623]                 if (length(args) > 0) 
[09:31:59.623]                   base::do.call(base::Sys.setenv, args = args)
[09:31:59.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:59.623]             }
[09:31:59.623]             else {
[09:31:59.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:59.623]             }
[09:31:59.623]             {
[09:31:59.623]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:59.623]                   0L) {
[09:31:59.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:59.623]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:59.623]                   base::options(opts)
[09:31:59.623]                 }
[09:31:59.623]                 {
[09:31:59.623]                   {
[09:31:59.623]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:59.623]                     NULL
[09:31:59.623]                   }
[09:31:59.623]                   options(future.plan = NULL)
[09:31:59.623]                   if (is.na(NA_character_)) 
[09:31:59.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:59.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:59.623]                     .init = FALSE)
[09:31:59.623]                 }
[09:31:59.623]             }
[09:31:59.623]         }
[09:31:59.623]     })
[09:31:59.623]     if (TRUE) {
[09:31:59.623]         base::sink(type = "output", split = FALSE)
[09:31:59.623]         if (TRUE) {
[09:31:59.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:59.623]         }
[09:31:59.623]         else {
[09:31:59.623]             ...future.result["stdout"] <- base::list(NULL)
[09:31:59.623]         }
[09:31:59.623]         base::close(...future.stdout)
[09:31:59.623]         ...future.stdout <- NULL
[09:31:59.623]     }
[09:31:59.623]     ...future.result$conditions <- ...future.conditions
[09:31:59.623]     ...future.result$finished <- base::Sys.time()
[09:31:59.623]     ...future.result
[09:31:59.623] }
[09:31:59.625] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[09:31:59.626] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[09:31:59.626] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[09:31:59.626] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[09:31:59.627] MultisessionFuture started
[09:31:59.627] - Launch lazy future ... done
[09:31:59.627] run() for ‘MultisessionFuture’ ... done
[09:31:59.627] result() for ClusterFuture ...
[09:31:59.627] receiveMessageFromWorker() for ClusterFuture ...
[09:31:59.627] - Validating connection of MultisessionFuture
[09:31:59.682] - received message: FutureResult
[09:31:59.682] - Received FutureResult
[09:31:59.682] - Erased future from FutureRegistry
[09:31:59.682] result() for ClusterFuture ...
[09:31:59.682] - result already collected: FutureResult
[09:31:59.682] result() for ClusterFuture ... done
[09:31:59.682] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:59.682] result() for ClusterFuture ... done
[09:31:59.682] result() for ClusterFuture ...
[09:31:59.683] - result already collected: FutureResult
[09:31:59.683] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[09:31:59.683] plan(): Setting new future strategy stack:
[09:31:59.683] List of future strategies:
[09:31:59.683] 1. multisession:
[09:31:59.683]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:59.683]    - tweaked: FALSE
[09:31:59.683]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:59.683] 2. multisession:
[09:31:59.683]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:59.683]    - tweaked: FALSE
[09:31:59.683]    - call: plan(list(a = strategy1, b = strategy2))
[09:31:59.684] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:59.684] multisession:
[09:31:59.684] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:59.684] - tweaked: FALSE
[09:31:59.684] - call: plan(list(a = strategy1, b = strategy2))
[09:31:59.689] getGlobalsAndPackages() ...
[09:31:59.689] Not searching for globals
[09:31:59.689] - globals: [0] <none>
[09:31:59.689] getGlobalsAndPackages() ... DONE
[09:31:59.690] [local output] makeClusterPSOCK() ...
[09:31:59.694] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:59.695] [local output] Base port: 11866
[09:31:59.695] [local output] Getting setup options for 2 cluster nodes ...
[09:31:59.696] [local output]  - Node 1 of 2 ...
[09:31:59.696] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:59.697] [local output] Rscript port: 11866

[09:31:59.698] [local output]  - Node 2 of 2 ...
[09:31:59.698] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:59.699] [local output] Rscript port: 11866

[09:31:59.699] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:59.699] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:59.700] [local output] Setting up PSOCK nodes in parallel
[09:31:59.700] List of 36
[09:31:59.700]  $ worker          : chr "localhost"
[09:31:59.700]   ..- attr(*, "localhost")= logi TRUE
[09:31:59.700]  $ master          : chr "localhost"
[09:31:59.700]  $ port            : int 11866
[09:31:59.700]  $ connectTimeout  : num 120
[09:31:59.700]  $ timeout         : num 2592000
[09:31:59.700]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:59.700]  $ homogeneous     : logi TRUE
[09:31:59.700]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:59.700]  $ rscript_envs    : NULL
[09:31:59.700]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:59.700]  $ rscript_startup : NULL
[09:31:59.700]  $ rscript_sh      : chr "sh"
[09:31:59.700]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:59.700]  $ methods         : logi TRUE
[09:31:59.700]  $ socketOptions   : chr "no-delay"
[09:31:59.700]  $ useXDR          : logi FALSE
[09:31:59.700]  $ outfile         : chr "/dev/null"
[09:31:59.700]  $ renice          : int NA
[09:31:59.700]  $ rshcmd          : NULL
[09:31:59.700]  $ user            : chr(0) 
[09:31:59.700]  $ revtunnel       : logi FALSE
[09:31:59.700]  $ rshlogfile      : NULL
[09:31:59.700]  $ rshopts         : chr(0) 
[09:31:59.700]  $ rank            : int 1
[09:31:59.700]  $ manual          : logi FALSE
[09:31:59.700]  $ dryrun          : logi FALSE
[09:31:59.700]  $ quiet           : logi FALSE
[09:31:59.700]  $ setup_strategy  : chr "parallel"
[09:31:59.700]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:59.700]  $ pidfile         : chr "/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b916110e714c.pid"
[09:31:59.700]  $ rshcmd_label    : NULL
[09:31:59.700]  $ rsh_call        : NULL
[09:31:59.700]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:59.700]  $ localMachine    : logi TRUE
[09:31:59.700]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:59.700]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:59.700]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:59.700]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:59.700]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:59.700]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:59.700]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:59.700]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:59.700]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:59.700]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:59.700]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:59.700]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:59.700]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:59.700]  $ arguments       :List of 28
[09:31:59.700]   ..$ worker          : chr "localhost"
[09:31:59.700]   ..$ master          : NULL
[09:31:59.700]   ..$ port            : int 11866
[09:31:59.700]   ..$ connectTimeout  : num 120
[09:31:59.700]   ..$ timeout         : num 2592000
[09:31:59.700]   ..$ rscript         : NULL
[09:31:59.700]   ..$ homogeneous     : NULL
[09:31:59.700]   ..$ rscript_args    : NULL
[09:31:59.700]   ..$ rscript_envs    : NULL
[09:31:59.700]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:59.700]   ..$ rscript_startup : NULL
[09:31:59.700]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:59.700]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:59.700]   ..$ methods         : logi TRUE
[09:31:59.700]   ..$ socketOptions   : chr "no-delay"
[09:31:59.700]   ..$ useXDR          : logi FALSE
[09:31:59.700]   ..$ outfile         : chr "/dev/null"
[09:31:59.700]   ..$ renice          : int NA
[09:31:59.700]   ..$ rshcmd          : NULL
[09:31:59.700]   ..$ user            : NULL
[09:31:59.700]   ..$ revtunnel       : logi NA
[09:31:59.700]   ..$ rshlogfile      : NULL
[09:31:59.700]   ..$ rshopts         : NULL
[09:31:59.700]   ..$ rank            : int 1
[09:31:59.700]   ..$ manual          : logi FALSE
[09:31:59.700]   ..$ dryrun          : logi FALSE
[09:31:59.700]   ..$ quiet           : logi FALSE
[09:31:59.700]   ..$ setup_strategy  : chr "parallel"
[09:31:59.700]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:59.720] [local output] System call to launch all workers:
[09:31:59.720] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuDppLD/worker.rank=1.parallelly.parent=47382.b916110e714c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11866 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:59.720] [local output] Starting PSOCK main server
[09:31:59.721] [local output] Workers launched
[09:31:59.721] [local output] Waiting for workers to connect back
[09:31:59.722]  - [local output] 0 workers out of 2 ready
[09:31:59.963]  - [local output] 0 workers out of 2 ready
[09:31:59.963]  - [local output] 1 workers out of 2 ready
[09:31:59.969]  - [local output] 1 workers out of 2 ready
[09:31:59.969]  - [local output] 2 workers out of 2 ready
[09:31:59.969] [local output] Launching of workers completed
[09:31:59.969] [local output] Collecting session information from workers
[09:31:59.970] [local output]  - Worker #1 of 2
[09:31:59.970] [local output]  - Worker #2 of 2
[09:31:59.970] [local output] makeClusterPSOCK() ... done
[09:31:59.981] Packages needed by the future expression (n = 0): <none>
[09:31:59.981] Packages needed by future strategies (n = 1): ‘future’
[09:31:59.982] {
[09:31:59.982]     {
[09:31:59.982]         {
[09:31:59.982]             ...future.startTime <- base::Sys.time()
[09:31:59.982]             {
[09:31:59.982]                 {
[09:31:59.982]                   {
[09:31:59.982]                     {
[09:31:59.982]                       {
[09:31:59.982]                         base::local({
[09:31:59.982]                           has_future <- base::requireNamespace("future", 
[09:31:59.982]                             quietly = TRUE)
[09:31:59.982]                           if (has_future) {
[09:31:59.982]                             ns <- base::getNamespace("future")
[09:31:59.982]                             version <- ns[[".package"]][["version"]]
[09:31:59.982]                             if (is.null(version)) 
[09:31:59.982]                               version <- utils::packageVersion("future")
[09:31:59.982]                           }
[09:31:59.982]                           else {
[09:31:59.982]                             version <- NULL
[09:31:59.982]                           }
[09:31:59.982]                           if (!has_future || version < "1.8.0") {
[09:31:59.982]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:59.982]                               "", base::R.version$version.string), 
[09:31:59.982]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:59.982]                                 base::R.version$platform, 8 * 
[09:31:59.982]                                   base::.Machine$sizeof.pointer), 
[09:31:59.982]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:59.982]                                 "release", "version")], collapse = " "), 
[09:31:59.982]                               hostname = base::Sys.info()[["nodename"]])
[09:31:59.982]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:59.982]                               info)
[09:31:59.982]                             info <- base::paste(info, collapse = "; ")
[09:31:59.982]                             if (!has_future) {
[09:31:59.982]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:59.982]                                 info)
[09:31:59.982]                             }
[09:31:59.982]                             else {
[09:31:59.982]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:59.982]                                 info, version)
[09:31:59.982]                             }
[09:31:59.982]                             base::stop(msg)
[09:31:59.982]                           }
[09:31:59.982]                         })
[09:31:59.982]                       }
[09:31:59.982]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:59.982]                       base::options(mc.cores = 1L)
[09:31:59.982]                     }
[09:31:59.982]                     base::local({
[09:31:59.982]                       for (pkg in "future") {
[09:31:59.982]                         base::loadNamespace(pkg)
[09:31:59.982]                         base::library(pkg, character.only = TRUE)
[09:31:59.982]                       }
[09:31:59.982]                     })
[09:31:59.982]                   }
[09:31:59.982]                   ...future.strategy.old <- future::plan("list")
[09:31:59.982]                   options(future.plan = NULL)
[09:31:59.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.982]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:31:59.982]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:31:59.982]                     envir = parent.frame()) 
[09:31:59.982]                   {
[09:31:59.982]                     if (is.function(workers)) 
[09:31:59.982]                       workers <- workers()
[09:31:59.982]                     workers <- structure(as.integer(workers), 
[09:31:59.982]                       class = class(workers))
[09:31:59.982]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:31:59.982]                       workers >= 1)
[09:31:59.982]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:31:59.982]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:31:59.982]                     }
[09:31:59.982]                     future <- MultisessionFuture(..., workers = workers, 
[09:31:59.982]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:31:59.982]                       envir = envir)
[09:31:59.982]                     if (!future$lazy) 
[09:31:59.982]                       future <- run(future)
[09:31:59.982]                     invisible(future)
[09:31:59.982]                   }), .cleanup = FALSE, .init = FALSE)
[09:31:59.982]                 }
[09:31:59.982]                 ...future.workdir <- getwd()
[09:31:59.982]             }
[09:31:59.982]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:59.982]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:59.982]         }
[09:31:59.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:59.982]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:59.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:59.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:59.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:59.982]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:59.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:59.982]             base::names(...future.oldOptions))
[09:31:59.982]     }
[09:31:59.982]     if (FALSE) {
[09:31:59.982]     }
[09:31:59.982]     else {
[09:31:59.982]         if (TRUE) {
[09:31:59.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:59.982]                 open = "w")
[09:31:59.982]         }
[09:31:59.982]         else {
[09:31:59.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:59.982]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:59.982]         }
[09:31:59.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:59.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:59.982]             base::sink(type = "output", split = FALSE)
[09:31:59.982]             base::close(...future.stdout)
[09:31:59.982]         }, add = TRUE)
[09:31:59.982]     }
[09:31:59.982]     ...future.frame <- base::sys.nframe()
[09:31:59.982]     ...future.conditions <- base::list()
[09:31:59.982]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:59.982]     if (FALSE) {
[09:31:59.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:59.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:59.982]     }
[09:31:59.982]     ...future.result <- base::tryCatch({
[09:31:59.982]         base::withCallingHandlers({
[09:31:59.982]             ...future.value <- base::withVisible(base::local({
[09:31:59.982]                 ...future.makeSendCondition <- base::local({
[09:31:59.982]                   sendCondition <- NULL
[09:31:59.982]                   function(frame = 1L) {
[09:31:59.982]                     if (is.function(sendCondition)) 
[09:31:59.982]                       return(sendCondition)
[09:31:59.982]                     ns <- getNamespace("parallel")
[09:31:59.982]                     if (exists("sendData", mode = "function", 
[09:31:59.982]                       envir = ns)) {
[09:31:59.982]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:59.982]                         envir = ns)
[09:31:59.982]                       envir <- sys.frame(frame)
[09:31:59.982]                       master <- NULL
[09:31:59.982]                       while (!identical(envir, .GlobalEnv) && 
[09:31:59.982]                         !identical(envir, emptyenv())) {
[09:31:59.982]                         if (exists("master", mode = "list", envir = envir, 
[09:31:59.982]                           inherits = FALSE)) {
[09:31:59.982]                           master <- get("master", mode = "list", 
[09:31:59.982]                             envir = envir, inherits = FALSE)
[09:31:59.982]                           if (inherits(master, c("SOCKnode", 
[09:31:59.982]                             "SOCK0node"))) {
[09:31:59.982]                             sendCondition <<- function(cond) {
[09:31:59.982]                               data <- list(type = "VALUE", value = cond, 
[09:31:59.982]                                 success = TRUE)
[09:31:59.982]                               parallel_sendData(master, data)
[09:31:59.982]                             }
[09:31:59.982]                             return(sendCondition)
[09:31:59.982]                           }
[09:31:59.982]                         }
[09:31:59.982]                         frame <- frame + 1L
[09:31:59.982]                         envir <- sys.frame(frame)
[09:31:59.982]                       }
[09:31:59.982]                     }
[09:31:59.982]                     sendCondition <<- function(cond) NULL
[09:31:59.982]                   }
[09:31:59.982]                 })
[09:31:59.982]                 withCallingHandlers({
[09:31:59.982]                   NA
[09:31:59.982]                 }, immediateCondition = function(cond) {
[09:31:59.982]                   sendCondition <- ...future.makeSendCondition()
[09:31:59.982]                   sendCondition(cond)
[09:31:59.982]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.982]                   {
[09:31:59.982]                     inherits <- base::inherits
[09:31:59.982]                     invokeRestart <- base::invokeRestart
[09:31:59.982]                     is.null <- base::is.null
[09:31:59.982]                     muffled <- FALSE
[09:31:59.982]                     if (inherits(cond, "message")) {
[09:31:59.982]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:59.982]                       if (muffled) 
[09:31:59.982]                         invokeRestart("muffleMessage")
[09:31:59.982]                     }
[09:31:59.982]                     else if (inherits(cond, "warning")) {
[09:31:59.982]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:59.982]                       if (muffled) 
[09:31:59.982]                         invokeRestart("muffleWarning")
[09:31:59.982]                     }
[09:31:59.982]                     else if (inherits(cond, "condition")) {
[09:31:59.982]                       if (!is.null(pattern)) {
[09:31:59.982]                         computeRestarts <- base::computeRestarts
[09:31:59.982]                         grepl <- base::grepl
[09:31:59.982]                         restarts <- computeRestarts(cond)
[09:31:59.982]                         for (restart in restarts) {
[09:31:59.982]                           name <- restart$name
[09:31:59.982]                           if (is.null(name)) 
[09:31:59.982]                             next
[09:31:59.982]                           if (!grepl(pattern, name)) 
[09:31:59.982]                             next
[09:31:59.982]                           invokeRestart(restart)
[09:31:59.982]                           muffled <- TRUE
[09:31:59.982]                           break
[09:31:59.982]                         }
[09:31:59.982]                       }
[09:31:59.982]                     }
[09:31:59.982]                     invisible(muffled)
[09:31:59.982]                   }
[09:31:59.982]                   muffleCondition(cond)
[09:31:59.982]                 })
[09:31:59.982]             }))
[09:31:59.982]             future::FutureResult(value = ...future.value$value, 
[09:31:59.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.982]                   ...future.rng), globalenv = if (FALSE) 
[09:31:59.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:59.982]                     ...future.globalenv.names))
[09:31:59.982]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:59.982]         }, condition = base::local({
[09:31:59.982]             c <- base::c
[09:31:59.982]             inherits <- base::inherits
[09:31:59.982]             invokeRestart <- base::invokeRestart
[09:31:59.982]             length <- base::length
[09:31:59.982]             list <- base::list
[09:31:59.982]             seq.int <- base::seq.int
[09:31:59.982]             signalCondition <- base::signalCondition
[09:31:59.982]             sys.calls <- base::sys.calls
[09:31:59.982]             `[[` <- base::`[[`
[09:31:59.982]             `+` <- base::`+`
[09:31:59.982]             `<<-` <- base::`<<-`
[09:31:59.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:59.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:59.982]                   3L)]
[09:31:59.982]             }
[09:31:59.982]             function(cond) {
[09:31:59.982]                 is_error <- inherits(cond, "error")
[09:31:59.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:59.982]                   NULL)
[09:31:59.982]                 if (is_error) {
[09:31:59.982]                   sessionInformation <- function() {
[09:31:59.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:59.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:59.982]                       search = base::search(), system = base::Sys.info())
[09:31:59.982]                   }
[09:31:59.982]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:59.982]                     cond$call), session = sessionInformation(), 
[09:31:59.982]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:59.982]                   signalCondition(cond)
[09:31:59.982]                 }
[09:31:59.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:59.982]                 "immediateCondition"))) {
[09:31:59.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:59.982]                   ...future.conditions[[length(...future.conditions) + 
[09:31:59.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:59.982]                   if (TRUE && !signal) {
[09:31:59.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.982]                     {
[09:31:59.982]                       inherits <- base::inherits
[09:31:59.982]                       invokeRestart <- base::invokeRestart
[09:31:59.982]                       is.null <- base::is.null
[09:31:59.982]                       muffled <- FALSE
[09:31:59.982]                       if (inherits(cond, "message")) {
[09:31:59.982]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.982]                         if (muffled) 
[09:31:59.982]                           invokeRestart("muffleMessage")
[09:31:59.982]                       }
[09:31:59.982]                       else if (inherits(cond, "warning")) {
[09:31:59.982]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.982]                         if (muffled) 
[09:31:59.982]                           invokeRestart("muffleWarning")
[09:31:59.982]                       }
[09:31:59.982]                       else if (inherits(cond, "condition")) {
[09:31:59.982]                         if (!is.null(pattern)) {
[09:31:59.982]                           computeRestarts <- base::computeRestarts
[09:31:59.982]                           grepl <- base::grepl
[09:31:59.982]                           restarts <- computeRestarts(cond)
[09:31:59.982]                           for (restart in restarts) {
[09:31:59.982]                             name <- restart$name
[09:31:59.982]                             if (is.null(name)) 
[09:31:59.982]                               next
[09:31:59.982]                             if (!grepl(pattern, name)) 
[09:31:59.982]                               next
[09:31:59.982]                             invokeRestart(restart)
[09:31:59.982]                             muffled <- TRUE
[09:31:59.982]                             break
[09:31:59.982]                           }
[09:31:59.982]                         }
[09:31:59.982]                       }
[09:31:59.982]                       invisible(muffled)
[09:31:59.982]                     }
[09:31:59.982]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.982]                   }
[09:31:59.982]                 }
[09:31:59.982]                 else {
[09:31:59.982]                   if (TRUE) {
[09:31:59.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:59.982]                     {
[09:31:59.982]                       inherits <- base::inherits
[09:31:59.982]                       invokeRestart <- base::invokeRestart
[09:31:59.982]                       is.null <- base::is.null
[09:31:59.982]                       muffled <- FALSE
[09:31:59.982]                       if (inherits(cond, "message")) {
[09:31:59.982]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:59.982]                         if (muffled) 
[09:31:59.982]                           invokeRestart("muffleMessage")
[09:31:59.982]                       }
[09:31:59.982]                       else if (inherits(cond, "warning")) {
[09:31:59.982]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:59.982]                         if (muffled) 
[09:31:59.982]                           invokeRestart("muffleWarning")
[09:31:59.982]                       }
[09:31:59.982]                       else if (inherits(cond, "condition")) {
[09:31:59.982]                         if (!is.null(pattern)) {
[09:31:59.982]                           computeRestarts <- base::computeRestarts
[09:31:59.982]                           grepl <- base::grepl
[09:31:59.982]                           restarts <- computeRestarts(cond)
[09:31:59.982]                           for (restart in restarts) {
[09:31:59.982]                             name <- restart$name
[09:31:59.982]                             if (is.null(name)) 
[09:31:59.982]                               next
[09:31:59.982]                             if (!grepl(pattern, name)) 
[09:31:59.982]                               next
[09:31:59.982]                             invokeRestart(restart)
[09:31:59.982]                             muffled <- TRUE
[09:31:59.982]                             break
[09:31:59.982]                           }
[09:31:59.982]                         }
[09:31:59.982]                       }
[09:31:59.982]                       invisible(muffled)
[09:31:59.982]                     }
[09:31:59.982]                     muffleCondition(cond, pattern = "^muffle")
[09:31:59.982]                   }
[09:31:59.982]                 }
[09:31:59.982]             }
[09:31:59.982]         }))
[09:31:59.982]     }, error = function(ex) {
[09:31:59.982]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:59.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:59.982]                 ...future.rng), started = ...future.startTime, 
[09:31:59.982]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:59.982]             version = "1.8"), class = "FutureResult")
[09:31:59.982]     }, finally = {
[09:31:59.982]         if (!identical(...future.workdir, getwd())) 
[09:31:59.982]             setwd(...future.workdir)
[09:31:59.982]         {
[09:31:59.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:59.982]                 ...future.oldOptions$nwarnings <- NULL
[09:31:59.982]             }
[09:31:59.982]             base::options(...future.oldOptions)
[09:31:59.982]             if (.Platform$OS.type == "windows") {
[09:31:59.982]                 old_names <- names(...future.oldEnvVars)
[09:31:59.982]                 envs <- base::Sys.getenv()
[09:31:59.982]                 names <- names(envs)
[09:31:59.982]                 common <- intersect(names, old_names)
[09:31:59.982]                 added <- setdiff(names, old_names)
[09:31:59.982]                 removed <- setdiff(old_names, names)
[09:31:59.982]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:59.982]                   envs[common]]
[09:31:59.982]                 NAMES <- toupper(changed)
[09:31:59.982]                 args <- list()
[09:31:59.982]                 for (kk in seq_along(NAMES)) {
[09:31:59.982]                   name <- changed[[kk]]
[09:31:59.982]                   NAME <- NAMES[[kk]]
[09:31:59.982]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.982]                     next
[09:31:59.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.982]                 }
[09:31:59.982]                 NAMES <- toupper(added)
[09:31:59.982]                 for (kk in seq_along(NAMES)) {
[09:31:59.982]                   name <- added[[kk]]
[09:31:59.982]                   NAME <- NAMES[[kk]]
[09:31:59.982]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.982]                     next
[09:31:59.982]                   args[[name]] <- ""
[09:31:59.982]                 }
[09:31:59.982]                 NAMES <- toupper(removed)
[09:31:59.982]                 for (kk in seq_along(NAMES)) {
[09:31:59.982]                   name <- removed[[kk]]
[09:31:59.982]                   NAME <- NAMES[[kk]]
[09:31:59.982]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:59.982]                     next
[09:31:59.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:59.982]                 }
[09:31:59.982]                 if (length(args) > 0) 
[09:31:59.982]                   base::do.call(base::Sys.setenv, args = args)
[09:31:59.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:59.982]             }
[09:31:59.982]             else {
[09:31:59.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:59.982]             }
[09:31:59.982]             {
[09:31:59.982]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:59.982]                   0L) {
[09:31:59.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:59.982]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:59.982]                   base::options(opts)
[09:31:59.982]                 }
[09:31:59.982]                 {
[09:31:59.982]                   {
[09:31:59.982]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:59.982]                     NULL
[09:31:59.982]                   }
[09:31:59.982]                   options(future.plan = NULL)
[09:31:59.982]                   if (is.na(NA_character_)) 
[09:31:59.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:59.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:59.982]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:59.982]                     .init = FALSE)
[09:31:59.982]                 }
[09:31:59.982]             }
[09:31:59.982]         }
[09:31:59.982]     })
[09:31:59.982]     if (TRUE) {
[09:31:59.982]         base::sink(type = "output", split = FALSE)
[09:31:59.982]         if (TRUE) {
[09:31:59.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:59.982]         }
[09:31:59.982]         else {
[09:31:59.982]             ...future.result["stdout"] <- base::list(NULL)
[09:31:59.982]         }
[09:31:59.982]         base::close(...future.stdout)
[09:31:59.982]         ...future.stdout <- NULL
[09:31:59.982]     }
[09:31:59.982]     ...future.result$conditions <- ...future.conditions
[09:31:59.982]     ...future.result$finished <- base::Sys.time()
[09:31:59.982]     ...future.result
[09:31:59.982] }
[09:32:00.032] MultisessionFuture started
[09:32:00.033] result() for ClusterFuture ...
[09:32:00.033] receiveMessageFromWorker() for ClusterFuture ...
[09:32:00.033] - Validating connection of MultisessionFuture
[09:32:00.076] - received message: FutureResult
[09:32:00.077] - Received FutureResult
[09:32:00.077] - Erased future from FutureRegistry
[09:32:00.077] result() for ClusterFuture ...
[09:32:00.077] - result already collected: FutureResult
[09:32:00.077] result() for ClusterFuture ... done
[09:32:00.077] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:00.077] result() for ClusterFuture ... done
[09:32:00.077] result() for ClusterFuture ...
[09:32:00.077] - result already collected: FutureResult
[09:32:00.078] result() for ClusterFuture ... done
[09:32:00.078] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:32:00.081] plan(): nbrOfWorkers() = 2
[09:32:00.081] getGlobalsAndPackages() ...
[09:32:00.081] Searching for globals...
[09:32:00.097] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[09:32:00.097] Searching for globals ... DONE
[09:32:00.097] Resolving globals: FALSE
[09:32:00.098] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[09:32:00.098] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[09:32:00.099] - globals: [2] ‘nested’, ‘strategy2’
[09:32:00.099] - packages: [1] ‘future’
[09:32:00.099] getGlobalsAndPackages() ... DONE
[09:32:00.099] run() for ‘Future’ ...
[09:32:00.099] - state: ‘created’
[09:32:00.099] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:00.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:00.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:00.113]   - Field: ‘node’
[09:32:00.113]   - Field: ‘label’
[09:32:00.113]   - Field: ‘local’
[09:32:00.113]   - Field: ‘owner’
[09:32:00.113]   - Field: ‘envir’
[09:32:00.113]   - Field: ‘workers’
[09:32:00.113]   - Field: ‘packages’
[09:32:00.114]   - Field: ‘gc’
[09:32:00.114]   - Field: ‘conditions’
[09:32:00.114]   - Field: ‘persistent’
[09:32:00.114]   - Field: ‘expr’
[09:32:00.114]   - Field: ‘uuid’
[09:32:00.114]   - Field: ‘seed’
[09:32:00.114]   - Field: ‘version’
[09:32:00.114]   - Field: ‘result’
[09:32:00.114]   - Field: ‘asynchronous’
[09:32:00.114]   - Field: ‘calls’
[09:32:00.114]   - Field: ‘globals’
[09:32:00.115]   - Field: ‘stdout’
[09:32:00.115]   - Field: ‘earlySignal’
[09:32:00.115]   - Field: ‘lazy’
[09:32:00.115]   - Field: ‘state’
[09:32:00.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:00.115] - Launch lazy future ...
[09:32:00.115] Packages needed by the future expression (n = 1): ‘future’
[09:32:00.115] Packages needed by future strategies (n = 1): ‘future’
[09:32:00.116] {
[09:32:00.116]     {
[09:32:00.116]         {
[09:32:00.116]             ...future.startTime <- base::Sys.time()
[09:32:00.116]             {
[09:32:00.116]                 {
[09:32:00.116]                   {
[09:32:00.116]                     {
[09:32:00.116]                       {
[09:32:00.116]                         base::local({
[09:32:00.116]                           has_future <- base::requireNamespace("future", 
[09:32:00.116]                             quietly = TRUE)
[09:32:00.116]                           if (has_future) {
[09:32:00.116]                             ns <- base::getNamespace("future")
[09:32:00.116]                             version <- ns[[".package"]][["version"]]
[09:32:00.116]                             if (is.null(version)) 
[09:32:00.116]                               version <- utils::packageVersion("future")
[09:32:00.116]                           }
[09:32:00.116]                           else {
[09:32:00.116]                             version <- NULL
[09:32:00.116]                           }
[09:32:00.116]                           if (!has_future || version < "1.8.0") {
[09:32:00.116]                             info <- base::c(r_version = base::gsub("R version ", 
[09:32:00.116]                               "", base::R.version$version.string), 
[09:32:00.116]                               platform = base::sprintf("%s (%s-bit)", 
[09:32:00.116]                                 base::R.version$platform, 8 * 
[09:32:00.116]                                   base::.Machine$sizeof.pointer), 
[09:32:00.116]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:00.116]                                 "release", "version")], collapse = " "), 
[09:32:00.116]                               hostname = base::Sys.info()[["nodename"]])
[09:32:00.116]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:32:00.116]                               info)
[09:32:00.116]                             info <- base::paste(info, collapse = "; ")
[09:32:00.116]                             if (!has_future) {
[09:32:00.116]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:00.116]                                 info)
[09:32:00.116]                             }
[09:32:00.116]                             else {
[09:32:00.116]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:00.116]                                 info, version)
[09:32:00.116]                             }
[09:32:00.116]                             base::stop(msg)
[09:32:00.116]                           }
[09:32:00.116]                         })
[09:32:00.116]                       }
[09:32:00.116]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:00.116]                       base::options(mc.cores = 1L)
[09:32:00.116]                     }
[09:32:00.116]                     base::local({
[09:32:00.116]                       for (pkg in "future") {
[09:32:00.116]                         base::loadNamespace(pkg)
[09:32:00.116]                         base::library(pkg, character.only = TRUE)
[09:32:00.116]                       }
[09:32:00.116]                     })
[09:32:00.116]                   }
[09:32:00.116]                   ...future.strategy.old <- future::plan("list")
[09:32:00.116]                   options(future.plan = NULL)
[09:32:00.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:00.116]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:32:00.116]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:32:00.116]                     envir = parent.frame()) 
[09:32:00.116]                   {
[09:32:00.116]                     if (is.function(workers)) 
[09:32:00.116]                       workers <- workers()
[09:32:00.116]                     workers <- structure(as.integer(workers), 
[09:32:00.116]                       class = class(workers))
[09:32:00.116]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:32:00.116]                       workers >= 1)
[09:32:00.116]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:32:00.116]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:32:00.116]                     }
[09:32:00.116]                     future <- MultisessionFuture(..., workers = workers, 
[09:32:00.116]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:32:00.116]                       envir = envir)
[09:32:00.116]                     if (!future$lazy) 
[09:32:00.116]                       future <- run(future)
[09:32:00.116]                     invisible(future)
[09:32:00.116]                   }), .cleanup = FALSE, .init = FALSE)
[09:32:00.116]                 }
[09:32:00.116]                 ...future.workdir <- getwd()
[09:32:00.116]             }
[09:32:00.116]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:00.116]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:00.116]         }
[09:32:00.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:00.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:00.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:00.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:00.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:00.116]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:00.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:00.116]             base::names(...future.oldOptions))
[09:32:00.116]     }
[09:32:00.116]     if (FALSE) {
[09:32:00.116]     }
[09:32:00.116]     else {
[09:32:00.116]         if (TRUE) {
[09:32:00.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:00.116]                 open = "w")
[09:32:00.116]         }
[09:32:00.116]         else {
[09:32:00.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:00.116]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:00.116]         }
[09:32:00.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:00.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:00.116]             base::sink(type = "output", split = FALSE)
[09:32:00.116]             base::close(...future.stdout)
[09:32:00.116]         }, add = TRUE)
[09:32:00.116]     }
[09:32:00.116]     ...future.frame <- base::sys.nframe()
[09:32:00.116]     ...future.conditions <- base::list()
[09:32:00.116]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:00.116]     if (FALSE) {
[09:32:00.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:00.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:00.116]     }
[09:32:00.116]     ...future.result <- base::tryCatch({
[09:32:00.116]         base::withCallingHandlers({
[09:32:00.116]             ...future.value <- base::withVisible(base::local({
[09:32:00.116]                 ...future.makeSendCondition <- base::local({
[09:32:00.116]                   sendCondition <- NULL
[09:32:00.116]                   function(frame = 1L) {
[09:32:00.116]                     if (is.function(sendCondition)) 
[09:32:00.116]                       return(sendCondition)
[09:32:00.116]                     ns <- getNamespace("parallel")
[09:32:00.116]                     if (exists("sendData", mode = "function", 
[09:32:00.116]                       envir = ns)) {
[09:32:00.116]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:00.116]                         envir = ns)
[09:32:00.116]                       envir <- sys.frame(frame)
[09:32:00.116]                       master <- NULL
[09:32:00.116]                       while (!identical(envir, .GlobalEnv) && 
[09:32:00.116]                         !identical(envir, emptyenv())) {
[09:32:00.116]                         if (exists("master", mode = "list", envir = envir, 
[09:32:00.116]                           inherits = FALSE)) {
[09:32:00.116]                           master <- get("master", mode = "list", 
[09:32:00.116]                             envir = envir, inherits = FALSE)
[09:32:00.116]                           if (inherits(master, c("SOCKnode", 
[09:32:00.116]                             "SOCK0node"))) {
[09:32:00.116]                             sendCondition <<- function(cond) {
[09:32:00.116]                               data <- list(type = "VALUE", value = cond, 
[09:32:00.116]                                 success = TRUE)
[09:32:00.116]                               parallel_sendData(master, data)
[09:32:00.116]                             }
[09:32:00.116]                             return(sendCondition)
[09:32:00.116]                           }
[09:32:00.116]                         }
[09:32:00.116]                         frame <- frame + 1L
[09:32:00.116]                         envir <- sys.frame(frame)
[09:32:00.116]                       }
[09:32:00.116]                     }
[09:32:00.116]                     sendCondition <<- function(cond) NULL
[09:32:00.116]                   }
[09:32:00.116]                 })
[09:32:00.116]                 withCallingHandlers({
[09:32:00.116]                   {
[09:32:00.116]                     a <- 1L
[09:32:00.116]                     plan_a <- unclass(future::plan("list"))
[09:32:00.116]                     nested_a <- nested[-1]
[09:32:00.116]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[09:32:00.116]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[09:32:00.116]                       strategy2))
[09:32:00.116]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[09:32:00.116]                       "init") <- NULL
[09:32:00.116]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[09:32:00.116]                       "init") <- NULL
[09:32:00.116]                     stopifnot(all.equal(plan_a, nested_a))
[09:32:00.116]                     y %<-% {
[09:32:00.116]                       b <- 2L
[09:32:00.116]                       plan_b <- future::plan("list")
[09:32:00.116]                       nested_b <- nested_a[-1]
[09:32:00.116]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[09:32:00.116]                         1L, inherits(plan_b[[1]], "future"), 
[09:32:00.116]                         inherits(future::plan("next"), "sequential"))
[09:32:00.116]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[09:32:00.116]                         b = b, nested_b = nested_b, plan_b = plan_b)
[09:32:00.116]                     }
[09:32:00.116]                     y
[09:32:00.116]                   }
[09:32:00.116]                 }, immediateCondition = function(cond) {
[09:32:00.116]                   sendCondition <- ...future.makeSendCondition()
[09:32:00.116]                   sendCondition(cond)
[09:32:00.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:00.116]                   {
[09:32:00.116]                     inherits <- base::inherits
[09:32:00.116]                     invokeRestart <- base::invokeRestart
[09:32:00.116]                     is.null <- base::is.null
[09:32:00.116]                     muffled <- FALSE
[09:32:00.116]                     if (inherits(cond, "message")) {
[09:32:00.116]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:00.116]                       if (muffled) 
[09:32:00.116]                         invokeRestart("muffleMessage")
[09:32:00.116]                     }
[09:32:00.116]                     else if (inherits(cond, "warning")) {
[09:32:00.116]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:00.116]                       if (muffled) 
[09:32:00.116]                         invokeRestart("muffleWarning")
[09:32:00.116]                     }
[09:32:00.116]                     else if (inherits(cond, "condition")) {
[09:32:00.116]                       if (!is.null(pattern)) {
[09:32:00.116]                         computeRestarts <- base::computeRestarts
[09:32:00.116]                         grepl <- base::grepl
[09:32:00.116]                         restarts <- computeRestarts(cond)
[09:32:00.116]                         for (restart in restarts) {
[09:32:00.116]                           name <- restart$name
[09:32:00.116]                           if (is.null(name)) 
[09:32:00.116]                             next
[09:32:00.116]                           if (!grepl(pattern, name)) 
[09:32:00.116]                             next
[09:32:00.116]                           invokeRestart(restart)
[09:32:00.116]                           muffled <- TRUE
[09:32:00.116]                           break
[09:32:00.116]                         }
[09:32:00.116]                       }
[09:32:00.116]                     }
[09:32:00.116]                     invisible(muffled)
[09:32:00.116]                   }
[09:32:00.116]                   muffleCondition(cond)
[09:32:00.116]                 })
[09:32:00.116]             }))
[09:32:00.116]             future::FutureResult(value = ...future.value$value, 
[09:32:00.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:00.116]                   ...future.rng), globalenv = if (FALSE) 
[09:32:00.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:00.116]                     ...future.globalenv.names))
[09:32:00.116]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:00.116]         }, condition = base::local({
[09:32:00.116]             c <- base::c
[09:32:00.116]             inherits <- base::inherits
[09:32:00.116]             invokeRestart <- base::invokeRestart
[09:32:00.116]             length <- base::length
[09:32:00.116]             list <- base::list
[09:32:00.116]             seq.int <- base::seq.int
[09:32:00.116]             signalCondition <- base::signalCondition
[09:32:00.116]             sys.calls <- base::sys.calls
[09:32:00.116]             `[[` <- base::`[[`
[09:32:00.116]             `+` <- base::`+`
[09:32:00.116]             `<<-` <- base::`<<-`
[09:32:00.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:00.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:00.116]                   3L)]
[09:32:00.116]             }
[09:32:00.116]             function(cond) {
[09:32:00.116]                 is_error <- inherits(cond, "error")
[09:32:00.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:00.116]                   NULL)
[09:32:00.116]                 if (is_error) {
[09:32:00.116]                   sessionInformation <- function() {
[09:32:00.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:00.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:00.116]                       search = base::search(), system = base::Sys.info())
[09:32:00.116]                   }
[09:32:00.116]                   ...future.conditions[[length(...future.conditions) + 
[09:32:00.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:00.116]                     cond$call), session = sessionInformation(), 
[09:32:00.116]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:00.116]                   signalCondition(cond)
[09:32:00.116]                 }
[09:32:00.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:00.116]                 "immediateCondition"))) {
[09:32:00.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:00.116]                   ...future.conditions[[length(...future.conditions) + 
[09:32:00.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:00.116]                   if (TRUE && !signal) {
[09:32:00.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:00.116]                     {
[09:32:00.116]                       inherits <- base::inherits
[09:32:00.116]                       invokeRestart <- base::invokeRestart
[09:32:00.116]                       is.null <- base::is.null
[09:32:00.116]                       muffled <- FALSE
[09:32:00.116]                       if (inherits(cond, "message")) {
[09:32:00.116]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:00.116]                         if (muffled) 
[09:32:00.116]                           invokeRestart("muffleMessage")
[09:32:00.116]                       }
[09:32:00.116]                       else if (inherits(cond, "warning")) {
[09:32:00.116]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:00.116]                         if (muffled) 
[09:32:00.116]                           invokeRestart("muffleWarning")
[09:32:00.116]                       }
[09:32:00.116]                       else if (inherits(cond, "condition")) {
[09:32:00.116]                         if (!is.null(pattern)) {
[09:32:00.116]                           computeRestarts <- base::computeRestarts
[09:32:00.116]                           grepl <- base::grepl
[09:32:00.116]                           restarts <- computeRestarts(cond)
[09:32:00.116]                           for (restart in restarts) {
[09:32:00.116]                             name <- restart$name
[09:32:00.116]                             if (is.null(name)) 
[09:32:00.116]                               next
[09:32:00.116]                             if (!grepl(pattern, name)) 
[09:32:00.116]                               next
[09:32:00.116]                             invokeRestart(restart)
[09:32:00.116]                             muffled <- TRUE
[09:32:00.116]                             break
[09:32:00.116]                           }
[09:32:00.116]                         }
[09:32:00.116]                       }
[09:32:00.116]                       invisible(muffled)
[09:32:00.116]                     }
[09:32:00.116]                     muffleCondition(cond, pattern = "^muffle")
[09:32:00.116]                   }
[09:32:00.116]                 }
[09:32:00.116]                 else {
[09:32:00.116]                   if (TRUE) {
[09:32:00.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:00.116]                     {
[09:32:00.116]                       inherits <- base::inherits
[09:32:00.116]                       invokeRestart <- base::invokeRestart
[09:32:00.116]                       is.null <- base::is.null
[09:32:00.116]                       muffled <- FALSE
[09:32:00.116]                       if (inherits(cond, "message")) {
[09:32:00.116]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:00.116]                         if (muffled) 
[09:32:00.116]                           invokeRestart("muffleMessage")
[09:32:00.116]                       }
[09:32:00.116]                       else if (inherits(cond, "warning")) {
[09:32:00.116]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:00.116]                         if (muffled) 
[09:32:00.116]                           invokeRestart("muffleWarning")
[09:32:00.116]                       }
[09:32:00.116]                       else if (inherits(cond, "condition")) {
[09:32:00.116]                         if (!is.null(pattern)) {
[09:32:00.116]                           computeRestarts <- base::computeRestarts
[09:32:00.116]                           grepl <- base::grepl
[09:32:00.116]                           restarts <- computeRestarts(cond)
[09:32:00.116]                           for (restart in restarts) {
[09:32:00.116]                             name <- restart$name
[09:32:00.116]                             if (is.null(name)) 
[09:32:00.116]                               next
[09:32:00.116]                             if (!grepl(pattern, name)) 
[09:32:00.116]                               next
[09:32:00.116]                             invokeRestart(restart)
[09:32:00.116]                             muffled <- TRUE
[09:32:00.116]                             break
[09:32:00.116]                           }
[09:32:00.116]                         }
[09:32:00.116]                       }
[09:32:00.116]                       invisible(muffled)
[09:32:00.116]                     }
[09:32:00.116]                     muffleCondition(cond, pattern = "^muffle")
[09:32:00.116]                   }
[09:32:00.116]                 }
[09:32:00.116]             }
[09:32:00.116]         }))
[09:32:00.116]     }, error = function(ex) {
[09:32:00.116]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:00.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:00.116]                 ...future.rng), started = ...future.startTime, 
[09:32:00.116]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:00.116]             version = "1.8"), class = "FutureResult")
[09:32:00.116]     }, finally = {
[09:32:00.116]         if (!identical(...future.workdir, getwd())) 
[09:32:00.116]             setwd(...future.workdir)
[09:32:00.116]         {
[09:32:00.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:00.116]                 ...future.oldOptions$nwarnings <- NULL
[09:32:00.116]             }
[09:32:00.116]             base::options(...future.oldOptions)
[09:32:00.116]             if (.Platform$OS.type == "windows") {
[09:32:00.116]                 old_names <- names(...future.oldEnvVars)
[09:32:00.116]                 envs <- base::Sys.getenv()
[09:32:00.116]                 names <- names(envs)
[09:32:00.116]                 common <- intersect(names, old_names)
[09:32:00.116]                 added <- setdiff(names, old_names)
[09:32:00.116]                 removed <- setdiff(old_names, names)
[09:32:00.116]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:00.116]                   envs[common]]
[09:32:00.116]                 NAMES <- toupper(changed)
[09:32:00.116]                 args <- list()
[09:32:00.116]                 for (kk in seq_along(NAMES)) {
[09:32:00.116]                   name <- changed[[kk]]
[09:32:00.116]                   NAME <- NAMES[[kk]]
[09:32:00.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:00.116]                     next
[09:32:00.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:00.116]                 }
[09:32:00.116]                 NAMES <- toupper(added)
[09:32:00.116]                 for (kk in seq_along(NAMES)) {
[09:32:00.116]                   name <- added[[kk]]
[09:32:00.116]                   NAME <- NAMES[[kk]]
[09:32:00.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:00.116]                     next
[09:32:00.116]                   args[[name]] <- ""
[09:32:00.116]                 }
[09:32:00.116]                 NAMES <- toupper(removed)
[09:32:00.116]                 for (kk in seq_along(NAMES)) {
[09:32:00.116]                   name <- removed[[kk]]
[09:32:00.116]                   NAME <- NAMES[[kk]]
[09:32:00.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:00.116]                     next
[09:32:00.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:00.116]                 }
[09:32:00.116]                 if (length(args) > 0) 
[09:32:00.116]                   base::do.call(base::Sys.setenv, args = args)
[09:32:00.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:00.116]             }
[09:32:00.116]             else {
[09:32:00.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:00.116]             }
[09:32:00.116]             {
[09:32:00.116]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:00.116]                   0L) {
[09:32:00.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:00.116]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:00.116]                   base::options(opts)
[09:32:00.116]                 }
[09:32:00.116]                 {
[09:32:00.116]                   {
[09:32:00.116]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:00.116]                     NULL
[09:32:00.116]                   }
[09:32:00.116]                   options(future.plan = NULL)
[09:32:00.116]                   if (is.na(NA_character_)) 
[09:32:00.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:00.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:00.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:00.116]                     .init = FALSE)
[09:32:00.116]                 }
[09:32:00.116]             }
[09:32:00.116]         }
[09:32:00.116]     })
[09:32:00.116]     if (TRUE) {
[09:32:00.116]         base::sink(type = "output", split = FALSE)
[09:32:00.116]         if (TRUE) {
[09:32:00.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:00.116]         }
[09:32:00.116]         else {
[09:32:00.116]             ...future.result["stdout"] <- base::list(NULL)
[09:32:00.116]         }
[09:32:00.116]         base::close(...future.stdout)
[09:32:00.116]         ...future.stdout <- NULL
[09:32:00.116]     }
[09:32:00.116]     ...future.result$conditions <- ...future.conditions
[09:32:00.116]     ...future.result$finished <- base::Sys.time()
[09:32:00.116]     ...future.result
[09:32:00.116] }
[09:32:00.119] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[09:32:00.119] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[09:32:00.160] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[09:32:00.160] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[09:32:00.161] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[09:32:00.161] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[09:32:00.161] MultisessionFuture started
[09:32:00.161] - Launch lazy future ... done
[09:32:00.162] run() for ‘MultisessionFuture’ ... done
[09:32:00.162] result() for ClusterFuture ...
[09:32:00.162] receiveMessageFromWorker() for ClusterFuture ...
[09:32:00.162] - Validating connection of MultisessionFuture
[09:32:00.233] - received message: FutureResult
[09:32:00.233] - Received FutureResult
[09:32:00.233] - Erased future from FutureRegistry
[09:32:00.233] result() for ClusterFuture ...
[09:32:00.233] - result already collected: FutureResult
[09:32:00.234] result() for ClusterFuture ... done
[09:32:00.234] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:00.234] result() for ClusterFuture ... done
[09:32:00.234] result() for ClusterFuture ...
[09:32:00.234] - result already collected: FutureResult
[09:32:00.234] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[09:32:00.239] getGlobalsAndPackages() ...
[09:32:00.240] Searching for globals...
[09:32:00.241] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[09:32:00.241] Searching for globals ... DONE
[09:32:00.241] Resolving globals: FALSE
[09:32:00.242] The total size of the 1 globals is 128 bytes (128 bytes)
[09:32:00.242] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[09:32:00.242] - globals: [1] ‘data’
[09:32:00.242] - packages: [1] ‘future’
[09:32:00.242] getGlobalsAndPackages() ... DONE
[09:32:00.243] run() for ‘Future’ ...
[09:32:00.243] - state: ‘created’
[09:32:00.243] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:00.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:00.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:00.257]   - Field: ‘node’
[09:32:00.257]   - Field: ‘label’
[09:32:00.257]   - Field: ‘local’
[09:32:00.257]   - Field: ‘owner’
[09:32:00.257]   - Field: ‘envir’
[09:32:00.257]   - Field: ‘workers’
[09:32:00.257]   - Field: ‘packages’
[09:32:00.257]   - Field: ‘gc’
[09:32:00.257]   - Field: ‘conditions’
[09:32:00.258]   - Field: ‘persistent’
[09:32:00.258]   - Field: ‘expr’
[09:32:00.258]   - Field: ‘uuid’
[09:32:00.258]   - Field: ‘seed’
[09:32:00.258]   - Field: ‘version’
[09:32:00.258]   - Field: ‘result’
[09:32:00.258]   - Field: ‘asynchronous’
[09:32:00.258]   - Field: ‘calls’
[09:32:00.258]   - Field: ‘globals’
[09:32:00.258]   - Field: ‘stdout’
[09:32:00.258]   - Field: ‘earlySignal’
[09:32:00.258]   - Field: ‘lazy’
[09:32:00.259]   - Field: ‘state’
[09:32:00.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:00.259] - Launch lazy future ...
[09:32:00.259] Packages needed by the future expression (n = 1): ‘future’
[09:32:00.259] Packages needed by future strategies (n = 1): ‘future’
[09:32:00.260] {
[09:32:00.260]     {
[09:32:00.260]         {
[09:32:00.260]             ...future.startTime <- base::Sys.time()
[09:32:00.260]             {
[09:32:00.260]                 {
[09:32:00.260]                   {
[09:32:00.260]                     {
[09:32:00.260]                       {
[09:32:00.260]                         base::local({
[09:32:00.260]                           has_future <- base::requireNamespace("future", 
[09:32:00.260]                             quietly = TRUE)
[09:32:00.260]                           if (has_future) {
[09:32:00.260]                             ns <- base::getNamespace("future")
[09:32:00.260]                             version <- ns[[".package"]][["version"]]
[09:32:00.260]                             if (is.null(version)) 
[09:32:00.260]                               version <- utils::packageVersion("future")
[09:32:00.260]                           }
[09:32:00.260]                           else {
[09:32:00.260]                             version <- NULL
[09:32:00.260]                           }
[09:32:00.260]                           if (!has_future || version < "1.8.0") {
[09:32:00.260]                             info <- base::c(r_version = base::gsub("R version ", 
[09:32:00.260]                               "", base::R.version$version.string), 
[09:32:00.260]                               platform = base::sprintf("%s (%s-bit)", 
[09:32:00.260]                                 base::R.version$platform, 8 * 
[09:32:00.260]                                   base::.Machine$sizeof.pointer), 
[09:32:00.260]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:00.260]                                 "release", "version")], collapse = " "), 
[09:32:00.260]                               hostname = base::Sys.info()[["nodename"]])
[09:32:00.260]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:32:00.260]                               info)
[09:32:00.260]                             info <- base::paste(info, collapse = "; ")
[09:32:00.260]                             if (!has_future) {
[09:32:00.260]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:00.260]                                 info)
[09:32:00.260]                             }
[09:32:00.260]                             else {
[09:32:00.260]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:00.260]                                 info, version)
[09:32:00.260]                             }
[09:32:00.260]                             base::stop(msg)
[09:32:00.260]                           }
[09:32:00.260]                         })
[09:32:00.260]                       }
[09:32:00.260]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:00.260]                       base::options(mc.cores = 1L)
[09:32:00.260]                     }
[09:32:00.260]                     base::local({
[09:32:00.260]                       for (pkg in "future") {
[09:32:00.260]                         base::loadNamespace(pkg)
[09:32:00.260]                         base::library(pkg, character.only = TRUE)
[09:32:00.260]                       }
[09:32:00.260]                     })
[09:32:00.260]                   }
[09:32:00.260]                   ...future.strategy.old <- future::plan("list")
[09:32:00.260]                   options(future.plan = NULL)
[09:32:00.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:00.260]                   future::plan(list(b = function (..., workers = availableCores(), 
[09:32:00.260]                     lazy = FALSE, rscript_libs = .libPaths(), 
[09:32:00.260]                     envir = parent.frame()) 
[09:32:00.260]                   {
[09:32:00.260]                     if (is.function(workers)) 
[09:32:00.260]                       workers <- workers()
[09:32:00.260]                     workers <- structure(as.integer(workers), 
[09:32:00.260]                       class = class(workers))
[09:32:00.260]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[09:32:00.260]                       workers >= 1)
[09:32:00.260]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[09:32:00.260]                       return(sequential(..., lazy = TRUE, envir = envir))
[09:32:00.260]                     }
[09:32:00.260]                     future <- MultisessionFuture(..., workers = workers, 
[09:32:00.260]                       lazy = lazy, rscript_libs = rscript_libs, 
[09:32:00.260]                       envir = envir)
[09:32:00.260]                     if (!future$lazy) 
[09:32:00.260]                       future <- run(future)
[09:32:00.260]                     invisible(future)
[09:32:00.260]                   }), .cleanup = FALSE, .init = FALSE)
[09:32:00.260]                 }
[09:32:00.260]                 ...future.workdir <- getwd()
[09:32:00.260]             }
[09:32:00.260]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:00.260]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:00.260]         }
[09:32:00.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:00.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:00.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:00.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:00.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:00.260]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:00.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:00.260]             base::names(...future.oldOptions))
[09:32:00.260]     }
[09:32:00.260]     if (FALSE) {
[09:32:00.260]     }
[09:32:00.260]     else {
[09:32:00.260]         if (TRUE) {
[09:32:00.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:00.260]                 open = "w")
[09:32:00.260]         }
[09:32:00.260]         else {
[09:32:00.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:00.260]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:00.260]         }
[09:32:00.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:00.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:00.260]             base::sink(type = "output", split = FALSE)
[09:32:00.260]             base::close(...future.stdout)
[09:32:00.260]         }, add = TRUE)
[09:32:00.260]     }
[09:32:00.260]     ...future.frame <- base::sys.nframe()
[09:32:00.260]     ...future.conditions <- base::list()
[09:32:00.260]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:00.260]     if (FALSE) {
[09:32:00.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:00.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:00.260]     }
[09:32:00.260]     ...future.result <- base::tryCatch({
[09:32:00.260]         base::withCallingHandlers({
[09:32:00.260]             ...future.value <- base::withVisible(base::local({
[09:32:00.260]                 ...future.makeSendCondition <- base::local({
[09:32:00.260]                   sendCondition <- NULL
[09:32:00.260]                   function(frame = 1L) {
[09:32:00.260]                     if (is.function(sendCondition)) 
[09:32:00.260]                       return(sendCondition)
[09:32:00.260]                     ns <- getNamespace("parallel")
[09:32:00.260]                     if (exists("sendData", mode = "function", 
[09:32:00.260]                       envir = ns)) {
[09:32:00.260]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:00.260]                         envir = ns)
[09:32:00.260]                       envir <- sys.frame(frame)
[09:32:00.260]                       master <- NULL
[09:32:00.260]                       while (!identical(envir, .GlobalEnv) && 
[09:32:00.260]                         !identical(envir, emptyenv())) {
[09:32:00.260]                         if (exists("master", mode = "list", envir = envir, 
[09:32:00.260]                           inherits = FALSE)) {
[09:32:00.260]                           master <- get("master", mode = "list", 
[09:32:00.260]                             envir = envir, inherits = FALSE)
[09:32:00.260]                           if (inherits(master, c("SOCKnode", 
[09:32:00.260]                             "SOCK0node"))) {
[09:32:00.260]                             sendCondition <<- function(cond) {
[09:32:00.260]                               data <- list(type = "VALUE", value = cond, 
[09:32:00.260]                                 success = TRUE)
[09:32:00.260]                               parallel_sendData(master, data)
[09:32:00.260]                             }
[09:32:00.260]                             return(sendCondition)
[09:32:00.260]                           }
[09:32:00.260]                         }
[09:32:00.260]                         frame <- frame + 1L
[09:32:00.260]                         envir <- sys.frame(frame)
[09:32:00.260]                       }
[09:32:00.260]                     }
[09:32:00.260]                     sendCondition <<- function(cond) NULL
[09:32:00.260]                   }
[09:32:00.260]                 })
[09:32:00.260]                 withCallingHandlers({
[09:32:00.260]                   {
[09:32:00.260]                     value(future(subset(data, a == 2)))
[09:32:00.260]                   }
[09:32:00.260]                 }, immediateCondition = function(cond) {
[09:32:00.260]                   sendCondition <- ...future.makeSendCondition()
[09:32:00.260]                   sendCondition(cond)
[09:32:00.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:00.260]                   {
[09:32:00.260]                     inherits <- base::inherits
[09:32:00.260]                     invokeRestart <- base::invokeRestart
[09:32:00.260]                     is.null <- base::is.null
[09:32:00.260]                     muffled <- FALSE
[09:32:00.260]                     if (inherits(cond, "message")) {
[09:32:00.260]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:00.260]                       if (muffled) 
[09:32:00.260]                         invokeRestart("muffleMessage")
[09:32:00.260]                     }
[09:32:00.260]                     else if (inherits(cond, "warning")) {
[09:32:00.260]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:00.260]                       if (muffled) 
[09:32:00.260]                         invokeRestart("muffleWarning")
[09:32:00.260]                     }
[09:32:00.260]                     else if (inherits(cond, "condition")) {
[09:32:00.260]                       if (!is.null(pattern)) {
[09:32:00.260]                         computeRestarts <- base::computeRestarts
[09:32:00.260]                         grepl <- base::grepl
[09:32:00.260]                         restarts <- computeRestarts(cond)
[09:32:00.260]                         for (restart in restarts) {
[09:32:00.260]                           name <- restart$name
[09:32:00.260]                           if (is.null(name)) 
[09:32:00.260]                             next
[09:32:00.260]                           if (!grepl(pattern, name)) 
[09:32:00.260]                             next
[09:32:00.260]                           invokeRestart(restart)
[09:32:00.260]                           muffled <- TRUE
[09:32:00.260]                           break
[09:32:00.260]                         }
[09:32:00.260]                       }
[09:32:00.260]                     }
[09:32:00.260]                     invisible(muffled)
[09:32:00.260]                   }
[09:32:00.260]                   muffleCondition(cond)
[09:32:00.260]                 })
[09:32:00.260]             }))
[09:32:00.260]             future::FutureResult(value = ...future.value$value, 
[09:32:00.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:00.260]                   ...future.rng), globalenv = if (FALSE) 
[09:32:00.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:00.260]                     ...future.globalenv.names))
[09:32:00.260]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:00.260]         }, condition = base::local({
[09:32:00.260]             c <- base::c
[09:32:00.260]             inherits <- base::inherits
[09:32:00.260]             invokeRestart <- base::invokeRestart
[09:32:00.260]             length <- base::length
[09:32:00.260]             list <- base::list
[09:32:00.260]             seq.int <- base::seq.int
[09:32:00.260]             signalCondition <- base::signalCondition
[09:32:00.260]             sys.calls <- base::sys.calls
[09:32:00.260]             `[[` <- base::`[[`
[09:32:00.260]             `+` <- base::`+`
[09:32:00.260]             `<<-` <- base::`<<-`
[09:32:00.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:00.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:00.260]                   3L)]
[09:32:00.260]             }
[09:32:00.260]             function(cond) {
[09:32:00.260]                 is_error <- inherits(cond, "error")
[09:32:00.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:00.260]                   NULL)
[09:32:00.260]                 if (is_error) {
[09:32:00.260]                   sessionInformation <- function() {
[09:32:00.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:00.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:00.260]                       search = base::search(), system = base::Sys.info())
[09:32:00.260]                   }
[09:32:00.260]                   ...future.conditions[[length(...future.conditions) + 
[09:32:00.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:00.260]                     cond$call), session = sessionInformation(), 
[09:32:00.260]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:00.260]                   signalCondition(cond)
[09:32:00.260]                 }
[09:32:00.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:00.260]                 "immediateCondition"))) {
[09:32:00.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:00.260]                   ...future.conditions[[length(...future.conditions) + 
[09:32:00.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:00.260]                   if (TRUE && !signal) {
[09:32:00.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:00.260]                     {
[09:32:00.260]                       inherits <- base::inherits
[09:32:00.260]                       invokeRestart <- base::invokeRestart
[09:32:00.260]                       is.null <- base::is.null
[09:32:00.260]                       muffled <- FALSE
[09:32:00.260]                       if (inherits(cond, "message")) {
[09:32:00.260]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:00.260]                         if (muffled) 
[09:32:00.260]                           invokeRestart("muffleMessage")
[09:32:00.260]                       }
[09:32:00.260]                       else if (inherits(cond, "warning")) {
[09:32:00.260]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:00.260]                         if (muffled) 
[09:32:00.260]                           invokeRestart("muffleWarning")
[09:32:00.260]                       }
[09:32:00.260]                       else if (inherits(cond, "condition")) {
[09:32:00.260]                         if (!is.null(pattern)) {
[09:32:00.260]                           computeRestarts <- base::computeRestarts
[09:32:00.260]                           grepl <- base::grepl
[09:32:00.260]                           restarts <- computeRestarts(cond)
[09:32:00.260]                           for (restart in restarts) {
[09:32:00.260]                             name <- restart$name
[09:32:00.260]                             if (is.null(name)) 
[09:32:00.260]                               next
[09:32:00.260]                             if (!grepl(pattern, name)) 
[09:32:00.260]                               next
[09:32:00.260]                             invokeRestart(restart)
[09:32:00.260]                             muffled <- TRUE
[09:32:00.260]                             break
[09:32:00.260]                           }
[09:32:00.260]                         }
[09:32:00.260]                       }
[09:32:00.260]                       invisible(muffled)
[09:32:00.260]                     }
[09:32:00.260]                     muffleCondition(cond, pattern = "^muffle")
[09:32:00.260]                   }
[09:32:00.260]                 }
[09:32:00.260]                 else {
[09:32:00.260]                   if (TRUE) {
[09:32:00.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:00.260]                     {
[09:32:00.260]                       inherits <- base::inherits
[09:32:00.260]                       invokeRestart <- base::invokeRestart
[09:32:00.260]                       is.null <- base::is.null
[09:32:00.260]                       muffled <- FALSE
[09:32:00.260]                       if (inherits(cond, "message")) {
[09:32:00.260]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:00.260]                         if (muffled) 
[09:32:00.260]                           invokeRestart("muffleMessage")
[09:32:00.260]                       }
[09:32:00.260]                       else if (inherits(cond, "warning")) {
[09:32:00.260]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:00.260]                         if (muffled) 
[09:32:00.260]                           invokeRestart("muffleWarning")
[09:32:00.260]                       }
[09:32:00.260]                       else if (inherits(cond, "condition")) {
[09:32:00.260]                         if (!is.null(pattern)) {
[09:32:00.260]                           computeRestarts <- base::computeRestarts
[09:32:00.260]                           grepl <- base::grepl
[09:32:00.260]                           restarts <- computeRestarts(cond)
[09:32:00.260]                           for (restart in restarts) {
[09:32:00.260]                             name <- restart$name
[09:32:00.260]                             if (is.null(name)) 
[09:32:00.260]                               next
[09:32:00.260]                             if (!grepl(pattern, name)) 
[09:32:00.260]                               next
[09:32:00.260]                             invokeRestart(restart)
[09:32:00.260]                             muffled <- TRUE
[09:32:00.260]                             break
[09:32:00.260]                           }
[09:32:00.260]                         }
[09:32:00.260]                       }
[09:32:00.260]                       invisible(muffled)
[09:32:00.260]                     }
[09:32:00.260]                     muffleCondition(cond, pattern = "^muffle")
[09:32:00.260]                   }
[09:32:00.260]                 }
[09:32:00.260]             }
[09:32:00.260]         }))
[09:32:00.260]     }, error = function(ex) {
[09:32:00.260]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:00.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:00.260]                 ...future.rng), started = ...future.startTime, 
[09:32:00.260]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:00.260]             version = "1.8"), class = "FutureResult")
[09:32:00.260]     }, finally = {
[09:32:00.260]         if (!identical(...future.workdir, getwd())) 
[09:32:00.260]             setwd(...future.workdir)
[09:32:00.260]         {
[09:32:00.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:00.260]                 ...future.oldOptions$nwarnings <- NULL
[09:32:00.260]             }
[09:32:00.260]             base::options(...future.oldOptions)
[09:32:00.260]             if (.Platform$OS.type == "windows") {
[09:32:00.260]                 old_names <- names(...future.oldEnvVars)
[09:32:00.260]                 envs <- base::Sys.getenv()
[09:32:00.260]                 names <- names(envs)
[09:32:00.260]                 common <- intersect(names, old_names)
[09:32:00.260]                 added <- setdiff(names, old_names)
[09:32:00.260]                 removed <- setdiff(old_names, names)
[09:32:00.260]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:00.260]                   envs[common]]
[09:32:00.260]                 NAMES <- toupper(changed)
[09:32:00.260]                 args <- list()
[09:32:00.260]                 for (kk in seq_along(NAMES)) {
[09:32:00.260]                   name <- changed[[kk]]
[09:32:00.260]                   NAME <- NAMES[[kk]]
[09:32:00.260]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:00.260]                     next
[09:32:00.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:00.260]                 }
[09:32:00.260]                 NAMES <- toupper(added)
[09:32:00.260]                 for (kk in seq_along(NAMES)) {
[09:32:00.260]                   name <- added[[kk]]
[09:32:00.260]                   NAME <- NAMES[[kk]]
[09:32:00.260]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:00.260]                     next
[09:32:00.260]                   args[[name]] <- ""
[09:32:00.260]                 }
[09:32:00.260]                 NAMES <- toupper(removed)
[09:32:00.260]                 for (kk in seq_along(NAMES)) {
[09:32:00.260]                   name <- removed[[kk]]
[09:32:00.260]                   NAME <- NAMES[[kk]]
[09:32:00.260]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:00.260]                     next
[09:32:00.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:00.260]                 }
[09:32:00.260]                 if (length(args) > 0) 
[09:32:00.260]                   base::do.call(base::Sys.setenv, args = args)
[09:32:00.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:00.260]             }
[09:32:00.260]             else {
[09:32:00.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:00.260]             }
[09:32:00.260]             {
[09:32:00.260]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:00.260]                   0L) {
[09:32:00.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:00.260]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:00.260]                   base::options(opts)
[09:32:00.260]                 }
[09:32:00.260]                 {
[09:32:00.260]                   {
[09:32:00.260]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:00.260]                     NULL
[09:32:00.260]                   }
[09:32:00.260]                   options(future.plan = NULL)
[09:32:00.260]                   if (is.na(NA_character_)) 
[09:32:00.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:00.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:00.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:00.260]                     .init = FALSE)
[09:32:00.260]                 }
[09:32:00.260]             }
[09:32:00.260]         }
[09:32:00.260]     })
[09:32:00.260]     if (TRUE) {
[09:32:00.260]         base::sink(type = "output", split = FALSE)
[09:32:00.260]         if (TRUE) {
[09:32:00.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:00.260]         }
[09:32:00.260]         else {
[09:32:00.260]             ...future.result["stdout"] <- base::list(NULL)
[09:32:00.260]         }
[09:32:00.260]         base::close(...future.stdout)
[09:32:00.260]         ...future.stdout <- NULL
[09:32:00.260]     }
[09:32:00.260]     ...future.result$conditions <- ...future.conditions
[09:32:00.260]     ...future.result$finished <- base::Sys.time()
[09:32:00.260]     ...future.result
[09:32:00.260] }
[09:32:00.262] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[09:32:00.263] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[09:32:00.263] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[09:32:00.263] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[09:32:00.264] MultisessionFuture started
[09:32:00.264] - Launch lazy future ... done
[09:32:00.264] run() for ‘MultisessionFuture’ ... done
[09:32:00.264] result() for ClusterFuture ...
[09:32:00.264] receiveMessageFromWorker() for ClusterFuture ...
[09:32:00.264] - Validating connection of MultisessionFuture
[09:32:00.318] - received message: FutureResult
[09:32:00.318] - Received FutureResult
[09:32:00.318] - Erased future from FutureRegistry
[09:32:00.318] result() for ClusterFuture ...
[09:32:00.319] - result already collected: FutureResult
[09:32:00.319] result() for ClusterFuture ... done
[09:32:00.319] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:00.319] result() for ClusterFuture ... done
[09:32:00.319] result() for ClusterFuture ...
[09:32:00.319] - result already collected: FutureResult
[09:32:00.319] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[09:32:00.320] plan(): Setting new future strategy stack:
[09:32:00.320] List of future strategies:
[09:32:00.320] 1. FutureStrategy:
[09:32:00.320]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:00.320]    - tweaked: FALSE
[09:32:00.320]    - call: future::plan(oplan)
[09:32:00.321] plan(): nbrOfWorkers() = 1
> 
