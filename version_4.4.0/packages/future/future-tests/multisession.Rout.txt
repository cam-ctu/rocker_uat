
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:40:08.716] plan(): Setting new future strategy stack:
[17:40:08.716] List of future strategies:
[17:40:08.716] 1. sequential:
[17:40:08.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.716]    - tweaked: FALSE
[17:40:08.716]    - call: future::plan("sequential")
[17:40:08.727] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[17:40:08.780] getGlobalsAndPackages() ...
[17:40:08.780] Searching for globals...
[17:40:08.783] - globals found: [1] ‘{’
[17:40:08.783] Searching for globals ... DONE
[17:40:08.784] Resolving globals: FALSE
[17:40:08.784] 
[17:40:08.784] 
[17:40:08.784] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:08.786] Packages needed by the future expression (n = 0): <none>
[17:40:08.786] Packages needed by future strategies (n = 0): <none>
[17:40:08.787] {
[17:40:08.787]     {
[17:40:08.787]         {
[17:40:08.787]             ...future.startTime <- base::Sys.time()
[17:40:08.787]             {
[17:40:08.787]                 {
[17:40:08.787]                   {
[17:40:08.787]                     base::local({
[17:40:08.787]                       has_future <- base::requireNamespace("future", 
[17:40:08.787]                         quietly = TRUE)
[17:40:08.787]                       if (has_future) {
[17:40:08.787]                         ns <- base::getNamespace("future")
[17:40:08.787]                         version <- ns[[".package"]][["version"]]
[17:40:08.787]                         if (is.null(version)) 
[17:40:08.787]                           version <- utils::packageVersion("future")
[17:40:08.787]                       }
[17:40:08.787]                       else {
[17:40:08.787]                         version <- NULL
[17:40:08.787]                       }
[17:40:08.787]                       if (!has_future || version < "1.8.0") {
[17:40:08.787]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.787]                           "", base::R.version$version.string), 
[17:40:08.787]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.787]                             "release", "version")], collapse = " "), 
[17:40:08.787]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.787]                           info)
[17:40:08.787]                         info <- base::paste(info, collapse = "; ")
[17:40:08.787]                         if (!has_future) {
[17:40:08.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.787]                             info)
[17:40:08.787]                         }
[17:40:08.787]                         else {
[17:40:08.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.787]                             info, version)
[17:40:08.787]                         }
[17:40:08.787]                         base::stop(msg)
[17:40:08.787]                       }
[17:40:08.787]                     })
[17:40:08.787]                   }
[17:40:08.787]                   ...future.strategy.old <- future::plan("list")
[17:40:08.787]                   options(future.plan = NULL)
[17:40:08.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.787]                 }
[17:40:08.787]                 ...future.workdir <- getwd()
[17:40:08.787]             }
[17:40:08.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.787]         }
[17:40:08.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.787]             base::names(...future.oldOptions))
[17:40:08.787]     }
[17:40:08.787]     if (FALSE) {
[17:40:08.787]     }
[17:40:08.787]     else {
[17:40:08.787]         if (TRUE) {
[17:40:08.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.787]                 open = "w")
[17:40:08.787]         }
[17:40:08.787]         else {
[17:40:08.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.787]         }
[17:40:08.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.787]             base::sink(type = "output", split = FALSE)
[17:40:08.787]             base::close(...future.stdout)
[17:40:08.787]         }, add = TRUE)
[17:40:08.787]     }
[17:40:08.787]     ...future.frame <- base::sys.nframe()
[17:40:08.787]     ...future.conditions <- base::list()
[17:40:08.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.787]     if (FALSE) {
[17:40:08.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.787]     }
[17:40:08.787]     ...future.result <- base::tryCatch({
[17:40:08.787]         base::withCallingHandlers({
[17:40:08.787]             ...future.value <- base::withVisible(base::local({
[17:40:08.787]                 42L
[17:40:08.787]             }))
[17:40:08.787]             future::FutureResult(value = ...future.value$value, 
[17:40:08.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.787]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.787]                     ...future.globalenv.names))
[17:40:08.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.787]         }, condition = base::local({
[17:40:08.787]             c <- base::c
[17:40:08.787]             inherits <- base::inherits
[17:40:08.787]             invokeRestart <- base::invokeRestart
[17:40:08.787]             length <- base::length
[17:40:08.787]             list <- base::list
[17:40:08.787]             seq.int <- base::seq.int
[17:40:08.787]             signalCondition <- base::signalCondition
[17:40:08.787]             sys.calls <- base::sys.calls
[17:40:08.787]             `[[` <- base::`[[`
[17:40:08.787]             `+` <- base::`+`
[17:40:08.787]             `<<-` <- base::`<<-`
[17:40:08.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.787]                   3L)]
[17:40:08.787]             }
[17:40:08.787]             function(cond) {
[17:40:08.787]                 is_error <- inherits(cond, "error")
[17:40:08.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.787]                   NULL)
[17:40:08.787]                 if (is_error) {
[17:40:08.787]                   sessionInformation <- function() {
[17:40:08.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.787]                       search = base::search(), system = base::Sys.info())
[17:40:08.787]                   }
[17:40:08.787]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.787]                     cond$call), session = sessionInformation(), 
[17:40:08.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.787]                   signalCondition(cond)
[17:40:08.787]                 }
[17:40:08.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.787]                 "immediateCondition"))) {
[17:40:08.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.787]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.787]                   if (TRUE && !signal) {
[17:40:08.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.787]                     {
[17:40:08.787]                       inherits <- base::inherits
[17:40:08.787]                       invokeRestart <- base::invokeRestart
[17:40:08.787]                       is.null <- base::is.null
[17:40:08.787]                       muffled <- FALSE
[17:40:08.787]                       if (inherits(cond, "message")) {
[17:40:08.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.787]                         if (muffled) 
[17:40:08.787]                           invokeRestart("muffleMessage")
[17:40:08.787]                       }
[17:40:08.787]                       else if (inherits(cond, "warning")) {
[17:40:08.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.787]                         if (muffled) 
[17:40:08.787]                           invokeRestart("muffleWarning")
[17:40:08.787]                       }
[17:40:08.787]                       else if (inherits(cond, "condition")) {
[17:40:08.787]                         if (!is.null(pattern)) {
[17:40:08.787]                           computeRestarts <- base::computeRestarts
[17:40:08.787]                           grepl <- base::grepl
[17:40:08.787]                           restarts <- computeRestarts(cond)
[17:40:08.787]                           for (restart in restarts) {
[17:40:08.787]                             name <- restart$name
[17:40:08.787]                             if (is.null(name)) 
[17:40:08.787]                               next
[17:40:08.787]                             if (!grepl(pattern, name)) 
[17:40:08.787]                               next
[17:40:08.787]                             invokeRestart(restart)
[17:40:08.787]                             muffled <- TRUE
[17:40:08.787]                             break
[17:40:08.787]                           }
[17:40:08.787]                         }
[17:40:08.787]                       }
[17:40:08.787]                       invisible(muffled)
[17:40:08.787]                     }
[17:40:08.787]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.787]                   }
[17:40:08.787]                 }
[17:40:08.787]                 else {
[17:40:08.787]                   if (TRUE) {
[17:40:08.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.787]                     {
[17:40:08.787]                       inherits <- base::inherits
[17:40:08.787]                       invokeRestart <- base::invokeRestart
[17:40:08.787]                       is.null <- base::is.null
[17:40:08.787]                       muffled <- FALSE
[17:40:08.787]                       if (inherits(cond, "message")) {
[17:40:08.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.787]                         if (muffled) 
[17:40:08.787]                           invokeRestart("muffleMessage")
[17:40:08.787]                       }
[17:40:08.787]                       else if (inherits(cond, "warning")) {
[17:40:08.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.787]                         if (muffled) 
[17:40:08.787]                           invokeRestart("muffleWarning")
[17:40:08.787]                       }
[17:40:08.787]                       else if (inherits(cond, "condition")) {
[17:40:08.787]                         if (!is.null(pattern)) {
[17:40:08.787]                           computeRestarts <- base::computeRestarts
[17:40:08.787]                           grepl <- base::grepl
[17:40:08.787]                           restarts <- computeRestarts(cond)
[17:40:08.787]                           for (restart in restarts) {
[17:40:08.787]                             name <- restart$name
[17:40:08.787]                             if (is.null(name)) 
[17:40:08.787]                               next
[17:40:08.787]                             if (!grepl(pattern, name)) 
[17:40:08.787]                               next
[17:40:08.787]                             invokeRestart(restart)
[17:40:08.787]                             muffled <- TRUE
[17:40:08.787]                             break
[17:40:08.787]                           }
[17:40:08.787]                         }
[17:40:08.787]                       }
[17:40:08.787]                       invisible(muffled)
[17:40:08.787]                     }
[17:40:08.787]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.787]                   }
[17:40:08.787]                 }
[17:40:08.787]             }
[17:40:08.787]         }))
[17:40:08.787]     }, error = function(ex) {
[17:40:08.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.787]                 ...future.rng), started = ...future.startTime, 
[17:40:08.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.787]             version = "1.8"), class = "FutureResult")
[17:40:08.787]     }, finally = {
[17:40:08.787]         if (!identical(...future.workdir, getwd())) 
[17:40:08.787]             setwd(...future.workdir)
[17:40:08.787]         {
[17:40:08.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.787]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.787]             }
[17:40:08.787]             base::options(...future.oldOptions)
[17:40:08.787]             if (.Platform$OS.type == "windows") {
[17:40:08.787]                 old_names <- names(...future.oldEnvVars)
[17:40:08.787]                 envs <- base::Sys.getenv()
[17:40:08.787]                 names <- names(envs)
[17:40:08.787]                 common <- intersect(names, old_names)
[17:40:08.787]                 added <- setdiff(names, old_names)
[17:40:08.787]                 removed <- setdiff(old_names, names)
[17:40:08.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.787]                   envs[common]]
[17:40:08.787]                 NAMES <- toupper(changed)
[17:40:08.787]                 args <- list()
[17:40:08.787]                 for (kk in seq_along(NAMES)) {
[17:40:08.787]                   name <- changed[[kk]]
[17:40:08.787]                   NAME <- NAMES[[kk]]
[17:40:08.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.787]                     next
[17:40:08.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.787]                 }
[17:40:08.787]                 NAMES <- toupper(added)
[17:40:08.787]                 for (kk in seq_along(NAMES)) {
[17:40:08.787]                   name <- added[[kk]]
[17:40:08.787]                   NAME <- NAMES[[kk]]
[17:40:08.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.787]                     next
[17:40:08.787]                   args[[name]] <- ""
[17:40:08.787]                 }
[17:40:08.787]                 NAMES <- toupper(removed)
[17:40:08.787]                 for (kk in seq_along(NAMES)) {
[17:40:08.787]                   name <- removed[[kk]]
[17:40:08.787]                   NAME <- NAMES[[kk]]
[17:40:08.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.787]                     next
[17:40:08.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.787]                 }
[17:40:08.787]                 if (length(args) > 0) 
[17:40:08.787]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.787]             }
[17:40:08.787]             else {
[17:40:08.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.787]             }
[17:40:08.787]             {
[17:40:08.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.787]                   0L) {
[17:40:08.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.787]                   base::options(opts)
[17:40:08.787]                 }
[17:40:08.787]                 {
[17:40:08.787]                   {
[17:40:08.787]                     NULL
[17:40:08.787]                     RNGkind("Mersenne-Twister")
[17:40:08.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.787]                       inherits = FALSE)
[17:40:08.787]                   }
[17:40:08.787]                   options(future.plan = NULL)
[17:40:08.787]                   if (is.na(NA_character_)) 
[17:40:08.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.787]                     .init = FALSE)
[17:40:08.787]                 }
[17:40:08.787]             }
[17:40:08.787]         }
[17:40:08.787]     })
[17:40:08.787]     if (TRUE) {
[17:40:08.787]         base::sink(type = "output", split = FALSE)
[17:40:08.787]         if (TRUE) {
[17:40:08.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.787]         }
[17:40:08.787]         else {
[17:40:08.787]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.787]         }
[17:40:08.787]         base::close(...future.stdout)
[17:40:08.787]         ...future.stdout <- NULL
[17:40:08.787]     }
[17:40:08.787]     ...future.result$conditions <- ...future.conditions
[17:40:08.787]     ...future.result$finished <- base::Sys.time()
[17:40:08.787]     ...future.result
[17:40:08.787] }
[17:40:08.789] plan(): Setting new future strategy stack:
[17:40:08.789] List of future strategies:
[17:40:08.789] 1. sequential:
[17:40:08.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.789]    - tweaked: FALSE
[17:40:08.789]    - call: NULL
[17:40:08.789] plan(): nbrOfWorkers() = 1
[17:40:08.790] plan(): Setting new future strategy stack:
[17:40:08.790] List of future strategies:
[17:40:08.790] 1. sequential:
[17:40:08.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.790]    - tweaked: FALSE
[17:40:08.790]    - call: future::plan("sequential")
[17:40:08.791] plan(): nbrOfWorkers() = 1
[17:40:08.791] SequentialFuture started (and completed)
[17:40:08.791] resolved() for ‘SequentialFuture’ ...
[17:40:08.792] - state: ‘finished’
[17:40:08.792] - run: TRUE
[17:40:08.792] - result: ‘FutureResult’
[17:40:08.792] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[17:40:08.795] getGlobalsAndPackages() ...
[17:40:08.795] Searching for globals...
[17:40:08.800] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[17:40:08.800] Searching for globals ... DONE
[17:40:08.800] Resolving globals: FALSE
[17:40:08.801] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:08.801] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:40:08.801] - globals: [1] ‘a’
[17:40:08.801] 
[17:40:08.802] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:08.802] Packages needed by the future expression (n = 0): <none>
[17:40:08.803] Packages needed by future strategies (n = 0): <none>
[17:40:08.803] {
[17:40:08.803]     {
[17:40:08.803]         {
[17:40:08.803]             ...future.startTime <- base::Sys.time()
[17:40:08.803]             {
[17:40:08.803]                 {
[17:40:08.803]                   {
[17:40:08.803]                     base::local({
[17:40:08.803]                       has_future <- base::requireNamespace("future", 
[17:40:08.803]                         quietly = TRUE)
[17:40:08.803]                       if (has_future) {
[17:40:08.803]                         ns <- base::getNamespace("future")
[17:40:08.803]                         version <- ns[[".package"]][["version"]]
[17:40:08.803]                         if (is.null(version)) 
[17:40:08.803]                           version <- utils::packageVersion("future")
[17:40:08.803]                       }
[17:40:08.803]                       else {
[17:40:08.803]                         version <- NULL
[17:40:08.803]                       }
[17:40:08.803]                       if (!has_future || version < "1.8.0") {
[17:40:08.803]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.803]                           "", base::R.version$version.string), 
[17:40:08.803]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.803]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.803]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.803]                             "release", "version")], collapse = " "), 
[17:40:08.803]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.803]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.803]                           info)
[17:40:08.803]                         info <- base::paste(info, collapse = "; ")
[17:40:08.803]                         if (!has_future) {
[17:40:08.803]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.803]                             info)
[17:40:08.803]                         }
[17:40:08.803]                         else {
[17:40:08.803]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.803]                             info, version)
[17:40:08.803]                         }
[17:40:08.803]                         base::stop(msg)
[17:40:08.803]                       }
[17:40:08.803]                     })
[17:40:08.803]                   }
[17:40:08.803]                   ...future.strategy.old <- future::plan("list")
[17:40:08.803]                   options(future.plan = NULL)
[17:40:08.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.803]                 }
[17:40:08.803]                 ...future.workdir <- getwd()
[17:40:08.803]             }
[17:40:08.803]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.803]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.803]         }
[17:40:08.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.803]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.803]             base::names(...future.oldOptions))
[17:40:08.803]     }
[17:40:08.803]     if (FALSE) {
[17:40:08.803]     }
[17:40:08.803]     else {
[17:40:08.803]         if (TRUE) {
[17:40:08.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.803]                 open = "w")
[17:40:08.803]         }
[17:40:08.803]         else {
[17:40:08.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.803]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.803]         }
[17:40:08.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.803]             base::sink(type = "output", split = FALSE)
[17:40:08.803]             base::close(...future.stdout)
[17:40:08.803]         }, add = TRUE)
[17:40:08.803]     }
[17:40:08.803]     ...future.frame <- base::sys.nframe()
[17:40:08.803]     ...future.conditions <- base::list()
[17:40:08.803]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.803]     if (FALSE) {
[17:40:08.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.803]     }
[17:40:08.803]     ...future.result <- base::tryCatch({
[17:40:08.803]         base::withCallingHandlers({
[17:40:08.803]             ...future.value <- base::withVisible(base::local({
[17:40:08.803]                 b <- 3
[17:40:08.803]                 c <- 2
[17:40:08.803]                 a * b * c
[17:40:08.803]             }))
[17:40:08.803]             future::FutureResult(value = ...future.value$value, 
[17:40:08.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.803]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.803]                     ...future.globalenv.names))
[17:40:08.803]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.803]         }, condition = base::local({
[17:40:08.803]             c <- base::c
[17:40:08.803]             inherits <- base::inherits
[17:40:08.803]             invokeRestart <- base::invokeRestart
[17:40:08.803]             length <- base::length
[17:40:08.803]             list <- base::list
[17:40:08.803]             seq.int <- base::seq.int
[17:40:08.803]             signalCondition <- base::signalCondition
[17:40:08.803]             sys.calls <- base::sys.calls
[17:40:08.803]             `[[` <- base::`[[`
[17:40:08.803]             `+` <- base::`+`
[17:40:08.803]             `<<-` <- base::`<<-`
[17:40:08.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.803]                   3L)]
[17:40:08.803]             }
[17:40:08.803]             function(cond) {
[17:40:08.803]                 is_error <- inherits(cond, "error")
[17:40:08.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.803]                   NULL)
[17:40:08.803]                 if (is_error) {
[17:40:08.803]                   sessionInformation <- function() {
[17:40:08.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.803]                       search = base::search(), system = base::Sys.info())
[17:40:08.803]                   }
[17:40:08.803]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.803]                     cond$call), session = sessionInformation(), 
[17:40:08.803]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.803]                   signalCondition(cond)
[17:40:08.803]                 }
[17:40:08.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.803]                 "immediateCondition"))) {
[17:40:08.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.803]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.803]                   if (TRUE && !signal) {
[17:40:08.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.803]                     {
[17:40:08.803]                       inherits <- base::inherits
[17:40:08.803]                       invokeRestart <- base::invokeRestart
[17:40:08.803]                       is.null <- base::is.null
[17:40:08.803]                       muffled <- FALSE
[17:40:08.803]                       if (inherits(cond, "message")) {
[17:40:08.803]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.803]                         if (muffled) 
[17:40:08.803]                           invokeRestart("muffleMessage")
[17:40:08.803]                       }
[17:40:08.803]                       else if (inherits(cond, "warning")) {
[17:40:08.803]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.803]                         if (muffled) 
[17:40:08.803]                           invokeRestart("muffleWarning")
[17:40:08.803]                       }
[17:40:08.803]                       else if (inherits(cond, "condition")) {
[17:40:08.803]                         if (!is.null(pattern)) {
[17:40:08.803]                           computeRestarts <- base::computeRestarts
[17:40:08.803]                           grepl <- base::grepl
[17:40:08.803]                           restarts <- computeRestarts(cond)
[17:40:08.803]                           for (restart in restarts) {
[17:40:08.803]                             name <- restart$name
[17:40:08.803]                             if (is.null(name)) 
[17:40:08.803]                               next
[17:40:08.803]                             if (!grepl(pattern, name)) 
[17:40:08.803]                               next
[17:40:08.803]                             invokeRestart(restart)
[17:40:08.803]                             muffled <- TRUE
[17:40:08.803]                             break
[17:40:08.803]                           }
[17:40:08.803]                         }
[17:40:08.803]                       }
[17:40:08.803]                       invisible(muffled)
[17:40:08.803]                     }
[17:40:08.803]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.803]                   }
[17:40:08.803]                 }
[17:40:08.803]                 else {
[17:40:08.803]                   if (TRUE) {
[17:40:08.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.803]                     {
[17:40:08.803]                       inherits <- base::inherits
[17:40:08.803]                       invokeRestart <- base::invokeRestart
[17:40:08.803]                       is.null <- base::is.null
[17:40:08.803]                       muffled <- FALSE
[17:40:08.803]                       if (inherits(cond, "message")) {
[17:40:08.803]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.803]                         if (muffled) 
[17:40:08.803]                           invokeRestart("muffleMessage")
[17:40:08.803]                       }
[17:40:08.803]                       else if (inherits(cond, "warning")) {
[17:40:08.803]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.803]                         if (muffled) 
[17:40:08.803]                           invokeRestart("muffleWarning")
[17:40:08.803]                       }
[17:40:08.803]                       else if (inherits(cond, "condition")) {
[17:40:08.803]                         if (!is.null(pattern)) {
[17:40:08.803]                           computeRestarts <- base::computeRestarts
[17:40:08.803]                           grepl <- base::grepl
[17:40:08.803]                           restarts <- computeRestarts(cond)
[17:40:08.803]                           for (restart in restarts) {
[17:40:08.803]                             name <- restart$name
[17:40:08.803]                             if (is.null(name)) 
[17:40:08.803]                               next
[17:40:08.803]                             if (!grepl(pattern, name)) 
[17:40:08.803]                               next
[17:40:08.803]                             invokeRestart(restart)
[17:40:08.803]                             muffled <- TRUE
[17:40:08.803]                             break
[17:40:08.803]                           }
[17:40:08.803]                         }
[17:40:08.803]                       }
[17:40:08.803]                       invisible(muffled)
[17:40:08.803]                     }
[17:40:08.803]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.803]                   }
[17:40:08.803]                 }
[17:40:08.803]             }
[17:40:08.803]         }))
[17:40:08.803]     }, error = function(ex) {
[17:40:08.803]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.803]                 ...future.rng), started = ...future.startTime, 
[17:40:08.803]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.803]             version = "1.8"), class = "FutureResult")
[17:40:08.803]     }, finally = {
[17:40:08.803]         if (!identical(...future.workdir, getwd())) 
[17:40:08.803]             setwd(...future.workdir)
[17:40:08.803]         {
[17:40:08.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.803]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.803]             }
[17:40:08.803]             base::options(...future.oldOptions)
[17:40:08.803]             if (.Platform$OS.type == "windows") {
[17:40:08.803]                 old_names <- names(...future.oldEnvVars)
[17:40:08.803]                 envs <- base::Sys.getenv()
[17:40:08.803]                 names <- names(envs)
[17:40:08.803]                 common <- intersect(names, old_names)
[17:40:08.803]                 added <- setdiff(names, old_names)
[17:40:08.803]                 removed <- setdiff(old_names, names)
[17:40:08.803]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.803]                   envs[common]]
[17:40:08.803]                 NAMES <- toupper(changed)
[17:40:08.803]                 args <- list()
[17:40:08.803]                 for (kk in seq_along(NAMES)) {
[17:40:08.803]                   name <- changed[[kk]]
[17:40:08.803]                   NAME <- NAMES[[kk]]
[17:40:08.803]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.803]                     next
[17:40:08.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.803]                 }
[17:40:08.803]                 NAMES <- toupper(added)
[17:40:08.803]                 for (kk in seq_along(NAMES)) {
[17:40:08.803]                   name <- added[[kk]]
[17:40:08.803]                   NAME <- NAMES[[kk]]
[17:40:08.803]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.803]                     next
[17:40:08.803]                   args[[name]] <- ""
[17:40:08.803]                 }
[17:40:08.803]                 NAMES <- toupper(removed)
[17:40:08.803]                 for (kk in seq_along(NAMES)) {
[17:40:08.803]                   name <- removed[[kk]]
[17:40:08.803]                   NAME <- NAMES[[kk]]
[17:40:08.803]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.803]                     next
[17:40:08.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.803]                 }
[17:40:08.803]                 if (length(args) > 0) 
[17:40:08.803]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.803]             }
[17:40:08.803]             else {
[17:40:08.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.803]             }
[17:40:08.803]             {
[17:40:08.803]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.803]                   0L) {
[17:40:08.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.803]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.803]                   base::options(opts)
[17:40:08.803]                 }
[17:40:08.803]                 {
[17:40:08.803]                   {
[17:40:08.803]                     NULL
[17:40:08.803]                     RNGkind("Mersenne-Twister")
[17:40:08.803]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.803]                       inherits = FALSE)
[17:40:08.803]                   }
[17:40:08.803]                   options(future.plan = NULL)
[17:40:08.803]                   if (is.na(NA_character_)) 
[17:40:08.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.803]                     .init = FALSE)
[17:40:08.803]                 }
[17:40:08.803]             }
[17:40:08.803]         }
[17:40:08.803]     })
[17:40:08.803]     if (TRUE) {
[17:40:08.803]         base::sink(type = "output", split = FALSE)
[17:40:08.803]         if (TRUE) {
[17:40:08.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.803]         }
[17:40:08.803]         else {
[17:40:08.803]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.803]         }
[17:40:08.803]         base::close(...future.stdout)
[17:40:08.803]         ...future.stdout <- NULL
[17:40:08.803]     }
[17:40:08.803]     ...future.result$conditions <- ...future.conditions
[17:40:08.803]     ...future.result$finished <- base::Sys.time()
[17:40:08.803]     ...future.result
[17:40:08.803] }
[17:40:08.805] assign_globals() ...
[17:40:08.805] List of 1
[17:40:08.805]  $ a: num 0
[17:40:08.805]  - attr(*, "where")=List of 1
[17:40:08.805]   ..$ a:<environment: R_EmptyEnv> 
[17:40:08.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:08.805]  - attr(*, "resolved")= logi FALSE
[17:40:08.805]  - attr(*, "total_size")= num 56
[17:40:08.811] - copied ‘a’ to environment
[17:40:08.811] assign_globals() ... done
[17:40:08.811] plan(): Setting new future strategy stack:
[17:40:08.811] List of future strategies:
[17:40:08.811] 1. sequential:
[17:40:08.811]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.811]    - tweaked: FALSE
[17:40:08.811]    - call: NULL
[17:40:08.812] plan(): nbrOfWorkers() = 1
[17:40:08.812] plan(): Setting new future strategy stack:
[17:40:08.812] List of future strategies:
[17:40:08.812] 1. sequential:
[17:40:08.812]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.812]    - tweaked: FALSE
[17:40:08.812]    - call: future::plan("sequential")
[17:40:08.813] plan(): nbrOfWorkers() = 1
[17:40:08.813] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[17:40:08.816] getGlobalsAndPackages() ...
[17:40:08.817] Searching for globals...
[17:40:08.817] - globals found: [2] ‘{’, ‘ii’
[17:40:08.817] Searching for globals ... DONE
[17:40:08.817] Resolving globals: FALSE
[17:40:08.818] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:08.818] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:40:08.818] - globals: [1] ‘ii’
[17:40:08.818] 
[17:40:08.818] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[17:40:08.822] getGlobalsAndPackages() ...
[17:40:08.822] Searching for globals...
[17:40:08.823] - globals found: [2] ‘{’, ‘ii’
[17:40:08.823] Searching for globals ... DONE
[17:40:08.823] Resolving globals: FALSE
[17:40:08.823] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:08.823] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:40:08.824] - globals: [1] ‘ii’
[17:40:08.824] 
[17:40:08.824] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[17:40:08.824] Packages needed by the future expression (n = 0): <none>
[17:40:08.824] Packages needed by future strategies (n = 0): <none>
[17:40:08.825] {
[17:40:08.825]     {
[17:40:08.825]         {
[17:40:08.825]             ...future.startTime <- base::Sys.time()
[17:40:08.825]             {
[17:40:08.825]                 {
[17:40:08.825]                   {
[17:40:08.825]                     base::local({
[17:40:08.825]                       has_future <- base::requireNamespace("future", 
[17:40:08.825]                         quietly = TRUE)
[17:40:08.825]                       if (has_future) {
[17:40:08.825]                         ns <- base::getNamespace("future")
[17:40:08.825]                         version <- ns[[".package"]][["version"]]
[17:40:08.825]                         if (is.null(version)) 
[17:40:08.825]                           version <- utils::packageVersion("future")
[17:40:08.825]                       }
[17:40:08.825]                       else {
[17:40:08.825]                         version <- NULL
[17:40:08.825]                       }
[17:40:08.825]                       if (!has_future || version < "1.8.0") {
[17:40:08.825]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.825]                           "", base::R.version$version.string), 
[17:40:08.825]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.825]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.825]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.825]                             "release", "version")], collapse = " "), 
[17:40:08.825]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.825]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.825]                           info)
[17:40:08.825]                         info <- base::paste(info, collapse = "; ")
[17:40:08.825]                         if (!has_future) {
[17:40:08.825]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.825]                             info)
[17:40:08.825]                         }
[17:40:08.825]                         else {
[17:40:08.825]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.825]                             info, version)
[17:40:08.825]                         }
[17:40:08.825]                         base::stop(msg)
[17:40:08.825]                       }
[17:40:08.825]                     })
[17:40:08.825]                   }
[17:40:08.825]                   ...future.strategy.old <- future::plan("list")
[17:40:08.825]                   options(future.plan = NULL)
[17:40:08.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.825]                 }
[17:40:08.825]                 ...future.workdir <- getwd()
[17:40:08.825]             }
[17:40:08.825]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.825]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.825]         }
[17:40:08.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.825]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.825]             base::names(...future.oldOptions))
[17:40:08.825]     }
[17:40:08.825]     if (FALSE) {
[17:40:08.825]     }
[17:40:08.825]     else {
[17:40:08.825]         if (TRUE) {
[17:40:08.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.825]                 open = "w")
[17:40:08.825]         }
[17:40:08.825]         else {
[17:40:08.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.825]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.825]         }
[17:40:08.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.825]             base::sink(type = "output", split = FALSE)
[17:40:08.825]             base::close(...future.stdout)
[17:40:08.825]         }, add = TRUE)
[17:40:08.825]     }
[17:40:08.825]     ...future.frame <- base::sys.nframe()
[17:40:08.825]     ...future.conditions <- base::list()
[17:40:08.825]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.825]     if (FALSE) {
[17:40:08.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.825]     }
[17:40:08.825]     ...future.result <- base::tryCatch({
[17:40:08.825]         base::withCallingHandlers({
[17:40:08.825]             ...future.value <- base::withVisible(base::local({
[17:40:08.825]                 ii
[17:40:08.825]             }))
[17:40:08.825]             future::FutureResult(value = ...future.value$value, 
[17:40:08.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.825]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.825]                     ...future.globalenv.names))
[17:40:08.825]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.825]         }, condition = base::local({
[17:40:08.825]             c <- base::c
[17:40:08.825]             inherits <- base::inherits
[17:40:08.825]             invokeRestart <- base::invokeRestart
[17:40:08.825]             length <- base::length
[17:40:08.825]             list <- base::list
[17:40:08.825]             seq.int <- base::seq.int
[17:40:08.825]             signalCondition <- base::signalCondition
[17:40:08.825]             sys.calls <- base::sys.calls
[17:40:08.825]             `[[` <- base::`[[`
[17:40:08.825]             `+` <- base::`+`
[17:40:08.825]             `<<-` <- base::`<<-`
[17:40:08.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.825]                   3L)]
[17:40:08.825]             }
[17:40:08.825]             function(cond) {
[17:40:08.825]                 is_error <- inherits(cond, "error")
[17:40:08.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.825]                   NULL)
[17:40:08.825]                 if (is_error) {
[17:40:08.825]                   sessionInformation <- function() {
[17:40:08.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.825]                       search = base::search(), system = base::Sys.info())
[17:40:08.825]                   }
[17:40:08.825]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.825]                     cond$call), session = sessionInformation(), 
[17:40:08.825]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.825]                   signalCondition(cond)
[17:40:08.825]                 }
[17:40:08.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.825]                 "immediateCondition"))) {
[17:40:08.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.825]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.825]                   if (TRUE && !signal) {
[17:40:08.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.825]                     {
[17:40:08.825]                       inherits <- base::inherits
[17:40:08.825]                       invokeRestart <- base::invokeRestart
[17:40:08.825]                       is.null <- base::is.null
[17:40:08.825]                       muffled <- FALSE
[17:40:08.825]                       if (inherits(cond, "message")) {
[17:40:08.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.825]                         if (muffled) 
[17:40:08.825]                           invokeRestart("muffleMessage")
[17:40:08.825]                       }
[17:40:08.825]                       else if (inherits(cond, "warning")) {
[17:40:08.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.825]                         if (muffled) 
[17:40:08.825]                           invokeRestart("muffleWarning")
[17:40:08.825]                       }
[17:40:08.825]                       else if (inherits(cond, "condition")) {
[17:40:08.825]                         if (!is.null(pattern)) {
[17:40:08.825]                           computeRestarts <- base::computeRestarts
[17:40:08.825]                           grepl <- base::grepl
[17:40:08.825]                           restarts <- computeRestarts(cond)
[17:40:08.825]                           for (restart in restarts) {
[17:40:08.825]                             name <- restart$name
[17:40:08.825]                             if (is.null(name)) 
[17:40:08.825]                               next
[17:40:08.825]                             if (!grepl(pattern, name)) 
[17:40:08.825]                               next
[17:40:08.825]                             invokeRestart(restart)
[17:40:08.825]                             muffled <- TRUE
[17:40:08.825]                             break
[17:40:08.825]                           }
[17:40:08.825]                         }
[17:40:08.825]                       }
[17:40:08.825]                       invisible(muffled)
[17:40:08.825]                     }
[17:40:08.825]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.825]                   }
[17:40:08.825]                 }
[17:40:08.825]                 else {
[17:40:08.825]                   if (TRUE) {
[17:40:08.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.825]                     {
[17:40:08.825]                       inherits <- base::inherits
[17:40:08.825]                       invokeRestart <- base::invokeRestart
[17:40:08.825]                       is.null <- base::is.null
[17:40:08.825]                       muffled <- FALSE
[17:40:08.825]                       if (inherits(cond, "message")) {
[17:40:08.825]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.825]                         if (muffled) 
[17:40:08.825]                           invokeRestart("muffleMessage")
[17:40:08.825]                       }
[17:40:08.825]                       else if (inherits(cond, "warning")) {
[17:40:08.825]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.825]                         if (muffled) 
[17:40:08.825]                           invokeRestart("muffleWarning")
[17:40:08.825]                       }
[17:40:08.825]                       else if (inherits(cond, "condition")) {
[17:40:08.825]                         if (!is.null(pattern)) {
[17:40:08.825]                           computeRestarts <- base::computeRestarts
[17:40:08.825]                           grepl <- base::grepl
[17:40:08.825]                           restarts <- computeRestarts(cond)
[17:40:08.825]                           for (restart in restarts) {
[17:40:08.825]                             name <- restart$name
[17:40:08.825]                             if (is.null(name)) 
[17:40:08.825]                               next
[17:40:08.825]                             if (!grepl(pattern, name)) 
[17:40:08.825]                               next
[17:40:08.825]                             invokeRestart(restart)
[17:40:08.825]                             muffled <- TRUE
[17:40:08.825]                             break
[17:40:08.825]                           }
[17:40:08.825]                         }
[17:40:08.825]                       }
[17:40:08.825]                       invisible(muffled)
[17:40:08.825]                     }
[17:40:08.825]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.825]                   }
[17:40:08.825]                 }
[17:40:08.825]             }
[17:40:08.825]         }))
[17:40:08.825]     }, error = function(ex) {
[17:40:08.825]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.825]                 ...future.rng), started = ...future.startTime, 
[17:40:08.825]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.825]             version = "1.8"), class = "FutureResult")
[17:40:08.825]     }, finally = {
[17:40:08.825]         if (!identical(...future.workdir, getwd())) 
[17:40:08.825]             setwd(...future.workdir)
[17:40:08.825]         {
[17:40:08.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.825]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.825]             }
[17:40:08.825]             base::options(...future.oldOptions)
[17:40:08.825]             if (.Platform$OS.type == "windows") {
[17:40:08.825]                 old_names <- names(...future.oldEnvVars)
[17:40:08.825]                 envs <- base::Sys.getenv()
[17:40:08.825]                 names <- names(envs)
[17:40:08.825]                 common <- intersect(names, old_names)
[17:40:08.825]                 added <- setdiff(names, old_names)
[17:40:08.825]                 removed <- setdiff(old_names, names)
[17:40:08.825]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.825]                   envs[common]]
[17:40:08.825]                 NAMES <- toupper(changed)
[17:40:08.825]                 args <- list()
[17:40:08.825]                 for (kk in seq_along(NAMES)) {
[17:40:08.825]                   name <- changed[[kk]]
[17:40:08.825]                   NAME <- NAMES[[kk]]
[17:40:08.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.825]                     next
[17:40:08.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.825]                 }
[17:40:08.825]                 NAMES <- toupper(added)
[17:40:08.825]                 for (kk in seq_along(NAMES)) {
[17:40:08.825]                   name <- added[[kk]]
[17:40:08.825]                   NAME <- NAMES[[kk]]
[17:40:08.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.825]                     next
[17:40:08.825]                   args[[name]] <- ""
[17:40:08.825]                 }
[17:40:08.825]                 NAMES <- toupper(removed)
[17:40:08.825]                 for (kk in seq_along(NAMES)) {
[17:40:08.825]                   name <- removed[[kk]]
[17:40:08.825]                   NAME <- NAMES[[kk]]
[17:40:08.825]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.825]                     next
[17:40:08.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.825]                 }
[17:40:08.825]                 if (length(args) > 0) 
[17:40:08.825]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.825]             }
[17:40:08.825]             else {
[17:40:08.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.825]             }
[17:40:08.825]             {
[17:40:08.825]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.825]                   0L) {
[17:40:08.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.825]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.825]                   base::options(opts)
[17:40:08.825]                 }
[17:40:08.825]                 {
[17:40:08.825]                   {
[17:40:08.825]                     NULL
[17:40:08.825]                     RNGkind("Mersenne-Twister")
[17:40:08.825]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.825]                       inherits = FALSE)
[17:40:08.825]                   }
[17:40:08.825]                   options(future.plan = NULL)
[17:40:08.825]                   if (is.na(NA_character_)) 
[17:40:08.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.825]                     .init = FALSE)
[17:40:08.825]                 }
[17:40:08.825]             }
[17:40:08.825]         }
[17:40:08.825]     })
[17:40:08.825]     if (TRUE) {
[17:40:08.825]         base::sink(type = "output", split = FALSE)
[17:40:08.825]         if (TRUE) {
[17:40:08.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.825]         }
[17:40:08.825]         else {
[17:40:08.825]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.825]         }
[17:40:08.825]         base::close(...future.stdout)
[17:40:08.825]         ...future.stdout <- NULL
[17:40:08.825]     }
[17:40:08.825]     ...future.result$conditions <- ...future.conditions
[17:40:08.825]     ...future.result$finished <- base::Sys.time()
[17:40:08.825]     ...future.result
[17:40:08.825] }
[17:40:08.826] assign_globals() ...
[17:40:08.826] List of 1
[17:40:08.826]  $ ii: int 1
[17:40:08.826]  - attr(*, "where")=List of 1
[17:40:08.826]   ..$ ii:<environment: R_EmptyEnv> 
[17:40:08.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:08.826]  - attr(*, "resolved")= logi FALSE
[17:40:08.826]  - attr(*, "total_size")= num 56
[17:40:08.828] - copied ‘ii’ to environment
[17:40:08.829] assign_globals() ... done
[17:40:08.829] plan(): Setting new future strategy stack:
[17:40:08.829] List of future strategies:
[17:40:08.829] 1. sequential:
[17:40:08.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.829]    - tweaked: FALSE
[17:40:08.829]    - call: NULL
[17:40:08.829] plan(): nbrOfWorkers() = 1
[17:40:08.830] plan(): Setting new future strategy stack:
[17:40:08.830] List of future strategies:
[17:40:08.830] 1. sequential:
[17:40:08.830]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.830]    - tweaked: FALSE
[17:40:08.830]    - call: future::plan("sequential")
[17:40:08.830] plan(): nbrOfWorkers() = 1
[17:40:08.831] SequentialFuture started (and completed)
[17:40:08.831] Packages needed by the future expression (n = 0): <none>
[17:40:08.831] Packages needed by future strategies (n = 0): <none>
[17:40:08.831] {
[17:40:08.831]     {
[17:40:08.831]         {
[17:40:08.831]             ...future.startTime <- base::Sys.time()
[17:40:08.831]             {
[17:40:08.831]                 {
[17:40:08.831]                   {
[17:40:08.831]                     base::local({
[17:40:08.831]                       has_future <- base::requireNamespace("future", 
[17:40:08.831]                         quietly = TRUE)
[17:40:08.831]                       if (has_future) {
[17:40:08.831]                         ns <- base::getNamespace("future")
[17:40:08.831]                         version <- ns[[".package"]][["version"]]
[17:40:08.831]                         if (is.null(version)) 
[17:40:08.831]                           version <- utils::packageVersion("future")
[17:40:08.831]                       }
[17:40:08.831]                       else {
[17:40:08.831]                         version <- NULL
[17:40:08.831]                       }
[17:40:08.831]                       if (!has_future || version < "1.8.0") {
[17:40:08.831]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.831]                           "", base::R.version$version.string), 
[17:40:08.831]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.831]                             "release", "version")], collapse = " "), 
[17:40:08.831]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.831]                           info)
[17:40:08.831]                         info <- base::paste(info, collapse = "; ")
[17:40:08.831]                         if (!has_future) {
[17:40:08.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.831]                             info)
[17:40:08.831]                         }
[17:40:08.831]                         else {
[17:40:08.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.831]                             info, version)
[17:40:08.831]                         }
[17:40:08.831]                         base::stop(msg)
[17:40:08.831]                       }
[17:40:08.831]                     })
[17:40:08.831]                   }
[17:40:08.831]                   ...future.strategy.old <- future::plan("list")
[17:40:08.831]                   options(future.plan = NULL)
[17:40:08.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.831]                 }
[17:40:08.831]                 ...future.workdir <- getwd()
[17:40:08.831]             }
[17:40:08.831]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.831]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.831]         }
[17:40:08.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.831]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.831]             base::names(...future.oldOptions))
[17:40:08.831]     }
[17:40:08.831]     if (FALSE) {
[17:40:08.831]     }
[17:40:08.831]     else {
[17:40:08.831]         if (TRUE) {
[17:40:08.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.831]                 open = "w")
[17:40:08.831]         }
[17:40:08.831]         else {
[17:40:08.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.831]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.831]         }
[17:40:08.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.831]             base::sink(type = "output", split = FALSE)
[17:40:08.831]             base::close(...future.stdout)
[17:40:08.831]         }, add = TRUE)
[17:40:08.831]     }
[17:40:08.831]     ...future.frame <- base::sys.nframe()
[17:40:08.831]     ...future.conditions <- base::list()
[17:40:08.831]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.831]     if (FALSE) {
[17:40:08.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.831]     }
[17:40:08.831]     ...future.result <- base::tryCatch({
[17:40:08.831]         base::withCallingHandlers({
[17:40:08.831]             ...future.value <- base::withVisible(base::local({
[17:40:08.831]                 ii
[17:40:08.831]             }))
[17:40:08.831]             future::FutureResult(value = ...future.value$value, 
[17:40:08.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.831]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.831]                     ...future.globalenv.names))
[17:40:08.831]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.831]         }, condition = base::local({
[17:40:08.831]             c <- base::c
[17:40:08.831]             inherits <- base::inherits
[17:40:08.831]             invokeRestart <- base::invokeRestart
[17:40:08.831]             length <- base::length
[17:40:08.831]             list <- base::list
[17:40:08.831]             seq.int <- base::seq.int
[17:40:08.831]             signalCondition <- base::signalCondition
[17:40:08.831]             sys.calls <- base::sys.calls
[17:40:08.831]             `[[` <- base::`[[`
[17:40:08.831]             `+` <- base::`+`
[17:40:08.831]             `<<-` <- base::`<<-`
[17:40:08.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.831]                   3L)]
[17:40:08.831]             }
[17:40:08.831]             function(cond) {
[17:40:08.831]                 is_error <- inherits(cond, "error")
[17:40:08.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.831]                   NULL)
[17:40:08.831]                 if (is_error) {
[17:40:08.831]                   sessionInformation <- function() {
[17:40:08.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.831]                       search = base::search(), system = base::Sys.info())
[17:40:08.831]                   }
[17:40:08.831]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.831]                     cond$call), session = sessionInformation(), 
[17:40:08.831]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.831]                   signalCondition(cond)
[17:40:08.831]                 }
[17:40:08.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.831]                 "immediateCondition"))) {
[17:40:08.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.831]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.831]                   if (TRUE && !signal) {
[17:40:08.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.831]                     {
[17:40:08.831]                       inherits <- base::inherits
[17:40:08.831]                       invokeRestart <- base::invokeRestart
[17:40:08.831]                       is.null <- base::is.null
[17:40:08.831]                       muffled <- FALSE
[17:40:08.831]                       if (inherits(cond, "message")) {
[17:40:08.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.831]                         if (muffled) 
[17:40:08.831]                           invokeRestart("muffleMessage")
[17:40:08.831]                       }
[17:40:08.831]                       else if (inherits(cond, "warning")) {
[17:40:08.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.831]                         if (muffled) 
[17:40:08.831]                           invokeRestart("muffleWarning")
[17:40:08.831]                       }
[17:40:08.831]                       else if (inherits(cond, "condition")) {
[17:40:08.831]                         if (!is.null(pattern)) {
[17:40:08.831]                           computeRestarts <- base::computeRestarts
[17:40:08.831]                           grepl <- base::grepl
[17:40:08.831]                           restarts <- computeRestarts(cond)
[17:40:08.831]                           for (restart in restarts) {
[17:40:08.831]                             name <- restart$name
[17:40:08.831]                             if (is.null(name)) 
[17:40:08.831]                               next
[17:40:08.831]                             if (!grepl(pattern, name)) 
[17:40:08.831]                               next
[17:40:08.831]                             invokeRestart(restart)
[17:40:08.831]                             muffled <- TRUE
[17:40:08.831]                             break
[17:40:08.831]                           }
[17:40:08.831]                         }
[17:40:08.831]                       }
[17:40:08.831]                       invisible(muffled)
[17:40:08.831]                     }
[17:40:08.831]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.831]                   }
[17:40:08.831]                 }
[17:40:08.831]                 else {
[17:40:08.831]                   if (TRUE) {
[17:40:08.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.831]                     {
[17:40:08.831]                       inherits <- base::inherits
[17:40:08.831]                       invokeRestart <- base::invokeRestart
[17:40:08.831]                       is.null <- base::is.null
[17:40:08.831]                       muffled <- FALSE
[17:40:08.831]                       if (inherits(cond, "message")) {
[17:40:08.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.831]                         if (muffled) 
[17:40:08.831]                           invokeRestart("muffleMessage")
[17:40:08.831]                       }
[17:40:08.831]                       else if (inherits(cond, "warning")) {
[17:40:08.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.831]                         if (muffled) 
[17:40:08.831]                           invokeRestart("muffleWarning")
[17:40:08.831]                       }
[17:40:08.831]                       else if (inherits(cond, "condition")) {
[17:40:08.831]                         if (!is.null(pattern)) {
[17:40:08.831]                           computeRestarts <- base::computeRestarts
[17:40:08.831]                           grepl <- base::grepl
[17:40:08.831]                           restarts <- computeRestarts(cond)
[17:40:08.831]                           for (restart in restarts) {
[17:40:08.831]                             name <- restart$name
[17:40:08.831]                             if (is.null(name)) 
[17:40:08.831]                               next
[17:40:08.831]                             if (!grepl(pattern, name)) 
[17:40:08.831]                               next
[17:40:08.831]                             invokeRestart(restart)
[17:40:08.831]                             muffled <- TRUE
[17:40:08.831]                             break
[17:40:08.831]                           }
[17:40:08.831]                         }
[17:40:08.831]                       }
[17:40:08.831]                       invisible(muffled)
[17:40:08.831]                     }
[17:40:08.831]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.831]                   }
[17:40:08.831]                 }
[17:40:08.831]             }
[17:40:08.831]         }))
[17:40:08.831]     }, error = function(ex) {
[17:40:08.831]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.831]                 ...future.rng), started = ...future.startTime, 
[17:40:08.831]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.831]             version = "1.8"), class = "FutureResult")
[17:40:08.831]     }, finally = {
[17:40:08.831]         if (!identical(...future.workdir, getwd())) 
[17:40:08.831]             setwd(...future.workdir)
[17:40:08.831]         {
[17:40:08.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.831]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.831]             }
[17:40:08.831]             base::options(...future.oldOptions)
[17:40:08.831]             if (.Platform$OS.type == "windows") {
[17:40:08.831]                 old_names <- names(...future.oldEnvVars)
[17:40:08.831]                 envs <- base::Sys.getenv()
[17:40:08.831]                 names <- names(envs)
[17:40:08.831]                 common <- intersect(names, old_names)
[17:40:08.831]                 added <- setdiff(names, old_names)
[17:40:08.831]                 removed <- setdiff(old_names, names)
[17:40:08.831]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.831]                   envs[common]]
[17:40:08.831]                 NAMES <- toupper(changed)
[17:40:08.831]                 args <- list()
[17:40:08.831]                 for (kk in seq_along(NAMES)) {
[17:40:08.831]                   name <- changed[[kk]]
[17:40:08.831]                   NAME <- NAMES[[kk]]
[17:40:08.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.831]                     next
[17:40:08.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.831]                 }
[17:40:08.831]                 NAMES <- toupper(added)
[17:40:08.831]                 for (kk in seq_along(NAMES)) {
[17:40:08.831]                   name <- added[[kk]]
[17:40:08.831]                   NAME <- NAMES[[kk]]
[17:40:08.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.831]                     next
[17:40:08.831]                   args[[name]] <- ""
[17:40:08.831]                 }
[17:40:08.831]                 NAMES <- toupper(removed)
[17:40:08.831]                 for (kk in seq_along(NAMES)) {
[17:40:08.831]                   name <- removed[[kk]]
[17:40:08.831]                   NAME <- NAMES[[kk]]
[17:40:08.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.831]                     next
[17:40:08.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.831]                 }
[17:40:08.831]                 if (length(args) > 0) 
[17:40:08.831]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.831]             }
[17:40:08.831]             else {
[17:40:08.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.831]             }
[17:40:08.831]             {
[17:40:08.831]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.831]                   0L) {
[17:40:08.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.831]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.831]                   base::options(opts)
[17:40:08.831]                 }
[17:40:08.831]                 {
[17:40:08.831]                   {
[17:40:08.831]                     NULL
[17:40:08.831]                     RNGkind("Mersenne-Twister")
[17:40:08.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.831]                       inherits = FALSE)
[17:40:08.831]                   }
[17:40:08.831]                   options(future.plan = NULL)
[17:40:08.831]                   if (is.na(NA_character_)) 
[17:40:08.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.831]                     .init = FALSE)
[17:40:08.831]                 }
[17:40:08.831]             }
[17:40:08.831]         }
[17:40:08.831]     })
[17:40:08.831]     if (TRUE) {
[17:40:08.831]         base::sink(type = "output", split = FALSE)
[17:40:08.831]         if (TRUE) {
[17:40:08.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.831]         }
[17:40:08.831]         else {
[17:40:08.831]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.831]         }
[17:40:08.831]         base::close(...future.stdout)
[17:40:08.831]         ...future.stdout <- NULL
[17:40:08.831]     }
[17:40:08.831]     ...future.result$conditions <- ...future.conditions
[17:40:08.831]     ...future.result$finished <- base::Sys.time()
[17:40:08.831]     ...future.result
[17:40:08.831] }
[17:40:08.833] assign_globals() ...
[17:40:08.833] List of 1
[17:40:08.833]  $ ii: int 2
[17:40:08.833]  - attr(*, "where")=List of 1
[17:40:08.833]   ..$ ii:<environment: R_EmptyEnv> 
[17:40:08.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:08.833]  - attr(*, "resolved")= logi FALSE
[17:40:08.833]  - attr(*, "total_size")= num 56
[17:40:08.835] - copied ‘ii’ to environment
[17:40:08.835] assign_globals() ... done
[17:40:08.835] plan(): Setting new future strategy stack:
[17:40:08.835] List of future strategies:
[17:40:08.835] 1. sequential:
[17:40:08.835]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.835]    - tweaked: FALSE
[17:40:08.835]    - call: NULL
[17:40:08.836] plan(): nbrOfWorkers() = 1
[17:40:08.836] plan(): Setting new future strategy stack:
[17:40:08.836] List of future strategies:
[17:40:08.836] 1. sequential:
[17:40:08.836]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.836]    - tweaked: FALSE
[17:40:08.836]    - call: future::plan("sequential")
[17:40:08.837] plan(): nbrOfWorkers() = 1
[17:40:08.837] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[17:40:08.837] getGlobalsAndPackages() ...
[17:40:08.837] Searching for globals...
[17:40:08.838] - globals found: [1] ‘.libPaths’
[17:40:08.838] Searching for globals ... DONE
[17:40:08.838] Resolving globals: FALSE
[17:40:08.838] 
[17:40:08.838] 
[17:40:08.838] getGlobalsAndPackages() ... DONE
[17:40:08.839] run() for ‘Future’ ...
[17:40:08.839] - state: ‘created’
[17:40:08.839] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:08.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:08.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:08.840]   - Field: ‘label’
[17:40:08.840]   - Field: ‘local’
[17:40:08.840]   - Field: ‘owner’
[17:40:08.840]   - Field: ‘envir’
[17:40:08.840]   - Field: ‘packages’
[17:40:08.840]   - Field: ‘gc’
[17:40:08.840]   - Field: ‘conditions’
[17:40:08.840]   - Field: ‘expr’
[17:40:08.840]   - Field: ‘uuid’
[17:40:08.840]   - Field: ‘seed’
[17:40:08.840]   - Field: ‘version’
[17:40:08.841]   - Field: ‘result’
[17:40:08.841]   - Field: ‘asynchronous’
[17:40:08.841]   - Field: ‘calls’
[17:40:08.841]   - Field: ‘globals’
[17:40:08.841]   - Field: ‘stdout’
[17:40:08.841]   - Field: ‘earlySignal’
[17:40:08.841]   - Field: ‘lazy’
[17:40:08.841]   - Field: ‘state’
[17:40:08.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:08.841] - Launch lazy future ...
[17:40:08.841] Packages needed by the future expression (n = 0): <none>
[17:40:08.842] Packages needed by future strategies (n = 0): <none>
[17:40:08.842] {
[17:40:08.842]     {
[17:40:08.842]         {
[17:40:08.842]             ...future.startTime <- base::Sys.time()
[17:40:08.842]             {
[17:40:08.842]                 {
[17:40:08.842]                   {
[17:40:08.842]                     base::local({
[17:40:08.842]                       has_future <- base::requireNamespace("future", 
[17:40:08.842]                         quietly = TRUE)
[17:40:08.842]                       if (has_future) {
[17:40:08.842]                         ns <- base::getNamespace("future")
[17:40:08.842]                         version <- ns[[".package"]][["version"]]
[17:40:08.842]                         if (is.null(version)) 
[17:40:08.842]                           version <- utils::packageVersion("future")
[17:40:08.842]                       }
[17:40:08.842]                       else {
[17:40:08.842]                         version <- NULL
[17:40:08.842]                       }
[17:40:08.842]                       if (!has_future || version < "1.8.0") {
[17:40:08.842]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.842]                           "", base::R.version$version.string), 
[17:40:08.842]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.842]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.842]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.842]                             "release", "version")], collapse = " "), 
[17:40:08.842]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.842]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.842]                           info)
[17:40:08.842]                         info <- base::paste(info, collapse = "; ")
[17:40:08.842]                         if (!has_future) {
[17:40:08.842]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.842]                             info)
[17:40:08.842]                         }
[17:40:08.842]                         else {
[17:40:08.842]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.842]                             info, version)
[17:40:08.842]                         }
[17:40:08.842]                         base::stop(msg)
[17:40:08.842]                       }
[17:40:08.842]                     })
[17:40:08.842]                   }
[17:40:08.842]                   ...future.strategy.old <- future::plan("list")
[17:40:08.842]                   options(future.plan = NULL)
[17:40:08.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.842]                 }
[17:40:08.842]                 ...future.workdir <- getwd()
[17:40:08.842]             }
[17:40:08.842]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.842]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.842]         }
[17:40:08.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.842]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.842]             base::names(...future.oldOptions))
[17:40:08.842]     }
[17:40:08.842]     if (FALSE) {
[17:40:08.842]     }
[17:40:08.842]     else {
[17:40:08.842]         if (TRUE) {
[17:40:08.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.842]                 open = "w")
[17:40:08.842]         }
[17:40:08.842]         else {
[17:40:08.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.842]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.842]         }
[17:40:08.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.842]             base::sink(type = "output", split = FALSE)
[17:40:08.842]             base::close(...future.stdout)
[17:40:08.842]         }, add = TRUE)
[17:40:08.842]     }
[17:40:08.842]     ...future.frame <- base::sys.nframe()
[17:40:08.842]     ...future.conditions <- base::list()
[17:40:08.842]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.842]     if (FALSE) {
[17:40:08.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.842]     }
[17:40:08.842]     ...future.result <- base::tryCatch({
[17:40:08.842]         base::withCallingHandlers({
[17:40:08.842]             ...future.value <- base::withVisible(base::local(.libPaths()))
[17:40:08.842]             future::FutureResult(value = ...future.value$value, 
[17:40:08.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.842]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.842]                     ...future.globalenv.names))
[17:40:08.842]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.842]         }, condition = base::local({
[17:40:08.842]             c <- base::c
[17:40:08.842]             inherits <- base::inherits
[17:40:08.842]             invokeRestart <- base::invokeRestart
[17:40:08.842]             length <- base::length
[17:40:08.842]             list <- base::list
[17:40:08.842]             seq.int <- base::seq.int
[17:40:08.842]             signalCondition <- base::signalCondition
[17:40:08.842]             sys.calls <- base::sys.calls
[17:40:08.842]             `[[` <- base::`[[`
[17:40:08.842]             `+` <- base::`+`
[17:40:08.842]             `<<-` <- base::`<<-`
[17:40:08.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.842]                   3L)]
[17:40:08.842]             }
[17:40:08.842]             function(cond) {
[17:40:08.842]                 is_error <- inherits(cond, "error")
[17:40:08.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.842]                   NULL)
[17:40:08.842]                 if (is_error) {
[17:40:08.842]                   sessionInformation <- function() {
[17:40:08.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.842]                       search = base::search(), system = base::Sys.info())
[17:40:08.842]                   }
[17:40:08.842]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.842]                     cond$call), session = sessionInformation(), 
[17:40:08.842]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.842]                   signalCondition(cond)
[17:40:08.842]                 }
[17:40:08.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.842]                 "immediateCondition"))) {
[17:40:08.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.842]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.842]                   if (TRUE && !signal) {
[17:40:08.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.842]                     {
[17:40:08.842]                       inherits <- base::inherits
[17:40:08.842]                       invokeRestart <- base::invokeRestart
[17:40:08.842]                       is.null <- base::is.null
[17:40:08.842]                       muffled <- FALSE
[17:40:08.842]                       if (inherits(cond, "message")) {
[17:40:08.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.842]                         if (muffled) 
[17:40:08.842]                           invokeRestart("muffleMessage")
[17:40:08.842]                       }
[17:40:08.842]                       else if (inherits(cond, "warning")) {
[17:40:08.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.842]                         if (muffled) 
[17:40:08.842]                           invokeRestart("muffleWarning")
[17:40:08.842]                       }
[17:40:08.842]                       else if (inherits(cond, "condition")) {
[17:40:08.842]                         if (!is.null(pattern)) {
[17:40:08.842]                           computeRestarts <- base::computeRestarts
[17:40:08.842]                           grepl <- base::grepl
[17:40:08.842]                           restarts <- computeRestarts(cond)
[17:40:08.842]                           for (restart in restarts) {
[17:40:08.842]                             name <- restart$name
[17:40:08.842]                             if (is.null(name)) 
[17:40:08.842]                               next
[17:40:08.842]                             if (!grepl(pattern, name)) 
[17:40:08.842]                               next
[17:40:08.842]                             invokeRestart(restart)
[17:40:08.842]                             muffled <- TRUE
[17:40:08.842]                             break
[17:40:08.842]                           }
[17:40:08.842]                         }
[17:40:08.842]                       }
[17:40:08.842]                       invisible(muffled)
[17:40:08.842]                     }
[17:40:08.842]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.842]                   }
[17:40:08.842]                 }
[17:40:08.842]                 else {
[17:40:08.842]                   if (TRUE) {
[17:40:08.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.842]                     {
[17:40:08.842]                       inherits <- base::inherits
[17:40:08.842]                       invokeRestart <- base::invokeRestart
[17:40:08.842]                       is.null <- base::is.null
[17:40:08.842]                       muffled <- FALSE
[17:40:08.842]                       if (inherits(cond, "message")) {
[17:40:08.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.842]                         if (muffled) 
[17:40:08.842]                           invokeRestart("muffleMessage")
[17:40:08.842]                       }
[17:40:08.842]                       else if (inherits(cond, "warning")) {
[17:40:08.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.842]                         if (muffled) 
[17:40:08.842]                           invokeRestart("muffleWarning")
[17:40:08.842]                       }
[17:40:08.842]                       else if (inherits(cond, "condition")) {
[17:40:08.842]                         if (!is.null(pattern)) {
[17:40:08.842]                           computeRestarts <- base::computeRestarts
[17:40:08.842]                           grepl <- base::grepl
[17:40:08.842]                           restarts <- computeRestarts(cond)
[17:40:08.842]                           for (restart in restarts) {
[17:40:08.842]                             name <- restart$name
[17:40:08.842]                             if (is.null(name)) 
[17:40:08.842]                               next
[17:40:08.842]                             if (!grepl(pattern, name)) 
[17:40:08.842]                               next
[17:40:08.842]                             invokeRestart(restart)
[17:40:08.842]                             muffled <- TRUE
[17:40:08.842]                             break
[17:40:08.842]                           }
[17:40:08.842]                         }
[17:40:08.842]                       }
[17:40:08.842]                       invisible(muffled)
[17:40:08.842]                     }
[17:40:08.842]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.842]                   }
[17:40:08.842]                 }
[17:40:08.842]             }
[17:40:08.842]         }))
[17:40:08.842]     }, error = function(ex) {
[17:40:08.842]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.842]                 ...future.rng), started = ...future.startTime, 
[17:40:08.842]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.842]             version = "1.8"), class = "FutureResult")
[17:40:08.842]     }, finally = {
[17:40:08.842]         if (!identical(...future.workdir, getwd())) 
[17:40:08.842]             setwd(...future.workdir)
[17:40:08.842]         {
[17:40:08.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.842]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.842]             }
[17:40:08.842]             base::options(...future.oldOptions)
[17:40:08.842]             if (.Platform$OS.type == "windows") {
[17:40:08.842]                 old_names <- names(...future.oldEnvVars)
[17:40:08.842]                 envs <- base::Sys.getenv()
[17:40:08.842]                 names <- names(envs)
[17:40:08.842]                 common <- intersect(names, old_names)
[17:40:08.842]                 added <- setdiff(names, old_names)
[17:40:08.842]                 removed <- setdiff(old_names, names)
[17:40:08.842]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.842]                   envs[common]]
[17:40:08.842]                 NAMES <- toupper(changed)
[17:40:08.842]                 args <- list()
[17:40:08.842]                 for (kk in seq_along(NAMES)) {
[17:40:08.842]                   name <- changed[[kk]]
[17:40:08.842]                   NAME <- NAMES[[kk]]
[17:40:08.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.842]                     next
[17:40:08.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.842]                 }
[17:40:08.842]                 NAMES <- toupper(added)
[17:40:08.842]                 for (kk in seq_along(NAMES)) {
[17:40:08.842]                   name <- added[[kk]]
[17:40:08.842]                   NAME <- NAMES[[kk]]
[17:40:08.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.842]                     next
[17:40:08.842]                   args[[name]] <- ""
[17:40:08.842]                 }
[17:40:08.842]                 NAMES <- toupper(removed)
[17:40:08.842]                 for (kk in seq_along(NAMES)) {
[17:40:08.842]                   name <- removed[[kk]]
[17:40:08.842]                   NAME <- NAMES[[kk]]
[17:40:08.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.842]                     next
[17:40:08.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.842]                 }
[17:40:08.842]                 if (length(args) > 0) 
[17:40:08.842]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.842]             }
[17:40:08.842]             else {
[17:40:08.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.842]             }
[17:40:08.842]             {
[17:40:08.842]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.842]                   0L) {
[17:40:08.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.842]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.842]                   base::options(opts)
[17:40:08.842]                 }
[17:40:08.842]                 {
[17:40:08.842]                   {
[17:40:08.842]                     NULL
[17:40:08.842]                     RNGkind("Mersenne-Twister")
[17:40:08.842]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.842]                       inherits = FALSE)
[17:40:08.842]                   }
[17:40:08.842]                   options(future.plan = NULL)
[17:40:08.842]                   if (is.na(NA_character_)) 
[17:40:08.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.842]                     .init = FALSE)
[17:40:08.842]                 }
[17:40:08.842]             }
[17:40:08.842]         }
[17:40:08.842]     })
[17:40:08.842]     if (TRUE) {
[17:40:08.842]         base::sink(type = "output", split = FALSE)
[17:40:08.842]         if (TRUE) {
[17:40:08.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.842]         }
[17:40:08.842]         else {
[17:40:08.842]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.842]         }
[17:40:08.842]         base::close(...future.stdout)
[17:40:08.842]         ...future.stdout <- NULL
[17:40:08.842]     }
[17:40:08.842]     ...future.result$conditions <- ...future.conditions
[17:40:08.842]     ...future.result$finished <- base::Sys.time()
[17:40:08.842]     ...future.result
[17:40:08.842] }
[17:40:08.844] plan(): Setting new future strategy stack:
[17:40:08.844] List of future strategies:
[17:40:08.844] 1. sequential:
[17:40:08.844]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.844]    - tweaked: FALSE
[17:40:08.844]    - call: NULL
[17:40:08.845] plan(): nbrOfWorkers() = 1
[17:40:08.846] plan(): Setting new future strategy stack:
[17:40:08.846] List of future strategies:
[17:40:08.846] 1. sequential:
[17:40:08.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.846]    - tweaked: FALSE
[17:40:08.846]    - call: future::plan("sequential")
[17:40:08.847] plan(): nbrOfWorkers() = 1
[17:40:08.847] SequentialFuture started (and completed)
[17:40:08.847] - Launch lazy future ... done
[17:40:08.847] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[17:40:08.851] getGlobalsAndPackages() ...
[17:40:08.851] Searching for globals...
[17:40:08.852] - globals found: [2] ‘{’, ‘stop’
[17:40:08.852] Searching for globals ... DONE
[17:40:08.852] Resolving globals: FALSE
[17:40:08.852] 
[17:40:08.852] 
[17:40:08.852] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:08.853] Packages needed by the future expression (n = 0): <none>
[17:40:08.853] Packages needed by future strategies (n = 0): <none>
[17:40:08.854] {
[17:40:08.854]     {
[17:40:08.854]         {
[17:40:08.854]             ...future.startTime <- base::Sys.time()
[17:40:08.854]             {
[17:40:08.854]                 {
[17:40:08.854]                   {
[17:40:08.854]                     base::local({
[17:40:08.854]                       has_future <- base::requireNamespace("future", 
[17:40:08.854]                         quietly = TRUE)
[17:40:08.854]                       if (has_future) {
[17:40:08.854]                         ns <- base::getNamespace("future")
[17:40:08.854]                         version <- ns[[".package"]][["version"]]
[17:40:08.854]                         if (is.null(version)) 
[17:40:08.854]                           version <- utils::packageVersion("future")
[17:40:08.854]                       }
[17:40:08.854]                       else {
[17:40:08.854]                         version <- NULL
[17:40:08.854]                       }
[17:40:08.854]                       if (!has_future || version < "1.8.0") {
[17:40:08.854]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.854]                           "", base::R.version$version.string), 
[17:40:08.854]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.854]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.854]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.854]                             "release", "version")], collapse = " "), 
[17:40:08.854]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.854]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.854]                           info)
[17:40:08.854]                         info <- base::paste(info, collapse = "; ")
[17:40:08.854]                         if (!has_future) {
[17:40:08.854]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.854]                             info)
[17:40:08.854]                         }
[17:40:08.854]                         else {
[17:40:08.854]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.854]                             info, version)
[17:40:08.854]                         }
[17:40:08.854]                         base::stop(msg)
[17:40:08.854]                       }
[17:40:08.854]                     })
[17:40:08.854]                   }
[17:40:08.854]                   ...future.strategy.old <- future::plan("list")
[17:40:08.854]                   options(future.plan = NULL)
[17:40:08.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.854]                 }
[17:40:08.854]                 ...future.workdir <- getwd()
[17:40:08.854]             }
[17:40:08.854]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.854]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.854]         }
[17:40:08.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.854]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.854]             base::names(...future.oldOptions))
[17:40:08.854]     }
[17:40:08.854]     if (FALSE) {
[17:40:08.854]     }
[17:40:08.854]     else {
[17:40:08.854]         if (TRUE) {
[17:40:08.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.854]                 open = "w")
[17:40:08.854]         }
[17:40:08.854]         else {
[17:40:08.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.854]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.854]         }
[17:40:08.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.854]             base::sink(type = "output", split = FALSE)
[17:40:08.854]             base::close(...future.stdout)
[17:40:08.854]         }, add = TRUE)
[17:40:08.854]     }
[17:40:08.854]     ...future.frame <- base::sys.nframe()
[17:40:08.854]     ...future.conditions <- base::list()
[17:40:08.854]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.854]     if (FALSE) {
[17:40:08.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.854]     }
[17:40:08.854]     ...future.result <- base::tryCatch({
[17:40:08.854]         base::withCallingHandlers({
[17:40:08.854]             ...future.value <- base::withVisible(base::local({
[17:40:08.854]                 stop("Whoops!")
[17:40:08.854]                 1
[17:40:08.854]             }))
[17:40:08.854]             future::FutureResult(value = ...future.value$value, 
[17:40:08.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.854]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.854]                     ...future.globalenv.names))
[17:40:08.854]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.854]         }, condition = base::local({
[17:40:08.854]             c <- base::c
[17:40:08.854]             inherits <- base::inherits
[17:40:08.854]             invokeRestart <- base::invokeRestart
[17:40:08.854]             length <- base::length
[17:40:08.854]             list <- base::list
[17:40:08.854]             seq.int <- base::seq.int
[17:40:08.854]             signalCondition <- base::signalCondition
[17:40:08.854]             sys.calls <- base::sys.calls
[17:40:08.854]             `[[` <- base::`[[`
[17:40:08.854]             `+` <- base::`+`
[17:40:08.854]             `<<-` <- base::`<<-`
[17:40:08.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.854]                   3L)]
[17:40:08.854]             }
[17:40:08.854]             function(cond) {
[17:40:08.854]                 is_error <- inherits(cond, "error")
[17:40:08.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.854]                   NULL)
[17:40:08.854]                 if (is_error) {
[17:40:08.854]                   sessionInformation <- function() {
[17:40:08.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.854]                       search = base::search(), system = base::Sys.info())
[17:40:08.854]                   }
[17:40:08.854]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.854]                     cond$call), session = sessionInformation(), 
[17:40:08.854]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.854]                   signalCondition(cond)
[17:40:08.854]                 }
[17:40:08.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.854]                 "immediateCondition"))) {
[17:40:08.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.854]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.854]                   if (TRUE && !signal) {
[17:40:08.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.854]                     {
[17:40:08.854]                       inherits <- base::inherits
[17:40:08.854]                       invokeRestart <- base::invokeRestart
[17:40:08.854]                       is.null <- base::is.null
[17:40:08.854]                       muffled <- FALSE
[17:40:08.854]                       if (inherits(cond, "message")) {
[17:40:08.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.854]                         if (muffled) 
[17:40:08.854]                           invokeRestart("muffleMessage")
[17:40:08.854]                       }
[17:40:08.854]                       else if (inherits(cond, "warning")) {
[17:40:08.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.854]                         if (muffled) 
[17:40:08.854]                           invokeRestart("muffleWarning")
[17:40:08.854]                       }
[17:40:08.854]                       else if (inherits(cond, "condition")) {
[17:40:08.854]                         if (!is.null(pattern)) {
[17:40:08.854]                           computeRestarts <- base::computeRestarts
[17:40:08.854]                           grepl <- base::grepl
[17:40:08.854]                           restarts <- computeRestarts(cond)
[17:40:08.854]                           for (restart in restarts) {
[17:40:08.854]                             name <- restart$name
[17:40:08.854]                             if (is.null(name)) 
[17:40:08.854]                               next
[17:40:08.854]                             if (!grepl(pattern, name)) 
[17:40:08.854]                               next
[17:40:08.854]                             invokeRestart(restart)
[17:40:08.854]                             muffled <- TRUE
[17:40:08.854]                             break
[17:40:08.854]                           }
[17:40:08.854]                         }
[17:40:08.854]                       }
[17:40:08.854]                       invisible(muffled)
[17:40:08.854]                     }
[17:40:08.854]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.854]                   }
[17:40:08.854]                 }
[17:40:08.854]                 else {
[17:40:08.854]                   if (TRUE) {
[17:40:08.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.854]                     {
[17:40:08.854]                       inherits <- base::inherits
[17:40:08.854]                       invokeRestart <- base::invokeRestart
[17:40:08.854]                       is.null <- base::is.null
[17:40:08.854]                       muffled <- FALSE
[17:40:08.854]                       if (inherits(cond, "message")) {
[17:40:08.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.854]                         if (muffled) 
[17:40:08.854]                           invokeRestart("muffleMessage")
[17:40:08.854]                       }
[17:40:08.854]                       else if (inherits(cond, "warning")) {
[17:40:08.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.854]                         if (muffled) 
[17:40:08.854]                           invokeRestart("muffleWarning")
[17:40:08.854]                       }
[17:40:08.854]                       else if (inherits(cond, "condition")) {
[17:40:08.854]                         if (!is.null(pattern)) {
[17:40:08.854]                           computeRestarts <- base::computeRestarts
[17:40:08.854]                           grepl <- base::grepl
[17:40:08.854]                           restarts <- computeRestarts(cond)
[17:40:08.854]                           for (restart in restarts) {
[17:40:08.854]                             name <- restart$name
[17:40:08.854]                             if (is.null(name)) 
[17:40:08.854]                               next
[17:40:08.854]                             if (!grepl(pattern, name)) 
[17:40:08.854]                               next
[17:40:08.854]                             invokeRestart(restart)
[17:40:08.854]                             muffled <- TRUE
[17:40:08.854]                             break
[17:40:08.854]                           }
[17:40:08.854]                         }
[17:40:08.854]                       }
[17:40:08.854]                       invisible(muffled)
[17:40:08.854]                     }
[17:40:08.854]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.854]                   }
[17:40:08.854]                 }
[17:40:08.854]             }
[17:40:08.854]         }))
[17:40:08.854]     }, error = function(ex) {
[17:40:08.854]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.854]                 ...future.rng), started = ...future.startTime, 
[17:40:08.854]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.854]             version = "1.8"), class = "FutureResult")
[17:40:08.854]     }, finally = {
[17:40:08.854]         if (!identical(...future.workdir, getwd())) 
[17:40:08.854]             setwd(...future.workdir)
[17:40:08.854]         {
[17:40:08.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.854]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.854]             }
[17:40:08.854]             base::options(...future.oldOptions)
[17:40:08.854]             if (.Platform$OS.type == "windows") {
[17:40:08.854]                 old_names <- names(...future.oldEnvVars)
[17:40:08.854]                 envs <- base::Sys.getenv()
[17:40:08.854]                 names <- names(envs)
[17:40:08.854]                 common <- intersect(names, old_names)
[17:40:08.854]                 added <- setdiff(names, old_names)
[17:40:08.854]                 removed <- setdiff(old_names, names)
[17:40:08.854]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.854]                   envs[common]]
[17:40:08.854]                 NAMES <- toupper(changed)
[17:40:08.854]                 args <- list()
[17:40:08.854]                 for (kk in seq_along(NAMES)) {
[17:40:08.854]                   name <- changed[[kk]]
[17:40:08.854]                   NAME <- NAMES[[kk]]
[17:40:08.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.854]                     next
[17:40:08.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.854]                 }
[17:40:08.854]                 NAMES <- toupper(added)
[17:40:08.854]                 for (kk in seq_along(NAMES)) {
[17:40:08.854]                   name <- added[[kk]]
[17:40:08.854]                   NAME <- NAMES[[kk]]
[17:40:08.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.854]                     next
[17:40:08.854]                   args[[name]] <- ""
[17:40:08.854]                 }
[17:40:08.854]                 NAMES <- toupper(removed)
[17:40:08.854]                 for (kk in seq_along(NAMES)) {
[17:40:08.854]                   name <- removed[[kk]]
[17:40:08.854]                   NAME <- NAMES[[kk]]
[17:40:08.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.854]                     next
[17:40:08.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.854]                 }
[17:40:08.854]                 if (length(args) > 0) 
[17:40:08.854]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.854]             }
[17:40:08.854]             else {
[17:40:08.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.854]             }
[17:40:08.854]             {
[17:40:08.854]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.854]                   0L) {
[17:40:08.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.854]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.854]                   base::options(opts)
[17:40:08.854]                 }
[17:40:08.854]                 {
[17:40:08.854]                   {
[17:40:08.854]                     NULL
[17:40:08.854]                     RNGkind("Mersenne-Twister")
[17:40:08.854]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.854]                       inherits = FALSE)
[17:40:08.854]                   }
[17:40:08.854]                   options(future.plan = NULL)
[17:40:08.854]                   if (is.na(NA_character_)) 
[17:40:08.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.854]                     .init = FALSE)
[17:40:08.854]                 }
[17:40:08.854]             }
[17:40:08.854]         }
[17:40:08.854]     })
[17:40:08.854]     if (TRUE) {
[17:40:08.854]         base::sink(type = "output", split = FALSE)
[17:40:08.854]         if (TRUE) {
[17:40:08.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.854]         }
[17:40:08.854]         else {
[17:40:08.854]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.854]         }
[17:40:08.854]         base::close(...future.stdout)
[17:40:08.854]         ...future.stdout <- NULL
[17:40:08.854]     }
[17:40:08.854]     ...future.result$conditions <- ...future.conditions
[17:40:08.854]     ...future.result$finished <- base::Sys.time()
[17:40:08.854]     ...future.result
[17:40:08.854] }
[17:40:08.855] plan(): Setting new future strategy stack:
[17:40:08.855] List of future strategies:
[17:40:08.855] 1. sequential:
[17:40:08.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.855]    - tweaked: FALSE
[17:40:08.855]    - call: NULL
[17:40:08.856] plan(): nbrOfWorkers() = 1
[17:40:08.857] plan(): Setting new future strategy stack:
[17:40:08.857] List of future strategies:
[17:40:08.857] 1. sequential:
[17:40:08.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.857]    - tweaked: FALSE
[17:40:08.857]    - call: future::plan("sequential")
[17:40:08.857] plan(): nbrOfWorkers() = 1
[17:40:08.857] SequentialFuture started (and completed)
[17:40:08.857] signalConditions() ...
[17:40:08.858]  - include = ‘immediateCondition’
[17:40:08.858]  - exclude = 
[17:40:08.858]  - resignal = FALSE
[17:40:08.858]  - Number of conditions: 1
[17:40:08.858] signalConditions() ... done
[17:40:08.858] signalConditions() ...
[17:40:08.858]  - include = ‘immediateCondition’
[17:40:08.858]  - exclude = 
[17:40:08.858]  - resignal = FALSE
[17:40:08.858]  - Number of conditions: 1
[17:40:08.858] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:40:08.859] signalConditions() ...
[17:40:08.859]  - include = ‘immediateCondition’
[17:40:08.859]  - exclude = 
[17:40:08.859]  - resignal = FALSE
[17:40:08.859]  - Number of conditions: 1
[17:40:08.859] signalConditions() ... done
[17:40:08.859] Future state: ‘finished’
[17:40:08.859] signalConditions() ...
[17:40:08.859]  - include = ‘condition’
[17:40:08.859]  - exclude = ‘immediateCondition’
[17:40:08.860]  - resignal = TRUE
[17:40:08.860]  - Number of conditions: 1
[17:40:08.860]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:40:08.860] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:40:08.860] signalConditions() ...
[17:40:08.860]  - include = ‘immediateCondition’
[17:40:08.860]  - exclude = 
[17:40:08.860]  - resignal = FALSE
[17:40:08.861]  - Number of conditions: 1
[17:40:08.861] signalConditions() ... done
[17:40:08.861] Future state: ‘finished’
[17:40:08.861] signalConditions() ...
[17:40:08.861]  - include = ‘condition’
[17:40:08.861]  - exclude = ‘immediateCondition’
[17:40:08.861]  - resignal = TRUE
[17:40:08.861]  - Number of conditions: 1
[17:40:08.861]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:40:08.861] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[17:40:08.865] getGlobalsAndPackages() ...
[17:40:08.865] Searching for globals...
[17:40:08.866] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[17:40:08.866] Searching for globals ... DONE
[17:40:08.866] Resolving globals: FALSE
[17:40:08.866] 
[17:40:08.866] 
[17:40:08.866] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:08.867] Packages needed by the future expression (n = 0): <none>
[17:40:08.867] Packages needed by future strategies (n = 0): <none>
[17:40:08.868] {
[17:40:08.868]     {
[17:40:08.868]         {
[17:40:08.868]             ...future.startTime <- base::Sys.time()
[17:40:08.868]             {
[17:40:08.868]                 {
[17:40:08.868]                   {
[17:40:08.868]                     base::local({
[17:40:08.868]                       has_future <- base::requireNamespace("future", 
[17:40:08.868]                         quietly = TRUE)
[17:40:08.868]                       if (has_future) {
[17:40:08.868]                         ns <- base::getNamespace("future")
[17:40:08.868]                         version <- ns[[".package"]][["version"]]
[17:40:08.868]                         if (is.null(version)) 
[17:40:08.868]                           version <- utils::packageVersion("future")
[17:40:08.868]                       }
[17:40:08.868]                       else {
[17:40:08.868]                         version <- NULL
[17:40:08.868]                       }
[17:40:08.868]                       if (!has_future || version < "1.8.0") {
[17:40:08.868]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:08.868]                           "", base::R.version$version.string), 
[17:40:08.868]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:08.868]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:08.868]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:08.868]                             "release", "version")], collapse = " "), 
[17:40:08.868]                           hostname = base::Sys.info()[["nodename"]])
[17:40:08.868]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:08.868]                           info)
[17:40:08.868]                         info <- base::paste(info, collapse = "; ")
[17:40:08.868]                         if (!has_future) {
[17:40:08.868]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:08.868]                             info)
[17:40:08.868]                         }
[17:40:08.868]                         else {
[17:40:08.868]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:08.868]                             info, version)
[17:40:08.868]                         }
[17:40:08.868]                         base::stop(msg)
[17:40:08.868]                       }
[17:40:08.868]                     })
[17:40:08.868]                   }
[17:40:08.868]                   ...future.strategy.old <- future::plan("list")
[17:40:08.868]                   options(future.plan = NULL)
[17:40:08.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:08.868]                 }
[17:40:08.868]                 ...future.workdir <- getwd()
[17:40:08.868]             }
[17:40:08.868]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:08.868]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:08.868]         }
[17:40:08.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:08.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:08.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:08.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:08.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:08.868]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:08.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:08.868]             base::names(...future.oldOptions))
[17:40:08.868]     }
[17:40:08.868]     if (FALSE) {
[17:40:08.868]     }
[17:40:08.868]     else {
[17:40:08.868]         if (TRUE) {
[17:40:08.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:08.868]                 open = "w")
[17:40:08.868]         }
[17:40:08.868]         else {
[17:40:08.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:08.868]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:08.868]         }
[17:40:08.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:08.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:08.868]             base::sink(type = "output", split = FALSE)
[17:40:08.868]             base::close(...future.stdout)
[17:40:08.868]         }, add = TRUE)
[17:40:08.868]     }
[17:40:08.868]     ...future.frame <- base::sys.nframe()
[17:40:08.868]     ...future.conditions <- base::list()
[17:40:08.868]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:08.868]     if (FALSE) {
[17:40:08.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:08.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:08.868]     }
[17:40:08.868]     ...future.result <- base::tryCatch({
[17:40:08.868]         base::withCallingHandlers({
[17:40:08.868]             ...future.value <- base::withVisible(base::local({
[17:40:08.868]                 stop(structure(list(message = "boom"), class = c("MyError", 
[17:40:08.868]                   "error", "condition")))
[17:40:08.868]             }))
[17:40:08.868]             future::FutureResult(value = ...future.value$value, 
[17:40:08.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.868]                   ...future.rng), globalenv = if (FALSE) 
[17:40:08.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:08.868]                     ...future.globalenv.names))
[17:40:08.868]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:08.868]         }, condition = base::local({
[17:40:08.868]             c <- base::c
[17:40:08.868]             inherits <- base::inherits
[17:40:08.868]             invokeRestart <- base::invokeRestart
[17:40:08.868]             length <- base::length
[17:40:08.868]             list <- base::list
[17:40:08.868]             seq.int <- base::seq.int
[17:40:08.868]             signalCondition <- base::signalCondition
[17:40:08.868]             sys.calls <- base::sys.calls
[17:40:08.868]             `[[` <- base::`[[`
[17:40:08.868]             `+` <- base::`+`
[17:40:08.868]             `<<-` <- base::`<<-`
[17:40:08.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:08.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:08.868]                   3L)]
[17:40:08.868]             }
[17:40:08.868]             function(cond) {
[17:40:08.868]                 is_error <- inherits(cond, "error")
[17:40:08.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:08.868]                   NULL)
[17:40:08.868]                 if (is_error) {
[17:40:08.868]                   sessionInformation <- function() {
[17:40:08.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:08.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:08.868]                       search = base::search(), system = base::Sys.info())
[17:40:08.868]                   }
[17:40:08.868]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:08.868]                     cond$call), session = sessionInformation(), 
[17:40:08.868]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:08.868]                   signalCondition(cond)
[17:40:08.868]                 }
[17:40:08.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:08.868]                 "immediateCondition"))) {
[17:40:08.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:08.868]                   ...future.conditions[[length(...future.conditions) + 
[17:40:08.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:08.868]                   if (TRUE && !signal) {
[17:40:08.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.868]                     {
[17:40:08.868]                       inherits <- base::inherits
[17:40:08.868]                       invokeRestart <- base::invokeRestart
[17:40:08.868]                       is.null <- base::is.null
[17:40:08.868]                       muffled <- FALSE
[17:40:08.868]                       if (inherits(cond, "message")) {
[17:40:08.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.868]                         if (muffled) 
[17:40:08.868]                           invokeRestart("muffleMessage")
[17:40:08.868]                       }
[17:40:08.868]                       else if (inherits(cond, "warning")) {
[17:40:08.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.868]                         if (muffled) 
[17:40:08.868]                           invokeRestart("muffleWarning")
[17:40:08.868]                       }
[17:40:08.868]                       else if (inherits(cond, "condition")) {
[17:40:08.868]                         if (!is.null(pattern)) {
[17:40:08.868]                           computeRestarts <- base::computeRestarts
[17:40:08.868]                           grepl <- base::grepl
[17:40:08.868]                           restarts <- computeRestarts(cond)
[17:40:08.868]                           for (restart in restarts) {
[17:40:08.868]                             name <- restart$name
[17:40:08.868]                             if (is.null(name)) 
[17:40:08.868]                               next
[17:40:08.868]                             if (!grepl(pattern, name)) 
[17:40:08.868]                               next
[17:40:08.868]                             invokeRestart(restart)
[17:40:08.868]                             muffled <- TRUE
[17:40:08.868]                             break
[17:40:08.868]                           }
[17:40:08.868]                         }
[17:40:08.868]                       }
[17:40:08.868]                       invisible(muffled)
[17:40:08.868]                     }
[17:40:08.868]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.868]                   }
[17:40:08.868]                 }
[17:40:08.868]                 else {
[17:40:08.868]                   if (TRUE) {
[17:40:08.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:08.868]                     {
[17:40:08.868]                       inherits <- base::inherits
[17:40:08.868]                       invokeRestart <- base::invokeRestart
[17:40:08.868]                       is.null <- base::is.null
[17:40:08.868]                       muffled <- FALSE
[17:40:08.868]                       if (inherits(cond, "message")) {
[17:40:08.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:08.868]                         if (muffled) 
[17:40:08.868]                           invokeRestart("muffleMessage")
[17:40:08.868]                       }
[17:40:08.868]                       else if (inherits(cond, "warning")) {
[17:40:08.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:08.868]                         if (muffled) 
[17:40:08.868]                           invokeRestart("muffleWarning")
[17:40:08.868]                       }
[17:40:08.868]                       else if (inherits(cond, "condition")) {
[17:40:08.868]                         if (!is.null(pattern)) {
[17:40:08.868]                           computeRestarts <- base::computeRestarts
[17:40:08.868]                           grepl <- base::grepl
[17:40:08.868]                           restarts <- computeRestarts(cond)
[17:40:08.868]                           for (restart in restarts) {
[17:40:08.868]                             name <- restart$name
[17:40:08.868]                             if (is.null(name)) 
[17:40:08.868]                               next
[17:40:08.868]                             if (!grepl(pattern, name)) 
[17:40:08.868]                               next
[17:40:08.868]                             invokeRestart(restart)
[17:40:08.868]                             muffled <- TRUE
[17:40:08.868]                             break
[17:40:08.868]                           }
[17:40:08.868]                         }
[17:40:08.868]                       }
[17:40:08.868]                       invisible(muffled)
[17:40:08.868]                     }
[17:40:08.868]                     muffleCondition(cond, pattern = "^muffle")
[17:40:08.868]                   }
[17:40:08.868]                 }
[17:40:08.868]             }
[17:40:08.868]         }))
[17:40:08.868]     }, error = function(ex) {
[17:40:08.868]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:08.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:08.868]                 ...future.rng), started = ...future.startTime, 
[17:40:08.868]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:08.868]             version = "1.8"), class = "FutureResult")
[17:40:08.868]     }, finally = {
[17:40:08.868]         if (!identical(...future.workdir, getwd())) 
[17:40:08.868]             setwd(...future.workdir)
[17:40:08.868]         {
[17:40:08.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:08.868]                 ...future.oldOptions$nwarnings <- NULL
[17:40:08.868]             }
[17:40:08.868]             base::options(...future.oldOptions)
[17:40:08.868]             if (.Platform$OS.type == "windows") {
[17:40:08.868]                 old_names <- names(...future.oldEnvVars)
[17:40:08.868]                 envs <- base::Sys.getenv()
[17:40:08.868]                 names <- names(envs)
[17:40:08.868]                 common <- intersect(names, old_names)
[17:40:08.868]                 added <- setdiff(names, old_names)
[17:40:08.868]                 removed <- setdiff(old_names, names)
[17:40:08.868]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:08.868]                   envs[common]]
[17:40:08.868]                 NAMES <- toupper(changed)
[17:40:08.868]                 args <- list()
[17:40:08.868]                 for (kk in seq_along(NAMES)) {
[17:40:08.868]                   name <- changed[[kk]]
[17:40:08.868]                   NAME <- NAMES[[kk]]
[17:40:08.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.868]                     next
[17:40:08.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.868]                 }
[17:40:08.868]                 NAMES <- toupper(added)
[17:40:08.868]                 for (kk in seq_along(NAMES)) {
[17:40:08.868]                   name <- added[[kk]]
[17:40:08.868]                   NAME <- NAMES[[kk]]
[17:40:08.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.868]                     next
[17:40:08.868]                   args[[name]] <- ""
[17:40:08.868]                 }
[17:40:08.868]                 NAMES <- toupper(removed)
[17:40:08.868]                 for (kk in seq_along(NAMES)) {
[17:40:08.868]                   name <- removed[[kk]]
[17:40:08.868]                   NAME <- NAMES[[kk]]
[17:40:08.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:08.868]                     next
[17:40:08.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:08.868]                 }
[17:40:08.868]                 if (length(args) > 0) 
[17:40:08.868]                   base::do.call(base::Sys.setenv, args = args)
[17:40:08.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:08.868]             }
[17:40:08.868]             else {
[17:40:08.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:08.868]             }
[17:40:08.868]             {
[17:40:08.868]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:08.868]                   0L) {
[17:40:08.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:08.868]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:08.868]                   base::options(opts)
[17:40:08.868]                 }
[17:40:08.868]                 {
[17:40:08.868]                   {
[17:40:08.868]                     NULL
[17:40:08.868]                     RNGkind("Mersenne-Twister")
[17:40:08.868]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:08.868]                       inherits = FALSE)
[17:40:08.868]                   }
[17:40:08.868]                   options(future.plan = NULL)
[17:40:08.868]                   if (is.na(NA_character_)) 
[17:40:08.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:08.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:08.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:08.868]                     .init = FALSE)
[17:40:08.868]                 }
[17:40:08.868]             }
[17:40:08.868]         }
[17:40:08.868]     })
[17:40:08.868]     if (TRUE) {
[17:40:08.868]         base::sink(type = "output", split = FALSE)
[17:40:08.868]         if (TRUE) {
[17:40:08.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:08.868]         }
[17:40:08.868]         else {
[17:40:08.868]             ...future.result["stdout"] <- base::list(NULL)
[17:40:08.868]         }
[17:40:08.868]         base::close(...future.stdout)
[17:40:08.868]         ...future.stdout <- NULL
[17:40:08.868]     }
[17:40:08.868]     ...future.result$conditions <- ...future.conditions
[17:40:08.868]     ...future.result$finished <- base::Sys.time()
[17:40:08.868]     ...future.result
[17:40:08.868] }
[17:40:08.869] plan(): Setting new future strategy stack:
[17:40:08.869] List of future strategies:
[17:40:08.869] 1. sequential:
[17:40:08.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.869]    - tweaked: FALSE
[17:40:08.869]    - call: NULL
[17:40:08.870] plan(): nbrOfWorkers() = 1
[17:40:08.871] plan(): Setting new future strategy stack:
[17:40:08.871] List of future strategies:
[17:40:08.871] 1. sequential:
[17:40:08.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:08.871]    - tweaked: FALSE
[17:40:08.871]    - call: future::plan("sequential")
[17:40:08.871] plan(): nbrOfWorkers() = 1
[17:40:08.871] SequentialFuture started (and completed)
[17:40:08.871] signalConditions() ...
[17:40:08.871]  - include = ‘immediateCondition’
[17:40:08.872]  - exclude = 
[17:40:08.872]  - resignal = FALSE
[17:40:08.872]  - Number of conditions: 1
[17:40:08.872] signalConditions() ... done
[17:40:08.872] signalConditions() ...
[17:40:08.872]  - include = ‘immediateCondition’
[17:40:08.872]  - exclude = 
[17:40:08.872]  - resignal = FALSE
[17:40:08.872]  - Number of conditions: 1
[17:40:08.872] signalConditions() ... done
<MyError: boom>
[17:40:08.873] signalConditions() ...
[17:40:08.873]  - include = ‘immediateCondition’
[17:40:08.873]  - exclude = 
[17:40:08.873]  - resignal = FALSE
[17:40:08.873]  - Number of conditions: 1
[17:40:08.873] signalConditions() ... done
[17:40:08.873] Future state: ‘finished’
[17:40:08.873] signalConditions() ...
[17:40:08.873]  - include = ‘condition’
[17:40:08.873]  - exclude = ‘immediateCondition’
[17:40:08.874]  - resignal = TRUE
[17:40:08.874]  - Number of conditions: 1
[17:40:08.874]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[17:40:08.874] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[17:40:08.879] getGlobalsAndPackages() ...
[17:40:08.879] 
[17:40:08.879] - globals: [0] <none>
[17:40:08.879] getGlobalsAndPackages() ... DONE
[17:40:08.879] [local output] makeClusterPSOCK() ...
[17:40:08.913] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:08.915] [local output] Base port: 11164
[17:40:08.915] [local output] Getting setup options for 2 cluster nodes ...
[17:40:08.915] [local output]  - Node 1 of 2 ...
[17:40:08.915] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:08.916] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b249345d2ca.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b249345d2ca.pid")'’
[17:40:09.103] - Possible to infer worker's PID: TRUE
[17:40:09.103] [local output] Rscript port: 11164

[17:40:09.104] [local output]  - Node 2 of 2 ...
[17:40:09.104] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:09.105] [local output] Rscript port: 11164

[17:40:09.105] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:09.105] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:09.105] [local output] Setting up PSOCK nodes in parallel
[17:40:09.106] List of 36
[17:40:09.106]  $ worker          : chr "localhost"
[17:40:09.106]   ..- attr(*, "localhost")= logi TRUE
[17:40:09.106]  $ master          : chr "localhost"
[17:40:09.106]  $ port            : int 11164
[17:40:09.106]  $ connectTimeout  : num 120
[17:40:09.106]  $ timeout         : num 2592000
[17:40:09.106]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:09.106]  $ homogeneous     : logi TRUE
[17:40:09.106]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:09.106]  $ rscript_envs    : NULL
[17:40:09.106]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:09.106]  $ rscript_startup : NULL
[17:40:09.106]  $ rscript_sh      : chr "sh"
[17:40:09.106]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:09.106]  $ methods         : logi TRUE
[17:40:09.106]  $ socketOptions   : chr "no-delay"
[17:40:09.106]  $ useXDR          : logi FALSE
[17:40:09.106]  $ outfile         : chr "/dev/null"
[17:40:09.106]  $ renice          : int NA
[17:40:09.106]  $ rshcmd          : NULL
[17:40:09.106]  $ user            : chr(0) 
[17:40:09.106]  $ revtunnel       : logi FALSE
[17:40:09.106]  $ rshlogfile      : NULL
[17:40:09.106]  $ rshopts         : chr(0) 
[17:40:09.106]  $ rank            : int 1
[17:40:09.106]  $ manual          : logi FALSE
[17:40:09.106]  $ dryrun          : logi FALSE
[17:40:09.106]  $ quiet           : logi FALSE
[17:40:09.106]  $ setup_strategy  : chr "parallel"
[17:40:09.106]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:09.106]  $ pidfile         : chr "/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b249345d2ca.pid"
[17:40:09.106]  $ rshcmd_label    : NULL
[17:40:09.106]  $ rsh_call        : NULL
[17:40:09.106]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:09.106]  $ localMachine    : logi TRUE
[17:40:09.106]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:09.106]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:09.106]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:09.106]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:09.106]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:09.106]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:09.106]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:09.106]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:09.106]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:09.106]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:09.106]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:09.106]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:09.106]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:09.106]  $ arguments       :List of 28
[17:40:09.106]   ..$ worker          : chr "localhost"
[17:40:09.106]   ..$ master          : NULL
[17:40:09.106]   ..$ port            : int 11164
[17:40:09.106]   ..$ connectTimeout  : num 120
[17:40:09.106]   ..$ timeout         : num 2592000
[17:40:09.106]   ..$ rscript         : NULL
[17:40:09.106]   ..$ homogeneous     : NULL
[17:40:09.106]   ..$ rscript_args    : NULL
[17:40:09.106]   ..$ rscript_envs    : NULL
[17:40:09.106]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:09.106]   ..$ rscript_startup : NULL
[17:40:09.106]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:09.106]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:09.106]   ..$ methods         : logi TRUE
[17:40:09.106]   ..$ socketOptions   : chr "no-delay"
[17:40:09.106]   ..$ useXDR          : logi FALSE
[17:40:09.106]   ..$ outfile         : chr "/dev/null"
[17:40:09.106]   ..$ renice          : int NA
[17:40:09.106]   ..$ rshcmd          : NULL
[17:40:09.106]   ..$ user            : NULL
[17:40:09.106]   ..$ revtunnel       : logi NA
[17:40:09.106]   ..$ rshlogfile      : NULL
[17:40:09.106]   ..$ rshopts         : NULL
[17:40:09.106]   ..$ rank            : int 1
[17:40:09.106]   ..$ manual          : logi FALSE
[17:40:09.106]   ..$ dryrun          : logi FALSE
[17:40:09.106]   ..$ quiet           : logi FALSE
[17:40:09.106]   ..$ setup_strategy  : chr "parallel"
[17:40:09.106]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:09.121] [local output] System call to launch all workers:
[17:40:09.122] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b249345d2ca.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11164 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:09.122] [local output] Starting PSOCK main server
[17:40:09.127] [local output] Workers launched
[17:40:09.127] [local output] Waiting for workers to connect back
[17:40:09.128]  - [local output] 0 workers out of 2 ready
[17:40:09.373]  - [local output] 0 workers out of 2 ready
[17:40:09.373]  - [local output] 1 workers out of 2 ready
[17:40:09.374]  - [local output] 1 workers out of 2 ready
[17:40:09.374]  - [local output] 2 workers out of 2 ready
[17:40:09.374] [local output] Launching of workers completed
[17:40:09.375] [local output] Collecting session information from workers
[17:40:09.375] [local output]  - Worker #1 of 2
[17:40:09.376] [local output]  - Worker #2 of 2
[17:40:09.376] [local output] makeClusterPSOCK() ... done
[17:40:09.388] Packages needed by the future expression (n = 0): <none>
[17:40:09.388] Packages needed by future strategies (n = 0): <none>
[17:40:09.389] {
[17:40:09.389]     {
[17:40:09.389]         {
[17:40:09.389]             ...future.startTime <- base::Sys.time()
[17:40:09.389]             {
[17:40:09.389]                 {
[17:40:09.389]                   {
[17:40:09.389]                     {
[17:40:09.389]                       base::local({
[17:40:09.389]                         has_future <- base::requireNamespace("future", 
[17:40:09.389]                           quietly = TRUE)
[17:40:09.389]                         if (has_future) {
[17:40:09.389]                           ns <- base::getNamespace("future")
[17:40:09.389]                           version <- ns[[".package"]][["version"]]
[17:40:09.389]                           if (is.null(version)) 
[17:40:09.389]                             version <- utils::packageVersion("future")
[17:40:09.389]                         }
[17:40:09.389]                         else {
[17:40:09.389]                           version <- NULL
[17:40:09.389]                         }
[17:40:09.389]                         if (!has_future || version < "1.8.0") {
[17:40:09.389]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.389]                             "", base::R.version$version.string), 
[17:40:09.389]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.389]                               "release", "version")], collapse = " "), 
[17:40:09.389]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.389]                             info)
[17:40:09.389]                           info <- base::paste(info, collapse = "; ")
[17:40:09.389]                           if (!has_future) {
[17:40:09.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.389]                               info)
[17:40:09.389]                           }
[17:40:09.389]                           else {
[17:40:09.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.389]                               info, version)
[17:40:09.389]                           }
[17:40:09.389]                           base::stop(msg)
[17:40:09.389]                         }
[17:40:09.389]                       })
[17:40:09.389]                     }
[17:40:09.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.389]                     base::options(mc.cores = 1L)
[17:40:09.389]                   }
[17:40:09.389]                   ...future.strategy.old <- future::plan("list")
[17:40:09.389]                   options(future.plan = NULL)
[17:40:09.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.389]                 }
[17:40:09.389]                 ...future.workdir <- getwd()
[17:40:09.389]             }
[17:40:09.389]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.389]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.389]         }
[17:40:09.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.389]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.389]             base::names(...future.oldOptions))
[17:40:09.389]     }
[17:40:09.389]     if (FALSE) {
[17:40:09.389]     }
[17:40:09.389]     else {
[17:40:09.389]         if (TRUE) {
[17:40:09.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.389]                 open = "w")
[17:40:09.389]         }
[17:40:09.389]         else {
[17:40:09.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.389]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.389]         }
[17:40:09.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.389]             base::sink(type = "output", split = FALSE)
[17:40:09.389]             base::close(...future.stdout)
[17:40:09.389]         }, add = TRUE)
[17:40:09.389]     }
[17:40:09.389]     ...future.frame <- base::sys.nframe()
[17:40:09.389]     ...future.conditions <- base::list()
[17:40:09.389]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.389]     if (FALSE) {
[17:40:09.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.389]     }
[17:40:09.389]     ...future.result <- base::tryCatch({
[17:40:09.389]         base::withCallingHandlers({
[17:40:09.389]             ...future.value <- base::withVisible(base::local({
[17:40:09.389]                 ...future.makeSendCondition <- base::local({
[17:40:09.389]                   sendCondition <- NULL
[17:40:09.389]                   function(frame = 1L) {
[17:40:09.389]                     if (is.function(sendCondition)) 
[17:40:09.389]                       return(sendCondition)
[17:40:09.389]                     ns <- getNamespace("parallel")
[17:40:09.389]                     if (exists("sendData", mode = "function", 
[17:40:09.389]                       envir = ns)) {
[17:40:09.389]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.389]                         envir = ns)
[17:40:09.389]                       envir <- sys.frame(frame)
[17:40:09.389]                       master <- NULL
[17:40:09.389]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.389]                         !identical(envir, emptyenv())) {
[17:40:09.389]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.389]                           inherits = FALSE)) {
[17:40:09.389]                           master <- get("master", mode = "list", 
[17:40:09.389]                             envir = envir, inherits = FALSE)
[17:40:09.389]                           if (inherits(master, c("SOCKnode", 
[17:40:09.389]                             "SOCK0node"))) {
[17:40:09.389]                             sendCondition <<- function(cond) {
[17:40:09.389]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.389]                                 success = TRUE)
[17:40:09.389]                               parallel_sendData(master, data)
[17:40:09.389]                             }
[17:40:09.389]                             return(sendCondition)
[17:40:09.389]                           }
[17:40:09.389]                         }
[17:40:09.389]                         frame <- frame + 1L
[17:40:09.389]                         envir <- sys.frame(frame)
[17:40:09.389]                       }
[17:40:09.389]                     }
[17:40:09.389]                     sendCondition <<- function(cond) NULL
[17:40:09.389]                   }
[17:40:09.389]                 })
[17:40:09.389]                 withCallingHandlers({
[17:40:09.389]                   {
[17:40:09.389]                     42L
[17:40:09.389]                   }
[17:40:09.389]                 }, immediateCondition = function(cond) {
[17:40:09.389]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.389]                   sendCondition(cond)
[17:40:09.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.389]                   {
[17:40:09.389]                     inherits <- base::inherits
[17:40:09.389]                     invokeRestart <- base::invokeRestart
[17:40:09.389]                     is.null <- base::is.null
[17:40:09.389]                     muffled <- FALSE
[17:40:09.389]                     if (inherits(cond, "message")) {
[17:40:09.389]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.389]                       if (muffled) 
[17:40:09.389]                         invokeRestart("muffleMessage")
[17:40:09.389]                     }
[17:40:09.389]                     else if (inherits(cond, "warning")) {
[17:40:09.389]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.389]                       if (muffled) 
[17:40:09.389]                         invokeRestart("muffleWarning")
[17:40:09.389]                     }
[17:40:09.389]                     else if (inherits(cond, "condition")) {
[17:40:09.389]                       if (!is.null(pattern)) {
[17:40:09.389]                         computeRestarts <- base::computeRestarts
[17:40:09.389]                         grepl <- base::grepl
[17:40:09.389]                         restarts <- computeRestarts(cond)
[17:40:09.389]                         for (restart in restarts) {
[17:40:09.389]                           name <- restart$name
[17:40:09.389]                           if (is.null(name)) 
[17:40:09.389]                             next
[17:40:09.389]                           if (!grepl(pattern, name)) 
[17:40:09.389]                             next
[17:40:09.389]                           invokeRestart(restart)
[17:40:09.389]                           muffled <- TRUE
[17:40:09.389]                           break
[17:40:09.389]                         }
[17:40:09.389]                       }
[17:40:09.389]                     }
[17:40:09.389]                     invisible(muffled)
[17:40:09.389]                   }
[17:40:09.389]                   muffleCondition(cond)
[17:40:09.389]                 })
[17:40:09.389]             }))
[17:40:09.389]             future::FutureResult(value = ...future.value$value, 
[17:40:09.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.389]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.389]                     ...future.globalenv.names))
[17:40:09.389]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.389]         }, condition = base::local({
[17:40:09.389]             c <- base::c
[17:40:09.389]             inherits <- base::inherits
[17:40:09.389]             invokeRestart <- base::invokeRestart
[17:40:09.389]             length <- base::length
[17:40:09.389]             list <- base::list
[17:40:09.389]             seq.int <- base::seq.int
[17:40:09.389]             signalCondition <- base::signalCondition
[17:40:09.389]             sys.calls <- base::sys.calls
[17:40:09.389]             `[[` <- base::`[[`
[17:40:09.389]             `+` <- base::`+`
[17:40:09.389]             `<<-` <- base::`<<-`
[17:40:09.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.389]                   3L)]
[17:40:09.389]             }
[17:40:09.389]             function(cond) {
[17:40:09.389]                 is_error <- inherits(cond, "error")
[17:40:09.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.389]                   NULL)
[17:40:09.389]                 if (is_error) {
[17:40:09.389]                   sessionInformation <- function() {
[17:40:09.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.389]                       search = base::search(), system = base::Sys.info())
[17:40:09.389]                   }
[17:40:09.389]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.389]                     cond$call), session = sessionInformation(), 
[17:40:09.389]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.389]                   signalCondition(cond)
[17:40:09.389]                 }
[17:40:09.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.389]                 "immediateCondition"))) {
[17:40:09.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.389]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.389]                   if (TRUE && !signal) {
[17:40:09.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.389]                     {
[17:40:09.389]                       inherits <- base::inherits
[17:40:09.389]                       invokeRestart <- base::invokeRestart
[17:40:09.389]                       is.null <- base::is.null
[17:40:09.389]                       muffled <- FALSE
[17:40:09.389]                       if (inherits(cond, "message")) {
[17:40:09.389]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.389]                         if (muffled) 
[17:40:09.389]                           invokeRestart("muffleMessage")
[17:40:09.389]                       }
[17:40:09.389]                       else if (inherits(cond, "warning")) {
[17:40:09.389]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.389]                         if (muffled) 
[17:40:09.389]                           invokeRestart("muffleWarning")
[17:40:09.389]                       }
[17:40:09.389]                       else if (inherits(cond, "condition")) {
[17:40:09.389]                         if (!is.null(pattern)) {
[17:40:09.389]                           computeRestarts <- base::computeRestarts
[17:40:09.389]                           grepl <- base::grepl
[17:40:09.389]                           restarts <- computeRestarts(cond)
[17:40:09.389]                           for (restart in restarts) {
[17:40:09.389]                             name <- restart$name
[17:40:09.389]                             if (is.null(name)) 
[17:40:09.389]                               next
[17:40:09.389]                             if (!grepl(pattern, name)) 
[17:40:09.389]                               next
[17:40:09.389]                             invokeRestart(restart)
[17:40:09.389]                             muffled <- TRUE
[17:40:09.389]                             break
[17:40:09.389]                           }
[17:40:09.389]                         }
[17:40:09.389]                       }
[17:40:09.389]                       invisible(muffled)
[17:40:09.389]                     }
[17:40:09.389]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.389]                   }
[17:40:09.389]                 }
[17:40:09.389]                 else {
[17:40:09.389]                   if (TRUE) {
[17:40:09.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.389]                     {
[17:40:09.389]                       inherits <- base::inherits
[17:40:09.389]                       invokeRestart <- base::invokeRestart
[17:40:09.389]                       is.null <- base::is.null
[17:40:09.389]                       muffled <- FALSE
[17:40:09.389]                       if (inherits(cond, "message")) {
[17:40:09.389]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.389]                         if (muffled) 
[17:40:09.389]                           invokeRestart("muffleMessage")
[17:40:09.389]                       }
[17:40:09.389]                       else if (inherits(cond, "warning")) {
[17:40:09.389]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.389]                         if (muffled) 
[17:40:09.389]                           invokeRestart("muffleWarning")
[17:40:09.389]                       }
[17:40:09.389]                       else if (inherits(cond, "condition")) {
[17:40:09.389]                         if (!is.null(pattern)) {
[17:40:09.389]                           computeRestarts <- base::computeRestarts
[17:40:09.389]                           grepl <- base::grepl
[17:40:09.389]                           restarts <- computeRestarts(cond)
[17:40:09.389]                           for (restart in restarts) {
[17:40:09.389]                             name <- restart$name
[17:40:09.389]                             if (is.null(name)) 
[17:40:09.389]                               next
[17:40:09.389]                             if (!grepl(pattern, name)) 
[17:40:09.389]                               next
[17:40:09.389]                             invokeRestart(restart)
[17:40:09.389]                             muffled <- TRUE
[17:40:09.389]                             break
[17:40:09.389]                           }
[17:40:09.389]                         }
[17:40:09.389]                       }
[17:40:09.389]                       invisible(muffled)
[17:40:09.389]                     }
[17:40:09.389]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.389]                   }
[17:40:09.389]                 }
[17:40:09.389]             }
[17:40:09.389]         }))
[17:40:09.389]     }, error = function(ex) {
[17:40:09.389]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.389]                 ...future.rng), started = ...future.startTime, 
[17:40:09.389]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.389]             version = "1.8"), class = "FutureResult")
[17:40:09.389]     }, finally = {
[17:40:09.389]         if (!identical(...future.workdir, getwd())) 
[17:40:09.389]             setwd(...future.workdir)
[17:40:09.389]         {
[17:40:09.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.389]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.389]             }
[17:40:09.389]             base::options(...future.oldOptions)
[17:40:09.389]             if (.Platform$OS.type == "windows") {
[17:40:09.389]                 old_names <- names(...future.oldEnvVars)
[17:40:09.389]                 envs <- base::Sys.getenv()
[17:40:09.389]                 names <- names(envs)
[17:40:09.389]                 common <- intersect(names, old_names)
[17:40:09.389]                 added <- setdiff(names, old_names)
[17:40:09.389]                 removed <- setdiff(old_names, names)
[17:40:09.389]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.389]                   envs[common]]
[17:40:09.389]                 NAMES <- toupper(changed)
[17:40:09.389]                 args <- list()
[17:40:09.389]                 for (kk in seq_along(NAMES)) {
[17:40:09.389]                   name <- changed[[kk]]
[17:40:09.389]                   NAME <- NAMES[[kk]]
[17:40:09.389]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.389]                     next
[17:40:09.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.389]                 }
[17:40:09.389]                 NAMES <- toupper(added)
[17:40:09.389]                 for (kk in seq_along(NAMES)) {
[17:40:09.389]                   name <- added[[kk]]
[17:40:09.389]                   NAME <- NAMES[[kk]]
[17:40:09.389]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.389]                     next
[17:40:09.389]                   args[[name]] <- ""
[17:40:09.389]                 }
[17:40:09.389]                 NAMES <- toupper(removed)
[17:40:09.389]                 for (kk in seq_along(NAMES)) {
[17:40:09.389]                   name <- removed[[kk]]
[17:40:09.389]                   NAME <- NAMES[[kk]]
[17:40:09.389]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.389]                     next
[17:40:09.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.389]                 }
[17:40:09.389]                 if (length(args) > 0) 
[17:40:09.389]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.389]             }
[17:40:09.389]             else {
[17:40:09.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.389]             }
[17:40:09.389]             {
[17:40:09.389]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.389]                   0L) {
[17:40:09.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.389]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.389]                   base::options(opts)
[17:40:09.389]                 }
[17:40:09.389]                 {
[17:40:09.389]                   {
[17:40:09.389]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.389]                     NULL
[17:40:09.389]                   }
[17:40:09.389]                   options(future.plan = NULL)
[17:40:09.389]                   if (is.na(NA_character_)) 
[17:40:09.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.389]                     .init = FALSE)
[17:40:09.389]                 }
[17:40:09.389]             }
[17:40:09.389]         }
[17:40:09.389]     })
[17:40:09.389]     if (TRUE) {
[17:40:09.389]         base::sink(type = "output", split = FALSE)
[17:40:09.389]         if (TRUE) {
[17:40:09.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.389]         }
[17:40:09.389]         else {
[17:40:09.389]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.389]         }
[17:40:09.389]         base::close(...future.stdout)
[17:40:09.389]         ...future.stdout <- NULL
[17:40:09.389]     }
[17:40:09.389]     ...future.result$conditions <- ...future.conditions
[17:40:09.389]     ...future.result$finished <- base::Sys.time()
[17:40:09.389]     ...future.result
[17:40:09.389] }
[17:40:09.441] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[17:40:09.464] result() for ClusterFuture ...
[17:40:09.465] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.465] - Validating connection of MultisessionFuture
[17:40:09.475] - received message: FutureResult
[17:40:09.475] - Received FutureResult
[17:40:09.478] - Erased future from FutureRegistry
[17:40:09.478] result() for ClusterFuture ...
[17:40:09.478] - result already collected: FutureResult
[17:40:09.478] result() for ClusterFuture ... done
[17:40:09.479] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:09.479] result() for ClusterFuture ... done
[17:40:09.479] result() for ClusterFuture ...
[17:40:09.479] - result already collected: FutureResult
[17:40:09.479] result() for ClusterFuture ... done
[1] 42
[17:40:09.483] getGlobalsAndPackages() ...
[17:40:09.483] Searching for globals...
[17:40:09.486] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[17:40:09.486] Searching for globals ... DONE
[17:40:09.486] Resolving globals: FALSE
[17:40:09.487] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:09.487] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:40:09.487] - globals: [1] ‘a’
[17:40:09.487] 
[17:40:09.488] getGlobalsAndPackages() ... DONE
[17:40:09.499] Packages needed by the future expression (n = 0): <none>
[17:40:09.499] Packages needed by future strategies (n = 0): <none>
[17:40:09.499] {
[17:40:09.499]     {
[17:40:09.499]         {
[17:40:09.499]             ...future.startTime <- base::Sys.time()
[17:40:09.499]             {
[17:40:09.499]                 {
[17:40:09.499]                   {
[17:40:09.499]                     {
[17:40:09.499]                       base::local({
[17:40:09.499]                         has_future <- base::requireNamespace("future", 
[17:40:09.499]                           quietly = TRUE)
[17:40:09.499]                         if (has_future) {
[17:40:09.499]                           ns <- base::getNamespace("future")
[17:40:09.499]                           version <- ns[[".package"]][["version"]]
[17:40:09.499]                           if (is.null(version)) 
[17:40:09.499]                             version <- utils::packageVersion("future")
[17:40:09.499]                         }
[17:40:09.499]                         else {
[17:40:09.499]                           version <- NULL
[17:40:09.499]                         }
[17:40:09.499]                         if (!has_future || version < "1.8.0") {
[17:40:09.499]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.499]                             "", base::R.version$version.string), 
[17:40:09.499]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.499]                               "release", "version")], collapse = " "), 
[17:40:09.499]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.499]                             info)
[17:40:09.499]                           info <- base::paste(info, collapse = "; ")
[17:40:09.499]                           if (!has_future) {
[17:40:09.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.499]                               info)
[17:40:09.499]                           }
[17:40:09.499]                           else {
[17:40:09.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.499]                               info, version)
[17:40:09.499]                           }
[17:40:09.499]                           base::stop(msg)
[17:40:09.499]                         }
[17:40:09.499]                       })
[17:40:09.499]                     }
[17:40:09.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.499]                     base::options(mc.cores = 1L)
[17:40:09.499]                   }
[17:40:09.499]                   ...future.strategy.old <- future::plan("list")
[17:40:09.499]                   options(future.plan = NULL)
[17:40:09.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.499]                 }
[17:40:09.499]                 ...future.workdir <- getwd()
[17:40:09.499]             }
[17:40:09.499]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.499]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.499]         }
[17:40:09.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.499]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.499]             base::names(...future.oldOptions))
[17:40:09.499]     }
[17:40:09.499]     if (FALSE) {
[17:40:09.499]     }
[17:40:09.499]     else {
[17:40:09.499]         if (TRUE) {
[17:40:09.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.499]                 open = "w")
[17:40:09.499]         }
[17:40:09.499]         else {
[17:40:09.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.499]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.499]         }
[17:40:09.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.499]             base::sink(type = "output", split = FALSE)
[17:40:09.499]             base::close(...future.stdout)
[17:40:09.499]         }, add = TRUE)
[17:40:09.499]     }
[17:40:09.499]     ...future.frame <- base::sys.nframe()
[17:40:09.499]     ...future.conditions <- base::list()
[17:40:09.499]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.499]     if (FALSE) {
[17:40:09.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.499]     }
[17:40:09.499]     ...future.result <- base::tryCatch({
[17:40:09.499]         base::withCallingHandlers({
[17:40:09.499]             ...future.value <- base::withVisible(base::local({
[17:40:09.499]                 ...future.makeSendCondition <- base::local({
[17:40:09.499]                   sendCondition <- NULL
[17:40:09.499]                   function(frame = 1L) {
[17:40:09.499]                     if (is.function(sendCondition)) 
[17:40:09.499]                       return(sendCondition)
[17:40:09.499]                     ns <- getNamespace("parallel")
[17:40:09.499]                     if (exists("sendData", mode = "function", 
[17:40:09.499]                       envir = ns)) {
[17:40:09.499]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.499]                         envir = ns)
[17:40:09.499]                       envir <- sys.frame(frame)
[17:40:09.499]                       master <- NULL
[17:40:09.499]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.499]                         !identical(envir, emptyenv())) {
[17:40:09.499]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.499]                           inherits = FALSE)) {
[17:40:09.499]                           master <- get("master", mode = "list", 
[17:40:09.499]                             envir = envir, inherits = FALSE)
[17:40:09.499]                           if (inherits(master, c("SOCKnode", 
[17:40:09.499]                             "SOCK0node"))) {
[17:40:09.499]                             sendCondition <<- function(cond) {
[17:40:09.499]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.499]                                 success = TRUE)
[17:40:09.499]                               parallel_sendData(master, data)
[17:40:09.499]                             }
[17:40:09.499]                             return(sendCondition)
[17:40:09.499]                           }
[17:40:09.499]                         }
[17:40:09.499]                         frame <- frame + 1L
[17:40:09.499]                         envir <- sys.frame(frame)
[17:40:09.499]                       }
[17:40:09.499]                     }
[17:40:09.499]                     sendCondition <<- function(cond) NULL
[17:40:09.499]                   }
[17:40:09.499]                 })
[17:40:09.499]                 withCallingHandlers({
[17:40:09.499]                   {
[17:40:09.499]                     b <- 3
[17:40:09.499]                     c <- 2
[17:40:09.499]                     a * b * c
[17:40:09.499]                   }
[17:40:09.499]                 }, immediateCondition = function(cond) {
[17:40:09.499]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.499]                   sendCondition(cond)
[17:40:09.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.499]                   {
[17:40:09.499]                     inherits <- base::inherits
[17:40:09.499]                     invokeRestart <- base::invokeRestart
[17:40:09.499]                     is.null <- base::is.null
[17:40:09.499]                     muffled <- FALSE
[17:40:09.499]                     if (inherits(cond, "message")) {
[17:40:09.499]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.499]                       if (muffled) 
[17:40:09.499]                         invokeRestart("muffleMessage")
[17:40:09.499]                     }
[17:40:09.499]                     else if (inherits(cond, "warning")) {
[17:40:09.499]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.499]                       if (muffled) 
[17:40:09.499]                         invokeRestart("muffleWarning")
[17:40:09.499]                     }
[17:40:09.499]                     else if (inherits(cond, "condition")) {
[17:40:09.499]                       if (!is.null(pattern)) {
[17:40:09.499]                         computeRestarts <- base::computeRestarts
[17:40:09.499]                         grepl <- base::grepl
[17:40:09.499]                         restarts <- computeRestarts(cond)
[17:40:09.499]                         for (restart in restarts) {
[17:40:09.499]                           name <- restart$name
[17:40:09.499]                           if (is.null(name)) 
[17:40:09.499]                             next
[17:40:09.499]                           if (!grepl(pattern, name)) 
[17:40:09.499]                             next
[17:40:09.499]                           invokeRestart(restart)
[17:40:09.499]                           muffled <- TRUE
[17:40:09.499]                           break
[17:40:09.499]                         }
[17:40:09.499]                       }
[17:40:09.499]                     }
[17:40:09.499]                     invisible(muffled)
[17:40:09.499]                   }
[17:40:09.499]                   muffleCondition(cond)
[17:40:09.499]                 })
[17:40:09.499]             }))
[17:40:09.499]             future::FutureResult(value = ...future.value$value, 
[17:40:09.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.499]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.499]                     ...future.globalenv.names))
[17:40:09.499]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.499]         }, condition = base::local({
[17:40:09.499]             c <- base::c
[17:40:09.499]             inherits <- base::inherits
[17:40:09.499]             invokeRestart <- base::invokeRestart
[17:40:09.499]             length <- base::length
[17:40:09.499]             list <- base::list
[17:40:09.499]             seq.int <- base::seq.int
[17:40:09.499]             signalCondition <- base::signalCondition
[17:40:09.499]             sys.calls <- base::sys.calls
[17:40:09.499]             `[[` <- base::`[[`
[17:40:09.499]             `+` <- base::`+`
[17:40:09.499]             `<<-` <- base::`<<-`
[17:40:09.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.499]                   3L)]
[17:40:09.499]             }
[17:40:09.499]             function(cond) {
[17:40:09.499]                 is_error <- inherits(cond, "error")
[17:40:09.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.499]                   NULL)
[17:40:09.499]                 if (is_error) {
[17:40:09.499]                   sessionInformation <- function() {
[17:40:09.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.499]                       search = base::search(), system = base::Sys.info())
[17:40:09.499]                   }
[17:40:09.499]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.499]                     cond$call), session = sessionInformation(), 
[17:40:09.499]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.499]                   signalCondition(cond)
[17:40:09.499]                 }
[17:40:09.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.499]                 "immediateCondition"))) {
[17:40:09.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.499]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.499]                   if (TRUE && !signal) {
[17:40:09.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.499]                     {
[17:40:09.499]                       inherits <- base::inherits
[17:40:09.499]                       invokeRestart <- base::invokeRestart
[17:40:09.499]                       is.null <- base::is.null
[17:40:09.499]                       muffled <- FALSE
[17:40:09.499]                       if (inherits(cond, "message")) {
[17:40:09.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.499]                         if (muffled) 
[17:40:09.499]                           invokeRestart("muffleMessage")
[17:40:09.499]                       }
[17:40:09.499]                       else if (inherits(cond, "warning")) {
[17:40:09.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.499]                         if (muffled) 
[17:40:09.499]                           invokeRestart("muffleWarning")
[17:40:09.499]                       }
[17:40:09.499]                       else if (inherits(cond, "condition")) {
[17:40:09.499]                         if (!is.null(pattern)) {
[17:40:09.499]                           computeRestarts <- base::computeRestarts
[17:40:09.499]                           grepl <- base::grepl
[17:40:09.499]                           restarts <- computeRestarts(cond)
[17:40:09.499]                           for (restart in restarts) {
[17:40:09.499]                             name <- restart$name
[17:40:09.499]                             if (is.null(name)) 
[17:40:09.499]                               next
[17:40:09.499]                             if (!grepl(pattern, name)) 
[17:40:09.499]                               next
[17:40:09.499]                             invokeRestart(restart)
[17:40:09.499]                             muffled <- TRUE
[17:40:09.499]                             break
[17:40:09.499]                           }
[17:40:09.499]                         }
[17:40:09.499]                       }
[17:40:09.499]                       invisible(muffled)
[17:40:09.499]                     }
[17:40:09.499]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.499]                   }
[17:40:09.499]                 }
[17:40:09.499]                 else {
[17:40:09.499]                   if (TRUE) {
[17:40:09.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.499]                     {
[17:40:09.499]                       inherits <- base::inherits
[17:40:09.499]                       invokeRestart <- base::invokeRestart
[17:40:09.499]                       is.null <- base::is.null
[17:40:09.499]                       muffled <- FALSE
[17:40:09.499]                       if (inherits(cond, "message")) {
[17:40:09.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.499]                         if (muffled) 
[17:40:09.499]                           invokeRestart("muffleMessage")
[17:40:09.499]                       }
[17:40:09.499]                       else if (inherits(cond, "warning")) {
[17:40:09.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.499]                         if (muffled) 
[17:40:09.499]                           invokeRestart("muffleWarning")
[17:40:09.499]                       }
[17:40:09.499]                       else if (inherits(cond, "condition")) {
[17:40:09.499]                         if (!is.null(pattern)) {
[17:40:09.499]                           computeRestarts <- base::computeRestarts
[17:40:09.499]                           grepl <- base::grepl
[17:40:09.499]                           restarts <- computeRestarts(cond)
[17:40:09.499]                           for (restart in restarts) {
[17:40:09.499]                             name <- restart$name
[17:40:09.499]                             if (is.null(name)) 
[17:40:09.499]                               next
[17:40:09.499]                             if (!grepl(pattern, name)) 
[17:40:09.499]                               next
[17:40:09.499]                             invokeRestart(restart)
[17:40:09.499]                             muffled <- TRUE
[17:40:09.499]                             break
[17:40:09.499]                           }
[17:40:09.499]                         }
[17:40:09.499]                       }
[17:40:09.499]                       invisible(muffled)
[17:40:09.499]                     }
[17:40:09.499]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.499]                   }
[17:40:09.499]                 }
[17:40:09.499]             }
[17:40:09.499]         }))
[17:40:09.499]     }, error = function(ex) {
[17:40:09.499]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.499]                 ...future.rng), started = ...future.startTime, 
[17:40:09.499]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.499]             version = "1.8"), class = "FutureResult")
[17:40:09.499]     }, finally = {
[17:40:09.499]         if (!identical(...future.workdir, getwd())) 
[17:40:09.499]             setwd(...future.workdir)
[17:40:09.499]         {
[17:40:09.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.499]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.499]             }
[17:40:09.499]             base::options(...future.oldOptions)
[17:40:09.499]             if (.Platform$OS.type == "windows") {
[17:40:09.499]                 old_names <- names(...future.oldEnvVars)
[17:40:09.499]                 envs <- base::Sys.getenv()
[17:40:09.499]                 names <- names(envs)
[17:40:09.499]                 common <- intersect(names, old_names)
[17:40:09.499]                 added <- setdiff(names, old_names)
[17:40:09.499]                 removed <- setdiff(old_names, names)
[17:40:09.499]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.499]                   envs[common]]
[17:40:09.499]                 NAMES <- toupper(changed)
[17:40:09.499]                 args <- list()
[17:40:09.499]                 for (kk in seq_along(NAMES)) {
[17:40:09.499]                   name <- changed[[kk]]
[17:40:09.499]                   NAME <- NAMES[[kk]]
[17:40:09.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.499]                     next
[17:40:09.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.499]                 }
[17:40:09.499]                 NAMES <- toupper(added)
[17:40:09.499]                 for (kk in seq_along(NAMES)) {
[17:40:09.499]                   name <- added[[kk]]
[17:40:09.499]                   NAME <- NAMES[[kk]]
[17:40:09.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.499]                     next
[17:40:09.499]                   args[[name]] <- ""
[17:40:09.499]                 }
[17:40:09.499]                 NAMES <- toupper(removed)
[17:40:09.499]                 for (kk in seq_along(NAMES)) {
[17:40:09.499]                   name <- removed[[kk]]
[17:40:09.499]                   NAME <- NAMES[[kk]]
[17:40:09.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.499]                     next
[17:40:09.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.499]                 }
[17:40:09.499]                 if (length(args) > 0) 
[17:40:09.499]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.499]             }
[17:40:09.499]             else {
[17:40:09.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.499]             }
[17:40:09.499]             {
[17:40:09.499]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.499]                   0L) {
[17:40:09.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.499]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.499]                   base::options(opts)
[17:40:09.499]                 }
[17:40:09.499]                 {
[17:40:09.499]                   {
[17:40:09.499]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.499]                     NULL
[17:40:09.499]                   }
[17:40:09.499]                   options(future.plan = NULL)
[17:40:09.499]                   if (is.na(NA_character_)) 
[17:40:09.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.499]                     .init = FALSE)
[17:40:09.499]                 }
[17:40:09.499]             }
[17:40:09.499]         }
[17:40:09.499]     })
[17:40:09.499]     if (TRUE) {
[17:40:09.499]         base::sink(type = "output", split = FALSE)
[17:40:09.499]         if (TRUE) {
[17:40:09.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.499]         }
[17:40:09.499]         else {
[17:40:09.499]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.499]         }
[17:40:09.499]         base::close(...future.stdout)
[17:40:09.499]         ...future.stdout <- NULL
[17:40:09.499]     }
[17:40:09.499]     ...future.result$conditions <- ...future.conditions
[17:40:09.499]     ...future.result$finished <- base::Sys.time()
[17:40:09.499]     ...future.result
[17:40:09.499] }
[17:40:09.502] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:40:09.503] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:40:09.503] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:40:09.503] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:40:09.504] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:09.506] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.506] - Validating connection of MultisessionFuture
[17:40:09.506] - received message: FutureResult
[17:40:09.506] - Received FutureResult
[17:40:09.506] - Erased future from FutureRegistry
[17:40:09.507] result() for ClusterFuture ...
[17:40:09.507] - result already collected: FutureResult
[17:40:09.507] result() for ClusterFuture ... done
[17:40:09.507] receiveMessageFromWorker() for ClusterFuture ... done
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:09.507] result() for ClusterFuture ...
[17:40:09.507] - result already collected: FutureResult
[17:40:09.507] result() for ClusterFuture ... done
[17:40:09.507] result() for ClusterFuture ...
[17:40:09.508] - result already collected: FutureResult
[17:40:09.508] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[17:40:09.511] getGlobalsAndPackages() ...
[17:40:09.512] Searching for globals...
[17:40:09.512] - globals found: [2] ‘{’, ‘ii’
[17:40:09.513] Searching for globals ... DONE
[17:40:09.513] Resolving globals: FALSE
[17:40:09.513] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:09.513] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:40:09.514] - globals: [1] ‘ii’
[17:40:09.514] 
[17:40:09.514] getGlobalsAndPackages() ... DONE
[17:40:09.525] Packages needed by the future expression (n = 0): <none>
[17:40:09.525] Packages needed by future strategies (n = 0): <none>
[17:40:09.525] {
[17:40:09.525]     {
[17:40:09.525]         {
[17:40:09.525]             ...future.startTime <- base::Sys.time()
[17:40:09.525]             {
[17:40:09.525]                 {
[17:40:09.525]                   {
[17:40:09.525]                     {
[17:40:09.525]                       base::local({
[17:40:09.525]                         has_future <- base::requireNamespace("future", 
[17:40:09.525]                           quietly = TRUE)
[17:40:09.525]                         if (has_future) {
[17:40:09.525]                           ns <- base::getNamespace("future")
[17:40:09.525]                           version <- ns[[".package"]][["version"]]
[17:40:09.525]                           if (is.null(version)) 
[17:40:09.525]                             version <- utils::packageVersion("future")
[17:40:09.525]                         }
[17:40:09.525]                         else {
[17:40:09.525]                           version <- NULL
[17:40:09.525]                         }
[17:40:09.525]                         if (!has_future || version < "1.8.0") {
[17:40:09.525]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.525]                             "", base::R.version$version.string), 
[17:40:09.525]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.525]                               "release", "version")], collapse = " "), 
[17:40:09.525]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.525]                             info)
[17:40:09.525]                           info <- base::paste(info, collapse = "; ")
[17:40:09.525]                           if (!has_future) {
[17:40:09.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.525]                               info)
[17:40:09.525]                           }
[17:40:09.525]                           else {
[17:40:09.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.525]                               info, version)
[17:40:09.525]                           }
[17:40:09.525]                           base::stop(msg)
[17:40:09.525]                         }
[17:40:09.525]                       })
[17:40:09.525]                     }
[17:40:09.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.525]                     base::options(mc.cores = 1L)
[17:40:09.525]                   }
[17:40:09.525]                   ...future.strategy.old <- future::plan("list")
[17:40:09.525]                   options(future.plan = NULL)
[17:40:09.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.525]                 }
[17:40:09.525]                 ...future.workdir <- getwd()
[17:40:09.525]             }
[17:40:09.525]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.525]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.525]         }
[17:40:09.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.525]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.525]             base::names(...future.oldOptions))
[17:40:09.525]     }
[17:40:09.525]     if (FALSE) {
[17:40:09.525]     }
[17:40:09.525]     else {
[17:40:09.525]         if (TRUE) {
[17:40:09.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.525]                 open = "w")
[17:40:09.525]         }
[17:40:09.525]         else {
[17:40:09.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.525]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.525]         }
[17:40:09.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.525]             base::sink(type = "output", split = FALSE)
[17:40:09.525]             base::close(...future.stdout)
[17:40:09.525]         }, add = TRUE)
[17:40:09.525]     }
[17:40:09.525]     ...future.frame <- base::sys.nframe()
[17:40:09.525]     ...future.conditions <- base::list()
[17:40:09.525]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.525]     if (FALSE) {
[17:40:09.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.525]     }
[17:40:09.525]     ...future.result <- base::tryCatch({
[17:40:09.525]         base::withCallingHandlers({
[17:40:09.525]             ...future.value <- base::withVisible(base::local({
[17:40:09.525]                 ...future.makeSendCondition <- base::local({
[17:40:09.525]                   sendCondition <- NULL
[17:40:09.525]                   function(frame = 1L) {
[17:40:09.525]                     if (is.function(sendCondition)) 
[17:40:09.525]                       return(sendCondition)
[17:40:09.525]                     ns <- getNamespace("parallel")
[17:40:09.525]                     if (exists("sendData", mode = "function", 
[17:40:09.525]                       envir = ns)) {
[17:40:09.525]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.525]                         envir = ns)
[17:40:09.525]                       envir <- sys.frame(frame)
[17:40:09.525]                       master <- NULL
[17:40:09.525]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.525]                         !identical(envir, emptyenv())) {
[17:40:09.525]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.525]                           inherits = FALSE)) {
[17:40:09.525]                           master <- get("master", mode = "list", 
[17:40:09.525]                             envir = envir, inherits = FALSE)
[17:40:09.525]                           if (inherits(master, c("SOCKnode", 
[17:40:09.525]                             "SOCK0node"))) {
[17:40:09.525]                             sendCondition <<- function(cond) {
[17:40:09.525]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.525]                                 success = TRUE)
[17:40:09.525]                               parallel_sendData(master, data)
[17:40:09.525]                             }
[17:40:09.525]                             return(sendCondition)
[17:40:09.525]                           }
[17:40:09.525]                         }
[17:40:09.525]                         frame <- frame + 1L
[17:40:09.525]                         envir <- sys.frame(frame)
[17:40:09.525]                       }
[17:40:09.525]                     }
[17:40:09.525]                     sendCondition <<- function(cond) NULL
[17:40:09.525]                   }
[17:40:09.525]                 })
[17:40:09.525]                 withCallingHandlers({
[17:40:09.525]                   {
[17:40:09.525]                     ii
[17:40:09.525]                   }
[17:40:09.525]                 }, immediateCondition = function(cond) {
[17:40:09.525]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.525]                   sendCondition(cond)
[17:40:09.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.525]                   {
[17:40:09.525]                     inherits <- base::inherits
[17:40:09.525]                     invokeRestart <- base::invokeRestart
[17:40:09.525]                     is.null <- base::is.null
[17:40:09.525]                     muffled <- FALSE
[17:40:09.525]                     if (inherits(cond, "message")) {
[17:40:09.525]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.525]                       if (muffled) 
[17:40:09.525]                         invokeRestart("muffleMessage")
[17:40:09.525]                     }
[17:40:09.525]                     else if (inherits(cond, "warning")) {
[17:40:09.525]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.525]                       if (muffled) 
[17:40:09.525]                         invokeRestart("muffleWarning")
[17:40:09.525]                     }
[17:40:09.525]                     else if (inherits(cond, "condition")) {
[17:40:09.525]                       if (!is.null(pattern)) {
[17:40:09.525]                         computeRestarts <- base::computeRestarts
[17:40:09.525]                         grepl <- base::grepl
[17:40:09.525]                         restarts <- computeRestarts(cond)
[17:40:09.525]                         for (restart in restarts) {
[17:40:09.525]                           name <- restart$name
[17:40:09.525]                           if (is.null(name)) 
[17:40:09.525]                             next
[17:40:09.525]                           if (!grepl(pattern, name)) 
[17:40:09.525]                             next
[17:40:09.525]                           invokeRestart(restart)
[17:40:09.525]                           muffled <- TRUE
[17:40:09.525]                           break
[17:40:09.525]                         }
[17:40:09.525]                       }
[17:40:09.525]                     }
[17:40:09.525]                     invisible(muffled)
[17:40:09.525]                   }
[17:40:09.525]                   muffleCondition(cond)
[17:40:09.525]                 })
[17:40:09.525]             }))
[17:40:09.525]             future::FutureResult(value = ...future.value$value, 
[17:40:09.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.525]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.525]                     ...future.globalenv.names))
[17:40:09.525]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.525]         }, condition = base::local({
[17:40:09.525]             c <- base::c
[17:40:09.525]             inherits <- base::inherits
[17:40:09.525]             invokeRestart <- base::invokeRestart
[17:40:09.525]             length <- base::length
[17:40:09.525]             list <- base::list
[17:40:09.525]             seq.int <- base::seq.int
[17:40:09.525]             signalCondition <- base::signalCondition
[17:40:09.525]             sys.calls <- base::sys.calls
[17:40:09.525]             `[[` <- base::`[[`
[17:40:09.525]             `+` <- base::`+`
[17:40:09.525]             `<<-` <- base::`<<-`
[17:40:09.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.525]                   3L)]
[17:40:09.525]             }
[17:40:09.525]             function(cond) {
[17:40:09.525]                 is_error <- inherits(cond, "error")
[17:40:09.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.525]                   NULL)
[17:40:09.525]                 if (is_error) {
[17:40:09.525]                   sessionInformation <- function() {
[17:40:09.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.525]                       search = base::search(), system = base::Sys.info())
[17:40:09.525]                   }
[17:40:09.525]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.525]                     cond$call), session = sessionInformation(), 
[17:40:09.525]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.525]                   signalCondition(cond)
[17:40:09.525]                 }
[17:40:09.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.525]                 "immediateCondition"))) {
[17:40:09.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.525]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.525]                   if (TRUE && !signal) {
[17:40:09.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.525]                     {
[17:40:09.525]                       inherits <- base::inherits
[17:40:09.525]                       invokeRestart <- base::invokeRestart
[17:40:09.525]                       is.null <- base::is.null
[17:40:09.525]                       muffled <- FALSE
[17:40:09.525]                       if (inherits(cond, "message")) {
[17:40:09.525]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.525]                         if (muffled) 
[17:40:09.525]                           invokeRestart("muffleMessage")
[17:40:09.525]                       }
[17:40:09.525]                       else if (inherits(cond, "warning")) {
[17:40:09.525]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.525]                         if (muffled) 
[17:40:09.525]                           invokeRestart("muffleWarning")
[17:40:09.525]                       }
[17:40:09.525]                       else if (inherits(cond, "condition")) {
[17:40:09.525]                         if (!is.null(pattern)) {
[17:40:09.525]                           computeRestarts <- base::computeRestarts
[17:40:09.525]                           grepl <- base::grepl
[17:40:09.525]                           restarts <- computeRestarts(cond)
[17:40:09.525]                           for (restart in restarts) {
[17:40:09.525]                             name <- restart$name
[17:40:09.525]                             if (is.null(name)) 
[17:40:09.525]                               next
[17:40:09.525]                             if (!grepl(pattern, name)) 
[17:40:09.525]                               next
[17:40:09.525]                             invokeRestart(restart)
[17:40:09.525]                             muffled <- TRUE
[17:40:09.525]                             break
[17:40:09.525]                           }
[17:40:09.525]                         }
[17:40:09.525]                       }
[17:40:09.525]                       invisible(muffled)
[17:40:09.525]                     }
[17:40:09.525]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.525]                   }
[17:40:09.525]                 }
[17:40:09.525]                 else {
[17:40:09.525]                   if (TRUE) {
[17:40:09.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.525]                     {
[17:40:09.525]                       inherits <- base::inherits
[17:40:09.525]                       invokeRestart <- base::invokeRestart
[17:40:09.525]                       is.null <- base::is.null
[17:40:09.525]                       muffled <- FALSE
[17:40:09.525]                       if (inherits(cond, "message")) {
[17:40:09.525]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.525]                         if (muffled) 
[17:40:09.525]                           invokeRestart("muffleMessage")
[17:40:09.525]                       }
[17:40:09.525]                       else if (inherits(cond, "warning")) {
[17:40:09.525]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.525]                         if (muffled) 
[17:40:09.525]                           invokeRestart("muffleWarning")
[17:40:09.525]                       }
[17:40:09.525]                       else if (inherits(cond, "condition")) {
[17:40:09.525]                         if (!is.null(pattern)) {
[17:40:09.525]                           computeRestarts <- base::computeRestarts
[17:40:09.525]                           grepl <- base::grepl
[17:40:09.525]                           restarts <- computeRestarts(cond)
[17:40:09.525]                           for (restart in restarts) {
[17:40:09.525]                             name <- restart$name
[17:40:09.525]                             if (is.null(name)) 
[17:40:09.525]                               next
[17:40:09.525]                             if (!grepl(pattern, name)) 
[17:40:09.525]                               next
[17:40:09.525]                             invokeRestart(restart)
[17:40:09.525]                             muffled <- TRUE
[17:40:09.525]                             break
[17:40:09.525]                           }
[17:40:09.525]                         }
[17:40:09.525]                       }
[17:40:09.525]                       invisible(muffled)
[17:40:09.525]                     }
[17:40:09.525]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.525]                   }
[17:40:09.525]                 }
[17:40:09.525]             }
[17:40:09.525]         }))
[17:40:09.525]     }, error = function(ex) {
[17:40:09.525]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.525]                 ...future.rng), started = ...future.startTime, 
[17:40:09.525]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.525]             version = "1.8"), class = "FutureResult")
[17:40:09.525]     }, finally = {
[17:40:09.525]         if (!identical(...future.workdir, getwd())) 
[17:40:09.525]             setwd(...future.workdir)
[17:40:09.525]         {
[17:40:09.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.525]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.525]             }
[17:40:09.525]             base::options(...future.oldOptions)
[17:40:09.525]             if (.Platform$OS.type == "windows") {
[17:40:09.525]                 old_names <- names(...future.oldEnvVars)
[17:40:09.525]                 envs <- base::Sys.getenv()
[17:40:09.525]                 names <- names(envs)
[17:40:09.525]                 common <- intersect(names, old_names)
[17:40:09.525]                 added <- setdiff(names, old_names)
[17:40:09.525]                 removed <- setdiff(old_names, names)
[17:40:09.525]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.525]                   envs[common]]
[17:40:09.525]                 NAMES <- toupper(changed)
[17:40:09.525]                 args <- list()
[17:40:09.525]                 for (kk in seq_along(NAMES)) {
[17:40:09.525]                   name <- changed[[kk]]
[17:40:09.525]                   NAME <- NAMES[[kk]]
[17:40:09.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.525]                     next
[17:40:09.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.525]                 }
[17:40:09.525]                 NAMES <- toupper(added)
[17:40:09.525]                 for (kk in seq_along(NAMES)) {
[17:40:09.525]                   name <- added[[kk]]
[17:40:09.525]                   NAME <- NAMES[[kk]]
[17:40:09.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.525]                     next
[17:40:09.525]                   args[[name]] <- ""
[17:40:09.525]                 }
[17:40:09.525]                 NAMES <- toupper(removed)
[17:40:09.525]                 for (kk in seq_along(NAMES)) {
[17:40:09.525]                   name <- removed[[kk]]
[17:40:09.525]                   NAME <- NAMES[[kk]]
[17:40:09.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.525]                     next
[17:40:09.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.525]                 }
[17:40:09.525]                 if (length(args) > 0) 
[17:40:09.525]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.525]             }
[17:40:09.525]             else {
[17:40:09.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.525]             }
[17:40:09.525]             {
[17:40:09.525]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.525]                   0L) {
[17:40:09.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.525]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.525]                   base::options(opts)
[17:40:09.525]                 }
[17:40:09.525]                 {
[17:40:09.525]                   {
[17:40:09.525]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.525]                     NULL
[17:40:09.525]                   }
[17:40:09.525]                   options(future.plan = NULL)
[17:40:09.525]                   if (is.na(NA_character_)) 
[17:40:09.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.525]                     .init = FALSE)
[17:40:09.525]                 }
[17:40:09.525]             }
[17:40:09.525]         }
[17:40:09.525]     })
[17:40:09.525]     if (TRUE) {
[17:40:09.525]         base::sink(type = "output", split = FALSE)
[17:40:09.525]         if (TRUE) {
[17:40:09.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.525]         }
[17:40:09.525]         else {
[17:40:09.525]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.525]         }
[17:40:09.525]         base::close(...future.stdout)
[17:40:09.525]         ...future.stdout <- NULL
[17:40:09.525]     }
[17:40:09.525]     ...future.result$conditions <- ...future.conditions
[17:40:09.525]     ...future.result$finished <- base::Sys.time()
[17:40:09.525]     ...future.result
[17:40:09.525] }
[17:40:09.528] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:40:09.528] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:40:09.529] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:40:09.529] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:40:09.529] MultisessionFuture started
 - Creating multisession future #1 ...
[17:40:09.534] getGlobalsAndPackages() ...
[17:40:09.534] Searching for globals...
[17:40:09.536] - globals found: [2] ‘{’, ‘ii’
[17:40:09.536] Searching for globals ... DONE
[17:40:09.536] Resolving globals: FALSE
[17:40:09.536] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:09.537] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:40:09.537] - globals: [1] ‘ii’
[17:40:09.537] 
[17:40:09.537] getGlobalsAndPackages() ... DONE
[17:40:09.548] Packages needed by the future expression (n = 0): <none>
[17:40:09.548] Packages needed by future strategies (n = 0): <none>
[17:40:09.549] {
[17:40:09.549]     {
[17:40:09.549]         {
[17:40:09.549]             ...future.startTime <- base::Sys.time()
[17:40:09.549]             {
[17:40:09.549]                 {
[17:40:09.549]                   {
[17:40:09.549]                     {
[17:40:09.549]                       base::local({
[17:40:09.549]                         has_future <- base::requireNamespace("future", 
[17:40:09.549]                           quietly = TRUE)
[17:40:09.549]                         if (has_future) {
[17:40:09.549]                           ns <- base::getNamespace("future")
[17:40:09.549]                           version <- ns[[".package"]][["version"]]
[17:40:09.549]                           if (is.null(version)) 
[17:40:09.549]                             version <- utils::packageVersion("future")
[17:40:09.549]                         }
[17:40:09.549]                         else {
[17:40:09.549]                           version <- NULL
[17:40:09.549]                         }
[17:40:09.549]                         if (!has_future || version < "1.8.0") {
[17:40:09.549]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.549]                             "", base::R.version$version.string), 
[17:40:09.549]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.549]                               "release", "version")], collapse = " "), 
[17:40:09.549]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.549]                             info)
[17:40:09.549]                           info <- base::paste(info, collapse = "; ")
[17:40:09.549]                           if (!has_future) {
[17:40:09.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.549]                               info)
[17:40:09.549]                           }
[17:40:09.549]                           else {
[17:40:09.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.549]                               info, version)
[17:40:09.549]                           }
[17:40:09.549]                           base::stop(msg)
[17:40:09.549]                         }
[17:40:09.549]                       })
[17:40:09.549]                     }
[17:40:09.549]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.549]                     base::options(mc.cores = 1L)
[17:40:09.549]                   }
[17:40:09.549]                   ...future.strategy.old <- future::plan("list")
[17:40:09.549]                   options(future.plan = NULL)
[17:40:09.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.549]                 }
[17:40:09.549]                 ...future.workdir <- getwd()
[17:40:09.549]             }
[17:40:09.549]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.549]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.549]         }
[17:40:09.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.549]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.549]             base::names(...future.oldOptions))
[17:40:09.549]     }
[17:40:09.549]     if (FALSE) {
[17:40:09.549]     }
[17:40:09.549]     else {
[17:40:09.549]         if (TRUE) {
[17:40:09.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.549]                 open = "w")
[17:40:09.549]         }
[17:40:09.549]         else {
[17:40:09.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.549]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.549]         }
[17:40:09.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.549]             base::sink(type = "output", split = FALSE)
[17:40:09.549]             base::close(...future.stdout)
[17:40:09.549]         }, add = TRUE)
[17:40:09.549]     }
[17:40:09.549]     ...future.frame <- base::sys.nframe()
[17:40:09.549]     ...future.conditions <- base::list()
[17:40:09.549]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.549]     if (FALSE) {
[17:40:09.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.549]     }
[17:40:09.549]     ...future.result <- base::tryCatch({
[17:40:09.549]         base::withCallingHandlers({
[17:40:09.549]             ...future.value <- base::withVisible(base::local({
[17:40:09.549]                 ...future.makeSendCondition <- base::local({
[17:40:09.549]                   sendCondition <- NULL
[17:40:09.549]                   function(frame = 1L) {
[17:40:09.549]                     if (is.function(sendCondition)) 
[17:40:09.549]                       return(sendCondition)
[17:40:09.549]                     ns <- getNamespace("parallel")
[17:40:09.549]                     if (exists("sendData", mode = "function", 
[17:40:09.549]                       envir = ns)) {
[17:40:09.549]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.549]                         envir = ns)
[17:40:09.549]                       envir <- sys.frame(frame)
[17:40:09.549]                       master <- NULL
[17:40:09.549]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.549]                         !identical(envir, emptyenv())) {
[17:40:09.549]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.549]                           inherits = FALSE)) {
[17:40:09.549]                           master <- get("master", mode = "list", 
[17:40:09.549]                             envir = envir, inherits = FALSE)
[17:40:09.549]                           if (inherits(master, c("SOCKnode", 
[17:40:09.549]                             "SOCK0node"))) {
[17:40:09.549]                             sendCondition <<- function(cond) {
[17:40:09.549]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.549]                                 success = TRUE)
[17:40:09.549]                               parallel_sendData(master, data)
[17:40:09.549]                             }
[17:40:09.549]                             return(sendCondition)
[17:40:09.549]                           }
[17:40:09.549]                         }
[17:40:09.549]                         frame <- frame + 1L
[17:40:09.549]                         envir <- sys.frame(frame)
[17:40:09.549]                       }
[17:40:09.549]                     }
[17:40:09.549]                     sendCondition <<- function(cond) NULL
[17:40:09.549]                   }
[17:40:09.549]                 })
[17:40:09.549]                 withCallingHandlers({
[17:40:09.549]                   {
[17:40:09.549]                     ii
[17:40:09.549]                   }
[17:40:09.549]                 }, immediateCondition = function(cond) {
[17:40:09.549]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.549]                   sendCondition(cond)
[17:40:09.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.549]                   {
[17:40:09.549]                     inherits <- base::inherits
[17:40:09.549]                     invokeRestart <- base::invokeRestart
[17:40:09.549]                     is.null <- base::is.null
[17:40:09.549]                     muffled <- FALSE
[17:40:09.549]                     if (inherits(cond, "message")) {
[17:40:09.549]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.549]                       if (muffled) 
[17:40:09.549]                         invokeRestart("muffleMessage")
[17:40:09.549]                     }
[17:40:09.549]                     else if (inherits(cond, "warning")) {
[17:40:09.549]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.549]                       if (muffled) 
[17:40:09.549]                         invokeRestart("muffleWarning")
[17:40:09.549]                     }
[17:40:09.549]                     else if (inherits(cond, "condition")) {
[17:40:09.549]                       if (!is.null(pattern)) {
[17:40:09.549]                         computeRestarts <- base::computeRestarts
[17:40:09.549]                         grepl <- base::grepl
[17:40:09.549]                         restarts <- computeRestarts(cond)
[17:40:09.549]                         for (restart in restarts) {
[17:40:09.549]                           name <- restart$name
[17:40:09.549]                           if (is.null(name)) 
[17:40:09.549]                             next
[17:40:09.549]                           if (!grepl(pattern, name)) 
[17:40:09.549]                             next
[17:40:09.549]                           invokeRestart(restart)
[17:40:09.549]                           muffled <- TRUE
[17:40:09.549]                           break
[17:40:09.549]                         }
[17:40:09.549]                       }
[17:40:09.549]                     }
[17:40:09.549]                     invisible(muffled)
[17:40:09.549]                   }
[17:40:09.549]                   muffleCondition(cond)
[17:40:09.549]                 })
[17:40:09.549]             }))
[17:40:09.549]             future::FutureResult(value = ...future.value$value, 
[17:40:09.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.549]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.549]                     ...future.globalenv.names))
[17:40:09.549]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.549]         }, condition = base::local({
[17:40:09.549]             c <- base::c
[17:40:09.549]             inherits <- base::inherits
[17:40:09.549]             invokeRestart <- base::invokeRestart
[17:40:09.549]             length <- base::length
[17:40:09.549]             list <- base::list
[17:40:09.549]             seq.int <- base::seq.int
[17:40:09.549]             signalCondition <- base::signalCondition
[17:40:09.549]             sys.calls <- base::sys.calls
[17:40:09.549]             `[[` <- base::`[[`
[17:40:09.549]             `+` <- base::`+`
[17:40:09.549]             `<<-` <- base::`<<-`
[17:40:09.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.549]                   3L)]
[17:40:09.549]             }
[17:40:09.549]             function(cond) {
[17:40:09.549]                 is_error <- inherits(cond, "error")
[17:40:09.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.549]                   NULL)
[17:40:09.549]                 if (is_error) {
[17:40:09.549]                   sessionInformation <- function() {
[17:40:09.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.549]                       search = base::search(), system = base::Sys.info())
[17:40:09.549]                   }
[17:40:09.549]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.549]                     cond$call), session = sessionInformation(), 
[17:40:09.549]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.549]                   signalCondition(cond)
[17:40:09.549]                 }
[17:40:09.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.549]                 "immediateCondition"))) {
[17:40:09.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.549]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.549]                   if (TRUE && !signal) {
[17:40:09.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.549]                     {
[17:40:09.549]                       inherits <- base::inherits
[17:40:09.549]                       invokeRestart <- base::invokeRestart
[17:40:09.549]                       is.null <- base::is.null
[17:40:09.549]                       muffled <- FALSE
[17:40:09.549]                       if (inherits(cond, "message")) {
[17:40:09.549]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.549]                         if (muffled) 
[17:40:09.549]                           invokeRestart("muffleMessage")
[17:40:09.549]                       }
[17:40:09.549]                       else if (inherits(cond, "warning")) {
[17:40:09.549]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.549]                         if (muffled) 
[17:40:09.549]                           invokeRestart("muffleWarning")
[17:40:09.549]                       }
[17:40:09.549]                       else if (inherits(cond, "condition")) {
[17:40:09.549]                         if (!is.null(pattern)) {
[17:40:09.549]                           computeRestarts <- base::computeRestarts
[17:40:09.549]                           grepl <- base::grepl
[17:40:09.549]                           restarts <- computeRestarts(cond)
[17:40:09.549]                           for (restart in restarts) {
[17:40:09.549]                             name <- restart$name
[17:40:09.549]                             if (is.null(name)) 
[17:40:09.549]                               next
[17:40:09.549]                             if (!grepl(pattern, name)) 
[17:40:09.549]                               next
[17:40:09.549]                             invokeRestart(restart)
[17:40:09.549]                             muffled <- TRUE
[17:40:09.549]                             break
[17:40:09.549]                           }
[17:40:09.549]                         }
[17:40:09.549]                       }
[17:40:09.549]                       invisible(muffled)
[17:40:09.549]                     }
[17:40:09.549]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.549]                   }
[17:40:09.549]                 }
[17:40:09.549]                 else {
[17:40:09.549]                   if (TRUE) {
[17:40:09.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.549]                     {
[17:40:09.549]                       inherits <- base::inherits
[17:40:09.549]                       invokeRestart <- base::invokeRestart
[17:40:09.549]                       is.null <- base::is.null
[17:40:09.549]                       muffled <- FALSE
[17:40:09.549]                       if (inherits(cond, "message")) {
[17:40:09.549]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.549]                         if (muffled) 
[17:40:09.549]                           invokeRestart("muffleMessage")
[17:40:09.549]                       }
[17:40:09.549]                       else if (inherits(cond, "warning")) {
[17:40:09.549]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.549]                         if (muffled) 
[17:40:09.549]                           invokeRestart("muffleWarning")
[17:40:09.549]                       }
[17:40:09.549]                       else if (inherits(cond, "condition")) {
[17:40:09.549]                         if (!is.null(pattern)) {
[17:40:09.549]                           computeRestarts <- base::computeRestarts
[17:40:09.549]                           grepl <- base::grepl
[17:40:09.549]                           restarts <- computeRestarts(cond)
[17:40:09.549]                           for (restart in restarts) {
[17:40:09.549]                             name <- restart$name
[17:40:09.549]                             if (is.null(name)) 
[17:40:09.549]                               next
[17:40:09.549]                             if (!grepl(pattern, name)) 
[17:40:09.549]                               next
[17:40:09.549]                             invokeRestart(restart)
[17:40:09.549]                             muffled <- TRUE
[17:40:09.549]                             break
[17:40:09.549]                           }
[17:40:09.549]                         }
[17:40:09.549]                       }
[17:40:09.549]                       invisible(muffled)
[17:40:09.549]                     }
[17:40:09.549]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.549]                   }
[17:40:09.549]                 }
[17:40:09.549]             }
[17:40:09.549]         }))
[17:40:09.549]     }, error = function(ex) {
[17:40:09.549]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.549]                 ...future.rng), started = ...future.startTime, 
[17:40:09.549]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.549]             version = "1.8"), class = "FutureResult")
[17:40:09.549]     }, finally = {
[17:40:09.549]         if (!identical(...future.workdir, getwd())) 
[17:40:09.549]             setwd(...future.workdir)
[17:40:09.549]         {
[17:40:09.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.549]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.549]             }
[17:40:09.549]             base::options(...future.oldOptions)
[17:40:09.549]             if (.Platform$OS.type == "windows") {
[17:40:09.549]                 old_names <- names(...future.oldEnvVars)
[17:40:09.549]                 envs <- base::Sys.getenv()
[17:40:09.549]                 names <- names(envs)
[17:40:09.549]                 common <- intersect(names, old_names)
[17:40:09.549]                 added <- setdiff(names, old_names)
[17:40:09.549]                 removed <- setdiff(old_names, names)
[17:40:09.549]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.549]                   envs[common]]
[17:40:09.549]                 NAMES <- toupper(changed)
[17:40:09.549]                 args <- list()
[17:40:09.549]                 for (kk in seq_along(NAMES)) {
[17:40:09.549]                   name <- changed[[kk]]
[17:40:09.549]                   NAME <- NAMES[[kk]]
[17:40:09.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.549]                     next
[17:40:09.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.549]                 }
[17:40:09.549]                 NAMES <- toupper(added)
[17:40:09.549]                 for (kk in seq_along(NAMES)) {
[17:40:09.549]                   name <- added[[kk]]
[17:40:09.549]                   NAME <- NAMES[[kk]]
[17:40:09.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.549]                     next
[17:40:09.549]                   args[[name]] <- ""
[17:40:09.549]                 }
[17:40:09.549]                 NAMES <- toupper(removed)
[17:40:09.549]                 for (kk in seq_along(NAMES)) {
[17:40:09.549]                   name <- removed[[kk]]
[17:40:09.549]                   NAME <- NAMES[[kk]]
[17:40:09.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.549]                     next
[17:40:09.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.549]                 }
[17:40:09.549]                 if (length(args) > 0) 
[17:40:09.549]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.549]             }
[17:40:09.549]             else {
[17:40:09.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.549]             }
[17:40:09.549]             {
[17:40:09.549]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.549]                   0L) {
[17:40:09.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.549]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.549]                   base::options(opts)
[17:40:09.549]                 }
[17:40:09.549]                 {
[17:40:09.549]                   {
[17:40:09.549]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.549]                     NULL
[17:40:09.549]                   }
[17:40:09.549]                   options(future.plan = NULL)
[17:40:09.549]                   if (is.na(NA_character_)) 
[17:40:09.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.549]                     .init = FALSE)
[17:40:09.549]                 }
[17:40:09.549]             }
[17:40:09.549]         }
[17:40:09.549]     })
[17:40:09.549]     if (TRUE) {
[17:40:09.549]         base::sink(type = "output", split = FALSE)
[17:40:09.549]         if (TRUE) {
[17:40:09.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.549]         }
[17:40:09.549]         else {
[17:40:09.549]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.549]         }
[17:40:09.549]         base::close(...future.stdout)
[17:40:09.549]         ...future.stdout <- NULL
[17:40:09.549]     }
[17:40:09.549]     ...future.result$conditions <- ...future.conditions
[17:40:09.549]     ...future.result$finished <- base::Sys.time()
[17:40:09.549]     ...future.result
[17:40:09.549] }
[17:40:09.600] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:40:09.600] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:40:09.601] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:40:09.601] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:40:09.601] MultisessionFuture started
 - Resolving 2 multisession futures
[17:40:09.602] result() for ClusterFuture ...
[17:40:09.602] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.602] - Validating connection of MultisessionFuture
[17:40:09.634] - received message: FutureResult
[17:40:09.634] - Received FutureResult
[17:40:09.634] - Erased future from FutureRegistry
[17:40:09.634] result() for ClusterFuture ...
[17:40:09.634] - result already collected: FutureResult
[17:40:09.634] result() for ClusterFuture ... done
[17:40:09.635] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:09.635] result() for ClusterFuture ... done
[17:40:09.635] result() for ClusterFuture ...
[17:40:09.635] - result already collected: FutureResult
[17:40:09.635] result() for ClusterFuture ... done
[17:40:09.635] result() for ClusterFuture ...
[17:40:09.635] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.635] - Validating connection of MultisessionFuture
[17:40:09.636] - received message: FutureResult
[17:40:09.636] - Received FutureResult
[17:40:09.636] - Erased future from FutureRegistry
[17:40:09.636] result() for ClusterFuture ...
[17:40:09.636] - result already collected: FutureResult
[17:40:09.636] result() for ClusterFuture ... done
[17:40:09.636] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:09.636] result() for ClusterFuture ... done
[17:40:09.637] result() for ClusterFuture ...
[17:40:09.637] - result already collected: FutureResult
[17:40:09.637] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[17:40:09.637] getGlobalsAndPackages() ...
[17:40:09.637] Searching for globals...
[17:40:09.638] - globals found: [1] ‘.libPaths’
[17:40:09.638] Searching for globals ... DONE
[17:40:09.638] Resolving globals: FALSE
[17:40:09.638] 
[17:40:09.639] 
[17:40:09.639] getGlobalsAndPackages() ... DONE
[17:40:09.639] run() for ‘Future’ ...
[17:40:09.639] - state: ‘created’
[17:40:09.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:09.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:09.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:09.640]   - Field: ‘label’
[17:40:09.640]   - Field: ‘local’
[17:40:09.640]   - Field: ‘owner’
[17:40:09.640]   - Field: ‘envir’
[17:40:09.640]   - Field: ‘packages’
[17:40:09.640]   - Field: ‘gc’
[17:40:09.641]   - Field: ‘conditions’
[17:40:09.641]   - Field: ‘expr’
[17:40:09.641]   - Field: ‘uuid’
[17:40:09.641]   - Field: ‘seed’
[17:40:09.641]   - Field: ‘version’
[17:40:09.641]   - Field: ‘result’
[17:40:09.641]   - Field: ‘asynchronous’
[17:40:09.641]   - Field: ‘calls’
[17:40:09.641]   - Field: ‘globals’
[17:40:09.642]   - Field: ‘stdout’
[17:40:09.642]   - Field: ‘earlySignal’
[17:40:09.642]   - Field: ‘lazy’
[17:40:09.642]   - Field: ‘state’
[17:40:09.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:09.642] - Launch lazy future ...
[17:40:09.642] Packages needed by the future expression (n = 0): <none>
[17:40:09.643] Packages needed by future strategies (n = 0): <none>
[17:40:09.643] {
[17:40:09.643]     {
[17:40:09.643]         {
[17:40:09.643]             ...future.startTime <- base::Sys.time()
[17:40:09.643]             {
[17:40:09.643]                 {
[17:40:09.643]                   {
[17:40:09.643]                     base::local({
[17:40:09.643]                       has_future <- base::requireNamespace("future", 
[17:40:09.643]                         quietly = TRUE)
[17:40:09.643]                       if (has_future) {
[17:40:09.643]                         ns <- base::getNamespace("future")
[17:40:09.643]                         version <- ns[[".package"]][["version"]]
[17:40:09.643]                         if (is.null(version)) 
[17:40:09.643]                           version <- utils::packageVersion("future")
[17:40:09.643]                       }
[17:40:09.643]                       else {
[17:40:09.643]                         version <- NULL
[17:40:09.643]                       }
[17:40:09.643]                       if (!has_future || version < "1.8.0") {
[17:40:09.643]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.643]                           "", base::R.version$version.string), 
[17:40:09.643]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:09.643]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.643]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.643]                             "release", "version")], collapse = " "), 
[17:40:09.643]                           hostname = base::Sys.info()[["nodename"]])
[17:40:09.643]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.643]                           info)
[17:40:09.643]                         info <- base::paste(info, collapse = "; ")
[17:40:09.643]                         if (!has_future) {
[17:40:09.643]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.643]                             info)
[17:40:09.643]                         }
[17:40:09.643]                         else {
[17:40:09.643]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.643]                             info, version)
[17:40:09.643]                         }
[17:40:09.643]                         base::stop(msg)
[17:40:09.643]                       }
[17:40:09.643]                     })
[17:40:09.643]                   }
[17:40:09.643]                   ...future.strategy.old <- future::plan("list")
[17:40:09.643]                   options(future.plan = NULL)
[17:40:09.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.643]                 }
[17:40:09.643]                 ...future.workdir <- getwd()
[17:40:09.643]             }
[17:40:09.643]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.643]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.643]         }
[17:40:09.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.643]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.643]             base::names(...future.oldOptions))
[17:40:09.643]     }
[17:40:09.643]     if (FALSE) {
[17:40:09.643]     }
[17:40:09.643]     else {
[17:40:09.643]         if (TRUE) {
[17:40:09.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.643]                 open = "w")
[17:40:09.643]         }
[17:40:09.643]         else {
[17:40:09.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.643]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.643]         }
[17:40:09.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.643]             base::sink(type = "output", split = FALSE)
[17:40:09.643]             base::close(...future.stdout)
[17:40:09.643]         }, add = TRUE)
[17:40:09.643]     }
[17:40:09.643]     ...future.frame <- base::sys.nframe()
[17:40:09.643]     ...future.conditions <- base::list()
[17:40:09.643]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.643]     if (FALSE) {
[17:40:09.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.643]     }
[17:40:09.643]     ...future.result <- base::tryCatch({
[17:40:09.643]         base::withCallingHandlers({
[17:40:09.643]             ...future.value <- base::withVisible(base::local(.libPaths()))
[17:40:09.643]             future::FutureResult(value = ...future.value$value, 
[17:40:09.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.643]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.643]                     ...future.globalenv.names))
[17:40:09.643]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.643]         }, condition = base::local({
[17:40:09.643]             c <- base::c
[17:40:09.643]             inherits <- base::inherits
[17:40:09.643]             invokeRestart <- base::invokeRestart
[17:40:09.643]             length <- base::length
[17:40:09.643]             list <- base::list
[17:40:09.643]             seq.int <- base::seq.int
[17:40:09.643]             signalCondition <- base::signalCondition
[17:40:09.643]             sys.calls <- base::sys.calls
[17:40:09.643]             `[[` <- base::`[[`
[17:40:09.643]             `+` <- base::`+`
[17:40:09.643]             `<<-` <- base::`<<-`
[17:40:09.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.643]                   3L)]
[17:40:09.643]             }
[17:40:09.643]             function(cond) {
[17:40:09.643]                 is_error <- inherits(cond, "error")
[17:40:09.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.643]                   NULL)
[17:40:09.643]                 if (is_error) {
[17:40:09.643]                   sessionInformation <- function() {
[17:40:09.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.643]                       search = base::search(), system = base::Sys.info())
[17:40:09.643]                   }
[17:40:09.643]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.643]                     cond$call), session = sessionInformation(), 
[17:40:09.643]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.643]                   signalCondition(cond)
[17:40:09.643]                 }
[17:40:09.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.643]                 "immediateCondition"))) {
[17:40:09.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.643]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.643]                   if (TRUE && !signal) {
[17:40:09.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.643]                     {
[17:40:09.643]                       inherits <- base::inherits
[17:40:09.643]                       invokeRestart <- base::invokeRestart
[17:40:09.643]                       is.null <- base::is.null
[17:40:09.643]                       muffled <- FALSE
[17:40:09.643]                       if (inherits(cond, "message")) {
[17:40:09.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.643]                         if (muffled) 
[17:40:09.643]                           invokeRestart("muffleMessage")
[17:40:09.643]                       }
[17:40:09.643]                       else if (inherits(cond, "warning")) {
[17:40:09.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.643]                         if (muffled) 
[17:40:09.643]                           invokeRestart("muffleWarning")
[17:40:09.643]                       }
[17:40:09.643]                       else if (inherits(cond, "condition")) {
[17:40:09.643]                         if (!is.null(pattern)) {
[17:40:09.643]                           computeRestarts <- base::computeRestarts
[17:40:09.643]                           grepl <- base::grepl
[17:40:09.643]                           restarts <- computeRestarts(cond)
[17:40:09.643]                           for (restart in restarts) {
[17:40:09.643]                             name <- restart$name
[17:40:09.643]                             if (is.null(name)) 
[17:40:09.643]                               next
[17:40:09.643]                             if (!grepl(pattern, name)) 
[17:40:09.643]                               next
[17:40:09.643]                             invokeRestart(restart)
[17:40:09.643]                             muffled <- TRUE
[17:40:09.643]                             break
[17:40:09.643]                           }
[17:40:09.643]                         }
[17:40:09.643]                       }
[17:40:09.643]                       invisible(muffled)
[17:40:09.643]                     }
[17:40:09.643]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.643]                   }
[17:40:09.643]                 }
[17:40:09.643]                 else {
[17:40:09.643]                   if (TRUE) {
[17:40:09.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.643]                     {
[17:40:09.643]                       inherits <- base::inherits
[17:40:09.643]                       invokeRestart <- base::invokeRestart
[17:40:09.643]                       is.null <- base::is.null
[17:40:09.643]                       muffled <- FALSE
[17:40:09.643]                       if (inherits(cond, "message")) {
[17:40:09.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.643]                         if (muffled) 
[17:40:09.643]                           invokeRestart("muffleMessage")
[17:40:09.643]                       }
[17:40:09.643]                       else if (inherits(cond, "warning")) {
[17:40:09.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.643]                         if (muffled) 
[17:40:09.643]                           invokeRestart("muffleWarning")
[17:40:09.643]                       }
[17:40:09.643]                       else if (inherits(cond, "condition")) {
[17:40:09.643]                         if (!is.null(pattern)) {
[17:40:09.643]                           computeRestarts <- base::computeRestarts
[17:40:09.643]                           grepl <- base::grepl
[17:40:09.643]                           restarts <- computeRestarts(cond)
[17:40:09.643]                           for (restart in restarts) {
[17:40:09.643]                             name <- restart$name
[17:40:09.643]                             if (is.null(name)) 
[17:40:09.643]                               next
[17:40:09.643]                             if (!grepl(pattern, name)) 
[17:40:09.643]                               next
[17:40:09.643]                             invokeRestart(restart)
[17:40:09.643]                             muffled <- TRUE
[17:40:09.643]                             break
[17:40:09.643]                           }
[17:40:09.643]                         }
[17:40:09.643]                       }
[17:40:09.643]                       invisible(muffled)
[17:40:09.643]                     }
[17:40:09.643]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.643]                   }
[17:40:09.643]                 }
[17:40:09.643]             }
[17:40:09.643]         }))
[17:40:09.643]     }, error = function(ex) {
[17:40:09.643]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.643]                 ...future.rng), started = ...future.startTime, 
[17:40:09.643]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.643]             version = "1.8"), class = "FutureResult")
[17:40:09.643]     }, finally = {
[17:40:09.643]         if (!identical(...future.workdir, getwd())) 
[17:40:09.643]             setwd(...future.workdir)
[17:40:09.643]         {
[17:40:09.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.643]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.643]             }
[17:40:09.643]             base::options(...future.oldOptions)
[17:40:09.643]             if (.Platform$OS.type == "windows") {
[17:40:09.643]                 old_names <- names(...future.oldEnvVars)
[17:40:09.643]                 envs <- base::Sys.getenv()
[17:40:09.643]                 names <- names(envs)
[17:40:09.643]                 common <- intersect(names, old_names)
[17:40:09.643]                 added <- setdiff(names, old_names)
[17:40:09.643]                 removed <- setdiff(old_names, names)
[17:40:09.643]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.643]                   envs[common]]
[17:40:09.643]                 NAMES <- toupper(changed)
[17:40:09.643]                 args <- list()
[17:40:09.643]                 for (kk in seq_along(NAMES)) {
[17:40:09.643]                   name <- changed[[kk]]
[17:40:09.643]                   NAME <- NAMES[[kk]]
[17:40:09.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.643]                     next
[17:40:09.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.643]                 }
[17:40:09.643]                 NAMES <- toupper(added)
[17:40:09.643]                 for (kk in seq_along(NAMES)) {
[17:40:09.643]                   name <- added[[kk]]
[17:40:09.643]                   NAME <- NAMES[[kk]]
[17:40:09.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.643]                     next
[17:40:09.643]                   args[[name]] <- ""
[17:40:09.643]                 }
[17:40:09.643]                 NAMES <- toupper(removed)
[17:40:09.643]                 for (kk in seq_along(NAMES)) {
[17:40:09.643]                   name <- removed[[kk]]
[17:40:09.643]                   NAME <- NAMES[[kk]]
[17:40:09.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.643]                     next
[17:40:09.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.643]                 }
[17:40:09.643]                 if (length(args) > 0) 
[17:40:09.643]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.643]             }
[17:40:09.643]             else {
[17:40:09.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.643]             }
[17:40:09.643]             {
[17:40:09.643]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.643]                   0L) {
[17:40:09.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.643]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.643]                   base::options(opts)
[17:40:09.643]                 }
[17:40:09.643]                 {
[17:40:09.643]                   {
[17:40:09.643]                     NULL
[17:40:09.643]                     RNGkind("Mersenne-Twister")
[17:40:09.643]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:09.643]                       inherits = FALSE)
[17:40:09.643]                   }
[17:40:09.643]                   options(future.plan = NULL)
[17:40:09.643]                   if (is.na(NA_character_)) 
[17:40:09.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.643]                     .init = FALSE)
[17:40:09.643]                 }
[17:40:09.643]             }
[17:40:09.643]         }
[17:40:09.643]     })
[17:40:09.643]     if (TRUE) {
[17:40:09.643]         base::sink(type = "output", split = FALSE)
[17:40:09.643]         if (TRUE) {
[17:40:09.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.643]         }
[17:40:09.643]         else {
[17:40:09.643]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.643]         }
[17:40:09.643]         base::close(...future.stdout)
[17:40:09.643]         ...future.stdout <- NULL
[17:40:09.643]     }
[17:40:09.643]     ...future.result$conditions <- ...future.conditions
[17:40:09.643]     ...future.result$finished <- base::Sys.time()
[17:40:09.643]     ...future.result
[17:40:09.643] }
[17:40:09.646] plan(): Setting new future strategy stack:
[17:40:09.646] List of future strategies:
[17:40:09.646] 1. sequential:
[17:40:09.646]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:09.646]    - tweaked: FALSE
[17:40:09.646]    - call: NULL
[17:40:09.647] plan(): nbrOfWorkers() = 1
[17:40:09.652] plan(): Setting new future strategy stack:
[17:40:09.652] List of future strategies:
[17:40:09.652] 1. sequential:
[17:40:09.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:09.652]    - tweaked: FALSE
[17:40:09.652]    - call: future::plan("sequential")
[17:40:09.653] plan(): nbrOfWorkers() = 1
[17:40:09.653] SequentialFuture started (and completed)
[17:40:09.653] - Launch lazy future ... done
[17:40:09.653] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[17:40:09.659] getGlobalsAndPackages() ...
[17:40:09.659] 
[17:40:09.660] - globals: [0] <none>
[17:40:09.660] getGlobalsAndPackages() ... DONE
[17:40:09.670] Packages needed by the future expression (n = 0): <none>
[17:40:09.671] Packages needed by future strategies (n = 0): <none>
[17:40:09.671] {
[17:40:09.671]     {
[17:40:09.671]         {
[17:40:09.671]             ...future.startTime <- base::Sys.time()
[17:40:09.671]             {
[17:40:09.671]                 {
[17:40:09.671]                   {
[17:40:09.671]                     {
[17:40:09.671]                       base::local({
[17:40:09.671]                         has_future <- base::requireNamespace("future", 
[17:40:09.671]                           quietly = TRUE)
[17:40:09.671]                         if (has_future) {
[17:40:09.671]                           ns <- base::getNamespace("future")
[17:40:09.671]                           version <- ns[[".package"]][["version"]]
[17:40:09.671]                           if (is.null(version)) 
[17:40:09.671]                             version <- utils::packageVersion("future")
[17:40:09.671]                         }
[17:40:09.671]                         else {
[17:40:09.671]                           version <- NULL
[17:40:09.671]                         }
[17:40:09.671]                         if (!has_future || version < "1.8.0") {
[17:40:09.671]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.671]                             "", base::R.version$version.string), 
[17:40:09.671]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.671]                               "release", "version")], collapse = " "), 
[17:40:09.671]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.671]                             info)
[17:40:09.671]                           info <- base::paste(info, collapse = "; ")
[17:40:09.671]                           if (!has_future) {
[17:40:09.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.671]                               info)
[17:40:09.671]                           }
[17:40:09.671]                           else {
[17:40:09.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.671]                               info, version)
[17:40:09.671]                           }
[17:40:09.671]                           base::stop(msg)
[17:40:09.671]                         }
[17:40:09.671]                       })
[17:40:09.671]                     }
[17:40:09.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.671]                     base::options(mc.cores = 1L)
[17:40:09.671]                   }
[17:40:09.671]                   ...future.strategy.old <- future::plan("list")
[17:40:09.671]                   options(future.plan = NULL)
[17:40:09.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.671]                 }
[17:40:09.671]                 ...future.workdir <- getwd()
[17:40:09.671]             }
[17:40:09.671]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.671]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.671]         }
[17:40:09.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.671]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.671]             base::names(...future.oldOptions))
[17:40:09.671]     }
[17:40:09.671]     if (FALSE) {
[17:40:09.671]     }
[17:40:09.671]     else {
[17:40:09.671]         if (TRUE) {
[17:40:09.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.671]                 open = "w")
[17:40:09.671]         }
[17:40:09.671]         else {
[17:40:09.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.671]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.671]         }
[17:40:09.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.671]             base::sink(type = "output", split = FALSE)
[17:40:09.671]             base::close(...future.stdout)
[17:40:09.671]         }, add = TRUE)
[17:40:09.671]     }
[17:40:09.671]     ...future.frame <- base::sys.nframe()
[17:40:09.671]     ...future.conditions <- base::list()
[17:40:09.671]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.671]     if (FALSE) {
[17:40:09.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.671]     }
[17:40:09.671]     ...future.result <- base::tryCatch({
[17:40:09.671]         base::withCallingHandlers({
[17:40:09.671]             ...future.value <- base::withVisible(base::local({
[17:40:09.671]                 ...future.makeSendCondition <- base::local({
[17:40:09.671]                   sendCondition <- NULL
[17:40:09.671]                   function(frame = 1L) {
[17:40:09.671]                     if (is.function(sendCondition)) 
[17:40:09.671]                       return(sendCondition)
[17:40:09.671]                     ns <- getNamespace("parallel")
[17:40:09.671]                     if (exists("sendData", mode = "function", 
[17:40:09.671]                       envir = ns)) {
[17:40:09.671]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.671]                         envir = ns)
[17:40:09.671]                       envir <- sys.frame(frame)
[17:40:09.671]                       master <- NULL
[17:40:09.671]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.671]                         !identical(envir, emptyenv())) {
[17:40:09.671]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.671]                           inherits = FALSE)) {
[17:40:09.671]                           master <- get("master", mode = "list", 
[17:40:09.671]                             envir = envir, inherits = FALSE)
[17:40:09.671]                           if (inherits(master, c("SOCKnode", 
[17:40:09.671]                             "SOCK0node"))) {
[17:40:09.671]                             sendCondition <<- function(cond) {
[17:40:09.671]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.671]                                 success = TRUE)
[17:40:09.671]                               parallel_sendData(master, data)
[17:40:09.671]                             }
[17:40:09.671]                             return(sendCondition)
[17:40:09.671]                           }
[17:40:09.671]                         }
[17:40:09.671]                         frame <- frame + 1L
[17:40:09.671]                         envir <- sys.frame(frame)
[17:40:09.671]                       }
[17:40:09.671]                     }
[17:40:09.671]                     sendCondition <<- function(cond) NULL
[17:40:09.671]                   }
[17:40:09.671]                 })
[17:40:09.671]                 withCallingHandlers({
[17:40:09.671]                   {
[17:40:09.671]                     stop("Whoops!")
[17:40:09.671]                     1
[17:40:09.671]                   }
[17:40:09.671]                 }, immediateCondition = function(cond) {
[17:40:09.671]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.671]                   sendCondition(cond)
[17:40:09.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.671]                   {
[17:40:09.671]                     inherits <- base::inherits
[17:40:09.671]                     invokeRestart <- base::invokeRestart
[17:40:09.671]                     is.null <- base::is.null
[17:40:09.671]                     muffled <- FALSE
[17:40:09.671]                     if (inherits(cond, "message")) {
[17:40:09.671]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.671]                       if (muffled) 
[17:40:09.671]                         invokeRestart("muffleMessage")
[17:40:09.671]                     }
[17:40:09.671]                     else if (inherits(cond, "warning")) {
[17:40:09.671]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.671]                       if (muffled) 
[17:40:09.671]                         invokeRestart("muffleWarning")
[17:40:09.671]                     }
[17:40:09.671]                     else if (inherits(cond, "condition")) {
[17:40:09.671]                       if (!is.null(pattern)) {
[17:40:09.671]                         computeRestarts <- base::computeRestarts
[17:40:09.671]                         grepl <- base::grepl
[17:40:09.671]                         restarts <- computeRestarts(cond)
[17:40:09.671]                         for (restart in restarts) {
[17:40:09.671]                           name <- restart$name
[17:40:09.671]                           if (is.null(name)) 
[17:40:09.671]                             next
[17:40:09.671]                           if (!grepl(pattern, name)) 
[17:40:09.671]                             next
[17:40:09.671]                           invokeRestart(restart)
[17:40:09.671]                           muffled <- TRUE
[17:40:09.671]                           break
[17:40:09.671]                         }
[17:40:09.671]                       }
[17:40:09.671]                     }
[17:40:09.671]                     invisible(muffled)
[17:40:09.671]                   }
[17:40:09.671]                   muffleCondition(cond)
[17:40:09.671]                 })
[17:40:09.671]             }))
[17:40:09.671]             future::FutureResult(value = ...future.value$value, 
[17:40:09.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.671]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.671]                     ...future.globalenv.names))
[17:40:09.671]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.671]         }, condition = base::local({
[17:40:09.671]             c <- base::c
[17:40:09.671]             inherits <- base::inherits
[17:40:09.671]             invokeRestart <- base::invokeRestart
[17:40:09.671]             length <- base::length
[17:40:09.671]             list <- base::list
[17:40:09.671]             seq.int <- base::seq.int
[17:40:09.671]             signalCondition <- base::signalCondition
[17:40:09.671]             sys.calls <- base::sys.calls
[17:40:09.671]             `[[` <- base::`[[`
[17:40:09.671]             `+` <- base::`+`
[17:40:09.671]             `<<-` <- base::`<<-`
[17:40:09.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.671]                   3L)]
[17:40:09.671]             }
[17:40:09.671]             function(cond) {
[17:40:09.671]                 is_error <- inherits(cond, "error")
[17:40:09.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.671]                   NULL)
[17:40:09.671]                 if (is_error) {
[17:40:09.671]                   sessionInformation <- function() {
[17:40:09.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.671]                       search = base::search(), system = base::Sys.info())
[17:40:09.671]                   }
[17:40:09.671]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.671]                     cond$call), session = sessionInformation(), 
[17:40:09.671]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.671]                   signalCondition(cond)
[17:40:09.671]                 }
[17:40:09.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.671]                 "immediateCondition"))) {
[17:40:09.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.671]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.671]                   if (TRUE && !signal) {
[17:40:09.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.671]                     {
[17:40:09.671]                       inherits <- base::inherits
[17:40:09.671]                       invokeRestart <- base::invokeRestart
[17:40:09.671]                       is.null <- base::is.null
[17:40:09.671]                       muffled <- FALSE
[17:40:09.671]                       if (inherits(cond, "message")) {
[17:40:09.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.671]                         if (muffled) 
[17:40:09.671]                           invokeRestart("muffleMessage")
[17:40:09.671]                       }
[17:40:09.671]                       else if (inherits(cond, "warning")) {
[17:40:09.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.671]                         if (muffled) 
[17:40:09.671]                           invokeRestart("muffleWarning")
[17:40:09.671]                       }
[17:40:09.671]                       else if (inherits(cond, "condition")) {
[17:40:09.671]                         if (!is.null(pattern)) {
[17:40:09.671]                           computeRestarts <- base::computeRestarts
[17:40:09.671]                           grepl <- base::grepl
[17:40:09.671]                           restarts <- computeRestarts(cond)
[17:40:09.671]                           for (restart in restarts) {
[17:40:09.671]                             name <- restart$name
[17:40:09.671]                             if (is.null(name)) 
[17:40:09.671]                               next
[17:40:09.671]                             if (!grepl(pattern, name)) 
[17:40:09.671]                               next
[17:40:09.671]                             invokeRestart(restart)
[17:40:09.671]                             muffled <- TRUE
[17:40:09.671]                             break
[17:40:09.671]                           }
[17:40:09.671]                         }
[17:40:09.671]                       }
[17:40:09.671]                       invisible(muffled)
[17:40:09.671]                     }
[17:40:09.671]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.671]                   }
[17:40:09.671]                 }
[17:40:09.671]                 else {
[17:40:09.671]                   if (TRUE) {
[17:40:09.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.671]                     {
[17:40:09.671]                       inherits <- base::inherits
[17:40:09.671]                       invokeRestart <- base::invokeRestart
[17:40:09.671]                       is.null <- base::is.null
[17:40:09.671]                       muffled <- FALSE
[17:40:09.671]                       if (inherits(cond, "message")) {
[17:40:09.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.671]                         if (muffled) 
[17:40:09.671]                           invokeRestart("muffleMessage")
[17:40:09.671]                       }
[17:40:09.671]                       else if (inherits(cond, "warning")) {
[17:40:09.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.671]                         if (muffled) 
[17:40:09.671]                           invokeRestart("muffleWarning")
[17:40:09.671]                       }
[17:40:09.671]                       else if (inherits(cond, "condition")) {
[17:40:09.671]                         if (!is.null(pattern)) {
[17:40:09.671]                           computeRestarts <- base::computeRestarts
[17:40:09.671]                           grepl <- base::grepl
[17:40:09.671]                           restarts <- computeRestarts(cond)
[17:40:09.671]                           for (restart in restarts) {
[17:40:09.671]                             name <- restart$name
[17:40:09.671]                             if (is.null(name)) 
[17:40:09.671]                               next
[17:40:09.671]                             if (!grepl(pattern, name)) 
[17:40:09.671]                               next
[17:40:09.671]                             invokeRestart(restart)
[17:40:09.671]                             muffled <- TRUE
[17:40:09.671]                             break
[17:40:09.671]                           }
[17:40:09.671]                         }
[17:40:09.671]                       }
[17:40:09.671]                       invisible(muffled)
[17:40:09.671]                     }
[17:40:09.671]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.671]                   }
[17:40:09.671]                 }
[17:40:09.671]             }
[17:40:09.671]         }))
[17:40:09.671]     }, error = function(ex) {
[17:40:09.671]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.671]                 ...future.rng), started = ...future.startTime, 
[17:40:09.671]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.671]             version = "1.8"), class = "FutureResult")
[17:40:09.671]     }, finally = {
[17:40:09.671]         if (!identical(...future.workdir, getwd())) 
[17:40:09.671]             setwd(...future.workdir)
[17:40:09.671]         {
[17:40:09.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.671]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.671]             }
[17:40:09.671]             base::options(...future.oldOptions)
[17:40:09.671]             if (.Platform$OS.type == "windows") {
[17:40:09.671]                 old_names <- names(...future.oldEnvVars)
[17:40:09.671]                 envs <- base::Sys.getenv()
[17:40:09.671]                 names <- names(envs)
[17:40:09.671]                 common <- intersect(names, old_names)
[17:40:09.671]                 added <- setdiff(names, old_names)
[17:40:09.671]                 removed <- setdiff(old_names, names)
[17:40:09.671]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.671]                   envs[common]]
[17:40:09.671]                 NAMES <- toupper(changed)
[17:40:09.671]                 args <- list()
[17:40:09.671]                 for (kk in seq_along(NAMES)) {
[17:40:09.671]                   name <- changed[[kk]]
[17:40:09.671]                   NAME <- NAMES[[kk]]
[17:40:09.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.671]                     next
[17:40:09.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.671]                 }
[17:40:09.671]                 NAMES <- toupper(added)
[17:40:09.671]                 for (kk in seq_along(NAMES)) {
[17:40:09.671]                   name <- added[[kk]]
[17:40:09.671]                   NAME <- NAMES[[kk]]
[17:40:09.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.671]                     next
[17:40:09.671]                   args[[name]] <- ""
[17:40:09.671]                 }
[17:40:09.671]                 NAMES <- toupper(removed)
[17:40:09.671]                 for (kk in seq_along(NAMES)) {
[17:40:09.671]                   name <- removed[[kk]]
[17:40:09.671]                   NAME <- NAMES[[kk]]
[17:40:09.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.671]                     next
[17:40:09.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.671]                 }
[17:40:09.671]                 if (length(args) > 0) 
[17:40:09.671]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.671]             }
[17:40:09.671]             else {
[17:40:09.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.671]             }
[17:40:09.671]             {
[17:40:09.671]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.671]                   0L) {
[17:40:09.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.671]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.671]                   base::options(opts)
[17:40:09.671]                 }
[17:40:09.671]                 {
[17:40:09.671]                   {
[17:40:09.671]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.671]                     NULL
[17:40:09.671]                   }
[17:40:09.671]                   options(future.plan = NULL)
[17:40:09.671]                   if (is.na(NA_character_)) 
[17:40:09.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.671]                     .init = FALSE)
[17:40:09.671]                 }
[17:40:09.671]             }
[17:40:09.671]         }
[17:40:09.671]     })
[17:40:09.671]     if (TRUE) {
[17:40:09.671]         base::sink(type = "output", split = FALSE)
[17:40:09.671]         if (TRUE) {
[17:40:09.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.671]         }
[17:40:09.671]         else {
[17:40:09.671]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.671]         }
[17:40:09.671]         base::close(...future.stdout)
[17:40:09.671]         ...future.stdout <- NULL
[17:40:09.671]     }
[17:40:09.671]     ...future.result$conditions <- ...future.conditions
[17:40:09.671]     ...future.result$finished <- base::Sys.time()
[17:40:09.671]     ...future.result
[17:40:09.671] }
[17:40:09.674] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:09.677] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.677] - Validating connection of MultisessionFuture
[17:40:09.677] - received message: FutureResult
[17:40:09.678] - Received FutureResult
[17:40:09.678] - Erased future from FutureRegistry
[17:40:09.678] result() for ClusterFuture ...
[17:40:09.678] - result already collected: FutureResult
[17:40:09.678] result() for ClusterFuture ... done
[17:40:09.678] signalConditions() ...
[17:40:09.678]  - include = ‘immediateCondition’
[17:40:09.678]  - exclude = 
[17:40:09.678]  - resignal = FALSE
[17:40:09.678]  - Number of conditions: 1
[17:40:09.678] signalConditions() ... done
[17:40:09.679] receiveMessageFromWorker() for ClusterFuture ... done
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:09.679] result() for ClusterFuture ...
[17:40:09.679] - result already collected: FutureResult
[17:40:09.679] result() for ClusterFuture ... done
[17:40:09.679] result() for ClusterFuture ...
[17:40:09.679] - result already collected: FutureResult
[17:40:09.679] result() for ClusterFuture ... done
[17:40:09.679] signalConditions() ...
[17:40:09.679]  - include = ‘immediateCondition’
[17:40:09.679]  - exclude = 
[17:40:09.679]  - resignal = FALSE
[17:40:09.679]  - Number of conditions: 1
[17:40:09.680] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:40:09.680] result() for ClusterFuture ...
[17:40:09.680] - result already collected: FutureResult
[17:40:09.680] result() for ClusterFuture ... done
[17:40:09.680] result() for ClusterFuture ...
[17:40:09.680] - result already collected: FutureResult
[17:40:09.680] result() for ClusterFuture ... done
[17:40:09.681] signalConditions() ...
[17:40:09.681]  - include = ‘immediateCondition’
[17:40:09.681]  - exclude = 
[17:40:09.681]  - resignal = FALSE
[17:40:09.681]  - Number of conditions: 1
[17:40:09.681] signalConditions() ... done
[17:40:09.681] Future state: ‘finished’
[17:40:09.681] result() for ClusterFuture ...
[17:40:09.681] - result already collected: FutureResult
[17:40:09.681] result() for ClusterFuture ... done
[17:40:09.681] signalConditions() ...
[17:40:09.681]  - include = ‘condition’
[17:40:09.682]  - exclude = ‘immediateCondition’
[17:40:09.682]  - resignal = TRUE
[17:40:09.682]  - Number of conditions: 1
[17:40:09.682]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:40:09.682] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:40:09.682] result() for ClusterFuture ...
[17:40:09.683] - result already collected: FutureResult
[17:40:09.683] result() for ClusterFuture ... done
[17:40:09.683] result() for ClusterFuture ...
[17:40:09.683] - result already collected: FutureResult
[17:40:09.683] result() for ClusterFuture ... done
[17:40:09.683] signalConditions() ...
[17:40:09.683]  - include = ‘immediateCondition’
[17:40:09.683]  - exclude = 
[17:40:09.683]  - resignal = FALSE
[17:40:09.683]  - Number of conditions: 1
[17:40:09.683] signalConditions() ... done
[17:40:09.683] Future state: ‘finished’
[17:40:09.684] result() for ClusterFuture ...
[17:40:09.684] - result already collected: FutureResult
[17:40:09.684] result() for ClusterFuture ... done
[17:40:09.684] signalConditions() ...
[17:40:09.684]  - include = ‘condition’
[17:40:09.684]  - exclude = ‘immediateCondition’
[17:40:09.684]  - resignal = TRUE
[17:40:09.684]  - Number of conditions: 1
[17:40:09.684]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:40:09.684] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[17:40:09.688] getGlobalsAndPackages() ...
[17:40:09.688] 
[17:40:09.688] - globals: [0] <none>
[17:40:09.688] getGlobalsAndPackages() ... DONE
[17:40:09.699] Packages needed by the future expression (n = 0): <none>
[17:40:09.699] Packages needed by future strategies (n = 0): <none>
[17:40:09.699] {
[17:40:09.699]     {
[17:40:09.699]         {
[17:40:09.699]             ...future.startTime <- base::Sys.time()
[17:40:09.699]             {
[17:40:09.699]                 {
[17:40:09.699]                   {
[17:40:09.699]                     {
[17:40:09.699]                       base::local({
[17:40:09.699]                         has_future <- base::requireNamespace("future", 
[17:40:09.699]                           quietly = TRUE)
[17:40:09.699]                         if (has_future) {
[17:40:09.699]                           ns <- base::getNamespace("future")
[17:40:09.699]                           version <- ns[[".package"]][["version"]]
[17:40:09.699]                           if (is.null(version)) 
[17:40:09.699]                             version <- utils::packageVersion("future")
[17:40:09.699]                         }
[17:40:09.699]                         else {
[17:40:09.699]                           version <- NULL
[17:40:09.699]                         }
[17:40:09.699]                         if (!has_future || version < "1.8.0") {
[17:40:09.699]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.699]                             "", base::R.version$version.string), 
[17:40:09.699]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.699]                               "release", "version")], collapse = " "), 
[17:40:09.699]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.699]                             info)
[17:40:09.699]                           info <- base::paste(info, collapse = "; ")
[17:40:09.699]                           if (!has_future) {
[17:40:09.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.699]                               info)
[17:40:09.699]                           }
[17:40:09.699]                           else {
[17:40:09.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.699]                               info, version)
[17:40:09.699]                           }
[17:40:09.699]                           base::stop(msg)
[17:40:09.699]                         }
[17:40:09.699]                       })
[17:40:09.699]                     }
[17:40:09.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.699]                     base::options(mc.cores = 1L)
[17:40:09.699]                   }
[17:40:09.699]                   ...future.strategy.old <- future::plan("list")
[17:40:09.699]                   options(future.plan = NULL)
[17:40:09.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.699]                 }
[17:40:09.699]                 ...future.workdir <- getwd()
[17:40:09.699]             }
[17:40:09.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.699]         }
[17:40:09.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.699]             base::names(...future.oldOptions))
[17:40:09.699]     }
[17:40:09.699]     if (FALSE) {
[17:40:09.699]     }
[17:40:09.699]     else {
[17:40:09.699]         if (TRUE) {
[17:40:09.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.699]                 open = "w")
[17:40:09.699]         }
[17:40:09.699]         else {
[17:40:09.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.699]         }
[17:40:09.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.699]             base::sink(type = "output", split = FALSE)
[17:40:09.699]             base::close(...future.stdout)
[17:40:09.699]         }, add = TRUE)
[17:40:09.699]     }
[17:40:09.699]     ...future.frame <- base::sys.nframe()
[17:40:09.699]     ...future.conditions <- base::list()
[17:40:09.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.699]     if (FALSE) {
[17:40:09.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.699]     }
[17:40:09.699]     ...future.result <- base::tryCatch({
[17:40:09.699]         base::withCallingHandlers({
[17:40:09.699]             ...future.value <- base::withVisible(base::local({
[17:40:09.699]                 ...future.makeSendCondition <- base::local({
[17:40:09.699]                   sendCondition <- NULL
[17:40:09.699]                   function(frame = 1L) {
[17:40:09.699]                     if (is.function(sendCondition)) 
[17:40:09.699]                       return(sendCondition)
[17:40:09.699]                     ns <- getNamespace("parallel")
[17:40:09.699]                     if (exists("sendData", mode = "function", 
[17:40:09.699]                       envir = ns)) {
[17:40:09.699]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.699]                         envir = ns)
[17:40:09.699]                       envir <- sys.frame(frame)
[17:40:09.699]                       master <- NULL
[17:40:09.699]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.699]                         !identical(envir, emptyenv())) {
[17:40:09.699]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.699]                           inherits = FALSE)) {
[17:40:09.699]                           master <- get("master", mode = "list", 
[17:40:09.699]                             envir = envir, inherits = FALSE)
[17:40:09.699]                           if (inherits(master, c("SOCKnode", 
[17:40:09.699]                             "SOCK0node"))) {
[17:40:09.699]                             sendCondition <<- function(cond) {
[17:40:09.699]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.699]                                 success = TRUE)
[17:40:09.699]                               parallel_sendData(master, data)
[17:40:09.699]                             }
[17:40:09.699]                             return(sendCondition)
[17:40:09.699]                           }
[17:40:09.699]                         }
[17:40:09.699]                         frame <- frame + 1L
[17:40:09.699]                         envir <- sys.frame(frame)
[17:40:09.699]                       }
[17:40:09.699]                     }
[17:40:09.699]                     sendCondition <<- function(cond) NULL
[17:40:09.699]                   }
[17:40:09.699]                 })
[17:40:09.699]                 withCallingHandlers({
[17:40:09.699]                   {
[17:40:09.699]                     stop(structure(list(message = "boom"), class = c("MyError", 
[17:40:09.699]                       "error", "condition")))
[17:40:09.699]                   }
[17:40:09.699]                 }, immediateCondition = function(cond) {
[17:40:09.699]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.699]                   sendCondition(cond)
[17:40:09.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.699]                   {
[17:40:09.699]                     inherits <- base::inherits
[17:40:09.699]                     invokeRestart <- base::invokeRestart
[17:40:09.699]                     is.null <- base::is.null
[17:40:09.699]                     muffled <- FALSE
[17:40:09.699]                     if (inherits(cond, "message")) {
[17:40:09.699]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.699]                       if (muffled) 
[17:40:09.699]                         invokeRestart("muffleMessage")
[17:40:09.699]                     }
[17:40:09.699]                     else if (inherits(cond, "warning")) {
[17:40:09.699]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.699]                       if (muffled) 
[17:40:09.699]                         invokeRestart("muffleWarning")
[17:40:09.699]                     }
[17:40:09.699]                     else if (inherits(cond, "condition")) {
[17:40:09.699]                       if (!is.null(pattern)) {
[17:40:09.699]                         computeRestarts <- base::computeRestarts
[17:40:09.699]                         grepl <- base::grepl
[17:40:09.699]                         restarts <- computeRestarts(cond)
[17:40:09.699]                         for (restart in restarts) {
[17:40:09.699]                           name <- restart$name
[17:40:09.699]                           if (is.null(name)) 
[17:40:09.699]                             next
[17:40:09.699]                           if (!grepl(pattern, name)) 
[17:40:09.699]                             next
[17:40:09.699]                           invokeRestart(restart)
[17:40:09.699]                           muffled <- TRUE
[17:40:09.699]                           break
[17:40:09.699]                         }
[17:40:09.699]                       }
[17:40:09.699]                     }
[17:40:09.699]                     invisible(muffled)
[17:40:09.699]                   }
[17:40:09.699]                   muffleCondition(cond)
[17:40:09.699]                 })
[17:40:09.699]             }))
[17:40:09.699]             future::FutureResult(value = ...future.value$value, 
[17:40:09.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.699]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.699]                     ...future.globalenv.names))
[17:40:09.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.699]         }, condition = base::local({
[17:40:09.699]             c <- base::c
[17:40:09.699]             inherits <- base::inherits
[17:40:09.699]             invokeRestart <- base::invokeRestart
[17:40:09.699]             length <- base::length
[17:40:09.699]             list <- base::list
[17:40:09.699]             seq.int <- base::seq.int
[17:40:09.699]             signalCondition <- base::signalCondition
[17:40:09.699]             sys.calls <- base::sys.calls
[17:40:09.699]             `[[` <- base::`[[`
[17:40:09.699]             `+` <- base::`+`
[17:40:09.699]             `<<-` <- base::`<<-`
[17:40:09.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.699]                   3L)]
[17:40:09.699]             }
[17:40:09.699]             function(cond) {
[17:40:09.699]                 is_error <- inherits(cond, "error")
[17:40:09.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.699]                   NULL)
[17:40:09.699]                 if (is_error) {
[17:40:09.699]                   sessionInformation <- function() {
[17:40:09.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.699]                       search = base::search(), system = base::Sys.info())
[17:40:09.699]                   }
[17:40:09.699]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.699]                     cond$call), session = sessionInformation(), 
[17:40:09.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.699]                   signalCondition(cond)
[17:40:09.699]                 }
[17:40:09.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.699]                 "immediateCondition"))) {
[17:40:09.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.699]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.699]                   if (TRUE && !signal) {
[17:40:09.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.699]                     {
[17:40:09.699]                       inherits <- base::inherits
[17:40:09.699]                       invokeRestart <- base::invokeRestart
[17:40:09.699]                       is.null <- base::is.null
[17:40:09.699]                       muffled <- FALSE
[17:40:09.699]                       if (inherits(cond, "message")) {
[17:40:09.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.699]                         if (muffled) 
[17:40:09.699]                           invokeRestart("muffleMessage")
[17:40:09.699]                       }
[17:40:09.699]                       else if (inherits(cond, "warning")) {
[17:40:09.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.699]                         if (muffled) 
[17:40:09.699]                           invokeRestart("muffleWarning")
[17:40:09.699]                       }
[17:40:09.699]                       else if (inherits(cond, "condition")) {
[17:40:09.699]                         if (!is.null(pattern)) {
[17:40:09.699]                           computeRestarts <- base::computeRestarts
[17:40:09.699]                           grepl <- base::grepl
[17:40:09.699]                           restarts <- computeRestarts(cond)
[17:40:09.699]                           for (restart in restarts) {
[17:40:09.699]                             name <- restart$name
[17:40:09.699]                             if (is.null(name)) 
[17:40:09.699]                               next
[17:40:09.699]                             if (!grepl(pattern, name)) 
[17:40:09.699]                               next
[17:40:09.699]                             invokeRestart(restart)
[17:40:09.699]                             muffled <- TRUE
[17:40:09.699]                             break
[17:40:09.699]                           }
[17:40:09.699]                         }
[17:40:09.699]                       }
[17:40:09.699]                       invisible(muffled)
[17:40:09.699]                     }
[17:40:09.699]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.699]                   }
[17:40:09.699]                 }
[17:40:09.699]                 else {
[17:40:09.699]                   if (TRUE) {
[17:40:09.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.699]                     {
[17:40:09.699]                       inherits <- base::inherits
[17:40:09.699]                       invokeRestart <- base::invokeRestart
[17:40:09.699]                       is.null <- base::is.null
[17:40:09.699]                       muffled <- FALSE
[17:40:09.699]                       if (inherits(cond, "message")) {
[17:40:09.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.699]                         if (muffled) 
[17:40:09.699]                           invokeRestart("muffleMessage")
[17:40:09.699]                       }
[17:40:09.699]                       else if (inherits(cond, "warning")) {
[17:40:09.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.699]                         if (muffled) 
[17:40:09.699]                           invokeRestart("muffleWarning")
[17:40:09.699]                       }
[17:40:09.699]                       else if (inherits(cond, "condition")) {
[17:40:09.699]                         if (!is.null(pattern)) {
[17:40:09.699]                           computeRestarts <- base::computeRestarts
[17:40:09.699]                           grepl <- base::grepl
[17:40:09.699]                           restarts <- computeRestarts(cond)
[17:40:09.699]                           for (restart in restarts) {
[17:40:09.699]                             name <- restart$name
[17:40:09.699]                             if (is.null(name)) 
[17:40:09.699]                               next
[17:40:09.699]                             if (!grepl(pattern, name)) 
[17:40:09.699]                               next
[17:40:09.699]                             invokeRestart(restart)
[17:40:09.699]                             muffled <- TRUE
[17:40:09.699]                             break
[17:40:09.699]                           }
[17:40:09.699]                         }
[17:40:09.699]                       }
[17:40:09.699]                       invisible(muffled)
[17:40:09.699]                     }
[17:40:09.699]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.699]                   }
[17:40:09.699]                 }
[17:40:09.699]             }
[17:40:09.699]         }))
[17:40:09.699]     }, error = function(ex) {
[17:40:09.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.699]                 ...future.rng), started = ...future.startTime, 
[17:40:09.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.699]             version = "1.8"), class = "FutureResult")
[17:40:09.699]     }, finally = {
[17:40:09.699]         if (!identical(...future.workdir, getwd())) 
[17:40:09.699]             setwd(...future.workdir)
[17:40:09.699]         {
[17:40:09.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.699]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.699]             }
[17:40:09.699]             base::options(...future.oldOptions)
[17:40:09.699]             if (.Platform$OS.type == "windows") {
[17:40:09.699]                 old_names <- names(...future.oldEnvVars)
[17:40:09.699]                 envs <- base::Sys.getenv()
[17:40:09.699]                 names <- names(envs)
[17:40:09.699]                 common <- intersect(names, old_names)
[17:40:09.699]                 added <- setdiff(names, old_names)
[17:40:09.699]                 removed <- setdiff(old_names, names)
[17:40:09.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.699]                   envs[common]]
[17:40:09.699]                 NAMES <- toupper(changed)
[17:40:09.699]                 args <- list()
[17:40:09.699]                 for (kk in seq_along(NAMES)) {
[17:40:09.699]                   name <- changed[[kk]]
[17:40:09.699]                   NAME <- NAMES[[kk]]
[17:40:09.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.699]                     next
[17:40:09.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.699]                 }
[17:40:09.699]                 NAMES <- toupper(added)
[17:40:09.699]                 for (kk in seq_along(NAMES)) {
[17:40:09.699]                   name <- added[[kk]]
[17:40:09.699]                   NAME <- NAMES[[kk]]
[17:40:09.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.699]                     next
[17:40:09.699]                   args[[name]] <- ""
[17:40:09.699]                 }
[17:40:09.699]                 NAMES <- toupper(removed)
[17:40:09.699]                 for (kk in seq_along(NAMES)) {
[17:40:09.699]                   name <- removed[[kk]]
[17:40:09.699]                   NAME <- NAMES[[kk]]
[17:40:09.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.699]                     next
[17:40:09.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.699]                 }
[17:40:09.699]                 if (length(args) > 0) 
[17:40:09.699]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.699]             }
[17:40:09.699]             else {
[17:40:09.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.699]             }
[17:40:09.699]             {
[17:40:09.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.699]                   0L) {
[17:40:09.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.699]                   base::options(opts)
[17:40:09.699]                 }
[17:40:09.699]                 {
[17:40:09.699]                   {
[17:40:09.699]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.699]                     NULL
[17:40:09.699]                   }
[17:40:09.699]                   options(future.plan = NULL)
[17:40:09.699]                   if (is.na(NA_character_)) 
[17:40:09.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.699]                     .init = FALSE)
[17:40:09.699]                 }
[17:40:09.699]             }
[17:40:09.699]         }
[17:40:09.699]     })
[17:40:09.699]     if (TRUE) {
[17:40:09.699]         base::sink(type = "output", split = FALSE)
[17:40:09.699]         if (TRUE) {
[17:40:09.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.699]         }
[17:40:09.699]         else {
[17:40:09.699]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.699]         }
[17:40:09.699]         base::close(...future.stdout)
[17:40:09.699]         ...future.stdout <- NULL
[17:40:09.699]     }
[17:40:09.699]     ...future.result$conditions <- ...future.conditions
[17:40:09.699]     ...future.result$finished <- base::Sys.time()
[17:40:09.699]     ...future.result
[17:40:09.699] }
[17:40:09.702] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:09.704] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.704] - Validating connection of MultisessionFuture
[17:40:09.705] - received message: FutureResult
[17:40:09.705] - Received FutureResult
[17:40:09.705] - Erased future from FutureRegistry
[17:40:09.705] result() for ClusterFuture ...
[17:40:09.705] - result already collected: FutureResult
[17:40:09.705] result() for ClusterFuture ... done
[17:40:09.705] signalConditions() ...
[17:40:09.706]  - include = ‘immediateCondition’
[17:40:09.706]  - exclude = 
[17:40:09.706]  - resignal = FALSE
[17:40:09.706]  - Number of conditions: 1
[17:40:09.706] signalConditions() ... done
[17:40:09.706] receiveMessageFromWorker() for ClusterFuture ... done
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:09.706] result() for ClusterFuture ...
[17:40:09.706] - result already collected: FutureResult
[17:40:09.707] result() for ClusterFuture ... done
[17:40:09.707] result() for ClusterFuture ...
[17:40:09.707] - result already collected: FutureResult
[17:40:09.707] result() for ClusterFuture ... done
[17:40:09.707] signalConditions() ...
[17:40:09.707]  - include = ‘immediateCondition’
[17:40:09.707]  - exclude = 
[17:40:09.707]  - resignal = FALSE
[17:40:09.707]  - Number of conditions: 1
[17:40:09.707] signalConditions() ... done
<MyError: boom>
[17:40:09.708] result() for ClusterFuture ...
[17:40:09.708] - result already collected: FutureResult
[17:40:09.708] result() for ClusterFuture ... done
[17:40:09.708] result() for ClusterFuture ...
[17:40:09.708] - result already collected: FutureResult
[17:40:09.708] result() for ClusterFuture ... done
[17:40:09.708] signalConditions() ...
[17:40:09.708]  - include = ‘immediateCondition’
[17:40:09.708]  - exclude = 
[17:40:09.709]  - resignal = FALSE
[17:40:09.709]  - Number of conditions: 1
[17:40:09.709] signalConditions() ... done
[17:40:09.709] Future state: ‘finished’
[17:40:09.709] result() for ClusterFuture ...
[17:40:09.709] - result already collected: FutureResult
[17:40:09.709] result() for ClusterFuture ... done
[17:40:09.709] signalConditions() ...
[17:40:09.709]  - include = ‘condition’
[17:40:09.709]  - exclude = ‘immediateCondition’
[17:40:09.709]  - resignal = TRUE
[17:40:09.710]  - Number of conditions: 1
[17:40:09.710]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[17:40:09.710] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ...")
*** multisession() - too large globals ...
> ooptsT <- options(future.globals.maxSize = object.size(1:1014))
> 
> limit <- getOption("future.globals.maxSize")
> cat(sprintf("Max total size of globals: %g bytes\n", limit))
Max total size of globals: 4104 bytes
> 
> for (workers in unique(c(1L, availableCores()))) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message("Max number of sessions: ", workers)
+ 
+   ## A large object
+   a <- 1:1014
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   f <- multisession({ sum(a) }, globals = TRUE, workers = workers)
+   print(f)
+   rm(list = "a")
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+ 
+   ## A too large object
+   a <- 1:1015
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   res <- try(f <- multisession({ sum(a) }, globals = TRUE, workers = workers), silent = TRUE)
+   rm(list = "a")
+   stopifnot(inherits(res, "try-error"))
+ } ## for (workers in ...)
Max number of sessions: 1
a: 4104 bytes
[17:40:09.728] getGlobalsAndPackages() ...
[17:40:09.728] Searching for globals...
[17:40:09.729] - globals found: [3] ‘{’, ‘sum’, ‘a’
[17:40:09.730] Searching for globals ... DONE
[17:40:09.730] Resolving globals: FALSE
[17:40:09.730] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[17:40:09.731] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[17:40:09.731] - globals: [1] ‘a’
[17:40:09.731] 
[17:40:09.732] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:09.733] Packages needed by the future expression (n = 0): <none>
[17:40:09.733] Packages needed by future strategies (n = 0): <none>
[17:40:09.733] {
[17:40:09.733]     {
[17:40:09.733]         {
[17:40:09.733]             ...future.startTime <- base::Sys.time()
[17:40:09.733]             {
[17:40:09.733]                 {
[17:40:09.733]                   {
[17:40:09.733]                     base::local({
[17:40:09.733]                       has_future <- base::requireNamespace("future", 
[17:40:09.733]                         quietly = TRUE)
[17:40:09.733]                       if (has_future) {
[17:40:09.733]                         ns <- base::getNamespace("future")
[17:40:09.733]                         version <- ns[[".package"]][["version"]]
[17:40:09.733]                         if (is.null(version)) 
[17:40:09.733]                           version <- utils::packageVersion("future")
[17:40:09.733]                       }
[17:40:09.733]                       else {
[17:40:09.733]                         version <- NULL
[17:40:09.733]                       }
[17:40:09.733]                       if (!has_future || version < "1.8.0") {
[17:40:09.733]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.733]                           "", base::R.version$version.string), 
[17:40:09.733]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:09.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.733]                             "release", "version")], collapse = " "), 
[17:40:09.733]                           hostname = base::Sys.info()[["nodename"]])
[17:40:09.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.733]                           info)
[17:40:09.733]                         info <- base::paste(info, collapse = "; ")
[17:40:09.733]                         if (!has_future) {
[17:40:09.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.733]                             info)
[17:40:09.733]                         }
[17:40:09.733]                         else {
[17:40:09.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.733]                             info, version)
[17:40:09.733]                         }
[17:40:09.733]                         base::stop(msg)
[17:40:09.733]                       }
[17:40:09.733]                     })
[17:40:09.733]                   }
[17:40:09.733]                   ...future.strategy.old <- future::plan("list")
[17:40:09.733]                   options(future.plan = NULL)
[17:40:09.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.733]                 }
[17:40:09.733]                 ...future.workdir <- getwd()
[17:40:09.733]             }
[17:40:09.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.733]         }
[17:40:09.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.733]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[17:40:09.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.733]             base::names(...future.oldOptions))
[17:40:09.733]     }
[17:40:09.733]     if (FALSE) {
[17:40:09.733]     }
[17:40:09.733]     else {
[17:40:09.733]         if (TRUE) {
[17:40:09.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.733]                 open = "w")
[17:40:09.733]         }
[17:40:09.733]         else {
[17:40:09.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.733]         }
[17:40:09.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.733]             base::sink(type = "output", split = FALSE)
[17:40:09.733]             base::close(...future.stdout)
[17:40:09.733]         }, add = TRUE)
[17:40:09.733]     }
[17:40:09.733]     ...future.frame <- base::sys.nframe()
[17:40:09.733]     ...future.conditions <- base::list()
[17:40:09.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.733]     if (FALSE) {
[17:40:09.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.733]     }
[17:40:09.733]     ...future.result <- base::tryCatch({
[17:40:09.733]         base::withCallingHandlers({
[17:40:09.733]             ...future.value <- base::withVisible(base::local({
[17:40:09.733]                 sum(a)
[17:40:09.733]             }))
[17:40:09.733]             future::FutureResult(value = ...future.value$value, 
[17:40:09.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.733]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.733]                     ...future.globalenv.names))
[17:40:09.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.733]         }, condition = base::local({
[17:40:09.733]             c <- base::c
[17:40:09.733]             inherits <- base::inherits
[17:40:09.733]             invokeRestart <- base::invokeRestart
[17:40:09.733]             length <- base::length
[17:40:09.733]             list <- base::list
[17:40:09.733]             seq.int <- base::seq.int
[17:40:09.733]             signalCondition <- base::signalCondition
[17:40:09.733]             sys.calls <- base::sys.calls
[17:40:09.733]             `[[` <- base::`[[`
[17:40:09.733]             `+` <- base::`+`
[17:40:09.733]             `<<-` <- base::`<<-`
[17:40:09.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.733]                   3L)]
[17:40:09.733]             }
[17:40:09.733]             function(cond) {
[17:40:09.733]                 is_error <- inherits(cond, "error")
[17:40:09.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.733]                   NULL)
[17:40:09.733]                 if (is_error) {
[17:40:09.733]                   sessionInformation <- function() {
[17:40:09.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.733]                       search = base::search(), system = base::Sys.info())
[17:40:09.733]                   }
[17:40:09.733]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.733]                     cond$call), session = sessionInformation(), 
[17:40:09.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.733]                   signalCondition(cond)
[17:40:09.733]                 }
[17:40:09.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.733]                 "immediateCondition"))) {
[17:40:09.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.733]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.733]                   if (TRUE && !signal) {
[17:40:09.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.733]                     {
[17:40:09.733]                       inherits <- base::inherits
[17:40:09.733]                       invokeRestart <- base::invokeRestart
[17:40:09.733]                       is.null <- base::is.null
[17:40:09.733]                       muffled <- FALSE
[17:40:09.733]                       if (inherits(cond, "message")) {
[17:40:09.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.733]                         if (muffled) 
[17:40:09.733]                           invokeRestart("muffleMessage")
[17:40:09.733]                       }
[17:40:09.733]                       else if (inherits(cond, "warning")) {
[17:40:09.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.733]                         if (muffled) 
[17:40:09.733]                           invokeRestart("muffleWarning")
[17:40:09.733]                       }
[17:40:09.733]                       else if (inherits(cond, "condition")) {
[17:40:09.733]                         if (!is.null(pattern)) {
[17:40:09.733]                           computeRestarts <- base::computeRestarts
[17:40:09.733]                           grepl <- base::grepl
[17:40:09.733]                           restarts <- computeRestarts(cond)
[17:40:09.733]                           for (restart in restarts) {
[17:40:09.733]                             name <- restart$name
[17:40:09.733]                             if (is.null(name)) 
[17:40:09.733]                               next
[17:40:09.733]                             if (!grepl(pattern, name)) 
[17:40:09.733]                               next
[17:40:09.733]                             invokeRestart(restart)
[17:40:09.733]                             muffled <- TRUE
[17:40:09.733]                             break
[17:40:09.733]                           }
[17:40:09.733]                         }
[17:40:09.733]                       }
[17:40:09.733]                       invisible(muffled)
[17:40:09.733]                     }
[17:40:09.733]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.733]                   }
[17:40:09.733]                 }
[17:40:09.733]                 else {
[17:40:09.733]                   if (TRUE) {
[17:40:09.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.733]                     {
[17:40:09.733]                       inherits <- base::inherits
[17:40:09.733]                       invokeRestart <- base::invokeRestart
[17:40:09.733]                       is.null <- base::is.null
[17:40:09.733]                       muffled <- FALSE
[17:40:09.733]                       if (inherits(cond, "message")) {
[17:40:09.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.733]                         if (muffled) 
[17:40:09.733]                           invokeRestart("muffleMessage")
[17:40:09.733]                       }
[17:40:09.733]                       else if (inherits(cond, "warning")) {
[17:40:09.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.733]                         if (muffled) 
[17:40:09.733]                           invokeRestart("muffleWarning")
[17:40:09.733]                       }
[17:40:09.733]                       else if (inherits(cond, "condition")) {
[17:40:09.733]                         if (!is.null(pattern)) {
[17:40:09.733]                           computeRestarts <- base::computeRestarts
[17:40:09.733]                           grepl <- base::grepl
[17:40:09.733]                           restarts <- computeRestarts(cond)
[17:40:09.733]                           for (restart in restarts) {
[17:40:09.733]                             name <- restart$name
[17:40:09.733]                             if (is.null(name)) 
[17:40:09.733]                               next
[17:40:09.733]                             if (!grepl(pattern, name)) 
[17:40:09.733]                               next
[17:40:09.733]                             invokeRestart(restart)
[17:40:09.733]                             muffled <- TRUE
[17:40:09.733]                             break
[17:40:09.733]                           }
[17:40:09.733]                         }
[17:40:09.733]                       }
[17:40:09.733]                       invisible(muffled)
[17:40:09.733]                     }
[17:40:09.733]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.733]                   }
[17:40:09.733]                 }
[17:40:09.733]             }
[17:40:09.733]         }))
[17:40:09.733]     }, error = function(ex) {
[17:40:09.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.733]                 ...future.rng), started = ...future.startTime, 
[17:40:09.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.733]             version = "1.8"), class = "FutureResult")
[17:40:09.733]     }, finally = {
[17:40:09.733]         if (!identical(...future.workdir, getwd())) 
[17:40:09.733]             setwd(...future.workdir)
[17:40:09.733]         {
[17:40:09.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.733]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.733]             }
[17:40:09.733]             base::options(...future.oldOptions)
[17:40:09.733]             if (.Platform$OS.type == "windows") {
[17:40:09.733]                 old_names <- names(...future.oldEnvVars)
[17:40:09.733]                 envs <- base::Sys.getenv()
[17:40:09.733]                 names <- names(envs)
[17:40:09.733]                 common <- intersect(names, old_names)
[17:40:09.733]                 added <- setdiff(names, old_names)
[17:40:09.733]                 removed <- setdiff(old_names, names)
[17:40:09.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.733]                   envs[common]]
[17:40:09.733]                 NAMES <- toupper(changed)
[17:40:09.733]                 args <- list()
[17:40:09.733]                 for (kk in seq_along(NAMES)) {
[17:40:09.733]                   name <- changed[[kk]]
[17:40:09.733]                   NAME <- NAMES[[kk]]
[17:40:09.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.733]                     next
[17:40:09.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.733]                 }
[17:40:09.733]                 NAMES <- toupper(added)
[17:40:09.733]                 for (kk in seq_along(NAMES)) {
[17:40:09.733]                   name <- added[[kk]]
[17:40:09.733]                   NAME <- NAMES[[kk]]
[17:40:09.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.733]                     next
[17:40:09.733]                   args[[name]] <- ""
[17:40:09.733]                 }
[17:40:09.733]                 NAMES <- toupper(removed)
[17:40:09.733]                 for (kk in seq_along(NAMES)) {
[17:40:09.733]                   name <- removed[[kk]]
[17:40:09.733]                   NAME <- NAMES[[kk]]
[17:40:09.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.733]                     next
[17:40:09.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.733]                 }
[17:40:09.733]                 if (length(args) > 0) 
[17:40:09.733]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.733]             }
[17:40:09.733]             else {
[17:40:09.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.733]             }
[17:40:09.733]             {
[17:40:09.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.733]                   0L) {
[17:40:09.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.733]                   base::options(opts)
[17:40:09.733]                 }
[17:40:09.733]                 {
[17:40:09.733]                   {
[17:40:09.733]                     NULL
[17:40:09.733]                     RNGkind("Mersenne-Twister")
[17:40:09.733]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:09.733]                       inherits = FALSE)
[17:40:09.733]                   }
[17:40:09.733]                   options(future.plan = NULL)
[17:40:09.733]                   if (is.na(NA_character_)) 
[17:40:09.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.733]                     .init = FALSE)
[17:40:09.733]                 }
[17:40:09.733]             }
[17:40:09.733]         }
[17:40:09.733]     })
[17:40:09.733]     if (TRUE) {
[17:40:09.733]         base::sink(type = "output", split = FALSE)
[17:40:09.733]         if (TRUE) {
[17:40:09.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.733]         }
[17:40:09.733]         else {
[17:40:09.733]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.733]         }
[17:40:09.733]         base::close(...future.stdout)
[17:40:09.733]         ...future.stdout <- NULL
[17:40:09.733]     }
[17:40:09.733]     ...future.result$conditions <- ...future.conditions
[17:40:09.733]     ...future.result$finished <- base::Sys.time()
[17:40:09.733]     ...future.result
[17:40:09.733] }
[17:40:09.735] assign_globals() ...
[17:40:09.735] List of 1
[17:40:09.735]  $ a: int [1:1014] 1 2 3 4 5 6 7 8 9 10 ...
[17:40:09.735]  - attr(*, "where")=List of 1
[17:40:09.735]   ..$ a:<environment: R_EmptyEnv> 
[17:40:09.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:09.735]  - attr(*, "resolved")= logi FALSE
[17:40:09.735]  - attr(*, "total_size")= num 4104
[17:40:09.737] - copied ‘a’ to environment
[17:40:09.738] assign_globals() ... done
[17:40:09.738] plan(): Setting new future strategy stack:
[17:40:09.738] List of future strategies:
[17:40:09.738] 1. sequential:
[17:40:09.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:09.738]    - tweaked: FALSE
[17:40:09.738]    - call: NULL
[17:40:09.738] plan(): nbrOfWorkers() = 1
[17:40:09.739] plan(): Setting new future strategy stack:
[17:40:09.739] List of future strategies:
[17:40:09.739] 1. sequential:
[17:40:09.739]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:09.739]    - tweaked: FALSE
[17:40:09.739]    - call: future::plan("sequential")
[17:40:09.740] plan(): nbrOfWorkers() = 1
[17:40:09.740] SequentialFuture started (and completed)
[1] 514605
a: 4112 bytes
[17:40:09.740] getGlobalsAndPackages() ...
[17:40:09.740] Searching for globals...
[17:40:09.741] - globals found: [3] ‘{’, ‘sum’, ‘a’
[17:40:09.741] Searching for globals ... DONE
[17:40:09.741] Resolving globals: FALSE
[17:40:09.742] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[17:40:09.742] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
Max number of sessions: 2
a: 4104 bytes
[17:40:09.743] getGlobalsAndPackages() ...
[17:40:09.743] Searching for globals...
[17:40:09.743] - globals found: [3] ‘{’, ‘sum’, ‘a’
[17:40:09.744] Searching for globals ... DONE
[17:40:09.744] Resolving globals: FALSE
[17:40:09.744] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[17:40:09.744] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[17:40:09.744] - globals: [1] ‘a’
[17:40:09.745] 
[17:40:09.745] getGlobalsAndPackages() ... DONE
[17:40:09.755] Packages needed by the future expression (n = 0): <none>
[17:40:09.755] Packages needed by future strategies (n = 0): <none>
[17:40:09.756] {
[17:40:09.756]     {
[17:40:09.756]         {
[17:40:09.756]             ...future.startTime <- base::Sys.time()
[17:40:09.756]             {
[17:40:09.756]                 {
[17:40:09.756]                   {
[17:40:09.756]                     {
[17:40:09.756]                       base::local({
[17:40:09.756]                         has_future <- base::requireNamespace("future", 
[17:40:09.756]                           quietly = TRUE)
[17:40:09.756]                         if (has_future) {
[17:40:09.756]                           ns <- base::getNamespace("future")
[17:40:09.756]                           version <- ns[[".package"]][["version"]]
[17:40:09.756]                           if (is.null(version)) 
[17:40:09.756]                             version <- utils::packageVersion("future")
[17:40:09.756]                         }
[17:40:09.756]                         else {
[17:40:09.756]                           version <- NULL
[17:40:09.756]                         }
[17:40:09.756]                         if (!has_future || version < "1.8.0") {
[17:40:09.756]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.756]                             "", base::R.version$version.string), 
[17:40:09.756]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:09.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.756]                               "release", "version")], collapse = " "), 
[17:40:09.756]                             hostname = base::Sys.info()[["nodename"]])
[17:40:09.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.756]                             info)
[17:40:09.756]                           info <- base::paste(info, collapse = "; ")
[17:40:09.756]                           if (!has_future) {
[17:40:09.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.756]                               info)
[17:40:09.756]                           }
[17:40:09.756]                           else {
[17:40:09.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.756]                               info, version)
[17:40:09.756]                           }
[17:40:09.756]                           base::stop(msg)
[17:40:09.756]                         }
[17:40:09.756]                       })
[17:40:09.756]                     }
[17:40:09.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:09.756]                     base::options(mc.cores = 1L)
[17:40:09.756]                   }
[17:40:09.756]                   ...future.strategy.old <- future::plan("list")
[17:40:09.756]                   options(future.plan = NULL)
[17:40:09.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.756]                 }
[17:40:09.756]                 ...future.workdir <- getwd()
[17:40:09.756]             }
[17:40:09.756]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.756]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.756]         }
[17:40:09.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.756]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[17:40:09.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.756]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.756]             base::names(...future.oldOptions))
[17:40:09.756]     }
[17:40:09.756]     if (FALSE) {
[17:40:09.756]     }
[17:40:09.756]     else {
[17:40:09.756]         if (TRUE) {
[17:40:09.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.756]                 open = "w")
[17:40:09.756]         }
[17:40:09.756]         else {
[17:40:09.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.756]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.756]         }
[17:40:09.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.756]             base::sink(type = "output", split = FALSE)
[17:40:09.756]             base::close(...future.stdout)
[17:40:09.756]         }, add = TRUE)
[17:40:09.756]     }
[17:40:09.756]     ...future.frame <- base::sys.nframe()
[17:40:09.756]     ...future.conditions <- base::list()
[17:40:09.756]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.756]     if (FALSE) {
[17:40:09.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.756]     }
[17:40:09.756]     ...future.result <- base::tryCatch({
[17:40:09.756]         base::withCallingHandlers({
[17:40:09.756]             ...future.value <- base::withVisible(base::local({
[17:40:09.756]                 ...future.makeSendCondition <- base::local({
[17:40:09.756]                   sendCondition <- NULL
[17:40:09.756]                   function(frame = 1L) {
[17:40:09.756]                     if (is.function(sendCondition)) 
[17:40:09.756]                       return(sendCondition)
[17:40:09.756]                     ns <- getNamespace("parallel")
[17:40:09.756]                     if (exists("sendData", mode = "function", 
[17:40:09.756]                       envir = ns)) {
[17:40:09.756]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:09.756]                         envir = ns)
[17:40:09.756]                       envir <- sys.frame(frame)
[17:40:09.756]                       master <- NULL
[17:40:09.756]                       while (!identical(envir, .GlobalEnv) && 
[17:40:09.756]                         !identical(envir, emptyenv())) {
[17:40:09.756]                         if (exists("master", mode = "list", envir = envir, 
[17:40:09.756]                           inherits = FALSE)) {
[17:40:09.756]                           master <- get("master", mode = "list", 
[17:40:09.756]                             envir = envir, inherits = FALSE)
[17:40:09.756]                           if (inherits(master, c("SOCKnode", 
[17:40:09.756]                             "SOCK0node"))) {
[17:40:09.756]                             sendCondition <<- function(cond) {
[17:40:09.756]                               data <- list(type = "VALUE", value = cond, 
[17:40:09.756]                                 success = TRUE)
[17:40:09.756]                               parallel_sendData(master, data)
[17:40:09.756]                             }
[17:40:09.756]                             return(sendCondition)
[17:40:09.756]                           }
[17:40:09.756]                         }
[17:40:09.756]                         frame <- frame + 1L
[17:40:09.756]                         envir <- sys.frame(frame)
[17:40:09.756]                       }
[17:40:09.756]                     }
[17:40:09.756]                     sendCondition <<- function(cond) NULL
[17:40:09.756]                   }
[17:40:09.756]                 })
[17:40:09.756]                 withCallingHandlers({
[17:40:09.756]                   {
[17:40:09.756]                     sum(a)
[17:40:09.756]                   }
[17:40:09.756]                 }, immediateCondition = function(cond) {
[17:40:09.756]                   sendCondition <- ...future.makeSendCondition()
[17:40:09.756]                   sendCondition(cond)
[17:40:09.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.756]                   {
[17:40:09.756]                     inherits <- base::inherits
[17:40:09.756]                     invokeRestart <- base::invokeRestart
[17:40:09.756]                     is.null <- base::is.null
[17:40:09.756]                     muffled <- FALSE
[17:40:09.756]                     if (inherits(cond, "message")) {
[17:40:09.756]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:09.756]                       if (muffled) 
[17:40:09.756]                         invokeRestart("muffleMessage")
[17:40:09.756]                     }
[17:40:09.756]                     else if (inherits(cond, "warning")) {
[17:40:09.756]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:09.756]                       if (muffled) 
[17:40:09.756]                         invokeRestart("muffleWarning")
[17:40:09.756]                     }
[17:40:09.756]                     else if (inherits(cond, "condition")) {
[17:40:09.756]                       if (!is.null(pattern)) {
[17:40:09.756]                         computeRestarts <- base::computeRestarts
[17:40:09.756]                         grepl <- base::grepl
[17:40:09.756]                         restarts <- computeRestarts(cond)
[17:40:09.756]                         for (restart in restarts) {
[17:40:09.756]                           name <- restart$name
[17:40:09.756]                           if (is.null(name)) 
[17:40:09.756]                             next
[17:40:09.756]                           if (!grepl(pattern, name)) 
[17:40:09.756]                             next
[17:40:09.756]                           invokeRestart(restart)
[17:40:09.756]                           muffled <- TRUE
[17:40:09.756]                           break
[17:40:09.756]                         }
[17:40:09.756]                       }
[17:40:09.756]                     }
[17:40:09.756]                     invisible(muffled)
[17:40:09.756]                   }
[17:40:09.756]                   muffleCondition(cond)
[17:40:09.756]                 })
[17:40:09.756]             }))
[17:40:09.756]             future::FutureResult(value = ...future.value$value, 
[17:40:09.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.756]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.756]                     ...future.globalenv.names))
[17:40:09.756]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.756]         }, condition = base::local({
[17:40:09.756]             c <- base::c
[17:40:09.756]             inherits <- base::inherits
[17:40:09.756]             invokeRestart <- base::invokeRestart
[17:40:09.756]             length <- base::length
[17:40:09.756]             list <- base::list
[17:40:09.756]             seq.int <- base::seq.int
[17:40:09.756]             signalCondition <- base::signalCondition
[17:40:09.756]             sys.calls <- base::sys.calls
[17:40:09.756]             `[[` <- base::`[[`
[17:40:09.756]             `+` <- base::`+`
[17:40:09.756]             `<<-` <- base::`<<-`
[17:40:09.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.756]                   3L)]
[17:40:09.756]             }
[17:40:09.756]             function(cond) {
[17:40:09.756]                 is_error <- inherits(cond, "error")
[17:40:09.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.756]                   NULL)
[17:40:09.756]                 if (is_error) {
[17:40:09.756]                   sessionInformation <- function() {
[17:40:09.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.756]                       search = base::search(), system = base::Sys.info())
[17:40:09.756]                   }
[17:40:09.756]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.756]                     cond$call), session = sessionInformation(), 
[17:40:09.756]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.756]                   signalCondition(cond)
[17:40:09.756]                 }
[17:40:09.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.756]                 "immediateCondition"))) {
[17:40:09.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.756]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.756]                   if (TRUE && !signal) {
[17:40:09.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.756]                     {
[17:40:09.756]                       inherits <- base::inherits
[17:40:09.756]                       invokeRestart <- base::invokeRestart
[17:40:09.756]                       is.null <- base::is.null
[17:40:09.756]                       muffled <- FALSE
[17:40:09.756]                       if (inherits(cond, "message")) {
[17:40:09.756]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.756]                         if (muffled) 
[17:40:09.756]                           invokeRestart("muffleMessage")
[17:40:09.756]                       }
[17:40:09.756]                       else if (inherits(cond, "warning")) {
[17:40:09.756]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.756]                         if (muffled) 
[17:40:09.756]                           invokeRestart("muffleWarning")
[17:40:09.756]                       }
[17:40:09.756]                       else if (inherits(cond, "condition")) {
[17:40:09.756]                         if (!is.null(pattern)) {
[17:40:09.756]                           computeRestarts <- base::computeRestarts
[17:40:09.756]                           grepl <- base::grepl
[17:40:09.756]                           restarts <- computeRestarts(cond)
[17:40:09.756]                           for (restart in restarts) {
[17:40:09.756]                             name <- restart$name
[17:40:09.756]                             if (is.null(name)) 
[17:40:09.756]                               next
[17:40:09.756]                             if (!grepl(pattern, name)) 
[17:40:09.756]                               next
[17:40:09.756]                             invokeRestart(restart)
[17:40:09.756]                             muffled <- TRUE
[17:40:09.756]                             break
[17:40:09.756]                           }
[17:40:09.756]                         }
[17:40:09.756]                       }
[17:40:09.756]                       invisible(muffled)
[17:40:09.756]                     }
[17:40:09.756]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.756]                   }
[17:40:09.756]                 }
[17:40:09.756]                 else {
[17:40:09.756]                   if (TRUE) {
[17:40:09.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.756]                     {
[17:40:09.756]                       inherits <- base::inherits
[17:40:09.756]                       invokeRestart <- base::invokeRestart
[17:40:09.756]                       is.null <- base::is.null
[17:40:09.756]                       muffled <- FALSE
[17:40:09.756]                       if (inherits(cond, "message")) {
[17:40:09.756]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.756]                         if (muffled) 
[17:40:09.756]                           invokeRestart("muffleMessage")
[17:40:09.756]                       }
[17:40:09.756]                       else if (inherits(cond, "warning")) {
[17:40:09.756]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.756]                         if (muffled) 
[17:40:09.756]                           invokeRestart("muffleWarning")
[17:40:09.756]                       }
[17:40:09.756]                       else if (inherits(cond, "condition")) {
[17:40:09.756]                         if (!is.null(pattern)) {
[17:40:09.756]                           computeRestarts <- base::computeRestarts
[17:40:09.756]                           grepl <- base::grepl
[17:40:09.756]                           restarts <- computeRestarts(cond)
[17:40:09.756]                           for (restart in restarts) {
[17:40:09.756]                             name <- restart$name
[17:40:09.756]                             if (is.null(name)) 
[17:40:09.756]                               next
[17:40:09.756]                             if (!grepl(pattern, name)) 
[17:40:09.756]                               next
[17:40:09.756]                             invokeRestart(restart)
[17:40:09.756]                             muffled <- TRUE
[17:40:09.756]                             break
[17:40:09.756]                           }
[17:40:09.756]                         }
[17:40:09.756]                       }
[17:40:09.756]                       invisible(muffled)
[17:40:09.756]                     }
[17:40:09.756]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.756]                   }
[17:40:09.756]                 }
[17:40:09.756]             }
[17:40:09.756]         }))
[17:40:09.756]     }, error = function(ex) {
[17:40:09.756]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.756]                 ...future.rng), started = ...future.startTime, 
[17:40:09.756]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.756]             version = "1.8"), class = "FutureResult")
[17:40:09.756]     }, finally = {
[17:40:09.756]         if (!identical(...future.workdir, getwd())) 
[17:40:09.756]             setwd(...future.workdir)
[17:40:09.756]         {
[17:40:09.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.756]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.756]             }
[17:40:09.756]             base::options(...future.oldOptions)
[17:40:09.756]             if (.Platform$OS.type == "windows") {
[17:40:09.756]                 old_names <- names(...future.oldEnvVars)
[17:40:09.756]                 envs <- base::Sys.getenv()
[17:40:09.756]                 names <- names(envs)
[17:40:09.756]                 common <- intersect(names, old_names)
[17:40:09.756]                 added <- setdiff(names, old_names)
[17:40:09.756]                 removed <- setdiff(old_names, names)
[17:40:09.756]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.756]                   envs[common]]
[17:40:09.756]                 NAMES <- toupper(changed)
[17:40:09.756]                 args <- list()
[17:40:09.756]                 for (kk in seq_along(NAMES)) {
[17:40:09.756]                   name <- changed[[kk]]
[17:40:09.756]                   NAME <- NAMES[[kk]]
[17:40:09.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.756]                     next
[17:40:09.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.756]                 }
[17:40:09.756]                 NAMES <- toupper(added)
[17:40:09.756]                 for (kk in seq_along(NAMES)) {
[17:40:09.756]                   name <- added[[kk]]
[17:40:09.756]                   NAME <- NAMES[[kk]]
[17:40:09.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.756]                     next
[17:40:09.756]                   args[[name]] <- ""
[17:40:09.756]                 }
[17:40:09.756]                 NAMES <- toupper(removed)
[17:40:09.756]                 for (kk in seq_along(NAMES)) {
[17:40:09.756]                   name <- removed[[kk]]
[17:40:09.756]                   NAME <- NAMES[[kk]]
[17:40:09.756]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.756]                     next
[17:40:09.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.756]                 }
[17:40:09.756]                 if (length(args) > 0) 
[17:40:09.756]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.756]             }
[17:40:09.756]             else {
[17:40:09.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.756]             }
[17:40:09.756]             {
[17:40:09.756]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.756]                   0L) {
[17:40:09.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.756]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.756]                   base::options(opts)
[17:40:09.756]                 }
[17:40:09.756]                 {
[17:40:09.756]                   {
[17:40:09.756]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:09.756]                     NULL
[17:40:09.756]                   }
[17:40:09.756]                   options(future.plan = NULL)
[17:40:09.756]                   if (is.na(NA_character_)) 
[17:40:09.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.756]                     .init = FALSE)
[17:40:09.756]                 }
[17:40:09.756]             }
[17:40:09.756]         }
[17:40:09.756]     })
[17:40:09.756]     if (TRUE) {
[17:40:09.756]         base::sink(type = "output", split = FALSE)
[17:40:09.756]         if (TRUE) {
[17:40:09.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.756]         }
[17:40:09.756]         else {
[17:40:09.756]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.756]         }
[17:40:09.756]         base::close(...future.stdout)
[17:40:09.756]         ...future.stdout <- NULL
[17:40:09.756]     }
[17:40:09.756]     ...future.result$conditions <- ...future.conditions
[17:40:09.756]     ...future.result$finished <- base::Sys.time()
[17:40:09.756]     ...future.result
[17:40:09.756] }
[17:40:09.758] Exporting 1 global objects (4.01 KiB) to cluster node #1 ...
[17:40:09.758] Exporting ‘a’ (4.01 KiB) to cluster node #1 ...
[17:40:09.759] Exporting ‘a’ (4.01 KiB) to cluster node #1 ... DONE
[17:40:09.759] Exporting 1 global objects (4.01 KiB) to cluster node #1 ... DONE
[17:40:09.759] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:40:09.761] receiveMessageFromWorker() for ClusterFuture ...
[17:40:09.761] - Validating connection of MultisessionFuture
[17:40:09.761] - received message: FutureResult
[17:40:09.761] - Received FutureResult
[17:40:09.761] - Erased future from FutureRegistry
[17:40:09.762] result() for ClusterFuture ...
[17:40:09.762] - result already collected: FutureResult
[17:40:09.762] result() for ClusterFuture ... done
[17:40:09.762] receiveMessageFromWorker() for ClusterFuture ... done
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 4e14475e-e24e-1433-99dd-c4bdd9bc2f63
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:09.762] result() for ClusterFuture ...
[17:40:09.762] - result already collected: FutureResult
[17:40:09.762] result() for ClusterFuture ... done
[17:40:09.762] result() for ClusterFuture ...
[17:40:09.762] - result already collected: FutureResult
[17:40:09.762] result() for ClusterFuture ... done
[1] 514605
a: 4112 bytes
[17:40:09.763] getGlobalsAndPackages() ...
[17:40:09.763] Searching for globals...
[17:40:09.763] - globals found: [3] ‘{’, ‘sum’, ‘a’
[17:40:09.764] Searching for globals ... DONE
[17:40:09.764] Resolving globals: FALSE
[17:40:09.764] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[17:40:09.764] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
> 
> ## Undo options changed in this test
> options(ooptsT)
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[17:40:09.765] getGlobalsAndPackages() ...
[17:40:09.765] Searching for globals...
[17:40:09.766] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[17:40:09.766] Searching for globals ... DONE
[17:40:09.766] Resolving globals: FALSE
[17:40:09.766] The total size of the 2 globals is 112 bytes (112 bytes)
[17:40:09.767] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[17:40:09.767] - globals: [2] ‘a’, ‘b’
[17:40:09.767] 
[17:40:09.767] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[17:40:09.767] Packages needed by the future expression (n = 0): <none>
[17:40:09.767] Packages needed by future strategies (n = 0): <none>
[17:40:09.768] {
[17:40:09.768]     {
[17:40:09.768]         {
[17:40:09.768]             ...future.startTime <- base::Sys.time()
[17:40:09.768]             {
[17:40:09.768]                 {
[17:40:09.768]                   {
[17:40:09.768]                     base::local({
[17:40:09.768]                       has_future <- base::requireNamespace("future", 
[17:40:09.768]                         quietly = TRUE)
[17:40:09.768]                       if (has_future) {
[17:40:09.768]                         ns <- base::getNamespace("future")
[17:40:09.768]                         version <- ns[[".package"]][["version"]]
[17:40:09.768]                         if (is.null(version)) 
[17:40:09.768]                           version <- utils::packageVersion("future")
[17:40:09.768]                       }
[17:40:09.768]                       else {
[17:40:09.768]                         version <- NULL
[17:40:09.768]                       }
[17:40:09.768]                       if (!has_future || version < "1.8.0") {
[17:40:09.768]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:09.768]                           "", base::R.version$version.string), 
[17:40:09.768]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:09.768]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:09.768]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:09.768]                             "release", "version")], collapse = " "), 
[17:40:09.768]                           hostname = base::Sys.info()[["nodename"]])
[17:40:09.768]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:09.768]                           info)
[17:40:09.768]                         info <- base::paste(info, collapse = "; ")
[17:40:09.768]                         if (!has_future) {
[17:40:09.768]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:09.768]                             info)
[17:40:09.768]                         }
[17:40:09.768]                         else {
[17:40:09.768]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:09.768]                             info, version)
[17:40:09.768]                         }
[17:40:09.768]                         base::stop(msg)
[17:40:09.768]                       }
[17:40:09.768]                     })
[17:40:09.768]                   }
[17:40:09.768]                   ...future.strategy.old <- future::plan("list")
[17:40:09.768]                   options(future.plan = NULL)
[17:40:09.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:09.768]                 }
[17:40:09.768]                 ...future.workdir <- getwd()
[17:40:09.768]             }
[17:40:09.768]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:09.768]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:09.768]         }
[17:40:09.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:09.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:09.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:09.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:09.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:09.768]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:09.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:09.768]             base::names(...future.oldOptions))
[17:40:09.768]     }
[17:40:09.768]     if (FALSE) {
[17:40:09.768]     }
[17:40:09.768]     else {
[17:40:09.768]         if (TRUE) {
[17:40:09.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:09.768]                 open = "w")
[17:40:09.768]         }
[17:40:09.768]         else {
[17:40:09.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:09.768]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:09.768]         }
[17:40:09.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:09.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:09.768]             base::sink(type = "output", split = FALSE)
[17:40:09.768]             base::close(...future.stdout)
[17:40:09.768]         }, add = TRUE)
[17:40:09.768]     }
[17:40:09.768]     ...future.frame <- base::sys.nframe()
[17:40:09.768]     ...future.conditions <- base::list()
[17:40:09.768]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:09.768]     if (FALSE) {
[17:40:09.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:09.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:09.768]     }
[17:40:09.768]     ...future.result <- base::tryCatch({
[17:40:09.768]         base::withCallingHandlers({
[17:40:09.768]             ...future.value <- base::withVisible(base::local({
[17:40:09.768]                 a * b
[17:40:09.768]             }))
[17:40:09.768]             future::FutureResult(value = ...future.value$value, 
[17:40:09.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.768]                   ...future.rng), globalenv = if (FALSE) 
[17:40:09.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:09.768]                     ...future.globalenv.names))
[17:40:09.768]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:09.768]         }, condition = base::local({
[17:40:09.768]             c <- base::c
[17:40:09.768]             inherits <- base::inherits
[17:40:09.768]             invokeRestart <- base::invokeRestart
[17:40:09.768]             length <- base::length
[17:40:09.768]             list <- base::list
[17:40:09.768]             seq.int <- base::seq.int
[17:40:09.768]             signalCondition <- base::signalCondition
[17:40:09.768]             sys.calls <- base::sys.calls
[17:40:09.768]             `[[` <- base::`[[`
[17:40:09.768]             `+` <- base::`+`
[17:40:09.768]             `<<-` <- base::`<<-`
[17:40:09.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:09.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:09.768]                   3L)]
[17:40:09.768]             }
[17:40:09.768]             function(cond) {
[17:40:09.768]                 is_error <- inherits(cond, "error")
[17:40:09.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:09.768]                   NULL)
[17:40:09.768]                 if (is_error) {
[17:40:09.768]                   sessionInformation <- function() {
[17:40:09.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:09.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:09.768]                       search = base::search(), system = base::Sys.info())
[17:40:09.768]                   }
[17:40:09.768]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:09.768]                     cond$call), session = sessionInformation(), 
[17:40:09.768]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:09.768]                   signalCondition(cond)
[17:40:09.768]                 }
[17:40:09.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:09.768]                 "immediateCondition"))) {
[17:40:09.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:09.768]                   ...future.conditions[[length(...future.conditions) + 
[17:40:09.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:09.768]                   if (TRUE && !signal) {
[17:40:09.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.768]                     {
[17:40:09.768]                       inherits <- base::inherits
[17:40:09.768]                       invokeRestart <- base::invokeRestart
[17:40:09.768]                       is.null <- base::is.null
[17:40:09.768]                       muffled <- FALSE
[17:40:09.768]                       if (inherits(cond, "message")) {
[17:40:09.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.768]                         if (muffled) 
[17:40:09.768]                           invokeRestart("muffleMessage")
[17:40:09.768]                       }
[17:40:09.768]                       else if (inherits(cond, "warning")) {
[17:40:09.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.768]                         if (muffled) 
[17:40:09.768]                           invokeRestart("muffleWarning")
[17:40:09.768]                       }
[17:40:09.768]                       else if (inherits(cond, "condition")) {
[17:40:09.768]                         if (!is.null(pattern)) {
[17:40:09.768]                           computeRestarts <- base::computeRestarts
[17:40:09.768]                           grepl <- base::grepl
[17:40:09.768]                           restarts <- computeRestarts(cond)
[17:40:09.768]                           for (restart in restarts) {
[17:40:09.768]                             name <- restart$name
[17:40:09.768]                             if (is.null(name)) 
[17:40:09.768]                               next
[17:40:09.768]                             if (!grepl(pattern, name)) 
[17:40:09.768]                               next
[17:40:09.768]                             invokeRestart(restart)
[17:40:09.768]                             muffled <- TRUE
[17:40:09.768]                             break
[17:40:09.768]                           }
[17:40:09.768]                         }
[17:40:09.768]                       }
[17:40:09.768]                       invisible(muffled)
[17:40:09.768]                     }
[17:40:09.768]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.768]                   }
[17:40:09.768]                 }
[17:40:09.768]                 else {
[17:40:09.768]                   if (TRUE) {
[17:40:09.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:09.768]                     {
[17:40:09.768]                       inherits <- base::inherits
[17:40:09.768]                       invokeRestart <- base::invokeRestart
[17:40:09.768]                       is.null <- base::is.null
[17:40:09.768]                       muffled <- FALSE
[17:40:09.768]                       if (inherits(cond, "message")) {
[17:40:09.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:09.768]                         if (muffled) 
[17:40:09.768]                           invokeRestart("muffleMessage")
[17:40:09.768]                       }
[17:40:09.768]                       else if (inherits(cond, "warning")) {
[17:40:09.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:09.768]                         if (muffled) 
[17:40:09.768]                           invokeRestart("muffleWarning")
[17:40:09.768]                       }
[17:40:09.768]                       else if (inherits(cond, "condition")) {
[17:40:09.768]                         if (!is.null(pattern)) {
[17:40:09.768]                           computeRestarts <- base::computeRestarts
[17:40:09.768]                           grepl <- base::grepl
[17:40:09.768]                           restarts <- computeRestarts(cond)
[17:40:09.768]                           for (restart in restarts) {
[17:40:09.768]                             name <- restart$name
[17:40:09.768]                             if (is.null(name)) 
[17:40:09.768]                               next
[17:40:09.768]                             if (!grepl(pattern, name)) 
[17:40:09.768]                               next
[17:40:09.768]                             invokeRestart(restart)
[17:40:09.768]                             muffled <- TRUE
[17:40:09.768]                             break
[17:40:09.768]                           }
[17:40:09.768]                         }
[17:40:09.768]                       }
[17:40:09.768]                       invisible(muffled)
[17:40:09.768]                     }
[17:40:09.768]                     muffleCondition(cond, pattern = "^muffle")
[17:40:09.768]                   }
[17:40:09.768]                 }
[17:40:09.768]             }
[17:40:09.768]         }))
[17:40:09.768]     }, error = function(ex) {
[17:40:09.768]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:09.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:09.768]                 ...future.rng), started = ...future.startTime, 
[17:40:09.768]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:09.768]             version = "1.8"), class = "FutureResult")
[17:40:09.768]     }, finally = {
[17:40:09.768]         if (!identical(...future.workdir, getwd())) 
[17:40:09.768]             setwd(...future.workdir)
[17:40:09.768]         {
[17:40:09.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:09.768]                 ...future.oldOptions$nwarnings <- NULL
[17:40:09.768]             }
[17:40:09.768]             base::options(...future.oldOptions)
[17:40:09.768]             if (.Platform$OS.type == "windows") {
[17:40:09.768]                 old_names <- names(...future.oldEnvVars)
[17:40:09.768]                 envs <- base::Sys.getenv()
[17:40:09.768]                 names <- names(envs)
[17:40:09.768]                 common <- intersect(names, old_names)
[17:40:09.768]                 added <- setdiff(names, old_names)
[17:40:09.768]                 removed <- setdiff(old_names, names)
[17:40:09.768]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:09.768]                   envs[common]]
[17:40:09.768]                 NAMES <- toupper(changed)
[17:40:09.768]                 args <- list()
[17:40:09.768]                 for (kk in seq_along(NAMES)) {
[17:40:09.768]                   name <- changed[[kk]]
[17:40:09.768]                   NAME <- NAMES[[kk]]
[17:40:09.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.768]                     next
[17:40:09.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.768]                 }
[17:40:09.768]                 NAMES <- toupper(added)
[17:40:09.768]                 for (kk in seq_along(NAMES)) {
[17:40:09.768]                   name <- added[[kk]]
[17:40:09.768]                   NAME <- NAMES[[kk]]
[17:40:09.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.768]                     next
[17:40:09.768]                   args[[name]] <- ""
[17:40:09.768]                 }
[17:40:09.768]                 NAMES <- toupper(removed)
[17:40:09.768]                 for (kk in seq_along(NAMES)) {
[17:40:09.768]                   name <- removed[[kk]]
[17:40:09.768]                   NAME <- NAMES[[kk]]
[17:40:09.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:09.768]                     next
[17:40:09.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:09.768]                 }
[17:40:09.768]                 if (length(args) > 0) 
[17:40:09.768]                   base::do.call(base::Sys.setenv, args = args)
[17:40:09.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:09.768]             }
[17:40:09.768]             else {
[17:40:09.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:09.768]             }
[17:40:09.768]             {
[17:40:09.768]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:09.768]                   0L) {
[17:40:09.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:09.768]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:09.768]                   base::options(opts)
[17:40:09.768]                 }
[17:40:09.768]                 {
[17:40:09.768]                   {
[17:40:09.768]                     NULL
[17:40:09.768]                     RNGkind("Mersenne-Twister")
[17:40:09.768]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:09.768]                       inherits = FALSE)
[17:40:09.768]                   }
[17:40:09.768]                   options(future.plan = NULL)
[17:40:09.768]                   if (is.na(NA_character_)) 
[17:40:09.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:09.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:09.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:09.768]                     .init = FALSE)
[17:40:09.768]                 }
[17:40:09.768]             }
[17:40:09.768]         }
[17:40:09.768]     })
[17:40:09.768]     if (TRUE) {
[17:40:09.768]         base::sink(type = "output", split = FALSE)
[17:40:09.768]         if (TRUE) {
[17:40:09.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:09.768]         }
[17:40:09.768]         else {
[17:40:09.768]             ...future.result["stdout"] <- base::list(NULL)
[17:40:09.768]         }
[17:40:09.768]         base::close(...future.stdout)
[17:40:09.768]         ...future.stdout <- NULL
[17:40:09.768]     }
[17:40:09.768]     ...future.result$conditions <- ...future.conditions
[17:40:09.768]     ...future.result$finished <- base::Sys.time()
[17:40:09.768]     ...future.result
[17:40:09.768] }
[17:40:09.769] assign_globals() ...
[17:40:09.770] List of 2
[17:40:09.770]  $ a: num 2
[17:40:09.770]  $ b: num 3
[17:40:09.770]  - attr(*, "where")=List of 2
[17:40:09.770]   ..$ a:<environment: R_EmptyEnv> 
[17:40:09.770]   ..$ b:<environment: R_EmptyEnv> 
[17:40:09.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:09.770]  - attr(*, "resolved")= logi FALSE
[17:40:09.770]  - attr(*, "total_size")= num 112
[17:40:09.774] - copied ‘a’ to environment
[17:40:09.774] - copied ‘b’ to environment
[17:40:09.774] assign_globals() ... done
[17:40:09.775] plan(): Setting new future strategy stack:
[17:40:09.775] List of future strategies:
[17:40:09.775] 1. sequential:
[17:40:09.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:09.775]    - tweaked: FALSE
[17:40:09.775]    - call: NULL
[17:40:09.775] plan(): nbrOfWorkers() = 1
[17:40:09.776] plan(): Setting new future strategy stack:
[17:40:09.776] List of future strategies:
[17:40:09.776] 1. sequential:
[17:40:09.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:09.776]    - tweaked: FALSE
[17:40:09.776]    - call: future::plan("sequential")
[17:40:09.776] plan(): nbrOfWorkers() = 1
[17:40:09.776] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[17:40:09.777] plan(): Setting new future strategy stack:
[17:40:09.777] List of future strategies:
[17:40:09.777] 1. multisession:
[17:40:09.777]    - args: function (..., workers = 2L, envir = parent.frame())
[17:40:09.777]    - tweaked: TRUE
[17:40:09.777]    - call: plan(multisession, workers = 2L)
[17:40:09.792] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:09.792] multisession:
[17:40:09.792] - args: function (..., workers = 2L, envir = parent.frame())
[17:40:09.792] - tweaked: TRUE
[17:40:09.792] - call: plan(multisession, workers = 2L)
[17:40:09.793] getGlobalsAndPackages() ...
[17:40:09.793] Not searching for globals
[17:40:09.793] - globals: [0] <none>
[17:40:09.793] getGlobalsAndPackages() ... DONE
[17:40:09.793] [local output] makeClusterPSOCK() ...
[17:40:09.796] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:09.797] [local output] Base port: 11531
[17:40:09.797] [local output] Getting setup options for 2 cluster nodes ...
[17:40:09.797] [local output]  - Node 1 of 2 ...
[17:40:09.797] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:09.798] [local output] Rscript port: 11531

[17:40:09.798] [local output]  - Node 2 of 2 ...
[17:40:09.799] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:09.799] [local output] Rscript port: 11531

[17:40:09.799] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:09.800] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:09.800] [local output] Setting up PSOCK nodes in parallel
[17:40:09.800] List of 36
[17:40:09.800]  $ worker          : chr "localhost"
[17:40:09.800]   ..- attr(*, "localhost")= logi TRUE
[17:40:09.800]  $ master          : chr "localhost"
[17:40:09.800]  $ port            : int 11531
[17:40:09.800]  $ connectTimeout  : num 120
[17:40:09.800]  $ timeout         : num 2592000
[17:40:09.800]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:09.800]  $ homogeneous     : logi TRUE
[17:40:09.800]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:09.800]  $ rscript_envs    : NULL
[17:40:09.800]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:09.800]  $ rscript_startup : NULL
[17:40:09.800]  $ rscript_sh      : chr "sh"
[17:40:09.800]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:09.800]  $ methods         : logi TRUE
[17:40:09.800]  $ socketOptions   : chr "no-delay"
[17:40:09.800]  $ useXDR          : logi FALSE
[17:40:09.800]  $ outfile         : chr "/dev/null"
[17:40:09.800]  $ renice          : int NA
[17:40:09.800]  $ rshcmd          : NULL
[17:40:09.800]  $ user            : chr(0) 
[17:40:09.800]  $ revtunnel       : logi FALSE
[17:40:09.800]  $ rshlogfile      : NULL
[17:40:09.800]  $ rshopts         : chr(0) 
[17:40:09.800]  $ rank            : int 1
[17:40:09.800]  $ manual          : logi FALSE
[17:40:09.800]  $ dryrun          : logi FALSE
[17:40:09.800]  $ quiet           : logi FALSE
[17:40:09.800]  $ setup_strategy  : chr "parallel"
[17:40:09.800]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:09.800]  $ pidfile         : chr "/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b24952379d26.pid"
[17:40:09.800]  $ rshcmd_label    : NULL
[17:40:09.800]  $ rsh_call        : NULL
[17:40:09.800]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:09.800]  $ localMachine    : logi TRUE
[17:40:09.800]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:09.800]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:09.800]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:09.800]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:09.800]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:09.800]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:09.800]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:09.800]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:09.800]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:09.800]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:09.800]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:09.800]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:09.800]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:09.800]  $ arguments       :List of 28
[17:40:09.800]   ..$ worker          : chr "localhost"
[17:40:09.800]   ..$ master          : NULL
[17:40:09.800]   ..$ port            : int 11531
[17:40:09.800]   ..$ connectTimeout  : num 120
[17:40:09.800]   ..$ timeout         : num 2592000
[17:40:09.800]   ..$ rscript         : NULL
[17:40:09.800]   ..$ homogeneous     : NULL
[17:40:09.800]   ..$ rscript_args    : NULL
[17:40:09.800]   ..$ rscript_envs    : NULL
[17:40:09.800]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:09.800]   ..$ rscript_startup : NULL
[17:40:09.800]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:09.800]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:09.800]   ..$ methods         : logi TRUE
[17:40:09.800]   ..$ socketOptions   : chr "no-delay"
[17:40:09.800]   ..$ useXDR          : logi FALSE
[17:40:09.800]   ..$ outfile         : chr "/dev/null"
[17:40:09.800]   ..$ renice          : int NA
[17:40:09.800]   ..$ rshcmd          : NULL
[17:40:09.800]   ..$ user            : NULL
[17:40:09.800]   ..$ revtunnel       : logi NA
[17:40:09.800]   ..$ rshlogfile      : NULL
[17:40:09.800]   ..$ rshopts         : NULL
[17:40:09.800]   ..$ rank            : int 1
[17:40:09.800]   ..$ manual          : logi FALSE
[17:40:09.800]   ..$ dryrun          : logi FALSE
[17:40:09.800]   ..$ quiet           : logi FALSE
[17:40:09.800]   ..$ setup_strategy  : chr "parallel"
[17:40:09.800]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:09.816] [local output] System call to launch all workers:
[17:40:09.816] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b24952379d26.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11531 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:09.816] [local output] Starting PSOCK main server
[17:40:09.818] [local output] Workers launched
[17:40:09.818] [local output] Waiting for workers to connect back
[17:40:09.818]  - [local output] 0 workers out of 2 ready
[17:40:10.064]  - [local output] 0 workers out of 2 ready
[17:40:10.064]  - [local output] 1 workers out of 2 ready
[17:40:10.065]  - [local output] 2 workers out of 2 ready
[17:40:10.065] [local output] Launching of workers completed
[17:40:10.065] [local output] Collecting session information from workers
[17:40:10.065] [local output]  - Worker #1 of 2
[17:40:10.066] [local output]  - Worker #2 of 2
[17:40:10.066] [local output] makeClusterPSOCK() ... done
[17:40:10.077] Packages needed by the future expression (n = 0): <none>
[17:40:10.077] Packages needed by future strategies (n = 0): <none>
[17:40:10.077] {
[17:40:10.077]     {
[17:40:10.077]         {
[17:40:10.077]             ...future.startTime <- base::Sys.time()
[17:40:10.077]             {
[17:40:10.077]                 {
[17:40:10.077]                   {
[17:40:10.077]                     {
[17:40:10.077]                       base::local({
[17:40:10.077]                         has_future <- base::requireNamespace("future", 
[17:40:10.077]                           quietly = TRUE)
[17:40:10.077]                         if (has_future) {
[17:40:10.077]                           ns <- base::getNamespace("future")
[17:40:10.077]                           version <- ns[[".package"]][["version"]]
[17:40:10.077]                           if (is.null(version)) 
[17:40:10.077]                             version <- utils::packageVersion("future")
[17:40:10.077]                         }
[17:40:10.077]                         else {
[17:40:10.077]                           version <- NULL
[17:40:10.077]                         }
[17:40:10.077]                         if (!has_future || version < "1.8.0") {
[17:40:10.077]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:10.077]                             "", base::R.version$version.string), 
[17:40:10.077]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:10.077]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:10.077]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:10.077]                               "release", "version")], collapse = " "), 
[17:40:10.077]                             hostname = base::Sys.info()[["nodename"]])
[17:40:10.077]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:10.077]                             info)
[17:40:10.077]                           info <- base::paste(info, collapse = "; ")
[17:40:10.077]                           if (!has_future) {
[17:40:10.077]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:10.077]                               info)
[17:40:10.077]                           }
[17:40:10.077]                           else {
[17:40:10.077]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:10.077]                               info, version)
[17:40:10.077]                           }
[17:40:10.077]                           base::stop(msg)
[17:40:10.077]                         }
[17:40:10.077]                       })
[17:40:10.077]                     }
[17:40:10.077]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:10.077]                     base::options(mc.cores = 1L)
[17:40:10.077]                   }
[17:40:10.077]                   ...future.strategy.old <- future::plan("list")
[17:40:10.077]                   options(future.plan = NULL)
[17:40:10.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:10.077]                 }
[17:40:10.077]                 ...future.workdir <- getwd()
[17:40:10.077]             }
[17:40:10.077]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:10.077]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:10.077]         }
[17:40:10.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:10.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:10.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:10.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:10.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:10.077]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:10.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:10.077]             base::names(...future.oldOptions))
[17:40:10.077]     }
[17:40:10.077]     if (FALSE) {
[17:40:10.077]     }
[17:40:10.077]     else {
[17:40:10.077]         if (TRUE) {
[17:40:10.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:10.077]                 open = "w")
[17:40:10.077]         }
[17:40:10.077]         else {
[17:40:10.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:10.077]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:10.077]         }
[17:40:10.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:10.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:10.077]             base::sink(type = "output", split = FALSE)
[17:40:10.077]             base::close(...future.stdout)
[17:40:10.077]         }, add = TRUE)
[17:40:10.077]     }
[17:40:10.077]     ...future.frame <- base::sys.nframe()
[17:40:10.077]     ...future.conditions <- base::list()
[17:40:10.077]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:10.077]     if (FALSE) {
[17:40:10.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:10.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:10.077]     }
[17:40:10.077]     ...future.result <- base::tryCatch({
[17:40:10.077]         base::withCallingHandlers({
[17:40:10.077]             ...future.value <- base::withVisible(base::local({
[17:40:10.077]                 ...future.makeSendCondition <- base::local({
[17:40:10.077]                   sendCondition <- NULL
[17:40:10.077]                   function(frame = 1L) {
[17:40:10.077]                     if (is.function(sendCondition)) 
[17:40:10.077]                       return(sendCondition)
[17:40:10.077]                     ns <- getNamespace("parallel")
[17:40:10.077]                     if (exists("sendData", mode = "function", 
[17:40:10.077]                       envir = ns)) {
[17:40:10.077]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:10.077]                         envir = ns)
[17:40:10.077]                       envir <- sys.frame(frame)
[17:40:10.077]                       master <- NULL
[17:40:10.077]                       while (!identical(envir, .GlobalEnv) && 
[17:40:10.077]                         !identical(envir, emptyenv())) {
[17:40:10.077]                         if (exists("master", mode = "list", envir = envir, 
[17:40:10.077]                           inherits = FALSE)) {
[17:40:10.077]                           master <- get("master", mode = "list", 
[17:40:10.077]                             envir = envir, inherits = FALSE)
[17:40:10.077]                           if (inherits(master, c("SOCKnode", 
[17:40:10.077]                             "SOCK0node"))) {
[17:40:10.077]                             sendCondition <<- function(cond) {
[17:40:10.077]                               data <- list(type = "VALUE", value = cond, 
[17:40:10.077]                                 success = TRUE)
[17:40:10.077]                               parallel_sendData(master, data)
[17:40:10.077]                             }
[17:40:10.077]                             return(sendCondition)
[17:40:10.077]                           }
[17:40:10.077]                         }
[17:40:10.077]                         frame <- frame + 1L
[17:40:10.077]                         envir <- sys.frame(frame)
[17:40:10.077]                       }
[17:40:10.077]                     }
[17:40:10.077]                     sendCondition <<- function(cond) NULL
[17:40:10.077]                   }
[17:40:10.077]                 })
[17:40:10.077]                 withCallingHandlers({
[17:40:10.077]                   NA
[17:40:10.077]                 }, immediateCondition = function(cond) {
[17:40:10.077]                   sendCondition <- ...future.makeSendCondition()
[17:40:10.077]                   sendCondition(cond)
[17:40:10.077]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.077]                   {
[17:40:10.077]                     inherits <- base::inherits
[17:40:10.077]                     invokeRestart <- base::invokeRestart
[17:40:10.077]                     is.null <- base::is.null
[17:40:10.077]                     muffled <- FALSE
[17:40:10.077]                     if (inherits(cond, "message")) {
[17:40:10.077]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:10.077]                       if (muffled) 
[17:40:10.077]                         invokeRestart("muffleMessage")
[17:40:10.077]                     }
[17:40:10.077]                     else if (inherits(cond, "warning")) {
[17:40:10.077]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:10.077]                       if (muffled) 
[17:40:10.077]                         invokeRestart("muffleWarning")
[17:40:10.077]                     }
[17:40:10.077]                     else if (inherits(cond, "condition")) {
[17:40:10.077]                       if (!is.null(pattern)) {
[17:40:10.077]                         computeRestarts <- base::computeRestarts
[17:40:10.077]                         grepl <- base::grepl
[17:40:10.077]                         restarts <- computeRestarts(cond)
[17:40:10.077]                         for (restart in restarts) {
[17:40:10.077]                           name <- restart$name
[17:40:10.077]                           if (is.null(name)) 
[17:40:10.077]                             next
[17:40:10.077]                           if (!grepl(pattern, name)) 
[17:40:10.077]                             next
[17:40:10.077]                           invokeRestart(restart)
[17:40:10.077]                           muffled <- TRUE
[17:40:10.077]                           break
[17:40:10.077]                         }
[17:40:10.077]                       }
[17:40:10.077]                     }
[17:40:10.077]                     invisible(muffled)
[17:40:10.077]                   }
[17:40:10.077]                   muffleCondition(cond)
[17:40:10.077]                 })
[17:40:10.077]             }))
[17:40:10.077]             future::FutureResult(value = ...future.value$value, 
[17:40:10.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.077]                   ...future.rng), globalenv = if (FALSE) 
[17:40:10.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:10.077]                     ...future.globalenv.names))
[17:40:10.077]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:10.077]         }, condition = base::local({
[17:40:10.077]             c <- base::c
[17:40:10.077]             inherits <- base::inherits
[17:40:10.077]             invokeRestart <- base::invokeRestart
[17:40:10.077]             length <- base::length
[17:40:10.077]             list <- base::list
[17:40:10.077]             seq.int <- base::seq.int
[17:40:10.077]             signalCondition <- base::signalCondition
[17:40:10.077]             sys.calls <- base::sys.calls
[17:40:10.077]             `[[` <- base::`[[`
[17:40:10.077]             `+` <- base::`+`
[17:40:10.077]             `<<-` <- base::`<<-`
[17:40:10.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:10.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:10.077]                   3L)]
[17:40:10.077]             }
[17:40:10.077]             function(cond) {
[17:40:10.077]                 is_error <- inherits(cond, "error")
[17:40:10.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:10.077]                   NULL)
[17:40:10.077]                 if (is_error) {
[17:40:10.077]                   sessionInformation <- function() {
[17:40:10.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:10.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:10.077]                       search = base::search(), system = base::Sys.info())
[17:40:10.077]                   }
[17:40:10.077]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:10.077]                     cond$call), session = sessionInformation(), 
[17:40:10.077]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:10.077]                   signalCondition(cond)
[17:40:10.077]                 }
[17:40:10.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:10.077]                 "immediateCondition"))) {
[17:40:10.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:10.077]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:10.077]                   if (TRUE && !signal) {
[17:40:10.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.077]                     {
[17:40:10.077]                       inherits <- base::inherits
[17:40:10.077]                       invokeRestart <- base::invokeRestart
[17:40:10.077]                       is.null <- base::is.null
[17:40:10.077]                       muffled <- FALSE
[17:40:10.077]                       if (inherits(cond, "message")) {
[17:40:10.077]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.077]                         if (muffled) 
[17:40:10.077]                           invokeRestart("muffleMessage")
[17:40:10.077]                       }
[17:40:10.077]                       else if (inherits(cond, "warning")) {
[17:40:10.077]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.077]                         if (muffled) 
[17:40:10.077]                           invokeRestart("muffleWarning")
[17:40:10.077]                       }
[17:40:10.077]                       else if (inherits(cond, "condition")) {
[17:40:10.077]                         if (!is.null(pattern)) {
[17:40:10.077]                           computeRestarts <- base::computeRestarts
[17:40:10.077]                           grepl <- base::grepl
[17:40:10.077]                           restarts <- computeRestarts(cond)
[17:40:10.077]                           for (restart in restarts) {
[17:40:10.077]                             name <- restart$name
[17:40:10.077]                             if (is.null(name)) 
[17:40:10.077]                               next
[17:40:10.077]                             if (!grepl(pattern, name)) 
[17:40:10.077]                               next
[17:40:10.077]                             invokeRestart(restart)
[17:40:10.077]                             muffled <- TRUE
[17:40:10.077]                             break
[17:40:10.077]                           }
[17:40:10.077]                         }
[17:40:10.077]                       }
[17:40:10.077]                       invisible(muffled)
[17:40:10.077]                     }
[17:40:10.077]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.077]                   }
[17:40:10.077]                 }
[17:40:10.077]                 else {
[17:40:10.077]                   if (TRUE) {
[17:40:10.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.077]                     {
[17:40:10.077]                       inherits <- base::inherits
[17:40:10.077]                       invokeRestart <- base::invokeRestart
[17:40:10.077]                       is.null <- base::is.null
[17:40:10.077]                       muffled <- FALSE
[17:40:10.077]                       if (inherits(cond, "message")) {
[17:40:10.077]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.077]                         if (muffled) 
[17:40:10.077]                           invokeRestart("muffleMessage")
[17:40:10.077]                       }
[17:40:10.077]                       else if (inherits(cond, "warning")) {
[17:40:10.077]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.077]                         if (muffled) 
[17:40:10.077]                           invokeRestart("muffleWarning")
[17:40:10.077]                       }
[17:40:10.077]                       else if (inherits(cond, "condition")) {
[17:40:10.077]                         if (!is.null(pattern)) {
[17:40:10.077]                           computeRestarts <- base::computeRestarts
[17:40:10.077]                           grepl <- base::grepl
[17:40:10.077]                           restarts <- computeRestarts(cond)
[17:40:10.077]                           for (restart in restarts) {
[17:40:10.077]                             name <- restart$name
[17:40:10.077]                             if (is.null(name)) 
[17:40:10.077]                               next
[17:40:10.077]                             if (!grepl(pattern, name)) 
[17:40:10.077]                               next
[17:40:10.077]                             invokeRestart(restart)
[17:40:10.077]                             muffled <- TRUE
[17:40:10.077]                             break
[17:40:10.077]                           }
[17:40:10.077]                         }
[17:40:10.077]                       }
[17:40:10.077]                       invisible(muffled)
[17:40:10.077]                     }
[17:40:10.077]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.077]                   }
[17:40:10.077]                 }
[17:40:10.077]             }
[17:40:10.077]         }))
[17:40:10.077]     }, error = function(ex) {
[17:40:10.077]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:10.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.077]                 ...future.rng), started = ...future.startTime, 
[17:40:10.077]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:10.077]             version = "1.8"), class = "FutureResult")
[17:40:10.077]     }, finally = {
[17:40:10.077]         if (!identical(...future.workdir, getwd())) 
[17:40:10.077]             setwd(...future.workdir)
[17:40:10.077]         {
[17:40:10.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:10.077]                 ...future.oldOptions$nwarnings <- NULL
[17:40:10.077]             }
[17:40:10.077]             base::options(...future.oldOptions)
[17:40:10.077]             if (.Platform$OS.type == "windows") {
[17:40:10.077]                 old_names <- names(...future.oldEnvVars)
[17:40:10.077]                 envs <- base::Sys.getenv()
[17:40:10.077]                 names <- names(envs)
[17:40:10.077]                 common <- intersect(names, old_names)
[17:40:10.077]                 added <- setdiff(names, old_names)
[17:40:10.077]                 removed <- setdiff(old_names, names)
[17:40:10.077]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:10.077]                   envs[common]]
[17:40:10.077]                 NAMES <- toupper(changed)
[17:40:10.077]                 args <- list()
[17:40:10.077]                 for (kk in seq_along(NAMES)) {
[17:40:10.077]                   name <- changed[[kk]]
[17:40:10.077]                   NAME <- NAMES[[kk]]
[17:40:10.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.077]                     next
[17:40:10.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.077]                 }
[17:40:10.077]                 NAMES <- toupper(added)
[17:40:10.077]                 for (kk in seq_along(NAMES)) {
[17:40:10.077]                   name <- added[[kk]]
[17:40:10.077]                   NAME <- NAMES[[kk]]
[17:40:10.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.077]                     next
[17:40:10.077]                   args[[name]] <- ""
[17:40:10.077]                 }
[17:40:10.077]                 NAMES <- toupper(removed)
[17:40:10.077]                 for (kk in seq_along(NAMES)) {
[17:40:10.077]                   name <- removed[[kk]]
[17:40:10.077]                   NAME <- NAMES[[kk]]
[17:40:10.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.077]                     next
[17:40:10.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.077]                 }
[17:40:10.077]                 if (length(args) > 0) 
[17:40:10.077]                   base::do.call(base::Sys.setenv, args = args)
[17:40:10.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:10.077]             }
[17:40:10.077]             else {
[17:40:10.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:10.077]             }
[17:40:10.077]             {
[17:40:10.077]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:10.077]                   0L) {
[17:40:10.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:10.077]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:10.077]                   base::options(opts)
[17:40:10.077]                 }
[17:40:10.077]                 {
[17:40:10.077]                   {
[17:40:10.077]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:10.077]                     NULL
[17:40:10.077]                   }
[17:40:10.077]                   options(future.plan = NULL)
[17:40:10.077]                   if (is.na(NA_character_)) 
[17:40:10.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:10.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:10.077]                     .init = FALSE)
[17:40:10.077]                 }
[17:40:10.077]             }
[17:40:10.077]         }
[17:40:10.077]     })
[17:40:10.077]     if (TRUE) {
[17:40:10.077]         base::sink(type = "output", split = FALSE)
[17:40:10.077]         if (TRUE) {
[17:40:10.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:10.077]         }
[17:40:10.077]         else {
[17:40:10.077]             ...future.result["stdout"] <- base::list(NULL)
[17:40:10.077]         }
[17:40:10.077]         base::close(...future.stdout)
[17:40:10.077]         ...future.stdout <- NULL
[17:40:10.077]     }
[17:40:10.077]     ...future.result$conditions <- ...future.conditions
[17:40:10.077]     ...future.result$finished <- base::Sys.time()
[17:40:10.077]     ...future.result
[17:40:10.077] }
[17:40:10.128] MultisessionFuture started
[17:40:10.128] result() for ClusterFuture ...
[17:40:10.128] receiveMessageFromWorker() for ClusterFuture ...
[17:40:10.128] - Validating connection of MultisessionFuture
[17:40:10.160] - received message: FutureResult
[17:40:10.160] - Received FutureResult
[17:40:10.160] - Erased future from FutureRegistry
[17:40:10.160] result() for ClusterFuture ...
[17:40:10.160] - result already collected: FutureResult
[17:40:10.160] result() for ClusterFuture ... done
[17:40:10.160] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:10.160] result() for ClusterFuture ... done
[17:40:10.160] result() for ClusterFuture ...
[17:40:10.161] - result already collected: FutureResult
[17:40:10.161] result() for ClusterFuture ... done
[17:40:10.161] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:10.161] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[17:40:10.161] getGlobalsAndPackages() ...
[17:40:10.161] Searching for globals...
[17:40:10.162] - globals found: [2] ‘{’, ‘gc’
[17:40:10.162] Searching for globals ... DONE
[17:40:10.162] Resolving globals: FALSE
[17:40:10.163] 
[17:40:10.163] 
[17:40:10.163] getGlobalsAndPackages() ... DONE
[17:40:10.163] run() for ‘Future’ ...
[17:40:10.163] - state: ‘created’
[17:40:10.163] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:10.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:10.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:10.174]   - Field: ‘node’
[17:40:10.174]   - Field: ‘label’
[17:40:10.174]   - Field: ‘local’
[17:40:10.174]   - Field: ‘owner’
[17:40:10.174]   - Field: ‘envir’
[17:40:10.174]   - Field: ‘workers’
[17:40:10.174]   - Field: ‘packages’
[17:40:10.174]   - Field: ‘gc’
[17:40:10.175]   - Field: ‘conditions’
[17:40:10.175]   - Field: ‘persistent’
[17:40:10.175]   - Field: ‘expr’
[17:40:10.175]   - Field: ‘uuid’
[17:40:10.175]   - Field: ‘seed’
[17:40:10.175]   - Field: ‘version’
[17:40:10.175]   - Field: ‘result’
[17:40:10.175]   - Field: ‘asynchronous’
[17:40:10.175]   - Field: ‘calls’
[17:40:10.175]   - Field: ‘globals’
[17:40:10.175]   - Field: ‘stdout’
[17:40:10.175]   - Field: ‘earlySignal’
[17:40:10.176]   - Field: ‘lazy’
[17:40:10.176]   - Field: ‘state’
[17:40:10.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:10.176] - Launch lazy future ...
[17:40:10.176] Packages needed by the future expression (n = 0): <none>
[17:40:10.176] Packages needed by future strategies (n = 0): <none>
[17:40:10.177] {
[17:40:10.177]     {
[17:40:10.177]         {
[17:40:10.177]             ...future.startTime <- base::Sys.time()
[17:40:10.177]             {
[17:40:10.177]                 {
[17:40:10.177]                   {
[17:40:10.177]                     {
[17:40:10.177]                       base::local({
[17:40:10.177]                         has_future <- base::requireNamespace("future", 
[17:40:10.177]                           quietly = TRUE)
[17:40:10.177]                         if (has_future) {
[17:40:10.177]                           ns <- base::getNamespace("future")
[17:40:10.177]                           version <- ns[[".package"]][["version"]]
[17:40:10.177]                           if (is.null(version)) 
[17:40:10.177]                             version <- utils::packageVersion("future")
[17:40:10.177]                         }
[17:40:10.177]                         else {
[17:40:10.177]                           version <- NULL
[17:40:10.177]                         }
[17:40:10.177]                         if (!has_future || version < "1.8.0") {
[17:40:10.177]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:10.177]                             "", base::R.version$version.string), 
[17:40:10.177]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:10.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:10.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:10.177]                               "release", "version")], collapse = " "), 
[17:40:10.177]                             hostname = base::Sys.info()[["nodename"]])
[17:40:10.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:10.177]                             info)
[17:40:10.177]                           info <- base::paste(info, collapse = "; ")
[17:40:10.177]                           if (!has_future) {
[17:40:10.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:10.177]                               info)
[17:40:10.177]                           }
[17:40:10.177]                           else {
[17:40:10.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:10.177]                               info, version)
[17:40:10.177]                           }
[17:40:10.177]                           base::stop(msg)
[17:40:10.177]                         }
[17:40:10.177]                       })
[17:40:10.177]                     }
[17:40:10.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:10.177]                     base::options(mc.cores = 1L)
[17:40:10.177]                   }
[17:40:10.177]                   ...future.strategy.old <- future::plan("list")
[17:40:10.177]                   options(future.plan = NULL)
[17:40:10.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:10.177]                 }
[17:40:10.177]                 ...future.workdir <- getwd()
[17:40:10.177]             }
[17:40:10.177]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:10.177]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:10.177]         }
[17:40:10.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:10.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:10.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:10.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:10.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:10.177]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:10.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:10.177]             base::names(...future.oldOptions))
[17:40:10.177]     }
[17:40:10.177]     if (FALSE) {
[17:40:10.177]     }
[17:40:10.177]     else {
[17:40:10.177]         if (TRUE) {
[17:40:10.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:10.177]                 open = "w")
[17:40:10.177]         }
[17:40:10.177]         else {
[17:40:10.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:10.177]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:10.177]         }
[17:40:10.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:10.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:10.177]             base::sink(type = "output", split = FALSE)
[17:40:10.177]             base::close(...future.stdout)
[17:40:10.177]         }, add = TRUE)
[17:40:10.177]     }
[17:40:10.177]     ...future.frame <- base::sys.nframe()
[17:40:10.177]     ...future.conditions <- base::list()
[17:40:10.177]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:10.177]     if (FALSE) {
[17:40:10.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:10.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:10.177]     }
[17:40:10.177]     ...future.result <- base::tryCatch({
[17:40:10.177]         base::withCallingHandlers({
[17:40:10.177]             ...future.value <- base::withVisible(base::local({
[17:40:10.177]                 ...future.makeSendCondition <- base::local({
[17:40:10.177]                   sendCondition <- NULL
[17:40:10.177]                   function(frame = 1L) {
[17:40:10.177]                     if (is.function(sendCondition)) 
[17:40:10.177]                       return(sendCondition)
[17:40:10.177]                     ns <- getNamespace("parallel")
[17:40:10.177]                     if (exists("sendData", mode = "function", 
[17:40:10.177]                       envir = ns)) {
[17:40:10.177]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:10.177]                         envir = ns)
[17:40:10.177]                       envir <- sys.frame(frame)
[17:40:10.177]                       master <- NULL
[17:40:10.177]                       while (!identical(envir, .GlobalEnv) && 
[17:40:10.177]                         !identical(envir, emptyenv())) {
[17:40:10.177]                         if (exists("master", mode = "list", envir = envir, 
[17:40:10.177]                           inherits = FALSE)) {
[17:40:10.177]                           master <- get("master", mode = "list", 
[17:40:10.177]                             envir = envir, inherits = FALSE)
[17:40:10.177]                           if (inherits(master, c("SOCKnode", 
[17:40:10.177]                             "SOCK0node"))) {
[17:40:10.177]                             sendCondition <<- function(cond) {
[17:40:10.177]                               data <- list(type = "VALUE", value = cond, 
[17:40:10.177]                                 success = TRUE)
[17:40:10.177]                               parallel_sendData(master, data)
[17:40:10.177]                             }
[17:40:10.177]                             return(sendCondition)
[17:40:10.177]                           }
[17:40:10.177]                         }
[17:40:10.177]                         frame <- frame + 1L
[17:40:10.177]                         envir <- sys.frame(frame)
[17:40:10.177]                       }
[17:40:10.177]                     }
[17:40:10.177]                     sendCondition <<- function(cond) NULL
[17:40:10.177]                   }
[17:40:10.177]                 })
[17:40:10.177]                 withCallingHandlers({
[17:40:10.177]                   {
[17:40:10.177]                     gc()
[17:40:10.177]                   }
[17:40:10.177]                 }, immediateCondition = function(cond) {
[17:40:10.177]                   sendCondition <- ...future.makeSendCondition()
[17:40:10.177]                   sendCondition(cond)
[17:40:10.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.177]                   {
[17:40:10.177]                     inherits <- base::inherits
[17:40:10.177]                     invokeRestart <- base::invokeRestart
[17:40:10.177]                     is.null <- base::is.null
[17:40:10.177]                     muffled <- FALSE
[17:40:10.177]                     if (inherits(cond, "message")) {
[17:40:10.177]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:10.177]                       if (muffled) 
[17:40:10.177]                         invokeRestart("muffleMessage")
[17:40:10.177]                     }
[17:40:10.177]                     else if (inherits(cond, "warning")) {
[17:40:10.177]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:10.177]                       if (muffled) 
[17:40:10.177]                         invokeRestart("muffleWarning")
[17:40:10.177]                     }
[17:40:10.177]                     else if (inherits(cond, "condition")) {
[17:40:10.177]                       if (!is.null(pattern)) {
[17:40:10.177]                         computeRestarts <- base::computeRestarts
[17:40:10.177]                         grepl <- base::grepl
[17:40:10.177]                         restarts <- computeRestarts(cond)
[17:40:10.177]                         for (restart in restarts) {
[17:40:10.177]                           name <- restart$name
[17:40:10.177]                           if (is.null(name)) 
[17:40:10.177]                             next
[17:40:10.177]                           if (!grepl(pattern, name)) 
[17:40:10.177]                             next
[17:40:10.177]                           invokeRestart(restart)
[17:40:10.177]                           muffled <- TRUE
[17:40:10.177]                           break
[17:40:10.177]                         }
[17:40:10.177]                       }
[17:40:10.177]                     }
[17:40:10.177]                     invisible(muffled)
[17:40:10.177]                   }
[17:40:10.177]                   muffleCondition(cond)
[17:40:10.177]                 })
[17:40:10.177]             }))
[17:40:10.177]             future::FutureResult(value = ...future.value$value, 
[17:40:10.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.177]                   ...future.rng), globalenv = if (FALSE) 
[17:40:10.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:10.177]                     ...future.globalenv.names))
[17:40:10.177]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:10.177]         }, condition = base::local({
[17:40:10.177]             c <- base::c
[17:40:10.177]             inherits <- base::inherits
[17:40:10.177]             invokeRestart <- base::invokeRestart
[17:40:10.177]             length <- base::length
[17:40:10.177]             list <- base::list
[17:40:10.177]             seq.int <- base::seq.int
[17:40:10.177]             signalCondition <- base::signalCondition
[17:40:10.177]             sys.calls <- base::sys.calls
[17:40:10.177]             `[[` <- base::`[[`
[17:40:10.177]             `+` <- base::`+`
[17:40:10.177]             `<<-` <- base::`<<-`
[17:40:10.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:10.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:10.177]                   3L)]
[17:40:10.177]             }
[17:40:10.177]             function(cond) {
[17:40:10.177]                 is_error <- inherits(cond, "error")
[17:40:10.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:10.177]                   NULL)
[17:40:10.177]                 if (is_error) {
[17:40:10.177]                   sessionInformation <- function() {
[17:40:10.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:10.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:10.177]                       search = base::search(), system = base::Sys.info())
[17:40:10.177]                   }
[17:40:10.177]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:10.177]                     cond$call), session = sessionInformation(), 
[17:40:10.177]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:10.177]                   signalCondition(cond)
[17:40:10.177]                 }
[17:40:10.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:10.177]                 "immediateCondition"))) {
[17:40:10.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:10.177]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:10.177]                   if (TRUE && !signal) {
[17:40:10.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.177]                     {
[17:40:10.177]                       inherits <- base::inherits
[17:40:10.177]                       invokeRestart <- base::invokeRestart
[17:40:10.177]                       is.null <- base::is.null
[17:40:10.177]                       muffled <- FALSE
[17:40:10.177]                       if (inherits(cond, "message")) {
[17:40:10.177]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.177]                         if (muffled) 
[17:40:10.177]                           invokeRestart("muffleMessage")
[17:40:10.177]                       }
[17:40:10.177]                       else if (inherits(cond, "warning")) {
[17:40:10.177]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.177]                         if (muffled) 
[17:40:10.177]                           invokeRestart("muffleWarning")
[17:40:10.177]                       }
[17:40:10.177]                       else if (inherits(cond, "condition")) {
[17:40:10.177]                         if (!is.null(pattern)) {
[17:40:10.177]                           computeRestarts <- base::computeRestarts
[17:40:10.177]                           grepl <- base::grepl
[17:40:10.177]                           restarts <- computeRestarts(cond)
[17:40:10.177]                           for (restart in restarts) {
[17:40:10.177]                             name <- restart$name
[17:40:10.177]                             if (is.null(name)) 
[17:40:10.177]                               next
[17:40:10.177]                             if (!grepl(pattern, name)) 
[17:40:10.177]                               next
[17:40:10.177]                             invokeRestart(restart)
[17:40:10.177]                             muffled <- TRUE
[17:40:10.177]                             break
[17:40:10.177]                           }
[17:40:10.177]                         }
[17:40:10.177]                       }
[17:40:10.177]                       invisible(muffled)
[17:40:10.177]                     }
[17:40:10.177]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.177]                   }
[17:40:10.177]                 }
[17:40:10.177]                 else {
[17:40:10.177]                   if (TRUE) {
[17:40:10.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.177]                     {
[17:40:10.177]                       inherits <- base::inherits
[17:40:10.177]                       invokeRestart <- base::invokeRestart
[17:40:10.177]                       is.null <- base::is.null
[17:40:10.177]                       muffled <- FALSE
[17:40:10.177]                       if (inherits(cond, "message")) {
[17:40:10.177]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.177]                         if (muffled) 
[17:40:10.177]                           invokeRestart("muffleMessage")
[17:40:10.177]                       }
[17:40:10.177]                       else if (inherits(cond, "warning")) {
[17:40:10.177]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.177]                         if (muffled) 
[17:40:10.177]                           invokeRestart("muffleWarning")
[17:40:10.177]                       }
[17:40:10.177]                       else if (inherits(cond, "condition")) {
[17:40:10.177]                         if (!is.null(pattern)) {
[17:40:10.177]                           computeRestarts <- base::computeRestarts
[17:40:10.177]                           grepl <- base::grepl
[17:40:10.177]                           restarts <- computeRestarts(cond)
[17:40:10.177]                           for (restart in restarts) {
[17:40:10.177]                             name <- restart$name
[17:40:10.177]                             if (is.null(name)) 
[17:40:10.177]                               next
[17:40:10.177]                             if (!grepl(pattern, name)) 
[17:40:10.177]                               next
[17:40:10.177]                             invokeRestart(restart)
[17:40:10.177]                             muffled <- TRUE
[17:40:10.177]                             break
[17:40:10.177]                           }
[17:40:10.177]                         }
[17:40:10.177]                       }
[17:40:10.177]                       invisible(muffled)
[17:40:10.177]                     }
[17:40:10.177]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.177]                   }
[17:40:10.177]                 }
[17:40:10.177]             }
[17:40:10.177]         }))
[17:40:10.177]     }, error = function(ex) {
[17:40:10.177]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:10.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.177]                 ...future.rng), started = ...future.startTime, 
[17:40:10.177]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:10.177]             version = "1.8"), class = "FutureResult")
[17:40:10.177]     }, finally = {
[17:40:10.177]         if (!identical(...future.workdir, getwd())) 
[17:40:10.177]             setwd(...future.workdir)
[17:40:10.177]         {
[17:40:10.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:10.177]                 ...future.oldOptions$nwarnings <- NULL
[17:40:10.177]             }
[17:40:10.177]             base::options(...future.oldOptions)
[17:40:10.177]             if (.Platform$OS.type == "windows") {
[17:40:10.177]                 old_names <- names(...future.oldEnvVars)
[17:40:10.177]                 envs <- base::Sys.getenv()
[17:40:10.177]                 names <- names(envs)
[17:40:10.177]                 common <- intersect(names, old_names)
[17:40:10.177]                 added <- setdiff(names, old_names)
[17:40:10.177]                 removed <- setdiff(old_names, names)
[17:40:10.177]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:10.177]                   envs[common]]
[17:40:10.177]                 NAMES <- toupper(changed)
[17:40:10.177]                 args <- list()
[17:40:10.177]                 for (kk in seq_along(NAMES)) {
[17:40:10.177]                   name <- changed[[kk]]
[17:40:10.177]                   NAME <- NAMES[[kk]]
[17:40:10.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.177]                     next
[17:40:10.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.177]                 }
[17:40:10.177]                 NAMES <- toupper(added)
[17:40:10.177]                 for (kk in seq_along(NAMES)) {
[17:40:10.177]                   name <- added[[kk]]
[17:40:10.177]                   NAME <- NAMES[[kk]]
[17:40:10.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.177]                     next
[17:40:10.177]                   args[[name]] <- ""
[17:40:10.177]                 }
[17:40:10.177]                 NAMES <- toupper(removed)
[17:40:10.177]                 for (kk in seq_along(NAMES)) {
[17:40:10.177]                   name <- removed[[kk]]
[17:40:10.177]                   NAME <- NAMES[[kk]]
[17:40:10.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.177]                     next
[17:40:10.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.177]                 }
[17:40:10.177]                 if (length(args) > 0) 
[17:40:10.177]                   base::do.call(base::Sys.setenv, args = args)
[17:40:10.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:10.177]             }
[17:40:10.177]             else {
[17:40:10.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:10.177]             }
[17:40:10.177]             {
[17:40:10.177]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:10.177]                   0L) {
[17:40:10.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:10.177]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:10.177]                   base::options(opts)
[17:40:10.177]                 }
[17:40:10.177]                 {
[17:40:10.177]                   {
[17:40:10.177]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:10.177]                     NULL
[17:40:10.177]                   }
[17:40:10.177]                   options(future.plan = NULL)
[17:40:10.177]                   if (is.na(NA_character_)) 
[17:40:10.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:10.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:10.177]                     .init = FALSE)
[17:40:10.177]                 }
[17:40:10.177]             }
[17:40:10.177]         }
[17:40:10.177]     })
[17:40:10.177]     if (TRUE) {
[17:40:10.177]         base::sink(type = "output", split = FALSE)
[17:40:10.177]         if (TRUE) {
[17:40:10.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:10.177]         }
[17:40:10.177]         else {
[17:40:10.177]             ...future.result["stdout"] <- base::list(NULL)
[17:40:10.177]         }
[17:40:10.177]         base::close(...future.stdout)
[17:40:10.177]         ...future.stdout <- NULL
[17:40:10.177]     }
[17:40:10.177]     ...future.result$conditions <- ...future.conditions
[17:40:10.177]     ...future.result$finished <- base::Sys.time()
[17:40:10.177]     ...future.result
[17:40:10.177] }
[17:40:10.180] MultisessionFuture started
[17:40:10.180] - Launch lazy future ... done
[17:40:10.180] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[17:40:10.180] result() for ClusterFuture ...
[17:40:10.180] receiveMessageFromWorker() for ClusterFuture ...
[17:40:10.181] - Validating connection of MultisessionFuture
[17:40:10.205] - received message: FutureResult
[17:40:10.205] - Received FutureResult
[17:40:10.205] - Erased future from FutureRegistry
[17:40:10.205] result() for ClusterFuture ...
[17:40:10.206] - result already collected: FutureResult
[17:40:10.206] result() for ClusterFuture ... done
[17:40:10.206] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:10.206] result() for ClusterFuture ... done
[17:40:10.206] result() for ClusterFuture ...
[17:40:10.206] - result already collected: FutureResult
[17:40:10.206] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 407014 21.8     692222   37   692222 37.0
Vcells 729668  5.6    8388608   64  1923668 14.7
> 
> f <- future({ integer(10e6) })
[17:40:10.206] getGlobalsAndPackages() ...
[17:40:10.207] Searching for globals...
[17:40:10.207] - globals found: [2] ‘{’, ‘integer’
[17:40:10.207] Searching for globals ... DONE
[17:40:10.208] Resolving globals: FALSE
[17:40:10.208] 
[17:40:10.208] 
[17:40:10.208] getGlobalsAndPackages() ... DONE
[17:40:10.208] run() for ‘Future’ ...
[17:40:10.208] - state: ‘created’
[17:40:10.209] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:10.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:10.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:10.219]   - Field: ‘node’
[17:40:10.219]   - Field: ‘label’
[17:40:10.219]   - Field: ‘local’
[17:40:10.219]   - Field: ‘owner’
[17:40:10.219]   - Field: ‘envir’
[17:40:10.220]   - Field: ‘workers’
[17:40:10.220]   - Field: ‘packages’
[17:40:10.220]   - Field: ‘gc’
[17:40:10.220]   - Field: ‘conditions’
[17:40:10.220]   - Field: ‘persistent’
[17:40:10.220]   - Field: ‘expr’
[17:40:10.220]   - Field: ‘uuid’
[17:40:10.220]   - Field: ‘seed’
[17:40:10.220]   - Field: ‘version’
[17:40:10.220]   - Field: ‘result’
[17:40:10.220]   - Field: ‘asynchronous’
[17:40:10.221]   - Field: ‘calls’
[17:40:10.221]   - Field: ‘globals’
[17:40:10.221]   - Field: ‘stdout’
[17:40:10.221]   - Field: ‘earlySignal’
[17:40:10.221]   - Field: ‘lazy’
[17:40:10.221]   - Field: ‘state’
[17:40:10.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:10.221] - Launch lazy future ...
[17:40:10.221] Packages needed by the future expression (n = 0): <none>
[17:40:10.222] Packages needed by future strategies (n = 0): <none>
[17:40:10.224] {
[17:40:10.224]     {
[17:40:10.224]         {
[17:40:10.224]             ...future.startTime <- base::Sys.time()
[17:40:10.224]             {
[17:40:10.224]                 {
[17:40:10.224]                   {
[17:40:10.224]                     {
[17:40:10.224]                       base::local({
[17:40:10.224]                         has_future <- base::requireNamespace("future", 
[17:40:10.224]                           quietly = TRUE)
[17:40:10.224]                         if (has_future) {
[17:40:10.224]                           ns <- base::getNamespace("future")
[17:40:10.224]                           version <- ns[[".package"]][["version"]]
[17:40:10.224]                           if (is.null(version)) 
[17:40:10.224]                             version <- utils::packageVersion("future")
[17:40:10.224]                         }
[17:40:10.224]                         else {
[17:40:10.224]                           version <- NULL
[17:40:10.224]                         }
[17:40:10.224]                         if (!has_future || version < "1.8.0") {
[17:40:10.224]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:10.224]                             "", base::R.version$version.string), 
[17:40:10.224]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:10.224]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:10.224]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:10.224]                               "release", "version")], collapse = " "), 
[17:40:10.224]                             hostname = base::Sys.info()[["nodename"]])
[17:40:10.224]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:10.224]                             info)
[17:40:10.224]                           info <- base::paste(info, collapse = "; ")
[17:40:10.224]                           if (!has_future) {
[17:40:10.224]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:10.224]                               info)
[17:40:10.224]                           }
[17:40:10.224]                           else {
[17:40:10.224]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:10.224]                               info, version)
[17:40:10.224]                           }
[17:40:10.224]                           base::stop(msg)
[17:40:10.224]                         }
[17:40:10.224]                       })
[17:40:10.224]                     }
[17:40:10.224]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:10.224]                     base::options(mc.cores = 1L)
[17:40:10.224]                   }
[17:40:10.224]                   ...future.strategy.old <- future::plan("list")
[17:40:10.224]                   options(future.plan = NULL)
[17:40:10.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:10.224]                 }
[17:40:10.224]                 ...future.workdir <- getwd()
[17:40:10.224]             }
[17:40:10.224]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:10.224]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:10.224]         }
[17:40:10.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:10.224]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:10.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:10.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:10.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:10.224]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:10.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:10.224]             base::names(...future.oldOptions))
[17:40:10.224]     }
[17:40:10.224]     if (FALSE) {
[17:40:10.224]     }
[17:40:10.224]     else {
[17:40:10.224]         if (TRUE) {
[17:40:10.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:10.224]                 open = "w")
[17:40:10.224]         }
[17:40:10.224]         else {
[17:40:10.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:10.224]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:10.224]         }
[17:40:10.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:10.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:10.224]             base::sink(type = "output", split = FALSE)
[17:40:10.224]             base::close(...future.stdout)
[17:40:10.224]         }, add = TRUE)
[17:40:10.224]     }
[17:40:10.224]     ...future.frame <- base::sys.nframe()
[17:40:10.224]     ...future.conditions <- base::list()
[17:40:10.224]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:10.224]     if (FALSE) {
[17:40:10.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:10.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:10.224]     }
[17:40:10.224]     ...future.result <- base::tryCatch({
[17:40:10.224]         base::withCallingHandlers({
[17:40:10.224]             ...future.value <- base::withVisible(base::local({
[17:40:10.224]                 ...future.makeSendCondition <- base::local({
[17:40:10.224]                   sendCondition <- NULL
[17:40:10.224]                   function(frame = 1L) {
[17:40:10.224]                     if (is.function(sendCondition)) 
[17:40:10.224]                       return(sendCondition)
[17:40:10.224]                     ns <- getNamespace("parallel")
[17:40:10.224]                     if (exists("sendData", mode = "function", 
[17:40:10.224]                       envir = ns)) {
[17:40:10.224]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:10.224]                         envir = ns)
[17:40:10.224]                       envir <- sys.frame(frame)
[17:40:10.224]                       master <- NULL
[17:40:10.224]                       while (!identical(envir, .GlobalEnv) && 
[17:40:10.224]                         !identical(envir, emptyenv())) {
[17:40:10.224]                         if (exists("master", mode = "list", envir = envir, 
[17:40:10.224]                           inherits = FALSE)) {
[17:40:10.224]                           master <- get("master", mode = "list", 
[17:40:10.224]                             envir = envir, inherits = FALSE)
[17:40:10.224]                           if (inherits(master, c("SOCKnode", 
[17:40:10.224]                             "SOCK0node"))) {
[17:40:10.224]                             sendCondition <<- function(cond) {
[17:40:10.224]                               data <- list(type = "VALUE", value = cond, 
[17:40:10.224]                                 success = TRUE)
[17:40:10.224]                               parallel_sendData(master, data)
[17:40:10.224]                             }
[17:40:10.224]                             return(sendCondition)
[17:40:10.224]                           }
[17:40:10.224]                         }
[17:40:10.224]                         frame <- frame + 1L
[17:40:10.224]                         envir <- sys.frame(frame)
[17:40:10.224]                       }
[17:40:10.224]                     }
[17:40:10.224]                     sendCondition <<- function(cond) NULL
[17:40:10.224]                   }
[17:40:10.224]                 })
[17:40:10.224]                 withCallingHandlers({
[17:40:10.224]                   {
[17:40:10.224]                     integer(1e+07)
[17:40:10.224]                   }
[17:40:10.224]                 }, immediateCondition = function(cond) {
[17:40:10.224]                   sendCondition <- ...future.makeSendCondition()
[17:40:10.224]                   sendCondition(cond)
[17:40:10.224]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.224]                   {
[17:40:10.224]                     inherits <- base::inherits
[17:40:10.224]                     invokeRestart <- base::invokeRestart
[17:40:10.224]                     is.null <- base::is.null
[17:40:10.224]                     muffled <- FALSE
[17:40:10.224]                     if (inherits(cond, "message")) {
[17:40:10.224]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:10.224]                       if (muffled) 
[17:40:10.224]                         invokeRestart("muffleMessage")
[17:40:10.224]                     }
[17:40:10.224]                     else if (inherits(cond, "warning")) {
[17:40:10.224]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:10.224]                       if (muffled) 
[17:40:10.224]                         invokeRestart("muffleWarning")
[17:40:10.224]                     }
[17:40:10.224]                     else if (inherits(cond, "condition")) {
[17:40:10.224]                       if (!is.null(pattern)) {
[17:40:10.224]                         computeRestarts <- base::computeRestarts
[17:40:10.224]                         grepl <- base::grepl
[17:40:10.224]                         restarts <- computeRestarts(cond)
[17:40:10.224]                         for (restart in restarts) {
[17:40:10.224]                           name <- restart$name
[17:40:10.224]                           if (is.null(name)) 
[17:40:10.224]                             next
[17:40:10.224]                           if (!grepl(pattern, name)) 
[17:40:10.224]                             next
[17:40:10.224]                           invokeRestart(restart)
[17:40:10.224]                           muffled <- TRUE
[17:40:10.224]                           break
[17:40:10.224]                         }
[17:40:10.224]                       }
[17:40:10.224]                     }
[17:40:10.224]                     invisible(muffled)
[17:40:10.224]                   }
[17:40:10.224]                   muffleCondition(cond)
[17:40:10.224]                 })
[17:40:10.224]             }))
[17:40:10.224]             future::FutureResult(value = ...future.value$value, 
[17:40:10.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.224]                   ...future.rng), globalenv = if (FALSE) 
[17:40:10.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:10.224]                     ...future.globalenv.names))
[17:40:10.224]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:10.224]         }, condition = base::local({
[17:40:10.224]             c <- base::c
[17:40:10.224]             inherits <- base::inherits
[17:40:10.224]             invokeRestart <- base::invokeRestart
[17:40:10.224]             length <- base::length
[17:40:10.224]             list <- base::list
[17:40:10.224]             seq.int <- base::seq.int
[17:40:10.224]             signalCondition <- base::signalCondition
[17:40:10.224]             sys.calls <- base::sys.calls
[17:40:10.224]             `[[` <- base::`[[`
[17:40:10.224]             `+` <- base::`+`
[17:40:10.224]             `<<-` <- base::`<<-`
[17:40:10.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:10.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:10.224]                   3L)]
[17:40:10.224]             }
[17:40:10.224]             function(cond) {
[17:40:10.224]                 is_error <- inherits(cond, "error")
[17:40:10.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:10.224]                   NULL)
[17:40:10.224]                 if (is_error) {
[17:40:10.224]                   sessionInformation <- function() {
[17:40:10.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:10.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:10.224]                       search = base::search(), system = base::Sys.info())
[17:40:10.224]                   }
[17:40:10.224]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:10.224]                     cond$call), session = sessionInformation(), 
[17:40:10.224]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:10.224]                   signalCondition(cond)
[17:40:10.224]                 }
[17:40:10.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:10.224]                 "immediateCondition"))) {
[17:40:10.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:10.224]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:10.224]                   if (TRUE && !signal) {
[17:40:10.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.224]                     {
[17:40:10.224]                       inherits <- base::inherits
[17:40:10.224]                       invokeRestart <- base::invokeRestart
[17:40:10.224]                       is.null <- base::is.null
[17:40:10.224]                       muffled <- FALSE
[17:40:10.224]                       if (inherits(cond, "message")) {
[17:40:10.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.224]                         if (muffled) 
[17:40:10.224]                           invokeRestart("muffleMessage")
[17:40:10.224]                       }
[17:40:10.224]                       else if (inherits(cond, "warning")) {
[17:40:10.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.224]                         if (muffled) 
[17:40:10.224]                           invokeRestart("muffleWarning")
[17:40:10.224]                       }
[17:40:10.224]                       else if (inherits(cond, "condition")) {
[17:40:10.224]                         if (!is.null(pattern)) {
[17:40:10.224]                           computeRestarts <- base::computeRestarts
[17:40:10.224]                           grepl <- base::grepl
[17:40:10.224]                           restarts <- computeRestarts(cond)
[17:40:10.224]                           for (restart in restarts) {
[17:40:10.224]                             name <- restart$name
[17:40:10.224]                             if (is.null(name)) 
[17:40:10.224]                               next
[17:40:10.224]                             if (!grepl(pattern, name)) 
[17:40:10.224]                               next
[17:40:10.224]                             invokeRestart(restart)
[17:40:10.224]                             muffled <- TRUE
[17:40:10.224]                             break
[17:40:10.224]                           }
[17:40:10.224]                         }
[17:40:10.224]                       }
[17:40:10.224]                       invisible(muffled)
[17:40:10.224]                     }
[17:40:10.224]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.224]                   }
[17:40:10.224]                 }
[17:40:10.224]                 else {
[17:40:10.224]                   if (TRUE) {
[17:40:10.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.224]                     {
[17:40:10.224]                       inherits <- base::inherits
[17:40:10.224]                       invokeRestart <- base::invokeRestart
[17:40:10.224]                       is.null <- base::is.null
[17:40:10.224]                       muffled <- FALSE
[17:40:10.224]                       if (inherits(cond, "message")) {
[17:40:10.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.224]                         if (muffled) 
[17:40:10.224]                           invokeRestart("muffleMessage")
[17:40:10.224]                       }
[17:40:10.224]                       else if (inherits(cond, "warning")) {
[17:40:10.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.224]                         if (muffled) 
[17:40:10.224]                           invokeRestart("muffleWarning")
[17:40:10.224]                       }
[17:40:10.224]                       else if (inherits(cond, "condition")) {
[17:40:10.224]                         if (!is.null(pattern)) {
[17:40:10.224]                           computeRestarts <- base::computeRestarts
[17:40:10.224]                           grepl <- base::grepl
[17:40:10.224]                           restarts <- computeRestarts(cond)
[17:40:10.224]                           for (restart in restarts) {
[17:40:10.224]                             name <- restart$name
[17:40:10.224]                             if (is.null(name)) 
[17:40:10.224]                               next
[17:40:10.224]                             if (!grepl(pattern, name)) 
[17:40:10.224]                               next
[17:40:10.224]                             invokeRestart(restart)
[17:40:10.224]                             muffled <- TRUE
[17:40:10.224]                             break
[17:40:10.224]                           }
[17:40:10.224]                         }
[17:40:10.224]                       }
[17:40:10.224]                       invisible(muffled)
[17:40:10.224]                     }
[17:40:10.224]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.224]                   }
[17:40:10.224]                 }
[17:40:10.224]             }
[17:40:10.224]         }))
[17:40:10.224]     }, error = function(ex) {
[17:40:10.224]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:10.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.224]                 ...future.rng), started = ...future.startTime, 
[17:40:10.224]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:10.224]             version = "1.8"), class = "FutureResult")
[17:40:10.224]     }, finally = {
[17:40:10.224]         if (!identical(...future.workdir, getwd())) 
[17:40:10.224]             setwd(...future.workdir)
[17:40:10.224]         {
[17:40:10.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:10.224]                 ...future.oldOptions$nwarnings <- NULL
[17:40:10.224]             }
[17:40:10.224]             base::options(...future.oldOptions)
[17:40:10.224]             if (.Platform$OS.type == "windows") {
[17:40:10.224]                 old_names <- names(...future.oldEnvVars)
[17:40:10.224]                 envs <- base::Sys.getenv()
[17:40:10.224]                 names <- names(envs)
[17:40:10.224]                 common <- intersect(names, old_names)
[17:40:10.224]                 added <- setdiff(names, old_names)
[17:40:10.224]                 removed <- setdiff(old_names, names)
[17:40:10.224]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:10.224]                   envs[common]]
[17:40:10.224]                 NAMES <- toupper(changed)
[17:40:10.224]                 args <- list()
[17:40:10.224]                 for (kk in seq_along(NAMES)) {
[17:40:10.224]                   name <- changed[[kk]]
[17:40:10.224]                   NAME <- NAMES[[kk]]
[17:40:10.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.224]                     next
[17:40:10.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.224]                 }
[17:40:10.224]                 NAMES <- toupper(added)
[17:40:10.224]                 for (kk in seq_along(NAMES)) {
[17:40:10.224]                   name <- added[[kk]]
[17:40:10.224]                   NAME <- NAMES[[kk]]
[17:40:10.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.224]                     next
[17:40:10.224]                   args[[name]] <- ""
[17:40:10.224]                 }
[17:40:10.224]                 NAMES <- toupper(removed)
[17:40:10.224]                 for (kk in seq_along(NAMES)) {
[17:40:10.224]                   name <- removed[[kk]]
[17:40:10.224]                   NAME <- NAMES[[kk]]
[17:40:10.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.224]                     next
[17:40:10.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.224]                 }
[17:40:10.224]                 if (length(args) > 0) 
[17:40:10.224]                   base::do.call(base::Sys.setenv, args = args)
[17:40:10.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:10.224]             }
[17:40:10.224]             else {
[17:40:10.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:10.224]             }
[17:40:10.224]             {
[17:40:10.224]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:10.224]                   0L) {
[17:40:10.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:10.224]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:10.224]                   base::options(opts)
[17:40:10.224]                 }
[17:40:10.224]                 {
[17:40:10.224]                   {
[17:40:10.224]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:10.224]                     NULL
[17:40:10.224]                   }
[17:40:10.224]                   options(future.plan = NULL)
[17:40:10.224]                   if (is.na(NA_character_)) 
[17:40:10.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:10.224]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:10.224]                     .init = FALSE)
[17:40:10.224]                 }
[17:40:10.224]             }
[17:40:10.224]         }
[17:40:10.224]     })
[17:40:10.224]     if (TRUE) {
[17:40:10.224]         base::sink(type = "output", split = FALSE)
[17:40:10.224]         if (TRUE) {
[17:40:10.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:10.224]         }
[17:40:10.224]         else {
[17:40:10.224]             ...future.result["stdout"] <- base::list(NULL)
[17:40:10.224]         }
[17:40:10.224]         base::close(...future.stdout)
[17:40:10.224]         ...future.stdout <- NULL
[17:40:10.224]     }
[17:40:10.224]     ...future.result$conditions <- ...future.conditions
[17:40:10.224]     ...future.result$finished <- base::Sys.time()
[17:40:10.224]     ...future.result
[17:40:10.224] }
[17:40:10.227] MultisessionFuture started
[17:40:10.227] - Launch lazy future ... done
[17:40:10.227] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[17:40:10.228] result() for ClusterFuture ...
[17:40:10.228] receiveMessageFromWorker() for ClusterFuture ...
[17:40:10.228] - Validating connection of MultisessionFuture
[17:40:10.287] - received message: FutureResult
[17:40:10.288] - Received FutureResult
[17:40:10.288] - Erased future from FutureRegistry
[17:40:10.288] result() for ClusterFuture ...
[17:40:10.288] - result already collected: FutureResult
[17:40:10.288] result() for ClusterFuture ... done
[17:40:10.288] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:10.288] result() for ClusterFuture ... done
[17:40:10.288] result() for ClusterFuture ...
[17:40:10.288] - result already collected: FutureResult
[17:40:10.288] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[17:40:10.289] getGlobalsAndPackages() ...
[17:40:10.289] Searching for globals...
[17:40:10.290] - globals found: [2] ‘{’, ‘gc’
[17:40:10.290] Searching for globals ... DONE
[17:40:10.290] Resolving globals: FALSE
[17:40:10.290] 
[17:40:10.290] 
[17:40:10.291] getGlobalsAndPackages() ... DONE
[17:40:10.291] run() for ‘Future’ ...
[17:40:10.291] - state: ‘created’
[17:40:10.291] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:10.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:10.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:10.301]   - Field: ‘node’
[17:40:10.302]   - Field: ‘label’
[17:40:10.302]   - Field: ‘local’
[17:40:10.302]   - Field: ‘owner’
[17:40:10.302]   - Field: ‘envir’
[17:40:10.302]   - Field: ‘workers’
[17:40:10.302]   - Field: ‘packages’
[17:40:10.302]   - Field: ‘gc’
[17:40:10.302]   - Field: ‘conditions’
[17:40:10.302]   - Field: ‘persistent’
[17:40:10.302]   - Field: ‘expr’
[17:40:10.302]   - Field: ‘uuid’
[17:40:10.303]   - Field: ‘seed’
[17:40:10.303]   - Field: ‘version’
[17:40:10.303]   - Field: ‘result’
[17:40:10.303]   - Field: ‘asynchronous’
[17:40:10.303]   - Field: ‘calls’
[17:40:10.303]   - Field: ‘globals’
[17:40:10.303]   - Field: ‘stdout’
[17:40:10.303]   - Field: ‘earlySignal’
[17:40:10.303]   - Field: ‘lazy’
[17:40:10.303]   - Field: ‘state’
[17:40:10.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:10.303] - Launch lazy future ...
[17:40:10.304] Packages needed by the future expression (n = 0): <none>
[17:40:10.304] Packages needed by future strategies (n = 0): <none>
[17:40:10.304] {
[17:40:10.304]     {
[17:40:10.304]         {
[17:40:10.304]             ...future.startTime <- base::Sys.time()
[17:40:10.304]             {
[17:40:10.304]                 {
[17:40:10.304]                   {
[17:40:10.304]                     {
[17:40:10.304]                       base::local({
[17:40:10.304]                         has_future <- base::requireNamespace("future", 
[17:40:10.304]                           quietly = TRUE)
[17:40:10.304]                         if (has_future) {
[17:40:10.304]                           ns <- base::getNamespace("future")
[17:40:10.304]                           version <- ns[[".package"]][["version"]]
[17:40:10.304]                           if (is.null(version)) 
[17:40:10.304]                             version <- utils::packageVersion("future")
[17:40:10.304]                         }
[17:40:10.304]                         else {
[17:40:10.304]                           version <- NULL
[17:40:10.304]                         }
[17:40:10.304]                         if (!has_future || version < "1.8.0") {
[17:40:10.304]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:10.304]                             "", base::R.version$version.string), 
[17:40:10.304]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:10.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:10.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:10.304]                               "release", "version")], collapse = " "), 
[17:40:10.304]                             hostname = base::Sys.info()[["nodename"]])
[17:40:10.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:10.304]                             info)
[17:40:10.304]                           info <- base::paste(info, collapse = "; ")
[17:40:10.304]                           if (!has_future) {
[17:40:10.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:10.304]                               info)
[17:40:10.304]                           }
[17:40:10.304]                           else {
[17:40:10.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:10.304]                               info, version)
[17:40:10.304]                           }
[17:40:10.304]                           base::stop(msg)
[17:40:10.304]                         }
[17:40:10.304]                       })
[17:40:10.304]                     }
[17:40:10.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:10.304]                     base::options(mc.cores = 1L)
[17:40:10.304]                   }
[17:40:10.304]                   ...future.strategy.old <- future::plan("list")
[17:40:10.304]                   options(future.plan = NULL)
[17:40:10.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:10.304]                 }
[17:40:10.304]                 ...future.workdir <- getwd()
[17:40:10.304]             }
[17:40:10.304]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:10.304]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:10.304]         }
[17:40:10.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:10.304]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:10.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:10.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:10.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:10.304]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:10.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:10.304]             base::names(...future.oldOptions))
[17:40:10.304]     }
[17:40:10.304]     if (FALSE) {
[17:40:10.304]     }
[17:40:10.304]     else {
[17:40:10.304]         if (TRUE) {
[17:40:10.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:10.304]                 open = "w")
[17:40:10.304]         }
[17:40:10.304]         else {
[17:40:10.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:10.304]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:10.304]         }
[17:40:10.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:10.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:10.304]             base::sink(type = "output", split = FALSE)
[17:40:10.304]             base::close(...future.stdout)
[17:40:10.304]         }, add = TRUE)
[17:40:10.304]     }
[17:40:10.304]     ...future.frame <- base::sys.nframe()
[17:40:10.304]     ...future.conditions <- base::list()
[17:40:10.304]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:10.304]     if (FALSE) {
[17:40:10.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:10.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:10.304]     }
[17:40:10.304]     ...future.result <- base::tryCatch({
[17:40:10.304]         base::withCallingHandlers({
[17:40:10.304]             ...future.value <- base::withVisible(base::local({
[17:40:10.304]                 ...future.makeSendCondition <- base::local({
[17:40:10.304]                   sendCondition <- NULL
[17:40:10.304]                   function(frame = 1L) {
[17:40:10.304]                     if (is.function(sendCondition)) 
[17:40:10.304]                       return(sendCondition)
[17:40:10.304]                     ns <- getNamespace("parallel")
[17:40:10.304]                     if (exists("sendData", mode = "function", 
[17:40:10.304]                       envir = ns)) {
[17:40:10.304]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:10.304]                         envir = ns)
[17:40:10.304]                       envir <- sys.frame(frame)
[17:40:10.304]                       master <- NULL
[17:40:10.304]                       while (!identical(envir, .GlobalEnv) && 
[17:40:10.304]                         !identical(envir, emptyenv())) {
[17:40:10.304]                         if (exists("master", mode = "list", envir = envir, 
[17:40:10.304]                           inherits = FALSE)) {
[17:40:10.304]                           master <- get("master", mode = "list", 
[17:40:10.304]                             envir = envir, inherits = FALSE)
[17:40:10.304]                           if (inherits(master, c("SOCKnode", 
[17:40:10.304]                             "SOCK0node"))) {
[17:40:10.304]                             sendCondition <<- function(cond) {
[17:40:10.304]                               data <- list(type = "VALUE", value = cond, 
[17:40:10.304]                                 success = TRUE)
[17:40:10.304]                               parallel_sendData(master, data)
[17:40:10.304]                             }
[17:40:10.304]                             return(sendCondition)
[17:40:10.304]                           }
[17:40:10.304]                         }
[17:40:10.304]                         frame <- frame + 1L
[17:40:10.304]                         envir <- sys.frame(frame)
[17:40:10.304]                       }
[17:40:10.304]                     }
[17:40:10.304]                     sendCondition <<- function(cond) NULL
[17:40:10.304]                   }
[17:40:10.304]                 })
[17:40:10.304]                 withCallingHandlers({
[17:40:10.304]                   {
[17:40:10.304]                     gc()
[17:40:10.304]                   }
[17:40:10.304]                 }, immediateCondition = function(cond) {
[17:40:10.304]                   sendCondition <- ...future.makeSendCondition()
[17:40:10.304]                   sendCondition(cond)
[17:40:10.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.304]                   {
[17:40:10.304]                     inherits <- base::inherits
[17:40:10.304]                     invokeRestart <- base::invokeRestart
[17:40:10.304]                     is.null <- base::is.null
[17:40:10.304]                     muffled <- FALSE
[17:40:10.304]                     if (inherits(cond, "message")) {
[17:40:10.304]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:10.304]                       if (muffled) 
[17:40:10.304]                         invokeRestart("muffleMessage")
[17:40:10.304]                     }
[17:40:10.304]                     else if (inherits(cond, "warning")) {
[17:40:10.304]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:10.304]                       if (muffled) 
[17:40:10.304]                         invokeRestart("muffleWarning")
[17:40:10.304]                     }
[17:40:10.304]                     else if (inherits(cond, "condition")) {
[17:40:10.304]                       if (!is.null(pattern)) {
[17:40:10.304]                         computeRestarts <- base::computeRestarts
[17:40:10.304]                         grepl <- base::grepl
[17:40:10.304]                         restarts <- computeRestarts(cond)
[17:40:10.304]                         for (restart in restarts) {
[17:40:10.304]                           name <- restart$name
[17:40:10.304]                           if (is.null(name)) 
[17:40:10.304]                             next
[17:40:10.304]                           if (!grepl(pattern, name)) 
[17:40:10.304]                             next
[17:40:10.304]                           invokeRestart(restart)
[17:40:10.304]                           muffled <- TRUE
[17:40:10.304]                           break
[17:40:10.304]                         }
[17:40:10.304]                       }
[17:40:10.304]                     }
[17:40:10.304]                     invisible(muffled)
[17:40:10.304]                   }
[17:40:10.304]                   muffleCondition(cond)
[17:40:10.304]                 })
[17:40:10.304]             }))
[17:40:10.304]             future::FutureResult(value = ...future.value$value, 
[17:40:10.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.304]                   ...future.rng), globalenv = if (FALSE) 
[17:40:10.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:10.304]                     ...future.globalenv.names))
[17:40:10.304]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:10.304]         }, condition = base::local({
[17:40:10.304]             c <- base::c
[17:40:10.304]             inherits <- base::inherits
[17:40:10.304]             invokeRestart <- base::invokeRestart
[17:40:10.304]             length <- base::length
[17:40:10.304]             list <- base::list
[17:40:10.304]             seq.int <- base::seq.int
[17:40:10.304]             signalCondition <- base::signalCondition
[17:40:10.304]             sys.calls <- base::sys.calls
[17:40:10.304]             `[[` <- base::`[[`
[17:40:10.304]             `+` <- base::`+`
[17:40:10.304]             `<<-` <- base::`<<-`
[17:40:10.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:10.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:10.304]                   3L)]
[17:40:10.304]             }
[17:40:10.304]             function(cond) {
[17:40:10.304]                 is_error <- inherits(cond, "error")
[17:40:10.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:10.304]                   NULL)
[17:40:10.304]                 if (is_error) {
[17:40:10.304]                   sessionInformation <- function() {
[17:40:10.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:10.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:10.304]                       search = base::search(), system = base::Sys.info())
[17:40:10.304]                   }
[17:40:10.304]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:10.304]                     cond$call), session = sessionInformation(), 
[17:40:10.304]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:10.304]                   signalCondition(cond)
[17:40:10.304]                 }
[17:40:10.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:10.304]                 "immediateCondition"))) {
[17:40:10.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:10.304]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:10.304]                   if (TRUE && !signal) {
[17:40:10.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.304]                     {
[17:40:10.304]                       inherits <- base::inherits
[17:40:10.304]                       invokeRestart <- base::invokeRestart
[17:40:10.304]                       is.null <- base::is.null
[17:40:10.304]                       muffled <- FALSE
[17:40:10.304]                       if (inherits(cond, "message")) {
[17:40:10.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.304]                         if (muffled) 
[17:40:10.304]                           invokeRestart("muffleMessage")
[17:40:10.304]                       }
[17:40:10.304]                       else if (inherits(cond, "warning")) {
[17:40:10.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.304]                         if (muffled) 
[17:40:10.304]                           invokeRestart("muffleWarning")
[17:40:10.304]                       }
[17:40:10.304]                       else if (inherits(cond, "condition")) {
[17:40:10.304]                         if (!is.null(pattern)) {
[17:40:10.304]                           computeRestarts <- base::computeRestarts
[17:40:10.304]                           grepl <- base::grepl
[17:40:10.304]                           restarts <- computeRestarts(cond)
[17:40:10.304]                           for (restart in restarts) {
[17:40:10.304]                             name <- restart$name
[17:40:10.304]                             if (is.null(name)) 
[17:40:10.304]                               next
[17:40:10.304]                             if (!grepl(pattern, name)) 
[17:40:10.304]                               next
[17:40:10.304]                             invokeRestart(restart)
[17:40:10.304]                             muffled <- TRUE
[17:40:10.304]                             break
[17:40:10.304]                           }
[17:40:10.304]                         }
[17:40:10.304]                       }
[17:40:10.304]                       invisible(muffled)
[17:40:10.304]                     }
[17:40:10.304]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.304]                   }
[17:40:10.304]                 }
[17:40:10.304]                 else {
[17:40:10.304]                   if (TRUE) {
[17:40:10.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.304]                     {
[17:40:10.304]                       inherits <- base::inherits
[17:40:10.304]                       invokeRestart <- base::invokeRestart
[17:40:10.304]                       is.null <- base::is.null
[17:40:10.304]                       muffled <- FALSE
[17:40:10.304]                       if (inherits(cond, "message")) {
[17:40:10.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.304]                         if (muffled) 
[17:40:10.304]                           invokeRestart("muffleMessage")
[17:40:10.304]                       }
[17:40:10.304]                       else if (inherits(cond, "warning")) {
[17:40:10.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.304]                         if (muffled) 
[17:40:10.304]                           invokeRestart("muffleWarning")
[17:40:10.304]                       }
[17:40:10.304]                       else if (inherits(cond, "condition")) {
[17:40:10.304]                         if (!is.null(pattern)) {
[17:40:10.304]                           computeRestarts <- base::computeRestarts
[17:40:10.304]                           grepl <- base::grepl
[17:40:10.304]                           restarts <- computeRestarts(cond)
[17:40:10.304]                           for (restart in restarts) {
[17:40:10.304]                             name <- restart$name
[17:40:10.304]                             if (is.null(name)) 
[17:40:10.304]                               next
[17:40:10.304]                             if (!grepl(pattern, name)) 
[17:40:10.304]                               next
[17:40:10.304]                             invokeRestart(restart)
[17:40:10.304]                             muffled <- TRUE
[17:40:10.304]                             break
[17:40:10.304]                           }
[17:40:10.304]                         }
[17:40:10.304]                       }
[17:40:10.304]                       invisible(muffled)
[17:40:10.304]                     }
[17:40:10.304]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.304]                   }
[17:40:10.304]                 }
[17:40:10.304]             }
[17:40:10.304]         }))
[17:40:10.304]     }, error = function(ex) {
[17:40:10.304]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:10.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.304]                 ...future.rng), started = ...future.startTime, 
[17:40:10.304]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:10.304]             version = "1.8"), class = "FutureResult")
[17:40:10.304]     }, finally = {
[17:40:10.304]         if (!identical(...future.workdir, getwd())) 
[17:40:10.304]             setwd(...future.workdir)
[17:40:10.304]         {
[17:40:10.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:10.304]                 ...future.oldOptions$nwarnings <- NULL
[17:40:10.304]             }
[17:40:10.304]             base::options(...future.oldOptions)
[17:40:10.304]             if (.Platform$OS.type == "windows") {
[17:40:10.304]                 old_names <- names(...future.oldEnvVars)
[17:40:10.304]                 envs <- base::Sys.getenv()
[17:40:10.304]                 names <- names(envs)
[17:40:10.304]                 common <- intersect(names, old_names)
[17:40:10.304]                 added <- setdiff(names, old_names)
[17:40:10.304]                 removed <- setdiff(old_names, names)
[17:40:10.304]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:10.304]                   envs[common]]
[17:40:10.304]                 NAMES <- toupper(changed)
[17:40:10.304]                 args <- list()
[17:40:10.304]                 for (kk in seq_along(NAMES)) {
[17:40:10.304]                   name <- changed[[kk]]
[17:40:10.304]                   NAME <- NAMES[[kk]]
[17:40:10.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.304]                     next
[17:40:10.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.304]                 }
[17:40:10.304]                 NAMES <- toupper(added)
[17:40:10.304]                 for (kk in seq_along(NAMES)) {
[17:40:10.304]                   name <- added[[kk]]
[17:40:10.304]                   NAME <- NAMES[[kk]]
[17:40:10.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.304]                     next
[17:40:10.304]                   args[[name]] <- ""
[17:40:10.304]                 }
[17:40:10.304]                 NAMES <- toupper(removed)
[17:40:10.304]                 for (kk in seq_along(NAMES)) {
[17:40:10.304]                   name <- removed[[kk]]
[17:40:10.304]                   NAME <- NAMES[[kk]]
[17:40:10.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.304]                     next
[17:40:10.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.304]                 }
[17:40:10.304]                 if (length(args) > 0) 
[17:40:10.304]                   base::do.call(base::Sys.setenv, args = args)
[17:40:10.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:10.304]             }
[17:40:10.304]             else {
[17:40:10.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:10.304]             }
[17:40:10.304]             {
[17:40:10.304]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:10.304]                   0L) {
[17:40:10.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:10.304]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:10.304]                   base::options(opts)
[17:40:10.304]                 }
[17:40:10.304]                 {
[17:40:10.304]                   {
[17:40:10.304]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:10.304]                     NULL
[17:40:10.304]                   }
[17:40:10.304]                   options(future.plan = NULL)
[17:40:10.304]                   if (is.na(NA_character_)) 
[17:40:10.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:10.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:10.304]                     .init = FALSE)
[17:40:10.304]                 }
[17:40:10.304]             }
[17:40:10.304]         }
[17:40:10.304]     })
[17:40:10.304]     if (TRUE) {
[17:40:10.304]         base::sink(type = "output", split = FALSE)
[17:40:10.304]         if (TRUE) {
[17:40:10.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:10.304]         }
[17:40:10.304]         else {
[17:40:10.304]             ...future.result["stdout"] <- base::list(NULL)
[17:40:10.304]         }
[17:40:10.304]         base::close(...future.stdout)
[17:40:10.304]         ...future.stdout <- NULL
[17:40:10.304]     }
[17:40:10.304]     ...future.result$conditions <- ...future.conditions
[17:40:10.304]     ...future.result$finished <- base::Sys.time()
[17:40:10.304]     ...future.result
[17:40:10.304] }
[17:40:10.307] MultisessionFuture started
[17:40:10.308] - Launch lazy future ... done
[17:40:10.308] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[17:40:10.308] result() for ClusterFuture ...
[17:40:10.308] receiveMessageFromWorker() for ClusterFuture ...
[17:40:10.308] - Validating connection of MultisessionFuture
[17:40:10.334] - received message: FutureResult
[17:40:10.334] - Received FutureResult
[17:40:10.334] - Erased future from FutureRegistry
[17:40:10.335] result() for ClusterFuture ...
[17:40:10.335] - result already collected: FutureResult
[17:40:10.335] result() for ClusterFuture ... done
[17:40:10.335] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:10.335] result() for ClusterFuture ... done
[17:40:10.335] result() for ClusterFuture ...
[17:40:10.335] - result already collected: FutureResult
[17:40:10.335] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 407009 21.8     692222   37   692222 37.0
Vcells 729658  5.6    8388608   64  5751575 43.9
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[17:40:10.335] getGlobalsAndPackages() ...
[17:40:10.336] Searching for globals...
[17:40:10.336] - globals found: [2] ‘{’, ‘integer’
[17:40:10.337] Searching for globals ... DONE
[17:40:10.337] Resolving globals: FALSE
[17:40:10.337] 
[17:40:10.337] 
[17:40:10.337] getGlobalsAndPackages() ... DONE
[17:40:10.337] run() for ‘Future’ ...
[17:40:10.337] - state: ‘created’
[17:40:10.338] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:10.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:10.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:10.348]   - Field: ‘node’
[17:40:10.348]   - Field: ‘label’
[17:40:10.348]   - Field: ‘local’
[17:40:10.349]   - Field: ‘owner’
[17:40:10.349]   - Field: ‘envir’
[17:40:10.349]   - Field: ‘workers’
[17:40:10.349]   - Field: ‘packages’
[17:40:10.349]   - Field: ‘gc’
[17:40:10.349]   - Field: ‘conditions’
[17:40:10.349]   - Field: ‘persistent’
[17:40:10.349]   - Field: ‘expr’
[17:40:10.349]   - Field: ‘uuid’
[17:40:10.349]   - Field: ‘seed’
[17:40:10.349]   - Field: ‘version’
[17:40:10.349]   - Field: ‘result’
[17:40:10.350]   - Field: ‘asynchronous’
[17:40:10.350]   - Field: ‘calls’
[17:40:10.350]   - Field: ‘globals’
[17:40:10.350]   - Field: ‘stdout’
[17:40:10.350]   - Field: ‘earlySignal’
[17:40:10.350]   - Field: ‘lazy’
[17:40:10.350]   - Field: ‘state’
[17:40:10.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:10.350] - Launch lazy future ...
[17:40:10.351] Packages needed by the future expression (n = 0): <none>
[17:40:10.351] Packages needed by future strategies (n = 0): <none>
[17:40:10.351] {
[17:40:10.351]     {
[17:40:10.351]         {
[17:40:10.351]             ...future.startTime <- base::Sys.time()
[17:40:10.351]             {
[17:40:10.351]                 {
[17:40:10.351]                   {
[17:40:10.351]                     {
[17:40:10.351]                       base::local({
[17:40:10.351]                         has_future <- base::requireNamespace("future", 
[17:40:10.351]                           quietly = TRUE)
[17:40:10.351]                         if (has_future) {
[17:40:10.351]                           ns <- base::getNamespace("future")
[17:40:10.351]                           version <- ns[[".package"]][["version"]]
[17:40:10.351]                           if (is.null(version)) 
[17:40:10.351]                             version <- utils::packageVersion("future")
[17:40:10.351]                         }
[17:40:10.351]                         else {
[17:40:10.351]                           version <- NULL
[17:40:10.351]                         }
[17:40:10.351]                         if (!has_future || version < "1.8.0") {
[17:40:10.351]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:10.351]                             "", base::R.version$version.string), 
[17:40:10.351]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:10.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:10.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:10.351]                               "release", "version")], collapse = " "), 
[17:40:10.351]                             hostname = base::Sys.info()[["nodename"]])
[17:40:10.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:10.351]                             info)
[17:40:10.351]                           info <- base::paste(info, collapse = "; ")
[17:40:10.351]                           if (!has_future) {
[17:40:10.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:10.351]                               info)
[17:40:10.351]                           }
[17:40:10.351]                           else {
[17:40:10.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:10.351]                               info, version)
[17:40:10.351]                           }
[17:40:10.351]                           base::stop(msg)
[17:40:10.351]                         }
[17:40:10.351]                       })
[17:40:10.351]                     }
[17:40:10.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:10.351]                     base::options(mc.cores = 1L)
[17:40:10.351]                   }
[17:40:10.351]                   ...future.strategy.old <- future::plan("list")
[17:40:10.351]                   options(future.plan = NULL)
[17:40:10.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:10.351]                 }
[17:40:10.351]                 ...future.workdir <- getwd()
[17:40:10.351]             }
[17:40:10.351]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:10.351]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:10.351]         }
[17:40:10.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:10.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:10.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:10.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:10.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:10.351]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:10.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:10.351]             base::names(...future.oldOptions))
[17:40:10.351]     }
[17:40:10.351]     if (FALSE) {
[17:40:10.351]     }
[17:40:10.351]     else {
[17:40:10.351]         if (TRUE) {
[17:40:10.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:10.351]                 open = "w")
[17:40:10.351]         }
[17:40:10.351]         else {
[17:40:10.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:10.351]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:10.351]         }
[17:40:10.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:10.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:10.351]             base::sink(type = "output", split = FALSE)
[17:40:10.351]             base::close(...future.stdout)
[17:40:10.351]         }, add = TRUE)
[17:40:10.351]     }
[17:40:10.351]     ...future.frame <- base::sys.nframe()
[17:40:10.351]     ...future.conditions <- base::list()
[17:40:10.351]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:10.351]     if (FALSE) {
[17:40:10.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:10.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:10.351]     }
[17:40:10.351]     ...future.result <- base::tryCatch({
[17:40:10.351]         base::withCallingHandlers({
[17:40:10.351]             ...future.value <- base::withVisible(base::local({
[17:40:10.351]                 ...future.makeSendCondition <- base::local({
[17:40:10.351]                   sendCondition <- NULL
[17:40:10.351]                   function(frame = 1L) {
[17:40:10.351]                     if (is.function(sendCondition)) 
[17:40:10.351]                       return(sendCondition)
[17:40:10.351]                     ns <- getNamespace("parallel")
[17:40:10.351]                     if (exists("sendData", mode = "function", 
[17:40:10.351]                       envir = ns)) {
[17:40:10.351]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:10.351]                         envir = ns)
[17:40:10.351]                       envir <- sys.frame(frame)
[17:40:10.351]                       master <- NULL
[17:40:10.351]                       while (!identical(envir, .GlobalEnv) && 
[17:40:10.351]                         !identical(envir, emptyenv())) {
[17:40:10.351]                         if (exists("master", mode = "list", envir = envir, 
[17:40:10.351]                           inherits = FALSE)) {
[17:40:10.351]                           master <- get("master", mode = "list", 
[17:40:10.351]                             envir = envir, inherits = FALSE)
[17:40:10.351]                           if (inherits(master, c("SOCKnode", 
[17:40:10.351]                             "SOCK0node"))) {
[17:40:10.351]                             sendCondition <<- function(cond) {
[17:40:10.351]                               data <- list(type = "VALUE", value = cond, 
[17:40:10.351]                                 success = TRUE)
[17:40:10.351]                               parallel_sendData(master, data)
[17:40:10.351]                             }
[17:40:10.351]                             return(sendCondition)
[17:40:10.351]                           }
[17:40:10.351]                         }
[17:40:10.351]                         frame <- frame + 1L
[17:40:10.351]                         envir <- sys.frame(frame)
[17:40:10.351]                       }
[17:40:10.351]                     }
[17:40:10.351]                     sendCondition <<- function(cond) NULL
[17:40:10.351]                   }
[17:40:10.351]                 })
[17:40:10.351]                 withCallingHandlers({
[17:40:10.351]                   {
[17:40:10.351]                     integer(1e+07)
[17:40:10.351]                   }
[17:40:10.351]                 }, immediateCondition = function(cond) {
[17:40:10.351]                   sendCondition <- ...future.makeSendCondition()
[17:40:10.351]                   sendCondition(cond)
[17:40:10.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.351]                   {
[17:40:10.351]                     inherits <- base::inherits
[17:40:10.351]                     invokeRestart <- base::invokeRestart
[17:40:10.351]                     is.null <- base::is.null
[17:40:10.351]                     muffled <- FALSE
[17:40:10.351]                     if (inherits(cond, "message")) {
[17:40:10.351]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:10.351]                       if (muffled) 
[17:40:10.351]                         invokeRestart("muffleMessage")
[17:40:10.351]                     }
[17:40:10.351]                     else if (inherits(cond, "warning")) {
[17:40:10.351]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:10.351]                       if (muffled) 
[17:40:10.351]                         invokeRestart("muffleWarning")
[17:40:10.351]                     }
[17:40:10.351]                     else if (inherits(cond, "condition")) {
[17:40:10.351]                       if (!is.null(pattern)) {
[17:40:10.351]                         computeRestarts <- base::computeRestarts
[17:40:10.351]                         grepl <- base::grepl
[17:40:10.351]                         restarts <- computeRestarts(cond)
[17:40:10.351]                         for (restart in restarts) {
[17:40:10.351]                           name <- restart$name
[17:40:10.351]                           if (is.null(name)) 
[17:40:10.351]                             next
[17:40:10.351]                           if (!grepl(pattern, name)) 
[17:40:10.351]                             next
[17:40:10.351]                           invokeRestart(restart)
[17:40:10.351]                           muffled <- TRUE
[17:40:10.351]                           break
[17:40:10.351]                         }
[17:40:10.351]                       }
[17:40:10.351]                     }
[17:40:10.351]                     invisible(muffled)
[17:40:10.351]                   }
[17:40:10.351]                   muffleCondition(cond)
[17:40:10.351]                 })
[17:40:10.351]             }))
[17:40:10.351]             future::FutureResult(value = ...future.value$value, 
[17:40:10.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.351]                   ...future.rng), globalenv = if (FALSE) 
[17:40:10.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:10.351]                     ...future.globalenv.names))
[17:40:10.351]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:10.351]         }, condition = base::local({
[17:40:10.351]             c <- base::c
[17:40:10.351]             inherits <- base::inherits
[17:40:10.351]             invokeRestart <- base::invokeRestart
[17:40:10.351]             length <- base::length
[17:40:10.351]             list <- base::list
[17:40:10.351]             seq.int <- base::seq.int
[17:40:10.351]             signalCondition <- base::signalCondition
[17:40:10.351]             sys.calls <- base::sys.calls
[17:40:10.351]             `[[` <- base::`[[`
[17:40:10.351]             `+` <- base::`+`
[17:40:10.351]             `<<-` <- base::`<<-`
[17:40:10.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:10.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:10.351]                   3L)]
[17:40:10.351]             }
[17:40:10.351]             function(cond) {
[17:40:10.351]                 is_error <- inherits(cond, "error")
[17:40:10.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:10.351]                   NULL)
[17:40:10.351]                 if (is_error) {
[17:40:10.351]                   sessionInformation <- function() {
[17:40:10.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:10.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:10.351]                       search = base::search(), system = base::Sys.info())
[17:40:10.351]                   }
[17:40:10.351]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:10.351]                     cond$call), session = sessionInformation(), 
[17:40:10.351]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:10.351]                   signalCondition(cond)
[17:40:10.351]                 }
[17:40:10.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:10.351]                 "immediateCondition"))) {
[17:40:10.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:10.351]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:10.351]                   if (TRUE && !signal) {
[17:40:10.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.351]                     {
[17:40:10.351]                       inherits <- base::inherits
[17:40:10.351]                       invokeRestart <- base::invokeRestart
[17:40:10.351]                       is.null <- base::is.null
[17:40:10.351]                       muffled <- FALSE
[17:40:10.351]                       if (inherits(cond, "message")) {
[17:40:10.351]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.351]                         if (muffled) 
[17:40:10.351]                           invokeRestart("muffleMessage")
[17:40:10.351]                       }
[17:40:10.351]                       else if (inherits(cond, "warning")) {
[17:40:10.351]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.351]                         if (muffled) 
[17:40:10.351]                           invokeRestart("muffleWarning")
[17:40:10.351]                       }
[17:40:10.351]                       else if (inherits(cond, "condition")) {
[17:40:10.351]                         if (!is.null(pattern)) {
[17:40:10.351]                           computeRestarts <- base::computeRestarts
[17:40:10.351]                           grepl <- base::grepl
[17:40:10.351]                           restarts <- computeRestarts(cond)
[17:40:10.351]                           for (restart in restarts) {
[17:40:10.351]                             name <- restart$name
[17:40:10.351]                             if (is.null(name)) 
[17:40:10.351]                               next
[17:40:10.351]                             if (!grepl(pattern, name)) 
[17:40:10.351]                               next
[17:40:10.351]                             invokeRestart(restart)
[17:40:10.351]                             muffled <- TRUE
[17:40:10.351]                             break
[17:40:10.351]                           }
[17:40:10.351]                         }
[17:40:10.351]                       }
[17:40:10.351]                       invisible(muffled)
[17:40:10.351]                     }
[17:40:10.351]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.351]                   }
[17:40:10.351]                 }
[17:40:10.351]                 else {
[17:40:10.351]                   if (TRUE) {
[17:40:10.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.351]                     {
[17:40:10.351]                       inherits <- base::inherits
[17:40:10.351]                       invokeRestart <- base::invokeRestart
[17:40:10.351]                       is.null <- base::is.null
[17:40:10.351]                       muffled <- FALSE
[17:40:10.351]                       if (inherits(cond, "message")) {
[17:40:10.351]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.351]                         if (muffled) 
[17:40:10.351]                           invokeRestart("muffleMessage")
[17:40:10.351]                       }
[17:40:10.351]                       else if (inherits(cond, "warning")) {
[17:40:10.351]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.351]                         if (muffled) 
[17:40:10.351]                           invokeRestart("muffleWarning")
[17:40:10.351]                       }
[17:40:10.351]                       else if (inherits(cond, "condition")) {
[17:40:10.351]                         if (!is.null(pattern)) {
[17:40:10.351]                           computeRestarts <- base::computeRestarts
[17:40:10.351]                           grepl <- base::grepl
[17:40:10.351]                           restarts <- computeRestarts(cond)
[17:40:10.351]                           for (restart in restarts) {
[17:40:10.351]                             name <- restart$name
[17:40:10.351]                             if (is.null(name)) 
[17:40:10.351]                               next
[17:40:10.351]                             if (!grepl(pattern, name)) 
[17:40:10.351]                               next
[17:40:10.351]                             invokeRestart(restart)
[17:40:10.351]                             muffled <- TRUE
[17:40:10.351]                             break
[17:40:10.351]                           }
[17:40:10.351]                         }
[17:40:10.351]                       }
[17:40:10.351]                       invisible(muffled)
[17:40:10.351]                     }
[17:40:10.351]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.351]                   }
[17:40:10.351]                 }
[17:40:10.351]             }
[17:40:10.351]         }))
[17:40:10.351]     }, error = function(ex) {
[17:40:10.351]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:10.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.351]                 ...future.rng), started = ...future.startTime, 
[17:40:10.351]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:10.351]             version = "1.8"), class = "FutureResult")
[17:40:10.351]     }, finally = {
[17:40:10.351]         if (!identical(...future.workdir, getwd())) 
[17:40:10.351]             setwd(...future.workdir)
[17:40:10.351]         {
[17:40:10.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:10.351]                 ...future.oldOptions$nwarnings <- NULL
[17:40:10.351]             }
[17:40:10.351]             base::options(...future.oldOptions)
[17:40:10.351]             if (.Platform$OS.type == "windows") {
[17:40:10.351]                 old_names <- names(...future.oldEnvVars)
[17:40:10.351]                 envs <- base::Sys.getenv()
[17:40:10.351]                 names <- names(envs)
[17:40:10.351]                 common <- intersect(names, old_names)
[17:40:10.351]                 added <- setdiff(names, old_names)
[17:40:10.351]                 removed <- setdiff(old_names, names)
[17:40:10.351]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:10.351]                   envs[common]]
[17:40:10.351]                 NAMES <- toupper(changed)
[17:40:10.351]                 args <- list()
[17:40:10.351]                 for (kk in seq_along(NAMES)) {
[17:40:10.351]                   name <- changed[[kk]]
[17:40:10.351]                   NAME <- NAMES[[kk]]
[17:40:10.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.351]                     next
[17:40:10.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.351]                 }
[17:40:10.351]                 NAMES <- toupper(added)
[17:40:10.351]                 for (kk in seq_along(NAMES)) {
[17:40:10.351]                   name <- added[[kk]]
[17:40:10.351]                   NAME <- NAMES[[kk]]
[17:40:10.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.351]                     next
[17:40:10.351]                   args[[name]] <- ""
[17:40:10.351]                 }
[17:40:10.351]                 NAMES <- toupper(removed)
[17:40:10.351]                 for (kk in seq_along(NAMES)) {
[17:40:10.351]                   name <- removed[[kk]]
[17:40:10.351]                   NAME <- NAMES[[kk]]
[17:40:10.351]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.351]                     next
[17:40:10.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.351]                 }
[17:40:10.351]                 if (length(args) > 0) 
[17:40:10.351]                   base::do.call(base::Sys.setenv, args = args)
[17:40:10.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:10.351]             }
[17:40:10.351]             else {
[17:40:10.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:10.351]             }
[17:40:10.351]             {
[17:40:10.351]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:10.351]                   0L) {
[17:40:10.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:10.351]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:10.351]                   base::options(opts)
[17:40:10.351]                 }
[17:40:10.351]                 {
[17:40:10.351]                   {
[17:40:10.351]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:10.351]                     NULL
[17:40:10.351]                   }
[17:40:10.351]                   options(future.plan = NULL)
[17:40:10.351]                   if (is.na(NA_character_)) 
[17:40:10.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:10.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:10.351]                     .init = FALSE)
[17:40:10.351]                 }
[17:40:10.351]             }
[17:40:10.351]         }
[17:40:10.351]     })
[17:40:10.351]     if (TRUE) {
[17:40:10.351]         base::sink(type = "output", split = FALSE)
[17:40:10.351]         if (TRUE) {
[17:40:10.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:10.351]         }
[17:40:10.351]         else {
[17:40:10.351]             ...future.result["stdout"] <- base::list(NULL)
[17:40:10.351]         }
[17:40:10.351]         base::close(...future.stdout)
[17:40:10.351]         ...future.stdout <- NULL
[17:40:10.351]     }
[17:40:10.351]     ...future.result$conditions <- ...future.conditions
[17:40:10.351]     ...future.result$finished <- base::Sys.time()
[17:40:10.351]     ...future.result
[17:40:10.351] }
[17:40:10.354] MultisessionFuture started
[17:40:10.354] - Launch lazy future ... done
[17:40:10.354] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[17:40:10.355] result() for ClusterFuture ...
[17:40:10.355] receiveMessageFromWorker() for ClusterFuture ...
[17:40:10.355] - Validating connection of MultisessionFuture
[17:40:10.416] - received message: FutureResult
[17:40:10.416] - Received FutureResult
[17:40:10.417] - Erased future from FutureRegistry
[17:40:10.417] result() for ClusterFuture ...
[17:40:10.417] - result already collected: FutureResult
[17:40:10.417] result() for ClusterFuture ... done
[17:40:10.417] - Garbage collecting worker ...
[17:40:10.662] - Garbage collecting worker ... done
[17:40:10.663] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:10.663] result() for ClusterFuture ... done
[17:40:10.663] result() for ClusterFuture ...
[17:40:10.663] - result already collected: FutureResult
[17:40:10.663] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[17:40:10.664] getGlobalsAndPackages() ...
[17:40:10.664] Searching for globals...
[17:40:10.665] - globals found: [2] ‘{’, ‘gc’
[17:40:10.665] Searching for globals ... DONE
[17:40:10.665] Resolving globals: FALSE
[17:40:10.665] 
[17:40:10.665] 
[17:40:10.665] getGlobalsAndPackages() ... DONE
[17:40:10.666] run() for ‘Future’ ...
[17:40:10.666] - state: ‘created’
[17:40:10.666] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:10.676] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:10.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:10.677]   - Field: ‘node’
[17:40:10.677]   - Field: ‘label’
[17:40:10.677]   - Field: ‘local’
[17:40:10.677]   - Field: ‘owner’
[17:40:10.677]   - Field: ‘envir’
[17:40:10.677]   - Field: ‘workers’
[17:40:10.677]   - Field: ‘packages’
[17:40:10.677]   - Field: ‘gc’
[17:40:10.677]   - Field: ‘conditions’
[17:40:10.677]   - Field: ‘persistent’
[17:40:10.677]   - Field: ‘expr’
[17:40:10.678]   - Field: ‘uuid’
[17:40:10.678]   - Field: ‘seed’
[17:40:10.678]   - Field: ‘version’
[17:40:10.678]   - Field: ‘result’
[17:40:10.678]   - Field: ‘asynchronous’
[17:40:10.678]   - Field: ‘calls’
[17:40:10.678]   - Field: ‘globals’
[17:40:10.678]   - Field: ‘stdout’
[17:40:10.678]   - Field: ‘earlySignal’
[17:40:10.678]   - Field: ‘lazy’
[17:40:10.678]   - Field: ‘state’
[17:40:10.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:10.679] - Launch lazy future ...
[17:40:10.679] Packages needed by the future expression (n = 0): <none>
[17:40:10.679] Packages needed by future strategies (n = 0): <none>
[17:40:10.679] {
[17:40:10.679]     {
[17:40:10.679]         {
[17:40:10.679]             ...future.startTime <- base::Sys.time()
[17:40:10.679]             {
[17:40:10.679]                 {
[17:40:10.679]                   {
[17:40:10.679]                     {
[17:40:10.679]                       base::local({
[17:40:10.679]                         has_future <- base::requireNamespace("future", 
[17:40:10.679]                           quietly = TRUE)
[17:40:10.679]                         if (has_future) {
[17:40:10.679]                           ns <- base::getNamespace("future")
[17:40:10.679]                           version <- ns[[".package"]][["version"]]
[17:40:10.679]                           if (is.null(version)) 
[17:40:10.679]                             version <- utils::packageVersion("future")
[17:40:10.679]                         }
[17:40:10.679]                         else {
[17:40:10.679]                           version <- NULL
[17:40:10.679]                         }
[17:40:10.679]                         if (!has_future || version < "1.8.0") {
[17:40:10.679]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:10.679]                             "", base::R.version$version.string), 
[17:40:10.679]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:10.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:10.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:10.679]                               "release", "version")], collapse = " "), 
[17:40:10.679]                             hostname = base::Sys.info()[["nodename"]])
[17:40:10.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:10.679]                             info)
[17:40:10.679]                           info <- base::paste(info, collapse = "; ")
[17:40:10.679]                           if (!has_future) {
[17:40:10.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:10.679]                               info)
[17:40:10.679]                           }
[17:40:10.679]                           else {
[17:40:10.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:10.679]                               info, version)
[17:40:10.679]                           }
[17:40:10.679]                           base::stop(msg)
[17:40:10.679]                         }
[17:40:10.679]                       })
[17:40:10.679]                     }
[17:40:10.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:10.679]                     base::options(mc.cores = 1L)
[17:40:10.679]                   }
[17:40:10.679]                   ...future.strategy.old <- future::plan("list")
[17:40:10.679]                   options(future.plan = NULL)
[17:40:10.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:10.679]                 }
[17:40:10.679]                 ...future.workdir <- getwd()
[17:40:10.679]             }
[17:40:10.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:10.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:10.679]         }
[17:40:10.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:10.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:10.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:10.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:10.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:10.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:10.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:10.679]             base::names(...future.oldOptions))
[17:40:10.679]     }
[17:40:10.679]     if (FALSE) {
[17:40:10.679]     }
[17:40:10.679]     else {
[17:40:10.679]         if (TRUE) {
[17:40:10.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:10.679]                 open = "w")
[17:40:10.679]         }
[17:40:10.679]         else {
[17:40:10.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:10.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:10.679]         }
[17:40:10.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:10.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:10.679]             base::sink(type = "output", split = FALSE)
[17:40:10.679]             base::close(...future.stdout)
[17:40:10.679]         }, add = TRUE)
[17:40:10.679]     }
[17:40:10.679]     ...future.frame <- base::sys.nframe()
[17:40:10.679]     ...future.conditions <- base::list()
[17:40:10.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:10.679]     if (FALSE) {
[17:40:10.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:10.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:10.679]     }
[17:40:10.679]     ...future.result <- base::tryCatch({
[17:40:10.679]         base::withCallingHandlers({
[17:40:10.679]             ...future.value <- base::withVisible(base::local({
[17:40:10.679]                 ...future.makeSendCondition <- base::local({
[17:40:10.679]                   sendCondition <- NULL
[17:40:10.679]                   function(frame = 1L) {
[17:40:10.679]                     if (is.function(sendCondition)) 
[17:40:10.679]                       return(sendCondition)
[17:40:10.679]                     ns <- getNamespace("parallel")
[17:40:10.679]                     if (exists("sendData", mode = "function", 
[17:40:10.679]                       envir = ns)) {
[17:40:10.679]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:10.679]                         envir = ns)
[17:40:10.679]                       envir <- sys.frame(frame)
[17:40:10.679]                       master <- NULL
[17:40:10.679]                       while (!identical(envir, .GlobalEnv) && 
[17:40:10.679]                         !identical(envir, emptyenv())) {
[17:40:10.679]                         if (exists("master", mode = "list", envir = envir, 
[17:40:10.679]                           inherits = FALSE)) {
[17:40:10.679]                           master <- get("master", mode = "list", 
[17:40:10.679]                             envir = envir, inherits = FALSE)
[17:40:10.679]                           if (inherits(master, c("SOCKnode", 
[17:40:10.679]                             "SOCK0node"))) {
[17:40:10.679]                             sendCondition <<- function(cond) {
[17:40:10.679]                               data <- list(type = "VALUE", value = cond, 
[17:40:10.679]                                 success = TRUE)
[17:40:10.679]                               parallel_sendData(master, data)
[17:40:10.679]                             }
[17:40:10.679]                             return(sendCondition)
[17:40:10.679]                           }
[17:40:10.679]                         }
[17:40:10.679]                         frame <- frame + 1L
[17:40:10.679]                         envir <- sys.frame(frame)
[17:40:10.679]                       }
[17:40:10.679]                     }
[17:40:10.679]                     sendCondition <<- function(cond) NULL
[17:40:10.679]                   }
[17:40:10.679]                 })
[17:40:10.679]                 withCallingHandlers({
[17:40:10.679]                   {
[17:40:10.679]                     gc()
[17:40:10.679]                   }
[17:40:10.679]                 }, immediateCondition = function(cond) {
[17:40:10.679]                   sendCondition <- ...future.makeSendCondition()
[17:40:10.679]                   sendCondition(cond)
[17:40:10.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.679]                   {
[17:40:10.679]                     inherits <- base::inherits
[17:40:10.679]                     invokeRestart <- base::invokeRestart
[17:40:10.679]                     is.null <- base::is.null
[17:40:10.679]                     muffled <- FALSE
[17:40:10.679]                     if (inherits(cond, "message")) {
[17:40:10.679]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:10.679]                       if (muffled) 
[17:40:10.679]                         invokeRestart("muffleMessage")
[17:40:10.679]                     }
[17:40:10.679]                     else if (inherits(cond, "warning")) {
[17:40:10.679]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:10.679]                       if (muffled) 
[17:40:10.679]                         invokeRestart("muffleWarning")
[17:40:10.679]                     }
[17:40:10.679]                     else if (inherits(cond, "condition")) {
[17:40:10.679]                       if (!is.null(pattern)) {
[17:40:10.679]                         computeRestarts <- base::computeRestarts
[17:40:10.679]                         grepl <- base::grepl
[17:40:10.679]                         restarts <- computeRestarts(cond)
[17:40:10.679]                         for (restart in restarts) {
[17:40:10.679]                           name <- restart$name
[17:40:10.679]                           if (is.null(name)) 
[17:40:10.679]                             next
[17:40:10.679]                           if (!grepl(pattern, name)) 
[17:40:10.679]                             next
[17:40:10.679]                           invokeRestart(restart)
[17:40:10.679]                           muffled <- TRUE
[17:40:10.679]                           break
[17:40:10.679]                         }
[17:40:10.679]                       }
[17:40:10.679]                     }
[17:40:10.679]                     invisible(muffled)
[17:40:10.679]                   }
[17:40:10.679]                   muffleCondition(cond)
[17:40:10.679]                 })
[17:40:10.679]             }))
[17:40:10.679]             future::FutureResult(value = ...future.value$value, 
[17:40:10.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.679]                   ...future.rng), globalenv = if (FALSE) 
[17:40:10.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:10.679]                     ...future.globalenv.names))
[17:40:10.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:10.679]         }, condition = base::local({
[17:40:10.679]             c <- base::c
[17:40:10.679]             inherits <- base::inherits
[17:40:10.679]             invokeRestart <- base::invokeRestart
[17:40:10.679]             length <- base::length
[17:40:10.679]             list <- base::list
[17:40:10.679]             seq.int <- base::seq.int
[17:40:10.679]             signalCondition <- base::signalCondition
[17:40:10.679]             sys.calls <- base::sys.calls
[17:40:10.679]             `[[` <- base::`[[`
[17:40:10.679]             `+` <- base::`+`
[17:40:10.679]             `<<-` <- base::`<<-`
[17:40:10.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:10.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:10.679]                   3L)]
[17:40:10.679]             }
[17:40:10.679]             function(cond) {
[17:40:10.679]                 is_error <- inherits(cond, "error")
[17:40:10.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:10.679]                   NULL)
[17:40:10.679]                 if (is_error) {
[17:40:10.679]                   sessionInformation <- function() {
[17:40:10.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:10.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:10.679]                       search = base::search(), system = base::Sys.info())
[17:40:10.679]                   }
[17:40:10.679]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:10.679]                     cond$call), session = sessionInformation(), 
[17:40:10.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:10.679]                   signalCondition(cond)
[17:40:10.679]                 }
[17:40:10.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:10.679]                 "immediateCondition"))) {
[17:40:10.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:10.679]                   ...future.conditions[[length(...future.conditions) + 
[17:40:10.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:10.679]                   if (TRUE && !signal) {
[17:40:10.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.679]                     {
[17:40:10.679]                       inherits <- base::inherits
[17:40:10.679]                       invokeRestart <- base::invokeRestart
[17:40:10.679]                       is.null <- base::is.null
[17:40:10.679]                       muffled <- FALSE
[17:40:10.679]                       if (inherits(cond, "message")) {
[17:40:10.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.679]                         if (muffled) 
[17:40:10.679]                           invokeRestart("muffleMessage")
[17:40:10.679]                       }
[17:40:10.679]                       else if (inherits(cond, "warning")) {
[17:40:10.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.679]                         if (muffled) 
[17:40:10.679]                           invokeRestart("muffleWarning")
[17:40:10.679]                       }
[17:40:10.679]                       else if (inherits(cond, "condition")) {
[17:40:10.679]                         if (!is.null(pattern)) {
[17:40:10.679]                           computeRestarts <- base::computeRestarts
[17:40:10.679]                           grepl <- base::grepl
[17:40:10.679]                           restarts <- computeRestarts(cond)
[17:40:10.679]                           for (restart in restarts) {
[17:40:10.679]                             name <- restart$name
[17:40:10.679]                             if (is.null(name)) 
[17:40:10.679]                               next
[17:40:10.679]                             if (!grepl(pattern, name)) 
[17:40:10.679]                               next
[17:40:10.679]                             invokeRestart(restart)
[17:40:10.679]                             muffled <- TRUE
[17:40:10.679]                             break
[17:40:10.679]                           }
[17:40:10.679]                         }
[17:40:10.679]                       }
[17:40:10.679]                       invisible(muffled)
[17:40:10.679]                     }
[17:40:10.679]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.679]                   }
[17:40:10.679]                 }
[17:40:10.679]                 else {
[17:40:10.679]                   if (TRUE) {
[17:40:10.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:10.679]                     {
[17:40:10.679]                       inherits <- base::inherits
[17:40:10.679]                       invokeRestart <- base::invokeRestart
[17:40:10.679]                       is.null <- base::is.null
[17:40:10.679]                       muffled <- FALSE
[17:40:10.679]                       if (inherits(cond, "message")) {
[17:40:10.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:10.679]                         if (muffled) 
[17:40:10.679]                           invokeRestart("muffleMessage")
[17:40:10.679]                       }
[17:40:10.679]                       else if (inherits(cond, "warning")) {
[17:40:10.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:10.679]                         if (muffled) 
[17:40:10.679]                           invokeRestart("muffleWarning")
[17:40:10.679]                       }
[17:40:10.679]                       else if (inherits(cond, "condition")) {
[17:40:10.679]                         if (!is.null(pattern)) {
[17:40:10.679]                           computeRestarts <- base::computeRestarts
[17:40:10.679]                           grepl <- base::grepl
[17:40:10.679]                           restarts <- computeRestarts(cond)
[17:40:10.679]                           for (restart in restarts) {
[17:40:10.679]                             name <- restart$name
[17:40:10.679]                             if (is.null(name)) 
[17:40:10.679]                               next
[17:40:10.679]                             if (!grepl(pattern, name)) 
[17:40:10.679]                               next
[17:40:10.679]                             invokeRestart(restart)
[17:40:10.679]                             muffled <- TRUE
[17:40:10.679]                             break
[17:40:10.679]                           }
[17:40:10.679]                         }
[17:40:10.679]                       }
[17:40:10.679]                       invisible(muffled)
[17:40:10.679]                     }
[17:40:10.679]                     muffleCondition(cond, pattern = "^muffle")
[17:40:10.679]                   }
[17:40:10.679]                 }
[17:40:10.679]             }
[17:40:10.679]         }))
[17:40:10.679]     }, error = function(ex) {
[17:40:10.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:10.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:10.679]                 ...future.rng), started = ...future.startTime, 
[17:40:10.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:10.679]             version = "1.8"), class = "FutureResult")
[17:40:10.679]     }, finally = {
[17:40:10.679]         if (!identical(...future.workdir, getwd())) 
[17:40:10.679]             setwd(...future.workdir)
[17:40:10.679]         {
[17:40:10.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:10.679]                 ...future.oldOptions$nwarnings <- NULL
[17:40:10.679]             }
[17:40:10.679]             base::options(...future.oldOptions)
[17:40:10.679]             if (.Platform$OS.type == "windows") {
[17:40:10.679]                 old_names <- names(...future.oldEnvVars)
[17:40:10.679]                 envs <- base::Sys.getenv()
[17:40:10.679]                 names <- names(envs)
[17:40:10.679]                 common <- intersect(names, old_names)
[17:40:10.679]                 added <- setdiff(names, old_names)
[17:40:10.679]                 removed <- setdiff(old_names, names)
[17:40:10.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:10.679]                   envs[common]]
[17:40:10.679]                 NAMES <- toupper(changed)
[17:40:10.679]                 args <- list()
[17:40:10.679]                 for (kk in seq_along(NAMES)) {
[17:40:10.679]                   name <- changed[[kk]]
[17:40:10.679]                   NAME <- NAMES[[kk]]
[17:40:10.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.679]                     next
[17:40:10.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.679]                 }
[17:40:10.679]                 NAMES <- toupper(added)
[17:40:10.679]                 for (kk in seq_along(NAMES)) {
[17:40:10.679]                   name <- added[[kk]]
[17:40:10.679]                   NAME <- NAMES[[kk]]
[17:40:10.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.679]                     next
[17:40:10.679]                   args[[name]] <- ""
[17:40:10.679]                 }
[17:40:10.679]                 NAMES <- toupper(removed)
[17:40:10.679]                 for (kk in seq_along(NAMES)) {
[17:40:10.679]                   name <- removed[[kk]]
[17:40:10.679]                   NAME <- NAMES[[kk]]
[17:40:10.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:10.679]                     next
[17:40:10.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:10.679]                 }
[17:40:10.679]                 if (length(args) > 0) 
[17:40:10.679]                   base::do.call(base::Sys.setenv, args = args)
[17:40:10.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:10.679]             }
[17:40:10.679]             else {
[17:40:10.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:10.679]             }
[17:40:10.679]             {
[17:40:10.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:10.679]                   0L) {
[17:40:10.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:10.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:10.679]                   base::options(opts)
[17:40:10.679]                 }
[17:40:10.679]                 {
[17:40:10.679]                   {
[17:40:10.679]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:10.679]                     NULL
[17:40:10.679]                   }
[17:40:10.679]                   options(future.plan = NULL)
[17:40:10.679]                   if (is.na(NA_character_)) 
[17:40:10.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:10.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:10.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:10.679]                     .init = FALSE)
[17:40:10.679]                 }
[17:40:10.679]             }
[17:40:10.679]         }
[17:40:10.679]     })
[17:40:10.679]     if (TRUE) {
[17:40:10.679]         base::sink(type = "output", split = FALSE)
[17:40:10.679]         if (TRUE) {
[17:40:10.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:10.679]         }
[17:40:10.679]         else {
[17:40:10.679]             ...future.result["stdout"] <- base::list(NULL)
[17:40:10.679]         }
[17:40:10.679]         base::close(...future.stdout)
[17:40:10.679]         ...future.stdout <- NULL
[17:40:10.679]     }
[17:40:10.679]     ...future.result$conditions <- ...future.conditions
[17:40:10.679]     ...future.result$finished <- base::Sys.time()
[17:40:10.679]     ...future.result
[17:40:10.679] }
[17:40:10.682] MultisessionFuture started
[17:40:10.682] - Launch lazy future ... done
[17:40:10.682] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[17:40:10.683] result() for ClusterFuture ...
[17:40:10.683] receiveMessageFromWorker() for ClusterFuture ...
[17:40:10.683] - Validating connection of MultisessionFuture
[17:40:10.748] - received message: FutureResult
[17:40:10.748] - Received FutureResult
[17:40:10.748] - Erased future from FutureRegistry
[17:40:10.748] result() for ClusterFuture ...
[17:40:10.749] - result already collected: FutureResult
[17:40:10.749] result() for ClusterFuture ... done
[17:40:10.749] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:10.749] result() for ClusterFuture ... done
[17:40:10.749] result() for ClusterFuture ...
[17:40:10.749] - result already collected: FutureResult
[17:40:10.749] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 407154 21.8     899071  48.1   692222  37.0
Vcells 729747  5.6   13476992 102.9 15806168 120.6
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[17:40:10.750] plan(): Setting new future strategy stack:
[17:40:10.750] List of future strategies:
[17:40:10.750] 1. multisession:
[17:40:10.750]    - args: function (..., workers = 2L, envir = parent.frame())
[17:40:10.750]    - tweaked: TRUE
[17:40:10.750]    - call: plan(multisession, workers = 2L)
[17:40:10.751] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:10.751] multisession:
[17:40:10.751] - args: function (..., workers = 2L, envir = parent.frame())
[17:40:10.751] - tweaked: TRUE
[17:40:10.751] - call: plan(multisession, workers = 2L)
[17:40:10.751] getGlobalsAndPackages() ...
[17:40:10.751] Not searching for globals
[17:40:10.751] - globals: [0] <none>
[17:40:10.751] getGlobalsAndPackages() ... DONE
[17:40:10.752] [local output] makeClusterPSOCK() ...
[17:40:10.756] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:10.757] [local output] Base port: 11794
[17:40:10.757] [local output] Getting setup options for 2 cluster nodes ...
[17:40:10.757] [local output]  - Node 1 of 2 ...
[17:40:10.758] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:10.759] [local output] Rscript port: 11794

[17:40:10.759] [local output]  - Node 2 of 2 ...
[17:40:10.760] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:10.760] [local output] Rscript port: 11794

[17:40:10.761] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:10.761] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:10.761] [local output] Setting up PSOCK nodes in parallel
[17:40:10.761] List of 36
[17:40:10.761]  $ worker          : chr "localhost"
[17:40:10.761]   ..- attr(*, "localhost")= logi TRUE
[17:40:10.761]  $ master          : chr "localhost"
[17:40:10.761]  $ port            : int 11794
[17:40:10.761]  $ connectTimeout  : num 120
[17:40:10.761]  $ timeout         : num 2592000
[17:40:10.761]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:10.761]  $ homogeneous     : logi TRUE
[17:40:10.761]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:10.761]  $ rscript_envs    : NULL
[17:40:10.761]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:10.761]  $ rscript_startup : NULL
[17:40:10.761]  $ rscript_sh      : chr "sh"
[17:40:10.761]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:10.761]  $ methods         : logi TRUE
[17:40:10.761]  $ socketOptions   : chr "no-delay"
[17:40:10.761]  $ useXDR          : logi FALSE
[17:40:10.761]  $ outfile         : chr "/dev/null"
[17:40:10.761]  $ renice          : int NA
[17:40:10.761]  $ rshcmd          : NULL
[17:40:10.761]  $ user            : chr(0) 
[17:40:10.761]  $ revtunnel       : logi FALSE
[17:40:10.761]  $ rshlogfile      : NULL
[17:40:10.761]  $ rshopts         : chr(0) 
[17:40:10.761]  $ rank            : int 1
[17:40:10.761]  $ manual          : logi FALSE
[17:40:10.761]  $ dryrun          : logi FALSE
[17:40:10.761]  $ quiet           : logi FALSE
[17:40:10.761]  $ setup_strategy  : chr "parallel"
[17:40:10.761]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:10.761]  $ pidfile         : chr "/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b2491cc50933.pid"
[17:40:10.761]  $ rshcmd_label    : NULL
[17:40:10.761]  $ rsh_call        : NULL
[17:40:10.761]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:10.761]  $ localMachine    : logi TRUE
[17:40:10.761]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:10.761]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:10.761]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:10.761]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:10.761]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:10.761]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:10.761]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:10.761]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:10.761]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:10.761]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:10.761]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:10.761]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:10.761]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:10.761]  $ arguments       :List of 28
[17:40:10.761]   ..$ worker          : chr "localhost"
[17:40:10.761]   ..$ master          : NULL
[17:40:10.761]   ..$ port            : int 11794
[17:40:10.761]   ..$ connectTimeout  : num 120
[17:40:10.761]   ..$ timeout         : num 2592000
[17:40:10.761]   ..$ rscript         : NULL
[17:40:10.761]   ..$ homogeneous     : NULL
[17:40:10.761]   ..$ rscript_args    : NULL
[17:40:10.761]   ..$ rscript_envs    : NULL
[17:40:10.761]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:10.761]   ..$ rscript_startup : NULL
[17:40:10.761]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:10.761]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:10.761]   ..$ methods         : logi TRUE
[17:40:10.761]   ..$ socketOptions   : chr "no-delay"
[17:40:10.761]   ..$ useXDR          : logi FALSE
[17:40:10.761]   ..$ outfile         : chr "/dev/null"
[17:40:10.761]   ..$ renice          : int NA
[17:40:10.761]   ..$ rshcmd          : NULL
[17:40:10.761]   ..$ user            : NULL
[17:40:10.761]   ..$ revtunnel       : logi NA
[17:40:10.761]   ..$ rshlogfile      : NULL
[17:40:10.761]   ..$ rshopts         : NULL
[17:40:10.761]   ..$ rank            : int 1
[17:40:10.761]   ..$ manual          : logi FALSE
[17:40:10.761]   ..$ dryrun          : logi FALSE
[17:40:10.761]   ..$ quiet           : logi FALSE
[17:40:10.761]   ..$ setup_strategy  : chr "parallel"
[17:40:10.761]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:10.780] [local output] System call to launch all workers:
[17:40:10.780] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpoe1XPu/worker.rank=1.parallelly.parent=45641.b2491cc50933.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11794 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:10.780] [local output] Starting PSOCK main server
[17:40:10.781] [local output] Workers launched
[17:40:10.782] [local output] Waiting for workers to connect back
[17:40:10.782]  - [local output] 0 workers out of 2 ready
[17:40:11.024]  - [local output] 0 workers out of 2 ready
[17:40:11.025]  - [local output] 1 workers out of 2 ready
[17:40:11.025]  - [local output] 2 workers out of 2 ready
[17:40:11.025] [local output] Launching of workers completed
[17:40:11.025] [local output] Collecting session information from workers
[17:40:11.026] [local output]  - Worker #1 of 2
[17:40:11.027] [local output]  - Worker #2 of 2
[17:40:11.027] [local output] makeClusterPSOCK() ... done
[17:40:11.037] Packages needed by the future expression (n = 0): <none>
[17:40:11.037] Packages needed by future strategies (n = 0): <none>
[17:40:11.038] {
[17:40:11.038]     {
[17:40:11.038]         {
[17:40:11.038]             ...future.startTime <- base::Sys.time()
[17:40:11.038]             {
[17:40:11.038]                 {
[17:40:11.038]                   {
[17:40:11.038]                     {
[17:40:11.038]                       base::local({
[17:40:11.038]                         has_future <- base::requireNamespace("future", 
[17:40:11.038]                           quietly = TRUE)
[17:40:11.038]                         if (has_future) {
[17:40:11.038]                           ns <- base::getNamespace("future")
[17:40:11.038]                           version <- ns[[".package"]][["version"]]
[17:40:11.038]                           if (is.null(version)) 
[17:40:11.038]                             version <- utils::packageVersion("future")
[17:40:11.038]                         }
[17:40:11.038]                         else {
[17:40:11.038]                           version <- NULL
[17:40:11.038]                         }
[17:40:11.038]                         if (!has_future || version < "1.8.0") {
[17:40:11.038]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:11.038]                             "", base::R.version$version.string), 
[17:40:11.038]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:11.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:11.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:11.038]                               "release", "version")], collapse = " "), 
[17:40:11.038]                             hostname = base::Sys.info()[["nodename"]])
[17:40:11.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:11.038]                             info)
[17:40:11.038]                           info <- base::paste(info, collapse = "; ")
[17:40:11.038]                           if (!has_future) {
[17:40:11.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:11.038]                               info)
[17:40:11.038]                           }
[17:40:11.038]                           else {
[17:40:11.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:11.038]                               info, version)
[17:40:11.038]                           }
[17:40:11.038]                           base::stop(msg)
[17:40:11.038]                         }
[17:40:11.038]                       })
[17:40:11.038]                     }
[17:40:11.038]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:11.038]                     base::options(mc.cores = 1L)
[17:40:11.038]                   }
[17:40:11.038]                   ...future.strategy.old <- future::plan("list")
[17:40:11.038]                   options(future.plan = NULL)
[17:40:11.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:11.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:11.038]                 }
[17:40:11.038]                 ...future.workdir <- getwd()
[17:40:11.038]             }
[17:40:11.038]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:11.038]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:11.038]         }
[17:40:11.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:11.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:11.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:11.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:11.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:11.038]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:11.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:11.038]             base::names(...future.oldOptions))
[17:40:11.038]     }
[17:40:11.038]     if (FALSE) {
[17:40:11.038]     }
[17:40:11.038]     else {
[17:40:11.038]         if (TRUE) {
[17:40:11.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:11.038]                 open = "w")
[17:40:11.038]         }
[17:40:11.038]         else {
[17:40:11.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:11.038]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:11.038]         }
[17:40:11.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:11.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:11.038]             base::sink(type = "output", split = FALSE)
[17:40:11.038]             base::close(...future.stdout)
[17:40:11.038]         }, add = TRUE)
[17:40:11.038]     }
[17:40:11.038]     ...future.frame <- base::sys.nframe()
[17:40:11.038]     ...future.conditions <- base::list()
[17:40:11.038]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:11.038]     if (FALSE) {
[17:40:11.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:11.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:11.038]     }
[17:40:11.038]     ...future.result <- base::tryCatch({
[17:40:11.038]         base::withCallingHandlers({
[17:40:11.038]             ...future.value <- base::withVisible(base::local({
[17:40:11.038]                 ...future.makeSendCondition <- base::local({
[17:40:11.038]                   sendCondition <- NULL
[17:40:11.038]                   function(frame = 1L) {
[17:40:11.038]                     if (is.function(sendCondition)) 
[17:40:11.038]                       return(sendCondition)
[17:40:11.038]                     ns <- getNamespace("parallel")
[17:40:11.038]                     if (exists("sendData", mode = "function", 
[17:40:11.038]                       envir = ns)) {
[17:40:11.038]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:11.038]                         envir = ns)
[17:40:11.038]                       envir <- sys.frame(frame)
[17:40:11.038]                       master <- NULL
[17:40:11.038]                       while (!identical(envir, .GlobalEnv) && 
[17:40:11.038]                         !identical(envir, emptyenv())) {
[17:40:11.038]                         if (exists("master", mode = "list", envir = envir, 
[17:40:11.038]                           inherits = FALSE)) {
[17:40:11.038]                           master <- get("master", mode = "list", 
[17:40:11.038]                             envir = envir, inherits = FALSE)
[17:40:11.038]                           if (inherits(master, c("SOCKnode", 
[17:40:11.038]                             "SOCK0node"))) {
[17:40:11.038]                             sendCondition <<- function(cond) {
[17:40:11.038]                               data <- list(type = "VALUE", value = cond, 
[17:40:11.038]                                 success = TRUE)
[17:40:11.038]                               parallel_sendData(master, data)
[17:40:11.038]                             }
[17:40:11.038]                             return(sendCondition)
[17:40:11.038]                           }
[17:40:11.038]                         }
[17:40:11.038]                         frame <- frame + 1L
[17:40:11.038]                         envir <- sys.frame(frame)
[17:40:11.038]                       }
[17:40:11.038]                     }
[17:40:11.038]                     sendCondition <<- function(cond) NULL
[17:40:11.038]                   }
[17:40:11.038]                 })
[17:40:11.038]                 withCallingHandlers({
[17:40:11.038]                   NA
[17:40:11.038]                 }, immediateCondition = function(cond) {
[17:40:11.038]                   sendCondition <- ...future.makeSendCondition()
[17:40:11.038]                   sendCondition(cond)
[17:40:11.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:11.038]                   {
[17:40:11.038]                     inherits <- base::inherits
[17:40:11.038]                     invokeRestart <- base::invokeRestart
[17:40:11.038]                     is.null <- base::is.null
[17:40:11.038]                     muffled <- FALSE
[17:40:11.038]                     if (inherits(cond, "message")) {
[17:40:11.038]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:11.038]                       if (muffled) 
[17:40:11.038]                         invokeRestart("muffleMessage")
[17:40:11.038]                     }
[17:40:11.038]                     else if (inherits(cond, "warning")) {
[17:40:11.038]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:11.038]                       if (muffled) 
[17:40:11.038]                         invokeRestart("muffleWarning")
[17:40:11.038]                     }
[17:40:11.038]                     else if (inherits(cond, "condition")) {
[17:40:11.038]                       if (!is.null(pattern)) {
[17:40:11.038]                         computeRestarts <- base::computeRestarts
[17:40:11.038]                         grepl <- base::grepl
[17:40:11.038]                         restarts <- computeRestarts(cond)
[17:40:11.038]                         for (restart in restarts) {
[17:40:11.038]                           name <- restart$name
[17:40:11.038]                           if (is.null(name)) 
[17:40:11.038]                             next
[17:40:11.038]                           if (!grepl(pattern, name)) 
[17:40:11.038]                             next
[17:40:11.038]                           invokeRestart(restart)
[17:40:11.038]                           muffled <- TRUE
[17:40:11.038]                           break
[17:40:11.038]                         }
[17:40:11.038]                       }
[17:40:11.038]                     }
[17:40:11.038]                     invisible(muffled)
[17:40:11.038]                   }
[17:40:11.038]                   muffleCondition(cond)
[17:40:11.038]                 })
[17:40:11.038]             }))
[17:40:11.038]             future::FutureResult(value = ...future.value$value, 
[17:40:11.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:11.038]                   ...future.rng), globalenv = if (FALSE) 
[17:40:11.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:11.038]                     ...future.globalenv.names))
[17:40:11.038]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:11.038]         }, condition = base::local({
[17:40:11.038]             c <- base::c
[17:40:11.038]             inherits <- base::inherits
[17:40:11.038]             invokeRestart <- base::invokeRestart
[17:40:11.038]             length <- base::length
[17:40:11.038]             list <- base::list
[17:40:11.038]             seq.int <- base::seq.int
[17:40:11.038]             signalCondition <- base::signalCondition
[17:40:11.038]             sys.calls <- base::sys.calls
[17:40:11.038]             `[[` <- base::`[[`
[17:40:11.038]             `+` <- base::`+`
[17:40:11.038]             `<<-` <- base::`<<-`
[17:40:11.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:11.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:11.038]                   3L)]
[17:40:11.038]             }
[17:40:11.038]             function(cond) {
[17:40:11.038]                 is_error <- inherits(cond, "error")
[17:40:11.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:11.038]                   NULL)
[17:40:11.038]                 if (is_error) {
[17:40:11.038]                   sessionInformation <- function() {
[17:40:11.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:11.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:11.038]                       search = base::search(), system = base::Sys.info())
[17:40:11.038]                   }
[17:40:11.038]                   ...future.conditions[[length(...future.conditions) + 
[17:40:11.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:11.038]                     cond$call), session = sessionInformation(), 
[17:40:11.038]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:11.038]                   signalCondition(cond)
[17:40:11.038]                 }
[17:40:11.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:11.038]                 "immediateCondition"))) {
[17:40:11.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:11.038]                   ...future.conditions[[length(...future.conditions) + 
[17:40:11.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:11.038]                   if (TRUE && !signal) {
[17:40:11.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:11.038]                     {
[17:40:11.038]                       inherits <- base::inherits
[17:40:11.038]                       invokeRestart <- base::invokeRestart
[17:40:11.038]                       is.null <- base::is.null
[17:40:11.038]                       muffled <- FALSE
[17:40:11.038]                       if (inherits(cond, "message")) {
[17:40:11.038]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:11.038]                         if (muffled) 
[17:40:11.038]                           invokeRestart("muffleMessage")
[17:40:11.038]                       }
[17:40:11.038]                       else if (inherits(cond, "warning")) {
[17:40:11.038]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:11.038]                         if (muffled) 
[17:40:11.038]                           invokeRestart("muffleWarning")
[17:40:11.038]                       }
[17:40:11.038]                       else if (inherits(cond, "condition")) {
[17:40:11.038]                         if (!is.null(pattern)) {
[17:40:11.038]                           computeRestarts <- base::computeRestarts
[17:40:11.038]                           grepl <- base::grepl
[17:40:11.038]                           restarts <- computeRestarts(cond)
[17:40:11.038]                           for (restart in restarts) {
[17:40:11.038]                             name <- restart$name
[17:40:11.038]                             if (is.null(name)) 
[17:40:11.038]                               next
[17:40:11.038]                             if (!grepl(pattern, name)) 
[17:40:11.038]                               next
[17:40:11.038]                             invokeRestart(restart)
[17:40:11.038]                             muffled <- TRUE
[17:40:11.038]                             break
[17:40:11.038]                           }
[17:40:11.038]                         }
[17:40:11.038]                       }
[17:40:11.038]                       invisible(muffled)
[17:40:11.038]                     }
[17:40:11.038]                     muffleCondition(cond, pattern = "^muffle")
[17:40:11.038]                   }
[17:40:11.038]                 }
[17:40:11.038]                 else {
[17:40:11.038]                   if (TRUE) {
[17:40:11.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:11.038]                     {
[17:40:11.038]                       inherits <- base::inherits
[17:40:11.038]                       invokeRestart <- base::invokeRestart
[17:40:11.038]                       is.null <- base::is.null
[17:40:11.038]                       muffled <- FALSE
[17:40:11.038]                       if (inherits(cond, "message")) {
[17:40:11.038]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:11.038]                         if (muffled) 
[17:40:11.038]                           invokeRestart("muffleMessage")
[17:40:11.038]                       }
[17:40:11.038]                       else if (inherits(cond, "warning")) {
[17:40:11.038]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:11.038]                         if (muffled) 
[17:40:11.038]                           invokeRestart("muffleWarning")
[17:40:11.038]                       }
[17:40:11.038]                       else if (inherits(cond, "condition")) {
[17:40:11.038]                         if (!is.null(pattern)) {
[17:40:11.038]                           computeRestarts <- base::computeRestarts
[17:40:11.038]                           grepl <- base::grepl
[17:40:11.038]                           restarts <- computeRestarts(cond)
[17:40:11.038]                           for (restart in restarts) {
[17:40:11.038]                             name <- restart$name
[17:40:11.038]                             if (is.null(name)) 
[17:40:11.038]                               next
[17:40:11.038]                             if (!grepl(pattern, name)) 
[17:40:11.038]                               next
[17:40:11.038]                             invokeRestart(restart)
[17:40:11.038]                             muffled <- TRUE
[17:40:11.038]                             break
[17:40:11.038]                           }
[17:40:11.038]                         }
[17:40:11.038]                       }
[17:40:11.038]                       invisible(muffled)
[17:40:11.038]                     }
[17:40:11.038]                     muffleCondition(cond, pattern = "^muffle")
[17:40:11.038]                   }
[17:40:11.038]                 }
[17:40:11.038]             }
[17:40:11.038]         }))
[17:40:11.038]     }, error = function(ex) {
[17:40:11.038]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:11.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:11.038]                 ...future.rng), started = ...future.startTime, 
[17:40:11.038]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:11.038]             version = "1.8"), class = "FutureResult")
[17:40:11.038]     }, finally = {
[17:40:11.038]         if (!identical(...future.workdir, getwd())) 
[17:40:11.038]             setwd(...future.workdir)
[17:40:11.038]         {
[17:40:11.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:11.038]                 ...future.oldOptions$nwarnings <- NULL
[17:40:11.038]             }
[17:40:11.038]             base::options(...future.oldOptions)
[17:40:11.038]             if (.Platform$OS.type == "windows") {
[17:40:11.038]                 old_names <- names(...future.oldEnvVars)
[17:40:11.038]                 envs <- base::Sys.getenv()
[17:40:11.038]                 names <- names(envs)
[17:40:11.038]                 common <- intersect(names, old_names)
[17:40:11.038]                 added <- setdiff(names, old_names)
[17:40:11.038]                 removed <- setdiff(old_names, names)
[17:40:11.038]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:11.038]                   envs[common]]
[17:40:11.038]                 NAMES <- toupper(changed)
[17:40:11.038]                 args <- list()
[17:40:11.038]                 for (kk in seq_along(NAMES)) {
[17:40:11.038]                   name <- changed[[kk]]
[17:40:11.038]                   NAME <- NAMES[[kk]]
[17:40:11.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:11.038]                     next
[17:40:11.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:11.038]                 }
[17:40:11.038]                 NAMES <- toupper(added)
[17:40:11.038]                 for (kk in seq_along(NAMES)) {
[17:40:11.038]                   name <- added[[kk]]
[17:40:11.038]                   NAME <- NAMES[[kk]]
[17:40:11.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:11.038]                     next
[17:40:11.038]                   args[[name]] <- ""
[17:40:11.038]                 }
[17:40:11.038]                 NAMES <- toupper(removed)
[17:40:11.038]                 for (kk in seq_along(NAMES)) {
[17:40:11.038]                   name <- removed[[kk]]
[17:40:11.038]                   NAME <- NAMES[[kk]]
[17:40:11.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:11.038]                     next
[17:40:11.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:11.038]                 }
[17:40:11.038]                 if (length(args) > 0) 
[17:40:11.038]                   base::do.call(base::Sys.setenv, args = args)
[17:40:11.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:11.038]             }
[17:40:11.038]             else {
[17:40:11.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:11.038]             }
[17:40:11.038]             {
[17:40:11.038]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:11.038]                   0L) {
[17:40:11.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:11.038]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:11.038]                   base::options(opts)
[17:40:11.038]                 }
[17:40:11.038]                 {
[17:40:11.038]                   {
[17:40:11.038]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:11.038]                     NULL
[17:40:11.038]                   }
[17:40:11.038]                   options(future.plan = NULL)
[17:40:11.038]                   if (is.na(NA_character_)) 
[17:40:11.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:11.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:11.038]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:11.038]                     .init = FALSE)
[17:40:11.038]                 }
[17:40:11.038]             }
[17:40:11.038]         }
[17:40:11.038]     })
[17:40:11.038]     if (TRUE) {
[17:40:11.038]         base::sink(type = "output", split = FALSE)
[17:40:11.038]         if (TRUE) {
[17:40:11.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:11.038]         }
[17:40:11.038]         else {
[17:40:11.038]             ...future.result["stdout"] <- base::list(NULL)
[17:40:11.038]         }
[17:40:11.038]         base::close(...future.stdout)
[17:40:11.038]         ...future.stdout <- NULL
[17:40:11.038]     }
[17:40:11.038]     ...future.result$conditions <- ...future.conditions
[17:40:11.038]     ...future.result$finished <- base::Sys.time()
[17:40:11.038]     ...future.result
[17:40:11.038] }
[17:40:11.088] MultisessionFuture started
[17:40:11.088] result() for ClusterFuture ...
[17:40:11.089] receiveMessageFromWorker() for ClusterFuture ...
[17:40:11.089] - Validating connection of MultisessionFuture
[17:40:11.120] - received message: FutureResult
[17:40:11.120] - Received FutureResult
[17:40:11.121] - Erased future from FutureRegistry
[17:40:11.121] result() for ClusterFuture ...
[17:40:11.121] - result already collected: FutureResult
[17:40:11.121] result() for ClusterFuture ... done
[17:40:11.121] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:11.121] result() for ClusterFuture ... done
[17:40:11.121] result() for ClusterFuture ...
[17:40:11.121] - result already collected: FutureResult
[17:40:11.121] result() for ClusterFuture ... done
[17:40:11.121] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:11.122] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[17:40:11.122] getGlobalsAndPackages() ...
[17:40:11.122] Searching for globals...
[17:40:11.122] 
[17:40:11.122] Searching for globals ... DONE
[17:40:11.122] - globals: [0] <none>
[17:40:11.123] getGlobalsAndPackages() ... DONE
[17:40:11.123] run() for ‘Future’ ...
[17:40:11.123] - state: ‘created’
[17:40:11.123] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:11.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:11.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:11.134]   - Field: ‘node’
[17:40:11.134]   - Field: ‘label’
[17:40:11.134]   - Field: ‘local’
[17:40:11.134]   - Field: ‘owner’
[17:40:11.134]   - Field: ‘envir’
[17:40:11.134]   - Field: ‘workers’
[17:40:11.134]   - Field: ‘packages’
[17:40:11.134]   - Field: ‘gc’
[17:40:11.134]   - Field: ‘conditions’
[17:40:11.134]   - Field: ‘persistent’
[17:40:11.135]   - Field: ‘expr’
[17:40:11.135]   - Field: ‘uuid’
[17:40:11.135]   - Field: ‘seed’
[17:40:11.135]   - Field: ‘version’
[17:40:11.135]   - Field: ‘result’
[17:40:11.135]   - Field: ‘asynchronous’
[17:40:11.135]   - Field: ‘calls’
[17:40:11.135]   - Field: ‘globals’
[17:40:11.135]   - Field: ‘stdout’
[17:40:11.135]   - Field: ‘earlySignal’
[17:40:11.135]   - Field: ‘lazy’
[17:40:11.136]   - Field: ‘state’
[17:40:11.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:11.136] - Launch lazy future ...
[17:40:11.136] Packages needed by the future expression (n = 0): <none>
[17:40:11.136] Packages needed by future strategies (n = 0): <none>
[17:40:11.137] {
[17:40:11.137]     {
[17:40:11.137]         {
[17:40:11.137]             ...future.startTime <- base::Sys.time()
[17:40:11.137]             {
[17:40:11.137]                 {
[17:40:11.137]                   {
[17:40:11.137]                     {
[17:40:11.137]                       base::local({
[17:40:11.137]                         has_future <- base::requireNamespace("future", 
[17:40:11.137]                           quietly = TRUE)
[17:40:11.137]                         if (has_future) {
[17:40:11.137]                           ns <- base::getNamespace("future")
[17:40:11.137]                           version <- ns[[".package"]][["version"]]
[17:40:11.137]                           if (is.null(version)) 
[17:40:11.137]                             version <- utils::packageVersion("future")
[17:40:11.137]                         }
[17:40:11.137]                         else {
[17:40:11.137]                           version <- NULL
[17:40:11.137]                         }
[17:40:11.137]                         if (!has_future || version < "1.8.0") {
[17:40:11.137]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:11.137]                             "", base::R.version$version.string), 
[17:40:11.137]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:11.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:11.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:11.137]                               "release", "version")], collapse = " "), 
[17:40:11.137]                             hostname = base::Sys.info()[["nodename"]])
[17:40:11.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:11.137]                             info)
[17:40:11.137]                           info <- base::paste(info, collapse = "; ")
[17:40:11.137]                           if (!has_future) {
[17:40:11.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:11.137]                               info)
[17:40:11.137]                           }
[17:40:11.137]                           else {
[17:40:11.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:11.137]                               info, version)
[17:40:11.137]                           }
[17:40:11.137]                           base::stop(msg)
[17:40:11.137]                         }
[17:40:11.137]                       })
[17:40:11.137]                     }
[17:40:11.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:11.137]                     base::options(mc.cores = 1L)
[17:40:11.137]                   }
[17:40:11.137]                   ...future.strategy.old <- future::plan("list")
[17:40:11.137]                   options(future.plan = NULL)
[17:40:11.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:11.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:11.137]                 }
[17:40:11.137]                 ...future.workdir <- getwd()
[17:40:11.137]             }
[17:40:11.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:11.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:11.137]         }
[17:40:11.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:11.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:11.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:11.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:11.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:11.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:11.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:11.137]             base::names(...future.oldOptions))
[17:40:11.137]     }
[17:40:11.137]     if (FALSE) {
[17:40:11.137]     }
[17:40:11.137]     else {
[17:40:11.137]         if (TRUE) {
[17:40:11.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:11.137]                 open = "w")
[17:40:11.137]         }
[17:40:11.137]         else {
[17:40:11.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:11.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:11.137]         }
[17:40:11.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:11.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:11.137]             base::sink(type = "output", split = FALSE)
[17:40:11.137]             base::close(...future.stdout)
[17:40:11.137]         }, add = TRUE)
[17:40:11.137]     }
[17:40:11.137]     ...future.frame <- base::sys.nframe()
[17:40:11.137]     ...future.conditions <- base::list()
[17:40:11.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:11.137]     if (FALSE) {
[17:40:11.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:11.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:11.137]     }
[17:40:11.137]     ...future.result <- base::tryCatch({
[17:40:11.137]         base::withCallingHandlers({
[17:40:11.137]             ...future.value <- base::withVisible(base::local({
[17:40:11.137]                 ...future.makeSendCondition <- base::local({
[17:40:11.137]                   sendCondition <- NULL
[17:40:11.137]                   function(frame = 1L) {
[17:40:11.137]                     if (is.function(sendCondition)) 
[17:40:11.137]                       return(sendCondition)
[17:40:11.137]                     ns <- getNamespace("parallel")
[17:40:11.137]                     if (exists("sendData", mode = "function", 
[17:40:11.137]                       envir = ns)) {
[17:40:11.137]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:11.137]                         envir = ns)
[17:40:11.137]                       envir <- sys.frame(frame)
[17:40:11.137]                       master <- NULL
[17:40:11.137]                       while (!identical(envir, .GlobalEnv) && 
[17:40:11.137]                         !identical(envir, emptyenv())) {
[17:40:11.137]                         if (exists("master", mode = "list", envir = envir, 
[17:40:11.137]                           inherits = FALSE)) {
[17:40:11.137]                           master <- get("master", mode = "list", 
[17:40:11.137]                             envir = envir, inherits = FALSE)
[17:40:11.137]                           if (inherits(master, c("SOCKnode", 
[17:40:11.137]                             "SOCK0node"))) {
[17:40:11.137]                             sendCondition <<- function(cond) {
[17:40:11.137]                               data <- list(type = "VALUE", value = cond, 
[17:40:11.137]                                 success = TRUE)
[17:40:11.137]                               parallel_sendData(master, data)
[17:40:11.137]                             }
[17:40:11.137]                             return(sendCondition)
[17:40:11.137]                           }
[17:40:11.137]                         }
[17:40:11.137]                         frame <- frame + 1L
[17:40:11.137]                         envir <- sys.frame(frame)
[17:40:11.137]                       }
[17:40:11.137]                     }
[17:40:11.137]                     sendCondition <<- function(cond) NULL
[17:40:11.137]                   }
[17:40:11.137]                 })
[17:40:11.137]                 withCallingHandlers({
[17:40:11.137]                   1L
[17:40:11.137]                 }, immediateCondition = function(cond) {
[17:40:11.137]                   sendCondition <- ...future.makeSendCondition()
[17:40:11.137]                   sendCondition(cond)
[17:40:11.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:11.137]                   {
[17:40:11.137]                     inherits <- base::inherits
[17:40:11.137]                     invokeRestart <- base::invokeRestart
[17:40:11.137]                     is.null <- base::is.null
[17:40:11.137]                     muffled <- FALSE
[17:40:11.137]                     if (inherits(cond, "message")) {
[17:40:11.137]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:11.137]                       if (muffled) 
[17:40:11.137]                         invokeRestart("muffleMessage")
[17:40:11.137]                     }
[17:40:11.137]                     else if (inherits(cond, "warning")) {
[17:40:11.137]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:11.137]                       if (muffled) 
[17:40:11.137]                         invokeRestart("muffleWarning")
[17:40:11.137]                     }
[17:40:11.137]                     else if (inherits(cond, "condition")) {
[17:40:11.137]                       if (!is.null(pattern)) {
[17:40:11.137]                         computeRestarts <- base::computeRestarts
[17:40:11.137]                         grepl <- base::grepl
[17:40:11.137]                         restarts <- computeRestarts(cond)
[17:40:11.137]                         for (restart in restarts) {
[17:40:11.137]                           name <- restart$name
[17:40:11.137]                           if (is.null(name)) 
[17:40:11.137]                             next
[17:40:11.137]                           if (!grepl(pattern, name)) 
[17:40:11.137]                             next
[17:40:11.137]                           invokeRestart(restart)
[17:40:11.137]                           muffled <- TRUE
[17:40:11.137]                           break
[17:40:11.137]                         }
[17:40:11.137]                       }
[17:40:11.137]                     }
[17:40:11.137]                     invisible(muffled)
[17:40:11.137]                   }
[17:40:11.137]                   muffleCondition(cond)
[17:40:11.137]                 })
[17:40:11.137]             }))
[17:40:11.137]             future::FutureResult(value = ...future.value$value, 
[17:40:11.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:11.137]                   ...future.rng), globalenv = if (FALSE) 
[17:40:11.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:11.137]                     ...future.globalenv.names))
[17:40:11.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:11.137]         }, condition = base::local({
[17:40:11.137]             c <- base::c
[17:40:11.137]             inherits <- base::inherits
[17:40:11.137]             invokeRestart <- base::invokeRestart
[17:40:11.137]             length <- base::length
[17:40:11.137]             list <- base::list
[17:40:11.137]             seq.int <- base::seq.int
[17:40:11.137]             signalCondition <- base::signalCondition
[17:40:11.137]             sys.calls <- base::sys.calls
[17:40:11.137]             `[[` <- base::`[[`
[17:40:11.137]             `+` <- base::`+`
[17:40:11.137]             `<<-` <- base::`<<-`
[17:40:11.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:11.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:11.137]                   3L)]
[17:40:11.137]             }
[17:40:11.137]             function(cond) {
[17:40:11.137]                 is_error <- inherits(cond, "error")
[17:40:11.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:11.137]                   NULL)
[17:40:11.137]                 if (is_error) {
[17:40:11.137]                   sessionInformation <- function() {
[17:40:11.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:11.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:11.137]                       search = base::search(), system = base::Sys.info())
[17:40:11.137]                   }
[17:40:11.137]                   ...future.conditions[[length(...future.conditions) + 
[17:40:11.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:11.137]                     cond$call), session = sessionInformation(), 
[17:40:11.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:11.137]                   signalCondition(cond)
[17:40:11.137]                 }
[17:40:11.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:11.137]                 "immediateCondition"))) {
[17:40:11.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:11.137]                   ...future.conditions[[length(...future.conditions) + 
[17:40:11.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:11.137]                   if (TRUE && !signal) {
[17:40:11.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:11.137]                     {
[17:40:11.137]                       inherits <- base::inherits
[17:40:11.137]                       invokeRestart <- base::invokeRestart
[17:40:11.137]                       is.null <- base::is.null
[17:40:11.137]                       muffled <- FALSE
[17:40:11.137]                       if (inherits(cond, "message")) {
[17:40:11.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:11.137]                         if (muffled) 
[17:40:11.137]                           invokeRestart("muffleMessage")
[17:40:11.137]                       }
[17:40:11.137]                       else if (inherits(cond, "warning")) {
[17:40:11.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:11.137]                         if (muffled) 
[17:40:11.137]                           invokeRestart("muffleWarning")
[17:40:11.137]                       }
[17:40:11.137]                       else if (inherits(cond, "condition")) {
[17:40:11.137]                         if (!is.null(pattern)) {
[17:40:11.137]                           computeRestarts <- base::computeRestarts
[17:40:11.137]                           grepl <- base::grepl
[17:40:11.137]                           restarts <- computeRestarts(cond)
[17:40:11.137]                           for (restart in restarts) {
[17:40:11.137]                             name <- restart$name
[17:40:11.137]                             if (is.null(name)) 
[17:40:11.137]                               next
[17:40:11.137]                             if (!grepl(pattern, name)) 
[17:40:11.137]                               next
[17:40:11.137]                             invokeRestart(restart)
[17:40:11.137]                             muffled <- TRUE
[17:40:11.137]                             break
[17:40:11.137]                           }
[17:40:11.137]                         }
[17:40:11.137]                       }
[17:40:11.137]                       invisible(muffled)
[17:40:11.137]                     }
[17:40:11.137]                     muffleCondition(cond, pattern = "^muffle")
[17:40:11.137]                   }
[17:40:11.137]                 }
[17:40:11.137]                 else {
[17:40:11.137]                   if (TRUE) {
[17:40:11.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:11.137]                     {
[17:40:11.137]                       inherits <- base::inherits
[17:40:11.137]                       invokeRestart <- base::invokeRestart
[17:40:11.137]                       is.null <- base::is.null
[17:40:11.137]                       muffled <- FALSE
[17:40:11.137]                       if (inherits(cond, "message")) {
[17:40:11.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:11.137]                         if (muffled) 
[17:40:11.137]                           invokeRestart("muffleMessage")
[17:40:11.137]                       }
[17:40:11.137]                       else if (inherits(cond, "warning")) {
[17:40:11.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:11.137]                         if (muffled) 
[17:40:11.137]                           invokeRestart("muffleWarning")
[17:40:11.137]                       }
[17:40:11.137]                       else if (inherits(cond, "condition")) {
[17:40:11.137]                         if (!is.null(pattern)) {
[17:40:11.137]                           computeRestarts <- base::computeRestarts
[17:40:11.137]                           grepl <- base::grepl
[17:40:11.137]                           restarts <- computeRestarts(cond)
[17:40:11.137]                           for (restart in restarts) {
[17:40:11.137]                             name <- restart$name
[17:40:11.137]                             if (is.null(name)) 
[17:40:11.137]                               next
[17:40:11.137]                             if (!grepl(pattern, name)) 
[17:40:11.137]                               next
[17:40:11.137]                             invokeRestart(restart)
[17:40:11.137]                             muffled <- TRUE
[17:40:11.137]                             break
[17:40:11.137]                           }
[17:40:11.137]                         }
[17:40:11.137]                       }
[17:40:11.137]                       invisible(muffled)
[17:40:11.137]                     }
[17:40:11.137]                     muffleCondition(cond, pattern = "^muffle")
[17:40:11.137]                   }
[17:40:11.137]                 }
[17:40:11.137]             }
[17:40:11.137]         }))
[17:40:11.137]     }, error = function(ex) {
[17:40:11.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:11.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:11.137]                 ...future.rng), started = ...future.startTime, 
[17:40:11.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:11.137]             version = "1.8"), class = "FutureResult")
[17:40:11.137]     }, finally = {
[17:40:11.137]         if (!identical(...future.workdir, getwd())) 
[17:40:11.137]             setwd(...future.workdir)
[17:40:11.137]         {
[17:40:11.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:11.137]                 ...future.oldOptions$nwarnings <- NULL
[17:40:11.137]             }
[17:40:11.137]             base::options(...future.oldOptions)
[17:40:11.137]             if (.Platform$OS.type == "windows") {
[17:40:11.137]                 old_names <- names(...future.oldEnvVars)
[17:40:11.137]                 envs <- base::Sys.getenv()
[17:40:11.137]                 names <- names(envs)
[17:40:11.137]                 common <- intersect(names, old_names)
[17:40:11.137]                 added <- setdiff(names, old_names)
[17:40:11.137]                 removed <- setdiff(old_names, names)
[17:40:11.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:11.137]                   envs[common]]
[17:40:11.137]                 NAMES <- toupper(changed)
[17:40:11.137]                 args <- list()
[17:40:11.137]                 for (kk in seq_along(NAMES)) {
[17:40:11.137]                   name <- changed[[kk]]
[17:40:11.137]                   NAME <- NAMES[[kk]]
[17:40:11.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:11.137]                     next
[17:40:11.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:11.137]                 }
[17:40:11.137]                 NAMES <- toupper(added)
[17:40:11.137]                 for (kk in seq_along(NAMES)) {
[17:40:11.137]                   name <- added[[kk]]
[17:40:11.137]                   NAME <- NAMES[[kk]]
[17:40:11.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:11.137]                     next
[17:40:11.137]                   args[[name]] <- ""
[17:40:11.137]                 }
[17:40:11.137]                 NAMES <- toupper(removed)
[17:40:11.137]                 for (kk in seq_along(NAMES)) {
[17:40:11.137]                   name <- removed[[kk]]
[17:40:11.137]                   NAME <- NAMES[[kk]]
[17:40:11.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:11.137]                     next
[17:40:11.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:11.137]                 }
[17:40:11.137]                 if (length(args) > 0) 
[17:40:11.137]                   base::do.call(base::Sys.setenv, args = args)
[17:40:11.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:11.137]             }
[17:40:11.137]             else {
[17:40:11.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:11.137]             }
[17:40:11.137]             {
[17:40:11.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:11.137]                   0L) {
[17:40:11.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:11.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:11.137]                   base::options(opts)
[17:40:11.137]                 }
[17:40:11.137]                 {
[17:40:11.137]                   {
[17:40:11.137]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:11.137]                     NULL
[17:40:11.137]                   }
[17:40:11.137]                   options(future.plan = NULL)
[17:40:11.137]                   if (is.na(NA_character_)) 
[17:40:11.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:11.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:11.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:11.137]                     .init = FALSE)
[17:40:11.137]                 }
[17:40:11.137]             }
[17:40:11.137]         }
[17:40:11.137]     })
[17:40:11.137]     if (TRUE) {
[17:40:11.137]         base::sink(type = "output", split = FALSE)
[17:40:11.137]         if (TRUE) {
[17:40:11.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:11.137]         }
[17:40:11.137]         else {
[17:40:11.137]             ...future.result["stdout"] <- base::list(NULL)
[17:40:11.137]         }
[17:40:11.137]         base::close(...future.stdout)
[17:40:11.137]         ...future.stdout <- NULL
[17:40:11.137]     }
[17:40:11.137]     ...future.result$conditions <- ...future.conditions
[17:40:11.137]     ...future.result$finished <- base::Sys.time()
[17:40:11.137]     ...future.result
[17:40:11.137] }
[17:40:11.140] MultisessionFuture started
[17:40:11.140] - Launch lazy future ... done
[17:40:11.140] run() for ‘MultisessionFuture’ ... done
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[17:40:11.140] plan(): Setting new future strategy stack:
[17:40:11.140] List of future strategies:
[17:40:11.140] 1. sequential:
[17:40:11.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:11.140]    - tweaked: FALSE
[17:40:11.140]    - call: plan(sequential)
[17:40:11.141] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[17:40:11.142] plan(): Setting new future strategy stack:
[17:40:11.142] List of future strategies:
[17:40:11.142] 1. FutureStrategy:
[17:40:11.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:11.142]    - tweaked: FALSE
[17:40:11.142]    - call: future::plan(oplan)
[17:40:11.143] plan(): nbrOfWorkers() = 1
> 
