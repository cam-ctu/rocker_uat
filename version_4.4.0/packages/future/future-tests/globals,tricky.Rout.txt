
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:39:55.397] plan(): Setting new future strategy stack:
[17:39:55.397] List of future strategies:
[17:39:55.397] 1. sequential:
[17:39:55.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.397]    - tweaked: FALSE
[17:39:55.397]    - call: future::plan("sequential")
[17:39:55.408] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[17:39:55.501] plan(): Setting new future strategy stack:
[17:39:55.501] List of future strategies:
[17:39:55.501] 1. sequential:
[17:39:55.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.501]    - tweaked: FALSE
[17:39:55.501]    - call: plan(strategy)
[17:39:55.513] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.515] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.515] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.521] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:39:55.521] Searching for globals ... DONE
[17:39:55.521] Resolving globals: TRUE
[17:39:55.521] Resolving any globals that are futures ...
[17:39:55.521] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:39:55.521] Resolving any globals that are futures ... DONE
[17:39:55.522] 
[17:39:55.522] 
[17:39:55.522] getGlobalsAndPackages() ... DONE
[17:39:55.523] run() for ‘Future’ ...
[17:39:55.523] - state: ‘created’
[17:39:55.523] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.523] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.523]   - Field: ‘label’
[17:39:55.524]   - Field: ‘local’
[17:39:55.524]   - Field: ‘owner’
[17:39:55.524]   - Field: ‘envir’
[17:39:55.524]   - Field: ‘packages’
[17:39:55.524]   - Field: ‘gc’
[17:39:55.524]   - Field: ‘conditions’
[17:39:55.524]   - Field: ‘expr’
[17:39:55.524]   - Field: ‘uuid’
[17:39:55.524]   - Field: ‘seed’
[17:39:55.524]   - Field: ‘version’
[17:39:55.524]   - Field: ‘result’
[17:39:55.524]   - Field: ‘asynchronous’
[17:39:55.525]   - Field: ‘calls’
[17:39:55.525]   - Field: ‘globals’
[17:39:55.525]   - Field: ‘stdout’
[17:39:55.525]   - Field: ‘earlySignal’
[17:39:55.525]   - Field: ‘lazy’
[17:39:55.525]   - Field: ‘state’
[17:39:55.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.525] - Launch lazy future ...
[17:39:55.526] Packages needed by the future expression (n = 0): <none>
[17:39:55.526] Packages needed by future strategies (n = 0): <none>
[17:39:55.527] {
[17:39:55.527]     {
[17:39:55.527]         {
[17:39:55.527]             ...future.startTime <- base::Sys.time()
[17:39:55.527]             {
[17:39:55.527]                 {
[17:39:55.527]                   {
[17:39:55.527]                     base::local({
[17:39:55.527]                       has_future <- base::requireNamespace("future", 
[17:39:55.527]                         quietly = TRUE)
[17:39:55.527]                       if (has_future) {
[17:39:55.527]                         ns <- base::getNamespace("future")
[17:39:55.527]                         version <- ns[[".package"]][["version"]]
[17:39:55.527]                         if (is.null(version)) 
[17:39:55.527]                           version <- utils::packageVersion("future")
[17:39:55.527]                       }
[17:39:55.527]                       else {
[17:39:55.527]                         version <- NULL
[17:39:55.527]                       }
[17:39:55.527]                       if (!has_future || version < "1.8.0") {
[17:39:55.527]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.527]                           "", base::R.version$version.string), 
[17:39:55.527]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.527]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.527]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.527]                             "release", "version")], collapse = " "), 
[17:39:55.527]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.527]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.527]                           info)
[17:39:55.527]                         info <- base::paste(info, collapse = "; ")
[17:39:55.527]                         if (!has_future) {
[17:39:55.527]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.527]                             info)
[17:39:55.527]                         }
[17:39:55.527]                         else {
[17:39:55.527]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.527]                             info, version)
[17:39:55.527]                         }
[17:39:55.527]                         base::stop(msg)
[17:39:55.527]                       }
[17:39:55.527]                     })
[17:39:55.527]                   }
[17:39:55.527]                   ...future.strategy.old <- future::plan("list")
[17:39:55.527]                   options(future.plan = NULL)
[17:39:55.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.527]                 }
[17:39:55.527]                 ...future.workdir <- getwd()
[17:39:55.527]             }
[17:39:55.527]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.527]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.527]         }
[17:39:55.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.527]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.527]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.527]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.527]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.527]             base::names(...future.oldOptions))
[17:39:55.527]     }
[17:39:55.527]     if (FALSE) {
[17:39:55.527]     }
[17:39:55.527]     else {
[17:39:55.527]         if (TRUE) {
[17:39:55.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.527]                 open = "w")
[17:39:55.527]         }
[17:39:55.527]         else {
[17:39:55.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.527]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.527]         }
[17:39:55.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.527]             base::sink(type = "output", split = FALSE)
[17:39:55.527]             base::close(...future.stdout)
[17:39:55.527]         }, add = TRUE)
[17:39:55.527]     }
[17:39:55.527]     ...future.frame <- base::sys.nframe()
[17:39:55.527]     ...future.conditions <- base::list()
[17:39:55.527]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.527]     if (FALSE) {
[17:39:55.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.527]     }
[17:39:55.527]     ...future.result <- base::tryCatch({
[17:39:55.527]         base::withCallingHandlers({
[17:39:55.527]             ...future.value <- base::withVisible(base::local({
[17:39:55.527]                 b <- a
[17:39:55.527]                 a <- 2
[17:39:55.527]                 a * b
[17:39:55.527]             }))
[17:39:55.527]             future::FutureResult(value = ...future.value$value, 
[17:39:55.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.527]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.527]                     ...future.globalenv.names))
[17:39:55.527]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.527]         }, condition = base::local({
[17:39:55.527]             c <- base::c
[17:39:55.527]             inherits <- base::inherits
[17:39:55.527]             invokeRestart <- base::invokeRestart
[17:39:55.527]             length <- base::length
[17:39:55.527]             list <- base::list
[17:39:55.527]             seq.int <- base::seq.int
[17:39:55.527]             signalCondition <- base::signalCondition
[17:39:55.527]             sys.calls <- base::sys.calls
[17:39:55.527]             `[[` <- base::`[[`
[17:39:55.527]             `+` <- base::`+`
[17:39:55.527]             `<<-` <- base::`<<-`
[17:39:55.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.527]                   3L)]
[17:39:55.527]             }
[17:39:55.527]             function(cond) {
[17:39:55.527]                 is_error <- inherits(cond, "error")
[17:39:55.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.527]                   NULL)
[17:39:55.527]                 if (is_error) {
[17:39:55.527]                   sessionInformation <- function() {
[17:39:55.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.527]                       search = base::search(), system = base::Sys.info())
[17:39:55.527]                   }
[17:39:55.527]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.527]                     cond$call), session = sessionInformation(), 
[17:39:55.527]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.527]                   signalCondition(cond)
[17:39:55.527]                 }
[17:39:55.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.527]                 "immediateCondition"))) {
[17:39:55.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.527]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.527]                   if (TRUE && !signal) {
[17:39:55.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.527]                     {
[17:39:55.527]                       inherits <- base::inherits
[17:39:55.527]                       invokeRestart <- base::invokeRestart
[17:39:55.527]                       is.null <- base::is.null
[17:39:55.527]                       muffled <- FALSE
[17:39:55.527]                       if (inherits(cond, "message")) {
[17:39:55.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.527]                         if (muffled) 
[17:39:55.527]                           invokeRestart("muffleMessage")
[17:39:55.527]                       }
[17:39:55.527]                       else if (inherits(cond, "warning")) {
[17:39:55.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.527]                         if (muffled) 
[17:39:55.527]                           invokeRestart("muffleWarning")
[17:39:55.527]                       }
[17:39:55.527]                       else if (inherits(cond, "condition")) {
[17:39:55.527]                         if (!is.null(pattern)) {
[17:39:55.527]                           computeRestarts <- base::computeRestarts
[17:39:55.527]                           grepl <- base::grepl
[17:39:55.527]                           restarts <- computeRestarts(cond)
[17:39:55.527]                           for (restart in restarts) {
[17:39:55.527]                             name <- restart$name
[17:39:55.527]                             if (is.null(name)) 
[17:39:55.527]                               next
[17:39:55.527]                             if (!grepl(pattern, name)) 
[17:39:55.527]                               next
[17:39:55.527]                             invokeRestart(restart)
[17:39:55.527]                             muffled <- TRUE
[17:39:55.527]                             break
[17:39:55.527]                           }
[17:39:55.527]                         }
[17:39:55.527]                       }
[17:39:55.527]                       invisible(muffled)
[17:39:55.527]                     }
[17:39:55.527]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.527]                   }
[17:39:55.527]                 }
[17:39:55.527]                 else {
[17:39:55.527]                   if (TRUE) {
[17:39:55.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.527]                     {
[17:39:55.527]                       inherits <- base::inherits
[17:39:55.527]                       invokeRestart <- base::invokeRestart
[17:39:55.527]                       is.null <- base::is.null
[17:39:55.527]                       muffled <- FALSE
[17:39:55.527]                       if (inherits(cond, "message")) {
[17:39:55.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.527]                         if (muffled) 
[17:39:55.527]                           invokeRestart("muffleMessage")
[17:39:55.527]                       }
[17:39:55.527]                       else if (inherits(cond, "warning")) {
[17:39:55.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.527]                         if (muffled) 
[17:39:55.527]                           invokeRestart("muffleWarning")
[17:39:55.527]                       }
[17:39:55.527]                       else if (inherits(cond, "condition")) {
[17:39:55.527]                         if (!is.null(pattern)) {
[17:39:55.527]                           computeRestarts <- base::computeRestarts
[17:39:55.527]                           grepl <- base::grepl
[17:39:55.527]                           restarts <- computeRestarts(cond)
[17:39:55.527]                           for (restart in restarts) {
[17:39:55.527]                             name <- restart$name
[17:39:55.527]                             if (is.null(name)) 
[17:39:55.527]                               next
[17:39:55.527]                             if (!grepl(pattern, name)) 
[17:39:55.527]                               next
[17:39:55.527]                             invokeRestart(restart)
[17:39:55.527]                             muffled <- TRUE
[17:39:55.527]                             break
[17:39:55.527]                           }
[17:39:55.527]                         }
[17:39:55.527]                       }
[17:39:55.527]                       invisible(muffled)
[17:39:55.527]                     }
[17:39:55.527]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.527]                   }
[17:39:55.527]                 }
[17:39:55.527]             }
[17:39:55.527]         }))
[17:39:55.527]     }, error = function(ex) {
[17:39:55.527]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.527]                 ...future.rng), started = ...future.startTime, 
[17:39:55.527]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.527]             version = "1.8"), class = "FutureResult")
[17:39:55.527]     }, finally = {
[17:39:55.527]         if (!identical(...future.workdir, getwd())) 
[17:39:55.527]             setwd(...future.workdir)
[17:39:55.527]         {
[17:39:55.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.527]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.527]             }
[17:39:55.527]             base::options(...future.oldOptions)
[17:39:55.527]             if (.Platform$OS.type == "windows") {
[17:39:55.527]                 old_names <- names(...future.oldEnvVars)
[17:39:55.527]                 envs <- base::Sys.getenv()
[17:39:55.527]                 names <- names(envs)
[17:39:55.527]                 common <- intersect(names, old_names)
[17:39:55.527]                 added <- setdiff(names, old_names)
[17:39:55.527]                 removed <- setdiff(old_names, names)
[17:39:55.527]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.527]                   envs[common]]
[17:39:55.527]                 NAMES <- toupper(changed)
[17:39:55.527]                 args <- list()
[17:39:55.527]                 for (kk in seq_along(NAMES)) {
[17:39:55.527]                   name <- changed[[kk]]
[17:39:55.527]                   NAME <- NAMES[[kk]]
[17:39:55.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.527]                     next
[17:39:55.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.527]                 }
[17:39:55.527]                 NAMES <- toupper(added)
[17:39:55.527]                 for (kk in seq_along(NAMES)) {
[17:39:55.527]                   name <- added[[kk]]
[17:39:55.527]                   NAME <- NAMES[[kk]]
[17:39:55.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.527]                     next
[17:39:55.527]                   args[[name]] <- ""
[17:39:55.527]                 }
[17:39:55.527]                 NAMES <- toupper(removed)
[17:39:55.527]                 for (kk in seq_along(NAMES)) {
[17:39:55.527]                   name <- removed[[kk]]
[17:39:55.527]                   NAME <- NAMES[[kk]]
[17:39:55.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.527]                     next
[17:39:55.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.527]                 }
[17:39:55.527]                 if (length(args) > 0) 
[17:39:55.527]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.527]             }
[17:39:55.527]             else {
[17:39:55.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.527]             }
[17:39:55.527]             {
[17:39:55.527]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.527]                   0L) {
[17:39:55.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.527]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.527]                   base::options(opts)
[17:39:55.527]                 }
[17:39:55.527]                 {
[17:39:55.527]                   {
[17:39:55.527]                     NULL
[17:39:55.527]                     RNGkind("Mersenne-Twister")
[17:39:55.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.527]                       inherits = FALSE)
[17:39:55.527]                   }
[17:39:55.527]                   options(future.plan = NULL)
[17:39:55.527]                   if (is.na(NA_character_)) 
[17:39:55.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.527]                     .init = FALSE)
[17:39:55.527]                 }
[17:39:55.527]             }
[17:39:55.527]         }
[17:39:55.527]     })
[17:39:55.527]     if (TRUE) {
[17:39:55.527]         base::sink(type = "output", split = FALSE)
[17:39:55.527]         if (TRUE) {
[17:39:55.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.527]         }
[17:39:55.527]         else {
[17:39:55.527]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.527]         }
[17:39:55.527]         base::close(...future.stdout)
[17:39:55.527]         ...future.stdout <- NULL
[17:39:55.527]     }
[17:39:55.527]     ...future.result$conditions <- ...future.conditions
[17:39:55.527]     ...future.result$finished <- base::Sys.time()
[17:39:55.527]     ...future.result
[17:39:55.527] }
[17:39:55.529] plan(): Setting new future strategy stack:
[17:39:55.529] List of future strategies:
[17:39:55.529] 1. sequential:
[17:39:55.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.529]    - tweaked: FALSE
[17:39:55.529]    - call: NULL
[17:39:55.529] plan(): nbrOfWorkers() = 1
[17:39:55.530] plan(): Setting new future strategy stack:
[17:39:55.530] List of future strategies:
[17:39:55.530] 1. sequential:
[17:39:55.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.530]    - tweaked: FALSE
[17:39:55.530]    - call: plan(strategy)
[17:39:55.531] plan(): nbrOfWorkers() = 1
[17:39:55.531] SequentialFuture started (and completed)
[17:39:55.531] - Launch lazy future ... done
[17:39:55.531] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.532] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.532] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.533] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:39:55.534] Searching for globals ... DONE
[17:39:55.534] Resolving globals: TRUE
[17:39:55.534] Resolving any globals that are futures ...
[17:39:55.534] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:39:55.534] Resolving any globals that are futures ... DONE
[17:39:55.534] 
[17:39:55.534] 
[17:39:55.534] getGlobalsAndPackages() ... DONE
[17:39:55.535] run() for ‘Future’ ...
[17:39:55.535] - state: ‘created’
[17:39:55.535] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.535] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.535]   - Field: ‘label’
[17:39:55.535]   - Field: ‘local’
[17:39:55.536]   - Field: ‘owner’
[17:39:55.536]   - Field: ‘envir’
[17:39:55.536]   - Field: ‘packages’
[17:39:55.536]   - Field: ‘gc’
[17:39:55.536]   - Field: ‘conditions’
[17:39:55.536]   - Field: ‘expr’
[17:39:55.536]   - Field: ‘uuid’
[17:39:55.536]   - Field: ‘seed’
[17:39:55.536]   - Field: ‘version’
[17:39:55.536]   - Field: ‘result’
[17:39:55.536]   - Field: ‘asynchronous’
[17:39:55.537]   - Field: ‘calls’
[17:39:55.537]   - Field: ‘globals’
[17:39:55.537]   - Field: ‘stdout’
[17:39:55.537]   - Field: ‘earlySignal’
[17:39:55.537]   - Field: ‘lazy’
[17:39:55.537]   - Field: ‘state’
[17:39:55.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.537] - Launch lazy future ...
[17:39:55.537] Packages needed by the future expression (n = 0): <none>
[17:39:55.537] Packages needed by future strategies (n = 0): <none>
[17:39:55.538] {
[17:39:55.538]     {
[17:39:55.538]         {
[17:39:55.538]             ...future.startTime <- base::Sys.time()
[17:39:55.538]             {
[17:39:55.538]                 {
[17:39:55.538]                   {
[17:39:55.538]                     base::local({
[17:39:55.538]                       has_future <- base::requireNamespace("future", 
[17:39:55.538]                         quietly = TRUE)
[17:39:55.538]                       if (has_future) {
[17:39:55.538]                         ns <- base::getNamespace("future")
[17:39:55.538]                         version <- ns[[".package"]][["version"]]
[17:39:55.538]                         if (is.null(version)) 
[17:39:55.538]                           version <- utils::packageVersion("future")
[17:39:55.538]                       }
[17:39:55.538]                       else {
[17:39:55.538]                         version <- NULL
[17:39:55.538]                       }
[17:39:55.538]                       if (!has_future || version < "1.8.0") {
[17:39:55.538]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.538]                           "", base::R.version$version.string), 
[17:39:55.538]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.538]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.538]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.538]                             "release", "version")], collapse = " "), 
[17:39:55.538]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.538]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.538]                           info)
[17:39:55.538]                         info <- base::paste(info, collapse = "; ")
[17:39:55.538]                         if (!has_future) {
[17:39:55.538]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.538]                             info)
[17:39:55.538]                         }
[17:39:55.538]                         else {
[17:39:55.538]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.538]                             info, version)
[17:39:55.538]                         }
[17:39:55.538]                         base::stop(msg)
[17:39:55.538]                       }
[17:39:55.538]                     })
[17:39:55.538]                   }
[17:39:55.538]                   ...future.strategy.old <- future::plan("list")
[17:39:55.538]                   options(future.plan = NULL)
[17:39:55.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.538]                 }
[17:39:55.538]                 ...future.workdir <- getwd()
[17:39:55.538]             }
[17:39:55.538]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.538]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.538]         }
[17:39:55.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.538]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.538]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.538]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.538]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.538]             base::names(...future.oldOptions))
[17:39:55.538]     }
[17:39:55.538]     if (FALSE) {
[17:39:55.538]     }
[17:39:55.538]     else {
[17:39:55.538]         if (TRUE) {
[17:39:55.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.538]                 open = "w")
[17:39:55.538]         }
[17:39:55.538]         else {
[17:39:55.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.538]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.538]         }
[17:39:55.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.538]             base::sink(type = "output", split = FALSE)
[17:39:55.538]             base::close(...future.stdout)
[17:39:55.538]         }, add = TRUE)
[17:39:55.538]     }
[17:39:55.538]     ...future.frame <- base::sys.nframe()
[17:39:55.538]     ...future.conditions <- base::list()
[17:39:55.538]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.538]     if (FALSE) {
[17:39:55.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.538]     }
[17:39:55.538]     ...future.result <- base::tryCatch({
[17:39:55.538]         base::withCallingHandlers({
[17:39:55.538]             ...future.value <- base::withVisible(base::local({
[17:39:55.538]                 b <- a
[17:39:55.538]                 a <- 2
[17:39:55.538]                 a * b
[17:39:55.538]             }))
[17:39:55.538]             future::FutureResult(value = ...future.value$value, 
[17:39:55.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.538]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.538]                     ...future.globalenv.names))
[17:39:55.538]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.538]         }, condition = base::local({
[17:39:55.538]             c <- base::c
[17:39:55.538]             inherits <- base::inherits
[17:39:55.538]             invokeRestart <- base::invokeRestart
[17:39:55.538]             length <- base::length
[17:39:55.538]             list <- base::list
[17:39:55.538]             seq.int <- base::seq.int
[17:39:55.538]             signalCondition <- base::signalCondition
[17:39:55.538]             sys.calls <- base::sys.calls
[17:39:55.538]             `[[` <- base::`[[`
[17:39:55.538]             `+` <- base::`+`
[17:39:55.538]             `<<-` <- base::`<<-`
[17:39:55.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.538]                   3L)]
[17:39:55.538]             }
[17:39:55.538]             function(cond) {
[17:39:55.538]                 is_error <- inherits(cond, "error")
[17:39:55.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.538]                   NULL)
[17:39:55.538]                 if (is_error) {
[17:39:55.538]                   sessionInformation <- function() {
[17:39:55.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.538]                       search = base::search(), system = base::Sys.info())
[17:39:55.538]                   }
[17:39:55.538]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.538]                     cond$call), session = sessionInformation(), 
[17:39:55.538]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.538]                   signalCondition(cond)
[17:39:55.538]                 }
[17:39:55.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.538]                 "immediateCondition"))) {
[17:39:55.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.538]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.538]                   if (TRUE && !signal) {
[17:39:55.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.538]                     {
[17:39:55.538]                       inherits <- base::inherits
[17:39:55.538]                       invokeRestart <- base::invokeRestart
[17:39:55.538]                       is.null <- base::is.null
[17:39:55.538]                       muffled <- FALSE
[17:39:55.538]                       if (inherits(cond, "message")) {
[17:39:55.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.538]                         if (muffled) 
[17:39:55.538]                           invokeRestart("muffleMessage")
[17:39:55.538]                       }
[17:39:55.538]                       else if (inherits(cond, "warning")) {
[17:39:55.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.538]                         if (muffled) 
[17:39:55.538]                           invokeRestart("muffleWarning")
[17:39:55.538]                       }
[17:39:55.538]                       else if (inherits(cond, "condition")) {
[17:39:55.538]                         if (!is.null(pattern)) {
[17:39:55.538]                           computeRestarts <- base::computeRestarts
[17:39:55.538]                           grepl <- base::grepl
[17:39:55.538]                           restarts <- computeRestarts(cond)
[17:39:55.538]                           for (restart in restarts) {
[17:39:55.538]                             name <- restart$name
[17:39:55.538]                             if (is.null(name)) 
[17:39:55.538]                               next
[17:39:55.538]                             if (!grepl(pattern, name)) 
[17:39:55.538]                               next
[17:39:55.538]                             invokeRestart(restart)
[17:39:55.538]                             muffled <- TRUE
[17:39:55.538]                             break
[17:39:55.538]                           }
[17:39:55.538]                         }
[17:39:55.538]                       }
[17:39:55.538]                       invisible(muffled)
[17:39:55.538]                     }
[17:39:55.538]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.538]                   }
[17:39:55.538]                 }
[17:39:55.538]                 else {
[17:39:55.538]                   if (TRUE) {
[17:39:55.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.538]                     {
[17:39:55.538]                       inherits <- base::inherits
[17:39:55.538]                       invokeRestart <- base::invokeRestart
[17:39:55.538]                       is.null <- base::is.null
[17:39:55.538]                       muffled <- FALSE
[17:39:55.538]                       if (inherits(cond, "message")) {
[17:39:55.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.538]                         if (muffled) 
[17:39:55.538]                           invokeRestart("muffleMessage")
[17:39:55.538]                       }
[17:39:55.538]                       else if (inherits(cond, "warning")) {
[17:39:55.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.538]                         if (muffled) 
[17:39:55.538]                           invokeRestart("muffleWarning")
[17:39:55.538]                       }
[17:39:55.538]                       else if (inherits(cond, "condition")) {
[17:39:55.538]                         if (!is.null(pattern)) {
[17:39:55.538]                           computeRestarts <- base::computeRestarts
[17:39:55.538]                           grepl <- base::grepl
[17:39:55.538]                           restarts <- computeRestarts(cond)
[17:39:55.538]                           for (restart in restarts) {
[17:39:55.538]                             name <- restart$name
[17:39:55.538]                             if (is.null(name)) 
[17:39:55.538]                               next
[17:39:55.538]                             if (!grepl(pattern, name)) 
[17:39:55.538]                               next
[17:39:55.538]                             invokeRestart(restart)
[17:39:55.538]                             muffled <- TRUE
[17:39:55.538]                             break
[17:39:55.538]                           }
[17:39:55.538]                         }
[17:39:55.538]                       }
[17:39:55.538]                       invisible(muffled)
[17:39:55.538]                     }
[17:39:55.538]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.538]                   }
[17:39:55.538]                 }
[17:39:55.538]             }
[17:39:55.538]         }))
[17:39:55.538]     }, error = function(ex) {
[17:39:55.538]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.538]                 ...future.rng), started = ...future.startTime, 
[17:39:55.538]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.538]             version = "1.8"), class = "FutureResult")
[17:39:55.538]     }, finally = {
[17:39:55.538]         if (!identical(...future.workdir, getwd())) 
[17:39:55.538]             setwd(...future.workdir)
[17:39:55.538]         {
[17:39:55.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.538]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.538]             }
[17:39:55.538]             base::options(...future.oldOptions)
[17:39:55.538]             if (.Platform$OS.type == "windows") {
[17:39:55.538]                 old_names <- names(...future.oldEnvVars)
[17:39:55.538]                 envs <- base::Sys.getenv()
[17:39:55.538]                 names <- names(envs)
[17:39:55.538]                 common <- intersect(names, old_names)
[17:39:55.538]                 added <- setdiff(names, old_names)
[17:39:55.538]                 removed <- setdiff(old_names, names)
[17:39:55.538]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.538]                   envs[common]]
[17:39:55.538]                 NAMES <- toupper(changed)
[17:39:55.538]                 args <- list()
[17:39:55.538]                 for (kk in seq_along(NAMES)) {
[17:39:55.538]                   name <- changed[[kk]]
[17:39:55.538]                   NAME <- NAMES[[kk]]
[17:39:55.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.538]                     next
[17:39:55.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.538]                 }
[17:39:55.538]                 NAMES <- toupper(added)
[17:39:55.538]                 for (kk in seq_along(NAMES)) {
[17:39:55.538]                   name <- added[[kk]]
[17:39:55.538]                   NAME <- NAMES[[kk]]
[17:39:55.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.538]                     next
[17:39:55.538]                   args[[name]] <- ""
[17:39:55.538]                 }
[17:39:55.538]                 NAMES <- toupper(removed)
[17:39:55.538]                 for (kk in seq_along(NAMES)) {
[17:39:55.538]                   name <- removed[[kk]]
[17:39:55.538]                   NAME <- NAMES[[kk]]
[17:39:55.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.538]                     next
[17:39:55.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.538]                 }
[17:39:55.538]                 if (length(args) > 0) 
[17:39:55.538]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.538]             }
[17:39:55.538]             else {
[17:39:55.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.538]             }
[17:39:55.538]             {
[17:39:55.538]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.538]                   0L) {
[17:39:55.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.538]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.538]                   base::options(opts)
[17:39:55.538]                 }
[17:39:55.538]                 {
[17:39:55.538]                   {
[17:39:55.538]                     NULL
[17:39:55.538]                     RNGkind("Mersenne-Twister")
[17:39:55.538]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.538]                       inherits = FALSE)
[17:39:55.538]                   }
[17:39:55.538]                   options(future.plan = NULL)
[17:39:55.538]                   if (is.na(NA_character_)) 
[17:39:55.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.538]                     .init = FALSE)
[17:39:55.538]                 }
[17:39:55.538]             }
[17:39:55.538]         }
[17:39:55.538]     })
[17:39:55.538]     if (TRUE) {
[17:39:55.538]         base::sink(type = "output", split = FALSE)
[17:39:55.538]         if (TRUE) {
[17:39:55.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.538]         }
[17:39:55.538]         else {
[17:39:55.538]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.538]         }
[17:39:55.538]         base::close(...future.stdout)
[17:39:55.538]         ...future.stdout <- NULL
[17:39:55.538]     }
[17:39:55.538]     ...future.result$conditions <- ...future.conditions
[17:39:55.538]     ...future.result$finished <- base::Sys.time()
[17:39:55.538]     ...future.result
[17:39:55.538] }
[17:39:55.540] plan(): Setting new future strategy stack:
[17:39:55.540] List of future strategies:
[17:39:55.540] 1. sequential:
[17:39:55.540]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.540]    - tweaked: FALSE
[17:39:55.540]    - call: NULL
[17:39:55.540] plan(): nbrOfWorkers() = 1
[17:39:55.541] plan(): Setting new future strategy stack:
[17:39:55.541] List of future strategies:
[17:39:55.541] 1. sequential:
[17:39:55.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.541]    - tweaked: FALSE
[17:39:55.541]    - call: plan(strategy)
[17:39:55.541] plan(): nbrOfWorkers() = 1
[17:39:55.542] SequentialFuture started (and completed)
[17:39:55.542] signalConditions() ...
[17:39:55.542]  - include = ‘immediateCondition’
[17:39:55.542]  - exclude = 
[17:39:55.542]  - resignal = FALSE
[17:39:55.542]  - Number of conditions: 1
[17:39:55.542] signalConditions() ... done
[17:39:55.542] - Launch lazy future ... done
[17:39:55.542] run() for ‘SequentialFuture’ ... done
[17:39:55.543] signalConditions() ...
[17:39:55.543]  - include = ‘immediateCondition’
[17:39:55.543]  - exclude = 
[17:39:55.543]  - resignal = FALSE
[17:39:55.543]  - Number of conditions: 1
[17:39:55.543] signalConditions() ... done
[17:39:55.543] Future state: ‘finished’
[17:39:55.543] signalConditions() ...
[17:39:55.543]  - include = ‘condition’
[17:39:55.545]  - exclude = ‘immediateCondition’
[17:39:55.545]  - resignal = TRUE
[17:39:55.545]  - Number of conditions: 1
[17:39:55.545]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:55.545] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:55"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.561] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.561] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.562] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.562] Searching for globals ... DONE
[17:39:55.562] Resolving globals: TRUE
[17:39:55.562] Resolving any globals that are futures ...
[17:39:55.562] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.562] Resolving any globals that are futures ... DONE
[17:39:55.563] Resolving futures part of globals (recursively) ...
[17:39:55.563] resolve() on list ...
[17:39:55.563]  recursive: 99
[17:39:55.564]  length: 1
[17:39:55.564]  elements: ‘ii’
[17:39:55.564]  length: 0 (resolved future 1)
[17:39:55.564] resolve() on list ... DONE
[17:39:55.564] - globals: [1] ‘ii’
[17:39:55.564] Resolving futures part of globals (recursively) ... DONE
[17:39:55.565] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.565] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.565] - globals: [1] ‘ii’
[17:39:55.565] 
[17:39:55.565] getGlobalsAndPackages() ... DONE
[17:39:55.566] run() for ‘Future’ ...
[17:39:55.566] - state: ‘created’
[17:39:55.566] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.566] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.566] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.566]   - Field: ‘label’
[17:39:55.566]   - Field: ‘local’
[17:39:55.567]   - Field: ‘owner’
[17:39:55.567]   - Field: ‘envir’
[17:39:55.567]   - Field: ‘packages’
[17:39:55.567]   - Field: ‘gc’
[17:39:55.567]   - Field: ‘conditions’
[17:39:55.567]   - Field: ‘expr’
[17:39:55.567]   - Field: ‘uuid’
[17:39:55.567]   - Field: ‘seed’
[17:39:55.567]   - Field: ‘version’
[17:39:55.567]   - Field: ‘result’
[17:39:55.567]   - Field: ‘asynchronous’
[17:39:55.567]   - Field: ‘calls’
[17:39:55.568]   - Field: ‘globals’
[17:39:55.568]   - Field: ‘stdout’
[17:39:55.568]   - Field: ‘earlySignal’
[17:39:55.568]   - Field: ‘lazy’
[17:39:55.568]   - Field: ‘state’
[17:39:55.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.568] - Launch lazy future ...
[17:39:55.568] Packages needed by the future expression (n = 0): <none>
[17:39:55.568] Packages needed by future strategies (n = 0): <none>
[17:39:55.569] {
[17:39:55.569]     {
[17:39:55.569]         {
[17:39:55.569]             ...future.startTime <- base::Sys.time()
[17:39:55.569]             {
[17:39:55.569]                 {
[17:39:55.569]                   {
[17:39:55.569]                     base::local({
[17:39:55.569]                       has_future <- base::requireNamespace("future", 
[17:39:55.569]                         quietly = TRUE)
[17:39:55.569]                       if (has_future) {
[17:39:55.569]                         ns <- base::getNamespace("future")
[17:39:55.569]                         version <- ns[[".package"]][["version"]]
[17:39:55.569]                         if (is.null(version)) 
[17:39:55.569]                           version <- utils::packageVersion("future")
[17:39:55.569]                       }
[17:39:55.569]                       else {
[17:39:55.569]                         version <- NULL
[17:39:55.569]                       }
[17:39:55.569]                       if (!has_future || version < "1.8.0") {
[17:39:55.569]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.569]                           "", base::R.version$version.string), 
[17:39:55.569]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.569]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.569]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.569]                             "release", "version")], collapse = " "), 
[17:39:55.569]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.569]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.569]                           info)
[17:39:55.569]                         info <- base::paste(info, collapse = "; ")
[17:39:55.569]                         if (!has_future) {
[17:39:55.569]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.569]                             info)
[17:39:55.569]                         }
[17:39:55.569]                         else {
[17:39:55.569]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.569]                             info, version)
[17:39:55.569]                         }
[17:39:55.569]                         base::stop(msg)
[17:39:55.569]                       }
[17:39:55.569]                     })
[17:39:55.569]                   }
[17:39:55.569]                   ...future.strategy.old <- future::plan("list")
[17:39:55.569]                   options(future.plan = NULL)
[17:39:55.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.569]                 }
[17:39:55.569]                 ...future.workdir <- getwd()
[17:39:55.569]             }
[17:39:55.569]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.569]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.569]         }
[17:39:55.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.569]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.569]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.569]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.569]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.569]             base::names(...future.oldOptions))
[17:39:55.569]     }
[17:39:55.569]     if (FALSE) {
[17:39:55.569]     }
[17:39:55.569]     else {
[17:39:55.569]         if (TRUE) {
[17:39:55.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.569]                 open = "w")
[17:39:55.569]         }
[17:39:55.569]         else {
[17:39:55.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.569]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.569]         }
[17:39:55.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.569]             base::sink(type = "output", split = FALSE)
[17:39:55.569]             base::close(...future.stdout)
[17:39:55.569]         }, add = TRUE)
[17:39:55.569]     }
[17:39:55.569]     ...future.frame <- base::sys.nframe()
[17:39:55.569]     ...future.conditions <- base::list()
[17:39:55.569]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.569]     if (FALSE) {
[17:39:55.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.569]     }
[17:39:55.569]     ...future.result <- base::tryCatch({
[17:39:55.569]         base::withCallingHandlers({
[17:39:55.569]             ...future.value <- base::withVisible(base::local({
[17:39:55.569]                 b <- a * ii
[17:39:55.569]                 a <- 0
[17:39:55.569]                 b
[17:39:55.569]             }))
[17:39:55.569]             future::FutureResult(value = ...future.value$value, 
[17:39:55.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.569]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.569]                     ...future.globalenv.names))
[17:39:55.569]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.569]         }, condition = base::local({
[17:39:55.569]             c <- base::c
[17:39:55.569]             inherits <- base::inherits
[17:39:55.569]             invokeRestart <- base::invokeRestart
[17:39:55.569]             length <- base::length
[17:39:55.569]             list <- base::list
[17:39:55.569]             seq.int <- base::seq.int
[17:39:55.569]             signalCondition <- base::signalCondition
[17:39:55.569]             sys.calls <- base::sys.calls
[17:39:55.569]             `[[` <- base::`[[`
[17:39:55.569]             `+` <- base::`+`
[17:39:55.569]             `<<-` <- base::`<<-`
[17:39:55.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.569]                   3L)]
[17:39:55.569]             }
[17:39:55.569]             function(cond) {
[17:39:55.569]                 is_error <- inherits(cond, "error")
[17:39:55.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.569]                   NULL)
[17:39:55.569]                 if (is_error) {
[17:39:55.569]                   sessionInformation <- function() {
[17:39:55.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.569]                       search = base::search(), system = base::Sys.info())
[17:39:55.569]                   }
[17:39:55.569]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.569]                     cond$call), session = sessionInformation(), 
[17:39:55.569]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.569]                   signalCondition(cond)
[17:39:55.569]                 }
[17:39:55.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.569]                 "immediateCondition"))) {
[17:39:55.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.569]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.569]                   if (TRUE && !signal) {
[17:39:55.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.569]                     {
[17:39:55.569]                       inherits <- base::inherits
[17:39:55.569]                       invokeRestart <- base::invokeRestart
[17:39:55.569]                       is.null <- base::is.null
[17:39:55.569]                       muffled <- FALSE
[17:39:55.569]                       if (inherits(cond, "message")) {
[17:39:55.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.569]                         if (muffled) 
[17:39:55.569]                           invokeRestart("muffleMessage")
[17:39:55.569]                       }
[17:39:55.569]                       else if (inherits(cond, "warning")) {
[17:39:55.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.569]                         if (muffled) 
[17:39:55.569]                           invokeRestart("muffleWarning")
[17:39:55.569]                       }
[17:39:55.569]                       else if (inherits(cond, "condition")) {
[17:39:55.569]                         if (!is.null(pattern)) {
[17:39:55.569]                           computeRestarts <- base::computeRestarts
[17:39:55.569]                           grepl <- base::grepl
[17:39:55.569]                           restarts <- computeRestarts(cond)
[17:39:55.569]                           for (restart in restarts) {
[17:39:55.569]                             name <- restart$name
[17:39:55.569]                             if (is.null(name)) 
[17:39:55.569]                               next
[17:39:55.569]                             if (!grepl(pattern, name)) 
[17:39:55.569]                               next
[17:39:55.569]                             invokeRestart(restart)
[17:39:55.569]                             muffled <- TRUE
[17:39:55.569]                             break
[17:39:55.569]                           }
[17:39:55.569]                         }
[17:39:55.569]                       }
[17:39:55.569]                       invisible(muffled)
[17:39:55.569]                     }
[17:39:55.569]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.569]                   }
[17:39:55.569]                 }
[17:39:55.569]                 else {
[17:39:55.569]                   if (TRUE) {
[17:39:55.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.569]                     {
[17:39:55.569]                       inherits <- base::inherits
[17:39:55.569]                       invokeRestart <- base::invokeRestart
[17:39:55.569]                       is.null <- base::is.null
[17:39:55.569]                       muffled <- FALSE
[17:39:55.569]                       if (inherits(cond, "message")) {
[17:39:55.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.569]                         if (muffled) 
[17:39:55.569]                           invokeRestart("muffleMessage")
[17:39:55.569]                       }
[17:39:55.569]                       else if (inherits(cond, "warning")) {
[17:39:55.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.569]                         if (muffled) 
[17:39:55.569]                           invokeRestart("muffleWarning")
[17:39:55.569]                       }
[17:39:55.569]                       else if (inherits(cond, "condition")) {
[17:39:55.569]                         if (!is.null(pattern)) {
[17:39:55.569]                           computeRestarts <- base::computeRestarts
[17:39:55.569]                           grepl <- base::grepl
[17:39:55.569]                           restarts <- computeRestarts(cond)
[17:39:55.569]                           for (restart in restarts) {
[17:39:55.569]                             name <- restart$name
[17:39:55.569]                             if (is.null(name)) 
[17:39:55.569]                               next
[17:39:55.569]                             if (!grepl(pattern, name)) 
[17:39:55.569]                               next
[17:39:55.569]                             invokeRestart(restart)
[17:39:55.569]                             muffled <- TRUE
[17:39:55.569]                             break
[17:39:55.569]                           }
[17:39:55.569]                         }
[17:39:55.569]                       }
[17:39:55.569]                       invisible(muffled)
[17:39:55.569]                     }
[17:39:55.569]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.569]                   }
[17:39:55.569]                 }
[17:39:55.569]             }
[17:39:55.569]         }))
[17:39:55.569]     }, error = function(ex) {
[17:39:55.569]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.569]                 ...future.rng), started = ...future.startTime, 
[17:39:55.569]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.569]             version = "1.8"), class = "FutureResult")
[17:39:55.569]     }, finally = {
[17:39:55.569]         if (!identical(...future.workdir, getwd())) 
[17:39:55.569]             setwd(...future.workdir)
[17:39:55.569]         {
[17:39:55.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.569]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.569]             }
[17:39:55.569]             base::options(...future.oldOptions)
[17:39:55.569]             if (.Platform$OS.type == "windows") {
[17:39:55.569]                 old_names <- names(...future.oldEnvVars)
[17:39:55.569]                 envs <- base::Sys.getenv()
[17:39:55.569]                 names <- names(envs)
[17:39:55.569]                 common <- intersect(names, old_names)
[17:39:55.569]                 added <- setdiff(names, old_names)
[17:39:55.569]                 removed <- setdiff(old_names, names)
[17:39:55.569]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.569]                   envs[common]]
[17:39:55.569]                 NAMES <- toupper(changed)
[17:39:55.569]                 args <- list()
[17:39:55.569]                 for (kk in seq_along(NAMES)) {
[17:39:55.569]                   name <- changed[[kk]]
[17:39:55.569]                   NAME <- NAMES[[kk]]
[17:39:55.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.569]                     next
[17:39:55.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.569]                 }
[17:39:55.569]                 NAMES <- toupper(added)
[17:39:55.569]                 for (kk in seq_along(NAMES)) {
[17:39:55.569]                   name <- added[[kk]]
[17:39:55.569]                   NAME <- NAMES[[kk]]
[17:39:55.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.569]                     next
[17:39:55.569]                   args[[name]] <- ""
[17:39:55.569]                 }
[17:39:55.569]                 NAMES <- toupper(removed)
[17:39:55.569]                 for (kk in seq_along(NAMES)) {
[17:39:55.569]                   name <- removed[[kk]]
[17:39:55.569]                   NAME <- NAMES[[kk]]
[17:39:55.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.569]                     next
[17:39:55.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.569]                 }
[17:39:55.569]                 if (length(args) > 0) 
[17:39:55.569]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.569]             }
[17:39:55.569]             else {
[17:39:55.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.569]             }
[17:39:55.569]             {
[17:39:55.569]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.569]                   0L) {
[17:39:55.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.569]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.569]                   base::options(opts)
[17:39:55.569]                 }
[17:39:55.569]                 {
[17:39:55.569]                   {
[17:39:55.569]                     NULL
[17:39:55.569]                     RNGkind("Mersenne-Twister")
[17:39:55.569]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.569]                       inherits = FALSE)
[17:39:55.569]                   }
[17:39:55.569]                   options(future.plan = NULL)
[17:39:55.569]                   if (is.na(NA_character_)) 
[17:39:55.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.569]                     .init = FALSE)
[17:39:55.569]                 }
[17:39:55.569]             }
[17:39:55.569]         }
[17:39:55.569]     })
[17:39:55.569]     if (TRUE) {
[17:39:55.569]         base::sink(type = "output", split = FALSE)
[17:39:55.569]         if (TRUE) {
[17:39:55.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.569]         }
[17:39:55.569]         else {
[17:39:55.569]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.569]         }
[17:39:55.569]         base::close(...future.stdout)
[17:39:55.569]         ...future.stdout <- NULL
[17:39:55.569]     }
[17:39:55.569]     ...future.result$conditions <- ...future.conditions
[17:39:55.569]     ...future.result$finished <- base::Sys.time()
[17:39:55.569]     ...future.result
[17:39:55.569] }
[17:39:55.570] assign_globals() ...
[17:39:55.570] List of 1
[17:39:55.570]  $ ii: int 1
[17:39:55.570]  - attr(*, "where")=List of 1
[17:39:55.570]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.570]  - attr(*, "resolved")= logi TRUE
[17:39:55.570]  - attr(*, "total_size")= num 56
[17:39:55.570]  - attr(*, "already-done")= logi TRUE
[17:39:55.573] - copied ‘ii’ to environment
[17:39:55.573] assign_globals() ... done
[17:39:55.573] plan(): Setting new future strategy stack:
[17:39:55.573] List of future strategies:
[17:39:55.573] 1. sequential:
[17:39:55.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.573]    - tweaked: FALSE
[17:39:55.573]    - call: NULL
[17:39:55.575] plan(): nbrOfWorkers() = 1
[17:39:55.576] plan(): Setting new future strategy stack:
[17:39:55.576] List of future strategies:
[17:39:55.576] 1. sequential:
[17:39:55.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.576]    - tweaked: FALSE
[17:39:55.576]    - call: plan(strategy)
[17:39:55.576] plan(): nbrOfWorkers() = 1
[17:39:55.576] SequentialFuture started (and completed)
[17:39:55.576] - Launch lazy future ... done
[17:39:55.577] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.577] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.577] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.578] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.578] Searching for globals ... DONE
[17:39:55.579] Resolving globals: TRUE
[17:39:55.579] Resolving any globals that are futures ...
[17:39:55.579] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.579] Resolving any globals that are futures ... DONE
[17:39:55.579] Resolving futures part of globals (recursively) ...
[17:39:55.579] resolve() on list ...
[17:39:55.579]  recursive: 99
[17:39:55.580]  length: 1
[17:39:55.580]  elements: ‘ii’
[17:39:55.580]  length: 0 (resolved future 1)
[17:39:55.580] resolve() on list ... DONE
[17:39:55.580] - globals: [1] ‘ii’
[17:39:55.580] Resolving futures part of globals (recursively) ... DONE
[17:39:55.580] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.580] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.581] - globals: [1] ‘ii’
[17:39:55.581] 
[17:39:55.581] getGlobalsAndPackages() ... DONE
[17:39:55.581] run() for ‘Future’ ...
[17:39:55.581] - state: ‘created’
[17:39:55.581] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.581] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.582]   - Field: ‘label’
[17:39:55.582]   - Field: ‘local’
[17:39:55.582]   - Field: ‘owner’
[17:39:55.582]   - Field: ‘envir’
[17:39:55.582]   - Field: ‘packages’
[17:39:55.582]   - Field: ‘gc’
[17:39:55.582]   - Field: ‘conditions’
[17:39:55.582]   - Field: ‘expr’
[17:39:55.582]   - Field: ‘uuid’
[17:39:55.582]   - Field: ‘seed’
[17:39:55.582]   - Field: ‘version’
[17:39:55.583]   - Field: ‘result’
[17:39:55.583]   - Field: ‘asynchronous’
[17:39:55.583]   - Field: ‘calls’
[17:39:55.583]   - Field: ‘globals’
[17:39:55.583]   - Field: ‘stdout’
[17:39:55.583]   - Field: ‘earlySignal’
[17:39:55.583]   - Field: ‘lazy’
[17:39:55.583]   - Field: ‘state’
[17:39:55.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.583] - Launch lazy future ...
[17:39:55.583] Packages needed by the future expression (n = 0): <none>
[17:39:55.584] Packages needed by future strategies (n = 0): <none>
[17:39:55.584] {
[17:39:55.584]     {
[17:39:55.584]         {
[17:39:55.584]             ...future.startTime <- base::Sys.time()
[17:39:55.584]             {
[17:39:55.584]                 {
[17:39:55.584]                   {
[17:39:55.584]                     base::local({
[17:39:55.584]                       has_future <- base::requireNamespace("future", 
[17:39:55.584]                         quietly = TRUE)
[17:39:55.584]                       if (has_future) {
[17:39:55.584]                         ns <- base::getNamespace("future")
[17:39:55.584]                         version <- ns[[".package"]][["version"]]
[17:39:55.584]                         if (is.null(version)) 
[17:39:55.584]                           version <- utils::packageVersion("future")
[17:39:55.584]                       }
[17:39:55.584]                       else {
[17:39:55.584]                         version <- NULL
[17:39:55.584]                       }
[17:39:55.584]                       if (!has_future || version < "1.8.0") {
[17:39:55.584]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.584]                           "", base::R.version$version.string), 
[17:39:55.584]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.584]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.584]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.584]                             "release", "version")], collapse = " "), 
[17:39:55.584]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.584]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.584]                           info)
[17:39:55.584]                         info <- base::paste(info, collapse = "; ")
[17:39:55.584]                         if (!has_future) {
[17:39:55.584]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.584]                             info)
[17:39:55.584]                         }
[17:39:55.584]                         else {
[17:39:55.584]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.584]                             info, version)
[17:39:55.584]                         }
[17:39:55.584]                         base::stop(msg)
[17:39:55.584]                       }
[17:39:55.584]                     })
[17:39:55.584]                   }
[17:39:55.584]                   ...future.strategy.old <- future::plan("list")
[17:39:55.584]                   options(future.plan = NULL)
[17:39:55.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.584]                 }
[17:39:55.584]                 ...future.workdir <- getwd()
[17:39:55.584]             }
[17:39:55.584]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.584]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.584]         }
[17:39:55.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.584]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.584]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.584]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.584]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.584]             base::names(...future.oldOptions))
[17:39:55.584]     }
[17:39:55.584]     if (FALSE) {
[17:39:55.584]     }
[17:39:55.584]     else {
[17:39:55.584]         if (TRUE) {
[17:39:55.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.584]                 open = "w")
[17:39:55.584]         }
[17:39:55.584]         else {
[17:39:55.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.584]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.584]         }
[17:39:55.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.584]             base::sink(type = "output", split = FALSE)
[17:39:55.584]             base::close(...future.stdout)
[17:39:55.584]         }, add = TRUE)
[17:39:55.584]     }
[17:39:55.584]     ...future.frame <- base::sys.nframe()
[17:39:55.584]     ...future.conditions <- base::list()
[17:39:55.584]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.584]     if (FALSE) {
[17:39:55.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.584]     }
[17:39:55.584]     ...future.result <- base::tryCatch({
[17:39:55.584]         base::withCallingHandlers({
[17:39:55.584]             ...future.value <- base::withVisible(base::local({
[17:39:55.584]                 b <- a * ii
[17:39:55.584]                 a <- 0
[17:39:55.584]                 b
[17:39:55.584]             }))
[17:39:55.584]             future::FutureResult(value = ...future.value$value, 
[17:39:55.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.584]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.584]                     ...future.globalenv.names))
[17:39:55.584]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.584]         }, condition = base::local({
[17:39:55.584]             c <- base::c
[17:39:55.584]             inherits <- base::inherits
[17:39:55.584]             invokeRestart <- base::invokeRestart
[17:39:55.584]             length <- base::length
[17:39:55.584]             list <- base::list
[17:39:55.584]             seq.int <- base::seq.int
[17:39:55.584]             signalCondition <- base::signalCondition
[17:39:55.584]             sys.calls <- base::sys.calls
[17:39:55.584]             `[[` <- base::`[[`
[17:39:55.584]             `+` <- base::`+`
[17:39:55.584]             `<<-` <- base::`<<-`
[17:39:55.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.584]                   3L)]
[17:39:55.584]             }
[17:39:55.584]             function(cond) {
[17:39:55.584]                 is_error <- inherits(cond, "error")
[17:39:55.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.584]                   NULL)
[17:39:55.584]                 if (is_error) {
[17:39:55.584]                   sessionInformation <- function() {
[17:39:55.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.584]                       search = base::search(), system = base::Sys.info())
[17:39:55.584]                   }
[17:39:55.584]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.584]                     cond$call), session = sessionInformation(), 
[17:39:55.584]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.584]                   signalCondition(cond)
[17:39:55.584]                 }
[17:39:55.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.584]                 "immediateCondition"))) {
[17:39:55.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.584]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.584]                   if (TRUE && !signal) {
[17:39:55.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.584]                     {
[17:39:55.584]                       inherits <- base::inherits
[17:39:55.584]                       invokeRestart <- base::invokeRestart
[17:39:55.584]                       is.null <- base::is.null
[17:39:55.584]                       muffled <- FALSE
[17:39:55.584]                       if (inherits(cond, "message")) {
[17:39:55.584]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.584]                         if (muffled) 
[17:39:55.584]                           invokeRestart("muffleMessage")
[17:39:55.584]                       }
[17:39:55.584]                       else if (inherits(cond, "warning")) {
[17:39:55.584]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.584]                         if (muffled) 
[17:39:55.584]                           invokeRestart("muffleWarning")
[17:39:55.584]                       }
[17:39:55.584]                       else if (inherits(cond, "condition")) {
[17:39:55.584]                         if (!is.null(pattern)) {
[17:39:55.584]                           computeRestarts <- base::computeRestarts
[17:39:55.584]                           grepl <- base::grepl
[17:39:55.584]                           restarts <- computeRestarts(cond)
[17:39:55.584]                           for (restart in restarts) {
[17:39:55.584]                             name <- restart$name
[17:39:55.584]                             if (is.null(name)) 
[17:39:55.584]                               next
[17:39:55.584]                             if (!grepl(pattern, name)) 
[17:39:55.584]                               next
[17:39:55.584]                             invokeRestart(restart)
[17:39:55.584]                             muffled <- TRUE
[17:39:55.584]                             break
[17:39:55.584]                           }
[17:39:55.584]                         }
[17:39:55.584]                       }
[17:39:55.584]                       invisible(muffled)
[17:39:55.584]                     }
[17:39:55.584]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.584]                   }
[17:39:55.584]                 }
[17:39:55.584]                 else {
[17:39:55.584]                   if (TRUE) {
[17:39:55.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.584]                     {
[17:39:55.584]                       inherits <- base::inherits
[17:39:55.584]                       invokeRestart <- base::invokeRestart
[17:39:55.584]                       is.null <- base::is.null
[17:39:55.584]                       muffled <- FALSE
[17:39:55.584]                       if (inherits(cond, "message")) {
[17:39:55.584]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.584]                         if (muffled) 
[17:39:55.584]                           invokeRestart("muffleMessage")
[17:39:55.584]                       }
[17:39:55.584]                       else if (inherits(cond, "warning")) {
[17:39:55.584]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.584]                         if (muffled) 
[17:39:55.584]                           invokeRestart("muffleWarning")
[17:39:55.584]                       }
[17:39:55.584]                       else if (inherits(cond, "condition")) {
[17:39:55.584]                         if (!is.null(pattern)) {
[17:39:55.584]                           computeRestarts <- base::computeRestarts
[17:39:55.584]                           grepl <- base::grepl
[17:39:55.584]                           restarts <- computeRestarts(cond)
[17:39:55.584]                           for (restart in restarts) {
[17:39:55.584]                             name <- restart$name
[17:39:55.584]                             if (is.null(name)) 
[17:39:55.584]                               next
[17:39:55.584]                             if (!grepl(pattern, name)) 
[17:39:55.584]                               next
[17:39:55.584]                             invokeRestart(restart)
[17:39:55.584]                             muffled <- TRUE
[17:39:55.584]                             break
[17:39:55.584]                           }
[17:39:55.584]                         }
[17:39:55.584]                       }
[17:39:55.584]                       invisible(muffled)
[17:39:55.584]                     }
[17:39:55.584]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.584]                   }
[17:39:55.584]                 }
[17:39:55.584]             }
[17:39:55.584]         }))
[17:39:55.584]     }, error = function(ex) {
[17:39:55.584]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.584]                 ...future.rng), started = ...future.startTime, 
[17:39:55.584]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.584]             version = "1.8"), class = "FutureResult")
[17:39:55.584]     }, finally = {
[17:39:55.584]         if (!identical(...future.workdir, getwd())) 
[17:39:55.584]             setwd(...future.workdir)
[17:39:55.584]         {
[17:39:55.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.584]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.584]             }
[17:39:55.584]             base::options(...future.oldOptions)
[17:39:55.584]             if (.Platform$OS.type == "windows") {
[17:39:55.584]                 old_names <- names(...future.oldEnvVars)
[17:39:55.584]                 envs <- base::Sys.getenv()
[17:39:55.584]                 names <- names(envs)
[17:39:55.584]                 common <- intersect(names, old_names)
[17:39:55.584]                 added <- setdiff(names, old_names)
[17:39:55.584]                 removed <- setdiff(old_names, names)
[17:39:55.584]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.584]                   envs[common]]
[17:39:55.584]                 NAMES <- toupper(changed)
[17:39:55.584]                 args <- list()
[17:39:55.584]                 for (kk in seq_along(NAMES)) {
[17:39:55.584]                   name <- changed[[kk]]
[17:39:55.584]                   NAME <- NAMES[[kk]]
[17:39:55.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.584]                     next
[17:39:55.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.584]                 }
[17:39:55.584]                 NAMES <- toupper(added)
[17:39:55.584]                 for (kk in seq_along(NAMES)) {
[17:39:55.584]                   name <- added[[kk]]
[17:39:55.584]                   NAME <- NAMES[[kk]]
[17:39:55.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.584]                     next
[17:39:55.584]                   args[[name]] <- ""
[17:39:55.584]                 }
[17:39:55.584]                 NAMES <- toupper(removed)
[17:39:55.584]                 for (kk in seq_along(NAMES)) {
[17:39:55.584]                   name <- removed[[kk]]
[17:39:55.584]                   NAME <- NAMES[[kk]]
[17:39:55.584]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.584]                     next
[17:39:55.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.584]                 }
[17:39:55.584]                 if (length(args) > 0) 
[17:39:55.584]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.584]             }
[17:39:55.584]             else {
[17:39:55.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.584]             }
[17:39:55.584]             {
[17:39:55.584]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.584]                   0L) {
[17:39:55.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.584]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.584]                   base::options(opts)
[17:39:55.584]                 }
[17:39:55.584]                 {
[17:39:55.584]                   {
[17:39:55.584]                     NULL
[17:39:55.584]                     RNGkind("Mersenne-Twister")
[17:39:55.584]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.584]                       inherits = FALSE)
[17:39:55.584]                   }
[17:39:55.584]                   options(future.plan = NULL)
[17:39:55.584]                   if (is.na(NA_character_)) 
[17:39:55.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.584]                     .init = FALSE)
[17:39:55.584]                 }
[17:39:55.584]             }
[17:39:55.584]         }
[17:39:55.584]     })
[17:39:55.584]     if (TRUE) {
[17:39:55.584]         base::sink(type = "output", split = FALSE)
[17:39:55.584]         if (TRUE) {
[17:39:55.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.584]         }
[17:39:55.584]         else {
[17:39:55.584]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.584]         }
[17:39:55.584]         base::close(...future.stdout)
[17:39:55.584]         ...future.stdout <- NULL
[17:39:55.584]     }
[17:39:55.584]     ...future.result$conditions <- ...future.conditions
[17:39:55.584]     ...future.result$finished <- base::Sys.time()
[17:39:55.584]     ...future.result
[17:39:55.584] }
[17:39:55.585] assign_globals() ...
[17:39:55.586] List of 1
[17:39:55.586]  $ ii: int 2
[17:39:55.586]  - attr(*, "where")=List of 1
[17:39:55.586]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.586]  - attr(*, "resolved")= logi TRUE
[17:39:55.586]  - attr(*, "total_size")= num 56
[17:39:55.586]  - attr(*, "already-done")= logi TRUE
[17:39:55.588] - copied ‘ii’ to environment
[17:39:55.588] assign_globals() ... done
[17:39:55.588] plan(): Setting new future strategy stack:
[17:39:55.588] List of future strategies:
[17:39:55.588] 1. sequential:
[17:39:55.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.588]    - tweaked: FALSE
[17:39:55.588]    - call: NULL
[17:39:55.589] plan(): nbrOfWorkers() = 1
[17:39:55.589] plan(): Setting new future strategy stack:
[17:39:55.589] List of future strategies:
[17:39:55.589] 1. sequential:
[17:39:55.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.589]    - tweaked: FALSE
[17:39:55.589]    - call: plan(strategy)
[17:39:55.590] plan(): nbrOfWorkers() = 1
[17:39:55.590] SequentialFuture started (and completed)
[17:39:55.590] - Launch lazy future ... done
[17:39:55.590] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.591] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.591] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.592] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.592] Searching for globals ... DONE
[17:39:55.592] Resolving globals: TRUE
[17:39:55.592] Resolving any globals that are futures ...
[17:39:55.592] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.592] Resolving any globals that are futures ... DONE
[17:39:55.593] Resolving futures part of globals (recursively) ...
[17:39:55.593] resolve() on list ...
[17:39:55.593]  recursive: 99
[17:39:55.593]  length: 1
[17:39:55.593]  elements: ‘ii’
[17:39:55.593]  length: 0 (resolved future 1)
[17:39:55.593] resolve() on list ... DONE
[17:39:55.593] - globals: [1] ‘ii’
[17:39:55.594] Resolving futures part of globals (recursively) ... DONE
[17:39:55.594] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.594] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.594] - globals: [1] ‘ii’
[17:39:55.594] 
[17:39:55.594] getGlobalsAndPackages() ... DONE
[17:39:55.594] run() for ‘Future’ ...
[17:39:55.595] - state: ‘created’
[17:39:55.595] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.595]   - Field: ‘label’
[17:39:55.595]   - Field: ‘local’
[17:39:55.595]   - Field: ‘owner’
[17:39:55.595]   - Field: ‘envir’
[17:39:55.595]   - Field: ‘packages’
[17:39:55.595]   - Field: ‘gc’
[17:39:55.596]   - Field: ‘conditions’
[17:39:55.596]   - Field: ‘expr’
[17:39:55.596]   - Field: ‘uuid’
[17:39:55.596]   - Field: ‘seed’
[17:39:55.596]   - Field: ‘version’
[17:39:55.596]   - Field: ‘result’
[17:39:55.596]   - Field: ‘asynchronous’
[17:39:55.596]   - Field: ‘calls’
[17:39:55.596]   - Field: ‘globals’
[17:39:55.596]   - Field: ‘stdout’
[17:39:55.596]   - Field: ‘earlySignal’
[17:39:55.597]   - Field: ‘lazy’
[17:39:55.597]   - Field: ‘state’
[17:39:55.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.597] - Launch lazy future ...
[17:39:55.597] Packages needed by the future expression (n = 0): <none>
[17:39:55.597] Packages needed by future strategies (n = 0): <none>
[17:39:55.597] {
[17:39:55.597]     {
[17:39:55.597]         {
[17:39:55.597]             ...future.startTime <- base::Sys.time()
[17:39:55.597]             {
[17:39:55.597]                 {
[17:39:55.597]                   {
[17:39:55.597]                     base::local({
[17:39:55.597]                       has_future <- base::requireNamespace("future", 
[17:39:55.597]                         quietly = TRUE)
[17:39:55.597]                       if (has_future) {
[17:39:55.597]                         ns <- base::getNamespace("future")
[17:39:55.597]                         version <- ns[[".package"]][["version"]]
[17:39:55.597]                         if (is.null(version)) 
[17:39:55.597]                           version <- utils::packageVersion("future")
[17:39:55.597]                       }
[17:39:55.597]                       else {
[17:39:55.597]                         version <- NULL
[17:39:55.597]                       }
[17:39:55.597]                       if (!has_future || version < "1.8.0") {
[17:39:55.597]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.597]                           "", base::R.version$version.string), 
[17:39:55.597]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.597]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.597]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.597]                             "release", "version")], collapse = " "), 
[17:39:55.597]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.597]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.597]                           info)
[17:39:55.597]                         info <- base::paste(info, collapse = "; ")
[17:39:55.597]                         if (!has_future) {
[17:39:55.597]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.597]                             info)
[17:39:55.597]                         }
[17:39:55.597]                         else {
[17:39:55.597]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.597]                             info, version)
[17:39:55.597]                         }
[17:39:55.597]                         base::stop(msg)
[17:39:55.597]                       }
[17:39:55.597]                     })
[17:39:55.597]                   }
[17:39:55.597]                   ...future.strategy.old <- future::plan("list")
[17:39:55.597]                   options(future.plan = NULL)
[17:39:55.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.597]                 }
[17:39:55.597]                 ...future.workdir <- getwd()
[17:39:55.597]             }
[17:39:55.597]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.597]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.597]         }
[17:39:55.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.597]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.597]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.597]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.597]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.597]             base::names(...future.oldOptions))
[17:39:55.597]     }
[17:39:55.597]     if (FALSE) {
[17:39:55.597]     }
[17:39:55.597]     else {
[17:39:55.597]         if (TRUE) {
[17:39:55.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.597]                 open = "w")
[17:39:55.597]         }
[17:39:55.597]         else {
[17:39:55.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.597]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.597]         }
[17:39:55.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.597]             base::sink(type = "output", split = FALSE)
[17:39:55.597]             base::close(...future.stdout)
[17:39:55.597]         }, add = TRUE)
[17:39:55.597]     }
[17:39:55.597]     ...future.frame <- base::sys.nframe()
[17:39:55.597]     ...future.conditions <- base::list()
[17:39:55.597]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.597]     if (FALSE) {
[17:39:55.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.597]     }
[17:39:55.597]     ...future.result <- base::tryCatch({
[17:39:55.597]         base::withCallingHandlers({
[17:39:55.597]             ...future.value <- base::withVisible(base::local({
[17:39:55.597]                 b <- a * ii
[17:39:55.597]                 a <- 0
[17:39:55.597]                 b
[17:39:55.597]             }))
[17:39:55.597]             future::FutureResult(value = ...future.value$value, 
[17:39:55.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.597]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.597]                     ...future.globalenv.names))
[17:39:55.597]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.597]         }, condition = base::local({
[17:39:55.597]             c <- base::c
[17:39:55.597]             inherits <- base::inherits
[17:39:55.597]             invokeRestart <- base::invokeRestart
[17:39:55.597]             length <- base::length
[17:39:55.597]             list <- base::list
[17:39:55.597]             seq.int <- base::seq.int
[17:39:55.597]             signalCondition <- base::signalCondition
[17:39:55.597]             sys.calls <- base::sys.calls
[17:39:55.597]             `[[` <- base::`[[`
[17:39:55.597]             `+` <- base::`+`
[17:39:55.597]             `<<-` <- base::`<<-`
[17:39:55.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.597]                   3L)]
[17:39:55.597]             }
[17:39:55.597]             function(cond) {
[17:39:55.597]                 is_error <- inherits(cond, "error")
[17:39:55.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.597]                   NULL)
[17:39:55.597]                 if (is_error) {
[17:39:55.597]                   sessionInformation <- function() {
[17:39:55.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.597]                       search = base::search(), system = base::Sys.info())
[17:39:55.597]                   }
[17:39:55.597]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.597]                     cond$call), session = sessionInformation(), 
[17:39:55.597]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.597]                   signalCondition(cond)
[17:39:55.597]                 }
[17:39:55.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.597]                 "immediateCondition"))) {
[17:39:55.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.597]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.597]                   if (TRUE && !signal) {
[17:39:55.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.597]                     {
[17:39:55.597]                       inherits <- base::inherits
[17:39:55.597]                       invokeRestart <- base::invokeRestart
[17:39:55.597]                       is.null <- base::is.null
[17:39:55.597]                       muffled <- FALSE
[17:39:55.597]                       if (inherits(cond, "message")) {
[17:39:55.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.597]                         if (muffled) 
[17:39:55.597]                           invokeRestart("muffleMessage")
[17:39:55.597]                       }
[17:39:55.597]                       else if (inherits(cond, "warning")) {
[17:39:55.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.597]                         if (muffled) 
[17:39:55.597]                           invokeRestart("muffleWarning")
[17:39:55.597]                       }
[17:39:55.597]                       else if (inherits(cond, "condition")) {
[17:39:55.597]                         if (!is.null(pattern)) {
[17:39:55.597]                           computeRestarts <- base::computeRestarts
[17:39:55.597]                           grepl <- base::grepl
[17:39:55.597]                           restarts <- computeRestarts(cond)
[17:39:55.597]                           for (restart in restarts) {
[17:39:55.597]                             name <- restart$name
[17:39:55.597]                             if (is.null(name)) 
[17:39:55.597]                               next
[17:39:55.597]                             if (!grepl(pattern, name)) 
[17:39:55.597]                               next
[17:39:55.597]                             invokeRestart(restart)
[17:39:55.597]                             muffled <- TRUE
[17:39:55.597]                             break
[17:39:55.597]                           }
[17:39:55.597]                         }
[17:39:55.597]                       }
[17:39:55.597]                       invisible(muffled)
[17:39:55.597]                     }
[17:39:55.597]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.597]                   }
[17:39:55.597]                 }
[17:39:55.597]                 else {
[17:39:55.597]                   if (TRUE) {
[17:39:55.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.597]                     {
[17:39:55.597]                       inherits <- base::inherits
[17:39:55.597]                       invokeRestart <- base::invokeRestart
[17:39:55.597]                       is.null <- base::is.null
[17:39:55.597]                       muffled <- FALSE
[17:39:55.597]                       if (inherits(cond, "message")) {
[17:39:55.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.597]                         if (muffled) 
[17:39:55.597]                           invokeRestart("muffleMessage")
[17:39:55.597]                       }
[17:39:55.597]                       else if (inherits(cond, "warning")) {
[17:39:55.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.597]                         if (muffled) 
[17:39:55.597]                           invokeRestart("muffleWarning")
[17:39:55.597]                       }
[17:39:55.597]                       else if (inherits(cond, "condition")) {
[17:39:55.597]                         if (!is.null(pattern)) {
[17:39:55.597]                           computeRestarts <- base::computeRestarts
[17:39:55.597]                           grepl <- base::grepl
[17:39:55.597]                           restarts <- computeRestarts(cond)
[17:39:55.597]                           for (restart in restarts) {
[17:39:55.597]                             name <- restart$name
[17:39:55.597]                             if (is.null(name)) 
[17:39:55.597]                               next
[17:39:55.597]                             if (!grepl(pattern, name)) 
[17:39:55.597]                               next
[17:39:55.597]                             invokeRestart(restart)
[17:39:55.597]                             muffled <- TRUE
[17:39:55.597]                             break
[17:39:55.597]                           }
[17:39:55.597]                         }
[17:39:55.597]                       }
[17:39:55.597]                       invisible(muffled)
[17:39:55.597]                     }
[17:39:55.597]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.597]                   }
[17:39:55.597]                 }
[17:39:55.597]             }
[17:39:55.597]         }))
[17:39:55.597]     }, error = function(ex) {
[17:39:55.597]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.597]                 ...future.rng), started = ...future.startTime, 
[17:39:55.597]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.597]             version = "1.8"), class = "FutureResult")
[17:39:55.597]     }, finally = {
[17:39:55.597]         if (!identical(...future.workdir, getwd())) 
[17:39:55.597]             setwd(...future.workdir)
[17:39:55.597]         {
[17:39:55.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.597]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.597]             }
[17:39:55.597]             base::options(...future.oldOptions)
[17:39:55.597]             if (.Platform$OS.type == "windows") {
[17:39:55.597]                 old_names <- names(...future.oldEnvVars)
[17:39:55.597]                 envs <- base::Sys.getenv()
[17:39:55.597]                 names <- names(envs)
[17:39:55.597]                 common <- intersect(names, old_names)
[17:39:55.597]                 added <- setdiff(names, old_names)
[17:39:55.597]                 removed <- setdiff(old_names, names)
[17:39:55.597]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.597]                   envs[common]]
[17:39:55.597]                 NAMES <- toupper(changed)
[17:39:55.597]                 args <- list()
[17:39:55.597]                 for (kk in seq_along(NAMES)) {
[17:39:55.597]                   name <- changed[[kk]]
[17:39:55.597]                   NAME <- NAMES[[kk]]
[17:39:55.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.597]                     next
[17:39:55.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.597]                 }
[17:39:55.597]                 NAMES <- toupper(added)
[17:39:55.597]                 for (kk in seq_along(NAMES)) {
[17:39:55.597]                   name <- added[[kk]]
[17:39:55.597]                   NAME <- NAMES[[kk]]
[17:39:55.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.597]                     next
[17:39:55.597]                   args[[name]] <- ""
[17:39:55.597]                 }
[17:39:55.597]                 NAMES <- toupper(removed)
[17:39:55.597]                 for (kk in seq_along(NAMES)) {
[17:39:55.597]                   name <- removed[[kk]]
[17:39:55.597]                   NAME <- NAMES[[kk]]
[17:39:55.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.597]                     next
[17:39:55.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.597]                 }
[17:39:55.597]                 if (length(args) > 0) 
[17:39:55.597]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.597]             }
[17:39:55.597]             else {
[17:39:55.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.597]             }
[17:39:55.597]             {
[17:39:55.597]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.597]                   0L) {
[17:39:55.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.597]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.597]                   base::options(opts)
[17:39:55.597]                 }
[17:39:55.597]                 {
[17:39:55.597]                   {
[17:39:55.597]                     NULL
[17:39:55.597]                     RNGkind("Mersenne-Twister")
[17:39:55.597]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.597]                       inherits = FALSE)
[17:39:55.597]                   }
[17:39:55.597]                   options(future.plan = NULL)
[17:39:55.597]                   if (is.na(NA_character_)) 
[17:39:55.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.597]                     .init = FALSE)
[17:39:55.597]                 }
[17:39:55.597]             }
[17:39:55.597]         }
[17:39:55.597]     })
[17:39:55.597]     if (TRUE) {
[17:39:55.597]         base::sink(type = "output", split = FALSE)
[17:39:55.597]         if (TRUE) {
[17:39:55.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.597]         }
[17:39:55.597]         else {
[17:39:55.597]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.597]         }
[17:39:55.597]         base::close(...future.stdout)
[17:39:55.597]         ...future.stdout <- NULL
[17:39:55.597]     }
[17:39:55.597]     ...future.result$conditions <- ...future.conditions
[17:39:55.597]     ...future.result$finished <- base::Sys.time()
[17:39:55.597]     ...future.result
[17:39:55.597] }
[17:39:55.599] assign_globals() ...
[17:39:55.599] List of 1
[17:39:55.599]  $ ii: int 3
[17:39:55.599]  - attr(*, "where")=List of 1
[17:39:55.599]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.599]  - attr(*, "resolved")= logi TRUE
[17:39:55.599]  - attr(*, "total_size")= num 56
[17:39:55.599]  - attr(*, "already-done")= logi TRUE
[17:39:55.602] - copied ‘ii’ to environment
[17:39:55.602] assign_globals() ... done
[17:39:55.603] plan(): Setting new future strategy stack:
[17:39:55.603] List of future strategies:
[17:39:55.603] 1. sequential:
[17:39:55.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.603]    - tweaked: FALSE
[17:39:55.603]    - call: NULL
[17:39:55.603] plan(): nbrOfWorkers() = 1
[17:39:55.604] plan(): Setting new future strategy stack:
[17:39:55.604] List of future strategies:
[17:39:55.604] 1. sequential:
[17:39:55.604]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.604]    - tweaked: FALSE
[17:39:55.604]    - call: plan(strategy)
[17:39:55.604] plan(): nbrOfWorkers() = 1
[17:39:55.604] SequentialFuture started (and completed)
[17:39:55.604] - Launch lazy future ... done
[17:39:55.605] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.606] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.606] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.607] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.607] Searching for globals ... DONE
[17:39:55.607] Resolving globals: TRUE
[17:39:55.607] Resolving any globals that are futures ...
[17:39:55.607] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.607] Resolving any globals that are futures ... DONE
[17:39:55.608] Resolving futures part of globals (recursively) ...
[17:39:55.608] resolve() on list ...
[17:39:55.608]  recursive: 99
[17:39:55.608]  length: 1
[17:39:55.608]  elements: ‘ii’
[17:39:55.608]  length: 0 (resolved future 1)
[17:39:55.608] resolve() on list ... DONE
[17:39:55.608] - globals: [1] ‘ii’
[17:39:55.609] Resolving futures part of globals (recursively) ... DONE
[17:39:55.609] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.609] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.609] - globals: [1] ‘ii’
[17:39:55.609] 
[17:39:55.609] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.610] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.610] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.611] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.611] Searching for globals ... DONE
[17:39:55.611] Resolving globals: TRUE
[17:39:55.611] Resolving any globals that are futures ...
[17:39:55.611] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.612] Resolving any globals that are futures ... DONE
[17:39:55.612] Resolving futures part of globals (recursively) ...
[17:39:55.612] resolve() on list ...
[17:39:55.612]  recursive: 99
[17:39:55.612]  length: 1
[17:39:55.612]  elements: ‘ii’
[17:39:55.612]  length: 0 (resolved future 1)
[17:39:55.613] resolve() on list ... DONE
[17:39:55.613] - globals: [1] ‘ii’
[17:39:55.613] Resolving futures part of globals (recursively) ... DONE
[17:39:55.613] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.613] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.613] - globals: [1] ‘ii’
[17:39:55.613] 
[17:39:55.613] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.614] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.614] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.615] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.615] Searching for globals ... DONE
[17:39:55.616] Resolving globals: TRUE
[17:39:55.616] Resolving any globals that are futures ...
[17:39:55.616] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:55.616] Resolving any globals that are futures ... DONE
[17:39:55.616] Resolving futures part of globals (recursively) ...
[17:39:55.616] resolve() on list ...
[17:39:55.616]  recursive: 99
[17:39:55.616]  length: 1
[17:39:55.617]  elements: ‘ii’
[17:39:55.617]  length: 0 (resolved future 1)
[17:39:55.617] resolve() on list ... DONE
[17:39:55.617] - globals: [1] ‘ii’
[17:39:55.617] Resolving futures part of globals (recursively) ... DONE
[17:39:55.617] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.617] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.617] - globals: [1] ‘ii’
[17:39:55.618] 
[17:39:55.618] getGlobalsAndPackages() ... DONE
[17:39:55.618] run() for ‘Future’ ...
[17:39:55.618] - state: ‘created’
[17:39:55.618] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.618] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.619]   - Field: ‘label’
[17:39:55.619]   - Field: ‘local’
[17:39:55.619]   - Field: ‘owner’
[17:39:55.619]   - Field: ‘envir’
[17:39:55.619]   - Field: ‘packages’
[17:39:55.619]   - Field: ‘gc’
[17:39:55.619]   - Field: ‘conditions’
[17:39:55.619]   - Field: ‘expr’
[17:39:55.619]   - Field: ‘uuid’
[17:39:55.619]   - Field: ‘seed’
[17:39:55.619]   - Field: ‘version’
[17:39:55.620]   - Field: ‘result’
[17:39:55.620]   - Field: ‘asynchronous’
[17:39:55.620]   - Field: ‘calls’
[17:39:55.620]   - Field: ‘globals’
[17:39:55.620]   - Field: ‘stdout’
[17:39:55.620]   - Field: ‘earlySignal’
[17:39:55.620]   - Field: ‘lazy’
[17:39:55.620]   - Field: ‘state’
[17:39:55.620] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.620] - Launch lazy future ...
[17:39:55.620] Packages needed by the future expression (n = 0): <none>
[17:39:55.621] Packages needed by future strategies (n = 0): <none>
[17:39:55.621] {
[17:39:55.621]     {
[17:39:55.621]         {
[17:39:55.621]             ...future.startTime <- base::Sys.time()
[17:39:55.621]             {
[17:39:55.621]                 {
[17:39:55.621]                   {
[17:39:55.621]                     base::local({
[17:39:55.621]                       has_future <- base::requireNamespace("future", 
[17:39:55.621]                         quietly = TRUE)
[17:39:55.621]                       if (has_future) {
[17:39:55.621]                         ns <- base::getNamespace("future")
[17:39:55.621]                         version <- ns[[".package"]][["version"]]
[17:39:55.621]                         if (is.null(version)) 
[17:39:55.621]                           version <- utils::packageVersion("future")
[17:39:55.621]                       }
[17:39:55.621]                       else {
[17:39:55.621]                         version <- NULL
[17:39:55.621]                       }
[17:39:55.621]                       if (!has_future || version < "1.8.0") {
[17:39:55.621]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.621]                           "", base::R.version$version.string), 
[17:39:55.621]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.621]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.621]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.621]                             "release", "version")], collapse = " "), 
[17:39:55.621]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.621]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.621]                           info)
[17:39:55.621]                         info <- base::paste(info, collapse = "; ")
[17:39:55.621]                         if (!has_future) {
[17:39:55.621]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.621]                             info)
[17:39:55.621]                         }
[17:39:55.621]                         else {
[17:39:55.621]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.621]                             info, version)
[17:39:55.621]                         }
[17:39:55.621]                         base::stop(msg)
[17:39:55.621]                       }
[17:39:55.621]                     })
[17:39:55.621]                   }
[17:39:55.621]                   ...future.strategy.old <- future::plan("list")
[17:39:55.621]                   options(future.plan = NULL)
[17:39:55.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.621]                 }
[17:39:55.621]                 ...future.workdir <- getwd()
[17:39:55.621]             }
[17:39:55.621]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.621]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.621]         }
[17:39:55.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.621]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.621]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.621]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.621]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.621]             base::names(...future.oldOptions))
[17:39:55.621]     }
[17:39:55.621]     if (FALSE) {
[17:39:55.621]     }
[17:39:55.621]     else {
[17:39:55.621]         if (TRUE) {
[17:39:55.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.621]                 open = "w")
[17:39:55.621]         }
[17:39:55.621]         else {
[17:39:55.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.621]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.621]         }
[17:39:55.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.621]             base::sink(type = "output", split = FALSE)
[17:39:55.621]             base::close(...future.stdout)
[17:39:55.621]         }, add = TRUE)
[17:39:55.621]     }
[17:39:55.621]     ...future.frame <- base::sys.nframe()
[17:39:55.621]     ...future.conditions <- base::list()
[17:39:55.621]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.621]     if (FALSE) {
[17:39:55.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.621]     }
[17:39:55.621]     ...future.result <- base::tryCatch({
[17:39:55.621]         base::withCallingHandlers({
[17:39:55.621]             ...future.value <- base::withVisible(base::local({
[17:39:55.621]                 b <- a * ii
[17:39:55.621]                 a <- 0
[17:39:55.621]                 b
[17:39:55.621]             }))
[17:39:55.621]             future::FutureResult(value = ...future.value$value, 
[17:39:55.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.621]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.621]                     ...future.globalenv.names))
[17:39:55.621]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.621]         }, condition = base::local({
[17:39:55.621]             c <- base::c
[17:39:55.621]             inherits <- base::inherits
[17:39:55.621]             invokeRestart <- base::invokeRestart
[17:39:55.621]             length <- base::length
[17:39:55.621]             list <- base::list
[17:39:55.621]             seq.int <- base::seq.int
[17:39:55.621]             signalCondition <- base::signalCondition
[17:39:55.621]             sys.calls <- base::sys.calls
[17:39:55.621]             `[[` <- base::`[[`
[17:39:55.621]             `+` <- base::`+`
[17:39:55.621]             `<<-` <- base::`<<-`
[17:39:55.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.621]                   3L)]
[17:39:55.621]             }
[17:39:55.621]             function(cond) {
[17:39:55.621]                 is_error <- inherits(cond, "error")
[17:39:55.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.621]                   NULL)
[17:39:55.621]                 if (is_error) {
[17:39:55.621]                   sessionInformation <- function() {
[17:39:55.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.621]                       search = base::search(), system = base::Sys.info())
[17:39:55.621]                   }
[17:39:55.621]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.621]                     cond$call), session = sessionInformation(), 
[17:39:55.621]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.621]                   signalCondition(cond)
[17:39:55.621]                 }
[17:39:55.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.621]                 "immediateCondition"))) {
[17:39:55.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.621]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.621]                   if (TRUE && !signal) {
[17:39:55.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.621]                     {
[17:39:55.621]                       inherits <- base::inherits
[17:39:55.621]                       invokeRestart <- base::invokeRestart
[17:39:55.621]                       is.null <- base::is.null
[17:39:55.621]                       muffled <- FALSE
[17:39:55.621]                       if (inherits(cond, "message")) {
[17:39:55.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.621]                         if (muffled) 
[17:39:55.621]                           invokeRestart("muffleMessage")
[17:39:55.621]                       }
[17:39:55.621]                       else if (inherits(cond, "warning")) {
[17:39:55.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.621]                         if (muffled) 
[17:39:55.621]                           invokeRestart("muffleWarning")
[17:39:55.621]                       }
[17:39:55.621]                       else if (inherits(cond, "condition")) {
[17:39:55.621]                         if (!is.null(pattern)) {
[17:39:55.621]                           computeRestarts <- base::computeRestarts
[17:39:55.621]                           grepl <- base::grepl
[17:39:55.621]                           restarts <- computeRestarts(cond)
[17:39:55.621]                           for (restart in restarts) {
[17:39:55.621]                             name <- restart$name
[17:39:55.621]                             if (is.null(name)) 
[17:39:55.621]                               next
[17:39:55.621]                             if (!grepl(pattern, name)) 
[17:39:55.621]                               next
[17:39:55.621]                             invokeRestart(restart)
[17:39:55.621]                             muffled <- TRUE
[17:39:55.621]                             break
[17:39:55.621]                           }
[17:39:55.621]                         }
[17:39:55.621]                       }
[17:39:55.621]                       invisible(muffled)
[17:39:55.621]                     }
[17:39:55.621]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.621]                   }
[17:39:55.621]                 }
[17:39:55.621]                 else {
[17:39:55.621]                   if (TRUE) {
[17:39:55.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.621]                     {
[17:39:55.621]                       inherits <- base::inherits
[17:39:55.621]                       invokeRestart <- base::invokeRestart
[17:39:55.621]                       is.null <- base::is.null
[17:39:55.621]                       muffled <- FALSE
[17:39:55.621]                       if (inherits(cond, "message")) {
[17:39:55.621]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.621]                         if (muffled) 
[17:39:55.621]                           invokeRestart("muffleMessage")
[17:39:55.621]                       }
[17:39:55.621]                       else if (inherits(cond, "warning")) {
[17:39:55.621]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.621]                         if (muffled) 
[17:39:55.621]                           invokeRestart("muffleWarning")
[17:39:55.621]                       }
[17:39:55.621]                       else if (inherits(cond, "condition")) {
[17:39:55.621]                         if (!is.null(pattern)) {
[17:39:55.621]                           computeRestarts <- base::computeRestarts
[17:39:55.621]                           grepl <- base::grepl
[17:39:55.621]                           restarts <- computeRestarts(cond)
[17:39:55.621]                           for (restart in restarts) {
[17:39:55.621]                             name <- restart$name
[17:39:55.621]                             if (is.null(name)) 
[17:39:55.621]                               next
[17:39:55.621]                             if (!grepl(pattern, name)) 
[17:39:55.621]                               next
[17:39:55.621]                             invokeRestart(restart)
[17:39:55.621]                             muffled <- TRUE
[17:39:55.621]                             break
[17:39:55.621]                           }
[17:39:55.621]                         }
[17:39:55.621]                       }
[17:39:55.621]                       invisible(muffled)
[17:39:55.621]                     }
[17:39:55.621]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.621]                   }
[17:39:55.621]                 }
[17:39:55.621]             }
[17:39:55.621]         }))
[17:39:55.621]     }, error = function(ex) {
[17:39:55.621]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.621]                 ...future.rng), started = ...future.startTime, 
[17:39:55.621]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.621]             version = "1.8"), class = "FutureResult")
[17:39:55.621]     }, finally = {
[17:39:55.621]         if (!identical(...future.workdir, getwd())) 
[17:39:55.621]             setwd(...future.workdir)
[17:39:55.621]         {
[17:39:55.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.621]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.621]             }
[17:39:55.621]             base::options(...future.oldOptions)
[17:39:55.621]             if (.Platform$OS.type == "windows") {
[17:39:55.621]                 old_names <- names(...future.oldEnvVars)
[17:39:55.621]                 envs <- base::Sys.getenv()
[17:39:55.621]                 names <- names(envs)
[17:39:55.621]                 common <- intersect(names, old_names)
[17:39:55.621]                 added <- setdiff(names, old_names)
[17:39:55.621]                 removed <- setdiff(old_names, names)
[17:39:55.621]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.621]                   envs[common]]
[17:39:55.621]                 NAMES <- toupper(changed)
[17:39:55.621]                 args <- list()
[17:39:55.621]                 for (kk in seq_along(NAMES)) {
[17:39:55.621]                   name <- changed[[kk]]
[17:39:55.621]                   NAME <- NAMES[[kk]]
[17:39:55.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.621]                     next
[17:39:55.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.621]                 }
[17:39:55.621]                 NAMES <- toupper(added)
[17:39:55.621]                 for (kk in seq_along(NAMES)) {
[17:39:55.621]                   name <- added[[kk]]
[17:39:55.621]                   NAME <- NAMES[[kk]]
[17:39:55.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.621]                     next
[17:39:55.621]                   args[[name]] <- ""
[17:39:55.621]                 }
[17:39:55.621]                 NAMES <- toupper(removed)
[17:39:55.621]                 for (kk in seq_along(NAMES)) {
[17:39:55.621]                   name <- removed[[kk]]
[17:39:55.621]                   NAME <- NAMES[[kk]]
[17:39:55.621]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.621]                     next
[17:39:55.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.621]                 }
[17:39:55.621]                 if (length(args) > 0) 
[17:39:55.621]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.621]             }
[17:39:55.621]             else {
[17:39:55.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.621]             }
[17:39:55.621]             {
[17:39:55.621]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.621]                   0L) {
[17:39:55.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.621]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.621]                   base::options(opts)
[17:39:55.621]                 }
[17:39:55.621]                 {
[17:39:55.621]                   {
[17:39:55.621]                     NULL
[17:39:55.621]                     RNGkind("Mersenne-Twister")
[17:39:55.621]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.621]                       inherits = FALSE)
[17:39:55.621]                   }
[17:39:55.621]                   options(future.plan = NULL)
[17:39:55.621]                   if (is.na(NA_character_)) 
[17:39:55.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.621]                     .init = FALSE)
[17:39:55.621]                 }
[17:39:55.621]             }
[17:39:55.621]         }
[17:39:55.621]     })
[17:39:55.621]     if (TRUE) {
[17:39:55.621]         base::sink(type = "output", split = FALSE)
[17:39:55.621]         if (TRUE) {
[17:39:55.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.621]         }
[17:39:55.621]         else {
[17:39:55.621]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.621]         }
[17:39:55.621]         base::close(...future.stdout)
[17:39:55.621]         ...future.stdout <- NULL
[17:39:55.621]     }
[17:39:55.621]     ...future.result$conditions <- ...future.conditions
[17:39:55.621]     ...future.result$finished <- base::Sys.time()
[17:39:55.621]     ...future.result
[17:39:55.621] }
[17:39:55.622] assign_globals() ...
[17:39:55.623] List of 1
[17:39:55.623]  $ ii: int 1
[17:39:55.623]  - attr(*, "where")=List of 1
[17:39:55.623]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.623]  - attr(*, "resolved")= logi TRUE
[17:39:55.623]  - attr(*, "total_size")= num 56
[17:39:55.623]  - attr(*, "already-done")= logi TRUE
[17:39:55.625] - copied ‘ii’ to environment
[17:39:55.625] assign_globals() ... done
[17:39:55.625] plan(): Setting new future strategy stack:
[17:39:55.625] List of future strategies:
[17:39:55.625] 1. sequential:
[17:39:55.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.625]    - tweaked: FALSE
[17:39:55.625]    - call: NULL
[17:39:55.626] plan(): nbrOfWorkers() = 1
[17:39:55.628] plan(): Setting new future strategy stack:
[17:39:55.628] List of future strategies:
[17:39:55.628] 1. sequential:
[17:39:55.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.628]    - tweaked: FALSE
[17:39:55.628]    - call: plan(strategy)
[17:39:55.628] plan(): nbrOfWorkers() = 1
[17:39:55.628] SequentialFuture started (and completed)
[17:39:55.629] signalConditions() ...
[17:39:55.629]  - include = ‘immediateCondition’
[17:39:55.629]  - exclude = 
[17:39:55.629]  - resignal = FALSE
[17:39:55.629]  - Number of conditions: 1
[17:39:55.629] signalConditions() ... done
[17:39:55.629] - Launch lazy future ... done
[17:39:55.629] run() for ‘SequentialFuture’ ... done
[17:39:55.629] signalConditions() ...
[17:39:55.629]  - include = ‘immediateCondition’
[17:39:55.629]  - exclude = 
[17:39:55.629]  - resignal = FALSE
[17:39:55.630]  - Number of conditions: 1
[17:39:55.630] signalConditions() ... done
[17:39:55.630] Future state: ‘finished’
[17:39:55.630] signalConditions() ...
[17:39:55.630]  - include = ‘condition’
[17:39:55.630]  - exclude = ‘immediateCondition’
[17:39:55.630]  - resignal = TRUE
[17:39:55.630]  - Number of conditions: 1
[17:39:55.630]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:55.630] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:55"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.643] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.643] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.644] 
[17:39:55.644] Searching for globals ... DONE
[17:39:55.644] - globals: [0] <none>
[17:39:55.644] getGlobalsAndPackages() ... DONE
[17:39:55.644] run() for ‘Future’ ...
[17:39:55.644] - state: ‘created’
[17:39:55.644] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.645] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.645] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.645]   - Field: ‘label’
[17:39:55.645]   - Field: ‘local’
[17:39:55.645]   - Field: ‘owner’
[17:39:55.645]   - Field: ‘envir’
[17:39:55.645]   - Field: ‘packages’
[17:39:55.645]   - Field: ‘gc’
[17:39:55.645]   - Field: ‘conditions’
[17:39:55.646]   - Field: ‘expr’
[17:39:55.646]   - Field: ‘uuid’
[17:39:55.646]   - Field: ‘seed’
[17:39:55.646]   - Field: ‘version’
[17:39:55.646]   - Field: ‘result’
[17:39:55.646]   - Field: ‘asynchronous’
[17:39:55.646]   - Field: ‘calls’
[17:39:55.646]   - Field: ‘globals’
[17:39:55.646]   - Field: ‘stdout’
[17:39:55.646]   - Field: ‘earlySignal’
[17:39:55.646]   - Field: ‘lazy’
[17:39:55.646]   - Field: ‘state’
[17:39:55.647] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.647] - Launch lazy future ...
[17:39:55.647] Packages needed by the future expression (n = 0): <none>
[17:39:55.647] Packages needed by future strategies (n = 0): <none>
[17:39:55.647] {
[17:39:55.647]     {
[17:39:55.647]         {
[17:39:55.647]             ...future.startTime <- base::Sys.time()
[17:39:55.647]             {
[17:39:55.647]                 {
[17:39:55.647]                   {
[17:39:55.647]                     base::local({
[17:39:55.647]                       has_future <- base::requireNamespace("future", 
[17:39:55.647]                         quietly = TRUE)
[17:39:55.647]                       if (has_future) {
[17:39:55.647]                         ns <- base::getNamespace("future")
[17:39:55.647]                         version <- ns[[".package"]][["version"]]
[17:39:55.647]                         if (is.null(version)) 
[17:39:55.647]                           version <- utils::packageVersion("future")
[17:39:55.647]                       }
[17:39:55.647]                       else {
[17:39:55.647]                         version <- NULL
[17:39:55.647]                       }
[17:39:55.647]                       if (!has_future || version < "1.8.0") {
[17:39:55.647]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.647]                           "", base::R.version$version.string), 
[17:39:55.647]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.647]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.647]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.647]                             "release", "version")], collapse = " "), 
[17:39:55.647]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.647]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.647]                           info)
[17:39:55.647]                         info <- base::paste(info, collapse = "; ")
[17:39:55.647]                         if (!has_future) {
[17:39:55.647]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.647]                             info)
[17:39:55.647]                         }
[17:39:55.647]                         else {
[17:39:55.647]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.647]                             info, version)
[17:39:55.647]                         }
[17:39:55.647]                         base::stop(msg)
[17:39:55.647]                       }
[17:39:55.647]                     })
[17:39:55.647]                   }
[17:39:55.647]                   ...future.strategy.old <- future::plan("list")
[17:39:55.647]                   options(future.plan = NULL)
[17:39:55.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.647]                 }
[17:39:55.647]                 ...future.workdir <- getwd()
[17:39:55.647]             }
[17:39:55.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.647]         }
[17:39:55.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.647]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.647]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.647]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.647]             base::names(...future.oldOptions))
[17:39:55.647]     }
[17:39:55.647]     if (FALSE) {
[17:39:55.647]     }
[17:39:55.647]     else {
[17:39:55.647]         if (TRUE) {
[17:39:55.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.647]                 open = "w")
[17:39:55.647]         }
[17:39:55.647]         else {
[17:39:55.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.647]         }
[17:39:55.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.647]             base::sink(type = "output", split = FALSE)
[17:39:55.647]             base::close(...future.stdout)
[17:39:55.647]         }, add = TRUE)
[17:39:55.647]     }
[17:39:55.647]     ...future.frame <- base::sys.nframe()
[17:39:55.647]     ...future.conditions <- base::list()
[17:39:55.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.647]     if (FALSE) {
[17:39:55.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.647]     }
[17:39:55.647]     ...future.result <- base::tryCatch({
[17:39:55.647]         base::withCallingHandlers({
[17:39:55.647]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.647]             future::FutureResult(value = ...future.value$value, 
[17:39:55.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.647]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.647]                     ...future.globalenv.names))
[17:39:55.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.647]         }, condition = base::local({
[17:39:55.647]             c <- base::c
[17:39:55.647]             inherits <- base::inherits
[17:39:55.647]             invokeRestart <- base::invokeRestart
[17:39:55.647]             length <- base::length
[17:39:55.647]             list <- base::list
[17:39:55.647]             seq.int <- base::seq.int
[17:39:55.647]             signalCondition <- base::signalCondition
[17:39:55.647]             sys.calls <- base::sys.calls
[17:39:55.647]             `[[` <- base::`[[`
[17:39:55.647]             `+` <- base::`+`
[17:39:55.647]             `<<-` <- base::`<<-`
[17:39:55.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.647]                   3L)]
[17:39:55.647]             }
[17:39:55.647]             function(cond) {
[17:39:55.647]                 is_error <- inherits(cond, "error")
[17:39:55.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.647]                   NULL)
[17:39:55.647]                 if (is_error) {
[17:39:55.647]                   sessionInformation <- function() {
[17:39:55.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.647]                       search = base::search(), system = base::Sys.info())
[17:39:55.647]                   }
[17:39:55.647]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.647]                     cond$call), session = sessionInformation(), 
[17:39:55.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.647]                   signalCondition(cond)
[17:39:55.647]                 }
[17:39:55.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.647]                 "immediateCondition"))) {
[17:39:55.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.647]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.647]                   if (TRUE && !signal) {
[17:39:55.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.647]                     {
[17:39:55.647]                       inherits <- base::inherits
[17:39:55.647]                       invokeRestart <- base::invokeRestart
[17:39:55.647]                       is.null <- base::is.null
[17:39:55.647]                       muffled <- FALSE
[17:39:55.647]                       if (inherits(cond, "message")) {
[17:39:55.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.647]                         if (muffled) 
[17:39:55.647]                           invokeRestart("muffleMessage")
[17:39:55.647]                       }
[17:39:55.647]                       else if (inherits(cond, "warning")) {
[17:39:55.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.647]                         if (muffled) 
[17:39:55.647]                           invokeRestart("muffleWarning")
[17:39:55.647]                       }
[17:39:55.647]                       else if (inherits(cond, "condition")) {
[17:39:55.647]                         if (!is.null(pattern)) {
[17:39:55.647]                           computeRestarts <- base::computeRestarts
[17:39:55.647]                           grepl <- base::grepl
[17:39:55.647]                           restarts <- computeRestarts(cond)
[17:39:55.647]                           for (restart in restarts) {
[17:39:55.647]                             name <- restart$name
[17:39:55.647]                             if (is.null(name)) 
[17:39:55.647]                               next
[17:39:55.647]                             if (!grepl(pattern, name)) 
[17:39:55.647]                               next
[17:39:55.647]                             invokeRestart(restart)
[17:39:55.647]                             muffled <- TRUE
[17:39:55.647]                             break
[17:39:55.647]                           }
[17:39:55.647]                         }
[17:39:55.647]                       }
[17:39:55.647]                       invisible(muffled)
[17:39:55.647]                     }
[17:39:55.647]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.647]                   }
[17:39:55.647]                 }
[17:39:55.647]                 else {
[17:39:55.647]                   if (TRUE) {
[17:39:55.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.647]                     {
[17:39:55.647]                       inherits <- base::inherits
[17:39:55.647]                       invokeRestart <- base::invokeRestart
[17:39:55.647]                       is.null <- base::is.null
[17:39:55.647]                       muffled <- FALSE
[17:39:55.647]                       if (inherits(cond, "message")) {
[17:39:55.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.647]                         if (muffled) 
[17:39:55.647]                           invokeRestart("muffleMessage")
[17:39:55.647]                       }
[17:39:55.647]                       else if (inherits(cond, "warning")) {
[17:39:55.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.647]                         if (muffled) 
[17:39:55.647]                           invokeRestart("muffleWarning")
[17:39:55.647]                       }
[17:39:55.647]                       else if (inherits(cond, "condition")) {
[17:39:55.647]                         if (!is.null(pattern)) {
[17:39:55.647]                           computeRestarts <- base::computeRestarts
[17:39:55.647]                           grepl <- base::grepl
[17:39:55.647]                           restarts <- computeRestarts(cond)
[17:39:55.647]                           for (restart in restarts) {
[17:39:55.647]                             name <- restart$name
[17:39:55.647]                             if (is.null(name)) 
[17:39:55.647]                               next
[17:39:55.647]                             if (!grepl(pattern, name)) 
[17:39:55.647]                               next
[17:39:55.647]                             invokeRestart(restart)
[17:39:55.647]                             muffled <- TRUE
[17:39:55.647]                             break
[17:39:55.647]                           }
[17:39:55.647]                         }
[17:39:55.647]                       }
[17:39:55.647]                       invisible(muffled)
[17:39:55.647]                     }
[17:39:55.647]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.647]                   }
[17:39:55.647]                 }
[17:39:55.647]             }
[17:39:55.647]         }))
[17:39:55.647]     }, error = function(ex) {
[17:39:55.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.647]                 ...future.rng), started = ...future.startTime, 
[17:39:55.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.647]             version = "1.8"), class = "FutureResult")
[17:39:55.647]     }, finally = {
[17:39:55.647]         if (!identical(...future.workdir, getwd())) 
[17:39:55.647]             setwd(...future.workdir)
[17:39:55.647]         {
[17:39:55.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.647]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.647]             }
[17:39:55.647]             base::options(...future.oldOptions)
[17:39:55.647]             if (.Platform$OS.type == "windows") {
[17:39:55.647]                 old_names <- names(...future.oldEnvVars)
[17:39:55.647]                 envs <- base::Sys.getenv()
[17:39:55.647]                 names <- names(envs)
[17:39:55.647]                 common <- intersect(names, old_names)
[17:39:55.647]                 added <- setdiff(names, old_names)
[17:39:55.647]                 removed <- setdiff(old_names, names)
[17:39:55.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.647]                   envs[common]]
[17:39:55.647]                 NAMES <- toupper(changed)
[17:39:55.647]                 args <- list()
[17:39:55.647]                 for (kk in seq_along(NAMES)) {
[17:39:55.647]                   name <- changed[[kk]]
[17:39:55.647]                   NAME <- NAMES[[kk]]
[17:39:55.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.647]                     next
[17:39:55.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.647]                 }
[17:39:55.647]                 NAMES <- toupper(added)
[17:39:55.647]                 for (kk in seq_along(NAMES)) {
[17:39:55.647]                   name <- added[[kk]]
[17:39:55.647]                   NAME <- NAMES[[kk]]
[17:39:55.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.647]                     next
[17:39:55.647]                   args[[name]] <- ""
[17:39:55.647]                 }
[17:39:55.647]                 NAMES <- toupper(removed)
[17:39:55.647]                 for (kk in seq_along(NAMES)) {
[17:39:55.647]                   name <- removed[[kk]]
[17:39:55.647]                   NAME <- NAMES[[kk]]
[17:39:55.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.647]                     next
[17:39:55.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.647]                 }
[17:39:55.647]                 if (length(args) > 0) 
[17:39:55.647]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.647]             }
[17:39:55.647]             else {
[17:39:55.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.647]             }
[17:39:55.647]             {
[17:39:55.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.647]                   0L) {
[17:39:55.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.647]                   base::options(opts)
[17:39:55.647]                 }
[17:39:55.647]                 {
[17:39:55.647]                   {
[17:39:55.647]                     NULL
[17:39:55.647]                     RNGkind("Mersenne-Twister")
[17:39:55.647]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.647]                       inherits = FALSE)
[17:39:55.647]                   }
[17:39:55.647]                   options(future.plan = NULL)
[17:39:55.647]                   if (is.na(NA_character_)) 
[17:39:55.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.647]                     .init = FALSE)
[17:39:55.647]                 }
[17:39:55.647]             }
[17:39:55.647]         }
[17:39:55.647]     })
[17:39:55.647]     if (TRUE) {
[17:39:55.647]         base::sink(type = "output", split = FALSE)
[17:39:55.647]         if (TRUE) {
[17:39:55.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.647]         }
[17:39:55.647]         else {
[17:39:55.647]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.647]         }
[17:39:55.647]         base::close(...future.stdout)
[17:39:55.647]         ...future.stdout <- NULL
[17:39:55.647]     }
[17:39:55.647]     ...future.result$conditions <- ...future.conditions
[17:39:55.647]     ...future.result$finished <- base::Sys.time()
[17:39:55.647]     ...future.result
[17:39:55.647] }
[17:39:55.649] plan(): Setting new future strategy stack:
[17:39:55.649] List of future strategies:
[17:39:55.649] 1. sequential:
[17:39:55.649]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.649]    - tweaked: FALSE
[17:39:55.649]    - call: NULL
[17:39:55.650] plan(): nbrOfWorkers() = 1
[17:39:55.650] plan(): Setting new future strategy stack:
[17:39:55.650] List of future strategies:
[17:39:55.650] 1. sequential:
[17:39:55.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.650]    - tweaked: FALSE
[17:39:55.650]    - call: plan(strategy)
[17:39:55.651] plan(): nbrOfWorkers() = 1
[17:39:55.651] SequentialFuture started (and completed)
[17:39:55.651] - Launch lazy future ... done
[17:39:55.651] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.651] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.652] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.654] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.654] Searching for globals ... DONE
[17:39:55.654] Resolving globals: TRUE
[17:39:55.654] Resolving any globals that are futures ...
[17:39:55.654] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.654] Resolving any globals that are futures ... DONE
[17:39:55.654] Resolving futures part of globals (recursively) ...
[17:39:55.655] resolve() on list ...
[17:39:55.655]  recursive: 99
[17:39:55.655]  length: 1
[17:39:55.655]  elements: ‘a’
[17:39:55.655] resolved() for ‘SequentialFuture’ ...
[17:39:55.655] - state: ‘finished’
[17:39:55.655] - run: TRUE
[17:39:55.655] - result: ‘FutureResult’
[17:39:55.655] resolved() for ‘SequentialFuture’ ... done
[17:39:55.655] Future #1
[17:39:55.656] resolved() for ‘SequentialFuture’ ...
[17:39:55.656] - state: ‘finished’
[17:39:55.656] - run: TRUE
[17:39:55.656] - result: ‘FutureResult’
[17:39:55.656] resolved() for ‘SequentialFuture’ ... done
[17:39:55.656] A SequentialFuture was resolved
[17:39:55.656]  length: 0 (resolved future 1)
[17:39:55.656] resolve() on list ... DONE
[17:39:55.657] - globals: [1] ‘a’
[17:39:55.657] Resolving futures part of globals (recursively) ... DONE
[17:39:55.657] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:39:55.658] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:39:55.658] - globals: [1] ‘a’
[17:39:55.658] - packages: [1] ‘future’
[17:39:55.658] getGlobalsAndPackages() ... DONE
[17:39:55.658] run() for ‘Future’ ...
[17:39:55.658] - state: ‘created’
[17:39:55.658] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.659] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.659]   - Field: ‘label’
[17:39:55.659]   - Field: ‘local’
[17:39:55.659]   - Field: ‘owner’
[17:39:55.659]   - Field: ‘envir’
[17:39:55.659]   - Field: ‘packages’
[17:39:55.659]   - Field: ‘gc’
[17:39:55.659]   - Field: ‘conditions’
[17:39:55.659]   - Field: ‘expr’
[17:39:55.660]   - Field: ‘uuid’
[17:39:55.660]   - Field: ‘seed’
[17:39:55.660]   - Field: ‘version’
[17:39:55.660]   - Field: ‘result’
[17:39:55.660]   - Field: ‘asynchronous’
[17:39:55.660]   - Field: ‘calls’
[17:39:55.660]   - Field: ‘globals’
[17:39:55.660]   - Field: ‘stdout’
[17:39:55.660]   - Field: ‘earlySignal’
[17:39:55.660]   - Field: ‘lazy’
[17:39:55.660]   - Field: ‘state’
[17:39:55.661] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.661] - Launch lazy future ...
[17:39:55.661] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.661] Packages needed by future strategies (n = 0): <none>
[17:39:55.661] {
[17:39:55.661]     {
[17:39:55.661]         {
[17:39:55.661]             ...future.startTime <- base::Sys.time()
[17:39:55.661]             {
[17:39:55.661]                 {
[17:39:55.661]                   {
[17:39:55.661]                     {
[17:39:55.661]                       base::local({
[17:39:55.661]                         has_future <- base::requireNamespace("future", 
[17:39:55.661]                           quietly = TRUE)
[17:39:55.661]                         if (has_future) {
[17:39:55.661]                           ns <- base::getNamespace("future")
[17:39:55.661]                           version <- ns[[".package"]][["version"]]
[17:39:55.661]                           if (is.null(version)) 
[17:39:55.661]                             version <- utils::packageVersion("future")
[17:39:55.661]                         }
[17:39:55.661]                         else {
[17:39:55.661]                           version <- NULL
[17:39:55.661]                         }
[17:39:55.661]                         if (!has_future || version < "1.8.0") {
[17:39:55.661]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.661]                             "", base::R.version$version.string), 
[17:39:55.661]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.661]                               "release", "version")], collapse = " "), 
[17:39:55.661]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.661]                             info)
[17:39:55.661]                           info <- base::paste(info, collapse = "; ")
[17:39:55.661]                           if (!has_future) {
[17:39:55.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.661]                               info)
[17:39:55.661]                           }
[17:39:55.661]                           else {
[17:39:55.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.661]                               info, version)
[17:39:55.661]                           }
[17:39:55.661]                           base::stop(msg)
[17:39:55.661]                         }
[17:39:55.661]                       })
[17:39:55.661]                     }
[17:39:55.661]                     base::local({
[17:39:55.661]                       for (pkg in "future") {
[17:39:55.661]                         base::loadNamespace(pkg)
[17:39:55.661]                         base::library(pkg, character.only = TRUE)
[17:39:55.661]                       }
[17:39:55.661]                     })
[17:39:55.661]                   }
[17:39:55.661]                   ...future.strategy.old <- future::plan("list")
[17:39:55.661]                   options(future.plan = NULL)
[17:39:55.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.661]                 }
[17:39:55.661]                 ...future.workdir <- getwd()
[17:39:55.661]             }
[17:39:55.661]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.661]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.661]         }
[17:39:55.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.661]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.661]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.661]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.661]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.661]             base::names(...future.oldOptions))
[17:39:55.661]     }
[17:39:55.661]     if (FALSE) {
[17:39:55.661]     }
[17:39:55.661]     else {
[17:39:55.661]         if (TRUE) {
[17:39:55.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.661]                 open = "w")
[17:39:55.661]         }
[17:39:55.661]         else {
[17:39:55.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.661]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.661]         }
[17:39:55.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.661]             base::sink(type = "output", split = FALSE)
[17:39:55.661]             base::close(...future.stdout)
[17:39:55.661]         }, add = TRUE)
[17:39:55.661]     }
[17:39:55.661]     ...future.frame <- base::sys.nframe()
[17:39:55.661]     ...future.conditions <- base::list()
[17:39:55.661]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.661]     if (FALSE) {
[17:39:55.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.661]     }
[17:39:55.661]     ...future.result <- base::tryCatch({
[17:39:55.661]         base::withCallingHandlers({
[17:39:55.661]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.661]                 1))
[17:39:55.661]             future::FutureResult(value = ...future.value$value, 
[17:39:55.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.661]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.661]                     ...future.globalenv.names))
[17:39:55.661]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.661]         }, condition = base::local({
[17:39:55.661]             c <- base::c
[17:39:55.661]             inherits <- base::inherits
[17:39:55.661]             invokeRestart <- base::invokeRestart
[17:39:55.661]             length <- base::length
[17:39:55.661]             list <- base::list
[17:39:55.661]             seq.int <- base::seq.int
[17:39:55.661]             signalCondition <- base::signalCondition
[17:39:55.661]             sys.calls <- base::sys.calls
[17:39:55.661]             `[[` <- base::`[[`
[17:39:55.661]             `+` <- base::`+`
[17:39:55.661]             `<<-` <- base::`<<-`
[17:39:55.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.661]                   3L)]
[17:39:55.661]             }
[17:39:55.661]             function(cond) {
[17:39:55.661]                 is_error <- inherits(cond, "error")
[17:39:55.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.661]                   NULL)
[17:39:55.661]                 if (is_error) {
[17:39:55.661]                   sessionInformation <- function() {
[17:39:55.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.661]                       search = base::search(), system = base::Sys.info())
[17:39:55.661]                   }
[17:39:55.661]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.661]                     cond$call), session = sessionInformation(), 
[17:39:55.661]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.661]                   signalCondition(cond)
[17:39:55.661]                 }
[17:39:55.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.661]                 "immediateCondition"))) {
[17:39:55.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.661]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.661]                   if (TRUE && !signal) {
[17:39:55.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.661]                     {
[17:39:55.661]                       inherits <- base::inherits
[17:39:55.661]                       invokeRestart <- base::invokeRestart
[17:39:55.661]                       is.null <- base::is.null
[17:39:55.661]                       muffled <- FALSE
[17:39:55.661]                       if (inherits(cond, "message")) {
[17:39:55.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.661]                         if (muffled) 
[17:39:55.661]                           invokeRestart("muffleMessage")
[17:39:55.661]                       }
[17:39:55.661]                       else if (inherits(cond, "warning")) {
[17:39:55.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.661]                         if (muffled) 
[17:39:55.661]                           invokeRestart("muffleWarning")
[17:39:55.661]                       }
[17:39:55.661]                       else if (inherits(cond, "condition")) {
[17:39:55.661]                         if (!is.null(pattern)) {
[17:39:55.661]                           computeRestarts <- base::computeRestarts
[17:39:55.661]                           grepl <- base::grepl
[17:39:55.661]                           restarts <- computeRestarts(cond)
[17:39:55.661]                           for (restart in restarts) {
[17:39:55.661]                             name <- restart$name
[17:39:55.661]                             if (is.null(name)) 
[17:39:55.661]                               next
[17:39:55.661]                             if (!grepl(pattern, name)) 
[17:39:55.661]                               next
[17:39:55.661]                             invokeRestart(restart)
[17:39:55.661]                             muffled <- TRUE
[17:39:55.661]                             break
[17:39:55.661]                           }
[17:39:55.661]                         }
[17:39:55.661]                       }
[17:39:55.661]                       invisible(muffled)
[17:39:55.661]                     }
[17:39:55.661]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.661]                   }
[17:39:55.661]                 }
[17:39:55.661]                 else {
[17:39:55.661]                   if (TRUE) {
[17:39:55.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.661]                     {
[17:39:55.661]                       inherits <- base::inherits
[17:39:55.661]                       invokeRestart <- base::invokeRestart
[17:39:55.661]                       is.null <- base::is.null
[17:39:55.661]                       muffled <- FALSE
[17:39:55.661]                       if (inherits(cond, "message")) {
[17:39:55.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.661]                         if (muffled) 
[17:39:55.661]                           invokeRestart("muffleMessage")
[17:39:55.661]                       }
[17:39:55.661]                       else if (inherits(cond, "warning")) {
[17:39:55.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.661]                         if (muffled) 
[17:39:55.661]                           invokeRestart("muffleWarning")
[17:39:55.661]                       }
[17:39:55.661]                       else if (inherits(cond, "condition")) {
[17:39:55.661]                         if (!is.null(pattern)) {
[17:39:55.661]                           computeRestarts <- base::computeRestarts
[17:39:55.661]                           grepl <- base::grepl
[17:39:55.661]                           restarts <- computeRestarts(cond)
[17:39:55.661]                           for (restart in restarts) {
[17:39:55.661]                             name <- restart$name
[17:39:55.661]                             if (is.null(name)) 
[17:39:55.661]                               next
[17:39:55.661]                             if (!grepl(pattern, name)) 
[17:39:55.661]                               next
[17:39:55.661]                             invokeRestart(restart)
[17:39:55.661]                             muffled <- TRUE
[17:39:55.661]                             break
[17:39:55.661]                           }
[17:39:55.661]                         }
[17:39:55.661]                       }
[17:39:55.661]                       invisible(muffled)
[17:39:55.661]                     }
[17:39:55.661]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.661]                   }
[17:39:55.661]                 }
[17:39:55.661]             }
[17:39:55.661]         }))
[17:39:55.661]     }, error = function(ex) {
[17:39:55.661]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.661]                 ...future.rng), started = ...future.startTime, 
[17:39:55.661]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.661]             version = "1.8"), class = "FutureResult")
[17:39:55.661]     }, finally = {
[17:39:55.661]         if (!identical(...future.workdir, getwd())) 
[17:39:55.661]             setwd(...future.workdir)
[17:39:55.661]         {
[17:39:55.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.661]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.661]             }
[17:39:55.661]             base::options(...future.oldOptions)
[17:39:55.661]             if (.Platform$OS.type == "windows") {
[17:39:55.661]                 old_names <- names(...future.oldEnvVars)
[17:39:55.661]                 envs <- base::Sys.getenv()
[17:39:55.661]                 names <- names(envs)
[17:39:55.661]                 common <- intersect(names, old_names)
[17:39:55.661]                 added <- setdiff(names, old_names)
[17:39:55.661]                 removed <- setdiff(old_names, names)
[17:39:55.661]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.661]                   envs[common]]
[17:39:55.661]                 NAMES <- toupper(changed)
[17:39:55.661]                 args <- list()
[17:39:55.661]                 for (kk in seq_along(NAMES)) {
[17:39:55.661]                   name <- changed[[kk]]
[17:39:55.661]                   NAME <- NAMES[[kk]]
[17:39:55.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.661]                     next
[17:39:55.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.661]                 }
[17:39:55.661]                 NAMES <- toupper(added)
[17:39:55.661]                 for (kk in seq_along(NAMES)) {
[17:39:55.661]                   name <- added[[kk]]
[17:39:55.661]                   NAME <- NAMES[[kk]]
[17:39:55.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.661]                     next
[17:39:55.661]                   args[[name]] <- ""
[17:39:55.661]                 }
[17:39:55.661]                 NAMES <- toupper(removed)
[17:39:55.661]                 for (kk in seq_along(NAMES)) {
[17:39:55.661]                   name <- removed[[kk]]
[17:39:55.661]                   NAME <- NAMES[[kk]]
[17:39:55.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.661]                     next
[17:39:55.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.661]                 }
[17:39:55.661]                 if (length(args) > 0) 
[17:39:55.661]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.661]             }
[17:39:55.661]             else {
[17:39:55.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.661]             }
[17:39:55.661]             {
[17:39:55.661]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.661]                   0L) {
[17:39:55.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.661]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.661]                   base::options(opts)
[17:39:55.661]                 }
[17:39:55.661]                 {
[17:39:55.661]                   {
[17:39:55.661]                     NULL
[17:39:55.661]                     RNGkind("Mersenne-Twister")
[17:39:55.661]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.661]                       inherits = FALSE)
[17:39:55.661]                   }
[17:39:55.661]                   options(future.plan = NULL)
[17:39:55.661]                   if (is.na(NA_character_)) 
[17:39:55.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.661]                     .init = FALSE)
[17:39:55.661]                 }
[17:39:55.661]             }
[17:39:55.661]         }
[17:39:55.661]     })
[17:39:55.661]     if (TRUE) {
[17:39:55.661]         base::sink(type = "output", split = FALSE)
[17:39:55.661]         if (TRUE) {
[17:39:55.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.661]         }
[17:39:55.661]         else {
[17:39:55.661]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.661]         }
[17:39:55.661]         base::close(...future.stdout)
[17:39:55.661]         ...future.stdout <- NULL
[17:39:55.661]     }
[17:39:55.661]     ...future.result$conditions <- ...future.conditions
[17:39:55.661]     ...future.result$finished <- base::Sys.time()
[17:39:55.661]     ...future.result
[17:39:55.661] }
[17:39:55.663] assign_globals() ...
[17:39:55.663] List of 1
[17:39:55.663]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd855fe58> 
[17:39:55.663]  - attr(*, "where")=List of 1
[17:39:55.663]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.663]  - attr(*, "resolved")= logi TRUE
[17:39:55.663]  - attr(*, "total_size")= num 10424
[17:39:55.663]  - attr(*, "already-done")= logi TRUE
[17:39:55.665] - copied ‘a’ to environment
[17:39:55.665] assign_globals() ... done
[17:39:55.666] plan(): Setting new future strategy stack:
[17:39:55.666] List of future strategies:
[17:39:55.666] 1. sequential:
[17:39:55.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.666]    - tweaked: FALSE
[17:39:55.666]    - call: NULL
[17:39:55.666] plan(): nbrOfWorkers() = 1
[17:39:55.667] plan(): Setting new future strategy stack:
[17:39:55.667] List of future strategies:
[17:39:55.667] 1. sequential:
[17:39:55.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.667]    - tweaked: FALSE
[17:39:55.667]    - call: plan(strategy)
[17:39:55.667] plan(): nbrOfWorkers() = 1
[17:39:55.668] SequentialFuture started (and completed)
[17:39:55.668] - Launch lazy future ... done
[17:39:55.668] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.668] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.668] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.669] 
[17:39:55.669] Searching for globals ... DONE
[17:39:55.669] - globals: [0] <none>
[17:39:55.669] getGlobalsAndPackages() ... DONE
[17:39:55.669] run() for ‘Future’ ...
[17:39:55.669] - state: ‘created’
[17:39:55.670] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.670] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.670] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.670]   - Field: ‘label’
[17:39:55.670]   - Field: ‘local’
[17:39:55.670]   - Field: ‘owner’
[17:39:55.670]   - Field: ‘envir’
[17:39:55.670]   - Field: ‘packages’
[17:39:55.670]   - Field: ‘gc’
[17:39:55.671]   - Field: ‘conditions’
[17:39:55.671]   - Field: ‘expr’
[17:39:55.671]   - Field: ‘uuid’
[17:39:55.671]   - Field: ‘seed’
[17:39:55.671]   - Field: ‘version’
[17:39:55.671]   - Field: ‘result’
[17:39:55.671]   - Field: ‘asynchronous’
[17:39:55.671]   - Field: ‘calls’
[17:39:55.671]   - Field: ‘globals’
[17:39:55.671]   - Field: ‘stdout’
[17:39:55.671]   - Field: ‘earlySignal’
[17:39:55.672]   - Field: ‘lazy’
[17:39:55.672]   - Field: ‘state’
[17:39:55.672] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.672] - Launch lazy future ...
[17:39:55.672] Packages needed by the future expression (n = 0): <none>
[17:39:55.672] Packages needed by future strategies (n = 0): <none>
[17:39:55.672] {
[17:39:55.672]     {
[17:39:55.672]         {
[17:39:55.672]             ...future.startTime <- base::Sys.time()
[17:39:55.672]             {
[17:39:55.672]                 {
[17:39:55.672]                   {
[17:39:55.672]                     base::local({
[17:39:55.672]                       has_future <- base::requireNamespace("future", 
[17:39:55.672]                         quietly = TRUE)
[17:39:55.672]                       if (has_future) {
[17:39:55.672]                         ns <- base::getNamespace("future")
[17:39:55.672]                         version <- ns[[".package"]][["version"]]
[17:39:55.672]                         if (is.null(version)) 
[17:39:55.672]                           version <- utils::packageVersion("future")
[17:39:55.672]                       }
[17:39:55.672]                       else {
[17:39:55.672]                         version <- NULL
[17:39:55.672]                       }
[17:39:55.672]                       if (!has_future || version < "1.8.0") {
[17:39:55.672]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.672]                           "", base::R.version$version.string), 
[17:39:55.672]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.672]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.672]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.672]                             "release", "version")], collapse = " "), 
[17:39:55.672]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.672]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.672]                           info)
[17:39:55.672]                         info <- base::paste(info, collapse = "; ")
[17:39:55.672]                         if (!has_future) {
[17:39:55.672]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.672]                             info)
[17:39:55.672]                         }
[17:39:55.672]                         else {
[17:39:55.672]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.672]                             info, version)
[17:39:55.672]                         }
[17:39:55.672]                         base::stop(msg)
[17:39:55.672]                       }
[17:39:55.672]                     })
[17:39:55.672]                   }
[17:39:55.672]                   ...future.strategy.old <- future::plan("list")
[17:39:55.672]                   options(future.plan = NULL)
[17:39:55.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.672]                 }
[17:39:55.672]                 ...future.workdir <- getwd()
[17:39:55.672]             }
[17:39:55.672]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.672]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.672]         }
[17:39:55.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.672]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.672]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.672]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.672]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.672]             base::names(...future.oldOptions))
[17:39:55.672]     }
[17:39:55.672]     if (FALSE) {
[17:39:55.672]     }
[17:39:55.672]     else {
[17:39:55.672]         if (TRUE) {
[17:39:55.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.672]                 open = "w")
[17:39:55.672]         }
[17:39:55.672]         else {
[17:39:55.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.672]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.672]         }
[17:39:55.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.672]             base::sink(type = "output", split = FALSE)
[17:39:55.672]             base::close(...future.stdout)
[17:39:55.672]         }, add = TRUE)
[17:39:55.672]     }
[17:39:55.672]     ...future.frame <- base::sys.nframe()
[17:39:55.672]     ...future.conditions <- base::list()
[17:39:55.672]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.672]     if (FALSE) {
[17:39:55.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.672]     }
[17:39:55.672]     ...future.result <- base::tryCatch({
[17:39:55.672]         base::withCallingHandlers({
[17:39:55.672]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.672]             future::FutureResult(value = ...future.value$value, 
[17:39:55.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.672]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.672]                     ...future.globalenv.names))
[17:39:55.672]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.672]         }, condition = base::local({
[17:39:55.672]             c <- base::c
[17:39:55.672]             inherits <- base::inherits
[17:39:55.672]             invokeRestart <- base::invokeRestart
[17:39:55.672]             length <- base::length
[17:39:55.672]             list <- base::list
[17:39:55.672]             seq.int <- base::seq.int
[17:39:55.672]             signalCondition <- base::signalCondition
[17:39:55.672]             sys.calls <- base::sys.calls
[17:39:55.672]             `[[` <- base::`[[`
[17:39:55.672]             `+` <- base::`+`
[17:39:55.672]             `<<-` <- base::`<<-`
[17:39:55.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.672]                   3L)]
[17:39:55.672]             }
[17:39:55.672]             function(cond) {
[17:39:55.672]                 is_error <- inherits(cond, "error")
[17:39:55.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.672]                   NULL)
[17:39:55.672]                 if (is_error) {
[17:39:55.672]                   sessionInformation <- function() {
[17:39:55.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.672]                       search = base::search(), system = base::Sys.info())
[17:39:55.672]                   }
[17:39:55.672]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.672]                     cond$call), session = sessionInformation(), 
[17:39:55.672]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.672]                   signalCondition(cond)
[17:39:55.672]                 }
[17:39:55.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.672]                 "immediateCondition"))) {
[17:39:55.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.672]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.672]                   if (TRUE && !signal) {
[17:39:55.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.672]                     {
[17:39:55.672]                       inherits <- base::inherits
[17:39:55.672]                       invokeRestart <- base::invokeRestart
[17:39:55.672]                       is.null <- base::is.null
[17:39:55.672]                       muffled <- FALSE
[17:39:55.672]                       if (inherits(cond, "message")) {
[17:39:55.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.672]                         if (muffled) 
[17:39:55.672]                           invokeRestart("muffleMessage")
[17:39:55.672]                       }
[17:39:55.672]                       else if (inherits(cond, "warning")) {
[17:39:55.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.672]                         if (muffled) 
[17:39:55.672]                           invokeRestart("muffleWarning")
[17:39:55.672]                       }
[17:39:55.672]                       else if (inherits(cond, "condition")) {
[17:39:55.672]                         if (!is.null(pattern)) {
[17:39:55.672]                           computeRestarts <- base::computeRestarts
[17:39:55.672]                           grepl <- base::grepl
[17:39:55.672]                           restarts <- computeRestarts(cond)
[17:39:55.672]                           for (restart in restarts) {
[17:39:55.672]                             name <- restart$name
[17:39:55.672]                             if (is.null(name)) 
[17:39:55.672]                               next
[17:39:55.672]                             if (!grepl(pattern, name)) 
[17:39:55.672]                               next
[17:39:55.672]                             invokeRestart(restart)
[17:39:55.672]                             muffled <- TRUE
[17:39:55.672]                             break
[17:39:55.672]                           }
[17:39:55.672]                         }
[17:39:55.672]                       }
[17:39:55.672]                       invisible(muffled)
[17:39:55.672]                     }
[17:39:55.672]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.672]                   }
[17:39:55.672]                 }
[17:39:55.672]                 else {
[17:39:55.672]                   if (TRUE) {
[17:39:55.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.672]                     {
[17:39:55.672]                       inherits <- base::inherits
[17:39:55.672]                       invokeRestart <- base::invokeRestart
[17:39:55.672]                       is.null <- base::is.null
[17:39:55.672]                       muffled <- FALSE
[17:39:55.672]                       if (inherits(cond, "message")) {
[17:39:55.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.672]                         if (muffled) 
[17:39:55.672]                           invokeRestart("muffleMessage")
[17:39:55.672]                       }
[17:39:55.672]                       else if (inherits(cond, "warning")) {
[17:39:55.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.672]                         if (muffled) 
[17:39:55.672]                           invokeRestart("muffleWarning")
[17:39:55.672]                       }
[17:39:55.672]                       else if (inherits(cond, "condition")) {
[17:39:55.672]                         if (!is.null(pattern)) {
[17:39:55.672]                           computeRestarts <- base::computeRestarts
[17:39:55.672]                           grepl <- base::grepl
[17:39:55.672]                           restarts <- computeRestarts(cond)
[17:39:55.672]                           for (restart in restarts) {
[17:39:55.672]                             name <- restart$name
[17:39:55.672]                             if (is.null(name)) 
[17:39:55.672]                               next
[17:39:55.672]                             if (!grepl(pattern, name)) 
[17:39:55.672]                               next
[17:39:55.672]                             invokeRestart(restart)
[17:39:55.672]                             muffled <- TRUE
[17:39:55.672]                             break
[17:39:55.672]                           }
[17:39:55.672]                         }
[17:39:55.672]                       }
[17:39:55.672]                       invisible(muffled)
[17:39:55.672]                     }
[17:39:55.672]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.672]                   }
[17:39:55.672]                 }
[17:39:55.672]             }
[17:39:55.672]         }))
[17:39:55.672]     }, error = function(ex) {
[17:39:55.672]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.672]                 ...future.rng), started = ...future.startTime, 
[17:39:55.672]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.672]             version = "1.8"), class = "FutureResult")
[17:39:55.672]     }, finally = {
[17:39:55.672]         if (!identical(...future.workdir, getwd())) 
[17:39:55.672]             setwd(...future.workdir)
[17:39:55.672]         {
[17:39:55.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.672]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.672]             }
[17:39:55.672]             base::options(...future.oldOptions)
[17:39:55.672]             if (.Platform$OS.type == "windows") {
[17:39:55.672]                 old_names <- names(...future.oldEnvVars)
[17:39:55.672]                 envs <- base::Sys.getenv()
[17:39:55.672]                 names <- names(envs)
[17:39:55.672]                 common <- intersect(names, old_names)
[17:39:55.672]                 added <- setdiff(names, old_names)
[17:39:55.672]                 removed <- setdiff(old_names, names)
[17:39:55.672]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.672]                   envs[common]]
[17:39:55.672]                 NAMES <- toupper(changed)
[17:39:55.672]                 args <- list()
[17:39:55.672]                 for (kk in seq_along(NAMES)) {
[17:39:55.672]                   name <- changed[[kk]]
[17:39:55.672]                   NAME <- NAMES[[kk]]
[17:39:55.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.672]                     next
[17:39:55.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.672]                 }
[17:39:55.672]                 NAMES <- toupper(added)
[17:39:55.672]                 for (kk in seq_along(NAMES)) {
[17:39:55.672]                   name <- added[[kk]]
[17:39:55.672]                   NAME <- NAMES[[kk]]
[17:39:55.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.672]                     next
[17:39:55.672]                   args[[name]] <- ""
[17:39:55.672]                 }
[17:39:55.672]                 NAMES <- toupper(removed)
[17:39:55.672]                 for (kk in seq_along(NAMES)) {
[17:39:55.672]                   name <- removed[[kk]]
[17:39:55.672]                   NAME <- NAMES[[kk]]
[17:39:55.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.672]                     next
[17:39:55.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.672]                 }
[17:39:55.672]                 if (length(args) > 0) 
[17:39:55.672]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.672]             }
[17:39:55.672]             else {
[17:39:55.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.672]             }
[17:39:55.672]             {
[17:39:55.672]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.672]                   0L) {
[17:39:55.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.672]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.672]                   base::options(opts)
[17:39:55.672]                 }
[17:39:55.672]                 {
[17:39:55.672]                   {
[17:39:55.672]                     NULL
[17:39:55.672]                     RNGkind("Mersenne-Twister")
[17:39:55.672]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.672]                       inherits = FALSE)
[17:39:55.672]                   }
[17:39:55.672]                   options(future.plan = NULL)
[17:39:55.672]                   if (is.na(NA_character_)) 
[17:39:55.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.672]                     .init = FALSE)
[17:39:55.672]                 }
[17:39:55.672]             }
[17:39:55.672]         }
[17:39:55.672]     })
[17:39:55.672]     if (TRUE) {
[17:39:55.672]         base::sink(type = "output", split = FALSE)
[17:39:55.672]         if (TRUE) {
[17:39:55.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.672]         }
[17:39:55.672]         else {
[17:39:55.672]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.672]         }
[17:39:55.672]         base::close(...future.stdout)
[17:39:55.672]         ...future.stdout <- NULL
[17:39:55.672]     }
[17:39:55.672]     ...future.result$conditions <- ...future.conditions
[17:39:55.672]     ...future.result$finished <- base::Sys.time()
[17:39:55.672]     ...future.result
[17:39:55.672] }
[17:39:55.674] plan(): Setting new future strategy stack:
[17:39:55.674] List of future strategies:
[17:39:55.674] 1. sequential:
[17:39:55.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.674]    - tweaked: FALSE
[17:39:55.674]    - call: NULL
[17:39:55.675] plan(): nbrOfWorkers() = 1
[17:39:55.675] plan(): Setting new future strategy stack:
[17:39:55.675] List of future strategies:
[17:39:55.675] 1. sequential:
[17:39:55.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.675]    - tweaked: FALSE
[17:39:55.675]    - call: plan(strategy)
[17:39:55.676] plan(): nbrOfWorkers() = 1
[17:39:55.676] SequentialFuture started (and completed)
[17:39:55.676] - Launch lazy future ... done
[17:39:55.676] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.676] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.677] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.677] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.677] Searching for globals ... DONE
[17:39:55.678] Resolving globals: TRUE
[17:39:55.678] Resolving any globals that are futures ...
[17:39:55.678] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.678] Resolving any globals that are futures ... DONE
[17:39:55.678] Resolving futures part of globals (recursively) ...
[17:39:55.678] resolve() on list ...
[17:39:55.678]  recursive: 99
[17:39:55.678]  length: 1
[17:39:55.679]  elements: ‘a’
[17:39:55.679] resolved() for ‘SequentialFuture’ ...
[17:39:55.679] - state: ‘finished’
[17:39:55.679] - run: TRUE
[17:39:55.679] - result: ‘FutureResult’
[17:39:55.679] resolved() for ‘SequentialFuture’ ... done
[17:39:55.679] Future #1
[17:39:55.679] resolved() for ‘SequentialFuture’ ...
[17:39:55.679] - state: ‘finished’
[17:39:55.679] - run: TRUE
[17:39:55.680] - result: ‘FutureResult’
[17:39:55.680] resolved() for ‘SequentialFuture’ ... done
[17:39:55.680] A SequentialFuture was resolved
[17:39:55.681]  length: 0 (resolved future 1)
[17:39:55.681] resolve() on list ... DONE
[17:39:55.681] - globals: [1] ‘a’
[17:39:55.681] Resolving futures part of globals (recursively) ... DONE
[17:39:55.682] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:39:55.682] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:39:55.682] - globals: [1] ‘a’
[17:39:55.683] - packages: [1] ‘future’
[17:39:55.683] getGlobalsAndPackages() ... DONE
[17:39:55.683] run() for ‘Future’ ...
[17:39:55.683] - state: ‘created’
[17:39:55.683] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.683] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.684]   - Field: ‘label’
[17:39:55.684]   - Field: ‘local’
[17:39:55.684]   - Field: ‘owner’
[17:39:55.684]   - Field: ‘envir’
[17:39:55.684]   - Field: ‘packages’
[17:39:55.684]   - Field: ‘gc’
[17:39:55.684]   - Field: ‘conditions’
[17:39:55.684]   - Field: ‘expr’
[17:39:55.684]   - Field: ‘uuid’
[17:39:55.684]   - Field: ‘seed’
[17:39:55.684]   - Field: ‘version’
[17:39:55.685]   - Field: ‘result’
[17:39:55.685]   - Field: ‘asynchronous’
[17:39:55.685]   - Field: ‘calls’
[17:39:55.685]   - Field: ‘globals’
[17:39:55.685]   - Field: ‘stdout’
[17:39:55.685]   - Field: ‘earlySignal’
[17:39:55.685]   - Field: ‘lazy’
[17:39:55.685]   - Field: ‘state’
[17:39:55.685] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.685] - Launch lazy future ...
[17:39:55.685] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.686] Packages needed by future strategies (n = 0): <none>
[17:39:55.686] {
[17:39:55.686]     {
[17:39:55.686]         {
[17:39:55.686]             ...future.startTime <- base::Sys.time()
[17:39:55.686]             {
[17:39:55.686]                 {
[17:39:55.686]                   {
[17:39:55.686]                     {
[17:39:55.686]                       base::local({
[17:39:55.686]                         has_future <- base::requireNamespace("future", 
[17:39:55.686]                           quietly = TRUE)
[17:39:55.686]                         if (has_future) {
[17:39:55.686]                           ns <- base::getNamespace("future")
[17:39:55.686]                           version <- ns[[".package"]][["version"]]
[17:39:55.686]                           if (is.null(version)) 
[17:39:55.686]                             version <- utils::packageVersion("future")
[17:39:55.686]                         }
[17:39:55.686]                         else {
[17:39:55.686]                           version <- NULL
[17:39:55.686]                         }
[17:39:55.686]                         if (!has_future || version < "1.8.0") {
[17:39:55.686]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.686]                             "", base::R.version$version.string), 
[17:39:55.686]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.686]                               "release", "version")], collapse = " "), 
[17:39:55.686]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.686]                             info)
[17:39:55.686]                           info <- base::paste(info, collapse = "; ")
[17:39:55.686]                           if (!has_future) {
[17:39:55.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.686]                               info)
[17:39:55.686]                           }
[17:39:55.686]                           else {
[17:39:55.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.686]                               info, version)
[17:39:55.686]                           }
[17:39:55.686]                           base::stop(msg)
[17:39:55.686]                         }
[17:39:55.686]                       })
[17:39:55.686]                     }
[17:39:55.686]                     base::local({
[17:39:55.686]                       for (pkg in "future") {
[17:39:55.686]                         base::loadNamespace(pkg)
[17:39:55.686]                         base::library(pkg, character.only = TRUE)
[17:39:55.686]                       }
[17:39:55.686]                     })
[17:39:55.686]                   }
[17:39:55.686]                   ...future.strategy.old <- future::plan("list")
[17:39:55.686]                   options(future.plan = NULL)
[17:39:55.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.686]                 }
[17:39:55.686]                 ...future.workdir <- getwd()
[17:39:55.686]             }
[17:39:55.686]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.686]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.686]         }
[17:39:55.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.686]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.686]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.686]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.686]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.686]             base::names(...future.oldOptions))
[17:39:55.686]     }
[17:39:55.686]     if (FALSE) {
[17:39:55.686]     }
[17:39:55.686]     else {
[17:39:55.686]         if (TRUE) {
[17:39:55.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.686]                 open = "w")
[17:39:55.686]         }
[17:39:55.686]         else {
[17:39:55.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.686]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.686]         }
[17:39:55.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.686]             base::sink(type = "output", split = FALSE)
[17:39:55.686]             base::close(...future.stdout)
[17:39:55.686]         }, add = TRUE)
[17:39:55.686]     }
[17:39:55.686]     ...future.frame <- base::sys.nframe()
[17:39:55.686]     ...future.conditions <- base::list()
[17:39:55.686]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.686]     if (FALSE) {
[17:39:55.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.686]     }
[17:39:55.686]     ...future.result <- base::tryCatch({
[17:39:55.686]         base::withCallingHandlers({
[17:39:55.686]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.686]                 1))
[17:39:55.686]             future::FutureResult(value = ...future.value$value, 
[17:39:55.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.686]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.686]                     ...future.globalenv.names))
[17:39:55.686]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.686]         }, condition = base::local({
[17:39:55.686]             c <- base::c
[17:39:55.686]             inherits <- base::inherits
[17:39:55.686]             invokeRestart <- base::invokeRestart
[17:39:55.686]             length <- base::length
[17:39:55.686]             list <- base::list
[17:39:55.686]             seq.int <- base::seq.int
[17:39:55.686]             signalCondition <- base::signalCondition
[17:39:55.686]             sys.calls <- base::sys.calls
[17:39:55.686]             `[[` <- base::`[[`
[17:39:55.686]             `+` <- base::`+`
[17:39:55.686]             `<<-` <- base::`<<-`
[17:39:55.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.686]                   3L)]
[17:39:55.686]             }
[17:39:55.686]             function(cond) {
[17:39:55.686]                 is_error <- inherits(cond, "error")
[17:39:55.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.686]                   NULL)
[17:39:55.686]                 if (is_error) {
[17:39:55.686]                   sessionInformation <- function() {
[17:39:55.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.686]                       search = base::search(), system = base::Sys.info())
[17:39:55.686]                   }
[17:39:55.686]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.686]                     cond$call), session = sessionInformation(), 
[17:39:55.686]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.686]                   signalCondition(cond)
[17:39:55.686]                 }
[17:39:55.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.686]                 "immediateCondition"))) {
[17:39:55.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.686]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.686]                   if (TRUE && !signal) {
[17:39:55.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.686]                     {
[17:39:55.686]                       inherits <- base::inherits
[17:39:55.686]                       invokeRestart <- base::invokeRestart
[17:39:55.686]                       is.null <- base::is.null
[17:39:55.686]                       muffled <- FALSE
[17:39:55.686]                       if (inherits(cond, "message")) {
[17:39:55.686]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.686]                         if (muffled) 
[17:39:55.686]                           invokeRestart("muffleMessage")
[17:39:55.686]                       }
[17:39:55.686]                       else if (inherits(cond, "warning")) {
[17:39:55.686]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.686]                         if (muffled) 
[17:39:55.686]                           invokeRestart("muffleWarning")
[17:39:55.686]                       }
[17:39:55.686]                       else if (inherits(cond, "condition")) {
[17:39:55.686]                         if (!is.null(pattern)) {
[17:39:55.686]                           computeRestarts <- base::computeRestarts
[17:39:55.686]                           grepl <- base::grepl
[17:39:55.686]                           restarts <- computeRestarts(cond)
[17:39:55.686]                           for (restart in restarts) {
[17:39:55.686]                             name <- restart$name
[17:39:55.686]                             if (is.null(name)) 
[17:39:55.686]                               next
[17:39:55.686]                             if (!grepl(pattern, name)) 
[17:39:55.686]                               next
[17:39:55.686]                             invokeRestart(restart)
[17:39:55.686]                             muffled <- TRUE
[17:39:55.686]                             break
[17:39:55.686]                           }
[17:39:55.686]                         }
[17:39:55.686]                       }
[17:39:55.686]                       invisible(muffled)
[17:39:55.686]                     }
[17:39:55.686]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.686]                   }
[17:39:55.686]                 }
[17:39:55.686]                 else {
[17:39:55.686]                   if (TRUE) {
[17:39:55.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.686]                     {
[17:39:55.686]                       inherits <- base::inherits
[17:39:55.686]                       invokeRestart <- base::invokeRestart
[17:39:55.686]                       is.null <- base::is.null
[17:39:55.686]                       muffled <- FALSE
[17:39:55.686]                       if (inherits(cond, "message")) {
[17:39:55.686]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.686]                         if (muffled) 
[17:39:55.686]                           invokeRestart("muffleMessage")
[17:39:55.686]                       }
[17:39:55.686]                       else if (inherits(cond, "warning")) {
[17:39:55.686]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.686]                         if (muffled) 
[17:39:55.686]                           invokeRestart("muffleWarning")
[17:39:55.686]                       }
[17:39:55.686]                       else if (inherits(cond, "condition")) {
[17:39:55.686]                         if (!is.null(pattern)) {
[17:39:55.686]                           computeRestarts <- base::computeRestarts
[17:39:55.686]                           grepl <- base::grepl
[17:39:55.686]                           restarts <- computeRestarts(cond)
[17:39:55.686]                           for (restart in restarts) {
[17:39:55.686]                             name <- restart$name
[17:39:55.686]                             if (is.null(name)) 
[17:39:55.686]                               next
[17:39:55.686]                             if (!grepl(pattern, name)) 
[17:39:55.686]                               next
[17:39:55.686]                             invokeRestart(restart)
[17:39:55.686]                             muffled <- TRUE
[17:39:55.686]                             break
[17:39:55.686]                           }
[17:39:55.686]                         }
[17:39:55.686]                       }
[17:39:55.686]                       invisible(muffled)
[17:39:55.686]                     }
[17:39:55.686]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.686]                   }
[17:39:55.686]                 }
[17:39:55.686]             }
[17:39:55.686]         }))
[17:39:55.686]     }, error = function(ex) {
[17:39:55.686]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.686]                 ...future.rng), started = ...future.startTime, 
[17:39:55.686]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.686]             version = "1.8"), class = "FutureResult")
[17:39:55.686]     }, finally = {
[17:39:55.686]         if (!identical(...future.workdir, getwd())) 
[17:39:55.686]             setwd(...future.workdir)
[17:39:55.686]         {
[17:39:55.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.686]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.686]             }
[17:39:55.686]             base::options(...future.oldOptions)
[17:39:55.686]             if (.Platform$OS.type == "windows") {
[17:39:55.686]                 old_names <- names(...future.oldEnvVars)
[17:39:55.686]                 envs <- base::Sys.getenv()
[17:39:55.686]                 names <- names(envs)
[17:39:55.686]                 common <- intersect(names, old_names)
[17:39:55.686]                 added <- setdiff(names, old_names)
[17:39:55.686]                 removed <- setdiff(old_names, names)
[17:39:55.686]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.686]                   envs[common]]
[17:39:55.686]                 NAMES <- toupper(changed)
[17:39:55.686]                 args <- list()
[17:39:55.686]                 for (kk in seq_along(NAMES)) {
[17:39:55.686]                   name <- changed[[kk]]
[17:39:55.686]                   NAME <- NAMES[[kk]]
[17:39:55.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.686]                     next
[17:39:55.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.686]                 }
[17:39:55.686]                 NAMES <- toupper(added)
[17:39:55.686]                 for (kk in seq_along(NAMES)) {
[17:39:55.686]                   name <- added[[kk]]
[17:39:55.686]                   NAME <- NAMES[[kk]]
[17:39:55.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.686]                     next
[17:39:55.686]                   args[[name]] <- ""
[17:39:55.686]                 }
[17:39:55.686]                 NAMES <- toupper(removed)
[17:39:55.686]                 for (kk in seq_along(NAMES)) {
[17:39:55.686]                   name <- removed[[kk]]
[17:39:55.686]                   NAME <- NAMES[[kk]]
[17:39:55.686]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.686]                     next
[17:39:55.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.686]                 }
[17:39:55.686]                 if (length(args) > 0) 
[17:39:55.686]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.686]             }
[17:39:55.686]             else {
[17:39:55.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.686]             }
[17:39:55.686]             {
[17:39:55.686]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.686]                   0L) {
[17:39:55.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.686]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.686]                   base::options(opts)
[17:39:55.686]                 }
[17:39:55.686]                 {
[17:39:55.686]                   {
[17:39:55.686]                     NULL
[17:39:55.686]                     RNGkind("Mersenne-Twister")
[17:39:55.686]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.686]                       inherits = FALSE)
[17:39:55.686]                   }
[17:39:55.686]                   options(future.plan = NULL)
[17:39:55.686]                   if (is.na(NA_character_)) 
[17:39:55.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.686]                     .init = FALSE)
[17:39:55.686]                 }
[17:39:55.686]             }
[17:39:55.686]         }
[17:39:55.686]     })
[17:39:55.686]     if (TRUE) {
[17:39:55.686]         base::sink(type = "output", split = FALSE)
[17:39:55.686]         if (TRUE) {
[17:39:55.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.686]         }
[17:39:55.686]         else {
[17:39:55.686]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.686]         }
[17:39:55.686]         base::close(...future.stdout)
[17:39:55.686]         ...future.stdout <- NULL
[17:39:55.686]     }
[17:39:55.686]     ...future.result$conditions <- ...future.conditions
[17:39:55.686]     ...future.result$finished <- base::Sys.time()
[17:39:55.686]     ...future.result
[17:39:55.686] }
[17:39:55.688] assign_globals() ...
[17:39:55.688] List of 1
[17:39:55.688]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd82f1ae0> 
[17:39:55.688]  - attr(*, "where")=List of 1
[17:39:55.688]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.688]  - attr(*, "resolved")= logi TRUE
[17:39:55.688]  - attr(*, "total_size")= num 10424
[17:39:55.688]  - attr(*, "already-done")= logi TRUE
[17:39:55.690] - copied ‘a’ to environment
[17:39:55.690] assign_globals() ... done
[17:39:55.690] plan(): Setting new future strategy stack:
[17:39:55.690] List of future strategies:
[17:39:55.690] 1. sequential:
[17:39:55.690]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.690]    - tweaked: FALSE
[17:39:55.690]    - call: NULL
[17:39:55.691] plan(): nbrOfWorkers() = 1
[17:39:55.692] plan(): Setting new future strategy stack:
[17:39:55.692] List of future strategies:
[17:39:55.692] 1. sequential:
[17:39:55.692]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.692]    - tweaked: FALSE
[17:39:55.692]    - call: plan(strategy)
[17:39:55.692] plan(): nbrOfWorkers() = 1
[17:39:55.692] SequentialFuture started (and completed)
[17:39:55.692] - Launch lazy future ... done
[17:39:55.692] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.693] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.693] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.693] 
[17:39:55.694] Searching for globals ... DONE
[17:39:55.694] - globals: [0] <none>
[17:39:55.694] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.694] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.694] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.695] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.695] Searching for globals ... DONE
[17:39:55.695] Resolving globals: TRUE
[17:39:55.695] Resolving any globals that are futures ...
[17:39:55.695] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.696] Resolving any globals that are futures ... DONE
[17:39:55.696] Resolving futures part of globals (recursively) ...
[17:39:55.696] resolve() on list ...
[17:39:55.696]  recursive: 99
[17:39:55.696]  length: 1
[17:39:55.696]  elements: ‘a’
[17:39:55.696] run() for ‘Future’ ...
[17:39:55.696] - state: ‘created’
[17:39:55.697] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.697] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.697]   - Field: ‘label’
[17:39:55.697]   - Field: ‘local’
[17:39:55.697]   - Field: ‘owner’
[17:39:55.697]   - Field: ‘envir’
[17:39:55.697]   - Field: ‘packages’
[17:39:55.697]   - Field: ‘gc’
[17:39:55.698]   - Field: ‘conditions’
[17:39:55.698]   - Field: ‘expr’
[17:39:55.698]   - Field: ‘uuid’
[17:39:55.698]   - Field: ‘seed’
[17:39:55.698]   - Field: ‘version’
[17:39:55.698]   - Field: ‘result’
[17:39:55.698]   - Field: ‘asynchronous’
[17:39:55.698]   - Field: ‘calls’
[17:39:55.698]   - Field: ‘globals’
[17:39:55.698]   - Field: ‘stdout’
[17:39:55.698]   - Field: ‘earlySignal’
[17:39:55.699]   - Field: ‘lazy’
[17:39:55.699]   - Field: ‘state’
[17:39:55.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.699] - Launch lazy future ...
[17:39:55.699] Packages needed by the future expression (n = 0): <none>
[17:39:55.699] Packages needed by future strategies (n = 0): <none>
[17:39:55.699] {
[17:39:55.699]     {
[17:39:55.699]         {
[17:39:55.699]             ...future.startTime <- base::Sys.time()
[17:39:55.699]             {
[17:39:55.699]                 {
[17:39:55.699]                   {
[17:39:55.699]                     base::local({
[17:39:55.699]                       has_future <- base::requireNamespace("future", 
[17:39:55.699]                         quietly = TRUE)
[17:39:55.699]                       if (has_future) {
[17:39:55.699]                         ns <- base::getNamespace("future")
[17:39:55.699]                         version <- ns[[".package"]][["version"]]
[17:39:55.699]                         if (is.null(version)) 
[17:39:55.699]                           version <- utils::packageVersion("future")
[17:39:55.699]                       }
[17:39:55.699]                       else {
[17:39:55.699]                         version <- NULL
[17:39:55.699]                       }
[17:39:55.699]                       if (!has_future || version < "1.8.0") {
[17:39:55.699]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.699]                           "", base::R.version$version.string), 
[17:39:55.699]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.699]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.699]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.699]                             "release", "version")], collapse = " "), 
[17:39:55.699]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.699]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.699]                           info)
[17:39:55.699]                         info <- base::paste(info, collapse = "; ")
[17:39:55.699]                         if (!has_future) {
[17:39:55.699]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.699]                             info)
[17:39:55.699]                         }
[17:39:55.699]                         else {
[17:39:55.699]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.699]                             info, version)
[17:39:55.699]                         }
[17:39:55.699]                         base::stop(msg)
[17:39:55.699]                       }
[17:39:55.699]                     })
[17:39:55.699]                   }
[17:39:55.699]                   ...future.strategy.old <- future::plan("list")
[17:39:55.699]                   options(future.plan = NULL)
[17:39:55.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.699]                 }
[17:39:55.699]                 ...future.workdir <- getwd()
[17:39:55.699]             }
[17:39:55.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.699]         }
[17:39:55.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.699]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.699]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.699]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.699]             base::names(...future.oldOptions))
[17:39:55.699]     }
[17:39:55.699]     if (FALSE) {
[17:39:55.699]     }
[17:39:55.699]     else {
[17:39:55.699]         if (TRUE) {
[17:39:55.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.699]                 open = "w")
[17:39:55.699]         }
[17:39:55.699]         else {
[17:39:55.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.699]         }
[17:39:55.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.699]             base::sink(type = "output", split = FALSE)
[17:39:55.699]             base::close(...future.stdout)
[17:39:55.699]         }, add = TRUE)
[17:39:55.699]     }
[17:39:55.699]     ...future.frame <- base::sys.nframe()
[17:39:55.699]     ...future.conditions <- base::list()
[17:39:55.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.699]     if (FALSE) {
[17:39:55.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.699]     }
[17:39:55.699]     ...future.result <- base::tryCatch({
[17:39:55.699]         base::withCallingHandlers({
[17:39:55.699]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.699]             future::FutureResult(value = ...future.value$value, 
[17:39:55.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.699]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.699]                     ...future.globalenv.names))
[17:39:55.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.699]         }, condition = base::local({
[17:39:55.699]             c <- base::c
[17:39:55.699]             inherits <- base::inherits
[17:39:55.699]             invokeRestart <- base::invokeRestart
[17:39:55.699]             length <- base::length
[17:39:55.699]             list <- base::list
[17:39:55.699]             seq.int <- base::seq.int
[17:39:55.699]             signalCondition <- base::signalCondition
[17:39:55.699]             sys.calls <- base::sys.calls
[17:39:55.699]             `[[` <- base::`[[`
[17:39:55.699]             `+` <- base::`+`
[17:39:55.699]             `<<-` <- base::`<<-`
[17:39:55.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.699]                   3L)]
[17:39:55.699]             }
[17:39:55.699]             function(cond) {
[17:39:55.699]                 is_error <- inherits(cond, "error")
[17:39:55.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.699]                   NULL)
[17:39:55.699]                 if (is_error) {
[17:39:55.699]                   sessionInformation <- function() {
[17:39:55.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.699]                       search = base::search(), system = base::Sys.info())
[17:39:55.699]                   }
[17:39:55.699]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.699]                     cond$call), session = sessionInformation(), 
[17:39:55.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.699]                   signalCondition(cond)
[17:39:55.699]                 }
[17:39:55.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.699]                 "immediateCondition"))) {
[17:39:55.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.699]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.699]                   if (TRUE && !signal) {
[17:39:55.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.699]                     {
[17:39:55.699]                       inherits <- base::inherits
[17:39:55.699]                       invokeRestart <- base::invokeRestart
[17:39:55.699]                       is.null <- base::is.null
[17:39:55.699]                       muffled <- FALSE
[17:39:55.699]                       if (inherits(cond, "message")) {
[17:39:55.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.699]                         if (muffled) 
[17:39:55.699]                           invokeRestart("muffleMessage")
[17:39:55.699]                       }
[17:39:55.699]                       else if (inherits(cond, "warning")) {
[17:39:55.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.699]                         if (muffled) 
[17:39:55.699]                           invokeRestart("muffleWarning")
[17:39:55.699]                       }
[17:39:55.699]                       else if (inherits(cond, "condition")) {
[17:39:55.699]                         if (!is.null(pattern)) {
[17:39:55.699]                           computeRestarts <- base::computeRestarts
[17:39:55.699]                           grepl <- base::grepl
[17:39:55.699]                           restarts <- computeRestarts(cond)
[17:39:55.699]                           for (restart in restarts) {
[17:39:55.699]                             name <- restart$name
[17:39:55.699]                             if (is.null(name)) 
[17:39:55.699]                               next
[17:39:55.699]                             if (!grepl(pattern, name)) 
[17:39:55.699]                               next
[17:39:55.699]                             invokeRestart(restart)
[17:39:55.699]                             muffled <- TRUE
[17:39:55.699]                             break
[17:39:55.699]                           }
[17:39:55.699]                         }
[17:39:55.699]                       }
[17:39:55.699]                       invisible(muffled)
[17:39:55.699]                     }
[17:39:55.699]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.699]                   }
[17:39:55.699]                 }
[17:39:55.699]                 else {
[17:39:55.699]                   if (TRUE) {
[17:39:55.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.699]                     {
[17:39:55.699]                       inherits <- base::inherits
[17:39:55.699]                       invokeRestart <- base::invokeRestart
[17:39:55.699]                       is.null <- base::is.null
[17:39:55.699]                       muffled <- FALSE
[17:39:55.699]                       if (inherits(cond, "message")) {
[17:39:55.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.699]                         if (muffled) 
[17:39:55.699]                           invokeRestart("muffleMessage")
[17:39:55.699]                       }
[17:39:55.699]                       else if (inherits(cond, "warning")) {
[17:39:55.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.699]                         if (muffled) 
[17:39:55.699]                           invokeRestart("muffleWarning")
[17:39:55.699]                       }
[17:39:55.699]                       else if (inherits(cond, "condition")) {
[17:39:55.699]                         if (!is.null(pattern)) {
[17:39:55.699]                           computeRestarts <- base::computeRestarts
[17:39:55.699]                           grepl <- base::grepl
[17:39:55.699]                           restarts <- computeRestarts(cond)
[17:39:55.699]                           for (restart in restarts) {
[17:39:55.699]                             name <- restart$name
[17:39:55.699]                             if (is.null(name)) 
[17:39:55.699]                               next
[17:39:55.699]                             if (!grepl(pattern, name)) 
[17:39:55.699]                               next
[17:39:55.699]                             invokeRestart(restart)
[17:39:55.699]                             muffled <- TRUE
[17:39:55.699]                             break
[17:39:55.699]                           }
[17:39:55.699]                         }
[17:39:55.699]                       }
[17:39:55.699]                       invisible(muffled)
[17:39:55.699]                     }
[17:39:55.699]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.699]                   }
[17:39:55.699]                 }
[17:39:55.699]             }
[17:39:55.699]         }))
[17:39:55.699]     }, error = function(ex) {
[17:39:55.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.699]                 ...future.rng), started = ...future.startTime, 
[17:39:55.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.699]             version = "1.8"), class = "FutureResult")
[17:39:55.699]     }, finally = {
[17:39:55.699]         if (!identical(...future.workdir, getwd())) 
[17:39:55.699]             setwd(...future.workdir)
[17:39:55.699]         {
[17:39:55.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.699]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.699]             }
[17:39:55.699]             base::options(...future.oldOptions)
[17:39:55.699]             if (.Platform$OS.type == "windows") {
[17:39:55.699]                 old_names <- names(...future.oldEnvVars)
[17:39:55.699]                 envs <- base::Sys.getenv()
[17:39:55.699]                 names <- names(envs)
[17:39:55.699]                 common <- intersect(names, old_names)
[17:39:55.699]                 added <- setdiff(names, old_names)
[17:39:55.699]                 removed <- setdiff(old_names, names)
[17:39:55.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.699]                   envs[common]]
[17:39:55.699]                 NAMES <- toupper(changed)
[17:39:55.699]                 args <- list()
[17:39:55.699]                 for (kk in seq_along(NAMES)) {
[17:39:55.699]                   name <- changed[[kk]]
[17:39:55.699]                   NAME <- NAMES[[kk]]
[17:39:55.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.699]                     next
[17:39:55.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.699]                 }
[17:39:55.699]                 NAMES <- toupper(added)
[17:39:55.699]                 for (kk in seq_along(NAMES)) {
[17:39:55.699]                   name <- added[[kk]]
[17:39:55.699]                   NAME <- NAMES[[kk]]
[17:39:55.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.699]                     next
[17:39:55.699]                   args[[name]] <- ""
[17:39:55.699]                 }
[17:39:55.699]                 NAMES <- toupper(removed)
[17:39:55.699]                 for (kk in seq_along(NAMES)) {
[17:39:55.699]                   name <- removed[[kk]]
[17:39:55.699]                   NAME <- NAMES[[kk]]
[17:39:55.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.699]                     next
[17:39:55.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.699]                 }
[17:39:55.699]                 if (length(args) > 0) 
[17:39:55.699]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.699]             }
[17:39:55.699]             else {
[17:39:55.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.699]             }
[17:39:55.699]             {
[17:39:55.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.699]                   0L) {
[17:39:55.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.699]                   base::options(opts)
[17:39:55.699]                 }
[17:39:55.699]                 {
[17:39:55.699]                   {
[17:39:55.699]                     NULL
[17:39:55.699]                     RNGkind("Mersenne-Twister")
[17:39:55.699]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.699]                       inherits = FALSE)
[17:39:55.699]                   }
[17:39:55.699]                   options(future.plan = NULL)
[17:39:55.699]                   if (is.na(NA_character_)) 
[17:39:55.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.699]                     .init = FALSE)
[17:39:55.699]                 }
[17:39:55.699]             }
[17:39:55.699]         }
[17:39:55.699]     })
[17:39:55.699]     if (TRUE) {
[17:39:55.699]         base::sink(type = "output", split = FALSE)
[17:39:55.699]         if (TRUE) {
[17:39:55.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.699]         }
[17:39:55.699]         else {
[17:39:55.699]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.699]         }
[17:39:55.699]         base::close(...future.stdout)
[17:39:55.699]         ...future.stdout <- NULL
[17:39:55.699]     }
[17:39:55.699]     ...future.result$conditions <- ...future.conditions
[17:39:55.699]     ...future.result$finished <- base::Sys.time()
[17:39:55.699]     ...future.result
[17:39:55.699] }
[17:39:55.701] plan(): Setting new future strategy stack:
[17:39:55.701] List of future strategies:
[17:39:55.701] 1. sequential:
[17:39:55.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.701]    - tweaked: FALSE
[17:39:55.701]    - call: NULL
[17:39:55.702] plan(): nbrOfWorkers() = 1
[17:39:55.702] plan(): Setting new future strategy stack:
[17:39:55.702] List of future strategies:
[17:39:55.702] 1. sequential:
[17:39:55.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.702]    - tweaked: FALSE
[17:39:55.702]    - call: plan(strategy)
[17:39:55.703] plan(): nbrOfWorkers() = 1
[17:39:55.703] SequentialFuture started (and completed)
[17:39:55.703] - Launch lazy future ... done
[17:39:55.703] run() for ‘SequentialFuture’ ... done
[17:39:55.703] resolved() for ‘SequentialFuture’ ...
[17:39:55.703] - state: ‘finished’
[17:39:55.703] - run: TRUE
[17:39:55.704] - result: ‘FutureResult’
[17:39:55.704] resolved() for ‘SequentialFuture’ ... done
[17:39:55.704] Future #1
[17:39:55.704] resolved() for ‘SequentialFuture’ ...
[17:39:55.704] - state: ‘finished’
[17:39:55.704] - run: TRUE
[17:39:55.704] - result: ‘FutureResult’
[17:39:55.704] resolved() for ‘SequentialFuture’ ... done
[17:39:55.704] A SequentialFuture was resolved
[17:39:55.704]  length: 0 (resolved future 1)
[17:39:55.704] resolve() on list ... DONE
[17:39:55.705] - globals: [1] ‘a’
[17:39:55.705] Resolving futures part of globals (recursively) ... DONE
[17:39:55.705] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:39:55.706] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:39:55.706] - globals: [1] ‘a’
[17:39:55.706] - packages: [1] ‘future’
[17:39:55.706] getGlobalsAndPackages() ... DONE
[17:39:55.706] run() for ‘Future’ ...
[17:39:55.706] - state: ‘created’
[17:39:55.706] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.707]   - Field: ‘label’
[17:39:55.707]   - Field: ‘local’
[17:39:55.709]   - Field: ‘owner’
[17:39:55.709]   - Field: ‘envir’
[17:39:55.709]   - Field: ‘packages’
[17:39:55.709]   - Field: ‘gc’
[17:39:55.709]   - Field: ‘conditions’
[17:39:55.709]   - Field: ‘expr’
[17:39:55.709]   - Field: ‘uuid’
[17:39:55.709]   - Field: ‘seed’
[17:39:55.709]   - Field: ‘version’
[17:39:55.709]   - Field: ‘result’
[17:39:55.709]   - Field: ‘asynchronous’
[17:39:55.710]   - Field: ‘calls’
[17:39:55.710]   - Field: ‘globals’
[17:39:55.710]   - Field: ‘stdout’
[17:39:55.710]   - Field: ‘earlySignal’
[17:39:55.710]   - Field: ‘lazy’
[17:39:55.710]   - Field: ‘state’
[17:39:55.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.710] - Launch lazy future ...
[17:39:55.710] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.710] Packages needed by future strategies (n = 0): <none>
[17:39:55.711] {
[17:39:55.711]     {
[17:39:55.711]         {
[17:39:55.711]             ...future.startTime <- base::Sys.time()
[17:39:55.711]             {
[17:39:55.711]                 {
[17:39:55.711]                   {
[17:39:55.711]                     {
[17:39:55.711]                       base::local({
[17:39:55.711]                         has_future <- base::requireNamespace("future", 
[17:39:55.711]                           quietly = TRUE)
[17:39:55.711]                         if (has_future) {
[17:39:55.711]                           ns <- base::getNamespace("future")
[17:39:55.711]                           version <- ns[[".package"]][["version"]]
[17:39:55.711]                           if (is.null(version)) 
[17:39:55.711]                             version <- utils::packageVersion("future")
[17:39:55.711]                         }
[17:39:55.711]                         else {
[17:39:55.711]                           version <- NULL
[17:39:55.711]                         }
[17:39:55.711]                         if (!has_future || version < "1.8.0") {
[17:39:55.711]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.711]                             "", base::R.version$version.string), 
[17:39:55.711]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.711]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.711]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.711]                               "release", "version")], collapse = " "), 
[17:39:55.711]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.711]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.711]                             info)
[17:39:55.711]                           info <- base::paste(info, collapse = "; ")
[17:39:55.711]                           if (!has_future) {
[17:39:55.711]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.711]                               info)
[17:39:55.711]                           }
[17:39:55.711]                           else {
[17:39:55.711]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.711]                               info, version)
[17:39:55.711]                           }
[17:39:55.711]                           base::stop(msg)
[17:39:55.711]                         }
[17:39:55.711]                       })
[17:39:55.711]                     }
[17:39:55.711]                     base::local({
[17:39:55.711]                       for (pkg in "future") {
[17:39:55.711]                         base::loadNamespace(pkg)
[17:39:55.711]                         base::library(pkg, character.only = TRUE)
[17:39:55.711]                       }
[17:39:55.711]                     })
[17:39:55.711]                   }
[17:39:55.711]                   ...future.strategy.old <- future::plan("list")
[17:39:55.711]                   options(future.plan = NULL)
[17:39:55.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.711]                 }
[17:39:55.711]                 ...future.workdir <- getwd()
[17:39:55.711]             }
[17:39:55.711]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.711]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.711]         }
[17:39:55.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.711]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.711]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.711]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.711]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.711]             base::names(...future.oldOptions))
[17:39:55.711]     }
[17:39:55.711]     if (FALSE) {
[17:39:55.711]     }
[17:39:55.711]     else {
[17:39:55.711]         if (TRUE) {
[17:39:55.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.711]                 open = "w")
[17:39:55.711]         }
[17:39:55.711]         else {
[17:39:55.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.711]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.711]         }
[17:39:55.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.711]             base::sink(type = "output", split = FALSE)
[17:39:55.711]             base::close(...future.stdout)
[17:39:55.711]         }, add = TRUE)
[17:39:55.711]     }
[17:39:55.711]     ...future.frame <- base::sys.nframe()
[17:39:55.711]     ...future.conditions <- base::list()
[17:39:55.711]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.711]     if (FALSE) {
[17:39:55.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.711]     }
[17:39:55.711]     ...future.result <- base::tryCatch({
[17:39:55.711]         base::withCallingHandlers({
[17:39:55.711]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.711]                 1))
[17:39:55.711]             future::FutureResult(value = ...future.value$value, 
[17:39:55.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.711]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.711]                     ...future.globalenv.names))
[17:39:55.711]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.711]         }, condition = base::local({
[17:39:55.711]             c <- base::c
[17:39:55.711]             inherits <- base::inherits
[17:39:55.711]             invokeRestart <- base::invokeRestart
[17:39:55.711]             length <- base::length
[17:39:55.711]             list <- base::list
[17:39:55.711]             seq.int <- base::seq.int
[17:39:55.711]             signalCondition <- base::signalCondition
[17:39:55.711]             sys.calls <- base::sys.calls
[17:39:55.711]             `[[` <- base::`[[`
[17:39:55.711]             `+` <- base::`+`
[17:39:55.711]             `<<-` <- base::`<<-`
[17:39:55.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.711]                   3L)]
[17:39:55.711]             }
[17:39:55.711]             function(cond) {
[17:39:55.711]                 is_error <- inherits(cond, "error")
[17:39:55.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.711]                   NULL)
[17:39:55.711]                 if (is_error) {
[17:39:55.711]                   sessionInformation <- function() {
[17:39:55.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.711]                       search = base::search(), system = base::Sys.info())
[17:39:55.711]                   }
[17:39:55.711]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.711]                     cond$call), session = sessionInformation(), 
[17:39:55.711]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.711]                   signalCondition(cond)
[17:39:55.711]                 }
[17:39:55.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.711]                 "immediateCondition"))) {
[17:39:55.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.711]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.711]                   if (TRUE && !signal) {
[17:39:55.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.711]                     {
[17:39:55.711]                       inherits <- base::inherits
[17:39:55.711]                       invokeRestart <- base::invokeRestart
[17:39:55.711]                       is.null <- base::is.null
[17:39:55.711]                       muffled <- FALSE
[17:39:55.711]                       if (inherits(cond, "message")) {
[17:39:55.711]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.711]                         if (muffled) 
[17:39:55.711]                           invokeRestart("muffleMessage")
[17:39:55.711]                       }
[17:39:55.711]                       else if (inherits(cond, "warning")) {
[17:39:55.711]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.711]                         if (muffled) 
[17:39:55.711]                           invokeRestart("muffleWarning")
[17:39:55.711]                       }
[17:39:55.711]                       else if (inherits(cond, "condition")) {
[17:39:55.711]                         if (!is.null(pattern)) {
[17:39:55.711]                           computeRestarts <- base::computeRestarts
[17:39:55.711]                           grepl <- base::grepl
[17:39:55.711]                           restarts <- computeRestarts(cond)
[17:39:55.711]                           for (restart in restarts) {
[17:39:55.711]                             name <- restart$name
[17:39:55.711]                             if (is.null(name)) 
[17:39:55.711]                               next
[17:39:55.711]                             if (!grepl(pattern, name)) 
[17:39:55.711]                               next
[17:39:55.711]                             invokeRestart(restart)
[17:39:55.711]                             muffled <- TRUE
[17:39:55.711]                             break
[17:39:55.711]                           }
[17:39:55.711]                         }
[17:39:55.711]                       }
[17:39:55.711]                       invisible(muffled)
[17:39:55.711]                     }
[17:39:55.711]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.711]                   }
[17:39:55.711]                 }
[17:39:55.711]                 else {
[17:39:55.711]                   if (TRUE) {
[17:39:55.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.711]                     {
[17:39:55.711]                       inherits <- base::inherits
[17:39:55.711]                       invokeRestart <- base::invokeRestart
[17:39:55.711]                       is.null <- base::is.null
[17:39:55.711]                       muffled <- FALSE
[17:39:55.711]                       if (inherits(cond, "message")) {
[17:39:55.711]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.711]                         if (muffled) 
[17:39:55.711]                           invokeRestart("muffleMessage")
[17:39:55.711]                       }
[17:39:55.711]                       else if (inherits(cond, "warning")) {
[17:39:55.711]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.711]                         if (muffled) 
[17:39:55.711]                           invokeRestart("muffleWarning")
[17:39:55.711]                       }
[17:39:55.711]                       else if (inherits(cond, "condition")) {
[17:39:55.711]                         if (!is.null(pattern)) {
[17:39:55.711]                           computeRestarts <- base::computeRestarts
[17:39:55.711]                           grepl <- base::grepl
[17:39:55.711]                           restarts <- computeRestarts(cond)
[17:39:55.711]                           for (restart in restarts) {
[17:39:55.711]                             name <- restart$name
[17:39:55.711]                             if (is.null(name)) 
[17:39:55.711]                               next
[17:39:55.711]                             if (!grepl(pattern, name)) 
[17:39:55.711]                               next
[17:39:55.711]                             invokeRestart(restart)
[17:39:55.711]                             muffled <- TRUE
[17:39:55.711]                             break
[17:39:55.711]                           }
[17:39:55.711]                         }
[17:39:55.711]                       }
[17:39:55.711]                       invisible(muffled)
[17:39:55.711]                     }
[17:39:55.711]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.711]                   }
[17:39:55.711]                 }
[17:39:55.711]             }
[17:39:55.711]         }))
[17:39:55.711]     }, error = function(ex) {
[17:39:55.711]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.711]                 ...future.rng), started = ...future.startTime, 
[17:39:55.711]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.711]             version = "1.8"), class = "FutureResult")
[17:39:55.711]     }, finally = {
[17:39:55.711]         if (!identical(...future.workdir, getwd())) 
[17:39:55.711]             setwd(...future.workdir)
[17:39:55.711]         {
[17:39:55.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.711]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.711]             }
[17:39:55.711]             base::options(...future.oldOptions)
[17:39:55.711]             if (.Platform$OS.type == "windows") {
[17:39:55.711]                 old_names <- names(...future.oldEnvVars)
[17:39:55.711]                 envs <- base::Sys.getenv()
[17:39:55.711]                 names <- names(envs)
[17:39:55.711]                 common <- intersect(names, old_names)
[17:39:55.711]                 added <- setdiff(names, old_names)
[17:39:55.711]                 removed <- setdiff(old_names, names)
[17:39:55.711]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.711]                   envs[common]]
[17:39:55.711]                 NAMES <- toupper(changed)
[17:39:55.711]                 args <- list()
[17:39:55.711]                 for (kk in seq_along(NAMES)) {
[17:39:55.711]                   name <- changed[[kk]]
[17:39:55.711]                   NAME <- NAMES[[kk]]
[17:39:55.711]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.711]                     next
[17:39:55.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.711]                 }
[17:39:55.711]                 NAMES <- toupper(added)
[17:39:55.711]                 for (kk in seq_along(NAMES)) {
[17:39:55.711]                   name <- added[[kk]]
[17:39:55.711]                   NAME <- NAMES[[kk]]
[17:39:55.711]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.711]                     next
[17:39:55.711]                   args[[name]] <- ""
[17:39:55.711]                 }
[17:39:55.711]                 NAMES <- toupper(removed)
[17:39:55.711]                 for (kk in seq_along(NAMES)) {
[17:39:55.711]                   name <- removed[[kk]]
[17:39:55.711]                   NAME <- NAMES[[kk]]
[17:39:55.711]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.711]                     next
[17:39:55.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.711]                 }
[17:39:55.711]                 if (length(args) > 0) 
[17:39:55.711]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.711]             }
[17:39:55.711]             else {
[17:39:55.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.711]             }
[17:39:55.711]             {
[17:39:55.711]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.711]                   0L) {
[17:39:55.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.711]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.711]                   base::options(opts)
[17:39:55.711]                 }
[17:39:55.711]                 {
[17:39:55.711]                   {
[17:39:55.711]                     NULL
[17:39:55.711]                     RNGkind("Mersenne-Twister")
[17:39:55.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.711]                       inherits = FALSE)
[17:39:55.711]                   }
[17:39:55.711]                   options(future.plan = NULL)
[17:39:55.711]                   if (is.na(NA_character_)) 
[17:39:55.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.711]                     .init = FALSE)
[17:39:55.711]                 }
[17:39:55.711]             }
[17:39:55.711]         }
[17:39:55.711]     })
[17:39:55.711]     if (TRUE) {
[17:39:55.711]         base::sink(type = "output", split = FALSE)
[17:39:55.711]         if (TRUE) {
[17:39:55.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.711]         }
[17:39:55.711]         else {
[17:39:55.711]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.711]         }
[17:39:55.711]         base::close(...future.stdout)
[17:39:55.711]         ...future.stdout <- NULL
[17:39:55.711]     }
[17:39:55.711]     ...future.result$conditions <- ...future.conditions
[17:39:55.711]     ...future.result$finished <- base::Sys.time()
[17:39:55.711]     ...future.result
[17:39:55.711] }
[17:39:55.713] assign_globals() ...
[17:39:55.713] List of 1
[17:39:55.713]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd80bab50> 
[17:39:55.713]  - attr(*, "where")=List of 1
[17:39:55.713]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.713]  - attr(*, "resolved")= logi TRUE
[17:39:55.713]  - attr(*, "total_size")= num 10592
[17:39:55.713]  - attr(*, "already-done")= logi TRUE
[17:39:55.715] - copied ‘a’ to environment
[17:39:55.715] assign_globals() ... done
[17:39:55.715] plan(): Setting new future strategy stack:
[17:39:55.715] List of future strategies:
[17:39:55.715] 1. sequential:
[17:39:55.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.715]    - tweaked: FALSE
[17:39:55.715]    - call: NULL
[17:39:55.716] plan(): nbrOfWorkers() = 1
[17:39:55.717] plan(): Setting new future strategy stack:
[17:39:55.717] List of future strategies:
[17:39:55.717] 1. sequential:
[17:39:55.717]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.717]    - tweaked: FALSE
[17:39:55.717]    - call: plan(strategy)
[17:39:55.717] plan(): nbrOfWorkers() = 1
[17:39:55.717] SequentialFuture started (and completed)
[17:39:55.717] - Launch lazy future ... done
[17:39:55.718] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.718] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.718] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.719] 
[17:39:55.719] Searching for globals ... DONE
[17:39:55.719] - globals: [0] <none>
[17:39:55.719] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.719] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.719] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.720] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.720] Searching for globals ... DONE
[17:39:55.721] Resolving globals: TRUE
[17:39:55.721] Resolving any globals that are futures ...
[17:39:55.721] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.721] Resolving any globals that are futures ... DONE
[17:39:55.721] Resolving futures part of globals (recursively) ...
[17:39:55.721] resolve() on list ...
[17:39:55.721]  recursive: 99
[17:39:55.722]  length: 1
[17:39:55.722]  elements: ‘a’
[17:39:55.722] run() for ‘Future’ ...
[17:39:55.722] - state: ‘created’
[17:39:55.722] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.722] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.722] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.722]   - Field: ‘label’
[17:39:55.722]   - Field: ‘local’
[17:39:55.723]   - Field: ‘owner’
[17:39:55.723]   - Field: ‘envir’
[17:39:55.723]   - Field: ‘packages’
[17:39:55.723]   - Field: ‘gc’
[17:39:55.723]   - Field: ‘conditions’
[17:39:55.723]   - Field: ‘expr’
[17:39:55.723]   - Field: ‘uuid’
[17:39:55.723]   - Field: ‘seed’
[17:39:55.723]   - Field: ‘version’
[17:39:55.723]   - Field: ‘result’
[17:39:55.723]   - Field: ‘asynchronous’
[17:39:55.724]   - Field: ‘calls’
[17:39:55.724]   - Field: ‘globals’
[17:39:55.724]   - Field: ‘stdout’
[17:39:55.724]   - Field: ‘earlySignal’
[17:39:55.724]   - Field: ‘lazy’
[17:39:55.724]   - Field: ‘state’
[17:39:55.724] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.724] - Launch lazy future ...
[17:39:55.724] Packages needed by the future expression (n = 0): <none>
[17:39:55.725] Packages needed by future strategies (n = 0): <none>
[17:39:55.725] {
[17:39:55.725]     {
[17:39:55.725]         {
[17:39:55.725]             ...future.startTime <- base::Sys.time()
[17:39:55.725]             {
[17:39:55.725]                 {
[17:39:55.725]                   {
[17:39:55.725]                     base::local({
[17:39:55.725]                       has_future <- base::requireNamespace("future", 
[17:39:55.725]                         quietly = TRUE)
[17:39:55.725]                       if (has_future) {
[17:39:55.725]                         ns <- base::getNamespace("future")
[17:39:55.725]                         version <- ns[[".package"]][["version"]]
[17:39:55.725]                         if (is.null(version)) 
[17:39:55.725]                           version <- utils::packageVersion("future")
[17:39:55.725]                       }
[17:39:55.725]                       else {
[17:39:55.725]                         version <- NULL
[17:39:55.725]                       }
[17:39:55.725]                       if (!has_future || version < "1.8.0") {
[17:39:55.725]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.725]                           "", base::R.version$version.string), 
[17:39:55.725]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.725]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.725]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.725]                             "release", "version")], collapse = " "), 
[17:39:55.725]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.725]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.725]                           info)
[17:39:55.725]                         info <- base::paste(info, collapse = "; ")
[17:39:55.725]                         if (!has_future) {
[17:39:55.725]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.725]                             info)
[17:39:55.725]                         }
[17:39:55.725]                         else {
[17:39:55.725]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.725]                             info, version)
[17:39:55.725]                         }
[17:39:55.725]                         base::stop(msg)
[17:39:55.725]                       }
[17:39:55.725]                     })
[17:39:55.725]                   }
[17:39:55.725]                   ...future.strategy.old <- future::plan("list")
[17:39:55.725]                   options(future.plan = NULL)
[17:39:55.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.725]                 }
[17:39:55.725]                 ...future.workdir <- getwd()
[17:39:55.725]             }
[17:39:55.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.725]         }
[17:39:55.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.725]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.725]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.725]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.725]             base::names(...future.oldOptions))
[17:39:55.725]     }
[17:39:55.725]     if (FALSE) {
[17:39:55.725]     }
[17:39:55.725]     else {
[17:39:55.725]         if (TRUE) {
[17:39:55.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.725]                 open = "w")
[17:39:55.725]         }
[17:39:55.725]         else {
[17:39:55.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.725]         }
[17:39:55.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.725]             base::sink(type = "output", split = FALSE)
[17:39:55.725]             base::close(...future.stdout)
[17:39:55.725]         }, add = TRUE)
[17:39:55.725]     }
[17:39:55.725]     ...future.frame <- base::sys.nframe()
[17:39:55.725]     ...future.conditions <- base::list()
[17:39:55.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.725]     if (FALSE) {
[17:39:55.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.725]     }
[17:39:55.725]     ...future.result <- base::tryCatch({
[17:39:55.725]         base::withCallingHandlers({
[17:39:55.725]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.725]             future::FutureResult(value = ...future.value$value, 
[17:39:55.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.725]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.725]                     ...future.globalenv.names))
[17:39:55.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.725]         }, condition = base::local({
[17:39:55.725]             c <- base::c
[17:39:55.725]             inherits <- base::inherits
[17:39:55.725]             invokeRestart <- base::invokeRestart
[17:39:55.725]             length <- base::length
[17:39:55.725]             list <- base::list
[17:39:55.725]             seq.int <- base::seq.int
[17:39:55.725]             signalCondition <- base::signalCondition
[17:39:55.725]             sys.calls <- base::sys.calls
[17:39:55.725]             `[[` <- base::`[[`
[17:39:55.725]             `+` <- base::`+`
[17:39:55.725]             `<<-` <- base::`<<-`
[17:39:55.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.725]                   3L)]
[17:39:55.725]             }
[17:39:55.725]             function(cond) {
[17:39:55.725]                 is_error <- inherits(cond, "error")
[17:39:55.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.725]                   NULL)
[17:39:55.725]                 if (is_error) {
[17:39:55.725]                   sessionInformation <- function() {
[17:39:55.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.725]                       search = base::search(), system = base::Sys.info())
[17:39:55.725]                   }
[17:39:55.725]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.725]                     cond$call), session = sessionInformation(), 
[17:39:55.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.725]                   signalCondition(cond)
[17:39:55.725]                 }
[17:39:55.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.725]                 "immediateCondition"))) {
[17:39:55.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.725]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.725]                   if (TRUE && !signal) {
[17:39:55.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.725]                     {
[17:39:55.725]                       inherits <- base::inherits
[17:39:55.725]                       invokeRestart <- base::invokeRestart
[17:39:55.725]                       is.null <- base::is.null
[17:39:55.725]                       muffled <- FALSE
[17:39:55.725]                       if (inherits(cond, "message")) {
[17:39:55.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.725]                         if (muffled) 
[17:39:55.725]                           invokeRestart("muffleMessage")
[17:39:55.725]                       }
[17:39:55.725]                       else if (inherits(cond, "warning")) {
[17:39:55.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.725]                         if (muffled) 
[17:39:55.725]                           invokeRestart("muffleWarning")
[17:39:55.725]                       }
[17:39:55.725]                       else if (inherits(cond, "condition")) {
[17:39:55.725]                         if (!is.null(pattern)) {
[17:39:55.725]                           computeRestarts <- base::computeRestarts
[17:39:55.725]                           grepl <- base::grepl
[17:39:55.725]                           restarts <- computeRestarts(cond)
[17:39:55.725]                           for (restart in restarts) {
[17:39:55.725]                             name <- restart$name
[17:39:55.725]                             if (is.null(name)) 
[17:39:55.725]                               next
[17:39:55.725]                             if (!grepl(pattern, name)) 
[17:39:55.725]                               next
[17:39:55.725]                             invokeRestart(restart)
[17:39:55.725]                             muffled <- TRUE
[17:39:55.725]                             break
[17:39:55.725]                           }
[17:39:55.725]                         }
[17:39:55.725]                       }
[17:39:55.725]                       invisible(muffled)
[17:39:55.725]                     }
[17:39:55.725]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.725]                   }
[17:39:55.725]                 }
[17:39:55.725]                 else {
[17:39:55.725]                   if (TRUE) {
[17:39:55.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.725]                     {
[17:39:55.725]                       inherits <- base::inherits
[17:39:55.725]                       invokeRestart <- base::invokeRestart
[17:39:55.725]                       is.null <- base::is.null
[17:39:55.725]                       muffled <- FALSE
[17:39:55.725]                       if (inherits(cond, "message")) {
[17:39:55.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.725]                         if (muffled) 
[17:39:55.725]                           invokeRestart("muffleMessage")
[17:39:55.725]                       }
[17:39:55.725]                       else if (inherits(cond, "warning")) {
[17:39:55.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.725]                         if (muffled) 
[17:39:55.725]                           invokeRestart("muffleWarning")
[17:39:55.725]                       }
[17:39:55.725]                       else if (inherits(cond, "condition")) {
[17:39:55.725]                         if (!is.null(pattern)) {
[17:39:55.725]                           computeRestarts <- base::computeRestarts
[17:39:55.725]                           grepl <- base::grepl
[17:39:55.725]                           restarts <- computeRestarts(cond)
[17:39:55.725]                           for (restart in restarts) {
[17:39:55.725]                             name <- restart$name
[17:39:55.725]                             if (is.null(name)) 
[17:39:55.725]                               next
[17:39:55.725]                             if (!grepl(pattern, name)) 
[17:39:55.725]                               next
[17:39:55.725]                             invokeRestart(restart)
[17:39:55.725]                             muffled <- TRUE
[17:39:55.725]                             break
[17:39:55.725]                           }
[17:39:55.725]                         }
[17:39:55.725]                       }
[17:39:55.725]                       invisible(muffled)
[17:39:55.725]                     }
[17:39:55.725]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.725]                   }
[17:39:55.725]                 }
[17:39:55.725]             }
[17:39:55.725]         }))
[17:39:55.725]     }, error = function(ex) {
[17:39:55.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.725]                 ...future.rng), started = ...future.startTime, 
[17:39:55.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.725]             version = "1.8"), class = "FutureResult")
[17:39:55.725]     }, finally = {
[17:39:55.725]         if (!identical(...future.workdir, getwd())) 
[17:39:55.725]             setwd(...future.workdir)
[17:39:55.725]         {
[17:39:55.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.725]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.725]             }
[17:39:55.725]             base::options(...future.oldOptions)
[17:39:55.725]             if (.Platform$OS.type == "windows") {
[17:39:55.725]                 old_names <- names(...future.oldEnvVars)
[17:39:55.725]                 envs <- base::Sys.getenv()
[17:39:55.725]                 names <- names(envs)
[17:39:55.725]                 common <- intersect(names, old_names)
[17:39:55.725]                 added <- setdiff(names, old_names)
[17:39:55.725]                 removed <- setdiff(old_names, names)
[17:39:55.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.725]                   envs[common]]
[17:39:55.725]                 NAMES <- toupper(changed)
[17:39:55.725]                 args <- list()
[17:39:55.725]                 for (kk in seq_along(NAMES)) {
[17:39:55.725]                   name <- changed[[kk]]
[17:39:55.725]                   NAME <- NAMES[[kk]]
[17:39:55.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.725]                     next
[17:39:55.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.725]                 }
[17:39:55.725]                 NAMES <- toupper(added)
[17:39:55.725]                 for (kk in seq_along(NAMES)) {
[17:39:55.725]                   name <- added[[kk]]
[17:39:55.725]                   NAME <- NAMES[[kk]]
[17:39:55.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.725]                     next
[17:39:55.725]                   args[[name]] <- ""
[17:39:55.725]                 }
[17:39:55.725]                 NAMES <- toupper(removed)
[17:39:55.725]                 for (kk in seq_along(NAMES)) {
[17:39:55.725]                   name <- removed[[kk]]
[17:39:55.725]                   NAME <- NAMES[[kk]]
[17:39:55.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.725]                     next
[17:39:55.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.725]                 }
[17:39:55.725]                 if (length(args) > 0) 
[17:39:55.725]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.725]             }
[17:39:55.725]             else {
[17:39:55.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.725]             }
[17:39:55.725]             {
[17:39:55.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.725]                   0L) {
[17:39:55.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.725]                   base::options(opts)
[17:39:55.725]                 }
[17:39:55.725]                 {
[17:39:55.725]                   {
[17:39:55.725]                     NULL
[17:39:55.725]                     RNGkind("Mersenne-Twister")
[17:39:55.725]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.725]                       inherits = FALSE)
[17:39:55.725]                   }
[17:39:55.725]                   options(future.plan = NULL)
[17:39:55.725]                   if (is.na(NA_character_)) 
[17:39:55.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.725]                     .init = FALSE)
[17:39:55.725]                 }
[17:39:55.725]             }
[17:39:55.725]         }
[17:39:55.725]     })
[17:39:55.725]     if (TRUE) {
[17:39:55.725]         base::sink(type = "output", split = FALSE)
[17:39:55.725]         if (TRUE) {
[17:39:55.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.725]         }
[17:39:55.725]         else {
[17:39:55.725]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.725]         }
[17:39:55.725]         base::close(...future.stdout)
[17:39:55.725]         ...future.stdout <- NULL
[17:39:55.725]     }
[17:39:55.725]     ...future.result$conditions <- ...future.conditions
[17:39:55.725]     ...future.result$finished <- base::Sys.time()
[17:39:55.725]     ...future.result
[17:39:55.725] }
[17:39:55.727] plan(): Setting new future strategy stack:
[17:39:55.727] List of future strategies:
[17:39:55.727] 1. sequential:
[17:39:55.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.727]    - tweaked: FALSE
[17:39:55.727]    - call: NULL
[17:39:55.727] plan(): nbrOfWorkers() = 1
[17:39:55.728] plan(): Setting new future strategy stack:
[17:39:55.728] List of future strategies:
[17:39:55.728] 1. sequential:
[17:39:55.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.728]    - tweaked: FALSE
[17:39:55.728]    - call: plan(strategy)
[17:39:55.728] plan(): nbrOfWorkers() = 1
[17:39:55.728] SequentialFuture started (and completed)
[17:39:55.729] - Launch lazy future ... done
[17:39:55.729] run() for ‘SequentialFuture’ ... done
[17:39:55.729] resolved() for ‘SequentialFuture’ ...
[17:39:55.729] - state: ‘finished’
[17:39:55.729] - run: TRUE
[17:39:55.729] - result: ‘FutureResult’
[17:39:55.729] resolved() for ‘SequentialFuture’ ... done
[17:39:55.729] Future #1
[17:39:55.729] resolved() for ‘SequentialFuture’ ...
[17:39:55.730] - state: ‘finished’
[17:39:55.730] - run: TRUE
[17:39:55.730] - result: ‘FutureResult’
[17:39:55.730] resolved() for ‘SequentialFuture’ ... done
[17:39:55.730] A SequentialFuture was resolved
[17:39:55.730]  length: 0 (resolved future 1)
[17:39:55.730] resolve() on list ... DONE
[17:39:55.730] - globals: [1] ‘a’
[17:39:55.730] Resolving futures part of globals (recursively) ... DONE
[17:39:55.731] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:39:55.731] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:39:55.731] - globals: [1] ‘a’
[17:39:55.731] - packages: [1] ‘future’
[17:39:55.732] getGlobalsAndPackages() ... DONE
[17:39:55.732] run() for ‘Future’ ...
[17:39:55.732] - state: ‘created’
[17:39:55.732] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.732] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.733]   - Field: ‘label’
[17:39:55.733]   - Field: ‘local’
[17:39:55.733]   - Field: ‘owner’
[17:39:55.733]   - Field: ‘envir’
[17:39:55.733]   - Field: ‘packages’
[17:39:55.733]   - Field: ‘gc’
[17:39:55.733]   - Field: ‘conditions’
[17:39:55.733]   - Field: ‘expr’
[17:39:55.733]   - Field: ‘uuid’
[17:39:55.733]   - Field: ‘seed’
[17:39:55.733]   - Field: ‘version’
[17:39:55.734]   - Field: ‘result’
[17:39:55.734]   - Field: ‘asynchronous’
[17:39:55.734]   - Field: ‘calls’
[17:39:55.734]   - Field: ‘globals’
[17:39:55.734]   - Field: ‘stdout’
[17:39:55.734]   - Field: ‘earlySignal’
[17:39:55.734]   - Field: ‘lazy’
[17:39:55.734]   - Field: ‘state’
[17:39:55.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.734] - Launch lazy future ...
[17:39:55.735] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.735] Packages needed by future strategies (n = 0): <none>
[17:39:55.737] {
[17:39:55.737]     {
[17:39:55.737]         {
[17:39:55.737]             ...future.startTime <- base::Sys.time()
[17:39:55.737]             {
[17:39:55.737]                 {
[17:39:55.737]                   {
[17:39:55.737]                     {
[17:39:55.737]                       base::local({
[17:39:55.737]                         has_future <- base::requireNamespace("future", 
[17:39:55.737]                           quietly = TRUE)
[17:39:55.737]                         if (has_future) {
[17:39:55.737]                           ns <- base::getNamespace("future")
[17:39:55.737]                           version <- ns[[".package"]][["version"]]
[17:39:55.737]                           if (is.null(version)) 
[17:39:55.737]                             version <- utils::packageVersion("future")
[17:39:55.737]                         }
[17:39:55.737]                         else {
[17:39:55.737]                           version <- NULL
[17:39:55.737]                         }
[17:39:55.737]                         if (!has_future || version < "1.8.0") {
[17:39:55.737]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.737]                             "", base::R.version$version.string), 
[17:39:55.737]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.737]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.737]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.737]                               "release", "version")], collapse = " "), 
[17:39:55.737]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.737]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.737]                             info)
[17:39:55.737]                           info <- base::paste(info, collapse = "; ")
[17:39:55.737]                           if (!has_future) {
[17:39:55.737]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.737]                               info)
[17:39:55.737]                           }
[17:39:55.737]                           else {
[17:39:55.737]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.737]                               info, version)
[17:39:55.737]                           }
[17:39:55.737]                           base::stop(msg)
[17:39:55.737]                         }
[17:39:55.737]                       })
[17:39:55.737]                     }
[17:39:55.737]                     base::local({
[17:39:55.737]                       for (pkg in "future") {
[17:39:55.737]                         base::loadNamespace(pkg)
[17:39:55.737]                         base::library(pkg, character.only = TRUE)
[17:39:55.737]                       }
[17:39:55.737]                     })
[17:39:55.737]                   }
[17:39:55.737]                   ...future.strategy.old <- future::plan("list")
[17:39:55.737]                   options(future.plan = NULL)
[17:39:55.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.737]                 }
[17:39:55.737]                 ...future.workdir <- getwd()
[17:39:55.737]             }
[17:39:55.737]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.737]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.737]         }
[17:39:55.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.737]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.737]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.737]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.737]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.737]             base::names(...future.oldOptions))
[17:39:55.737]     }
[17:39:55.737]     if (FALSE) {
[17:39:55.737]     }
[17:39:55.737]     else {
[17:39:55.737]         if (TRUE) {
[17:39:55.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.737]                 open = "w")
[17:39:55.737]         }
[17:39:55.737]         else {
[17:39:55.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.737]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.737]         }
[17:39:55.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.737]             base::sink(type = "output", split = FALSE)
[17:39:55.737]             base::close(...future.stdout)
[17:39:55.737]         }, add = TRUE)
[17:39:55.737]     }
[17:39:55.737]     ...future.frame <- base::sys.nframe()
[17:39:55.737]     ...future.conditions <- base::list()
[17:39:55.737]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.737]     if (FALSE) {
[17:39:55.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.737]     }
[17:39:55.737]     ...future.result <- base::tryCatch({
[17:39:55.737]         base::withCallingHandlers({
[17:39:55.737]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.737]                 1))
[17:39:55.737]             future::FutureResult(value = ...future.value$value, 
[17:39:55.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.737]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.737]                     ...future.globalenv.names))
[17:39:55.737]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.737]         }, condition = base::local({
[17:39:55.737]             c <- base::c
[17:39:55.737]             inherits <- base::inherits
[17:39:55.737]             invokeRestart <- base::invokeRestart
[17:39:55.737]             length <- base::length
[17:39:55.737]             list <- base::list
[17:39:55.737]             seq.int <- base::seq.int
[17:39:55.737]             signalCondition <- base::signalCondition
[17:39:55.737]             sys.calls <- base::sys.calls
[17:39:55.737]             `[[` <- base::`[[`
[17:39:55.737]             `+` <- base::`+`
[17:39:55.737]             `<<-` <- base::`<<-`
[17:39:55.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.737]                   3L)]
[17:39:55.737]             }
[17:39:55.737]             function(cond) {
[17:39:55.737]                 is_error <- inherits(cond, "error")
[17:39:55.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.737]                   NULL)
[17:39:55.737]                 if (is_error) {
[17:39:55.737]                   sessionInformation <- function() {
[17:39:55.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.737]                       search = base::search(), system = base::Sys.info())
[17:39:55.737]                   }
[17:39:55.737]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.737]                     cond$call), session = sessionInformation(), 
[17:39:55.737]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.737]                   signalCondition(cond)
[17:39:55.737]                 }
[17:39:55.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.737]                 "immediateCondition"))) {
[17:39:55.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.737]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.737]                   if (TRUE && !signal) {
[17:39:55.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.737]                     {
[17:39:55.737]                       inherits <- base::inherits
[17:39:55.737]                       invokeRestart <- base::invokeRestart
[17:39:55.737]                       is.null <- base::is.null
[17:39:55.737]                       muffled <- FALSE
[17:39:55.737]                       if (inherits(cond, "message")) {
[17:39:55.737]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.737]                         if (muffled) 
[17:39:55.737]                           invokeRestart("muffleMessage")
[17:39:55.737]                       }
[17:39:55.737]                       else if (inherits(cond, "warning")) {
[17:39:55.737]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.737]                         if (muffled) 
[17:39:55.737]                           invokeRestart("muffleWarning")
[17:39:55.737]                       }
[17:39:55.737]                       else if (inherits(cond, "condition")) {
[17:39:55.737]                         if (!is.null(pattern)) {
[17:39:55.737]                           computeRestarts <- base::computeRestarts
[17:39:55.737]                           grepl <- base::grepl
[17:39:55.737]                           restarts <- computeRestarts(cond)
[17:39:55.737]                           for (restart in restarts) {
[17:39:55.737]                             name <- restart$name
[17:39:55.737]                             if (is.null(name)) 
[17:39:55.737]                               next
[17:39:55.737]                             if (!grepl(pattern, name)) 
[17:39:55.737]                               next
[17:39:55.737]                             invokeRestart(restart)
[17:39:55.737]                             muffled <- TRUE
[17:39:55.737]                             break
[17:39:55.737]                           }
[17:39:55.737]                         }
[17:39:55.737]                       }
[17:39:55.737]                       invisible(muffled)
[17:39:55.737]                     }
[17:39:55.737]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.737]                   }
[17:39:55.737]                 }
[17:39:55.737]                 else {
[17:39:55.737]                   if (TRUE) {
[17:39:55.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.737]                     {
[17:39:55.737]                       inherits <- base::inherits
[17:39:55.737]                       invokeRestart <- base::invokeRestart
[17:39:55.737]                       is.null <- base::is.null
[17:39:55.737]                       muffled <- FALSE
[17:39:55.737]                       if (inherits(cond, "message")) {
[17:39:55.737]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.737]                         if (muffled) 
[17:39:55.737]                           invokeRestart("muffleMessage")
[17:39:55.737]                       }
[17:39:55.737]                       else if (inherits(cond, "warning")) {
[17:39:55.737]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.737]                         if (muffled) 
[17:39:55.737]                           invokeRestart("muffleWarning")
[17:39:55.737]                       }
[17:39:55.737]                       else if (inherits(cond, "condition")) {
[17:39:55.737]                         if (!is.null(pattern)) {
[17:39:55.737]                           computeRestarts <- base::computeRestarts
[17:39:55.737]                           grepl <- base::grepl
[17:39:55.737]                           restarts <- computeRestarts(cond)
[17:39:55.737]                           for (restart in restarts) {
[17:39:55.737]                             name <- restart$name
[17:39:55.737]                             if (is.null(name)) 
[17:39:55.737]                               next
[17:39:55.737]                             if (!grepl(pattern, name)) 
[17:39:55.737]                               next
[17:39:55.737]                             invokeRestart(restart)
[17:39:55.737]                             muffled <- TRUE
[17:39:55.737]                             break
[17:39:55.737]                           }
[17:39:55.737]                         }
[17:39:55.737]                       }
[17:39:55.737]                       invisible(muffled)
[17:39:55.737]                     }
[17:39:55.737]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.737]                   }
[17:39:55.737]                 }
[17:39:55.737]             }
[17:39:55.737]         }))
[17:39:55.737]     }, error = function(ex) {
[17:39:55.737]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.737]                 ...future.rng), started = ...future.startTime, 
[17:39:55.737]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.737]             version = "1.8"), class = "FutureResult")
[17:39:55.737]     }, finally = {
[17:39:55.737]         if (!identical(...future.workdir, getwd())) 
[17:39:55.737]             setwd(...future.workdir)
[17:39:55.737]         {
[17:39:55.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.737]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.737]             }
[17:39:55.737]             base::options(...future.oldOptions)
[17:39:55.737]             if (.Platform$OS.type == "windows") {
[17:39:55.737]                 old_names <- names(...future.oldEnvVars)
[17:39:55.737]                 envs <- base::Sys.getenv()
[17:39:55.737]                 names <- names(envs)
[17:39:55.737]                 common <- intersect(names, old_names)
[17:39:55.737]                 added <- setdiff(names, old_names)
[17:39:55.737]                 removed <- setdiff(old_names, names)
[17:39:55.737]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.737]                   envs[common]]
[17:39:55.737]                 NAMES <- toupper(changed)
[17:39:55.737]                 args <- list()
[17:39:55.737]                 for (kk in seq_along(NAMES)) {
[17:39:55.737]                   name <- changed[[kk]]
[17:39:55.737]                   NAME <- NAMES[[kk]]
[17:39:55.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.737]                     next
[17:39:55.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.737]                 }
[17:39:55.737]                 NAMES <- toupper(added)
[17:39:55.737]                 for (kk in seq_along(NAMES)) {
[17:39:55.737]                   name <- added[[kk]]
[17:39:55.737]                   NAME <- NAMES[[kk]]
[17:39:55.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.737]                     next
[17:39:55.737]                   args[[name]] <- ""
[17:39:55.737]                 }
[17:39:55.737]                 NAMES <- toupper(removed)
[17:39:55.737]                 for (kk in seq_along(NAMES)) {
[17:39:55.737]                   name <- removed[[kk]]
[17:39:55.737]                   NAME <- NAMES[[kk]]
[17:39:55.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.737]                     next
[17:39:55.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.737]                 }
[17:39:55.737]                 if (length(args) > 0) 
[17:39:55.737]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.737]             }
[17:39:55.737]             else {
[17:39:55.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.737]             }
[17:39:55.737]             {
[17:39:55.737]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.737]                   0L) {
[17:39:55.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.737]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.737]                   base::options(opts)
[17:39:55.737]                 }
[17:39:55.737]                 {
[17:39:55.737]                   {
[17:39:55.737]                     NULL
[17:39:55.737]                     RNGkind("Mersenne-Twister")
[17:39:55.737]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.737]                       inherits = FALSE)
[17:39:55.737]                   }
[17:39:55.737]                   options(future.plan = NULL)
[17:39:55.737]                   if (is.na(NA_character_)) 
[17:39:55.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.737]                     .init = FALSE)
[17:39:55.737]                 }
[17:39:55.737]             }
[17:39:55.737]         }
[17:39:55.737]     })
[17:39:55.737]     if (TRUE) {
[17:39:55.737]         base::sink(type = "output", split = FALSE)
[17:39:55.737]         if (TRUE) {
[17:39:55.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.737]         }
[17:39:55.737]         else {
[17:39:55.737]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.737]         }
[17:39:55.737]         base::close(...future.stdout)
[17:39:55.737]         ...future.stdout <- NULL
[17:39:55.737]     }
[17:39:55.737]     ...future.result$conditions <- ...future.conditions
[17:39:55.737]     ...future.result$finished <- base::Sys.time()
[17:39:55.737]     ...future.result
[17:39:55.737] }
[17:39:55.738] assign_globals() ...
[17:39:55.738] List of 1
[17:39:55.738]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd7ddb520> 
[17:39:55.738]  - attr(*, "where")=List of 1
[17:39:55.738]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.738]  - attr(*, "resolved")= logi TRUE
[17:39:55.738]  - attr(*, "total_size")= num 10592
[17:39:55.738]  - attr(*, "already-done")= logi TRUE
[17:39:55.741] - copied ‘a’ to environment
[17:39:55.741] assign_globals() ... done
[17:39:55.741] plan(): Setting new future strategy stack:
[17:39:55.741] List of future strategies:
[17:39:55.741] 1. sequential:
[17:39:55.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.741]    - tweaked: FALSE
[17:39:55.741]    - call: NULL
[17:39:55.742] plan(): nbrOfWorkers() = 1
[17:39:55.743] plan(): Setting new future strategy stack:
[17:39:55.743] List of future strategies:
[17:39:55.743] 1. sequential:
[17:39:55.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.743]    - tweaked: FALSE
[17:39:55.743]    - call: plan(strategy)
[17:39:55.743] plan(): nbrOfWorkers() = 1
[17:39:55.743] SequentialFuture started (and completed)
[17:39:55.743] - Launch lazy future ... done
[17:39:55.743] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.744] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.744] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:55.745] - globals found: [2] ‘{’, ‘pkg’
[17:39:55.745] Searching for globals ... DONE
[17:39:55.745] Resolving globals: TRUE
[17:39:55.745] Resolving any globals that are futures ...
[17:39:55.745] - globals: [2] ‘{’, ‘pkg’
[17:39:55.745] Resolving any globals that are futures ... DONE
[17:39:55.746] Resolving futures part of globals (recursively) ...
[17:39:55.746] resolve() on list ...
[17:39:55.746]  recursive: 99
[17:39:55.746]  length: 1
[17:39:55.746]  elements: ‘pkg’
[17:39:55.746]  length: 0 (resolved future 1)
[17:39:55.746] resolve() on list ... DONE
[17:39:55.746] - globals: [1] ‘pkg’
[17:39:55.747] Resolving futures part of globals (recursively) ... DONE
[17:39:55.747] The total size of the 1 globals is 112 bytes (112 bytes)
[17:39:55.747] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:39:55.747] - globals: [1] ‘pkg’
[17:39:55.747] 
[17:39:55.747] getGlobalsAndPackages() ... DONE
[17:39:55.748] Packages needed by the future expression (n = 0): <none>
[17:39:55.748] Packages needed by future strategies (n = 0): <none>
[17:39:55.748] {
[17:39:55.748]     {
[17:39:55.748]         {
[17:39:55.748]             ...future.startTime <- base::Sys.time()
[17:39:55.748]             {
[17:39:55.748]                 {
[17:39:55.748]                   {
[17:39:55.748]                     base::local({
[17:39:55.748]                       has_future <- base::requireNamespace("future", 
[17:39:55.748]                         quietly = TRUE)
[17:39:55.748]                       if (has_future) {
[17:39:55.748]                         ns <- base::getNamespace("future")
[17:39:55.748]                         version <- ns[[".package"]][["version"]]
[17:39:55.748]                         if (is.null(version)) 
[17:39:55.748]                           version <- utils::packageVersion("future")
[17:39:55.748]                       }
[17:39:55.748]                       else {
[17:39:55.748]                         version <- NULL
[17:39:55.748]                       }
[17:39:55.748]                       if (!has_future || version < "1.8.0") {
[17:39:55.748]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.748]                           "", base::R.version$version.string), 
[17:39:55.748]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.748]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.748]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.748]                             "release", "version")], collapse = " "), 
[17:39:55.748]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.748]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.748]                           info)
[17:39:55.748]                         info <- base::paste(info, collapse = "; ")
[17:39:55.748]                         if (!has_future) {
[17:39:55.748]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.748]                             info)
[17:39:55.748]                         }
[17:39:55.748]                         else {
[17:39:55.748]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.748]                             info, version)
[17:39:55.748]                         }
[17:39:55.748]                         base::stop(msg)
[17:39:55.748]                       }
[17:39:55.748]                     })
[17:39:55.748]                   }
[17:39:55.748]                   ...future.strategy.old <- future::plan("list")
[17:39:55.748]                   options(future.plan = NULL)
[17:39:55.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.748]                 }
[17:39:55.748]                 ...future.workdir <- getwd()
[17:39:55.748]             }
[17:39:55.748]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.748]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.748]         }
[17:39:55.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.748]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:55.748]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.748]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.748]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.748]             base::names(...future.oldOptions))
[17:39:55.748]     }
[17:39:55.748]     if (FALSE) {
[17:39:55.748]     }
[17:39:55.748]     else {
[17:39:55.748]         if (TRUE) {
[17:39:55.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.748]                 open = "w")
[17:39:55.748]         }
[17:39:55.748]         else {
[17:39:55.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.748]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.748]         }
[17:39:55.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.748]             base::sink(type = "output", split = FALSE)
[17:39:55.748]             base::close(...future.stdout)
[17:39:55.748]         }, add = TRUE)
[17:39:55.748]     }
[17:39:55.748]     ...future.frame <- base::sys.nframe()
[17:39:55.748]     ...future.conditions <- base::list()
[17:39:55.748]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.748]     if (FALSE) {
[17:39:55.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.748]     }
[17:39:55.748]     ...future.result <- base::tryCatch({
[17:39:55.748]         base::withCallingHandlers({
[17:39:55.748]             ...future.value <- base::withVisible(base::local({
[17:39:55.748]                 pkg
[17:39:55.748]             }))
[17:39:55.748]             future::FutureResult(value = ...future.value$value, 
[17:39:55.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.748]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.748]                     ...future.globalenv.names))
[17:39:55.748]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.748]         }, condition = base::local({
[17:39:55.748]             c <- base::c
[17:39:55.748]             inherits <- base::inherits
[17:39:55.748]             invokeRestart <- base::invokeRestart
[17:39:55.748]             length <- base::length
[17:39:55.748]             list <- base::list
[17:39:55.748]             seq.int <- base::seq.int
[17:39:55.748]             signalCondition <- base::signalCondition
[17:39:55.748]             sys.calls <- base::sys.calls
[17:39:55.748]             `[[` <- base::`[[`
[17:39:55.748]             `+` <- base::`+`
[17:39:55.748]             `<<-` <- base::`<<-`
[17:39:55.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.748]                   3L)]
[17:39:55.748]             }
[17:39:55.748]             function(cond) {
[17:39:55.748]                 is_error <- inherits(cond, "error")
[17:39:55.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.748]                   NULL)
[17:39:55.748]                 if (is_error) {
[17:39:55.748]                   sessionInformation <- function() {
[17:39:55.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.748]                       search = base::search(), system = base::Sys.info())
[17:39:55.748]                   }
[17:39:55.748]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.748]                     cond$call), session = sessionInformation(), 
[17:39:55.748]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.748]                   signalCondition(cond)
[17:39:55.748]                 }
[17:39:55.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.748]                 "immediateCondition"))) {
[17:39:55.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.748]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.748]                   if (TRUE && !signal) {
[17:39:55.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.748]                     {
[17:39:55.748]                       inherits <- base::inherits
[17:39:55.748]                       invokeRestart <- base::invokeRestart
[17:39:55.748]                       is.null <- base::is.null
[17:39:55.748]                       muffled <- FALSE
[17:39:55.748]                       if (inherits(cond, "message")) {
[17:39:55.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.748]                         if (muffled) 
[17:39:55.748]                           invokeRestart("muffleMessage")
[17:39:55.748]                       }
[17:39:55.748]                       else if (inherits(cond, "warning")) {
[17:39:55.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.748]                         if (muffled) 
[17:39:55.748]                           invokeRestart("muffleWarning")
[17:39:55.748]                       }
[17:39:55.748]                       else if (inherits(cond, "condition")) {
[17:39:55.748]                         if (!is.null(pattern)) {
[17:39:55.748]                           computeRestarts <- base::computeRestarts
[17:39:55.748]                           grepl <- base::grepl
[17:39:55.748]                           restarts <- computeRestarts(cond)
[17:39:55.748]                           for (restart in restarts) {
[17:39:55.748]                             name <- restart$name
[17:39:55.748]                             if (is.null(name)) 
[17:39:55.748]                               next
[17:39:55.748]                             if (!grepl(pattern, name)) 
[17:39:55.748]                               next
[17:39:55.748]                             invokeRestart(restart)
[17:39:55.748]                             muffled <- TRUE
[17:39:55.748]                             break
[17:39:55.748]                           }
[17:39:55.748]                         }
[17:39:55.748]                       }
[17:39:55.748]                       invisible(muffled)
[17:39:55.748]                     }
[17:39:55.748]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.748]                   }
[17:39:55.748]                 }
[17:39:55.748]                 else {
[17:39:55.748]                   if (TRUE) {
[17:39:55.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.748]                     {
[17:39:55.748]                       inherits <- base::inherits
[17:39:55.748]                       invokeRestart <- base::invokeRestart
[17:39:55.748]                       is.null <- base::is.null
[17:39:55.748]                       muffled <- FALSE
[17:39:55.748]                       if (inherits(cond, "message")) {
[17:39:55.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.748]                         if (muffled) 
[17:39:55.748]                           invokeRestart("muffleMessage")
[17:39:55.748]                       }
[17:39:55.748]                       else if (inherits(cond, "warning")) {
[17:39:55.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.748]                         if (muffled) 
[17:39:55.748]                           invokeRestart("muffleWarning")
[17:39:55.748]                       }
[17:39:55.748]                       else if (inherits(cond, "condition")) {
[17:39:55.748]                         if (!is.null(pattern)) {
[17:39:55.748]                           computeRestarts <- base::computeRestarts
[17:39:55.748]                           grepl <- base::grepl
[17:39:55.748]                           restarts <- computeRestarts(cond)
[17:39:55.748]                           for (restart in restarts) {
[17:39:55.748]                             name <- restart$name
[17:39:55.748]                             if (is.null(name)) 
[17:39:55.748]                               next
[17:39:55.748]                             if (!grepl(pattern, name)) 
[17:39:55.748]                               next
[17:39:55.748]                             invokeRestart(restart)
[17:39:55.748]                             muffled <- TRUE
[17:39:55.748]                             break
[17:39:55.748]                           }
[17:39:55.748]                         }
[17:39:55.748]                       }
[17:39:55.748]                       invisible(muffled)
[17:39:55.748]                     }
[17:39:55.748]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.748]                   }
[17:39:55.748]                 }
[17:39:55.748]             }
[17:39:55.748]         }))
[17:39:55.748]     }, error = function(ex) {
[17:39:55.748]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.748]                 ...future.rng), started = ...future.startTime, 
[17:39:55.748]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.748]             version = "1.8"), class = "FutureResult")
[17:39:55.748]     }, finally = {
[17:39:55.748]         if (!identical(...future.workdir, getwd())) 
[17:39:55.748]             setwd(...future.workdir)
[17:39:55.748]         {
[17:39:55.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.748]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.748]             }
[17:39:55.748]             base::options(...future.oldOptions)
[17:39:55.748]             if (.Platform$OS.type == "windows") {
[17:39:55.748]                 old_names <- names(...future.oldEnvVars)
[17:39:55.748]                 envs <- base::Sys.getenv()
[17:39:55.748]                 names <- names(envs)
[17:39:55.748]                 common <- intersect(names, old_names)
[17:39:55.748]                 added <- setdiff(names, old_names)
[17:39:55.748]                 removed <- setdiff(old_names, names)
[17:39:55.748]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.748]                   envs[common]]
[17:39:55.748]                 NAMES <- toupper(changed)
[17:39:55.748]                 args <- list()
[17:39:55.748]                 for (kk in seq_along(NAMES)) {
[17:39:55.748]                   name <- changed[[kk]]
[17:39:55.748]                   NAME <- NAMES[[kk]]
[17:39:55.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.748]                     next
[17:39:55.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.748]                 }
[17:39:55.748]                 NAMES <- toupper(added)
[17:39:55.748]                 for (kk in seq_along(NAMES)) {
[17:39:55.748]                   name <- added[[kk]]
[17:39:55.748]                   NAME <- NAMES[[kk]]
[17:39:55.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.748]                     next
[17:39:55.748]                   args[[name]] <- ""
[17:39:55.748]                 }
[17:39:55.748]                 NAMES <- toupper(removed)
[17:39:55.748]                 for (kk in seq_along(NAMES)) {
[17:39:55.748]                   name <- removed[[kk]]
[17:39:55.748]                   NAME <- NAMES[[kk]]
[17:39:55.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.748]                     next
[17:39:55.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.748]                 }
[17:39:55.748]                 if (length(args) > 0) 
[17:39:55.748]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.748]             }
[17:39:55.748]             else {
[17:39:55.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.748]             }
[17:39:55.748]             {
[17:39:55.748]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.748]                   0L) {
[17:39:55.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.748]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.748]                   base::options(opts)
[17:39:55.748]                 }
[17:39:55.748]                 {
[17:39:55.748]                   {
[17:39:55.748]                     NULL
[17:39:55.748]                     RNGkind("Mersenne-Twister")
[17:39:55.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.748]                       inherits = FALSE)
[17:39:55.748]                   }
[17:39:55.748]                   options(future.plan = NULL)
[17:39:55.748]                   if (is.na(NA_character_)) 
[17:39:55.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.748]                     .init = FALSE)
[17:39:55.748]                 }
[17:39:55.748]             }
[17:39:55.748]         }
[17:39:55.748]     })
[17:39:55.748]     if (TRUE) {
[17:39:55.748]         base::sink(type = "output", split = FALSE)
[17:39:55.748]         if (TRUE) {
[17:39:55.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.748]         }
[17:39:55.748]         else {
[17:39:55.748]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.748]         }
[17:39:55.748]         base::close(...future.stdout)
[17:39:55.748]         ...future.stdout <- NULL
[17:39:55.748]     }
[17:39:55.748]     ...future.result$conditions <- ...future.conditions
[17:39:55.748]     ...future.result$finished <- base::Sys.time()
[17:39:55.748]     ...future.result
[17:39:55.748] }
[17:39:55.750] assign_globals() ...
[17:39:55.750] List of 1
[17:39:55.750]  $ pkg: chr "foo"
[17:39:55.750]  - attr(*, "where")=List of 1
[17:39:55.750]   ..$ pkg:<environment: R_EmptyEnv> 
[17:39:55.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.750]  - attr(*, "resolved")= logi TRUE
[17:39:55.750]  - attr(*, "total_size")= num 112
[17:39:55.752] - copied ‘pkg’ to environment
[17:39:55.752] assign_globals() ... done
[17:39:55.752] plan(): Setting new future strategy stack:
[17:39:55.752] List of future strategies:
[17:39:55.752] 1. sequential:
[17:39:55.752]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.752]    - tweaked: FALSE
[17:39:55.752]    - call: NULL
[17:39:55.753] plan(): nbrOfWorkers() = 1
[17:39:55.753] plan(): Setting new future strategy stack:
[17:39:55.753] List of future strategies:
[17:39:55.753] 1. sequential:
[17:39:55.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.753]    - tweaked: FALSE
[17:39:55.753]    - call: plan(strategy)
[17:39:55.754] plan(): nbrOfWorkers() = 1
[17:39:55.754] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.755] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.755] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.757] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:55.757] Searching for globals ... DONE
[17:39:55.757] Resolving globals: TRUE
[17:39:55.757] Resolving any globals that are futures ...
[17:39:55.757] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:55.758] Resolving any globals that are futures ... DONE
[17:39:55.758] Resolving futures part of globals (recursively) ...
[17:39:55.758] resolve() on list ...
[17:39:55.758]  recursive: 99
[17:39:55.758]  length: 1
[17:39:55.758]  elements: ‘a’
[17:39:55.758]  length: 0 (resolved future 1)
[17:39:55.759] resolve() on list ... DONE
[17:39:55.759] - globals: [1] ‘a’
[17:39:55.759] Resolving futures part of globals (recursively) ... DONE
[17:39:55.759] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.759] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:39:55.759] - globals: [1] ‘a’
[17:39:55.759] 
[17:39:55.759] getGlobalsAndPackages() ... DONE
[17:39:55.760] run() for ‘Future’ ...
[17:39:55.760] - state: ‘created’
[17:39:55.760] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.760] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.760] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.760]   - Field: ‘label’
[17:39:55.761]   - Field: ‘local’
[17:39:55.761]   - Field: ‘owner’
[17:39:55.761]   - Field: ‘envir’
[17:39:55.761]   - Field: ‘packages’
[17:39:55.761]   - Field: ‘gc’
[17:39:55.761]   - Field: ‘conditions’
[17:39:55.761]   - Field: ‘expr’
[17:39:55.761]   - Field: ‘uuid’
[17:39:55.761]   - Field: ‘seed’
[17:39:55.761]   - Field: ‘version’
[17:39:55.761]   - Field: ‘result’
[17:39:55.761]   - Field: ‘asynchronous’
[17:39:55.762]   - Field: ‘calls’
[17:39:55.762]   - Field: ‘globals’
[17:39:55.762]   - Field: ‘stdout’
[17:39:55.762]   - Field: ‘earlySignal’
[17:39:55.762]   - Field: ‘lazy’
[17:39:55.762]   - Field: ‘state’
[17:39:55.762] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.762] - Launch lazy future ...
[17:39:55.762] Packages needed by the future expression (n = 0): <none>
[17:39:55.762] Packages needed by future strategies (n = 0): <none>
[17:39:55.763] {
[17:39:55.763]     {
[17:39:55.763]         {
[17:39:55.763]             ...future.startTime <- base::Sys.time()
[17:39:55.763]             {
[17:39:55.763]                 {
[17:39:55.763]                   {
[17:39:55.763]                     base::local({
[17:39:55.763]                       has_future <- base::requireNamespace("future", 
[17:39:55.763]                         quietly = TRUE)
[17:39:55.763]                       if (has_future) {
[17:39:55.763]                         ns <- base::getNamespace("future")
[17:39:55.763]                         version <- ns[[".package"]][["version"]]
[17:39:55.763]                         if (is.null(version)) 
[17:39:55.763]                           version <- utils::packageVersion("future")
[17:39:55.763]                       }
[17:39:55.763]                       else {
[17:39:55.763]                         version <- NULL
[17:39:55.763]                       }
[17:39:55.763]                       if (!has_future || version < "1.8.0") {
[17:39:55.763]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.763]                           "", base::R.version$version.string), 
[17:39:55.763]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.763]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.763]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.763]                             "release", "version")], collapse = " "), 
[17:39:55.763]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.763]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.763]                           info)
[17:39:55.763]                         info <- base::paste(info, collapse = "; ")
[17:39:55.763]                         if (!has_future) {
[17:39:55.763]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.763]                             info)
[17:39:55.763]                         }
[17:39:55.763]                         else {
[17:39:55.763]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.763]                             info, version)
[17:39:55.763]                         }
[17:39:55.763]                         base::stop(msg)
[17:39:55.763]                       }
[17:39:55.763]                     })
[17:39:55.763]                   }
[17:39:55.763]                   ...future.strategy.old <- future::plan("list")
[17:39:55.763]                   options(future.plan = NULL)
[17:39:55.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.763]                 }
[17:39:55.763]                 ...future.workdir <- getwd()
[17:39:55.763]             }
[17:39:55.763]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.763]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.763]         }
[17:39:55.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.763]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.763]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.763]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.763]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.763]             base::names(...future.oldOptions))
[17:39:55.763]     }
[17:39:55.763]     if (FALSE) {
[17:39:55.763]     }
[17:39:55.763]     else {
[17:39:55.763]         if (TRUE) {
[17:39:55.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.763]                 open = "w")
[17:39:55.763]         }
[17:39:55.763]         else {
[17:39:55.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.763]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.763]         }
[17:39:55.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.763]             base::sink(type = "output", split = FALSE)
[17:39:55.763]             base::close(...future.stdout)
[17:39:55.763]         }, add = TRUE)
[17:39:55.763]     }
[17:39:55.763]     ...future.frame <- base::sys.nframe()
[17:39:55.763]     ...future.conditions <- base::list()
[17:39:55.763]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.763]     if (FALSE) {
[17:39:55.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.763]     }
[17:39:55.763]     ...future.result <- base::tryCatch({
[17:39:55.763]         base::withCallingHandlers({
[17:39:55.763]             ...future.value <- base::withVisible(base::local({
[17:39:55.763]                 b <- a
[17:39:55.763]                 a <- 2
[17:39:55.763]                 a * b
[17:39:55.763]             }))
[17:39:55.763]             future::FutureResult(value = ...future.value$value, 
[17:39:55.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.763]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.763]                     ...future.globalenv.names))
[17:39:55.763]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.763]         }, condition = base::local({
[17:39:55.763]             c <- base::c
[17:39:55.763]             inherits <- base::inherits
[17:39:55.763]             invokeRestart <- base::invokeRestart
[17:39:55.763]             length <- base::length
[17:39:55.763]             list <- base::list
[17:39:55.763]             seq.int <- base::seq.int
[17:39:55.763]             signalCondition <- base::signalCondition
[17:39:55.763]             sys.calls <- base::sys.calls
[17:39:55.763]             `[[` <- base::`[[`
[17:39:55.763]             `+` <- base::`+`
[17:39:55.763]             `<<-` <- base::`<<-`
[17:39:55.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.763]                   3L)]
[17:39:55.763]             }
[17:39:55.763]             function(cond) {
[17:39:55.763]                 is_error <- inherits(cond, "error")
[17:39:55.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.763]                   NULL)
[17:39:55.763]                 if (is_error) {
[17:39:55.763]                   sessionInformation <- function() {
[17:39:55.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.763]                       search = base::search(), system = base::Sys.info())
[17:39:55.763]                   }
[17:39:55.763]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.763]                     cond$call), session = sessionInformation(), 
[17:39:55.763]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.763]                   signalCondition(cond)
[17:39:55.763]                 }
[17:39:55.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.763]                 "immediateCondition"))) {
[17:39:55.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.763]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.763]                   if (TRUE && !signal) {
[17:39:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.763]                     {
[17:39:55.763]                       inherits <- base::inherits
[17:39:55.763]                       invokeRestart <- base::invokeRestart
[17:39:55.763]                       is.null <- base::is.null
[17:39:55.763]                       muffled <- FALSE
[17:39:55.763]                       if (inherits(cond, "message")) {
[17:39:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.763]                         if (muffled) 
[17:39:55.763]                           invokeRestart("muffleMessage")
[17:39:55.763]                       }
[17:39:55.763]                       else if (inherits(cond, "warning")) {
[17:39:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.763]                         if (muffled) 
[17:39:55.763]                           invokeRestart("muffleWarning")
[17:39:55.763]                       }
[17:39:55.763]                       else if (inherits(cond, "condition")) {
[17:39:55.763]                         if (!is.null(pattern)) {
[17:39:55.763]                           computeRestarts <- base::computeRestarts
[17:39:55.763]                           grepl <- base::grepl
[17:39:55.763]                           restarts <- computeRestarts(cond)
[17:39:55.763]                           for (restart in restarts) {
[17:39:55.763]                             name <- restart$name
[17:39:55.763]                             if (is.null(name)) 
[17:39:55.763]                               next
[17:39:55.763]                             if (!grepl(pattern, name)) 
[17:39:55.763]                               next
[17:39:55.763]                             invokeRestart(restart)
[17:39:55.763]                             muffled <- TRUE
[17:39:55.763]                             break
[17:39:55.763]                           }
[17:39:55.763]                         }
[17:39:55.763]                       }
[17:39:55.763]                       invisible(muffled)
[17:39:55.763]                     }
[17:39:55.763]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.763]                   }
[17:39:55.763]                 }
[17:39:55.763]                 else {
[17:39:55.763]                   if (TRUE) {
[17:39:55.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.763]                     {
[17:39:55.763]                       inherits <- base::inherits
[17:39:55.763]                       invokeRestart <- base::invokeRestart
[17:39:55.763]                       is.null <- base::is.null
[17:39:55.763]                       muffled <- FALSE
[17:39:55.763]                       if (inherits(cond, "message")) {
[17:39:55.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.763]                         if (muffled) 
[17:39:55.763]                           invokeRestart("muffleMessage")
[17:39:55.763]                       }
[17:39:55.763]                       else if (inherits(cond, "warning")) {
[17:39:55.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.763]                         if (muffled) 
[17:39:55.763]                           invokeRestart("muffleWarning")
[17:39:55.763]                       }
[17:39:55.763]                       else if (inherits(cond, "condition")) {
[17:39:55.763]                         if (!is.null(pattern)) {
[17:39:55.763]                           computeRestarts <- base::computeRestarts
[17:39:55.763]                           grepl <- base::grepl
[17:39:55.763]                           restarts <- computeRestarts(cond)
[17:39:55.763]                           for (restart in restarts) {
[17:39:55.763]                             name <- restart$name
[17:39:55.763]                             if (is.null(name)) 
[17:39:55.763]                               next
[17:39:55.763]                             if (!grepl(pattern, name)) 
[17:39:55.763]                               next
[17:39:55.763]                             invokeRestart(restart)
[17:39:55.763]                             muffled <- TRUE
[17:39:55.763]                             break
[17:39:55.763]                           }
[17:39:55.763]                         }
[17:39:55.763]                       }
[17:39:55.763]                       invisible(muffled)
[17:39:55.763]                     }
[17:39:55.763]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.763]                   }
[17:39:55.763]                 }
[17:39:55.763]             }
[17:39:55.763]         }))
[17:39:55.763]     }, error = function(ex) {
[17:39:55.763]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.763]                 ...future.rng), started = ...future.startTime, 
[17:39:55.763]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.763]             version = "1.8"), class = "FutureResult")
[17:39:55.763]     }, finally = {
[17:39:55.763]         if (!identical(...future.workdir, getwd())) 
[17:39:55.763]             setwd(...future.workdir)
[17:39:55.763]         {
[17:39:55.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.763]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.763]             }
[17:39:55.763]             base::options(...future.oldOptions)
[17:39:55.763]             if (.Platform$OS.type == "windows") {
[17:39:55.763]                 old_names <- names(...future.oldEnvVars)
[17:39:55.763]                 envs <- base::Sys.getenv()
[17:39:55.763]                 names <- names(envs)
[17:39:55.763]                 common <- intersect(names, old_names)
[17:39:55.763]                 added <- setdiff(names, old_names)
[17:39:55.763]                 removed <- setdiff(old_names, names)
[17:39:55.763]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.763]                   envs[common]]
[17:39:55.763]                 NAMES <- toupper(changed)
[17:39:55.763]                 args <- list()
[17:39:55.763]                 for (kk in seq_along(NAMES)) {
[17:39:55.763]                   name <- changed[[kk]]
[17:39:55.763]                   NAME <- NAMES[[kk]]
[17:39:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.763]                     next
[17:39:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.763]                 }
[17:39:55.763]                 NAMES <- toupper(added)
[17:39:55.763]                 for (kk in seq_along(NAMES)) {
[17:39:55.763]                   name <- added[[kk]]
[17:39:55.763]                   NAME <- NAMES[[kk]]
[17:39:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.763]                     next
[17:39:55.763]                   args[[name]] <- ""
[17:39:55.763]                 }
[17:39:55.763]                 NAMES <- toupper(removed)
[17:39:55.763]                 for (kk in seq_along(NAMES)) {
[17:39:55.763]                   name <- removed[[kk]]
[17:39:55.763]                   NAME <- NAMES[[kk]]
[17:39:55.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.763]                     next
[17:39:55.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.763]                 }
[17:39:55.763]                 if (length(args) > 0) 
[17:39:55.763]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.763]             }
[17:39:55.763]             else {
[17:39:55.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.763]             }
[17:39:55.763]             {
[17:39:55.763]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.763]                   0L) {
[17:39:55.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.763]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.763]                   base::options(opts)
[17:39:55.763]                 }
[17:39:55.763]                 {
[17:39:55.763]                   {
[17:39:55.763]                     NULL
[17:39:55.763]                     RNGkind("Mersenne-Twister")
[17:39:55.763]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.763]                       inherits = FALSE)
[17:39:55.763]                   }
[17:39:55.763]                   options(future.plan = NULL)
[17:39:55.763]                   if (is.na(NA_character_)) 
[17:39:55.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.763]                     .init = FALSE)
[17:39:55.763]                 }
[17:39:55.763]             }
[17:39:55.763]         }
[17:39:55.763]     })
[17:39:55.763]     if (TRUE) {
[17:39:55.763]         base::sink(type = "output", split = FALSE)
[17:39:55.763]         if (TRUE) {
[17:39:55.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.763]         }
[17:39:55.763]         else {
[17:39:55.763]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.763]         }
[17:39:55.763]         base::close(...future.stdout)
[17:39:55.763]         ...future.stdout <- NULL
[17:39:55.763]     }
[17:39:55.763]     ...future.result$conditions <- ...future.conditions
[17:39:55.763]     ...future.result$finished <- base::Sys.time()
[17:39:55.763]     ...future.result
[17:39:55.763] }
[17:39:55.764] assign_globals() ...
[17:39:55.764] List of 1
[17:39:55.764]  $ a: num 3
[17:39:55.764]  - attr(*, "where")=List of 1
[17:39:55.764]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.764]  - attr(*, "resolved")= logi TRUE
[17:39:55.764]  - attr(*, "total_size")= num 56
[17:39:55.764]  - attr(*, "already-done")= logi TRUE
[17:39:55.768] - copied ‘a’ to environment
[17:39:55.769] assign_globals() ... done
[17:39:55.769] plan(): Setting new future strategy stack:
[17:39:55.769] List of future strategies:
[17:39:55.769] 1. sequential:
[17:39:55.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.769]    - tweaked: FALSE
[17:39:55.769]    - call: NULL
[17:39:55.769] plan(): nbrOfWorkers() = 1
[17:39:55.770] plan(): Setting new future strategy stack:
[17:39:55.770] List of future strategies:
[17:39:55.770] 1. sequential:
[17:39:55.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.770]    - tweaked: FALSE
[17:39:55.770]    - call: plan(strategy)
[17:39:55.771] plan(): nbrOfWorkers() = 1
[17:39:55.771] SequentialFuture started (and completed)
[17:39:55.771] - Launch lazy future ... done
[17:39:55.771] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.771] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.772] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.773] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:55.773] Searching for globals ... DONE
[17:39:55.774] Resolving globals: TRUE
[17:39:55.774] Resolving any globals that are futures ...
[17:39:55.774] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:55.774] Resolving any globals that are futures ... DONE
[17:39:55.774] Resolving futures part of globals (recursively) ...
[17:39:55.774] resolve() on list ...
[17:39:55.774]  recursive: 99
[17:39:55.775]  length: 1
[17:39:55.775]  elements: ‘a’
[17:39:55.775]  length: 0 (resolved future 1)
[17:39:55.775] resolve() on list ... DONE
[17:39:55.775] - globals: [1] ‘a’
[17:39:55.775] Resolving futures part of globals (recursively) ... DONE
[17:39:55.775] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:55.776] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:39:55.776] - globals: [1] ‘a’
[17:39:55.776] 
[17:39:55.776] getGlobalsAndPackages() ... DONE
[17:39:55.776] run() for ‘Future’ ...
[17:39:55.776] - state: ‘created’
[17:39:55.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.777] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.777]   - Field: ‘label’
[17:39:55.777]   - Field: ‘local’
[17:39:55.777]   - Field: ‘owner’
[17:39:55.777]   - Field: ‘envir’
[17:39:55.777]   - Field: ‘packages’
[17:39:55.777]   - Field: ‘gc’
[17:39:55.777]   - Field: ‘conditions’
[17:39:55.778]   - Field: ‘expr’
[17:39:55.778]   - Field: ‘uuid’
[17:39:55.778]   - Field: ‘seed’
[17:39:55.778]   - Field: ‘version’
[17:39:55.778]   - Field: ‘result’
[17:39:55.778]   - Field: ‘asynchronous’
[17:39:55.778]   - Field: ‘calls’
[17:39:55.778]   - Field: ‘globals’
[17:39:55.778]   - Field: ‘stdout’
[17:39:55.778]   - Field: ‘earlySignal’
[17:39:55.778]   - Field: ‘lazy’
[17:39:55.778]   - Field: ‘state’
[17:39:55.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.779] - Launch lazy future ...
[17:39:55.779] Packages needed by the future expression (n = 0): <none>
[17:39:55.779] Packages needed by future strategies (n = 0): <none>
[17:39:55.779] {
[17:39:55.779]     {
[17:39:55.779]         {
[17:39:55.779]             ...future.startTime <- base::Sys.time()
[17:39:55.779]             {
[17:39:55.779]                 {
[17:39:55.779]                   {
[17:39:55.779]                     base::local({
[17:39:55.779]                       has_future <- base::requireNamespace("future", 
[17:39:55.779]                         quietly = TRUE)
[17:39:55.779]                       if (has_future) {
[17:39:55.779]                         ns <- base::getNamespace("future")
[17:39:55.779]                         version <- ns[[".package"]][["version"]]
[17:39:55.779]                         if (is.null(version)) 
[17:39:55.779]                           version <- utils::packageVersion("future")
[17:39:55.779]                       }
[17:39:55.779]                       else {
[17:39:55.779]                         version <- NULL
[17:39:55.779]                       }
[17:39:55.779]                       if (!has_future || version < "1.8.0") {
[17:39:55.779]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.779]                           "", base::R.version$version.string), 
[17:39:55.779]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.779]                             "release", "version")], collapse = " "), 
[17:39:55.779]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.779]                           info)
[17:39:55.779]                         info <- base::paste(info, collapse = "; ")
[17:39:55.779]                         if (!has_future) {
[17:39:55.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.779]                             info)
[17:39:55.779]                         }
[17:39:55.779]                         else {
[17:39:55.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.779]                             info, version)
[17:39:55.779]                         }
[17:39:55.779]                         base::stop(msg)
[17:39:55.779]                       }
[17:39:55.779]                     })
[17:39:55.779]                   }
[17:39:55.779]                   ...future.strategy.old <- future::plan("list")
[17:39:55.779]                   options(future.plan = NULL)
[17:39:55.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.779]                 }
[17:39:55.779]                 ...future.workdir <- getwd()
[17:39:55.779]             }
[17:39:55.779]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.779]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.779]         }
[17:39:55.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.779]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.779]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.779]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.779]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.779]             base::names(...future.oldOptions))
[17:39:55.779]     }
[17:39:55.779]     if (FALSE) {
[17:39:55.779]     }
[17:39:55.779]     else {
[17:39:55.779]         if (TRUE) {
[17:39:55.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.779]                 open = "w")
[17:39:55.779]         }
[17:39:55.779]         else {
[17:39:55.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.779]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.779]         }
[17:39:55.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.779]             base::sink(type = "output", split = FALSE)
[17:39:55.779]             base::close(...future.stdout)
[17:39:55.779]         }, add = TRUE)
[17:39:55.779]     }
[17:39:55.779]     ...future.frame <- base::sys.nframe()
[17:39:55.779]     ...future.conditions <- base::list()
[17:39:55.779]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.779]     if (FALSE) {
[17:39:55.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.779]     }
[17:39:55.779]     ...future.result <- base::tryCatch({
[17:39:55.779]         base::withCallingHandlers({
[17:39:55.779]             ...future.value <- base::withVisible(base::local({
[17:39:55.779]                 b <- a
[17:39:55.779]                 a <- 2
[17:39:55.779]                 a * b
[17:39:55.779]             }))
[17:39:55.779]             future::FutureResult(value = ...future.value$value, 
[17:39:55.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.779]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.779]                     ...future.globalenv.names))
[17:39:55.779]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.779]         }, condition = base::local({
[17:39:55.779]             c <- base::c
[17:39:55.779]             inherits <- base::inherits
[17:39:55.779]             invokeRestart <- base::invokeRestart
[17:39:55.779]             length <- base::length
[17:39:55.779]             list <- base::list
[17:39:55.779]             seq.int <- base::seq.int
[17:39:55.779]             signalCondition <- base::signalCondition
[17:39:55.779]             sys.calls <- base::sys.calls
[17:39:55.779]             `[[` <- base::`[[`
[17:39:55.779]             `+` <- base::`+`
[17:39:55.779]             `<<-` <- base::`<<-`
[17:39:55.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.779]                   3L)]
[17:39:55.779]             }
[17:39:55.779]             function(cond) {
[17:39:55.779]                 is_error <- inherits(cond, "error")
[17:39:55.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.779]                   NULL)
[17:39:55.779]                 if (is_error) {
[17:39:55.779]                   sessionInformation <- function() {
[17:39:55.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.779]                       search = base::search(), system = base::Sys.info())
[17:39:55.779]                   }
[17:39:55.779]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.779]                     cond$call), session = sessionInformation(), 
[17:39:55.779]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.779]                   signalCondition(cond)
[17:39:55.779]                 }
[17:39:55.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.779]                 "immediateCondition"))) {
[17:39:55.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.779]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.779]                   if (TRUE && !signal) {
[17:39:55.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.779]                     {
[17:39:55.779]                       inherits <- base::inherits
[17:39:55.779]                       invokeRestart <- base::invokeRestart
[17:39:55.779]                       is.null <- base::is.null
[17:39:55.779]                       muffled <- FALSE
[17:39:55.779]                       if (inherits(cond, "message")) {
[17:39:55.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.779]                         if (muffled) 
[17:39:55.779]                           invokeRestart("muffleMessage")
[17:39:55.779]                       }
[17:39:55.779]                       else if (inherits(cond, "warning")) {
[17:39:55.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.779]                         if (muffled) 
[17:39:55.779]                           invokeRestart("muffleWarning")
[17:39:55.779]                       }
[17:39:55.779]                       else if (inherits(cond, "condition")) {
[17:39:55.779]                         if (!is.null(pattern)) {
[17:39:55.779]                           computeRestarts <- base::computeRestarts
[17:39:55.779]                           grepl <- base::grepl
[17:39:55.779]                           restarts <- computeRestarts(cond)
[17:39:55.779]                           for (restart in restarts) {
[17:39:55.779]                             name <- restart$name
[17:39:55.779]                             if (is.null(name)) 
[17:39:55.779]                               next
[17:39:55.779]                             if (!grepl(pattern, name)) 
[17:39:55.779]                               next
[17:39:55.779]                             invokeRestart(restart)
[17:39:55.779]                             muffled <- TRUE
[17:39:55.779]                             break
[17:39:55.779]                           }
[17:39:55.779]                         }
[17:39:55.779]                       }
[17:39:55.779]                       invisible(muffled)
[17:39:55.779]                     }
[17:39:55.779]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.779]                   }
[17:39:55.779]                 }
[17:39:55.779]                 else {
[17:39:55.779]                   if (TRUE) {
[17:39:55.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.779]                     {
[17:39:55.779]                       inherits <- base::inherits
[17:39:55.779]                       invokeRestart <- base::invokeRestart
[17:39:55.779]                       is.null <- base::is.null
[17:39:55.779]                       muffled <- FALSE
[17:39:55.779]                       if (inherits(cond, "message")) {
[17:39:55.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.779]                         if (muffled) 
[17:39:55.779]                           invokeRestart("muffleMessage")
[17:39:55.779]                       }
[17:39:55.779]                       else if (inherits(cond, "warning")) {
[17:39:55.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.779]                         if (muffled) 
[17:39:55.779]                           invokeRestart("muffleWarning")
[17:39:55.779]                       }
[17:39:55.779]                       else if (inherits(cond, "condition")) {
[17:39:55.779]                         if (!is.null(pattern)) {
[17:39:55.779]                           computeRestarts <- base::computeRestarts
[17:39:55.779]                           grepl <- base::grepl
[17:39:55.779]                           restarts <- computeRestarts(cond)
[17:39:55.779]                           for (restart in restarts) {
[17:39:55.779]                             name <- restart$name
[17:39:55.779]                             if (is.null(name)) 
[17:39:55.779]                               next
[17:39:55.779]                             if (!grepl(pattern, name)) 
[17:39:55.779]                               next
[17:39:55.779]                             invokeRestart(restart)
[17:39:55.779]                             muffled <- TRUE
[17:39:55.779]                             break
[17:39:55.779]                           }
[17:39:55.779]                         }
[17:39:55.779]                       }
[17:39:55.779]                       invisible(muffled)
[17:39:55.779]                     }
[17:39:55.779]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.779]                   }
[17:39:55.779]                 }
[17:39:55.779]             }
[17:39:55.779]         }))
[17:39:55.779]     }, error = function(ex) {
[17:39:55.779]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.779]                 ...future.rng), started = ...future.startTime, 
[17:39:55.779]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.779]             version = "1.8"), class = "FutureResult")
[17:39:55.779]     }, finally = {
[17:39:55.779]         if (!identical(...future.workdir, getwd())) 
[17:39:55.779]             setwd(...future.workdir)
[17:39:55.779]         {
[17:39:55.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.779]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.779]             }
[17:39:55.779]             base::options(...future.oldOptions)
[17:39:55.779]             if (.Platform$OS.type == "windows") {
[17:39:55.779]                 old_names <- names(...future.oldEnvVars)
[17:39:55.779]                 envs <- base::Sys.getenv()
[17:39:55.779]                 names <- names(envs)
[17:39:55.779]                 common <- intersect(names, old_names)
[17:39:55.779]                 added <- setdiff(names, old_names)
[17:39:55.779]                 removed <- setdiff(old_names, names)
[17:39:55.779]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.779]                   envs[common]]
[17:39:55.779]                 NAMES <- toupper(changed)
[17:39:55.779]                 args <- list()
[17:39:55.779]                 for (kk in seq_along(NAMES)) {
[17:39:55.779]                   name <- changed[[kk]]
[17:39:55.779]                   NAME <- NAMES[[kk]]
[17:39:55.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.779]                     next
[17:39:55.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.779]                 }
[17:39:55.779]                 NAMES <- toupper(added)
[17:39:55.779]                 for (kk in seq_along(NAMES)) {
[17:39:55.779]                   name <- added[[kk]]
[17:39:55.779]                   NAME <- NAMES[[kk]]
[17:39:55.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.779]                     next
[17:39:55.779]                   args[[name]] <- ""
[17:39:55.779]                 }
[17:39:55.779]                 NAMES <- toupper(removed)
[17:39:55.779]                 for (kk in seq_along(NAMES)) {
[17:39:55.779]                   name <- removed[[kk]]
[17:39:55.779]                   NAME <- NAMES[[kk]]
[17:39:55.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.779]                     next
[17:39:55.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.779]                 }
[17:39:55.779]                 if (length(args) > 0) 
[17:39:55.779]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.779]             }
[17:39:55.779]             else {
[17:39:55.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.779]             }
[17:39:55.779]             {
[17:39:55.779]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.779]                   0L) {
[17:39:55.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.779]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.779]                   base::options(opts)
[17:39:55.779]                 }
[17:39:55.779]                 {
[17:39:55.779]                   {
[17:39:55.779]                     NULL
[17:39:55.779]                     RNGkind("Mersenne-Twister")
[17:39:55.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.779]                       inherits = FALSE)
[17:39:55.779]                   }
[17:39:55.779]                   options(future.plan = NULL)
[17:39:55.779]                   if (is.na(NA_character_)) 
[17:39:55.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.779]                     .init = FALSE)
[17:39:55.779]                 }
[17:39:55.779]             }
[17:39:55.779]         }
[17:39:55.779]     })
[17:39:55.779]     if (TRUE) {
[17:39:55.779]         base::sink(type = "output", split = FALSE)
[17:39:55.779]         if (TRUE) {
[17:39:55.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.779]         }
[17:39:55.779]         else {
[17:39:55.779]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.779]         }
[17:39:55.779]         base::close(...future.stdout)
[17:39:55.779]         ...future.stdout <- NULL
[17:39:55.779]     }
[17:39:55.779]     ...future.result$conditions <- ...future.conditions
[17:39:55.779]     ...future.result$finished <- base::Sys.time()
[17:39:55.779]     ...future.result
[17:39:55.779] }
[17:39:55.781] assign_globals() ...
[17:39:55.781] List of 1
[17:39:55.781]  $ a: num 3
[17:39:55.781]  - attr(*, "where")=List of 1
[17:39:55.781]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.781]  - attr(*, "resolved")= logi TRUE
[17:39:55.781]  - attr(*, "total_size")= num 56
[17:39:55.781]  - attr(*, "already-done")= logi TRUE
[17:39:55.783] - copied ‘a’ to environment
[17:39:55.783] assign_globals() ... done
[17:39:55.784] plan(): Setting new future strategy stack:
[17:39:55.784] List of future strategies:
[17:39:55.784] 1. sequential:
[17:39:55.784]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.784]    - tweaked: FALSE
[17:39:55.784]    - call: NULL
[17:39:55.784] plan(): nbrOfWorkers() = 1
[17:39:55.785] plan(): Setting new future strategy stack:
[17:39:55.785] List of future strategies:
[17:39:55.785] 1. sequential:
[17:39:55.785]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.785]    - tweaked: FALSE
[17:39:55.785]    - call: plan(strategy)
[17:39:55.785] plan(): nbrOfWorkers() = 1
[17:39:55.785] SequentialFuture started (and completed)
[17:39:55.786] - Launch lazy future ... done
[17:39:55.786] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.786] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.786] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.788] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.788] Searching for globals ... DONE
[17:39:55.788] Resolving globals: TRUE
[17:39:55.788] Resolving any globals that are futures ...
[17:39:55.788] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.789] Resolving any globals that are futures ... DONE
[17:39:55.789] Resolving futures part of globals (recursively) ...
[17:39:55.789] resolve() on list ...
[17:39:55.789]  recursive: 99
[17:39:55.789]  length: 2
[17:39:55.789]  elements: ‘a’, ‘ii’
[17:39:55.790]  length: 1 (resolved future 1)
[17:39:55.790]  length: 0 (resolved future 2)
[17:39:55.790] resolve() on list ... DONE
[17:39:55.790] - globals: [2] ‘a’, ‘ii’
[17:39:55.790] Resolving futures part of globals (recursively) ... DONE
[17:39:55.791] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:55.792] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.792] - globals: [2] ‘a’, ‘ii’
[17:39:55.792] 
[17:39:55.792] getGlobalsAndPackages() ... DONE
[17:39:55.792] run() for ‘Future’ ...
[17:39:55.792] - state: ‘created’
[17:39:55.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.793] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.793]   - Field: ‘label’
[17:39:55.793]   - Field: ‘local’
[17:39:55.793]   - Field: ‘owner’
[17:39:55.793]   - Field: ‘envir’
[17:39:55.793]   - Field: ‘packages’
[17:39:55.793]   - Field: ‘gc’
[17:39:55.794]   - Field: ‘conditions’
[17:39:55.794]   - Field: ‘expr’
[17:39:55.794]   - Field: ‘uuid’
[17:39:55.794]   - Field: ‘seed’
[17:39:55.794]   - Field: ‘version’
[17:39:55.794]   - Field: ‘result’
[17:39:55.794]   - Field: ‘asynchronous’
[17:39:55.794]   - Field: ‘calls’
[17:39:55.794]   - Field: ‘globals’
[17:39:55.794]   - Field: ‘stdout’
[17:39:55.794]   - Field: ‘earlySignal’
[17:39:55.794]   - Field: ‘lazy’
[17:39:55.795]   - Field: ‘state’
[17:39:55.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.795] - Launch lazy future ...
[17:39:55.795] Packages needed by the future expression (n = 0): <none>
[17:39:55.795] Packages needed by future strategies (n = 0): <none>
[17:39:55.795] {
[17:39:55.795]     {
[17:39:55.795]         {
[17:39:55.795]             ...future.startTime <- base::Sys.time()
[17:39:55.795]             {
[17:39:55.795]                 {
[17:39:55.795]                   {
[17:39:55.795]                     base::local({
[17:39:55.795]                       has_future <- base::requireNamespace("future", 
[17:39:55.795]                         quietly = TRUE)
[17:39:55.795]                       if (has_future) {
[17:39:55.795]                         ns <- base::getNamespace("future")
[17:39:55.795]                         version <- ns[[".package"]][["version"]]
[17:39:55.795]                         if (is.null(version)) 
[17:39:55.795]                           version <- utils::packageVersion("future")
[17:39:55.795]                       }
[17:39:55.795]                       else {
[17:39:55.795]                         version <- NULL
[17:39:55.795]                       }
[17:39:55.795]                       if (!has_future || version < "1.8.0") {
[17:39:55.795]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.795]                           "", base::R.version$version.string), 
[17:39:55.795]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.795]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.795]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.795]                             "release", "version")], collapse = " "), 
[17:39:55.795]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.795]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.795]                           info)
[17:39:55.795]                         info <- base::paste(info, collapse = "; ")
[17:39:55.795]                         if (!has_future) {
[17:39:55.795]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.795]                             info)
[17:39:55.795]                         }
[17:39:55.795]                         else {
[17:39:55.795]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.795]                             info, version)
[17:39:55.795]                         }
[17:39:55.795]                         base::stop(msg)
[17:39:55.795]                       }
[17:39:55.795]                     })
[17:39:55.795]                   }
[17:39:55.795]                   ...future.strategy.old <- future::plan("list")
[17:39:55.795]                   options(future.plan = NULL)
[17:39:55.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.795]                 }
[17:39:55.795]                 ...future.workdir <- getwd()
[17:39:55.795]             }
[17:39:55.795]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.795]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.795]         }
[17:39:55.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.795]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.795]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.795]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.795]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.795]             base::names(...future.oldOptions))
[17:39:55.795]     }
[17:39:55.795]     if (FALSE) {
[17:39:55.795]     }
[17:39:55.795]     else {
[17:39:55.795]         if (TRUE) {
[17:39:55.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.795]                 open = "w")
[17:39:55.795]         }
[17:39:55.795]         else {
[17:39:55.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.795]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.795]         }
[17:39:55.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.795]             base::sink(type = "output", split = FALSE)
[17:39:55.795]             base::close(...future.stdout)
[17:39:55.795]         }, add = TRUE)
[17:39:55.795]     }
[17:39:55.795]     ...future.frame <- base::sys.nframe()
[17:39:55.795]     ...future.conditions <- base::list()
[17:39:55.795]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.795]     if (FALSE) {
[17:39:55.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.795]     }
[17:39:55.795]     ...future.result <- base::tryCatch({
[17:39:55.795]         base::withCallingHandlers({
[17:39:55.795]             ...future.value <- base::withVisible(base::local({
[17:39:55.795]                 b <- a * ii
[17:39:55.795]                 a <- 0
[17:39:55.795]                 b
[17:39:55.795]             }))
[17:39:55.795]             future::FutureResult(value = ...future.value$value, 
[17:39:55.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.795]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.795]                     ...future.globalenv.names))
[17:39:55.795]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.795]         }, condition = base::local({
[17:39:55.795]             c <- base::c
[17:39:55.795]             inherits <- base::inherits
[17:39:55.795]             invokeRestart <- base::invokeRestart
[17:39:55.795]             length <- base::length
[17:39:55.795]             list <- base::list
[17:39:55.795]             seq.int <- base::seq.int
[17:39:55.795]             signalCondition <- base::signalCondition
[17:39:55.795]             sys.calls <- base::sys.calls
[17:39:55.795]             `[[` <- base::`[[`
[17:39:55.795]             `+` <- base::`+`
[17:39:55.795]             `<<-` <- base::`<<-`
[17:39:55.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.795]                   3L)]
[17:39:55.795]             }
[17:39:55.795]             function(cond) {
[17:39:55.795]                 is_error <- inherits(cond, "error")
[17:39:55.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.795]                   NULL)
[17:39:55.795]                 if (is_error) {
[17:39:55.795]                   sessionInformation <- function() {
[17:39:55.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.795]                       search = base::search(), system = base::Sys.info())
[17:39:55.795]                   }
[17:39:55.795]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.795]                     cond$call), session = sessionInformation(), 
[17:39:55.795]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.795]                   signalCondition(cond)
[17:39:55.795]                 }
[17:39:55.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.795]                 "immediateCondition"))) {
[17:39:55.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.795]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.795]                   if (TRUE && !signal) {
[17:39:55.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.795]                     {
[17:39:55.795]                       inherits <- base::inherits
[17:39:55.795]                       invokeRestart <- base::invokeRestart
[17:39:55.795]                       is.null <- base::is.null
[17:39:55.795]                       muffled <- FALSE
[17:39:55.795]                       if (inherits(cond, "message")) {
[17:39:55.795]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.795]                         if (muffled) 
[17:39:55.795]                           invokeRestart("muffleMessage")
[17:39:55.795]                       }
[17:39:55.795]                       else if (inherits(cond, "warning")) {
[17:39:55.795]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.795]                         if (muffled) 
[17:39:55.795]                           invokeRestart("muffleWarning")
[17:39:55.795]                       }
[17:39:55.795]                       else if (inherits(cond, "condition")) {
[17:39:55.795]                         if (!is.null(pattern)) {
[17:39:55.795]                           computeRestarts <- base::computeRestarts
[17:39:55.795]                           grepl <- base::grepl
[17:39:55.795]                           restarts <- computeRestarts(cond)
[17:39:55.795]                           for (restart in restarts) {
[17:39:55.795]                             name <- restart$name
[17:39:55.795]                             if (is.null(name)) 
[17:39:55.795]                               next
[17:39:55.795]                             if (!grepl(pattern, name)) 
[17:39:55.795]                               next
[17:39:55.795]                             invokeRestart(restart)
[17:39:55.795]                             muffled <- TRUE
[17:39:55.795]                             break
[17:39:55.795]                           }
[17:39:55.795]                         }
[17:39:55.795]                       }
[17:39:55.795]                       invisible(muffled)
[17:39:55.795]                     }
[17:39:55.795]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.795]                   }
[17:39:55.795]                 }
[17:39:55.795]                 else {
[17:39:55.795]                   if (TRUE) {
[17:39:55.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.795]                     {
[17:39:55.795]                       inherits <- base::inherits
[17:39:55.795]                       invokeRestart <- base::invokeRestart
[17:39:55.795]                       is.null <- base::is.null
[17:39:55.795]                       muffled <- FALSE
[17:39:55.795]                       if (inherits(cond, "message")) {
[17:39:55.795]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.795]                         if (muffled) 
[17:39:55.795]                           invokeRestart("muffleMessage")
[17:39:55.795]                       }
[17:39:55.795]                       else if (inherits(cond, "warning")) {
[17:39:55.795]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.795]                         if (muffled) 
[17:39:55.795]                           invokeRestart("muffleWarning")
[17:39:55.795]                       }
[17:39:55.795]                       else if (inherits(cond, "condition")) {
[17:39:55.795]                         if (!is.null(pattern)) {
[17:39:55.795]                           computeRestarts <- base::computeRestarts
[17:39:55.795]                           grepl <- base::grepl
[17:39:55.795]                           restarts <- computeRestarts(cond)
[17:39:55.795]                           for (restart in restarts) {
[17:39:55.795]                             name <- restart$name
[17:39:55.795]                             if (is.null(name)) 
[17:39:55.795]                               next
[17:39:55.795]                             if (!grepl(pattern, name)) 
[17:39:55.795]                               next
[17:39:55.795]                             invokeRestart(restart)
[17:39:55.795]                             muffled <- TRUE
[17:39:55.795]                             break
[17:39:55.795]                           }
[17:39:55.795]                         }
[17:39:55.795]                       }
[17:39:55.795]                       invisible(muffled)
[17:39:55.795]                     }
[17:39:55.795]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.795]                   }
[17:39:55.795]                 }
[17:39:55.795]             }
[17:39:55.795]         }))
[17:39:55.795]     }, error = function(ex) {
[17:39:55.795]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.795]                 ...future.rng), started = ...future.startTime, 
[17:39:55.795]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.795]             version = "1.8"), class = "FutureResult")
[17:39:55.795]     }, finally = {
[17:39:55.795]         if (!identical(...future.workdir, getwd())) 
[17:39:55.795]             setwd(...future.workdir)
[17:39:55.795]         {
[17:39:55.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.795]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.795]             }
[17:39:55.795]             base::options(...future.oldOptions)
[17:39:55.795]             if (.Platform$OS.type == "windows") {
[17:39:55.795]                 old_names <- names(...future.oldEnvVars)
[17:39:55.795]                 envs <- base::Sys.getenv()
[17:39:55.795]                 names <- names(envs)
[17:39:55.795]                 common <- intersect(names, old_names)
[17:39:55.795]                 added <- setdiff(names, old_names)
[17:39:55.795]                 removed <- setdiff(old_names, names)
[17:39:55.795]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.795]                   envs[common]]
[17:39:55.795]                 NAMES <- toupper(changed)
[17:39:55.795]                 args <- list()
[17:39:55.795]                 for (kk in seq_along(NAMES)) {
[17:39:55.795]                   name <- changed[[kk]]
[17:39:55.795]                   NAME <- NAMES[[kk]]
[17:39:55.795]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.795]                     next
[17:39:55.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.795]                 }
[17:39:55.795]                 NAMES <- toupper(added)
[17:39:55.795]                 for (kk in seq_along(NAMES)) {
[17:39:55.795]                   name <- added[[kk]]
[17:39:55.795]                   NAME <- NAMES[[kk]]
[17:39:55.795]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.795]                     next
[17:39:55.795]                   args[[name]] <- ""
[17:39:55.795]                 }
[17:39:55.795]                 NAMES <- toupper(removed)
[17:39:55.795]                 for (kk in seq_along(NAMES)) {
[17:39:55.795]                   name <- removed[[kk]]
[17:39:55.795]                   NAME <- NAMES[[kk]]
[17:39:55.795]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.795]                     next
[17:39:55.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.795]                 }
[17:39:55.795]                 if (length(args) > 0) 
[17:39:55.795]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.795]             }
[17:39:55.795]             else {
[17:39:55.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.795]             }
[17:39:55.795]             {
[17:39:55.795]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.795]                   0L) {
[17:39:55.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.795]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.795]                   base::options(opts)
[17:39:55.795]                 }
[17:39:55.795]                 {
[17:39:55.795]                   {
[17:39:55.795]                     NULL
[17:39:55.795]                     RNGkind("Mersenne-Twister")
[17:39:55.795]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.795]                       inherits = FALSE)
[17:39:55.795]                   }
[17:39:55.795]                   options(future.plan = NULL)
[17:39:55.795]                   if (is.na(NA_character_)) 
[17:39:55.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.795]                     .init = FALSE)
[17:39:55.795]                 }
[17:39:55.795]             }
[17:39:55.795]         }
[17:39:55.795]     })
[17:39:55.795]     if (TRUE) {
[17:39:55.795]         base::sink(type = "output", split = FALSE)
[17:39:55.795]         if (TRUE) {
[17:39:55.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.795]         }
[17:39:55.795]         else {
[17:39:55.795]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.795]         }
[17:39:55.795]         base::close(...future.stdout)
[17:39:55.795]         ...future.stdout <- NULL
[17:39:55.795]     }
[17:39:55.795]     ...future.result$conditions <- ...future.conditions
[17:39:55.795]     ...future.result$finished <- base::Sys.time()
[17:39:55.795]     ...future.result
[17:39:55.795] }
[17:39:55.797] assign_globals() ...
[17:39:55.797] List of 2
[17:39:55.797]  $ a : num 1
[17:39:55.797]  $ ii: int 1
[17:39:55.797]  - attr(*, "where")=List of 2
[17:39:55.797]   ..$ a :<environment: R_EmptyEnv> 
[17:39:55.797]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.797]  - attr(*, "resolved")= logi TRUE
[17:39:55.797]  - attr(*, "total_size")= num 112
[17:39:55.797]  - attr(*, "already-done")= logi TRUE
[17:39:55.800] - copied ‘a’ to environment
[17:39:55.800] - copied ‘ii’ to environment
[17:39:55.800] assign_globals() ... done
[17:39:55.800] plan(): Setting new future strategy stack:
[17:39:55.800] List of future strategies:
[17:39:55.800] 1. sequential:
[17:39:55.800]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.800]    - tweaked: FALSE
[17:39:55.800]    - call: NULL
[17:39:55.801] plan(): nbrOfWorkers() = 1
[17:39:55.801] plan(): Setting new future strategy stack:
[17:39:55.802] List of future strategies:
[17:39:55.802] 1. sequential:
[17:39:55.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.802]    - tweaked: FALSE
[17:39:55.802]    - call: plan(strategy)
[17:39:55.802] plan(): nbrOfWorkers() = 1
[17:39:55.802] SequentialFuture started (and completed)
[17:39:55.802] - Launch lazy future ... done
[17:39:55.802] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.803] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.803] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.805] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.805] Searching for globals ... DONE
[17:39:55.805] Resolving globals: TRUE
[17:39:55.805] Resolving any globals that are futures ...
[17:39:55.805] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.805] Resolving any globals that are futures ... DONE
[17:39:55.805] Resolving futures part of globals (recursively) ...
[17:39:55.806] resolve() on list ...
[17:39:55.806]  recursive: 99
[17:39:55.806]  length: 2
[17:39:55.806]  elements: ‘a’, ‘ii’
[17:39:55.806]  length: 1 (resolved future 1)
[17:39:55.806]  length: 0 (resolved future 2)
[17:39:55.806] resolve() on list ... DONE
[17:39:55.806] - globals: [2] ‘a’, ‘ii’
[17:39:55.806] Resolving futures part of globals (recursively) ... DONE
[17:39:55.806] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:55.807] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.807] - globals: [2] ‘a’, ‘ii’
[17:39:55.807] 
[17:39:55.807] getGlobalsAndPackages() ... DONE
[17:39:55.807] run() for ‘Future’ ...
[17:39:55.807] - state: ‘created’
[17:39:55.808] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.808] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.808]   - Field: ‘label’
[17:39:55.808]   - Field: ‘local’
[17:39:55.808]   - Field: ‘owner’
[17:39:55.808]   - Field: ‘envir’
[17:39:55.808]   - Field: ‘packages’
[17:39:55.808]   - Field: ‘gc’
[17:39:55.808]   - Field: ‘conditions’
[17:39:55.809]   - Field: ‘expr’
[17:39:55.809]   - Field: ‘uuid’
[17:39:55.809]   - Field: ‘seed’
[17:39:55.809]   - Field: ‘version’
[17:39:55.809]   - Field: ‘result’
[17:39:55.809]   - Field: ‘asynchronous’
[17:39:55.809]   - Field: ‘calls’
[17:39:55.809]   - Field: ‘globals’
[17:39:55.809]   - Field: ‘stdout’
[17:39:55.809]   - Field: ‘earlySignal’
[17:39:55.809]   - Field: ‘lazy’
[17:39:55.810]   - Field: ‘state’
[17:39:55.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.810] - Launch lazy future ...
[17:39:55.810] Packages needed by the future expression (n = 0): <none>
[17:39:55.810] Packages needed by future strategies (n = 0): <none>
[17:39:55.810] {
[17:39:55.810]     {
[17:39:55.810]         {
[17:39:55.810]             ...future.startTime <- base::Sys.time()
[17:39:55.810]             {
[17:39:55.810]                 {
[17:39:55.810]                   {
[17:39:55.810]                     base::local({
[17:39:55.810]                       has_future <- base::requireNamespace("future", 
[17:39:55.810]                         quietly = TRUE)
[17:39:55.810]                       if (has_future) {
[17:39:55.810]                         ns <- base::getNamespace("future")
[17:39:55.810]                         version <- ns[[".package"]][["version"]]
[17:39:55.810]                         if (is.null(version)) 
[17:39:55.810]                           version <- utils::packageVersion("future")
[17:39:55.810]                       }
[17:39:55.810]                       else {
[17:39:55.810]                         version <- NULL
[17:39:55.810]                       }
[17:39:55.810]                       if (!has_future || version < "1.8.0") {
[17:39:55.810]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.810]                           "", base::R.version$version.string), 
[17:39:55.810]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.810]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.810]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.810]                             "release", "version")], collapse = " "), 
[17:39:55.810]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.810]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.810]                           info)
[17:39:55.810]                         info <- base::paste(info, collapse = "; ")
[17:39:55.810]                         if (!has_future) {
[17:39:55.810]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.810]                             info)
[17:39:55.810]                         }
[17:39:55.810]                         else {
[17:39:55.810]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.810]                             info, version)
[17:39:55.810]                         }
[17:39:55.810]                         base::stop(msg)
[17:39:55.810]                       }
[17:39:55.810]                     })
[17:39:55.810]                   }
[17:39:55.810]                   ...future.strategy.old <- future::plan("list")
[17:39:55.810]                   options(future.plan = NULL)
[17:39:55.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.810]                 }
[17:39:55.810]                 ...future.workdir <- getwd()
[17:39:55.810]             }
[17:39:55.810]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.810]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.810]         }
[17:39:55.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.810]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.810]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.810]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.810]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.810]             base::names(...future.oldOptions))
[17:39:55.810]     }
[17:39:55.810]     if (FALSE) {
[17:39:55.810]     }
[17:39:55.810]     else {
[17:39:55.810]         if (TRUE) {
[17:39:55.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.810]                 open = "w")
[17:39:55.810]         }
[17:39:55.810]         else {
[17:39:55.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.810]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.810]         }
[17:39:55.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.810]             base::sink(type = "output", split = FALSE)
[17:39:55.810]             base::close(...future.stdout)
[17:39:55.810]         }, add = TRUE)
[17:39:55.810]     }
[17:39:55.810]     ...future.frame <- base::sys.nframe()
[17:39:55.810]     ...future.conditions <- base::list()
[17:39:55.810]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.810]     if (FALSE) {
[17:39:55.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.810]     }
[17:39:55.810]     ...future.result <- base::tryCatch({
[17:39:55.810]         base::withCallingHandlers({
[17:39:55.810]             ...future.value <- base::withVisible(base::local({
[17:39:55.810]                 b <- a * ii
[17:39:55.810]                 a <- 0
[17:39:55.810]                 b
[17:39:55.810]             }))
[17:39:55.810]             future::FutureResult(value = ...future.value$value, 
[17:39:55.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.810]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.810]                     ...future.globalenv.names))
[17:39:55.810]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.810]         }, condition = base::local({
[17:39:55.810]             c <- base::c
[17:39:55.810]             inherits <- base::inherits
[17:39:55.810]             invokeRestart <- base::invokeRestart
[17:39:55.810]             length <- base::length
[17:39:55.810]             list <- base::list
[17:39:55.810]             seq.int <- base::seq.int
[17:39:55.810]             signalCondition <- base::signalCondition
[17:39:55.810]             sys.calls <- base::sys.calls
[17:39:55.810]             `[[` <- base::`[[`
[17:39:55.810]             `+` <- base::`+`
[17:39:55.810]             `<<-` <- base::`<<-`
[17:39:55.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.810]                   3L)]
[17:39:55.810]             }
[17:39:55.810]             function(cond) {
[17:39:55.810]                 is_error <- inherits(cond, "error")
[17:39:55.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.810]                   NULL)
[17:39:55.810]                 if (is_error) {
[17:39:55.810]                   sessionInformation <- function() {
[17:39:55.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.810]                       search = base::search(), system = base::Sys.info())
[17:39:55.810]                   }
[17:39:55.810]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.810]                     cond$call), session = sessionInformation(), 
[17:39:55.810]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.810]                   signalCondition(cond)
[17:39:55.810]                 }
[17:39:55.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.810]                 "immediateCondition"))) {
[17:39:55.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.810]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.810]                   if (TRUE && !signal) {
[17:39:55.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.810]                     {
[17:39:55.810]                       inherits <- base::inherits
[17:39:55.810]                       invokeRestart <- base::invokeRestart
[17:39:55.810]                       is.null <- base::is.null
[17:39:55.810]                       muffled <- FALSE
[17:39:55.810]                       if (inherits(cond, "message")) {
[17:39:55.810]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.810]                         if (muffled) 
[17:39:55.810]                           invokeRestart("muffleMessage")
[17:39:55.810]                       }
[17:39:55.810]                       else if (inherits(cond, "warning")) {
[17:39:55.810]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.810]                         if (muffled) 
[17:39:55.810]                           invokeRestart("muffleWarning")
[17:39:55.810]                       }
[17:39:55.810]                       else if (inherits(cond, "condition")) {
[17:39:55.810]                         if (!is.null(pattern)) {
[17:39:55.810]                           computeRestarts <- base::computeRestarts
[17:39:55.810]                           grepl <- base::grepl
[17:39:55.810]                           restarts <- computeRestarts(cond)
[17:39:55.810]                           for (restart in restarts) {
[17:39:55.810]                             name <- restart$name
[17:39:55.810]                             if (is.null(name)) 
[17:39:55.810]                               next
[17:39:55.810]                             if (!grepl(pattern, name)) 
[17:39:55.810]                               next
[17:39:55.810]                             invokeRestart(restart)
[17:39:55.810]                             muffled <- TRUE
[17:39:55.810]                             break
[17:39:55.810]                           }
[17:39:55.810]                         }
[17:39:55.810]                       }
[17:39:55.810]                       invisible(muffled)
[17:39:55.810]                     }
[17:39:55.810]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.810]                   }
[17:39:55.810]                 }
[17:39:55.810]                 else {
[17:39:55.810]                   if (TRUE) {
[17:39:55.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.810]                     {
[17:39:55.810]                       inherits <- base::inherits
[17:39:55.810]                       invokeRestart <- base::invokeRestart
[17:39:55.810]                       is.null <- base::is.null
[17:39:55.810]                       muffled <- FALSE
[17:39:55.810]                       if (inherits(cond, "message")) {
[17:39:55.810]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.810]                         if (muffled) 
[17:39:55.810]                           invokeRestart("muffleMessage")
[17:39:55.810]                       }
[17:39:55.810]                       else if (inherits(cond, "warning")) {
[17:39:55.810]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.810]                         if (muffled) 
[17:39:55.810]                           invokeRestart("muffleWarning")
[17:39:55.810]                       }
[17:39:55.810]                       else if (inherits(cond, "condition")) {
[17:39:55.810]                         if (!is.null(pattern)) {
[17:39:55.810]                           computeRestarts <- base::computeRestarts
[17:39:55.810]                           grepl <- base::grepl
[17:39:55.810]                           restarts <- computeRestarts(cond)
[17:39:55.810]                           for (restart in restarts) {
[17:39:55.810]                             name <- restart$name
[17:39:55.810]                             if (is.null(name)) 
[17:39:55.810]                               next
[17:39:55.810]                             if (!grepl(pattern, name)) 
[17:39:55.810]                               next
[17:39:55.810]                             invokeRestart(restart)
[17:39:55.810]                             muffled <- TRUE
[17:39:55.810]                             break
[17:39:55.810]                           }
[17:39:55.810]                         }
[17:39:55.810]                       }
[17:39:55.810]                       invisible(muffled)
[17:39:55.810]                     }
[17:39:55.810]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.810]                   }
[17:39:55.810]                 }
[17:39:55.810]             }
[17:39:55.810]         }))
[17:39:55.810]     }, error = function(ex) {
[17:39:55.810]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.810]                 ...future.rng), started = ...future.startTime, 
[17:39:55.810]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.810]             version = "1.8"), class = "FutureResult")
[17:39:55.810]     }, finally = {
[17:39:55.810]         if (!identical(...future.workdir, getwd())) 
[17:39:55.810]             setwd(...future.workdir)
[17:39:55.810]         {
[17:39:55.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.810]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.810]             }
[17:39:55.810]             base::options(...future.oldOptions)
[17:39:55.810]             if (.Platform$OS.type == "windows") {
[17:39:55.810]                 old_names <- names(...future.oldEnvVars)
[17:39:55.810]                 envs <- base::Sys.getenv()
[17:39:55.810]                 names <- names(envs)
[17:39:55.810]                 common <- intersect(names, old_names)
[17:39:55.810]                 added <- setdiff(names, old_names)
[17:39:55.810]                 removed <- setdiff(old_names, names)
[17:39:55.810]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.810]                   envs[common]]
[17:39:55.810]                 NAMES <- toupper(changed)
[17:39:55.810]                 args <- list()
[17:39:55.810]                 for (kk in seq_along(NAMES)) {
[17:39:55.810]                   name <- changed[[kk]]
[17:39:55.810]                   NAME <- NAMES[[kk]]
[17:39:55.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.810]                     next
[17:39:55.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.810]                 }
[17:39:55.810]                 NAMES <- toupper(added)
[17:39:55.810]                 for (kk in seq_along(NAMES)) {
[17:39:55.810]                   name <- added[[kk]]
[17:39:55.810]                   NAME <- NAMES[[kk]]
[17:39:55.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.810]                     next
[17:39:55.810]                   args[[name]] <- ""
[17:39:55.810]                 }
[17:39:55.810]                 NAMES <- toupper(removed)
[17:39:55.810]                 for (kk in seq_along(NAMES)) {
[17:39:55.810]                   name <- removed[[kk]]
[17:39:55.810]                   NAME <- NAMES[[kk]]
[17:39:55.810]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.810]                     next
[17:39:55.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.810]                 }
[17:39:55.810]                 if (length(args) > 0) 
[17:39:55.810]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.810]             }
[17:39:55.810]             else {
[17:39:55.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.810]             }
[17:39:55.810]             {
[17:39:55.810]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.810]                   0L) {
[17:39:55.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.810]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.810]                   base::options(opts)
[17:39:55.810]                 }
[17:39:55.810]                 {
[17:39:55.810]                   {
[17:39:55.810]                     NULL
[17:39:55.810]                     RNGkind("Mersenne-Twister")
[17:39:55.810]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.810]                       inherits = FALSE)
[17:39:55.810]                   }
[17:39:55.810]                   options(future.plan = NULL)
[17:39:55.810]                   if (is.na(NA_character_)) 
[17:39:55.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.810]                     .init = FALSE)
[17:39:55.810]                 }
[17:39:55.810]             }
[17:39:55.810]         }
[17:39:55.810]     })
[17:39:55.810]     if (TRUE) {
[17:39:55.810]         base::sink(type = "output", split = FALSE)
[17:39:55.810]         if (TRUE) {
[17:39:55.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.810]         }
[17:39:55.810]         else {
[17:39:55.810]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.810]         }
[17:39:55.810]         base::close(...future.stdout)
[17:39:55.810]         ...future.stdout <- NULL
[17:39:55.810]     }
[17:39:55.810]     ...future.result$conditions <- ...future.conditions
[17:39:55.810]     ...future.result$finished <- base::Sys.time()
[17:39:55.810]     ...future.result
[17:39:55.810] }
[17:39:55.812] assign_globals() ...
[17:39:55.812] List of 2
[17:39:55.812]  $ a : num 1
[17:39:55.812]  $ ii: int 2
[17:39:55.812]  - attr(*, "where")=List of 2
[17:39:55.812]   ..$ a :<environment: R_EmptyEnv> 
[17:39:55.812]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.812]  - attr(*, "resolved")= logi TRUE
[17:39:55.812]  - attr(*, "total_size")= num 112
[17:39:55.812]  - attr(*, "already-done")= logi TRUE
[17:39:55.815] - copied ‘a’ to environment
[17:39:55.815] - copied ‘ii’ to environment
[17:39:55.815] assign_globals() ... done
[17:39:55.815] plan(): Setting new future strategy stack:
[17:39:55.815] List of future strategies:
[17:39:55.815] 1. sequential:
[17:39:55.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.815]    - tweaked: FALSE
[17:39:55.815]    - call: NULL
[17:39:55.817] plan(): nbrOfWorkers() = 1
[17:39:55.817] plan(): Setting new future strategy stack:
[17:39:55.818] List of future strategies:
[17:39:55.818] 1. sequential:
[17:39:55.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.818]    - tweaked: FALSE
[17:39:55.818]    - call: plan(strategy)
[17:39:55.818] plan(): nbrOfWorkers() = 1
[17:39:55.818] SequentialFuture started (and completed)
[17:39:55.818] - Launch lazy future ... done
[17:39:55.818] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.819] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.819] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.821] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.821] Searching for globals ... DONE
[17:39:55.821] Resolving globals: TRUE
[17:39:55.821] Resolving any globals that are futures ...
[17:39:55.821] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.821] Resolving any globals that are futures ... DONE
[17:39:55.821] Resolving futures part of globals (recursively) ...
[17:39:55.822] resolve() on list ...
[17:39:55.822]  recursive: 99
[17:39:55.822]  length: 2
[17:39:55.822]  elements: ‘a’, ‘ii’
[17:39:55.822]  length: 1 (resolved future 1)
[17:39:55.822]  length: 0 (resolved future 2)
[17:39:55.822] resolve() on list ... DONE
[17:39:55.822] - globals: [2] ‘a’, ‘ii’
[17:39:55.822] Resolving futures part of globals (recursively) ... DONE
[17:39:55.822] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:55.823] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.823] - globals: [2] ‘a’, ‘ii’
[17:39:55.823] 
[17:39:55.823] getGlobalsAndPackages() ... DONE
[17:39:55.823] run() for ‘Future’ ...
[17:39:55.823] - state: ‘created’
[17:39:55.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.824] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.824]   - Field: ‘label’
[17:39:55.824]   - Field: ‘local’
[17:39:55.824]   - Field: ‘owner’
[17:39:55.824]   - Field: ‘envir’
[17:39:55.824]   - Field: ‘packages’
[17:39:55.824]   - Field: ‘gc’
[17:39:55.824]   - Field: ‘conditions’
[17:39:55.825]   - Field: ‘expr’
[17:39:55.825]   - Field: ‘uuid’
[17:39:55.825]   - Field: ‘seed’
[17:39:55.825]   - Field: ‘version’
[17:39:55.825]   - Field: ‘result’
[17:39:55.825]   - Field: ‘asynchronous’
[17:39:55.825]   - Field: ‘calls’
[17:39:55.825]   - Field: ‘globals’
[17:39:55.825]   - Field: ‘stdout’
[17:39:55.825]   - Field: ‘earlySignal’
[17:39:55.825]   - Field: ‘lazy’
[17:39:55.826]   - Field: ‘state’
[17:39:55.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.826] - Launch lazy future ...
[17:39:55.826] Packages needed by the future expression (n = 0): <none>
[17:39:55.826] Packages needed by future strategies (n = 0): <none>
[17:39:55.826] {
[17:39:55.826]     {
[17:39:55.826]         {
[17:39:55.826]             ...future.startTime <- base::Sys.time()
[17:39:55.826]             {
[17:39:55.826]                 {
[17:39:55.826]                   {
[17:39:55.826]                     base::local({
[17:39:55.826]                       has_future <- base::requireNamespace("future", 
[17:39:55.826]                         quietly = TRUE)
[17:39:55.826]                       if (has_future) {
[17:39:55.826]                         ns <- base::getNamespace("future")
[17:39:55.826]                         version <- ns[[".package"]][["version"]]
[17:39:55.826]                         if (is.null(version)) 
[17:39:55.826]                           version <- utils::packageVersion("future")
[17:39:55.826]                       }
[17:39:55.826]                       else {
[17:39:55.826]                         version <- NULL
[17:39:55.826]                       }
[17:39:55.826]                       if (!has_future || version < "1.8.0") {
[17:39:55.826]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.826]                           "", base::R.version$version.string), 
[17:39:55.826]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.826]                             "release", "version")], collapse = " "), 
[17:39:55.826]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.826]                           info)
[17:39:55.826]                         info <- base::paste(info, collapse = "; ")
[17:39:55.826]                         if (!has_future) {
[17:39:55.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.826]                             info)
[17:39:55.826]                         }
[17:39:55.826]                         else {
[17:39:55.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.826]                             info, version)
[17:39:55.826]                         }
[17:39:55.826]                         base::stop(msg)
[17:39:55.826]                       }
[17:39:55.826]                     })
[17:39:55.826]                   }
[17:39:55.826]                   ...future.strategy.old <- future::plan("list")
[17:39:55.826]                   options(future.plan = NULL)
[17:39:55.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.826]                 }
[17:39:55.826]                 ...future.workdir <- getwd()
[17:39:55.826]             }
[17:39:55.826]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.826]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.826]         }
[17:39:55.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.826]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.826]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.826]             base::names(...future.oldOptions))
[17:39:55.826]     }
[17:39:55.826]     if (FALSE) {
[17:39:55.826]     }
[17:39:55.826]     else {
[17:39:55.826]         if (TRUE) {
[17:39:55.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.826]                 open = "w")
[17:39:55.826]         }
[17:39:55.826]         else {
[17:39:55.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.826]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.826]         }
[17:39:55.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.826]             base::sink(type = "output", split = FALSE)
[17:39:55.826]             base::close(...future.stdout)
[17:39:55.826]         }, add = TRUE)
[17:39:55.826]     }
[17:39:55.826]     ...future.frame <- base::sys.nframe()
[17:39:55.826]     ...future.conditions <- base::list()
[17:39:55.826]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.826]     if (FALSE) {
[17:39:55.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.826]     }
[17:39:55.826]     ...future.result <- base::tryCatch({
[17:39:55.826]         base::withCallingHandlers({
[17:39:55.826]             ...future.value <- base::withVisible(base::local({
[17:39:55.826]                 b <- a * ii
[17:39:55.826]                 a <- 0
[17:39:55.826]                 b
[17:39:55.826]             }))
[17:39:55.826]             future::FutureResult(value = ...future.value$value, 
[17:39:55.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.826]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.826]                     ...future.globalenv.names))
[17:39:55.826]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.826]         }, condition = base::local({
[17:39:55.826]             c <- base::c
[17:39:55.826]             inherits <- base::inherits
[17:39:55.826]             invokeRestart <- base::invokeRestart
[17:39:55.826]             length <- base::length
[17:39:55.826]             list <- base::list
[17:39:55.826]             seq.int <- base::seq.int
[17:39:55.826]             signalCondition <- base::signalCondition
[17:39:55.826]             sys.calls <- base::sys.calls
[17:39:55.826]             `[[` <- base::`[[`
[17:39:55.826]             `+` <- base::`+`
[17:39:55.826]             `<<-` <- base::`<<-`
[17:39:55.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.826]                   3L)]
[17:39:55.826]             }
[17:39:55.826]             function(cond) {
[17:39:55.826]                 is_error <- inherits(cond, "error")
[17:39:55.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.826]                   NULL)
[17:39:55.826]                 if (is_error) {
[17:39:55.826]                   sessionInformation <- function() {
[17:39:55.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.826]                       search = base::search(), system = base::Sys.info())
[17:39:55.826]                   }
[17:39:55.826]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.826]                     cond$call), session = sessionInformation(), 
[17:39:55.826]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.826]                   signalCondition(cond)
[17:39:55.826]                 }
[17:39:55.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.826]                 "immediateCondition"))) {
[17:39:55.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.826]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.826]                   if (TRUE && !signal) {
[17:39:55.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.826]                     {
[17:39:55.826]                       inherits <- base::inherits
[17:39:55.826]                       invokeRestart <- base::invokeRestart
[17:39:55.826]                       is.null <- base::is.null
[17:39:55.826]                       muffled <- FALSE
[17:39:55.826]                       if (inherits(cond, "message")) {
[17:39:55.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.826]                         if (muffled) 
[17:39:55.826]                           invokeRestart("muffleMessage")
[17:39:55.826]                       }
[17:39:55.826]                       else if (inherits(cond, "warning")) {
[17:39:55.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.826]                         if (muffled) 
[17:39:55.826]                           invokeRestart("muffleWarning")
[17:39:55.826]                       }
[17:39:55.826]                       else if (inherits(cond, "condition")) {
[17:39:55.826]                         if (!is.null(pattern)) {
[17:39:55.826]                           computeRestarts <- base::computeRestarts
[17:39:55.826]                           grepl <- base::grepl
[17:39:55.826]                           restarts <- computeRestarts(cond)
[17:39:55.826]                           for (restart in restarts) {
[17:39:55.826]                             name <- restart$name
[17:39:55.826]                             if (is.null(name)) 
[17:39:55.826]                               next
[17:39:55.826]                             if (!grepl(pattern, name)) 
[17:39:55.826]                               next
[17:39:55.826]                             invokeRestart(restart)
[17:39:55.826]                             muffled <- TRUE
[17:39:55.826]                             break
[17:39:55.826]                           }
[17:39:55.826]                         }
[17:39:55.826]                       }
[17:39:55.826]                       invisible(muffled)
[17:39:55.826]                     }
[17:39:55.826]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.826]                   }
[17:39:55.826]                 }
[17:39:55.826]                 else {
[17:39:55.826]                   if (TRUE) {
[17:39:55.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.826]                     {
[17:39:55.826]                       inherits <- base::inherits
[17:39:55.826]                       invokeRestart <- base::invokeRestart
[17:39:55.826]                       is.null <- base::is.null
[17:39:55.826]                       muffled <- FALSE
[17:39:55.826]                       if (inherits(cond, "message")) {
[17:39:55.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.826]                         if (muffled) 
[17:39:55.826]                           invokeRestart("muffleMessage")
[17:39:55.826]                       }
[17:39:55.826]                       else if (inherits(cond, "warning")) {
[17:39:55.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.826]                         if (muffled) 
[17:39:55.826]                           invokeRestart("muffleWarning")
[17:39:55.826]                       }
[17:39:55.826]                       else if (inherits(cond, "condition")) {
[17:39:55.826]                         if (!is.null(pattern)) {
[17:39:55.826]                           computeRestarts <- base::computeRestarts
[17:39:55.826]                           grepl <- base::grepl
[17:39:55.826]                           restarts <- computeRestarts(cond)
[17:39:55.826]                           for (restart in restarts) {
[17:39:55.826]                             name <- restart$name
[17:39:55.826]                             if (is.null(name)) 
[17:39:55.826]                               next
[17:39:55.826]                             if (!grepl(pattern, name)) 
[17:39:55.826]                               next
[17:39:55.826]                             invokeRestart(restart)
[17:39:55.826]                             muffled <- TRUE
[17:39:55.826]                             break
[17:39:55.826]                           }
[17:39:55.826]                         }
[17:39:55.826]                       }
[17:39:55.826]                       invisible(muffled)
[17:39:55.826]                     }
[17:39:55.826]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.826]                   }
[17:39:55.826]                 }
[17:39:55.826]             }
[17:39:55.826]         }))
[17:39:55.826]     }, error = function(ex) {
[17:39:55.826]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.826]                 ...future.rng), started = ...future.startTime, 
[17:39:55.826]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.826]             version = "1.8"), class = "FutureResult")
[17:39:55.826]     }, finally = {
[17:39:55.826]         if (!identical(...future.workdir, getwd())) 
[17:39:55.826]             setwd(...future.workdir)
[17:39:55.826]         {
[17:39:55.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.826]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.826]             }
[17:39:55.826]             base::options(...future.oldOptions)
[17:39:55.826]             if (.Platform$OS.type == "windows") {
[17:39:55.826]                 old_names <- names(...future.oldEnvVars)
[17:39:55.826]                 envs <- base::Sys.getenv()
[17:39:55.826]                 names <- names(envs)
[17:39:55.826]                 common <- intersect(names, old_names)
[17:39:55.826]                 added <- setdiff(names, old_names)
[17:39:55.826]                 removed <- setdiff(old_names, names)
[17:39:55.826]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.826]                   envs[common]]
[17:39:55.826]                 NAMES <- toupper(changed)
[17:39:55.826]                 args <- list()
[17:39:55.826]                 for (kk in seq_along(NAMES)) {
[17:39:55.826]                   name <- changed[[kk]]
[17:39:55.826]                   NAME <- NAMES[[kk]]
[17:39:55.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.826]                     next
[17:39:55.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.826]                 }
[17:39:55.826]                 NAMES <- toupper(added)
[17:39:55.826]                 for (kk in seq_along(NAMES)) {
[17:39:55.826]                   name <- added[[kk]]
[17:39:55.826]                   NAME <- NAMES[[kk]]
[17:39:55.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.826]                     next
[17:39:55.826]                   args[[name]] <- ""
[17:39:55.826]                 }
[17:39:55.826]                 NAMES <- toupper(removed)
[17:39:55.826]                 for (kk in seq_along(NAMES)) {
[17:39:55.826]                   name <- removed[[kk]]
[17:39:55.826]                   NAME <- NAMES[[kk]]
[17:39:55.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.826]                     next
[17:39:55.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.826]                 }
[17:39:55.826]                 if (length(args) > 0) 
[17:39:55.826]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.826]             }
[17:39:55.826]             else {
[17:39:55.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.826]             }
[17:39:55.826]             {
[17:39:55.826]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.826]                   0L) {
[17:39:55.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.826]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.826]                   base::options(opts)
[17:39:55.826]                 }
[17:39:55.826]                 {
[17:39:55.826]                   {
[17:39:55.826]                     NULL
[17:39:55.826]                     RNGkind("Mersenne-Twister")
[17:39:55.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.826]                       inherits = FALSE)
[17:39:55.826]                   }
[17:39:55.826]                   options(future.plan = NULL)
[17:39:55.826]                   if (is.na(NA_character_)) 
[17:39:55.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.826]                     .init = FALSE)
[17:39:55.826]                 }
[17:39:55.826]             }
[17:39:55.826]         }
[17:39:55.826]     })
[17:39:55.826]     if (TRUE) {
[17:39:55.826]         base::sink(type = "output", split = FALSE)
[17:39:55.826]         if (TRUE) {
[17:39:55.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.826]         }
[17:39:55.826]         else {
[17:39:55.826]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.826]         }
[17:39:55.826]         base::close(...future.stdout)
[17:39:55.826]         ...future.stdout <- NULL
[17:39:55.826]     }
[17:39:55.826]     ...future.result$conditions <- ...future.conditions
[17:39:55.826]     ...future.result$finished <- base::Sys.time()
[17:39:55.826]     ...future.result
[17:39:55.826] }
[17:39:55.828] assign_globals() ...
[17:39:55.828] List of 2
[17:39:55.828]  $ a : num 1
[17:39:55.828]  $ ii: int 3
[17:39:55.828]  - attr(*, "where")=List of 2
[17:39:55.828]   ..$ a :<environment: R_EmptyEnv> 
[17:39:55.828]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.828]  - attr(*, "resolved")= logi TRUE
[17:39:55.828]  - attr(*, "total_size")= num 112
[17:39:55.828]  - attr(*, "already-done")= logi TRUE
[17:39:55.831] - copied ‘a’ to environment
[17:39:55.831] - copied ‘ii’ to environment
[17:39:55.831] assign_globals() ... done
[17:39:55.831] plan(): Setting new future strategy stack:
[17:39:55.831] List of future strategies:
[17:39:55.831] 1. sequential:
[17:39:55.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.831]    - tweaked: FALSE
[17:39:55.831]    - call: NULL
[17:39:55.831] plan(): nbrOfWorkers() = 1
[17:39:55.832] plan(): Setting new future strategy stack:
[17:39:55.832] List of future strategies:
[17:39:55.832] 1. sequential:
[17:39:55.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.832]    - tweaked: FALSE
[17:39:55.832]    - call: plan(strategy)
[17:39:55.833] plan(): nbrOfWorkers() = 1
[17:39:55.833] SequentialFuture started (and completed)
[17:39:55.833] - Launch lazy future ... done
[17:39:55.833] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.834] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.834] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.836] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.836] Searching for globals ... DONE
[17:39:55.836] Resolving globals: TRUE
[17:39:55.836] Resolving any globals that are futures ...
[17:39:55.836] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.836] Resolving any globals that are futures ... DONE
[17:39:55.836] Resolving futures part of globals (recursively) ...
[17:39:55.837] resolve() on list ...
[17:39:55.837]  recursive: 99
[17:39:55.837]  length: 2
[17:39:55.837]  elements: ‘a’, ‘ii’
[17:39:55.837]  length: 1 (resolved future 1)
[17:39:55.837]  length: 0 (resolved future 2)
[17:39:55.837] resolve() on list ... DONE
[17:39:55.837] - globals: [2] ‘a’, ‘ii’
[17:39:55.837] Resolving futures part of globals (recursively) ... DONE
[17:39:55.838] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:55.838] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.838] - globals: [2] ‘a’, ‘ii’
[17:39:55.838] 
[17:39:55.838] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.839] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.839] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.842] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.842] Searching for globals ... DONE
[17:39:55.842] Resolving globals: TRUE
[17:39:55.842] Resolving any globals that are futures ...
[17:39:55.842] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.842] Resolving any globals that are futures ... DONE
[17:39:55.843] Resolving futures part of globals (recursively) ...
[17:39:55.843] resolve() on list ...
[17:39:55.843]  recursive: 99
[17:39:55.843]  length: 2
[17:39:55.843]  elements: ‘a’, ‘ii’
[17:39:55.843]  length: 1 (resolved future 1)
[17:39:55.843]  length: 0 (resolved future 2)
[17:39:55.843] resolve() on list ... DONE
[17:39:55.843] - globals: [2] ‘a’, ‘ii’
[17:39:55.843] Resolving futures part of globals (recursively) ... DONE
[17:39:55.844] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:55.844] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.844] - globals: [2] ‘a’, ‘ii’
[17:39:55.844] 
[17:39:55.844] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.845] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.845] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.847] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.847] Searching for globals ... DONE
[17:39:55.847] Resolving globals: TRUE
[17:39:55.847] Resolving any globals that are futures ...
[17:39:55.847] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:55.847] Resolving any globals that are futures ... DONE
[17:39:55.847] Resolving futures part of globals (recursively) ...
[17:39:55.848] resolve() on list ...
[17:39:55.848]  recursive: 99
[17:39:55.848]  length: 2
[17:39:55.848]  elements: ‘a’, ‘ii’
[17:39:55.848]  length: 1 (resolved future 1)
[17:39:55.848]  length: 0 (resolved future 2)
[17:39:55.848] resolve() on list ... DONE
[17:39:55.848] - globals: [2] ‘a’, ‘ii’
[17:39:55.848] Resolving futures part of globals (recursively) ... DONE
[17:39:55.849] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:55.849] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:55.849] - globals: [2] ‘a’, ‘ii’
[17:39:55.849] 
[17:39:55.849] getGlobalsAndPackages() ... DONE
[17:39:55.849] run() for ‘Future’ ...
[17:39:55.850] - state: ‘created’
[17:39:55.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.850]   - Field: ‘label’
[17:39:55.850]   - Field: ‘local’
[17:39:55.850]   - Field: ‘owner’
[17:39:55.850]   - Field: ‘envir’
[17:39:55.850]   - Field: ‘packages’
[17:39:55.851]   - Field: ‘gc’
[17:39:55.851]   - Field: ‘conditions’
[17:39:55.851]   - Field: ‘expr’
[17:39:55.851]   - Field: ‘uuid’
[17:39:55.851]   - Field: ‘seed’
[17:39:55.851]   - Field: ‘version’
[17:39:55.851]   - Field: ‘result’
[17:39:55.851]   - Field: ‘asynchronous’
[17:39:55.851]   - Field: ‘calls’
[17:39:55.851]   - Field: ‘globals’
[17:39:55.851]   - Field: ‘stdout’
[17:39:55.851]   - Field: ‘earlySignal’
[17:39:55.852]   - Field: ‘lazy’
[17:39:55.852]   - Field: ‘state’
[17:39:55.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.852] - Launch lazy future ...
[17:39:55.852] Packages needed by the future expression (n = 0): <none>
[17:39:55.852] Packages needed by future strategies (n = 0): <none>
[17:39:55.852] {
[17:39:55.852]     {
[17:39:55.852]         {
[17:39:55.852]             ...future.startTime <- base::Sys.time()
[17:39:55.852]             {
[17:39:55.852]                 {
[17:39:55.852]                   {
[17:39:55.852]                     base::local({
[17:39:55.852]                       has_future <- base::requireNamespace("future", 
[17:39:55.852]                         quietly = TRUE)
[17:39:55.852]                       if (has_future) {
[17:39:55.852]                         ns <- base::getNamespace("future")
[17:39:55.852]                         version <- ns[[".package"]][["version"]]
[17:39:55.852]                         if (is.null(version)) 
[17:39:55.852]                           version <- utils::packageVersion("future")
[17:39:55.852]                       }
[17:39:55.852]                       else {
[17:39:55.852]                         version <- NULL
[17:39:55.852]                       }
[17:39:55.852]                       if (!has_future || version < "1.8.0") {
[17:39:55.852]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.852]                           "", base::R.version$version.string), 
[17:39:55.852]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.852]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.852]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.852]                             "release", "version")], collapse = " "), 
[17:39:55.852]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.852]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.852]                           info)
[17:39:55.852]                         info <- base::paste(info, collapse = "; ")
[17:39:55.852]                         if (!has_future) {
[17:39:55.852]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.852]                             info)
[17:39:55.852]                         }
[17:39:55.852]                         else {
[17:39:55.852]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.852]                             info, version)
[17:39:55.852]                         }
[17:39:55.852]                         base::stop(msg)
[17:39:55.852]                       }
[17:39:55.852]                     })
[17:39:55.852]                   }
[17:39:55.852]                   ...future.strategy.old <- future::plan("list")
[17:39:55.852]                   options(future.plan = NULL)
[17:39:55.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.852]                 }
[17:39:55.852]                 ...future.workdir <- getwd()
[17:39:55.852]             }
[17:39:55.852]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.852]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.852]         }
[17:39:55.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.852]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.852]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.852]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.852]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.852]             base::names(...future.oldOptions))
[17:39:55.852]     }
[17:39:55.852]     if (FALSE) {
[17:39:55.852]     }
[17:39:55.852]     else {
[17:39:55.852]         if (TRUE) {
[17:39:55.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.852]                 open = "w")
[17:39:55.852]         }
[17:39:55.852]         else {
[17:39:55.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.852]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.852]         }
[17:39:55.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.852]             base::sink(type = "output", split = FALSE)
[17:39:55.852]             base::close(...future.stdout)
[17:39:55.852]         }, add = TRUE)
[17:39:55.852]     }
[17:39:55.852]     ...future.frame <- base::sys.nframe()
[17:39:55.852]     ...future.conditions <- base::list()
[17:39:55.852]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.852]     if (FALSE) {
[17:39:55.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.852]     }
[17:39:55.852]     ...future.result <- base::tryCatch({
[17:39:55.852]         base::withCallingHandlers({
[17:39:55.852]             ...future.value <- base::withVisible(base::local({
[17:39:55.852]                 b <- a * ii
[17:39:55.852]                 a <- 0
[17:39:55.852]                 b
[17:39:55.852]             }))
[17:39:55.852]             future::FutureResult(value = ...future.value$value, 
[17:39:55.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.852]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.852]                     ...future.globalenv.names))
[17:39:55.852]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.852]         }, condition = base::local({
[17:39:55.852]             c <- base::c
[17:39:55.852]             inherits <- base::inherits
[17:39:55.852]             invokeRestart <- base::invokeRestart
[17:39:55.852]             length <- base::length
[17:39:55.852]             list <- base::list
[17:39:55.852]             seq.int <- base::seq.int
[17:39:55.852]             signalCondition <- base::signalCondition
[17:39:55.852]             sys.calls <- base::sys.calls
[17:39:55.852]             `[[` <- base::`[[`
[17:39:55.852]             `+` <- base::`+`
[17:39:55.852]             `<<-` <- base::`<<-`
[17:39:55.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.852]                   3L)]
[17:39:55.852]             }
[17:39:55.852]             function(cond) {
[17:39:55.852]                 is_error <- inherits(cond, "error")
[17:39:55.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.852]                   NULL)
[17:39:55.852]                 if (is_error) {
[17:39:55.852]                   sessionInformation <- function() {
[17:39:55.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.852]                       search = base::search(), system = base::Sys.info())
[17:39:55.852]                   }
[17:39:55.852]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.852]                     cond$call), session = sessionInformation(), 
[17:39:55.852]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.852]                   signalCondition(cond)
[17:39:55.852]                 }
[17:39:55.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.852]                 "immediateCondition"))) {
[17:39:55.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.852]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.852]                   if (TRUE && !signal) {
[17:39:55.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.852]                     {
[17:39:55.852]                       inherits <- base::inherits
[17:39:55.852]                       invokeRestart <- base::invokeRestart
[17:39:55.852]                       is.null <- base::is.null
[17:39:55.852]                       muffled <- FALSE
[17:39:55.852]                       if (inherits(cond, "message")) {
[17:39:55.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.852]                         if (muffled) 
[17:39:55.852]                           invokeRestart("muffleMessage")
[17:39:55.852]                       }
[17:39:55.852]                       else if (inherits(cond, "warning")) {
[17:39:55.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.852]                         if (muffled) 
[17:39:55.852]                           invokeRestart("muffleWarning")
[17:39:55.852]                       }
[17:39:55.852]                       else if (inherits(cond, "condition")) {
[17:39:55.852]                         if (!is.null(pattern)) {
[17:39:55.852]                           computeRestarts <- base::computeRestarts
[17:39:55.852]                           grepl <- base::grepl
[17:39:55.852]                           restarts <- computeRestarts(cond)
[17:39:55.852]                           for (restart in restarts) {
[17:39:55.852]                             name <- restart$name
[17:39:55.852]                             if (is.null(name)) 
[17:39:55.852]                               next
[17:39:55.852]                             if (!grepl(pattern, name)) 
[17:39:55.852]                               next
[17:39:55.852]                             invokeRestart(restart)
[17:39:55.852]                             muffled <- TRUE
[17:39:55.852]                             break
[17:39:55.852]                           }
[17:39:55.852]                         }
[17:39:55.852]                       }
[17:39:55.852]                       invisible(muffled)
[17:39:55.852]                     }
[17:39:55.852]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.852]                   }
[17:39:55.852]                 }
[17:39:55.852]                 else {
[17:39:55.852]                   if (TRUE) {
[17:39:55.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.852]                     {
[17:39:55.852]                       inherits <- base::inherits
[17:39:55.852]                       invokeRestart <- base::invokeRestart
[17:39:55.852]                       is.null <- base::is.null
[17:39:55.852]                       muffled <- FALSE
[17:39:55.852]                       if (inherits(cond, "message")) {
[17:39:55.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.852]                         if (muffled) 
[17:39:55.852]                           invokeRestart("muffleMessage")
[17:39:55.852]                       }
[17:39:55.852]                       else if (inherits(cond, "warning")) {
[17:39:55.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.852]                         if (muffled) 
[17:39:55.852]                           invokeRestart("muffleWarning")
[17:39:55.852]                       }
[17:39:55.852]                       else if (inherits(cond, "condition")) {
[17:39:55.852]                         if (!is.null(pattern)) {
[17:39:55.852]                           computeRestarts <- base::computeRestarts
[17:39:55.852]                           grepl <- base::grepl
[17:39:55.852]                           restarts <- computeRestarts(cond)
[17:39:55.852]                           for (restart in restarts) {
[17:39:55.852]                             name <- restart$name
[17:39:55.852]                             if (is.null(name)) 
[17:39:55.852]                               next
[17:39:55.852]                             if (!grepl(pattern, name)) 
[17:39:55.852]                               next
[17:39:55.852]                             invokeRestart(restart)
[17:39:55.852]                             muffled <- TRUE
[17:39:55.852]                             break
[17:39:55.852]                           }
[17:39:55.852]                         }
[17:39:55.852]                       }
[17:39:55.852]                       invisible(muffled)
[17:39:55.852]                     }
[17:39:55.852]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.852]                   }
[17:39:55.852]                 }
[17:39:55.852]             }
[17:39:55.852]         }))
[17:39:55.852]     }, error = function(ex) {
[17:39:55.852]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.852]                 ...future.rng), started = ...future.startTime, 
[17:39:55.852]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.852]             version = "1.8"), class = "FutureResult")
[17:39:55.852]     }, finally = {
[17:39:55.852]         if (!identical(...future.workdir, getwd())) 
[17:39:55.852]             setwd(...future.workdir)
[17:39:55.852]         {
[17:39:55.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.852]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.852]             }
[17:39:55.852]             base::options(...future.oldOptions)
[17:39:55.852]             if (.Platform$OS.type == "windows") {
[17:39:55.852]                 old_names <- names(...future.oldEnvVars)
[17:39:55.852]                 envs <- base::Sys.getenv()
[17:39:55.852]                 names <- names(envs)
[17:39:55.852]                 common <- intersect(names, old_names)
[17:39:55.852]                 added <- setdiff(names, old_names)
[17:39:55.852]                 removed <- setdiff(old_names, names)
[17:39:55.852]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.852]                   envs[common]]
[17:39:55.852]                 NAMES <- toupper(changed)
[17:39:55.852]                 args <- list()
[17:39:55.852]                 for (kk in seq_along(NAMES)) {
[17:39:55.852]                   name <- changed[[kk]]
[17:39:55.852]                   NAME <- NAMES[[kk]]
[17:39:55.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.852]                     next
[17:39:55.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.852]                 }
[17:39:55.852]                 NAMES <- toupper(added)
[17:39:55.852]                 for (kk in seq_along(NAMES)) {
[17:39:55.852]                   name <- added[[kk]]
[17:39:55.852]                   NAME <- NAMES[[kk]]
[17:39:55.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.852]                     next
[17:39:55.852]                   args[[name]] <- ""
[17:39:55.852]                 }
[17:39:55.852]                 NAMES <- toupper(removed)
[17:39:55.852]                 for (kk in seq_along(NAMES)) {
[17:39:55.852]                   name <- removed[[kk]]
[17:39:55.852]                   NAME <- NAMES[[kk]]
[17:39:55.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.852]                     next
[17:39:55.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.852]                 }
[17:39:55.852]                 if (length(args) > 0) 
[17:39:55.852]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.852]             }
[17:39:55.852]             else {
[17:39:55.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.852]             }
[17:39:55.852]             {
[17:39:55.852]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.852]                   0L) {
[17:39:55.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.852]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.852]                   base::options(opts)
[17:39:55.852]                 }
[17:39:55.852]                 {
[17:39:55.852]                   {
[17:39:55.852]                     NULL
[17:39:55.852]                     RNGkind("Mersenne-Twister")
[17:39:55.852]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.852]                       inherits = FALSE)
[17:39:55.852]                   }
[17:39:55.852]                   options(future.plan = NULL)
[17:39:55.852]                   if (is.na(NA_character_)) 
[17:39:55.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.852]                     .init = FALSE)
[17:39:55.852]                 }
[17:39:55.852]             }
[17:39:55.852]         }
[17:39:55.852]     })
[17:39:55.852]     if (TRUE) {
[17:39:55.852]         base::sink(type = "output", split = FALSE)
[17:39:55.852]         if (TRUE) {
[17:39:55.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.852]         }
[17:39:55.852]         else {
[17:39:55.852]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.852]         }
[17:39:55.852]         base::close(...future.stdout)
[17:39:55.852]         ...future.stdout <- NULL
[17:39:55.852]     }
[17:39:55.852]     ...future.result$conditions <- ...future.conditions
[17:39:55.852]     ...future.result$finished <- base::Sys.time()
[17:39:55.852]     ...future.result
[17:39:55.852] }
[17:39:55.854] assign_globals() ...
[17:39:55.854] List of 2
[17:39:55.854]  $ a : num 1
[17:39:55.854]  $ ii: int 1
[17:39:55.854]  - attr(*, "where")=List of 2
[17:39:55.854]   ..$ a :<environment: R_EmptyEnv> 
[17:39:55.854]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.854]  - attr(*, "resolved")= logi TRUE
[17:39:55.854]  - attr(*, "total_size")= num 112
[17:39:55.854]  - attr(*, "already-done")= logi TRUE
[17:39:55.857] - copied ‘a’ to environment
[17:39:55.857] - copied ‘ii’ to environment
[17:39:55.857] assign_globals() ... done
[17:39:55.857] plan(): Setting new future strategy stack:
[17:39:55.857] List of future strategies:
[17:39:55.857] 1. sequential:
[17:39:55.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.857]    - tweaked: FALSE
[17:39:55.857]    - call: NULL
[17:39:55.858] plan(): nbrOfWorkers() = 1
[17:39:55.858] plan(): Setting new future strategy stack:
[17:39:55.858] List of future strategies:
[17:39:55.858] 1. sequential:
[17:39:55.858]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.858]    - tweaked: FALSE
[17:39:55.858]    - call: plan(strategy)
[17:39:55.859] plan(): nbrOfWorkers() = 1
[17:39:55.859] SequentialFuture started (and completed)
[17:39:55.859] - Launch lazy future ... done
[17:39:55.859] run() for ‘SequentialFuture’ ... done
[17:39:55.859] run() for ‘Future’ ...
[17:39:55.859] - state: ‘created’
[17:39:55.860] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.860]   - Field: ‘label’
[17:39:55.860]   - Field: ‘local’
[17:39:55.860]   - Field: ‘owner’
[17:39:55.860]   - Field: ‘envir’
[17:39:55.860]   - Field: ‘packages’
[17:39:55.861]   - Field: ‘gc’
[17:39:55.861]   - Field: ‘conditions’
[17:39:55.861]   - Field: ‘expr’
[17:39:55.861]   - Field: ‘uuid’
[17:39:55.861]   - Field: ‘seed’
[17:39:55.861]   - Field: ‘version’
[17:39:55.861]   - Field: ‘result’
[17:39:55.861]   - Field: ‘asynchronous’
[17:39:55.861]   - Field: ‘calls’
[17:39:55.861]   - Field: ‘globals’
[17:39:55.861]   - Field: ‘stdout’
[17:39:55.861]   - Field: ‘earlySignal’
[17:39:55.862]   - Field: ‘lazy’
[17:39:55.862]   - Field: ‘state’
[17:39:55.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.862] - Launch lazy future ...
[17:39:55.862] Packages needed by the future expression (n = 0): <none>
[17:39:55.862] Packages needed by future strategies (n = 0): <none>
[17:39:55.863] {
[17:39:55.863]     {
[17:39:55.863]         {
[17:39:55.863]             ...future.startTime <- base::Sys.time()
[17:39:55.863]             {
[17:39:55.863]                 {
[17:39:55.863]                   {
[17:39:55.863]                     base::local({
[17:39:55.863]                       has_future <- base::requireNamespace("future", 
[17:39:55.863]                         quietly = TRUE)
[17:39:55.863]                       if (has_future) {
[17:39:55.863]                         ns <- base::getNamespace("future")
[17:39:55.863]                         version <- ns[[".package"]][["version"]]
[17:39:55.863]                         if (is.null(version)) 
[17:39:55.863]                           version <- utils::packageVersion("future")
[17:39:55.863]                       }
[17:39:55.863]                       else {
[17:39:55.863]                         version <- NULL
[17:39:55.863]                       }
[17:39:55.863]                       if (!has_future || version < "1.8.0") {
[17:39:55.863]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.863]                           "", base::R.version$version.string), 
[17:39:55.863]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.863]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.863]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.863]                             "release", "version")], collapse = " "), 
[17:39:55.863]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.863]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.863]                           info)
[17:39:55.863]                         info <- base::paste(info, collapse = "; ")
[17:39:55.863]                         if (!has_future) {
[17:39:55.863]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.863]                             info)
[17:39:55.863]                         }
[17:39:55.863]                         else {
[17:39:55.863]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.863]                             info, version)
[17:39:55.863]                         }
[17:39:55.863]                         base::stop(msg)
[17:39:55.863]                       }
[17:39:55.863]                     })
[17:39:55.863]                   }
[17:39:55.863]                   ...future.strategy.old <- future::plan("list")
[17:39:55.863]                   options(future.plan = NULL)
[17:39:55.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.863]                 }
[17:39:55.863]                 ...future.workdir <- getwd()
[17:39:55.863]             }
[17:39:55.863]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.863]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.863]         }
[17:39:55.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.863]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.863]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.863]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.863]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.863]             base::names(...future.oldOptions))
[17:39:55.863]     }
[17:39:55.863]     if (FALSE) {
[17:39:55.863]     }
[17:39:55.863]     else {
[17:39:55.863]         if (TRUE) {
[17:39:55.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.863]                 open = "w")
[17:39:55.863]         }
[17:39:55.863]         else {
[17:39:55.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.863]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.863]         }
[17:39:55.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.863]             base::sink(type = "output", split = FALSE)
[17:39:55.863]             base::close(...future.stdout)
[17:39:55.863]         }, add = TRUE)
[17:39:55.863]     }
[17:39:55.863]     ...future.frame <- base::sys.nframe()
[17:39:55.863]     ...future.conditions <- base::list()
[17:39:55.863]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.863]     if (FALSE) {
[17:39:55.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.863]     }
[17:39:55.863]     ...future.result <- base::tryCatch({
[17:39:55.863]         base::withCallingHandlers({
[17:39:55.863]             ...future.value <- base::withVisible(base::local({
[17:39:55.863]                 b <- a * ii
[17:39:55.863]                 a <- 0
[17:39:55.863]                 b
[17:39:55.863]             }))
[17:39:55.863]             future::FutureResult(value = ...future.value$value, 
[17:39:55.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.863]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.863]                     ...future.globalenv.names))
[17:39:55.863]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.863]         }, condition = base::local({
[17:39:55.863]             c <- base::c
[17:39:55.863]             inherits <- base::inherits
[17:39:55.863]             invokeRestart <- base::invokeRestart
[17:39:55.863]             length <- base::length
[17:39:55.863]             list <- base::list
[17:39:55.863]             seq.int <- base::seq.int
[17:39:55.863]             signalCondition <- base::signalCondition
[17:39:55.863]             sys.calls <- base::sys.calls
[17:39:55.863]             `[[` <- base::`[[`
[17:39:55.863]             `+` <- base::`+`
[17:39:55.863]             `<<-` <- base::`<<-`
[17:39:55.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.863]                   3L)]
[17:39:55.863]             }
[17:39:55.863]             function(cond) {
[17:39:55.863]                 is_error <- inherits(cond, "error")
[17:39:55.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.863]                   NULL)
[17:39:55.863]                 if (is_error) {
[17:39:55.863]                   sessionInformation <- function() {
[17:39:55.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.863]                       search = base::search(), system = base::Sys.info())
[17:39:55.863]                   }
[17:39:55.863]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.863]                     cond$call), session = sessionInformation(), 
[17:39:55.863]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.863]                   signalCondition(cond)
[17:39:55.863]                 }
[17:39:55.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.863]                 "immediateCondition"))) {
[17:39:55.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.863]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.863]                   if (TRUE && !signal) {
[17:39:55.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.863]                     {
[17:39:55.863]                       inherits <- base::inherits
[17:39:55.863]                       invokeRestart <- base::invokeRestart
[17:39:55.863]                       is.null <- base::is.null
[17:39:55.863]                       muffled <- FALSE
[17:39:55.863]                       if (inherits(cond, "message")) {
[17:39:55.863]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.863]                         if (muffled) 
[17:39:55.863]                           invokeRestart("muffleMessage")
[17:39:55.863]                       }
[17:39:55.863]                       else if (inherits(cond, "warning")) {
[17:39:55.863]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.863]                         if (muffled) 
[17:39:55.863]                           invokeRestart("muffleWarning")
[17:39:55.863]                       }
[17:39:55.863]                       else if (inherits(cond, "condition")) {
[17:39:55.863]                         if (!is.null(pattern)) {
[17:39:55.863]                           computeRestarts <- base::computeRestarts
[17:39:55.863]                           grepl <- base::grepl
[17:39:55.863]                           restarts <- computeRestarts(cond)
[17:39:55.863]                           for (restart in restarts) {
[17:39:55.863]                             name <- restart$name
[17:39:55.863]                             if (is.null(name)) 
[17:39:55.863]                               next
[17:39:55.863]                             if (!grepl(pattern, name)) 
[17:39:55.863]                               next
[17:39:55.863]                             invokeRestart(restart)
[17:39:55.863]                             muffled <- TRUE
[17:39:55.863]                             break
[17:39:55.863]                           }
[17:39:55.863]                         }
[17:39:55.863]                       }
[17:39:55.863]                       invisible(muffled)
[17:39:55.863]                     }
[17:39:55.863]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.863]                   }
[17:39:55.863]                 }
[17:39:55.863]                 else {
[17:39:55.863]                   if (TRUE) {
[17:39:55.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.863]                     {
[17:39:55.863]                       inherits <- base::inherits
[17:39:55.863]                       invokeRestart <- base::invokeRestart
[17:39:55.863]                       is.null <- base::is.null
[17:39:55.863]                       muffled <- FALSE
[17:39:55.863]                       if (inherits(cond, "message")) {
[17:39:55.863]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.863]                         if (muffled) 
[17:39:55.863]                           invokeRestart("muffleMessage")
[17:39:55.863]                       }
[17:39:55.863]                       else if (inherits(cond, "warning")) {
[17:39:55.863]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.863]                         if (muffled) 
[17:39:55.863]                           invokeRestart("muffleWarning")
[17:39:55.863]                       }
[17:39:55.863]                       else if (inherits(cond, "condition")) {
[17:39:55.863]                         if (!is.null(pattern)) {
[17:39:55.863]                           computeRestarts <- base::computeRestarts
[17:39:55.863]                           grepl <- base::grepl
[17:39:55.863]                           restarts <- computeRestarts(cond)
[17:39:55.863]                           for (restart in restarts) {
[17:39:55.863]                             name <- restart$name
[17:39:55.863]                             if (is.null(name)) 
[17:39:55.863]                               next
[17:39:55.863]                             if (!grepl(pattern, name)) 
[17:39:55.863]                               next
[17:39:55.863]                             invokeRestart(restart)
[17:39:55.863]                             muffled <- TRUE
[17:39:55.863]                             break
[17:39:55.863]                           }
[17:39:55.863]                         }
[17:39:55.863]                       }
[17:39:55.863]                       invisible(muffled)
[17:39:55.863]                     }
[17:39:55.863]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.863]                   }
[17:39:55.863]                 }
[17:39:55.863]             }
[17:39:55.863]         }))
[17:39:55.863]     }, error = function(ex) {
[17:39:55.863]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.863]                 ...future.rng), started = ...future.startTime, 
[17:39:55.863]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.863]             version = "1.8"), class = "FutureResult")
[17:39:55.863]     }, finally = {
[17:39:55.863]         if (!identical(...future.workdir, getwd())) 
[17:39:55.863]             setwd(...future.workdir)
[17:39:55.863]         {
[17:39:55.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.863]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.863]             }
[17:39:55.863]             base::options(...future.oldOptions)
[17:39:55.863]             if (.Platform$OS.type == "windows") {
[17:39:55.863]                 old_names <- names(...future.oldEnvVars)
[17:39:55.863]                 envs <- base::Sys.getenv()
[17:39:55.863]                 names <- names(envs)
[17:39:55.863]                 common <- intersect(names, old_names)
[17:39:55.863]                 added <- setdiff(names, old_names)
[17:39:55.863]                 removed <- setdiff(old_names, names)
[17:39:55.863]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.863]                   envs[common]]
[17:39:55.863]                 NAMES <- toupper(changed)
[17:39:55.863]                 args <- list()
[17:39:55.863]                 for (kk in seq_along(NAMES)) {
[17:39:55.863]                   name <- changed[[kk]]
[17:39:55.863]                   NAME <- NAMES[[kk]]
[17:39:55.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.863]                     next
[17:39:55.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.863]                 }
[17:39:55.863]                 NAMES <- toupper(added)
[17:39:55.863]                 for (kk in seq_along(NAMES)) {
[17:39:55.863]                   name <- added[[kk]]
[17:39:55.863]                   NAME <- NAMES[[kk]]
[17:39:55.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.863]                     next
[17:39:55.863]                   args[[name]] <- ""
[17:39:55.863]                 }
[17:39:55.863]                 NAMES <- toupper(removed)
[17:39:55.863]                 for (kk in seq_along(NAMES)) {
[17:39:55.863]                   name <- removed[[kk]]
[17:39:55.863]                   NAME <- NAMES[[kk]]
[17:39:55.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.863]                     next
[17:39:55.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.863]                 }
[17:39:55.863]                 if (length(args) > 0) 
[17:39:55.863]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.863]             }
[17:39:55.863]             else {
[17:39:55.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.863]             }
[17:39:55.863]             {
[17:39:55.863]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.863]                   0L) {
[17:39:55.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.863]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.863]                   base::options(opts)
[17:39:55.863]                 }
[17:39:55.863]                 {
[17:39:55.863]                   {
[17:39:55.863]                     NULL
[17:39:55.863]                     RNGkind("Mersenne-Twister")
[17:39:55.863]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.863]                       inherits = FALSE)
[17:39:55.863]                   }
[17:39:55.863]                   options(future.plan = NULL)
[17:39:55.863]                   if (is.na(NA_character_)) 
[17:39:55.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.863]                     .init = FALSE)
[17:39:55.863]                 }
[17:39:55.863]             }
[17:39:55.863]         }
[17:39:55.863]     })
[17:39:55.863]     if (TRUE) {
[17:39:55.863]         base::sink(type = "output", split = FALSE)
[17:39:55.863]         if (TRUE) {
[17:39:55.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.863]         }
[17:39:55.863]         else {
[17:39:55.863]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.863]         }
[17:39:55.863]         base::close(...future.stdout)
[17:39:55.863]         ...future.stdout <- NULL
[17:39:55.863]     }
[17:39:55.863]     ...future.result$conditions <- ...future.conditions
[17:39:55.863]     ...future.result$finished <- base::Sys.time()
[17:39:55.863]     ...future.result
[17:39:55.863] }
[17:39:55.865] assign_globals() ...
[17:39:55.865] List of 2
[17:39:55.865]  $ a : num 1
[17:39:55.865]  $ ii: int 2
[17:39:55.865]  - attr(*, "where")=List of 2
[17:39:55.865]   ..$ a :<environment: R_EmptyEnv> 
[17:39:55.865]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.865]  - attr(*, "resolved")= logi TRUE
[17:39:55.865]  - attr(*, "total_size")= num 112
[17:39:55.865]  - attr(*, "already-done")= logi TRUE
[17:39:55.868] - copied ‘a’ to environment
[17:39:55.868] - copied ‘ii’ to environment
[17:39:55.868] assign_globals() ... done
[17:39:55.868] plan(): Setting new future strategy stack:
[17:39:55.868] List of future strategies:
[17:39:55.868] 1. sequential:
[17:39:55.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.868]    - tweaked: FALSE
[17:39:55.868]    - call: NULL
[17:39:55.869] plan(): nbrOfWorkers() = 1
[17:39:55.869] plan(): Setting new future strategy stack:
[17:39:55.869] List of future strategies:
[17:39:55.869] 1. sequential:
[17:39:55.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.869]    - tweaked: FALSE
[17:39:55.869]    - call: plan(strategy)
[17:39:55.870] plan(): nbrOfWorkers() = 1
[17:39:55.870] SequentialFuture started (and completed)
[17:39:55.870] - Launch lazy future ... done
[17:39:55.870] run() for ‘SequentialFuture’ ... done
[17:39:55.870] run() for ‘Future’ ...
[17:39:55.870] - state: ‘created’
[17:39:55.871] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.871] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.871]   - Field: ‘label’
[17:39:55.871]   - Field: ‘local’
[17:39:55.871]   - Field: ‘owner’
[17:39:55.871]   - Field: ‘envir’
[17:39:55.871]   - Field: ‘packages’
[17:39:55.871]   - Field: ‘gc’
[17:39:55.872]   - Field: ‘conditions’
[17:39:55.872]   - Field: ‘expr’
[17:39:55.872]   - Field: ‘uuid’
[17:39:55.872]   - Field: ‘seed’
[17:39:55.872]   - Field: ‘version’
[17:39:55.872]   - Field: ‘result’
[17:39:55.872]   - Field: ‘asynchronous’
[17:39:55.872]   - Field: ‘calls’
[17:39:55.872]   - Field: ‘globals’
[17:39:55.872]   - Field: ‘stdout’
[17:39:55.872]   - Field: ‘earlySignal’
[17:39:55.873]   - Field: ‘lazy’
[17:39:55.873]   - Field: ‘state’
[17:39:55.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.873] - Launch lazy future ...
[17:39:55.873] Packages needed by the future expression (n = 0): <none>
[17:39:55.873] Packages needed by future strategies (n = 0): <none>
[17:39:55.873] {
[17:39:55.873]     {
[17:39:55.873]         {
[17:39:55.873]             ...future.startTime <- base::Sys.time()
[17:39:55.873]             {
[17:39:55.873]                 {
[17:39:55.873]                   {
[17:39:55.873]                     base::local({
[17:39:55.873]                       has_future <- base::requireNamespace("future", 
[17:39:55.873]                         quietly = TRUE)
[17:39:55.873]                       if (has_future) {
[17:39:55.873]                         ns <- base::getNamespace("future")
[17:39:55.873]                         version <- ns[[".package"]][["version"]]
[17:39:55.873]                         if (is.null(version)) 
[17:39:55.873]                           version <- utils::packageVersion("future")
[17:39:55.873]                       }
[17:39:55.873]                       else {
[17:39:55.873]                         version <- NULL
[17:39:55.873]                       }
[17:39:55.873]                       if (!has_future || version < "1.8.0") {
[17:39:55.873]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.873]                           "", base::R.version$version.string), 
[17:39:55.873]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.873]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.873]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.873]                             "release", "version")], collapse = " "), 
[17:39:55.873]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.873]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.873]                           info)
[17:39:55.873]                         info <- base::paste(info, collapse = "; ")
[17:39:55.873]                         if (!has_future) {
[17:39:55.873]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.873]                             info)
[17:39:55.873]                         }
[17:39:55.873]                         else {
[17:39:55.873]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.873]                             info, version)
[17:39:55.873]                         }
[17:39:55.873]                         base::stop(msg)
[17:39:55.873]                       }
[17:39:55.873]                     })
[17:39:55.873]                   }
[17:39:55.873]                   ...future.strategy.old <- future::plan("list")
[17:39:55.873]                   options(future.plan = NULL)
[17:39:55.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.873]                 }
[17:39:55.873]                 ...future.workdir <- getwd()
[17:39:55.873]             }
[17:39:55.873]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.873]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.873]         }
[17:39:55.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.873]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.873]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.873]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.873]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.873]             base::names(...future.oldOptions))
[17:39:55.873]     }
[17:39:55.873]     if (FALSE) {
[17:39:55.873]     }
[17:39:55.873]     else {
[17:39:55.873]         if (TRUE) {
[17:39:55.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.873]                 open = "w")
[17:39:55.873]         }
[17:39:55.873]         else {
[17:39:55.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.873]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.873]         }
[17:39:55.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.873]             base::sink(type = "output", split = FALSE)
[17:39:55.873]             base::close(...future.stdout)
[17:39:55.873]         }, add = TRUE)
[17:39:55.873]     }
[17:39:55.873]     ...future.frame <- base::sys.nframe()
[17:39:55.873]     ...future.conditions <- base::list()
[17:39:55.873]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.873]     if (FALSE) {
[17:39:55.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.873]     }
[17:39:55.873]     ...future.result <- base::tryCatch({
[17:39:55.873]         base::withCallingHandlers({
[17:39:55.873]             ...future.value <- base::withVisible(base::local({
[17:39:55.873]                 b <- a * ii
[17:39:55.873]                 a <- 0
[17:39:55.873]                 b
[17:39:55.873]             }))
[17:39:55.873]             future::FutureResult(value = ...future.value$value, 
[17:39:55.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.873]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.873]                     ...future.globalenv.names))
[17:39:55.873]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.873]         }, condition = base::local({
[17:39:55.873]             c <- base::c
[17:39:55.873]             inherits <- base::inherits
[17:39:55.873]             invokeRestart <- base::invokeRestart
[17:39:55.873]             length <- base::length
[17:39:55.873]             list <- base::list
[17:39:55.873]             seq.int <- base::seq.int
[17:39:55.873]             signalCondition <- base::signalCondition
[17:39:55.873]             sys.calls <- base::sys.calls
[17:39:55.873]             `[[` <- base::`[[`
[17:39:55.873]             `+` <- base::`+`
[17:39:55.873]             `<<-` <- base::`<<-`
[17:39:55.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.873]                   3L)]
[17:39:55.873]             }
[17:39:55.873]             function(cond) {
[17:39:55.873]                 is_error <- inherits(cond, "error")
[17:39:55.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.873]                   NULL)
[17:39:55.873]                 if (is_error) {
[17:39:55.873]                   sessionInformation <- function() {
[17:39:55.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.873]                       search = base::search(), system = base::Sys.info())
[17:39:55.873]                   }
[17:39:55.873]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.873]                     cond$call), session = sessionInformation(), 
[17:39:55.873]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.873]                   signalCondition(cond)
[17:39:55.873]                 }
[17:39:55.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.873]                 "immediateCondition"))) {
[17:39:55.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.873]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.873]                   if (TRUE && !signal) {
[17:39:55.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.873]                     {
[17:39:55.873]                       inherits <- base::inherits
[17:39:55.873]                       invokeRestart <- base::invokeRestart
[17:39:55.873]                       is.null <- base::is.null
[17:39:55.873]                       muffled <- FALSE
[17:39:55.873]                       if (inherits(cond, "message")) {
[17:39:55.873]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.873]                         if (muffled) 
[17:39:55.873]                           invokeRestart("muffleMessage")
[17:39:55.873]                       }
[17:39:55.873]                       else if (inherits(cond, "warning")) {
[17:39:55.873]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.873]                         if (muffled) 
[17:39:55.873]                           invokeRestart("muffleWarning")
[17:39:55.873]                       }
[17:39:55.873]                       else if (inherits(cond, "condition")) {
[17:39:55.873]                         if (!is.null(pattern)) {
[17:39:55.873]                           computeRestarts <- base::computeRestarts
[17:39:55.873]                           grepl <- base::grepl
[17:39:55.873]                           restarts <- computeRestarts(cond)
[17:39:55.873]                           for (restart in restarts) {
[17:39:55.873]                             name <- restart$name
[17:39:55.873]                             if (is.null(name)) 
[17:39:55.873]                               next
[17:39:55.873]                             if (!grepl(pattern, name)) 
[17:39:55.873]                               next
[17:39:55.873]                             invokeRestart(restart)
[17:39:55.873]                             muffled <- TRUE
[17:39:55.873]                             break
[17:39:55.873]                           }
[17:39:55.873]                         }
[17:39:55.873]                       }
[17:39:55.873]                       invisible(muffled)
[17:39:55.873]                     }
[17:39:55.873]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.873]                   }
[17:39:55.873]                 }
[17:39:55.873]                 else {
[17:39:55.873]                   if (TRUE) {
[17:39:55.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.873]                     {
[17:39:55.873]                       inherits <- base::inherits
[17:39:55.873]                       invokeRestart <- base::invokeRestart
[17:39:55.873]                       is.null <- base::is.null
[17:39:55.873]                       muffled <- FALSE
[17:39:55.873]                       if (inherits(cond, "message")) {
[17:39:55.873]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.873]                         if (muffled) 
[17:39:55.873]                           invokeRestart("muffleMessage")
[17:39:55.873]                       }
[17:39:55.873]                       else if (inherits(cond, "warning")) {
[17:39:55.873]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.873]                         if (muffled) 
[17:39:55.873]                           invokeRestart("muffleWarning")
[17:39:55.873]                       }
[17:39:55.873]                       else if (inherits(cond, "condition")) {
[17:39:55.873]                         if (!is.null(pattern)) {
[17:39:55.873]                           computeRestarts <- base::computeRestarts
[17:39:55.873]                           grepl <- base::grepl
[17:39:55.873]                           restarts <- computeRestarts(cond)
[17:39:55.873]                           for (restart in restarts) {
[17:39:55.873]                             name <- restart$name
[17:39:55.873]                             if (is.null(name)) 
[17:39:55.873]                               next
[17:39:55.873]                             if (!grepl(pattern, name)) 
[17:39:55.873]                               next
[17:39:55.873]                             invokeRestart(restart)
[17:39:55.873]                             muffled <- TRUE
[17:39:55.873]                             break
[17:39:55.873]                           }
[17:39:55.873]                         }
[17:39:55.873]                       }
[17:39:55.873]                       invisible(muffled)
[17:39:55.873]                     }
[17:39:55.873]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.873]                   }
[17:39:55.873]                 }
[17:39:55.873]             }
[17:39:55.873]         }))
[17:39:55.873]     }, error = function(ex) {
[17:39:55.873]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.873]                 ...future.rng), started = ...future.startTime, 
[17:39:55.873]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.873]             version = "1.8"), class = "FutureResult")
[17:39:55.873]     }, finally = {
[17:39:55.873]         if (!identical(...future.workdir, getwd())) 
[17:39:55.873]             setwd(...future.workdir)
[17:39:55.873]         {
[17:39:55.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.873]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.873]             }
[17:39:55.873]             base::options(...future.oldOptions)
[17:39:55.873]             if (.Platform$OS.type == "windows") {
[17:39:55.873]                 old_names <- names(...future.oldEnvVars)
[17:39:55.873]                 envs <- base::Sys.getenv()
[17:39:55.873]                 names <- names(envs)
[17:39:55.873]                 common <- intersect(names, old_names)
[17:39:55.873]                 added <- setdiff(names, old_names)
[17:39:55.873]                 removed <- setdiff(old_names, names)
[17:39:55.873]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.873]                   envs[common]]
[17:39:55.873]                 NAMES <- toupper(changed)
[17:39:55.873]                 args <- list()
[17:39:55.873]                 for (kk in seq_along(NAMES)) {
[17:39:55.873]                   name <- changed[[kk]]
[17:39:55.873]                   NAME <- NAMES[[kk]]
[17:39:55.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.873]                     next
[17:39:55.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.873]                 }
[17:39:55.873]                 NAMES <- toupper(added)
[17:39:55.873]                 for (kk in seq_along(NAMES)) {
[17:39:55.873]                   name <- added[[kk]]
[17:39:55.873]                   NAME <- NAMES[[kk]]
[17:39:55.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.873]                     next
[17:39:55.873]                   args[[name]] <- ""
[17:39:55.873]                 }
[17:39:55.873]                 NAMES <- toupper(removed)
[17:39:55.873]                 for (kk in seq_along(NAMES)) {
[17:39:55.873]                   name <- removed[[kk]]
[17:39:55.873]                   NAME <- NAMES[[kk]]
[17:39:55.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.873]                     next
[17:39:55.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.873]                 }
[17:39:55.873]                 if (length(args) > 0) 
[17:39:55.873]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.873]             }
[17:39:55.873]             else {
[17:39:55.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.873]             }
[17:39:55.873]             {
[17:39:55.873]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.873]                   0L) {
[17:39:55.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.873]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.873]                   base::options(opts)
[17:39:55.873]                 }
[17:39:55.873]                 {
[17:39:55.873]                   {
[17:39:55.873]                     NULL
[17:39:55.873]                     RNGkind("Mersenne-Twister")
[17:39:55.873]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.873]                       inherits = FALSE)
[17:39:55.873]                   }
[17:39:55.873]                   options(future.plan = NULL)
[17:39:55.873]                   if (is.na(NA_character_)) 
[17:39:55.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.873]                     .init = FALSE)
[17:39:55.873]                 }
[17:39:55.873]             }
[17:39:55.873]         }
[17:39:55.873]     })
[17:39:55.873]     if (TRUE) {
[17:39:55.873]         base::sink(type = "output", split = FALSE)
[17:39:55.873]         if (TRUE) {
[17:39:55.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.873]         }
[17:39:55.873]         else {
[17:39:55.873]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.873]         }
[17:39:55.873]         base::close(...future.stdout)
[17:39:55.873]         ...future.stdout <- NULL
[17:39:55.873]     }
[17:39:55.873]     ...future.result$conditions <- ...future.conditions
[17:39:55.873]     ...future.result$finished <- base::Sys.time()
[17:39:55.873]     ...future.result
[17:39:55.873] }
[17:39:55.875] assign_globals() ...
[17:39:55.875] List of 2
[17:39:55.875]  $ a : num 1
[17:39:55.875]  $ ii: int 3
[17:39:55.875]  - attr(*, "where")=List of 2
[17:39:55.875]   ..$ a :<environment: R_EmptyEnv> 
[17:39:55.875]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:55.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.875]  - attr(*, "resolved")= logi TRUE
[17:39:55.875]  - attr(*, "total_size")= num 112
[17:39:55.875]  - attr(*, "already-done")= logi TRUE
[17:39:55.878] - copied ‘a’ to environment
[17:39:55.878] - copied ‘ii’ to environment
[17:39:55.878] assign_globals() ... done
[17:39:55.878] plan(): Setting new future strategy stack:
[17:39:55.878] List of future strategies:
[17:39:55.878] 1. sequential:
[17:39:55.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.878]    - tweaked: FALSE
[17:39:55.878]    - call: NULL
[17:39:55.879] plan(): nbrOfWorkers() = 1
[17:39:55.879] plan(): Setting new future strategy stack:
[17:39:55.879] List of future strategies:
[17:39:55.879] 1. sequential:
[17:39:55.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.879]    - tweaked: FALSE
[17:39:55.879]    - call: plan(strategy)
[17:39:55.880] plan(): nbrOfWorkers() = 1
[17:39:55.880] SequentialFuture started (and completed)
[17:39:55.880] - Launch lazy future ... done
[17:39:55.880] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.880] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.881] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.881] 
[17:39:55.881] Searching for globals ... DONE
[17:39:55.881] - globals: [0] <none>
[17:39:55.881] getGlobalsAndPackages() ... DONE
[17:39:55.881] run() for ‘Future’ ...
[17:39:55.882] - state: ‘created’
[17:39:55.882] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.882] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.882]   - Field: ‘label’
[17:39:55.882]   - Field: ‘local’
[17:39:55.882]   - Field: ‘owner’
[17:39:55.882]   - Field: ‘envir’
[17:39:55.882]   - Field: ‘packages’
[17:39:55.882]   - Field: ‘gc’
[17:39:55.883]   - Field: ‘conditions’
[17:39:55.883]   - Field: ‘expr’
[17:39:55.883]   - Field: ‘uuid’
[17:39:55.883]   - Field: ‘seed’
[17:39:55.883]   - Field: ‘version’
[17:39:55.883]   - Field: ‘result’
[17:39:55.883]   - Field: ‘asynchronous’
[17:39:55.883]   - Field: ‘calls’
[17:39:55.883]   - Field: ‘globals’
[17:39:55.883]   - Field: ‘stdout’
[17:39:55.883]   - Field: ‘earlySignal’
[17:39:55.883]   - Field: ‘lazy’
[17:39:55.884]   - Field: ‘state’
[17:39:55.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.884] - Launch lazy future ...
[17:39:55.884] Packages needed by the future expression (n = 0): <none>
[17:39:55.884] Packages needed by future strategies (n = 0): <none>
[17:39:55.884] {
[17:39:55.884]     {
[17:39:55.884]         {
[17:39:55.884]             ...future.startTime <- base::Sys.time()
[17:39:55.884]             {
[17:39:55.884]                 {
[17:39:55.884]                   {
[17:39:55.884]                     base::local({
[17:39:55.884]                       has_future <- base::requireNamespace("future", 
[17:39:55.884]                         quietly = TRUE)
[17:39:55.884]                       if (has_future) {
[17:39:55.884]                         ns <- base::getNamespace("future")
[17:39:55.884]                         version <- ns[[".package"]][["version"]]
[17:39:55.884]                         if (is.null(version)) 
[17:39:55.884]                           version <- utils::packageVersion("future")
[17:39:55.884]                       }
[17:39:55.884]                       else {
[17:39:55.884]                         version <- NULL
[17:39:55.884]                       }
[17:39:55.884]                       if (!has_future || version < "1.8.0") {
[17:39:55.884]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.884]                           "", base::R.version$version.string), 
[17:39:55.884]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.884]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.884]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.884]                             "release", "version")], collapse = " "), 
[17:39:55.884]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.884]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.884]                           info)
[17:39:55.884]                         info <- base::paste(info, collapse = "; ")
[17:39:55.884]                         if (!has_future) {
[17:39:55.884]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.884]                             info)
[17:39:55.884]                         }
[17:39:55.884]                         else {
[17:39:55.884]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.884]                             info, version)
[17:39:55.884]                         }
[17:39:55.884]                         base::stop(msg)
[17:39:55.884]                       }
[17:39:55.884]                     })
[17:39:55.884]                   }
[17:39:55.884]                   ...future.strategy.old <- future::plan("list")
[17:39:55.884]                   options(future.plan = NULL)
[17:39:55.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.884]                 }
[17:39:55.884]                 ...future.workdir <- getwd()
[17:39:55.884]             }
[17:39:55.884]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.884]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.884]         }
[17:39:55.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.884]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.884]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.884]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.884]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.884]             base::names(...future.oldOptions))
[17:39:55.884]     }
[17:39:55.884]     if (FALSE) {
[17:39:55.884]     }
[17:39:55.884]     else {
[17:39:55.884]         if (TRUE) {
[17:39:55.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.884]                 open = "w")
[17:39:55.884]         }
[17:39:55.884]         else {
[17:39:55.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.884]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.884]         }
[17:39:55.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.884]             base::sink(type = "output", split = FALSE)
[17:39:55.884]             base::close(...future.stdout)
[17:39:55.884]         }, add = TRUE)
[17:39:55.884]     }
[17:39:55.884]     ...future.frame <- base::sys.nframe()
[17:39:55.884]     ...future.conditions <- base::list()
[17:39:55.884]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.884]     if (FALSE) {
[17:39:55.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.884]     }
[17:39:55.884]     ...future.result <- base::tryCatch({
[17:39:55.884]         base::withCallingHandlers({
[17:39:55.884]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.884]             future::FutureResult(value = ...future.value$value, 
[17:39:55.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.884]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.884]                     ...future.globalenv.names))
[17:39:55.884]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.884]         }, condition = base::local({
[17:39:55.884]             c <- base::c
[17:39:55.884]             inherits <- base::inherits
[17:39:55.884]             invokeRestart <- base::invokeRestart
[17:39:55.884]             length <- base::length
[17:39:55.884]             list <- base::list
[17:39:55.884]             seq.int <- base::seq.int
[17:39:55.884]             signalCondition <- base::signalCondition
[17:39:55.884]             sys.calls <- base::sys.calls
[17:39:55.884]             `[[` <- base::`[[`
[17:39:55.884]             `+` <- base::`+`
[17:39:55.884]             `<<-` <- base::`<<-`
[17:39:55.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.884]                   3L)]
[17:39:55.884]             }
[17:39:55.884]             function(cond) {
[17:39:55.884]                 is_error <- inherits(cond, "error")
[17:39:55.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.884]                   NULL)
[17:39:55.884]                 if (is_error) {
[17:39:55.884]                   sessionInformation <- function() {
[17:39:55.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.884]                       search = base::search(), system = base::Sys.info())
[17:39:55.884]                   }
[17:39:55.884]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.884]                     cond$call), session = sessionInformation(), 
[17:39:55.884]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.884]                   signalCondition(cond)
[17:39:55.884]                 }
[17:39:55.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.884]                 "immediateCondition"))) {
[17:39:55.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.884]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.884]                   if (TRUE && !signal) {
[17:39:55.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.884]                     {
[17:39:55.884]                       inherits <- base::inherits
[17:39:55.884]                       invokeRestart <- base::invokeRestart
[17:39:55.884]                       is.null <- base::is.null
[17:39:55.884]                       muffled <- FALSE
[17:39:55.884]                       if (inherits(cond, "message")) {
[17:39:55.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.884]                         if (muffled) 
[17:39:55.884]                           invokeRestart("muffleMessage")
[17:39:55.884]                       }
[17:39:55.884]                       else if (inherits(cond, "warning")) {
[17:39:55.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.884]                         if (muffled) 
[17:39:55.884]                           invokeRestart("muffleWarning")
[17:39:55.884]                       }
[17:39:55.884]                       else if (inherits(cond, "condition")) {
[17:39:55.884]                         if (!is.null(pattern)) {
[17:39:55.884]                           computeRestarts <- base::computeRestarts
[17:39:55.884]                           grepl <- base::grepl
[17:39:55.884]                           restarts <- computeRestarts(cond)
[17:39:55.884]                           for (restart in restarts) {
[17:39:55.884]                             name <- restart$name
[17:39:55.884]                             if (is.null(name)) 
[17:39:55.884]                               next
[17:39:55.884]                             if (!grepl(pattern, name)) 
[17:39:55.884]                               next
[17:39:55.884]                             invokeRestart(restart)
[17:39:55.884]                             muffled <- TRUE
[17:39:55.884]                             break
[17:39:55.884]                           }
[17:39:55.884]                         }
[17:39:55.884]                       }
[17:39:55.884]                       invisible(muffled)
[17:39:55.884]                     }
[17:39:55.884]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.884]                   }
[17:39:55.884]                 }
[17:39:55.884]                 else {
[17:39:55.884]                   if (TRUE) {
[17:39:55.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.884]                     {
[17:39:55.884]                       inherits <- base::inherits
[17:39:55.884]                       invokeRestart <- base::invokeRestart
[17:39:55.884]                       is.null <- base::is.null
[17:39:55.884]                       muffled <- FALSE
[17:39:55.884]                       if (inherits(cond, "message")) {
[17:39:55.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.884]                         if (muffled) 
[17:39:55.884]                           invokeRestart("muffleMessage")
[17:39:55.884]                       }
[17:39:55.884]                       else if (inherits(cond, "warning")) {
[17:39:55.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.884]                         if (muffled) 
[17:39:55.884]                           invokeRestart("muffleWarning")
[17:39:55.884]                       }
[17:39:55.884]                       else if (inherits(cond, "condition")) {
[17:39:55.884]                         if (!is.null(pattern)) {
[17:39:55.884]                           computeRestarts <- base::computeRestarts
[17:39:55.884]                           grepl <- base::grepl
[17:39:55.884]                           restarts <- computeRestarts(cond)
[17:39:55.884]                           for (restart in restarts) {
[17:39:55.884]                             name <- restart$name
[17:39:55.884]                             if (is.null(name)) 
[17:39:55.884]                               next
[17:39:55.884]                             if (!grepl(pattern, name)) 
[17:39:55.884]                               next
[17:39:55.884]                             invokeRestart(restart)
[17:39:55.884]                             muffled <- TRUE
[17:39:55.884]                             break
[17:39:55.884]                           }
[17:39:55.884]                         }
[17:39:55.884]                       }
[17:39:55.884]                       invisible(muffled)
[17:39:55.884]                     }
[17:39:55.884]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.884]                   }
[17:39:55.884]                 }
[17:39:55.884]             }
[17:39:55.884]         }))
[17:39:55.884]     }, error = function(ex) {
[17:39:55.884]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.884]                 ...future.rng), started = ...future.startTime, 
[17:39:55.884]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.884]             version = "1.8"), class = "FutureResult")
[17:39:55.884]     }, finally = {
[17:39:55.884]         if (!identical(...future.workdir, getwd())) 
[17:39:55.884]             setwd(...future.workdir)
[17:39:55.884]         {
[17:39:55.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.884]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.884]             }
[17:39:55.884]             base::options(...future.oldOptions)
[17:39:55.884]             if (.Platform$OS.type == "windows") {
[17:39:55.884]                 old_names <- names(...future.oldEnvVars)
[17:39:55.884]                 envs <- base::Sys.getenv()
[17:39:55.884]                 names <- names(envs)
[17:39:55.884]                 common <- intersect(names, old_names)
[17:39:55.884]                 added <- setdiff(names, old_names)
[17:39:55.884]                 removed <- setdiff(old_names, names)
[17:39:55.884]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.884]                   envs[common]]
[17:39:55.884]                 NAMES <- toupper(changed)
[17:39:55.884]                 args <- list()
[17:39:55.884]                 for (kk in seq_along(NAMES)) {
[17:39:55.884]                   name <- changed[[kk]]
[17:39:55.884]                   NAME <- NAMES[[kk]]
[17:39:55.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.884]                     next
[17:39:55.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.884]                 }
[17:39:55.884]                 NAMES <- toupper(added)
[17:39:55.884]                 for (kk in seq_along(NAMES)) {
[17:39:55.884]                   name <- added[[kk]]
[17:39:55.884]                   NAME <- NAMES[[kk]]
[17:39:55.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.884]                     next
[17:39:55.884]                   args[[name]] <- ""
[17:39:55.884]                 }
[17:39:55.884]                 NAMES <- toupper(removed)
[17:39:55.884]                 for (kk in seq_along(NAMES)) {
[17:39:55.884]                   name <- removed[[kk]]
[17:39:55.884]                   NAME <- NAMES[[kk]]
[17:39:55.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.884]                     next
[17:39:55.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.884]                 }
[17:39:55.884]                 if (length(args) > 0) 
[17:39:55.884]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.884]             }
[17:39:55.884]             else {
[17:39:55.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.884]             }
[17:39:55.884]             {
[17:39:55.884]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.884]                   0L) {
[17:39:55.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.884]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.884]                   base::options(opts)
[17:39:55.884]                 }
[17:39:55.884]                 {
[17:39:55.884]                   {
[17:39:55.884]                     NULL
[17:39:55.884]                     RNGkind("Mersenne-Twister")
[17:39:55.884]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.884]                       inherits = FALSE)
[17:39:55.884]                   }
[17:39:55.884]                   options(future.plan = NULL)
[17:39:55.884]                   if (is.na(NA_character_)) 
[17:39:55.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.884]                     .init = FALSE)
[17:39:55.884]                 }
[17:39:55.884]             }
[17:39:55.884]         }
[17:39:55.884]     })
[17:39:55.884]     if (TRUE) {
[17:39:55.884]         base::sink(type = "output", split = FALSE)
[17:39:55.884]         if (TRUE) {
[17:39:55.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.884]         }
[17:39:55.884]         else {
[17:39:55.884]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.884]         }
[17:39:55.884]         base::close(...future.stdout)
[17:39:55.884]         ...future.stdout <- NULL
[17:39:55.884]     }
[17:39:55.884]     ...future.result$conditions <- ...future.conditions
[17:39:55.884]     ...future.result$finished <- base::Sys.time()
[17:39:55.884]     ...future.result
[17:39:55.884] }
[17:39:55.886] plan(): Setting new future strategy stack:
[17:39:55.886] List of future strategies:
[17:39:55.886] 1. sequential:
[17:39:55.886]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.886]    - tweaked: FALSE
[17:39:55.886]    - call: NULL
[17:39:55.886] plan(): nbrOfWorkers() = 1
[17:39:55.887] plan(): Setting new future strategy stack:
[17:39:55.887] List of future strategies:
[17:39:55.887] 1. sequential:
[17:39:55.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.887]    - tweaked: FALSE
[17:39:55.887]    - call: plan(strategy)
[17:39:55.888] plan(): nbrOfWorkers() = 1
[17:39:55.888] SequentialFuture started (and completed)
[17:39:55.888] - Launch lazy future ... done
[17:39:55.888] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.888] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.888] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.890] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.890] Searching for globals ... DONE
[17:39:55.890] Resolving globals: TRUE
[17:39:55.890] Resolving any globals that are futures ...
[17:39:55.891] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.891] Resolving any globals that are futures ... DONE
[17:39:55.891] Resolving futures part of globals (recursively) ...
[17:39:55.891] resolve() on list ...
[17:39:55.891]  recursive: 99
[17:39:55.891]  length: 1
[17:39:55.891]  elements: ‘a’
[17:39:55.892] resolved() for ‘SequentialFuture’ ...
[17:39:55.892] - state: ‘finished’
[17:39:55.892] - run: TRUE
[17:39:55.892] - result: ‘FutureResult’
[17:39:55.892] resolved() for ‘SequentialFuture’ ... done
[17:39:55.892] Future #1
[17:39:55.892] resolved() for ‘SequentialFuture’ ...
[17:39:55.892] - state: ‘finished’
[17:39:55.892] - run: TRUE
[17:39:55.892] - result: ‘FutureResult’
[17:39:55.892] resolved() for ‘SequentialFuture’ ... done
[17:39:55.893] A SequentialFuture was resolved
[17:39:55.893]  length: 0 (resolved future 1)
[17:39:55.893] resolve() on list ... DONE
[17:39:55.893] - globals: [1] ‘a’
[17:39:55.893] Resolving futures part of globals (recursively) ... DONE
[17:39:55.895] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[17:39:55.895] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:39:55.895] - globals: [1] ‘a’
[17:39:55.895] - packages: [1] ‘future’
[17:39:55.895] getGlobalsAndPackages() ... DONE
[17:39:55.895] run() for ‘Future’ ...
[17:39:55.896] - state: ‘created’
[17:39:55.896] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.896] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.896] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.896]   - Field: ‘label’
[17:39:55.896]   - Field: ‘local’
[17:39:55.896]   - Field: ‘owner’
[17:39:55.896]   - Field: ‘envir’
[17:39:55.896]   - Field: ‘packages’
[17:39:55.897]   - Field: ‘gc’
[17:39:55.897]   - Field: ‘conditions’
[17:39:55.897]   - Field: ‘expr’
[17:39:55.897]   - Field: ‘uuid’
[17:39:55.897]   - Field: ‘seed’
[17:39:55.897]   - Field: ‘version’
[17:39:55.897]   - Field: ‘result’
[17:39:55.897]   - Field: ‘asynchronous’
[17:39:55.897]   - Field: ‘calls’
[17:39:55.897]   - Field: ‘globals’
[17:39:55.897]   - Field: ‘stdout’
[17:39:55.897]   - Field: ‘earlySignal’
[17:39:55.898]   - Field: ‘lazy’
[17:39:55.898]   - Field: ‘state’
[17:39:55.898] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.898] - Launch lazy future ...
[17:39:55.898] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.898] Packages needed by future strategies (n = 0): <none>
[17:39:55.898] {
[17:39:55.898]     {
[17:39:55.898]         {
[17:39:55.898]             ...future.startTime <- base::Sys.time()
[17:39:55.898]             {
[17:39:55.898]                 {
[17:39:55.898]                   {
[17:39:55.898]                     {
[17:39:55.898]                       base::local({
[17:39:55.898]                         has_future <- base::requireNamespace("future", 
[17:39:55.898]                           quietly = TRUE)
[17:39:55.898]                         if (has_future) {
[17:39:55.898]                           ns <- base::getNamespace("future")
[17:39:55.898]                           version <- ns[[".package"]][["version"]]
[17:39:55.898]                           if (is.null(version)) 
[17:39:55.898]                             version <- utils::packageVersion("future")
[17:39:55.898]                         }
[17:39:55.898]                         else {
[17:39:55.898]                           version <- NULL
[17:39:55.898]                         }
[17:39:55.898]                         if (!has_future || version < "1.8.0") {
[17:39:55.898]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.898]                             "", base::R.version$version.string), 
[17:39:55.898]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.898]                               "release", "version")], collapse = " "), 
[17:39:55.898]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.898]                             info)
[17:39:55.898]                           info <- base::paste(info, collapse = "; ")
[17:39:55.898]                           if (!has_future) {
[17:39:55.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.898]                               info)
[17:39:55.898]                           }
[17:39:55.898]                           else {
[17:39:55.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.898]                               info, version)
[17:39:55.898]                           }
[17:39:55.898]                           base::stop(msg)
[17:39:55.898]                         }
[17:39:55.898]                       })
[17:39:55.898]                     }
[17:39:55.898]                     base::local({
[17:39:55.898]                       for (pkg in "future") {
[17:39:55.898]                         base::loadNamespace(pkg)
[17:39:55.898]                         base::library(pkg, character.only = TRUE)
[17:39:55.898]                       }
[17:39:55.898]                     })
[17:39:55.898]                   }
[17:39:55.898]                   ...future.strategy.old <- future::plan("list")
[17:39:55.898]                   options(future.plan = NULL)
[17:39:55.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.898]                 }
[17:39:55.898]                 ...future.workdir <- getwd()
[17:39:55.898]             }
[17:39:55.898]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.898]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.898]         }
[17:39:55.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.898]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.898]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.898]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.898]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.898]             base::names(...future.oldOptions))
[17:39:55.898]     }
[17:39:55.898]     if (FALSE) {
[17:39:55.898]     }
[17:39:55.898]     else {
[17:39:55.898]         if (TRUE) {
[17:39:55.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.898]                 open = "w")
[17:39:55.898]         }
[17:39:55.898]         else {
[17:39:55.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.898]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.898]         }
[17:39:55.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.898]             base::sink(type = "output", split = FALSE)
[17:39:55.898]             base::close(...future.stdout)
[17:39:55.898]         }, add = TRUE)
[17:39:55.898]     }
[17:39:55.898]     ...future.frame <- base::sys.nframe()
[17:39:55.898]     ...future.conditions <- base::list()
[17:39:55.898]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.898]     if (FALSE) {
[17:39:55.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.898]     }
[17:39:55.898]     ...future.result <- base::tryCatch({
[17:39:55.898]         base::withCallingHandlers({
[17:39:55.898]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.898]                 1))
[17:39:55.898]             future::FutureResult(value = ...future.value$value, 
[17:39:55.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.898]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.898]                     ...future.globalenv.names))
[17:39:55.898]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.898]         }, condition = base::local({
[17:39:55.898]             c <- base::c
[17:39:55.898]             inherits <- base::inherits
[17:39:55.898]             invokeRestart <- base::invokeRestart
[17:39:55.898]             length <- base::length
[17:39:55.898]             list <- base::list
[17:39:55.898]             seq.int <- base::seq.int
[17:39:55.898]             signalCondition <- base::signalCondition
[17:39:55.898]             sys.calls <- base::sys.calls
[17:39:55.898]             `[[` <- base::`[[`
[17:39:55.898]             `+` <- base::`+`
[17:39:55.898]             `<<-` <- base::`<<-`
[17:39:55.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.898]                   3L)]
[17:39:55.898]             }
[17:39:55.898]             function(cond) {
[17:39:55.898]                 is_error <- inherits(cond, "error")
[17:39:55.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.898]                   NULL)
[17:39:55.898]                 if (is_error) {
[17:39:55.898]                   sessionInformation <- function() {
[17:39:55.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.898]                       search = base::search(), system = base::Sys.info())
[17:39:55.898]                   }
[17:39:55.898]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.898]                     cond$call), session = sessionInformation(), 
[17:39:55.898]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.898]                   signalCondition(cond)
[17:39:55.898]                 }
[17:39:55.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.898]                 "immediateCondition"))) {
[17:39:55.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.898]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.898]                   if (TRUE && !signal) {
[17:39:55.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.898]                     {
[17:39:55.898]                       inherits <- base::inherits
[17:39:55.898]                       invokeRestart <- base::invokeRestart
[17:39:55.898]                       is.null <- base::is.null
[17:39:55.898]                       muffled <- FALSE
[17:39:55.898]                       if (inherits(cond, "message")) {
[17:39:55.898]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.898]                         if (muffled) 
[17:39:55.898]                           invokeRestart("muffleMessage")
[17:39:55.898]                       }
[17:39:55.898]                       else if (inherits(cond, "warning")) {
[17:39:55.898]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.898]                         if (muffled) 
[17:39:55.898]                           invokeRestart("muffleWarning")
[17:39:55.898]                       }
[17:39:55.898]                       else if (inherits(cond, "condition")) {
[17:39:55.898]                         if (!is.null(pattern)) {
[17:39:55.898]                           computeRestarts <- base::computeRestarts
[17:39:55.898]                           grepl <- base::grepl
[17:39:55.898]                           restarts <- computeRestarts(cond)
[17:39:55.898]                           for (restart in restarts) {
[17:39:55.898]                             name <- restart$name
[17:39:55.898]                             if (is.null(name)) 
[17:39:55.898]                               next
[17:39:55.898]                             if (!grepl(pattern, name)) 
[17:39:55.898]                               next
[17:39:55.898]                             invokeRestart(restart)
[17:39:55.898]                             muffled <- TRUE
[17:39:55.898]                             break
[17:39:55.898]                           }
[17:39:55.898]                         }
[17:39:55.898]                       }
[17:39:55.898]                       invisible(muffled)
[17:39:55.898]                     }
[17:39:55.898]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.898]                   }
[17:39:55.898]                 }
[17:39:55.898]                 else {
[17:39:55.898]                   if (TRUE) {
[17:39:55.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.898]                     {
[17:39:55.898]                       inherits <- base::inherits
[17:39:55.898]                       invokeRestart <- base::invokeRestart
[17:39:55.898]                       is.null <- base::is.null
[17:39:55.898]                       muffled <- FALSE
[17:39:55.898]                       if (inherits(cond, "message")) {
[17:39:55.898]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.898]                         if (muffled) 
[17:39:55.898]                           invokeRestart("muffleMessage")
[17:39:55.898]                       }
[17:39:55.898]                       else if (inherits(cond, "warning")) {
[17:39:55.898]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.898]                         if (muffled) 
[17:39:55.898]                           invokeRestart("muffleWarning")
[17:39:55.898]                       }
[17:39:55.898]                       else if (inherits(cond, "condition")) {
[17:39:55.898]                         if (!is.null(pattern)) {
[17:39:55.898]                           computeRestarts <- base::computeRestarts
[17:39:55.898]                           grepl <- base::grepl
[17:39:55.898]                           restarts <- computeRestarts(cond)
[17:39:55.898]                           for (restart in restarts) {
[17:39:55.898]                             name <- restart$name
[17:39:55.898]                             if (is.null(name)) 
[17:39:55.898]                               next
[17:39:55.898]                             if (!grepl(pattern, name)) 
[17:39:55.898]                               next
[17:39:55.898]                             invokeRestart(restart)
[17:39:55.898]                             muffled <- TRUE
[17:39:55.898]                             break
[17:39:55.898]                           }
[17:39:55.898]                         }
[17:39:55.898]                       }
[17:39:55.898]                       invisible(muffled)
[17:39:55.898]                     }
[17:39:55.898]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.898]                   }
[17:39:55.898]                 }
[17:39:55.898]             }
[17:39:55.898]         }))
[17:39:55.898]     }, error = function(ex) {
[17:39:55.898]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.898]                 ...future.rng), started = ...future.startTime, 
[17:39:55.898]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.898]             version = "1.8"), class = "FutureResult")
[17:39:55.898]     }, finally = {
[17:39:55.898]         if (!identical(...future.workdir, getwd())) 
[17:39:55.898]             setwd(...future.workdir)
[17:39:55.898]         {
[17:39:55.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.898]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.898]             }
[17:39:55.898]             base::options(...future.oldOptions)
[17:39:55.898]             if (.Platform$OS.type == "windows") {
[17:39:55.898]                 old_names <- names(...future.oldEnvVars)
[17:39:55.898]                 envs <- base::Sys.getenv()
[17:39:55.898]                 names <- names(envs)
[17:39:55.898]                 common <- intersect(names, old_names)
[17:39:55.898]                 added <- setdiff(names, old_names)
[17:39:55.898]                 removed <- setdiff(old_names, names)
[17:39:55.898]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.898]                   envs[common]]
[17:39:55.898]                 NAMES <- toupper(changed)
[17:39:55.898]                 args <- list()
[17:39:55.898]                 for (kk in seq_along(NAMES)) {
[17:39:55.898]                   name <- changed[[kk]]
[17:39:55.898]                   NAME <- NAMES[[kk]]
[17:39:55.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.898]                     next
[17:39:55.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.898]                 }
[17:39:55.898]                 NAMES <- toupper(added)
[17:39:55.898]                 for (kk in seq_along(NAMES)) {
[17:39:55.898]                   name <- added[[kk]]
[17:39:55.898]                   NAME <- NAMES[[kk]]
[17:39:55.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.898]                     next
[17:39:55.898]                   args[[name]] <- ""
[17:39:55.898]                 }
[17:39:55.898]                 NAMES <- toupper(removed)
[17:39:55.898]                 for (kk in seq_along(NAMES)) {
[17:39:55.898]                   name <- removed[[kk]]
[17:39:55.898]                   NAME <- NAMES[[kk]]
[17:39:55.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.898]                     next
[17:39:55.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.898]                 }
[17:39:55.898]                 if (length(args) > 0) 
[17:39:55.898]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.898]             }
[17:39:55.898]             else {
[17:39:55.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.898]             }
[17:39:55.898]             {
[17:39:55.898]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.898]                   0L) {
[17:39:55.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.898]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.898]                   base::options(opts)
[17:39:55.898]                 }
[17:39:55.898]                 {
[17:39:55.898]                   {
[17:39:55.898]                     NULL
[17:39:55.898]                     RNGkind("Mersenne-Twister")
[17:39:55.898]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.898]                       inherits = FALSE)
[17:39:55.898]                   }
[17:39:55.898]                   options(future.plan = NULL)
[17:39:55.898]                   if (is.na(NA_character_)) 
[17:39:55.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.898]                     .init = FALSE)
[17:39:55.898]                 }
[17:39:55.898]             }
[17:39:55.898]         }
[17:39:55.898]     })
[17:39:55.898]     if (TRUE) {
[17:39:55.898]         base::sink(type = "output", split = FALSE)
[17:39:55.898]         if (TRUE) {
[17:39:55.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.898]         }
[17:39:55.898]         else {
[17:39:55.898]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.898]         }
[17:39:55.898]         base::close(...future.stdout)
[17:39:55.898]         ...future.stdout <- NULL
[17:39:55.898]     }
[17:39:55.898]     ...future.result$conditions <- ...future.conditions
[17:39:55.898]     ...future.result$finished <- base::Sys.time()
[17:39:55.898]     ...future.result
[17:39:55.898] }
[17:39:55.900] assign_globals() ...
[17:39:55.900] List of 1
[17:39:55.900]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd846aba0> 
[17:39:55.900]  - attr(*, "where")=List of 1
[17:39:55.900]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.900]  - attr(*, "resolved")= logi TRUE
[17:39:55.900]  - attr(*, "total_size")= num 1622272
[17:39:55.900]  - attr(*, "already-done")= logi TRUE
[17:39:55.902] - copied ‘a’ to environment
[17:39:55.902] assign_globals() ... done
[17:39:55.903] plan(): Setting new future strategy stack:
[17:39:55.903] List of future strategies:
[17:39:55.903] 1. sequential:
[17:39:55.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.903]    - tweaked: FALSE
[17:39:55.903]    - call: NULL
[17:39:55.903] plan(): nbrOfWorkers() = 1
[17:39:55.904] plan(): Setting new future strategy stack:
[17:39:55.904] List of future strategies:
[17:39:55.904] 1. sequential:
[17:39:55.904]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.904]    - tweaked: FALSE
[17:39:55.904]    - call: plan(strategy)
[17:39:55.904] plan(): nbrOfWorkers() = 1
[17:39:55.905] SequentialFuture started (and completed)
[17:39:55.905] - Launch lazy future ... done
[17:39:55.905] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.905] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.905] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.906] 
[17:39:55.906] Searching for globals ... DONE
[17:39:55.906] - globals: [0] <none>
[17:39:55.906] getGlobalsAndPackages() ... DONE
[17:39:55.906] run() for ‘Future’ ...
[17:39:55.906] - state: ‘created’
[17:39:55.906] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.907] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.907]   - Field: ‘label’
[17:39:55.907]   - Field: ‘local’
[17:39:55.907]   - Field: ‘owner’
[17:39:55.907]   - Field: ‘envir’
[17:39:55.907]   - Field: ‘packages’
[17:39:55.907]   - Field: ‘gc’
[17:39:55.907]   - Field: ‘conditions’
[17:39:55.907]   - Field: ‘expr’
[17:39:55.907]   - Field: ‘uuid’
[17:39:55.908]   - Field: ‘seed’
[17:39:55.908]   - Field: ‘version’
[17:39:55.908]   - Field: ‘result’
[17:39:55.908]   - Field: ‘asynchronous’
[17:39:55.908]   - Field: ‘calls’
[17:39:55.908]   - Field: ‘globals’
[17:39:55.908]   - Field: ‘stdout’
[17:39:55.908]   - Field: ‘earlySignal’
[17:39:55.908]   - Field: ‘lazy’
[17:39:55.908]   - Field: ‘state’
[17:39:55.908] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.909] - Launch lazy future ...
[17:39:55.909] Packages needed by the future expression (n = 0): <none>
[17:39:55.909] Packages needed by future strategies (n = 0): <none>
[17:39:55.909] {
[17:39:55.909]     {
[17:39:55.909]         {
[17:39:55.909]             ...future.startTime <- base::Sys.time()
[17:39:55.909]             {
[17:39:55.909]                 {
[17:39:55.909]                   {
[17:39:55.909]                     base::local({
[17:39:55.909]                       has_future <- base::requireNamespace("future", 
[17:39:55.909]                         quietly = TRUE)
[17:39:55.909]                       if (has_future) {
[17:39:55.909]                         ns <- base::getNamespace("future")
[17:39:55.909]                         version <- ns[[".package"]][["version"]]
[17:39:55.909]                         if (is.null(version)) 
[17:39:55.909]                           version <- utils::packageVersion("future")
[17:39:55.909]                       }
[17:39:55.909]                       else {
[17:39:55.909]                         version <- NULL
[17:39:55.909]                       }
[17:39:55.909]                       if (!has_future || version < "1.8.0") {
[17:39:55.909]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.909]                           "", base::R.version$version.string), 
[17:39:55.909]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.909]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.909]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.909]                             "release", "version")], collapse = " "), 
[17:39:55.909]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.909]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.909]                           info)
[17:39:55.909]                         info <- base::paste(info, collapse = "; ")
[17:39:55.909]                         if (!has_future) {
[17:39:55.909]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.909]                             info)
[17:39:55.909]                         }
[17:39:55.909]                         else {
[17:39:55.909]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.909]                             info, version)
[17:39:55.909]                         }
[17:39:55.909]                         base::stop(msg)
[17:39:55.909]                       }
[17:39:55.909]                     })
[17:39:55.909]                   }
[17:39:55.909]                   ...future.strategy.old <- future::plan("list")
[17:39:55.909]                   options(future.plan = NULL)
[17:39:55.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.909]                 }
[17:39:55.909]                 ...future.workdir <- getwd()
[17:39:55.909]             }
[17:39:55.909]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.909]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.909]         }
[17:39:55.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.909]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.909]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.909]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.909]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.909]             base::names(...future.oldOptions))
[17:39:55.909]     }
[17:39:55.909]     if (FALSE) {
[17:39:55.909]     }
[17:39:55.909]     else {
[17:39:55.909]         if (TRUE) {
[17:39:55.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.909]                 open = "w")
[17:39:55.909]         }
[17:39:55.909]         else {
[17:39:55.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.909]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.909]         }
[17:39:55.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.909]             base::sink(type = "output", split = FALSE)
[17:39:55.909]             base::close(...future.stdout)
[17:39:55.909]         }, add = TRUE)
[17:39:55.909]     }
[17:39:55.909]     ...future.frame <- base::sys.nframe()
[17:39:55.909]     ...future.conditions <- base::list()
[17:39:55.909]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.909]     if (FALSE) {
[17:39:55.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.909]     }
[17:39:55.909]     ...future.result <- base::tryCatch({
[17:39:55.909]         base::withCallingHandlers({
[17:39:55.909]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.909]             future::FutureResult(value = ...future.value$value, 
[17:39:55.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.909]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.909]                     ...future.globalenv.names))
[17:39:55.909]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.909]         }, condition = base::local({
[17:39:55.909]             c <- base::c
[17:39:55.909]             inherits <- base::inherits
[17:39:55.909]             invokeRestart <- base::invokeRestart
[17:39:55.909]             length <- base::length
[17:39:55.909]             list <- base::list
[17:39:55.909]             seq.int <- base::seq.int
[17:39:55.909]             signalCondition <- base::signalCondition
[17:39:55.909]             sys.calls <- base::sys.calls
[17:39:55.909]             `[[` <- base::`[[`
[17:39:55.909]             `+` <- base::`+`
[17:39:55.909]             `<<-` <- base::`<<-`
[17:39:55.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.909]                   3L)]
[17:39:55.909]             }
[17:39:55.909]             function(cond) {
[17:39:55.909]                 is_error <- inherits(cond, "error")
[17:39:55.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.909]                   NULL)
[17:39:55.909]                 if (is_error) {
[17:39:55.909]                   sessionInformation <- function() {
[17:39:55.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.909]                       search = base::search(), system = base::Sys.info())
[17:39:55.909]                   }
[17:39:55.909]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.909]                     cond$call), session = sessionInformation(), 
[17:39:55.909]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.909]                   signalCondition(cond)
[17:39:55.909]                 }
[17:39:55.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.909]                 "immediateCondition"))) {
[17:39:55.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.909]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.909]                   if (TRUE && !signal) {
[17:39:55.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.909]                     {
[17:39:55.909]                       inherits <- base::inherits
[17:39:55.909]                       invokeRestart <- base::invokeRestart
[17:39:55.909]                       is.null <- base::is.null
[17:39:55.909]                       muffled <- FALSE
[17:39:55.909]                       if (inherits(cond, "message")) {
[17:39:55.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.909]                         if (muffled) 
[17:39:55.909]                           invokeRestart("muffleMessage")
[17:39:55.909]                       }
[17:39:55.909]                       else if (inherits(cond, "warning")) {
[17:39:55.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.909]                         if (muffled) 
[17:39:55.909]                           invokeRestart("muffleWarning")
[17:39:55.909]                       }
[17:39:55.909]                       else if (inherits(cond, "condition")) {
[17:39:55.909]                         if (!is.null(pattern)) {
[17:39:55.909]                           computeRestarts <- base::computeRestarts
[17:39:55.909]                           grepl <- base::grepl
[17:39:55.909]                           restarts <- computeRestarts(cond)
[17:39:55.909]                           for (restart in restarts) {
[17:39:55.909]                             name <- restart$name
[17:39:55.909]                             if (is.null(name)) 
[17:39:55.909]                               next
[17:39:55.909]                             if (!grepl(pattern, name)) 
[17:39:55.909]                               next
[17:39:55.909]                             invokeRestart(restart)
[17:39:55.909]                             muffled <- TRUE
[17:39:55.909]                             break
[17:39:55.909]                           }
[17:39:55.909]                         }
[17:39:55.909]                       }
[17:39:55.909]                       invisible(muffled)
[17:39:55.909]                     }
[17:39:55.909]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.909]                   }
[17:39:55.909]                 }
[17:39:55.909]                 else {
[17:39:55.909]                   if (TRUE) {
[17:39:55.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.909]                     {
[17:39:55.909]                       inherits <- base::inherits
[17:39:55.909]                       invokeRestart <- base::invokeRestart
[17:39:55.909]                       is.null <- base::is.null
[17:39:55.909]                       muffled <- FALSE
[17:39:55.909]                       if (inherits(cond, "message")) {
[17:39:55.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.909]                         if (muffled) 
[17:39:55.909]                           invokeRestart("muffleMessage")
[17:39:55.909]                       }
[17:39:55.909]                       else if (inherits(cond, "warning")) {
[17:39:55.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.909]                         if (muffled) 
[17:39:55.909]                           invokeRestart("muffleWarning")
[17:39:55.909]                       }
[17:39:55.909]                       else if (inherits(cond, "condition")) {
[17:39:55.909]                         if (!is.null(pattern)) {
[17:39:55.909]                           computeRestarts <- base::computeRestarts
[17:39:55.909]                           grepl <- base::grepl
[17:39:55.909]                           restarts <- computeRestarts(cond)
[17:39:55.909]                           for (restart in restarts) {
[17:39:55.909]                             name <- restart$name
[17:39:55.909]                             if (is.null(name)) 
[17:39:55.909]                               next
[17:39:55.909]                             if (!grepl(pattern, name)) 
[17:39:55.909]                               next
[17:39:55.909]                             invokeRestart(restart)
[17:39:55.909]                             muffled <- TRUE
[17:39:55.909]                             break
[17:39:55.909]                           }
[17:39:55.909]                         }
[17:39:55.909]                       }
[17:39:55.909]                       invisible(muffled)
[17:39:55.909]                     }
[17:39:55.909]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.909]                   }
[17:39:55.909]                 }
[17:39:55.909]             }
[17:39:55.909]         }))
[17:39:55.909]     }, error = function(ex) {
[17:39:55.909]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.909]                 ...future.rng), started = ...future.startTime, 
[17:39:55.909]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.909]             version = "1.8"), class = "FutureResult")
[17:39:55.909]     }, finally = {
[17:39:55.909]         if (!identical(...future.workdir, getwd())) 
[17:39:55.909]             setwd(...future.workdir)
[17:39:55.909]         {
[17:39:55.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.909]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.909]             }
[17:39:55.909]             base::options(...future.oldOptions)
[17:39:55.909]             if (.Platform$OS.type == "windows") {
[17:39:55.909]                 old_names <- names(...future.oldEnvVars)
[17:39:55.909]                 envs <- base::Sys.getenv()
[17:39:55.909]                 names <- names(envs)
[17:39:55.909]                 common <- intersect(names, old_names)
[17:39:55.909]                 added <- setdiff(names, old_names)
[17:39:55.909]                 removed <- setdiff(old_names, names)
[17:39:55.909]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.909]                   envs[common]]
[17:39:55.909]                 NAMES <- toupper(changed)
[17:39:55.909]                 args <- list()
[17:39:55.909]                 for (kk in seq_along(NAMES)) {
[17:39:55.909]                   name <- changed[[kk]]
[17:39:55.909]                   NAME <- NAMES[[kk]]
[17:39:55.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.909]                     next
[17:39:55.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.909]                 }
[17:39:55.909]                 NAMES <- toupper(added)
[17:39:55.909]                 for (kk in seq_along(NAMES)) {
[17:39:55.909]                   name <- added[[kk]]
[17:39:55.909]                   NAME <- NAMES[[kk]]
[17:39:55.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.909]                     next
[17:39:55.909]                   args[[name]] <- ""
[17:39:55.909]                 }
[17:39:55.909]                 NAMES <- toupper(removed)
[17:39:55.909]                 for (kk in seq_along(NAMES)) {
[17:39:55.909]                   name <- removed[[kk]]
[17:39:55.909]                   NAME <- NAMES[[kk]]
[17:39:55.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.909]                     next
[17:39:55.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.909]                 }
[17:39:55.909]                 if (length(args) > 0) 
[17:39:55.909]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.909]             }
[17:39:55.909]             else {
[17:39:55.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.909]             }
[17:39:55.909]             {
[17:39:55.909]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.909]                   0L) {
[17:39:55.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.909]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.909]                   base::options(opts)
[17:39:55.909]                 }
[17:39:55.909]                 {
[17:39:55.909]                   {
[17:39:55.909]                     NULL
[17:39:55.909]                     RNGkind("Mersenne-Twister")
[17:39:55.909]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.909]                       inherits = FALSE)
[17:39:55.909]                   }
[17:39:55.909]                   options(future.plan = NULL)
[17:39:55.909]                   if (is.na(NA_character_)) 
[17:39:55.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.909]                     .init = FALSE)
[17:39:55.909]                 }
[17:39:55.909]             }
[17:39:55.909]         }
[17:39:55.909]     })
[17:39:55.909]     if (TRUE) {
[17:39:55.909]         base::sink(type = "output", split = FALSE)
[17:39:55.909]         if (TRUE) {
[17:39:55.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.909]         }
[17:39:55.909]         else {
[17:39:55.909]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.909]         }
[17:39:55.909]         base::close(...future.stdout)
[17:39:55.909]         ...future.stdout <- NULL
[17:39:55.909]     }
[17:39:55.909]     ...future.result$conditions <- ...future.conditions
[17:39:55.909]     ...future.result$finished <- base::Sys.time()
[17:39:55.909]     ...future.result
[17:39:55.909] }
[17:39:55.911] plan(): Setting new future strategy stack:
[17:39:55.911] List of future strategies:
[17:39:55.911] 1. sequential:
[17:39:55.911]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.911]    - tweaked: FALSE
[17:39:55.911]    - call: NULL
[17:39:55.911] plan(): nbrOfWorkers() = 1
[17:39:55.912] plan(): Setting new future strategy stack:
[17:39:55.912] List of future strategies:
[17:39:55.912] 1. sequential:
[17:39:55.912]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.912]    - tweaked: FALSE
[17:39:55.912]    - call: plan(strategy)
[17:39:55.912] plan(): nbrOfWorkers() = 1
[17:39:55.913] SequentialFuture started (and completed)
[17:39:55.913] - Launch lazy future ... done
[17:39:55.913] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.913] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.913] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.915] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.915] Searching for globals ... DONE
[17:39:55.915] Resolving globals: TRUE
[17:39:55.915] Resolving any globals that are futures ...
[17:39:55.915] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.915] Resolving any globals that are futures ... DONE
[17:39:55.916] Resolving futures part of globals (recursively) ...
[17:39:55.916] resolve() on list ...
[17:39:55.916]  recursive: 99
[17:39:55.916]  length: 1
[17:39:55.916]  elements: ‘a’
[17:39:55.916] resolved() for ‘SequentialFuture’ ...
[17:39:55.916] - state: ‘finished’
[17:39:55.916] - run: TRUE
[17:39:55.917] - result: ‘FutureResult’
[17:39:55.917] resolved() for ‘SequentialFuture’ ... done
[17:39:55.917] Future #1
[17:39:55.917] resolved() for ‘SequentialFuture’ ...
[17:39:55.917] - state: ‘finished’
[17:39:55.917] - run: TRUE
[17:39:55.917] - result: ‘FutureResult’
[17:39:55.917] resolved() for ‘SequentialFuture’ ... done
[17:39:55.917] A SequentialFuture was resolved
[17:39:55.917]  length: 0 (resolved future 1)
[17:39:55.917] resolve() on list ... DONE
[17:39:55.918] - globals: [1] ‘a’
[17:39:55.918] Resolving futures part of globals (recursively) ... DONE
[17:39:55.919] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[17:39:55.920] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:39:55.920] - globals: [1] ‘a’
[17:39:55.920] - packages: [1] ‘future’
[17:39:55.920] getGlobalsAndPackages() ... DONE
[17:39:55.920] run() for ‘Future’ ...
[17:39:55.920] - state: ‘created’
[17:39:55.920] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.921] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.921]   - Field: ‘label’
[17:39:55.921]   - Field: ‘local’
[17:39:55.921]   - Field: ‘owner’
[17:39:55.921]   - Field: ‘envir’
[17:39:55.921]   - Field: ‘packages’
[17:39:55.921]   - Field: ‘gc’
[17:39:55.921]   - Field: ‘conditions’
[17:39:55.921]   - Field: ‘expr’
[17:39:55.922]   - Field: ‘uuid’
[17:39:55.922]   - Field: ‘seed’
[17:39:55.922]   - Field: ‘version’
[17:39:55.922]   - Field: ‘result’
[17:39:55.922]   - Field: ‘asynchronous’
[17:39:55.922]   - Field: ‘calls’
[17:39:55.922]   - Field: ‘globals’
[17:39:55.922]   - Field: ‘stdout’
[17:39:55.922]   - Field: ‘earlySignal’
[17:39:55.922]   - Field: ‘lazy’
[17:39:55.922]   - Field: ‘state’
[17:39:55.922] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.923] - Launch lazy future ...
[17:39:55.923] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.923] Packages needed by future strategies (n = 0): <none>
[17:39:55.923] {
[17:39:55.923]     {
[17:39:55.923]         {
[17:39:55.923]             ...future.startTime <- base::Sys.time()
[17:39:55.923]             {
[17:39:55.923]                 {
[17:39:55.923]                   {
[17:39:55.923]                     {
[17:39:55.923]                       base::local({
[17:39:55.923]                         has_future <- base::requireNamespace("future", 
[17:39:55.923]                           quietly = TRUE)
[17:39:55.923]                         if (has_future) {
[17:39:55.923]                           ns <- base::getNamespace("future")
[17:39:55.923]                           version <- ns[[".package"]][["version"]]
[17:39:55.923]                           if (is.null(version)) 
[17:39:55.923]                             version <- utils::packageVersion("future")
[17:39:55.923]                         }
[17:39:55.923]                         else {
[17:39:55.923]                           version <- NULL
[17:39:55.923]                         }
[17:39:55.923]                         if (!has_future || version < "1.8.0") {
[17:39:55.923]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.923]                             "", base::R.version$version.string), 
[17:39:55.923]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.923]                               "release", "version")], collapse = " "), 
[17:39:55.923]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.923]                             info)
[17:39:55.923]                           info <- base::paste(info, collapse = "; ")
[17:39:55.923]                           if (!has_future) {
[17:39:55.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.923]                               info)
[17:39:55.923]                           }
[17:39:55.923]                           else {
[17:39:55.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.923]                               info, version)
[17:39:55.923]                           }
[17:39:55.923]                           base::stop(msg)
[17:39:55.923]                         }
[17:39:55.923]                       })
[17:39:55.923]                     }
[17:39:55.923]                     base::local({
[17:39:55.923]                       for (pkg in "future") {
[17:39:55.923]                         base::loadNamespace(pkg)
[17:39:55.923]                         base::library(pkg, character.only = TRUE)
[17:39:55.923]                       }
[17:39:55.923]                     })
[17:39:55.923]                   }
[17:39:55.923]                   ...future.strategy.old <- future::plan("list")
[17:39:55.923]                   options(future.plan = NULL)
[17:39:55.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.923]                 }
[17:39:55.923]                 ...future.workdir <- getwd()
[17:39:55.923]             }
[17:39:55.923]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.923]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.923]         }
[17:39:55.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.923]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.923]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.923]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.923]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.923]             base::names(...future.oldOptions))
[17:39:55.923]     }
[17:39:55.923]     if (FALSE) {
[17:39:55.923]     }
[17:39:55.923]     else {
[17:39:55.923]         if (TRUE) {
[17:39:55.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.923]                 open = "w")
[17:39:55.923]         }
[17:39:55.923]         else {
[17:39:55.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.923]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.923]         }
[17:39:55.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.923]             base::sink(type = "output", split = FALSE)
[17:39:55.923]             base::close(...future.stdout)
[17:39:55.923]         }, add = TRUE)
[17:39:55.923]     }
[17:39:55.923]     ...future.frame <- base::sys.nframe()
[17:39:55.923]     ...future.conditions <- base::list()
[17:39:55.923]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.923]     if (FALSE) {
[17:39:55.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.923]     }
[17:39:55.923]     ...future.result <- base::tryCatch({
[17:39:55.923]         base::withCallingHandlers({
[17:39:55.923]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.923]                 1))
[17:39:55.923]             future::FutureResult(value = ...future.value$value, 
[17:39:55.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.923]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.923]                     ...future.globalenv.names))
[17:39:55.923]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.923]         }, condition = base::local({
[17:39:55.923]             c <- base::c
[17:39:55.923]             inherits <- base::inherits
[17:39:55.923]             invokeRestart <- base::invokeRestart
[17:39:55.923]             length <- base::length
[17:39:55.923]             list <- base::list
[17:39:55.923]             seq.int <- base::seq.int
[17:39:55.923]             signalCondition <- base::signalCondition
[17:39:55.923]             sys.calls <- base::sys.calls
[17:39:55.923]             `[[` <- base::`[[`
[17:39:55.923]             `+` <- base::`+`
[17:39:55.923]             `<<-` <- base::`<<-`
[17:39:55.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.923]                   3L)]
[17:39:55.923]             }
[17:39:55.923]             function(cond) {
[17:39:55.923]                 is_error <- inherits(cond, "error")
[17:39:55.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.923]                   NULL)
[17:39:55.923]                 if (is_error) {
[17:39:55.923]                   sessionInformation <- function() {
[17:39:55.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.923]                       search = base::search(), system = base::Sys.info())
[17:39:55.923]                   }
[17:39:55.923]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.923]                     cond$call), session = sessionInformation(), 
[17:39:55.923]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.923]                   signalCondition(cond)
[17:39:55.923]                 }
[17:39:55.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.923]                 "immediateCondition"))) {
[17:39:55.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.923]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.923]                   if (TRUE && !signal) {
[17:39:55.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.923]                     {
[17:39:55.923]                       inherits <- base::inherits
[17:39:55.923]                       invokeRestart <- base::invokeRestart
[17:39:55.923]                       is.null <- base::is.null
[17:39:55.923]                       muffled <- FALSE
[17:39:55.923]                       if (inherits(cond, "message")) {
[17:39:55.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.923]                         if (muffled) 
[17:39:55.923]                           invokeRestart("muffleMessage")
[17:39:55.923]                       }
[17:39:55.923]                       else if (inherits(cond, "warning")) {
[17:39:55.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.923]                         if (muffled) 
[17:39:55.923]                           invokeRestart("muffleWarning")
[17:39:55.923]                       }
[17:39:55.923]                       else if (inherits(cond, "condition")) {
[17:39:55.923]                         if (!is.null(pattern)) {
[17:39:55.923]                           computeRestarts <- base::computeRestarts
[17:39:55.923]                           grepl <- base::grepl
[17:39:55.923]                           restarts <- computeRestarts(cond)
[17:39:55.923]                           for (restart in restarts) {
[17:39:55.923]                             name <- restart$name
[17:39:55.923]                             if (is.null(name)) 
[17:39:55.923]                               next
[17:39:55.923]                             if (!grepl(pattern, name)) 
[17:39:55.923]                               next
[17:39:55.923]                             invokeRestart(restart)
[17:39:55.923]                             muffled <- TRUE
[17:39:55.923]                             break
[17:39:55.923]                           }
[17:39:55.923]                         }
[17:39:55.923]                       }
[17:39:55.923]                       invisible(muffled)
[17:39:55.923]                     }
[17:39:55.923]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.923]                   }
[17:39:55.923]                 }
[17:39:55.923]                 else {
[17:39:55.923]                   if (TRUE) {
[17:39:55.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.923]                     {
[17:39:55.923]                       inherits <- base::inherits
[17:39:55.923]                       invokeRestart <- base::invokeRestart
[17:39:55.923]                       is.null <- base::is.null
[17:39:55.923]                       muffled <- FALSE
[17:39:55.923]                       if (inherits(cond, "message")) {
[17:39:55.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.923]                         if (muffled) 
[17:39:55.923]                           invokeRestart("muffleMessage")
[17:39:55.923]                       }
[17:39:55.923]                       else if (inherits(cond, "warning")) {
[17:39:55.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.923]                         if (muffled) 
[17:39:55.923]                           invokeRestart("muffleWarning")
[17:39:55.923]                       }
[17:39:55.923]                       else if (inherits(cond, "condition")) {
[17:39:55.923]                         if (!is.null(pattern)) {
[17:39:55.923]                           computeRestarts <- base::computeRestarts
[17:39:55.923]                           grepl <- base::grepl
[17:39:55.923]                           restarts <- computeRestarts(cond)
[17:39:55.923]                           for (restart in restarts) {
[17:39:55.923]                             name <- restart$name
[17:39:55.923]                             if (is.null(name)) 
[17:39:55.923]                               next
[17:39:55.923]                             if (!grepl(pattern, name)) 
[17:39:55.923]                               next
[17:39:55.923]                             invokeRestart(restart)
[17:39:55.923]                             muffled <- TRUE
[17:39:55.923]                             break
[17:39:55.923]                           }
[17:39:55.923]                         }
[17:39:55.923]                       }
[17:39:55.923]                       invisible(muffled)
[17:39:55.923]                     }
[17:39:55.923]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.923]                   }
[17:39:55.923]                 }
[17:39:55.923]             }
[17:39:55.923]         }))
[17:39:55.923]     }, error = function(ex) {
[17:39:55.923]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.923]                 ...future.rng), started = ...future.startTime, 
[17:39:55.923]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.923]             version = "1.8"), class = "FutureResult")
[17:39:55.923]     }, finally = {
[17:39:55.923]         if (!identical(...future.workdir, getwd())) 
[17:39:55.923]             setwd(...future.workdir)
[17:39:55.923]         {
[17:39:55.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.923]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.923]             }
[17:39:55.923]             base::options(...future.oldOptions)
[17:39:55.923]             if (.Platform$OS.type == "windows") {
[17:39:55.923]                 old_names <- names(...future.oldEnvVars)
[17:39:55.923]                 envs <- base::Sys.getenv()
[17:39:55.923]                 names <- names(envs)
[17:39:55.923]                 common <- intersect(names, old_names)
[17:39:55.923]                 added <- setdiff(names, old_names)
[17:39:55.923]                 removed <- setdiff(old_names, names)
[17:39:55.923]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.923]                   envs[common]]
[17:39:55.923]                 NAMES <- toupper(changed)
[17:39:55.923]                 args <- list()
[17:39:55.923]                 for (kk in seq_along(NAMES)) {
[17:39:55.923]                   name <- changed[[kk]]
[17:39:55.923]                   NAME <- NAMES[[kk]]
[17:39:55.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.923]                     next
[17:39:55.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.923]                 }
[17:39:55.923]                 NAMES <- toupper(added)
[17:39:55.923]                 for (kk in seq_along(NAMES)) {
[17:39:55.923]                   name <- added[[kk]]
[17:39:55.923]                   NAME <- NAMES[[kk]]
[17:39:55.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.923]                     next
[17:39:55.923]                   args[[name]] <- ""
[17:39:55.923]                 }
[17:39:55.923]                 NAMES <- toupper(removed)
[17:39:55.923]                 for (kk in seq_along(NAMES)) {
[17:39:55.923]                   name <- removed[[kk]]
[17:39:55.923]                   NAME <- NAMES[[kk]]
[17:39:55.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.923]                     next
[17:39:55.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.923]                 }
[17:39:55.923]                 if (length(args) > 0) 
[17:39:55.923]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.923]             }
[17:39:55.923]             else {
[17:39:55.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.923]             }
[17:39:55.923]             {
[17:39:55.923]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.923]                   0L) {
[17:39:55.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.923]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.923]                   base::options(opts)
[17:39:55.923]                 }
[17:39:55.923]                 {
[17:39:55.923]                   {
[17:39:55.923]                     NULL
[17:39:55.923]                     RNGkind("Mersenne-Twister")
[17:39:55.923]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.923]                       inherits = FALSE)
[17:39:55.923]                   }
[17:39:55.923]                   options(future.plan = NULL)
[17:39:55.923]                   if (is.na(NA_character_)) 
[17:39:55.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.923]                     .init = FALSE)
[17:39:55.923]                 }
[17:39:55.923]             }
[17:39:55.923]         }
[17:39:55.923]     })
[17:39:55.923]     if (TRUE) {
[17:39:55.923]         base::sink(type = "output", split = FALSE)
[17:39:55.923]         if (TRUE) {
[17:39:55.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.923]         }
[17:39:55.923]         else {
[17:39:55.923]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.923]         }
[17:39:55.923]         base::close(...future.stdout)
[17:39:55.923]         ...future.stdout <- NULL
[17:39:55.923]     }
[17:39:55.923]     ...future.result$conditions <- ...future.conditions
[17:39:55.923]     ...future.result$finished <- base::Sys.time()
[17:39:55.923]     ...future.result
[17:39:55.923] }
[17:39:55.925] assign_globals() ...
[17:39:55.925] List of 1
[17:39:55.925]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd84409a8> 
[17:39:55.925]  - attr(*, "where")=List of 1
[17:39:55.925]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.925]  - attr(*, "resolved")= logi TRUE
[17:39:55.925]  - attr(*, "total_size")= num 1622272
[17:39:55.925]  - attr(*, "already-done")= logi TRUE
[17:39:55.927] - copied ‘a’ to environment
[17:39:55.927] assign_globals() ... done
[17:39:55.927] plan(): Setting new future strategy stack:
[17:39:55.928] List of future strategies:
[17:39:55.928] 1. sequential:
[17:39:55.928]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.928]    - tweaked: FALSE
[17:39:55.928]    - call: NULL
[17:39:55.928] plan(): nbrOfWorkers() = 1
[17:39:55.929] plan(): Setting new future strategy stack:
[17:39:55.929] List of future strategies:
[17:39:55.929] 1. sequential:
[17:39:55.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.929]    - tweaked: FALSE
[17:39:55.929]    - call: plan(strategy)
[17:39:55.929] plan(): nbrOfWorkers() = 1
[17:39:55.929] SequentialFuture started (and completed)
[17:39:55.930] - Launch lazy future ... done
[17:39:55.930] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.930] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.930] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.931] 
[17:39:55.931] Searching for globals ... DONE
[17:39:55.931] - globals: [0] <none>
[17:39:55.931] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.931] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.931] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.932] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.932] Searching for globals ... DONE
[17:39:55.932] Resolving globals: TRUE
[17:39:55.932] Resolving any globals that are futures ...
[17:39:55.932] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.932] Resolving any globals that are futures ... DONE
[17:39:55.933] Resolving futures part of globals (recursively) ...
[17:39:55.933] resolve() on list ...
[17:39:55.933]  recursive: 99
[17:39:55.933]  length: 1
[17:39:55.933]  elements: ‘a’
[17:39:55.933] run() for ‘Future’ ...
[17:39:55.933] - state: ‘created’
[17:39:55.934] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.934] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.934]   - Field: ‘label’
[17:39:55.934]   - Field: ‘local’
[17:39:55.934]   - Field: ‘owner’
[17:39:55.934]   - Field: ‘envir’
[17:39:55.934]   - Field: ‘packages’
[17:39:55.934]   - Field: ‘gc’
[17:39:55.934]   - Field: ‘conditions’
[17:39:55.935]   - Field: ‘expr’
[17:39:55.935]   - Field: ‘uuid’
[17:39:55.935]   - Field: ‘seed’
[17:39:55.935]   - Field: ‘version’
[17:39:55.935]   - Field: ‘result’
[17:39:55.935]   - Field: ‘asynchronous’
[17:39:55.935]   - Field: ‘calls’
[17:39:55.935]   - Field: ‘globals’
[17:39:55.935]   - Field: ‘stdout’
[17:39:55.935]   - Field: ‘earlySignal’
[17:39:55.935]   - Field: ‘lazy’
[17:39:55.935]   - Field: ‘state’
[17:39:55.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.936] - Launch lazy future ...
[17:39:55.936] Packages needed by the future expression (n = 0): <none>
[17:39:55.936] Packages needed by future strategies (n = 0): <none>
[17:39:55.936] {
[17:39:55.936]     {
[17:39:55.936]         {
[17:39:55.936]             ...future.startTime <- base::Sys.time()
[17:39:55.936]             {
[17:39:55.936]                 {
[17:39:55.936]                   {
[17:39:55.936]                     base::local({
[17:39:55.936]                       has_future <- base::requireNamespace("future", 
[17:39:55.936]                         quietly = TRUE)
[17:39:55.936]                       if (has_future) {
[17:39:55.936]                         ns <- base::getNamespace("future")
[17:39:55.936]                         version <- ns[[".package"]][["version"]]
[17:39:55.936]                         if (is.null(version)) 
[17:39:55.936]                           version <- utils::packageVersion("future")
[17:39:55.936]                       }
[17:39:55.936]                       else {
[17:39:55.936]                         version <- NULL
[17:39:55.936]                       }
[17:39:55.936]                       if (!has_future || version < "1.8.0") {
[17:39:55.936]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.936]                           "", base::R.version$version.string), 
[17:39:55.936]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.936]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.936]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.936]                             "release", "version")], collapse = " "), 
[17:39:55.936]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.936]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.936]                           info)
[17:39:55.936]                         info <- base::paste(info, collapse = "; ")
[17:39:55.936]                         if (!has_future) {
[17:39:55.936]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.936]                             info)
[17:39:55.936]                         }
[17:39:55.936]                         else {
[17:39:55.936]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.936]                             info, version)
[17:39:55.936]                         }
[17:39:55.936]                         base::stop(msg)
[17:39:55.936]                       }
[17:39:55.936]                     })
[17:39:55.936]                   }
[17:39:55.936]                   ...future.strategy.old <- future::plan("list")
[17:39:55.936]                   options(future.plan = NULL)
[17:39:55.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.936]                 }
[17:39:55.936]                 ...future.workdir <- getwd()
[17:39:55.936]             }
[17:39:55.936]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.936]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.936]         }
[17:39:55.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.936]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.936]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.936]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.936]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.936]             base::names(...future.oldOptions))
[17:39:55.936]     }
[17:39:55.936]     if (FALSE) {
[17:39:55.936]     }
[17:39:55.936]     else {
[17:39:55.936]         if (TRUE) {
[17:39:55.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.936]                 open = "w")
[17:39:55.936]         }
[17:39:55.936]         else {
[17:39:55.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.936]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.936]         }
[17:39:55.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.936]             base::sink(type = "output", split = FALSE)
[17:39:55.936]             base::close(...future.stdout)
[17:39:55.936]         }, add = TRUE)
[17:39:55.936]     }
[17:39:55.936]     ...future.frame <- base::sys.nframe()
[17:39:55.936]     ...future.conditions <- base::list()
[17:39:55.936]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.936]     if (FALSE) {
[17:39:55.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.936]     }
[17:39:55.936]     ...future.result <- base::tryCatch({
[17:39:55.936]         base::withCallingHandlers({
[17:39:55.936]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.936]             future::FutureResult(value = ...future.value$value, 
[17:39:55.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.936]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.936]                     ...future.globalenv.names))
[17:39:55.936]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.936]         }, condition = base::local({
[17:39:55.936]             c <- base::c
[17:39:55.936]             inherits <- base::inherits
[17:39:55.936]             invokeRestart <- base::invokeRestart
[17:39:55.936]             length <- base::length
[17:39:55.936]             list <- base::list
[17:39:55.936]             seq.int <- base::seq.int
[17:39:55.936]             signalCondition <- base::signalCondition
[17:39:55.936]             sys.calls <- base::sys.calls
[17:39:55.936]             `[[` <- base::`[[`
[17:39:55.936]             `+` <- base::`+`
[17:39:55.936]             `<<-` <- base::`<<-`
[17:39:55.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.936]                   3L)]
[17:39:55.936]             }
[17:39:55.936]             function(cond) {
[17:39:55.936]                 is_error <- inherits(cond, "error")
[17:39:55.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.936]                   NULL)
[17:39:55.936]                 if (is_error) {
[17:39:55.936]                   sessionInformation <- function() {
[17:39:55.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.936]                       search = base::search(), system = base::Sys.info())
[17:39:55.936]                   }
[17:39:55.936]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.936]                     cond$call), session = sessionInformation(), 
[17:39:55.936]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.936]                   signalCondition(cond)
[17:39:55.936]                 }
[17:39:55.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.936]                 "immediateCondition"))) {
[17:39:55.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.936]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.936]                   if (TRUE && !signal) {
[17:39:55.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.936]                     {
[17:39:55.936]                       inherits <- base::inherits
[17:39:55.936]                       invokeRestart <- base::invokeRestart
[17:39:55.936]                       is.null <- base::is.null
[17:39:55.936]                       muffled <- FALSE
[17:39:55.936]                       if (inherits(cond, "message")) {
[17:39:55.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.936]                         if (muffled) 
[17:39:55.936]                           invokeRestart("muffleMessage")
[17:39:55.936]                       }
[17:39:55.936]                       else if (inherits(cond, "warning")) {
[17:39:55.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.936]                         if (muffled) 
[17:39:55.936]                           invokeRestart("muffleWarning")
[17:39:55.936]                       }
[17:39:55.936]                       else if (inherits(cond, "condition")) {
[17:39:55.936]                         if (!is.null(pattern)) {
[17:39:55.936]                           computeRestarts <- base::computeRestarts
[17:39:55.936]                           grepl <- base::grepl
[17:39:55.936]                           restarts <- computeRestarts(cond)
[17:39:55.936]                           for (restart in restarts) {
[17:39:55.936]                             name <- restart$name
[17:39:55.936]                             if (is.null(name)) 
[17:39:55.936]                               next
[17:39:55.936]                             if (!grepl(pattern, name)) 
[17:39:55.936]                               next
[17:39:55.936]                             invokeRestart(restart)
[17:39:55.936]                             muffled <- TRUE
[17:39:55.936]                             break
[17:39:55.936]                           }
[17:39:55.936]                         }
[17:39:55.936]                       }
[17:39:55.936]                       invisible(muffled)
[17:39:55.936]                     }
[17:39:55.936]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.936]                   }
[17:39:55.936]                 }
[17:39:55.936]                 else {
[17:39:55.936]                   if (TRUE) {
[17:39:55.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.936]                     {
[17:39:55.936]                       inherits <- base::inherits
[17:39:55.936]                       invokeRestart <- base::invokeRestart
[17:39:55.936]                       is.null <- base::is.null
[17:39:55.936]                       muffled <- FALSE
[17:39:55.936]                       if (inherits(cond, "message")) {
[17:39:55.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.936]                         if (muffled) 
[17:39:55.936]                           invokeRestart("muffleMessage")
[17:39:55.936]                       }
[17:39:55.936]                       else if (inherits(cond, "warning")) {
[17:39:55.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.936]                         if (muffled) 
[17:39:55.936]                           invokeRestart("muffleWarning")
[17:39:55.936]                       }
[17:39:55.936]                       else if (inherits(cond, "condition")) {
[17:39:55.936]                         if (!is.null(pattern)) {
[17:39:55.936]                           computeRestarts <- base::computeRestarts
[17:39:55.936]                           grepl <- base::grepl
[17:39:55.936]                           restarts <- computeRestarts(cond)
[17:39:55.936]                           for (restart in restarts) {
[17:39:55.936]                             name <- restart$name
[17:39:55.936]                             if (is.null(name)) 
[17:39:55.936]                               next
[17:39:55.936]                             if (!grepl(pattern, name)) 
[17:39:55.936]                               next
[17:39:55.936]                             invokeRestart(restart)
[17:39:55.936]                             muffled <- TRUE
[17:39:55.936]                             break
[17:39:55.936]                           }
[17:39:55.936]                         }
[17:39:55.936]                       }
[17:39:55.936]                       invisible(muffled)
[17:39:55.936]                     }
[17:39:55.936]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.936]                   }
[17:39:55.936]                 }
[17:39:55.936]             }
[17:39:55.936]         }))
[17:39:55.936]     }, error = function(ex) {
[17:39:55.936]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.936]                 ...future.rng), started = ...future.startTime, 
[17:39:55.936]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.936]             version = "1.8"), class = "FutureResult")
[17:39:55.936]     }, finally = {
[17:39:55.936]         if (!identical(...future.workdir, getwd())) 
[17:39:55.936]             setwd(...future.workdir)
[17:39:55.936]         {
[17:39:55.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.936]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.936]             }
[17:39:55.936]             base::options(...future.oldOptions)
[17:39:55.936]             if (.Platform$OS.type == "windows") {
[17:39:55.936]                 old_names <- names(...future.oldEnvVars)
[17:39:55.936]                 envs <- base::Sys.getenv()
[17:39:55.936]                 names <- names(envs)
[17:39:55.936]                 common <- intersect(names, old_names)
[17:39:55.936]                 added <- setdiff(names, old_names)
[17:39:55.936]                 removed <- setdiff(old_names, names)
[17:39:55.936]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.936]                   envs[common]]
[17:39:55.936]                 NAMES <- toupper(changed)
[17:39:55.936]                 args <- list()
[17:39:55.936]                 for (kk in seq_along(NAMES)) {
[17:39:55.936]                   name <- changed[[kk]]
[17:39:55.936]                   NAME <- NAMES[[kk]]
[17:39:55.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.936]                     next
[17:39:55.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.936]                 }
[17:39:55.936]                 NAMES <- toupper(added)
[17:39:55.936]                 for (kk in seq_along(NAMES)) {
[17:39:55.936]                   name <- added[[kk]]
[17:39:55.936]                   NAME <- NAMES[[kk]]
[17:39:55.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.936]                     next
[17:39:55.936]                   args[[name]] <- ""
[17:39:55.936]                 }
[17:39:55.936]                 NAMES <- toupper(removed)
[17:39:55.936]                 for (kk in seq_along(NAMES)) {
[17:39:55.936]                   name <- removed[[kk]]
[17:39:55.936]                   NAME <- NAMES[[kk]]
[17:39:55.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.936]                     next
[17:39:55.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.936]                 }
[17:39:55.936]                 if (length(args) > 0) 
[17:39:55.936]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.936]             }
[17:39:55.936]             else {
[17:39:55.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.936]             }
[17:39:55.936]             {
[17:39:55.936]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.936]                   0L) {
[17:39:55.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.936]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.936]                   base::options(opts)
[17:39:55.936]                 }
[17:39:55.936]                 {
[17:39:55.936]                   {
[17:39:55.936]                     NULL
[17:39:55.936]                     RNGkind("Mersenne-Twister")
[17:39:55.936]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.936]                       inherits = FALSE)
[17:39:55.936]                   }
[17:39:55.936]                   options(future.plan = NULL)
[17:39:55.936]                   if (is.na(NA_character_)) 
[17:39:55.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.936]                     .init = FALSE)
[17:39:55.936]                 }
[17:39:55.936]             }
[17:39:55.936]         }
[17:39:55.936]     })
[17:39:55.936]     if (TRUE) {
[17:39:55.936]         base::sink(type = "output", split = FALSE)
[17:39:55.936]         if (TRUE) {
[17:39:55.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.936]         }
[17:39:55.936]         else {
[17:39:55.936]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.936]         }
[17:39:55.936]         base::close(...future.stdout)
[17:39:55.936]         ...future.stdout <- NULL
[17:39:55.936]     }
[17:39:55.936]     ...future.result$conditions <- ...future.conditions
[17:39:55.936]     ...future.result$finished <- base::Sys.time()
[17:39:55.936]     ...future.result
[17:39:55.936] }
[17:39:55.963] plan(): Setting new future strategy stack:
[17:39:55.964] List of future strategies:
[17:39:55.964] 1. sequential:
[17:39:55.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.964]    - tweaked: FALSE
[17:39:55.964]    - call: NULL
[17:39:55.964] plan(): nbrOfWorkers() = 1
[17:39:55.965] plan(): Setting new future strategy stack:
[17:39:55.965] List of future strategies:
[17:39:55.965] 1. sequential:
[17:39:55.965]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.965]    - tweaked: FALSE
[17:39:55.965]    - call: plan(strategy)
[17:39:55.966] plan(): nbrOfWorkers() = 1
[17:39:55.966] SequentialFuture started (and completed)
[17:39:55.966] - Launch lazy future ... done
[17:39:55.966] run() for ‘SequentialFuture’ ... done
[17:39:55.966] resolved() for ‘SequentialFuture’ ...
[17:39:55.966] - state: ‘finished’
[17:39:55.966] - run: TRUE
[17:39:55.966] - result: ‘FutureResult’
[17:39:55.966] resolved() for ‘SequentialFuture’ ... done
[17:39:55.966] Future #1
[17:39:55.967] resolved() for ‘SequentialFuture’ ...
[17:39:55.967] - state: ‘finished’
[17:39:55.967] - run: TRUE
[17:39:55.967] - result: ‘FutureResult’
[17:39:55.967] resolved() for ‘SequentialFuture’ ... done
[17:39:55.967] A SequentialFuture was resolved
[17:39:55.967]  length: 0 (resolved future 1)
[17:39:55.967] resolve() on list ... DONE
[17:39:55.967] - globals: [1] ‘a’
[17:39:55.967] Resolving futures part of globals (recursively) ... DONE
[17:39:55.969] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[17:39:55.970] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:39:55.970] - globals: [1] ‘a’
[17:39:55.970] - packages: [1] ‘future’
[17:39:55.970] getGlobalsAndPackages() ... DONE
[17:39:55.970] run() for ‘Future’ ...
[17:39:55.970] - state: ‘created’
[17:39:55.970] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.971]   - Field: ‘label’
[17:39:55.971]   - Field: ‘local’
[17:39:55.971]   - Field: ‘owner’
[17:39:55.971]   - Field: ‘envir’
[17:39:55.971]   - Field: ‘packages’
[17:39:55.971]   - Field: ‘gc’
[17:39:55.971]   - Field: ‘conditions’
[17:39:55.971]   - Field: ‘expr’
[17:39:55.971]   - Field: ‘uuid’
[17:39:55.972]   - Field: ‘seed’
[17:39:55.972]   - Field: ‘version’
[17:39:55.972]   - Field: ‘result’
[17:39:55.972]   - Field: ‘asynchronous’
[17:39:55.972]   - Field: ‘calls’
[17:39:55.972]   - Field: ‘globals’
[17:39:55.972]   - Field: ‘stdout’
[17:39:55.972]   - Field: ‘earlySignal’
[17:39:55.972]   - Field: ‘lazy’
[17:39:55.972]   - Field: ‘state’
[17:39:55.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.973] - Launch lazy future ...
[17:39:55.973] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.973] Packages needed by future strategies (n = 0): <none>
[17:39:55.973] {
[17:39:55.973]     {
[17:39:55.973]         {
[17:39:55.973]             ...future.startTime <- base::Sys.time()
[17:39:55.973]             {
[17:39:55.973]                 {
[17:39:55.973]                   {
[17:39:55.973]                     {
[17:39:55.973]                       base::local({
[17:39:55.973]                         has_future <- base::requireNamespace("future", 
[17:39:55.973]                           quietly = TRUE)
[17:39:55.973]                         if (has_future) {
[17:39:55.973]                           ns <- base::getNamespace("future")
[17:39:55.973]                           version <- ns[[".package"]][["version"]]
[17:39:55.973]                           if (is.null(version)) 
[17:39:55.973]                             version <- utils::packageVersion("future")
[17:39:55.973]                         }
[17:39:55.973]                         else {
[17:39:55.973]                           version <- NULL
[17:39:55.973]                         }
[17:39:55.973]                         if (!has_future || version < "1.8.0") {
[17:39:55.973]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.973]                             "", base::R.version$version.string), 
[17:39:55.973]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.973]                               "release", "version")], collapse = " "), 
[17:39:55.973]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.973]                             info)
[17:39:55.973]                           info <- base::paste(info, collapse = "; ")
[17:39:55.973]                           if (!has_future) {
[17:39:55.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.973]                               info)
[17:39:55.973]                           }
[17:39:55.973]                           else {
[17:39:55.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.973]                               info, version)
[17:39:55.973]                           }
[17:39:55.973]                           base::stop(msg)
[17:39:55.973]                         }
[17:39:55.973]                       })
[17:39:55.973]                     }
[17:39:55.973]                     base::local({
[17:39:55.973]                       for (pkg in "future") {
[17:39:55.973]                         base::loadNamespace(pkg)
[17:39:55.973]                         base::library(pkg, character.only = TRUE)
[17:39:55.973]                       }
[17:39:55.973]                     })
[17:39:55.973]                   }
[17:39:55.973]                   ...future.strategy.old <- future::plan("list")
[17:39:55.973]                   options(future.plan = NULL)
[17:39:55.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.973]                 }
[17:39:55.973]                 ...future.workdir <- getwd()
[17:39:55.973]             }
[17:39:55.973]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.973]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.973]         }
[17:39:55.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.973]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.973]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.973]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.973]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.973]             base::names(...future.oldOptions))
[17:39:55.973]     }
[17:39:55.973]     if (FALSE) {
[17:39:55.973]     }
[17:39:55.973]     else {
[17:39:55.973]         if (TRUE) {
[17:39:55.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.973]                 open = "w")
[17:39:55.973]         }
[17:39:55.973]         else {
[17:39:55.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.973]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.973]         }
[17:39:55.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.973]             base::sink(type = "output", split = FALSE)
[17:39:55.973]             base::close(...future.stdout)
[17:39:55.973]         }, add = TRUE)
[17:39:55.973]     }
[17:39:55.973]     ...future.frame <- base::sys.nframe()
[17:39:55.973]     ...future.conditions <- base::list()
[17:39:55.973]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.973]     if (FALSE) {
[17:39:55.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.973]     }
[17:39:55.973]     ...future.result <- base::tryCatch({
[17:39:55.973]         base::withCallingHandlers({
[17:39:55.973]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.973]                 1))
[17:39:55.973]             future::FutureResult(value = ...future.value$value, 
[17:39:55.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.973]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.973]                     ...future.globalenv.names))
[17:39:55.973]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.973]         }, condition = base::local({
[17:39:55.973]             c <- base::c
[17:39:55.973]             inherits <- base::inherits
[17:39:55.973]             invokeRestart <- base::invokeRestart
[17:39:55.973]             length <- base::length
[17:39:55.973]             list <- base::list
[17:39:55.973]             seq.int <- base::seq.int
[17:39:55.973]             signalCondition <- base::signalCondition
[17:39:55.973]             sys.calls <- base::sys.calls
[17:39:55.973]             `[[` <- base::`[[`
[17:39:55.973]             `+` <- base::`+`
[17:39:55.973]             `<<-` <- base::`<<-`
[17:39:55.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.973]                   3L)]
[17:39:55.973]             }
[17:39:55.973]             function(cond) {
[17:39:55.973]                 is_error <- inherits(cond, "error")
[17:39:55.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.973]                   NULL)
[17:39:55.973]                 if (is_error) {
[17:39:55.973]                   sessionInformation <- function() {
[17:39:55.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.973]                       search = base::search(), system = base::Sys.info())
[17:39:55.973]                   }
[17:39:55.973]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.973]                     cond$call), session = sessionInformation(), 
[17:39:55.973]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.973]                   signalCondition(cond)
[17:39:55.973]                 }
[17:39:55.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.973]                 "immediateCondition"))) {
[17:39:55.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.973]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.973]                   if (TRUE && !signal) {
[17:39:55.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.973]                     {
[17:39:55.973]                       inherits <- base::inherits
[17:39:55.973]                       invokeRestart <- base::invokeRestart
[17:39:55.973]                       is.null <- base::is.null
[17:39:55.973]                       muffled <- FALSE
[17:39:55.973]                       if (inherits(cond, "message")) {
[17:39:55.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.973]                         if (muffled) 
[17:39:55.973]                           invokeRestart("muffleMessage")
[17:39:55.973]                       }
[17:39:55.973]                       else if (inherits(cond, "warning")) {
[17:39:55.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.973]                         if (muffled) 
[17:39:55.973]                           invokeRestart("muffleWarning")
[17:39:55.973]                       }
[17:39:55.973]                       else if (inherits(cond, "condition")) {
[17:39:55.973]                         if (!is.null(pattern)) {
[17:39:55.973]                           computeRestarts <- base::computeRestarts
[17:39:55.973]                           grepl <- base::grepl
[17:39:55.973]                           restarts <- computeRestarts(cond)
[17:39:55.973]                           for (restart in restarts) {
[17:39:55.973]                             name <- restart$name
[17:39:55.973]                             if (is.null(name)) 
[17:39:55.973]                               next
[17:39:55.973]                             if (!grepl(pattern, name)) 
[17:39:55.973]                               next
[17:39:55.973]                             invokeRestart(restart)
[17:39:55.973]                             muffled <- TRUE
[17:39:55.973]                             break
[17:39:55.973]                           }
[17:39:55.973]                         }
[17:39:55.973]                       }
[17:39:55.973]                       invisible(muffled)
[17:39:55.973]                     }
[17:39:55.973]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.973]                   }
[17:39:55.973]                 }
[17:39:55.973]                 else {
[17:39:55.973]                   if (TRUE) {
[17:39:55.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.973]                     {
[17:39:55.973]                       inherits <- base::inherits
[17:39:55.973]                       invokeRestart <- base::invokeRestart
[17:39:55.973]                       is.null <- base::is.null
[17:39:55.973]                       muffled <- FALSE
[17:39:55.973]                       if (inherits(cond, "message")) {
[17:39:55.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.973]                         if (muffled) 
[17:39:55.973]                           invokeRestart("muffleMessage")
[17:39:55.973]                       }
[17:39:55.973]                       else if (inherits(cond, "warning")) {
[17:39:55.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.973]                         if (muffled) 
[17:39:55.973]                           invokeRestart("muffleWarning")
[17:39:55.973]                       }
[17:39:55.973]                       else if (inherits(cond, "condition")) {
[17:39:55.973]                         if (!is.null(pattern)) {
[17:39:55.973]                           computeRestarts <- base::computeRestarts
[17:39:55.973]                           grepl <- base::grepl
[17:39:55.973]                           restarts <- computeRestarts(cond)
[17:39:55.973]                           for (restart in restarts) {
[17:39:55.973]                             name <- restart$name
[17:39:55.973]                             if (is.null(name)) 
[17:39:55.973]                               next
[17:39:55.973]                             if (!grepl(pattern, name)) 
[17:39:55.973]                               next
[17:39:55.973]                             invokeRestart(restart)
[17:39:55.973]                             muffled <- TRUE
[17:39:55.973]                             break
[17:39:55.973]                           }
[17:39:55.973]                         }
[17:39:55.973]                       }
[17:39:55.973]                       invisible(muffled)
[17:39:55.973]                     }
[17:39:55.973]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.973]                   }
[17:39:55.973]                 }
[17:39:55.973]             }
[17:39:55.973]         }))
[17:39:55.973]     }, error = function(ex) {
[17:39:55.973]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.973]                 ...future.rng), started = ...future.startTime, 
[17:39:55.973]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.973]             version = "1.8"), class = "FutureResult")
[17:39:55.973]     }, finally = {
[17:39:55.973]         if (!identical(...future.workdir, getwd())) 
[17:39:55.973]             setwd(...future.workdir)
[17:39:55.973]         {
[17:39:55.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.973]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.973]             }
[17:39:55.973]             base::options(...future.oldOptions)
[17:39:55.973]             if (.Platform$OS.type == "windows") {
[17:39:55.973]                 old_names <- names(...future.oldEnvVars)
[17:39:55.973]                 envs <- base::Sys.getenv()
[17:39:55.973]                 names <- names(envs)
[17:39:55.973]                 common <- intersect(names, old_names)
[17:39:55.973]                 added <- setdiff(names, old_names)
[17:39:55.973]                 removed <- setdiff(old_names, names)
[17:39:55.973]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.973]                   envs[common]]
[17:39:55.973]                 NAMES <- toupper(changed)
[17:39:55.973]                 args <- list()
[17:39:55.973]                 for (kk in seq_along(NAMES)) {
[17:39:55.973]                   name <- changed[[kk]]
[17:39:55.973]                   NAME <- NAMES[[kk]]
[17:39:55.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.973]                     next
[17:39:55.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.973]                 }
[17:39:55.973]                 NAMES <- toupper(added)
[17:39:55.973]                 for (kk in seq_along(NAMES)) {
[17:39:55.973]                   name <- added[[kk]]
[17:39:55.973]                   NAME <- NAMES[[kk]]
[17:39:55.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.973]                     next
[17:39:55.973]                   args[[name]] <- ""
[17:39:55.973]                 }
[17:39:55.973]                 NAMES <- toupper(removed)
[17:39:55.973]                 for (kk in seq_along(NAMES)) {
[17:39:55.973]                   name <- removed[[kk]]
[17:39:55.973]                   NAME <- NAMES[[kk]]
[17:39:55.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.973]                     next
[17:39:55.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.973]                 }
[17:39:55.973]                 if (length(args) > 0) 
[17:39:55.973]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.973]             }
[17:39:55.973]             else {
[17:39:55.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.973]             }
[17:39:55.973]             {
[17:39:55.973]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.973]                   0L) {
[17:39:55.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.973]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.973]                   base::options(opts)
[17:39:55.973]                 }
[17:39:55.973]                 {
[17:39:55.973]                   {
[17:39:55.973]                     NULL
[17:39:55.973]                     RNGkind("Mersenne-Twister")
[17:39:55.973]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.973]                       inherits = FALSE)
[17:39:55.973]                   }
[17:39:55.973]                   options(future.plan = NULL)
[17:39:55.973]                   if (is.na(NA_character_)) 
[17:39:55.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.973]                     .init = FALSE)
[17:39:55.973]                 }
[17:39:55.973]             }
[17:39:55.973]         }
[17:39:55.973]     })
[17:39:55.973]     if (TRUE) {
[17:39:55.973]         base::sink(type = "output", split = FALSE)
[17:39:55.973]         if (TRUE) {
[17:39:55.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.973]         }
[17:39:55.973]         else {
[17:39:55.973]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.973]         }
[17:39:55.973]         base::close(...future.stdout)
[17:39:55.973]         ...future.stdout <- NULL
[17:39:55.973]     }
[17:39:55.973]     ...future.result$conditions <- ...future.conditions
[17:39:55.973]     ...future.result$finished <- base::Sys.time()
[17:39:55.973]     ...future.result
[17:39:55.973] }
[17:39:55.975] assign_globals() ...
[17:39:55.975] List of 1
[17:39:55.975]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd84504a0> 
[17:39:55.975]  - attr(*, "where")=List of 1
[17:39:55.975]   ..$ a:<environment: R_EmptyEnv> 
[17:39:55.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:55.975]  - attr(*, "resolved")= logi TRUE
[17:39:55.975]  - attr(*, "total_size")= num 1622440
[17:39:55.975]  - attr(*, "already-done")= logi TRUE
[17:39:55.977] - copied ‘a’ to environment
[17:39:55.977] assign_globals() ... done
[17:39:55.978] plan(): Setting new future strategy stack:
[17:39:55.978] List of future strategies:
[17:39:55.978] 1. sequential:
[17:39:55.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.978]    - tweaked: FALSE
[17:39:55.978]    - call: NULL
[17:39:55.978] plan(): nbrOfWorkers() = 1
[17:39:55.979] plan(): Setting new future strategy stack:
[17:39:55.979] List of future strategies:
[17:39:55.979] 1. sequential:
[17:39:55.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.979]    - tweaked: FALSE
[17:39:55.979]    - call: plan(strategy)
[17:39:55.980] plan(): nbrOfWorkers() = 1
[17:39:55.980] SequentialFuture started (and completed)
[17:39:55.980] - Launch lazy future ... done
[17:39:55.980] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.980] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.981] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.981] 
[17:39:55.981] Searching for globals ... DONE
[17:39:55.981] - globals: [0] <none>
[17:39:55.981] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:55.982] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:55.982] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:55.982] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:55.983] Searching for globals ... DONE
[17:39:55.983] Resolving globals: TRUE
[17:39:55.983] Resolving any globals that are futures ...
[17:39:55.983] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:55.983] Resolving any globals that are futures ... DONE
[17:39:55.983] Resolving futures part of globals (recursively) ...
[17:39:55.983] resolve() on list ...
[17:39:55.983]  recursive: 99
[17:39:55.984]  length: 1
[17:39:55.984]  elements: ‘a’
[17:39:55.984] run() for ‘Future’ ...
[17:39:55.984] - state: ‘created’
[17:39:55.984] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.984] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.984]   - Field: ‘label’
[17:39:55.985]   - Field: ‘local’
[17:39:55.985]   - Field: ‘owner’
[17:39:55.985]   - Field: ‘envir’
[17:39:55.985]   - Field: ‘packages’
[17:39:55.985]   - Field: ‘gc’
[17:39:55.985]   - Field: ‘conditions’
[17:39:55.985]   - Field: ‘expr’
[17:39:55.985]   - Field: ‘uuid’
[17:39:55.985]   - Field: ‘seed’
[17:39:55.985]   - Field: ‘version’
[17:39:55.985]   - Field: ‘result’
[17:39:55.986]   - Field: ‘asynchronous’
[17:39:55.986]   - Field: ‘calls’
[17:39:55.986]   - Field: ‘globals’
[17:39:55.986]   - Field: ‘stdout’
[17:39:55.986]   - Field: ‘earlySignal’
[17:39:55.986]   - Field: ‘lazy’
[17:39:55.986]   - Field: ‘state’
[17:39:55.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.986] - Launch lazy future ...
[17:39:55.986] Packages needed by the future expression (n = 0): <none>
[17:39:55.986] Packages needed by future strategies (n = 0): <none>
[17:39:55.987] {
[17:39:55.987]     {
[17:39:55.987]         {
[17:39:55.987]             ...future.startTime <- base::Sys.time()
[17:39:55.987]             {
[17:39:55.987]                 {
[17:39:55.987]                   {
[17:39:55.987]                     base::local({
[17:39:55.987]                       has_future <- base::requireNamespace("future", 
[17:39:55.987]                         quietly = TRUE)
[17:39:55.987]                       if (has_future) {
[17:39:55.987]                         ns <- base::getNamespace("future")
[17:39:55.987]                         version <- ns[[".package"]][["version"]]
[17:39:55.987]                         if (is.null(version)) 
[17:39:55.987]                           version <- utils::packageVersion("future")
[17:39:55.987]                       }
[17:39:55.987]                       else {
[17:39:55.987]                         version <- NULL
[17:39:55.987]                       }
[17:39:55.987]                       if (!has_future || version < "1.8.0") {
[17:39:55.987]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.987]                           "", base::R.version$version.string), 
[17:39:55.987]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:55.987]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.987]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.987]                             "release", "version")], collapse = " "), 
[17:39:55.987]                           hostname = base::Sys.info()[["nodename"]])
[17:39:55.987]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.987]                           info)
[17:39:55.987]                         info <- base::paste(info, collapse = "; ")
[17:39:55.987]                         if (!has_future) {
[17:39:55.987]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.987]                             info)
[17:39:55.987]                         }
[17:39:55.987]                         else {
[17:39:55.987]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.987]                             info, version)
[17:39:55.987]                         }
[17:39:55.987]                         base::stop(msg)
[17:39:55.987]                       }
[17:39:55.987]                     })
[17:39:55.987]                   }
[17:39:55.987]                   ...future.strategy.old <- future::plan("list")
[17:39:55.987]                   options(future.plan = NULL)
[17:39:55.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.987]                 }
[17:39:55.987]                 ...future.workdir <- getwd()
[17:39:55.987]             }
[17:39:55.987]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.987]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.987]         }
[17:39:55.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.987]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.987]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.987]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.987]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.987]             base::names(...future.oldOptions))
[17:39:55.987]     }
[17:39:55.987]     if (FALSE) {
[17:39:55.987]     }
[17:39:55.987]     else {
[17:39:55.987]         if (TRUE) {
[17:39:55.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.987]                 open = "w")
[17:39:55.987]         }
[17:39:55.987]         else {
[17:39:55.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.987]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.987]         }
[17:39:55.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.987]             base::sink(type = "output", split = FALSE)
[17:39:55.987]             base::close(...future.stdout)
[17:39:55.987]         }, add = TRUE)
[17:39:55.987]     }
[17:39:55.987]     ...future.frame <- base::sys.nframe()
[17:39:55.987]     ...future.conditions <- base::list()
[17:39:55.987]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.987]     if (FALSE) {
[17:39:55.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.987]     }
[17:39:55.987]     ...future.result <- base::tryCatch({
[17:39:55.987]         base::withCallingHandlers({
[17:39:55.987]             ...future.value <- base::withVisible(base::local(1))
[17:39:55.987]             future::FutureResult(value = ...future.value$value, 
[17:39:55.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.987]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.987]                     ...future.globalenv.names))
[17:39:55.987]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.987]         }, condition = base::local({
[17:39:55.987]             c <- base::c
[17:39:55.987]             inherits <- base::inherits
[17:39:55.987]             invokeRestart <- base::invokeRestart
[17:39:55.987]             length <- base::length
[17:39:55.987]             list <- base::list
[17:39:55.987]             seq.int <- base::seq.int
[17:39:55.987]             signalCondition <- base::signalCondition
[17:39:55.987]             sys.calls <- base::sys.calls
[17:39:55.987]             `[[` <- base::`[[`
[17:39:55.987]             `+` <- base::`+`
[17:39:55.987]             `<<-` <- base::`<<-`
[17:39:55.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.987]                   3L)]
[17:39:55.987]             }
[17:39:55.987]             function(cond) {
[17:39:55.987]                 is_error <- inherits(cond, "error")
[17:39:55.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.987]                   NULL)
[17:39:55.987]                 if (is_error) {
[17:39:55.987]                   sessionInformation <- function() {
[17:39:55.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.987]                       search = base::search(), system = base::Sys.info())
[17:39:55.987]                   }
[17:39:55.987]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.987]                     cond$call), session = sessionInformation(), 
[17:39:55.987]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.987]                   signalCondition(cond)
[17:39:55.987]                 }
[17:39:55.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.987]                 "immediateCondition"))) {
[17:39:55.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.987]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.987]                   if (TRUE && !signal) {
[17:39:55.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.987]                     {
[17:39:55.987]                       inherits <- base::inherits
[17:39:55.987]                       invokeRestart <- base::invokeRestart
[17:39:55.987]                       is.null <- base::is.null
[17:39:55.987]                       muffled <- FALSE
[17:39:55.987]                       if (inherits(cond, "message")) {
[17:39:55.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.987]                         if (muffled) 
[17:39:55.987]                           invokeRestart("muffleMessage")
[17:39:55.987]                       }
[17:39:55.987]                       else if (inherits(cond, "warning")) {
[17:39:55.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.987]                         if (muffled) 
[17:39:55.987]                           invokeRestart("muffleWarning")
[17:39:55.987]                       }
[17:39:55.987]                       else if (inherits(cond, "condition")) {
[17:39:55.987]                         if (!is.null(pattern)) {
[17:39:55.987]                           computeRestarts <- base::computeRestarts
[17:39:55.987]                           grepl <- base::grepl
[17:39:55.987]                           restarts <- computeRestarts(cond)
[17:39:55.987]                           for (restart in restarts) {
[17:39:55.987]                             name <- restart$name
[17:39:55.987]                             if (is.null(name)) 
[17:39:55.987]                               next
[17:39:55.987]                             if (!grepl(pattern, name)) 
[17:39:55.987]                               next
[17:39:55.987]                             invokeRestart(restart)
[17:39:55.987]                             muffled <- TRUE
[17:39:55.987]                             break
[17:39:55.987]                           }
[17:39:55.987]                         }
[17:39:55.987]                       }
[17:39:55.987]                       invisible(muffled)
[17:39:55.987]                     }
[17:39:55.987]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.987]                   }
[17:39:55.987]                 }
[17:39:55.987]                 else {
[17:39:55.987]                   if (TRUE) {
[17:39:55.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.987]                     {
[17:39:55.987]                       inherits <- base::inherits
[17:39:55.987]                       invokeRestart <- base::invokeRestart
[17:39:55.987]                       is.null <- base::is.null
[17:39:55.987]                       muffled <- FALSE
[17:39:55.987]                       if (inherits(cond, "message")) {
[17:39:55.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.987]                         if (muffled) 
[17:39:55.987]                           invokeRestart("muffleMessage")
[17:39:55.987]                       }
[17:39:55.987]                       else if (inherits(cond, "warning")) {
[17:39:55.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.987]                         if (muffled) 
[17:39:55.987]                           invokeRestart("muffleWarning")
[17:39:55.987]                       }
[17:39:55.987]                       else if (inherits(cond, "condition")) {
[17:39:55.987]                         if (!is.null(pattern)) {
[17:39:55.987]                           computeRestarts <- base::computeRestarts
[17:39:55.987]                           grepl <- base::grepl
[17:39:55.987]                           restarts <- computeRestarts(cond)
[17:39:55.987]                           for (restart in restarts) {
[17:39:55.987]                             name <- restart$name
[17:39:55.987]                             if (is.null(name)) 
[17:39:55.987]                               next
[17:39:55.987]                             if (!grepl(pattern, name)) 
[17:39:55.987]                               next
[17:39:55.987]                             invokeRestart(restart)
[17:39:55.987]                             muffled <- TRUE
[17:39:55.987]                             break
[17:39:55.987]                           }
[17:39:55.987]                         }
[17:39:55.987]                       }
[17:39:55.987]                       invisible(muffled)
[17:39:55.987]                     }
[17:39:55.987]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.987]                   }
[17:39:55.987]                 }
[17:39:55.987]             }
[17:39:55.987]         }))
[17:39:55.987]     }, error = function(ex) {
[17:39:55.987]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.987]                 ...future.rng), started = ...future.startTime, 
[17:39:55.987]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.987]             version = "1.8"), class = "FutureResult")
[17:39:55.987]     }, finally = {
[17:39:55.987]         if (!identical(...future.workdir, getwd())) 
[17:39:55.987]             setwd(...future.workdir)
[17:39:55.987]         {
[17:39:55.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.987]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.987]             }
[17:39:55.987]             base::options(...future.oldOptions)
[17:39:55.987]             if (.Platform$OS.type == "windows") {
[17:39:55.987]                 old_names <- names(...future.oldEnvVars)
[17:39:55.987]                 envs <- base::Sys.getenv()
[17:39:55.987]                 names <- names(envs)
[17:39:55.987]                 common <- intersect(names, old_names)
[17:39:55.987]                 added <- setdiff(names, old_names)
[17:39:55.987]                 removed <- setdiff(old_names, names)
[17:39:55.987]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.987]                   envs[common]]
[17:39:55.987]                 NAMES <- toupper(changed)
[17:39:55.987]                 args <- list()
[17:39:55.987]                 for (kk in seq_along(NAMES)) {
[17:39:55.987]                   name <- changed[[kk]]
[17:39:55.987]                   NAME <- NAMES[[kk]]
[17:39:55.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.987]                     next
[17:39:55.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.987]                 }
[17:39:55.987]                 NAMES <- toupper(added)
[17:39:55.987]                 for (kk in seq_along(NAMES)) {
[17:39:55.987]                   name <- added[[kk]]
[17:39:55.987]                   NAME <- NAMES[[kk]]
[17:39:55.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.987]                     next
[17:39:55.987]                   args[[name]] <- ""
[17:39:55.987]                 }
[17:39:55.987]                 NAMES <- toupper(removed)
[17:39:55.987]                 for (kk in seq_along(NAMES)) {
[17:39:55.987]                   name <- removed[[kk]]
[17:39:55.987]                   NAME <- NAMES[[kk]]
[17:39:55.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.987]                     next
[17:39:55.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.987]                 }
[17:39:55.987]                 if (length(args) > 0) 
[17:39:55.987]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.987]             }
[17:39:55.987]             else {
[17:39:55.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.987]             }
[17:39:55.987]             {
[17:39:55.987]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.987]                   0L) {
[17:39:55.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.987]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.987]                   base::options(opts)
[17:39:55.987]                 }
[17:39:55.987]                 {
[17:39:55.987]                   {
[17:39:55.987]                     NULL
[17:39:55.987]                     RNGkind("Mersenne-Twister")
[17:39:55.987]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.987]                       inherits = FALSE)
[17:39:55.987]                   }
[17:39:55.987]                   options(future.plan = NULL)
[17:39:55.987]                   if (is.na(NA_character_)) 
[17:39:55.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.987]                     .init = FALSE)
[17:39:55.987]                 }
[17:39:55.987]             }
[17:39:55.987]         }
[17:39:55.987]     })
[17:39:55.987]     if (TRUE) {
[17:39:55.987]         base::sink(type = "output", split = FALSE)
[17:39:55.987]         if (TRUE) {
[17:39:55.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.987]         }
[17:39:55.987]         else {
[17:39:55.987]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.987]         }
[17:39:55.987]         base::close(...future.stdout)
[17:39:55.987]         ...future.stdout <- NULL
[17:39:55.987]     }
[17:39:55.987]     ...future.result$conditions <- ...future.conditions
[17:39:55.987]     ...future.result$finished <- base::Sys.time()
[17:39:55.987]     ...future.result
[17:39:55.987] }
[17:39:55.989] plan(): Setting new future strategy stack:
[17:39:55.989] List of future strategies:
[17:39:55.989] 1. sequential:
[17:39:55.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.989]    - tweaked: FALSE
[17:39:55.989]    - call: NULL
[17:39:55.989] plan(): nbrOfWorkers() = 1
[17:39:55.990] plan(): Setting new future strategy stack:
[17:39:55.990] List of future strategies:
[17:39:55.990] 1. sequential:
[17:39:55.990]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:55.990]    - tweaked: FALSE
[17:39:55.990]    - call: plan(strategy)
[17:39:55.990] plan(): nbrOfWorkers() = 1
[17:39:55.990] SequentialFuture started (and completed)
[17:39:55.991] - Launch lazy future ... done
[17:39:55.991] run() for ‘SequentialFuture’ ... done
[17:39:55.991] resolved() for ‘SequentialFuture’ ...
[17:39:55.991] - state: ‘finished’
[17:39:55.991] - run: TRUE
[17:39:55.991] - result: ‘FutureResult’
[17:39:55.991] resolved() for ‘SequentialFuture’ ... done
[17:39:55.991] Future #1
[17:39:55.991] resolved() for ‘SequentialFuture’ ...
[17:39:55.991] - state: ‘finished’
[17:39:55.993] - run: TRUE
[17:39:55.993] - result: ‘FutureResult’
[17:39:55.993] resolved() for ‘SequentialFuture’ ... done
[17:39:55.993] A SequentialFuture was resolved
[17:39:55.993]  length: 0 (resolved future 1)
[17:39:55.993] resolve() on list ... DONE
[17:39:55.993] - globals: [1] ‘a’
[17:39:55.993] Resolving futures part of globals (recursively) ... DONE
[17:39:55.995] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[17:39:55.995] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:39:55.995] - globals: [1] ‘a’
[17:39:55.996] - packages: [1] ‘future’
[17:39:55.996] getGlobalsAndPackages() ... DONE
[17:39:55.996] run() for ‘Future’ ...
[17:39:55.996] - state: ‘created’
[17:39:55.996] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:55.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:55.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:55.997]   - Field: ‘label’
[17:39:55.997]   - Field: ‘local’
[17:39:55.997]   - Field: ‘owner’
[17:39:55.997]   - Field: ‘envir’
[17:39:55.997]   - Field: ‘packages’
[17:39:55.997]   - Field: ‘gc’
[17:39:55.997]   - Field: ‘conditions’
[17:39:55.997]   - Field: ‘expr’
[17:39:55.997]   - Field: ‘uuid’
[17:39:55.997]   - Field: ‘seed’
[17:39:55.998]   - Field: ‘version’
[17:39:55.998]   - Field: ‘result’
[17:39:55.998]   - Field: ‘asynchronous’
[17:39:55.998]   - Field: ‘calls’
[17:39:55.998]   - Field: ‘globals’
[17:39:55.998]   - Field: ‘stdout’
[17:39:55.998]   - Field: ‘earlySignal’
[17:39:55.998]   - Field: ‘lazy’
[17:39:55.998]   - Field: ‘state’
[17:39:55.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:55.998] - Launch lazy future ...
[17:39:55.999] Packages needed by the future expression (n = 1): ‘future’
[17:39:55.999] Packages needed by future strategies (n = 0): <none>
[17:39:55.999] {
[17:39:55.999]     {
[17:39:55.999]         {
[17:39:55.999]             ...future.startTime <- base::Sys.time()
[17:39:55.999]             {
[17:39:55.999]                 {
[17:39:55.999]                   {
[17:39:55.999]                     {
[17:39:55.999]                       base::local({
[17:39:55.999]                         has_future <- base::requireNamespace("future", 
[17:39:55.999]                           quietly = TRUE)
[17:39:55.999]                         if (has_future) {
[17:39:55.999]                           ns <- base::getNamespace("future")
[17:39:55.999]                           version <- ns[[".package"]][["version"]]
[17:39:55.999]                           if (is.null(version)) 
[17:39:55.999]                             version <- utils::packageVersion("future")
[17:39:55.999]                         }
[17:39:55.999]                         else {
[17:39:55.999]                           version <- NULL
[17:39:55.999]                         }
[17:39:55.999]                         if (!has_future || version < "1.8.0") {
[17:39:55.999]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:55.999]                             "", base::R.version$version.string), 
[17:39:55.999]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:55.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:55.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:55.999]                               "release", "version")], collapse = " "), 
[17:39:55.999]                             hostname = base::Sys.info()[["nodename"]])
[17:39:55.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:55.999]                             info)
[17:39:55.999]                           info <- base::paste(info, collapse = "; ")
[17:39:55.999]                           if (!has_future) {
[17:39:55.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:55.999]                               info)
[17:39:55.999]                           }
[17:39:55.999]                           else {
[17:39:55.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:55.999]                               info, version)
[17:39:55.999]                           }
[17:39:55.999]                           base::stop(msg)
[17:39:55.999]                         }
[17:39:55.999]                       })
[17:39:55.999]                     }
[17:39:55.999]                     base::local({
[17:39:55.999]                       for (pkg in "future") {
[17:39:55.999]                         base::loadNamespace(pkg)
[17:39:55.999]                         base::library(pkg, character.only = TRUE)
[17:39:55.999]                       }
[17:39:55.999]                     })
[17:39:55.999]                   }
[17:39:55.999]                   ...future.strategy.old <- future::plan("list")
[17:39:55.999]                   options(future.plan = NULL)
[17:39:55.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:55.999]                 }
[17:39:55.999]                 ...future.workdir <- getwd()
[17:39:55.999]             }
[17:39:55.999]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:55.999]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:55.999]         }
[17:39:55.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:55.999]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:55.999]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:55.999]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:55.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:55.999]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:55.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:55.999]             base::names(...future.oldOptions))
[17:39:55.999]     }
[17:39:55.999]     if (FALSE) {
[17:39:55.999]     }
[17:39:55.999]     else {
[17:39:55.999]         if (TRUE) {
[17:39:55.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:55.999]                 open = "w")
[17:39:55.999]         }
[17:39:55.999]         else {
[17:39:55.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:55.999]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:55.999]         }
[17:39:55.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:55.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:55.999]             base::sink(type = "output", split = FALSE)
[17:39:55.999]             base::close(...future.stdout)
[17:39:55.999]         }, add = TRUE)
[17:39:55.999]     }
[17:39:55.999]     ...future.frame <- base::sys.nframe()
[17:39:55.999]     ...future.conditions <- base::list()
[17:39:55.999]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:55.999]     if (FALSE) {
[17:39:55.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:55.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:55.999]     }
[17:39:55.999]     ...future.result <- base::tryCatch({
[17:39:55.999]         base::withCallingHandlers({
[17:39:55.999]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:39:55.999]                 1))
[17:39:55.999]             future::FutureResult(value = ...future.value$value, 
[17:39:55.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.999]                   ...future.rng), globalenv = if (FALSE) 
[17:39:55.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:55.999]                     ...future.globalenv.names))
[17:39:55.999]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:55.999]         }, condition = base::local({
[17:39:55.999]             c <- base::c
[17:39:55.999]             inherits <- base::inherits
[17:39:55.999]             invokeRestart <- base::invokeRestart
[17:39:55.999]             length <- base::length
[17:39:55.999]             list <- base::list
[17:39:55.999]             seq.int <- base::seq.int
[17:39:55.999]             signalCondition <- base::signalCondition
[17:39:55.999]             sys.calls <- base::sys.calls
[17:39:55.999]             `[[` <- base::`[[`
[17:39:55.999]             `+` <- base::`+`
[17:39:55.999]             `<<-` <- base::`<<-`
[17:39:55.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:55.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:55.999]                   3L)]
[17:39:55.999]             }
[17:39:55.999]             function(cond) {
[17:39:55.999]                 is_error <- inherits(cond, "error")
[17:39:55.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:55.999]                   NULL)
[17:39:55.999]                 if (is_error) {
[17:39:55.999]                   sessionInformation <- function() {
[17:39:55.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:55.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:55.999]                       search = base::search(), system = base::Sys.info())
[17:39:55.999]                   }
[17:39:55.999]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:55.999]                     cond$call), session = sessionInformation(), 
[17:39:55.999]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:55.999]                   signalCondition(cond)
[17:39:55.999]                 }
[17:39:55.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:55.999]                 "immediateCondition"))) {
[17:39:55.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:55.999]                   ...future.conditions[[length(...future.conditions) + 
[17:39:55.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:55.999]                   if (TRUE && !signal) {
[17:39:55.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.999]                     {
[17:39:55.999]                       inherits <- base::inherits
[17:39:55.999]                       invokeRestart <- base::invokeRestart
[17:39:55.999]                       is.null <- base::is.null
[17:39:55.999]                       muffled <- FALSE
[17:39:55.999]                       if (inherits(cond, "message")) {
[17:39:55.999]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.999]                         if (muffled) 
[17:39:55.999]                           invokeRestart("muffleMessage")
[17:39:55.999]                       }
[17:39:55.999]                       else if (inherits(cond, "warning")) {
[17:39:55.999]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.999]                         if (muffled) 
[17:39:55.999]                           invokeRestart("muffleWarning")
[17:39:55.999]                       }
[17:39:55.999]                       else if (inherits(cond, "condition")) {
[17:39:55.999]                         if (!is.null(pattern)) {
[17:39:55.999]                           computeRestarts <- base::computeRestarts
[17:39:55.999]                           grepl <- base::grepl
[17:39:55.999]                           restarts <- computeRestarts(cond)
[17:39:55.999]                           for (restart in restarts) {
[17:39:55.999]                             name <- restart$name
[17:39:55.999]                             if (is.null(name)) 
[17:39:55.999]                               next
[17:39:55.999]                             if (!grepl(pattern, name)) 
[17:39:55.999]                               next
[17:39:55.999]                             invokeRestart(restart)
[17:39:55.999]                             muffled <- TRUE
[17:39:55.999]                             break
[17:39:55.999]                           }
[17:39:55.999]                         }
[17:39:55.999]                       }
[17:39:55.999]                       invisible(muffled)
[17:39:55.999]                     }
[17:39:55.999]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.999]                   }
[17:39:55.999]                 }
[17:39:55.999]                 else {
[17:39:55.999]                   if (TRUE) {
[17:39:55.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:55.999]                     {
[17:39:55.999]                       inherits <- base::inherits
[17:39:55.999]                       invokeRestart <- base::invokeRestart
[17:39:55.999]                       is.null <- base::is.null
[17:39:55.999]                       muffled <- FALSE
[17:39:55.999]                       if (inherits(cond, "message")) {
[17:39:55.999]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:55.999]                         if (muffled) 
[17:39:55.999]                           invokeRestart("muffleMessage")
[17:39:55.999]                       }
[17:39:55.999]                       else if (inherits(cond, "warning")) {
[17:39:55.999]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:55.999]                         if (muffled) 
[17:39:55.999]                           invokeRestart("muffleWarning")
[17:39:55.999]                       }
[17:39:55.999]                       else if (inherits(cond, "condition")) {
[17:39:55.999]                         if (!is.null(pattern)) {
[17:39:55.999]                           computeRestarts <- base::computeRestarts
[17:39:55.999]                           grepl <- base::grepl
[17:39:55.999]                           restarts <- computeRestarts(cond)
[17:39:55.999]                           for (restart in restarts) {
[17:39:55.999]                             name <- restart$name
[17:39:55.999]                             if (is.null(name)) 
[17:39:55.999]                               next
[17:39:55.999]                             if (!grepl(pattern, name)) 
[17:39:55.999]                               next
[17:39:55.999]                             invokeRestart(restart)
[17:39:55.999]                             muffled <- TRUE
[17:39:55.999]                             break
[17:39:55.999]                           }
[17:39:55.999]                         }
[17:39:55.999]                       }
[17:39:55.999]                       invisible(muffled)
[17:39:55.999]                     }
[17:39:55.999]                     muffleCondition(cond, pattern = "^muffle")
[17:39:55.999]                   }
[17:39:55.999]                 }
[17:39:55.999]             }
[17:39:55.999]         }))
[17:39:55.999]     }, error = function(ex) {
[17:39:55.999]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:55.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:55.999]                 ...future.rng), started = ...future.startTime, 
[17:39:55.999]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:55.999]             version = "1.8"), class = "FutureResult")
[17:39:55.999]     }, finally = {
[17:39:55.999]         if (!identical(...future.workdir, getwd())) 
[17:39:55.999]             setwd(...future.workdir)
[17:39:55.999]         {
[17:39:55.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:55.999]                 ...future.oldOptions$nwarnings <- NULL
[17:39:55.999]             }
[17:39:55.999]             base::options(...future.oldOptions)
[17:39:55.999]             if (.Platform$OS.type == "windows") {
[17:39:55.999]                 old_names <- names(...future.oldEnvVars)
[17:39:55.999]                 envs <- base::Sys.getenv()
[17:39:55.999]                 names <- names(envs)
[17:39:55.999]                 common <- intersect(names, old_names)
[17:39:55.999]                 added <- setdiff(names, old_names)
[17:39:55.999]                 removed <- setdiff(old_names, names)
[17:39:55.999]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:55.999]                   envs[common]]
[17:39:55.999]                 NAMES <- toupper(changed)
[17:39:55.999]                 args <- list()
[17:39:55.999]                 for (kk in seq_along(NAMES)) {
[17:39:55.999]                   name <- changed[[kk]]
[17:39:55.999]                   NAME <- NAMES[[kk]]
[17:39:55.999]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.999]                     next
[17:39:55.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.999]                 }
[17:39:55.999]                 NAMES <- toupper(added)
[17:39:55.999]                 for (kk in seq_along(NAMES)) {
[17:39:55.999]                   name <- added[[kk]]
[17:39:55.999]                   NAME <- NAMES[[kk]]
[17:39:55.999]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.999]                     next
[17:39:55.999]                   args[[name]] <- ""
[17:39:55.999]                 }
[17:39:55.999]                 NAMES <- toupper(removed)
[17:39:55.999]                 for (kk in seq_along(NAMES)) {
[17:39:55.999]                   name <- removed[[kk]]
[17:39:55.999]                   NAME <- NAMES[[kk]]
[17:39:55.999]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:55.999]                     next
[17:39:55.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:55.999]                 }
[17:39:55.999]                 if (length(args) > 0) 
[17:39:55.999]                   base::do.call(base::Sys.setenv, args = args)
[17:39:55.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:55.999]             }
[17:39:55.999]             else {
[17:39:55.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:55.999]             }
[17:39:55.999]             {
[17:39:55.999]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:55.999]                   0L) {
[17:39:55.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:55.999]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:55.999]                   base::options(opts)
[17:39:55.999]                 }
[17:39:55.999]                 {
[17:39:55.999]                   {
[17:39:55.999]                     NULL
[17:39:55.999]                     RNGkind("Mersenne-Twister")
[17:39:55.999]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:55.999]                       inherits = FALSE)
[17:39:55.999]                   }
[17:39:55.999]                   options(future.plan = NULL)
[17:39:55.999]                   if (is.na(NA_character_)) 
[17:39:55.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:55.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:55.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:55.999]                     .init = FALSE)
[17:39:55.999]                 }
[17:39:55.999]             }
[17:39:55.999]         }
[17:39:55.999]     })
[17:39:55.999]     if (TRUE) {
[17:39:55.999]         base::sink(type = "output", split = FALSE)
[17:39:55.999]         if (TRUE) {
[17:39:55.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:55.999]         }
[17:39:55.999]         else {
[17:39:55.999]             ...future.result["stdout"] <- base::list(NULL)
[17:39:55.999]         }
[17:39:55.999]         base::close(...future.stdout)
[17:39:55.999]         ...future.stdout <- NULL
[17:39:55.999]     }
[17:39:55.999]     ...future.result$conditions <- ...future.conditions
[17:39:55.999]     ...future.result$finished <- base::Sys.time()
[17:39:55.999]     ...future.result
[17:39:55.999] }
[17:39:56.001] assign_globals() ...
[17:39:56.001] List of 1
[17:39:56.001]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bfd82dca08> 
[17:39:56.001]  - attr(*, "where")=List of 1
[17:39:56.001]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.001]  - attr(*, "resolved")= logi TRUE
[17:39:56.001]  - attr(*, "total_size")= num 1622440
[17:39:56.001]  - attr(*, "already-done")= logi TRUE
[17:39:56.003] - copied ‘a’ to environment
[17:39:56.003] assign_globals() ... done
[17:39:56.003] plan(): Setting new future strategy stack:
[17:39:56.003] List of future strategies:
[17:39:56.003] 1. sequential:
[17:39:56.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.003]    - tweaked: FALSE
[17:39:56.003]    - call: NULL
[17:39:56.004] plan(): nbrOfWorkers() = 1
[17:39:56.005] plan(): Setting new future strategy stack:
[17:39:56.005] List of future strategies:
[17:39:56.005] 1. sequential:
[17:39:56.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.005]    - tweaked: FALSE
[17:39:56.005]    - call: plan(strategy)
[17:39:56.005] plan(): nbrOfWorkers() = 1
[17:39:56.005] SequentialFuture started (and completed)
[17:39:56.005] - Launch lazy future ... done
[17:39:56.006] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.006] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.006] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.007] - globals found: [2] ‘{’, ‘pkg’
[17:39:56.007] Searching for globals ... DONE
[17:39:56.007] Resolving globals: TRUE
[17:39:56.007] Resolving any globals that are futures ...
[17:39:56.007] - globals: [2] ‘{’, ‘pkg’
[17:39:56.007] Resolving any globals that are futures ... DONE
[17:39:56.008] Resolving futures part of globals (recursively) ...
[17:39:56.008] resolve() on list ...
[17:39:56.008]  recursive: 99
[17:39:56.008]  length: 1
[17:39:56.008]  elements: ‘pkg’
[17:39:56.008]  length: 0 (resolved future 1)
[17:39:56.008] resolve() on list ... DONE
[17:39:56.008] - globals: [1] ‘pkg’
[17:39:56.008] Resolving futures part of globals (recursively) ... DONE
[17:39:56.009] The total size of the 1 globals is 112 bytes (112 bytes)
[17:39:56.009] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:39:56.009] - globals: [1] ‘pkg’
[17:39:56.009] 
[17:39:56.009] getGlobalsAndPackages() ... DONE
[17:39:56.009] Packages needed by the future expression (n = 0): <none>
[17:39:56.009] Packages needed by future strategies (n = 0): <none>
[17:39:56.010] {
[17:39:56.010]     {
[17:39:56.010]         {
[17:39:56.010]             ...future.startTime <- base::Sys.time()
[17:39:56.010]             {
[17:39:56.010]                 {
[17:39:56.010]                   {
[17:39:56.010]                     base::local({
[17:39:56.010]                       has_future <- base::requireNamespace("future", 
[17:39:56.010]                         quietly = TRUE)
[17:39:56.010]                       if (has_future) {
[17:39:56.010]                         ns <- base::getNamespace("future")
[17:39:56.010]                         version <- ns[[".package"]][["version"]]
[17:39:56.010]                         if (is.null(version)) 
[17:39:56.010]                           version <- utils::packageVersion("future")
[17:39:56.010]                       }
[17:39:56.010]                       else {
[17:39:56.010]                         version <- NULL
[17:39:56.010]                       }
[17:39:56.010]                       if (!has_future || version < "1.8.0") {
[17:39:56.010]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.010]                           "", base::R.version$version.string), 
[17:39:56.010]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:56.010]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.010]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.010]                             "release", "version")], collapse = " "), 
[17:39:56.010]                           hostname = base::Sys.info()[["nodename"]])
[17:39:56.010]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.010]                           info)
[17:39:56.010]                         info <- base::paste(info, collapse = "; ")
[17:39:56.010]                         if (!has_future) {
[17:39:56.010]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.010]                             info)
[17:39:56.010]                         }
[17:39:56.010]                         else {
[17:39:56.010]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.010]                             info, version)
[17:39:56.010]                         }
[17:39:56.010]                         base::stop(msg)
[17:39:56.010]                       }
[17:39:56.010]                     })
[17:39:56.010]                   }
[17:39:56.010]                   ...future.strategy.old <- future::plan("list")
[17:39:56.010]                   options(future.plan = NULL)
[17:39:56.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.010]                 }
[17:39:56.010]                 ...future.workdir <- getwd()
[17:39:56.010]             }
[17:39:56.010]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.010]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.010]         }
[17:39:56.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.010]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.010]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.010]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.010]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.010]             base::names(...future.oldOptions))
[17:39:56.010]     }
[17:39:56.010]     if (FALSE) {
[17:39:56.010]     }
[17:39:56.010]     else {
[17:39:56.010]         if (TRUE) {
[17:39:56.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.010]                 open = "w")
[17:39:56.010]         }
[17:39:56.010]         else {
[17:39:56.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.010]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.010]         }
[17:39:56.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.010]             base::sink(type = "output", split = FALSE)
[17:39:56.010]             base::close(...future.stdout)
[17:39:56.010]         }, add = TRUE)
[17:39:56.010]     }
[17:39:56.010]     ...future.frame <- base::sys.nframe()
[17:39:56.010]     ...future.conditions <- base::list()
[17:39:56.010]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.010]     if (FALSE) {
[17:39:56.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.010]     }
[17:39:56.010]     ...future.result <- base::tryCatch({
[17:39:56.010]         base::withCallingHandlers({
[17:39:56.010]             ...future.value <- base::withVisible(base::local({
[17:39:56.010]                 pkg
[17:39:56.010]             }))
[17:39:56.010]             future::FutureResult(value = ...future.value$value, 
[17:39:56.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.010]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.010]                     ...future.globalenv.names))
[17:39:56.010]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.010]         }, condition = base::local({
[17:39:56.010]             c <- base::c
[17:39:56.010]             inherits <- base::inherits
[17:39:56.010]             invokeRestart <- base::invokeRestart
[17:39:56.010]             length <- base::length
[17:39:56.010]             list <- base::list
[17:39:56.010]             seq.int <- base::seq.int
[17:39:56.010]             signalCondition <- base::signalCondition
[17:39:56.010]             sys.calls <- base::sys.calls
[17:39:56.010]             `[[` <- base::`[[`
[17:39:56.010]             `+` <- base::`+`
[17:39:56.010]             `<<-` <- base::`<<-`
[17:39:56.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.010]                   3L)]
[17:39:56.010]             }
[17:39:56.010]             function(cond) {
[17:39:56.010]                 is_error <- inherits(cond, "error")
[17:39:56.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.010]                   NULL)
[17:39:56.010]                 if (is_error) {
[17:39:56.010]                   sessionInformation <- function() {
[17:39:56.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.010]                       search = base::search(), system = base::Sys.info())
[17:39:56.010]                   }
[17:39:56.010]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.010]                     cond$call), session = sessionInformation(), 
[17:39:56.010]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.010]                   signalCondition(cond)
[17:39:56.010]                 }
[17:39:56.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.010]                 "immediateCondition"))) {
[17:39:56.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.010]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.010]                   if (TRUE && !signal) {
[17:39:56.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.010]                     {
[17:39:56.010]                       inherits <- base::inherits
[17:39:56.010]                       invokeRestart <- base::invokeRestart
[17:39:56.010]                       is.null <- base::is.null
[17:39:56.010]                       muffled <- FALSE
[17:39:56.010]                       if (inherits(cond, "message")) {
[17:39:56.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.010]                         if (muffled) 
[17:39:56.010]                           invokeRestart("muffleMessage")
[17:39:56.010]                       }
[17:39:56.010]                       else if (inherits(cond, "warning")) {
[17:39:56.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.010]                         if (muffled) 
[17:39:56.010]                           invokeRestart("muffleWarning")
[17:39:56.010]                       }
[17:39:56.010]                       else if (inherits(cond, "condition")) {
[17:39:56.010]                         if (!is.null(pattern)) {
[17:39:56.010]                           computeRestarts <- base::computeRestarts
[17:39:56.010]                           grepl <- base::grepl
[17:39:56.010]                           restarts <- computeRestarts(cond)
[17:39:56.010]                           for (restart in restarts) {
[17:39:56.010]                             name <- restart$name
[17:39:56.010]                             if (is.null(name)) 
[17:39:56.010]                               next
[17:39:56.010]                             if (!grepl(pattern, name)) 
[17:39:56.010]                               next
[17:39:56.010]                             invokeRestart(restart)
[17:39:56.010]                             muffled <- TRUE
[17:39:56.010]                             break
[17:39:56.010]                           }
[17:39:56.010]                         }
[17:39:56.010]                       }
[17:39:56.010]                       invisible(muffled)
[17:39:56.010]                     }
[17:39:56.010]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.010]                   }
[17:39:56.010]                 }
[17:39:56.010]                 else {
[17:39:56.010]                   if (TRUE) {
[17:39:56.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.010]                     {
[17:39:56.010]                       inherits <- base::inherits
[17:39:56.010]                       invokeRestart <- base::invokeRestart
[17:39:56.010]                       is.null <- base::is.null
[17:39:56.010]                       muffled <- FALSE
[17:39:56.010]                       if (inherits(cond, "message")) {
[17:39:56.010]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.010]                         if (muffled) 
[17:39:56.010]                           invokeRestart("muffleMessage")
[17:39:56.010]                       }
[17:39:56.010]                       else if (inherits(cond, "warning")) {
[17:39:56.010]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.010]                         if (muffled) 
[17:39:56.010]                           invokeRestart("muffleWarning")
[17:39:56.010]                       }
[17:39:56.010]                       else if (inherits(cond, "condition")) {
[17:39:56.010]                         if (!is.null(pattern)) {
[17:39:56.010]                           computeRestarts <- base::computeRestarts
[17:39:56.010]                           grepl <- base::grepl
[17:39:56.010]                           restarts <- computeRestarts(cond)
[17:39:56.010]                           for (restart in restarts) {
[17:39:56.010]                             name <- restart$name
[17:39:56.010]                             if (is.null(name)) 
[17:39:56.010]                               next
[17:39:56.010]                             if (!grepl(pattern, name)) 
[17:39:56.010]                               next
[17:39:56.010]                             invokeRestart(restart)
[17:39:56.010]                             muffled <- TRUE
[17:39:56.010]                             break
[17:39:56.010]                           }
[17:39:56.010]                         }
[17:39:56.010]                       }
[17:39:56.010]                       invisible(muffled)
[17:39:56.010]                     }
[17:39:56.010]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.010]                   }
[17:39:56.010]                 }
[17:39:56.010]             }
[17:39:56.010]         }))
[17:39:56.010]     }, error = function(ex) {
[17:39:56.010]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.010]                 ...future.rng), started = ...future.startTime, 
[17:39:56.010]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.010]             version = "1.8"), class = "FutureResult")
[17:39:56.010]     }, finally = {
[17:39:56.010]         if (!identical(...future.workdir, getwd())) 
[17:39:56.010]             setwd(...future.workdir)
[17:39:56.010]         {
[17:39:56.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.010]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.010]             }
[17:39:56.010]             base::options(...future.oldOptions)
[17:39:56.010]             if (.Platform$OS.type == "windows") {
[17:39:56.010]                 old_names <- names(...future.oldEnvVars)
[17:39:56.010]                 envs <- base::Sys.getenv()
[17:39:56.010]                 names <- names(envs)
[17:39:56.010]                 common <- intersect(names, old_names)
[17:39:56.010]                 added <- setdiff(names, old_names)
[17:39:56.010]                 removed <- setdiff(old_names, names)
[17:39:56.010]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.010]                   envs[common]]
[17:39:56.010]                 NAMES <- toupper(changed)
[17:39:56.010]                 args <- list()
[17:39:56.010]                 for (kk in seq_along(NAMES)) {
[17:39:56.010]                   name <- changed[[kk]]
[17:39:56.010]                   NAME <- NAMES[[kk]]
[17:39:56.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.010]                     next
[17:39:56.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.010]                 }
[17:39:56.010]                 NAMES <- toupper(added)
[17:39:56.010]                 for (kk in seq_along(NAMES)) {
[17:39:56.010]                   name <- added[[kk]]
[17:39:56.010]                   NAME <- NAMES[[kk]]
[17:39:56.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.010]                     next
[17:39:56.010]                   args[[name]] <- ""
[17:39:56.010]                 }
[17:39:56.010]                 NAMES <- toupper(removed)
[17:39:56.010]                 for (kk in seq_along(NAMES)) {
[17:39:56.010]                   name <- removed[[kk]]
[17:39:56.010]                   NAME <- NAMES[[kk]]
[17:39:56.010]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.010]                     next
[17:39:56.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.010]                 }
[17:39:56.010]                 if (length(args) > 0) 
[17:39:56.010]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.010]             }
[17:39:56.010]             else {
[17:39:56.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.010]             }
[17:39:56.010]             {
[17:39:56.010]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.010]                   0L) {
[17:39:56.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.010]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.010]                   base::options(opts)
[17:39:56.010]                 }
[17:39:56.010]                 {
[17:39:56.010]                   {
[17:39:56.010]                     NULL
[17:39:56.010]                     RNGkind("Mersenne-Twister")
[17:39:56.010]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:56.010]                       inherits = FALSE)
[17:39:56.010]                   }
[17:39:56.010]                   options(future.plan = NULL)
[17:39:56.010]                   if (is.na(NA_character_)) 
[17:39:56.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.010]                     .init = FALSE)
[17:39:56.010]                 }
[17:39:56.010]             }
[17:39:56.010]         }
[17:39:56.010]     })
[17:39:56.010]     if (TRUE) {
[17:39:56.010]         base::sink(type = "output", split = FALSE)
[17:39:56.010]         if (TRUE) {
[17:39:56.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.010]         }
[17:39:56.010]         else {
[17:39:56.010]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.010]         }
[17:39:56.010]         base::close(...future.stdout)
[17:39:56.010]         ...future.stdout <- NULL
[17:39:56.010]     }
[17:39:56.010]     ...future.result$conditions <- ...future.conditions
[17:39:56.010]     ...future.result$finished <- base::Sys.time()
[17:39:56.010]     ...future.result
[17:39:56.010] }
[17:39:56.011] assign_globals() ...
[17:39:56.011] List of 1
[17:39:56.011]  $ pkg: chr "foo"
[17:39:56.011]  - attr(*, "where")=List of 1
[17:39:56.011]   ..$ pkg:<environment: R_EmptyEnv> 
[17:39:56.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.011]  - attr(*, "resolved")= logi TRUE
[17:39:56.011]  - attr(*, "total_size")= num 112
[17:39:56.013] - copied ‘pkg’ to environment
[17:39:56.013] assign_globals() ... done
[17:39:56.014] plan(): Setting new future strategy stack:
[17:39:56.014] List of future strategies:
[17:39:56.014] 1. sequential:
[17:39:56.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.014]    - tweaked: FALSE
[17:39:56.014]    - call: NULL
[17:39:56.014] plan(): nbrOfWorkers() = 1
[17:39:56.015] plan(): Setting new future strategy stack:
[17:39:56.015] List of future strategies:
[17:39:56.015] 1. sequential:
[17:39:56.015]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.015]    - tweaked: FALSE
[17:39:56.015]    - call: plan(strategy)
[17:39:56.015] plan(): nbrOfWorkers() = 1
[17:39:56.015] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.016] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.016] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.018] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:39:56.018] Searching for globals ... DONE
[17:39:56.018] Resolving globals: TRUE
[17:39:56.018] Resolving any globals that are futures ...
[17:39:56.018] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:39:56.018] Resolving any globals that are futures ... DONE
[17:39:56.018] 
[17:39:56.019] 
[17:39:56.019] getGlobalsAndPackages() ... DONE
[17:39:56.019] run() for ‘Future’ ...
[17:39:56.019] - state: ‘created’
[17:39:56.019] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:56.020] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:56.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:56.020]   - Field: ‘label’
[17:39:56.020]   - Field: ‘local’
[17:39:56.021]   - Field: ‘owner’
[17:39:56.021]   - Field: ‘envir’
[17:39:56.021]   - Field: ‘packages’
[17:39:56.021]   - Field: ‘gc’
[17:39:56.021]   - Field: ‘conditions’
[17:39:56.021]   - Field: ‘expr’
[17:39:56.021]   - Field: ‘uuid’
[17:39:56.021]   - Field: ‘seed’
[17:39:56.021]   - Field: ‘version’
[17:39:56.021]   - Field: ‘result’
[17:39:56.021]   - Field: ‘asynchronous’
[17:39:56.021]   - Field: ‘calls’
[17:39:56.022]   - Field: ‘globals’
[17:39:56.022]   - Field: ‘stdout’
[17:39:56.022]   - Field: ‘earlySignal’
[17:39:56.022]   - Field: ‘lazy’
[17:39:56.022]   - Field: ‘state’
[17:39:56.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:56.022] - Launch lazy future ...
[17:39:56.022] Packages needed by the future expression (n = 0): <none>
[17:39:56.022] Packages needed by future strategies (n = 0): <none>
[17:39:56.023] {
[17:39:56.023]     {
[17:39:56.023]         {
[17:39:56.023]             ...future.startTime <- base::Sys.time()
[17:39:56.023]             {
[17:39:56.023]                 {
[17:39:56.023]                   {
[17:39:56.023]                     base::local({
[17:39:56.023]                       has_future <- base::requireNamespace("future", 
[17:39:56.023]                         quietly = TRUE)
[17:39:56.023]                       if (has_future) {
[17:39:56.023]                         ns <- base::getNamespace("future")
[17:39:56.023]                         version <- ns[[".package"]][["version"]]
[17:39:56.023]                         if (is.null(version)) 
[17:39:56.023]                           version <- utils::packageVersion("future")
[17:39:56.023]                       }
[17:39:56.023]                       else {
[17:39:56.023]                         version <- NULL
[17:39:56.023]                       }
[17:39:56.023]                       if (!has_future || version < "1.8.0") {
[17:39:56.023]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.023]                           "", base::R.version$version.string), 
[17:39:56.023]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:56.023]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.023]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.023]                             "release", "version")], collapse = " "), 
[17:39:56.023]                           hostname = base::Sys.info()[["nodename"]])
[17:39:56.023]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.023]                           info)
[17:39:56.023]                         info <- base::paste(info, collapse = "; ")
[17:39:56.023]                         if (!has_future) {
[17:39:56.023]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.023]                             info)
[17:39:56.023]                         }
[17:39:56.023]                         else {
[17:39:56.023]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.023]                             info, version)
[17:39:56.023]                         }
[17:39:56.023]                         base::stop(msg)
[17:39:56.023]                       }
[17:39:56.023]                     })
[17:39:56.023]                   }
[17:39:56.023]                   ...future.strategy.old <- future::plan("list")
[17:39:56.023]                   options(future.plan = NULL)
[17:39:56.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.023]                 }
[17:39:56.023]                 ...future.workdir <- getwd()
[17:39:56.023]             }
[17:39:56.023]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.023]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.023]         }
[17:39:56.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.023]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.023]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.023]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.023]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.023]             base::names(...future.oldOptions))
[17:39:56.023]     }
[17:39:56.023]     if (FALSE) {
[17:39:56.023]     }
[17:39:56.023]     else {
[17:39:56.023]         if (TRUE) {
[17:39:56.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.023]                 open = "w")
[17:39:56.023]         }
[17:39:56.023]         else {
[17:39:56.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.023]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.023]         }
[17:39:56.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.023]             base::sink(type = "output", split = FALSE)
[17:39:56.023]             base::close(...future.stdout)
[17:39:56.023]         }, add = TRUE)
[17:39:56.023]     }
[17:39:56.023]     ...future.frame <- base::sys.nframe()
[17:39:56.023]     ...future.conditions <- base::list()
[17:39:56.023]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.023]     if (FALSE) {
[17:39:56.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.023]     }
[17:39:56.023]     ...future.result <- base::tryCatch({
[17:39:56.023]         base::withCallingHandlers({
[17:39:56.023]             ...future.value <- base::withVisible(base::local({
[17:39:56.023]                 x <- 0
[17:39:56.023]                 x <- x + 1
[17:39:56.023]                 x
[17:39:56.023]             }))
[17:39:56.023]             future::FutureResult(value = ...future.value$value, 
[17:39:56.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.023]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.023]                     ...future.globalenv.names))
[17:39:56.023]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.023]         }, condition = base::local({
[17:39:56.023]             c <- base::c
[17:39:56.023]             inherits <- base::inherits
[17:39:56.023]             invokeRestart <- base::invokeRestart
[17:39:56.023]             length <- base::length
[17:39:56.023]             list <- base::list
[17:39:56.023]             seq.int <- base::seq.int
[17:39:56.023]             signalCondition <- base::signalCondition
[17:39:56.023]             sys.calls <- base::sys.calls
[17:39:56.023]             `[[` <- base::`[[`
[17:39:56.023]             `+` <- base::`+`
[17:39:56.023]             `<<-` <- base::`<<-`
[17:39:56.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.023]                   3L)]
[17:39:56.023]             }
[17:39:56.023]             function(cond) {
[17:39:56.023]                 is_error <- inherits(cond, "error")
[17:39:56.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.023]                   NULL)
[17:39:56.023]                 if (is_error) {
[17:39:56.023]                   sessionInformation <- function() {
[17:39:56.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.023]                       search = base::search(), system = base::Sys.info())
[17:39:56.023]                   }
[17:39:56.023]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.023]                     cond$call), session = sessionInformation(), 
[17:39:56.023]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.023]                   signalCondition(cond)
[17:39:56.023]                 }
[17:39:56.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.023]                 "immediateCondition"))) {
[17:39:56.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.023]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.023]                   if (TRUE && !signal) {
[17:39:56.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.023]                     {
[17:39:56.023]                       inherits <- base::inherits
[17:39:56.023]                       invokeRestart <- base::invokeRestart
[17:39:56.023]                       is.null <- base::is.null
[17:39:56.023]                       muffled <- FALSE
[17:39:56.023]                       if (inherits(cond, "message")) {
[17:39:56.023]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.023]                         if (muffled) 
[17:39:56.023]                           invokeRestart("muffleMessage")
[17:39:56.023]                       }
[17:39:56.023]                       else if (inherits(cond, "warning")) {
[17:39:56.023]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.023]                         if (muffled) 
[17:39:56.023]                           invokeRestart("muffleWarning")
[17:39:56.023]                       }
[17:39:56.023]                       else if (inherits(cond, "condition")) {
[17:39:56.023]                         if (!is.null(pattern)) {
[17:39:56.023]                           computeRestarts <- base::computeRestarts
[17:39:56.023]                           grepl <- base::grepl
[17:39:56.023]                           restarts <- computeRestarts(cond)
[17:39:56.023]                           for (restart in restarts) {
[17:39:56.023]                             name <- restart$name
[17:39:56.023]                             if (is.null(name)) 
[17:39:56.023]                               next
[17:39:56.023]                             if (!grepl(pattern, name)) 
[17:39:56.023]                               next
[17:39:56.023]                             invokeRestart(restart)
[17:39:56.023]                             muffled <- TRUE
[17:39:56.023]                             break
[17:39:56.023]                           }
[17:39:56.023]                         }
[17:39:56.023]                       }
[17:39:56.023]                       invisible(muffled)
[17:39:56.023]                     }
[17:39:56.023]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.023]                   }
[17:39:56.023]                 }
[17:39:56.023]                 else {
[17:39:56.023]                   if (TRUE) {
[17:39:56.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.023]                     {
[17:39:56.023]                       inherits <- base::inherits
[17:39:56.023]                       invokeRestart <- base::invokeRestart
[17:39:56.023]                       is.null <- base::is.null
[17:39:56.023]                       muffled <- FALSE
[17:39:56.023]                       if (inherits(cond, "message")) {
[17:39:56.023]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.023]                         if (muffled) 
[17:39:56.023]                           invokeRestart("muffleMessage")
[17:39:56.023]                       }
[17:39:56.023]                       else if (inherits(cond, "warning")) {
[17:39:56.023]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.023]                         if (muffled) 
[17:39:56.023]                           invokeRestart("muffleWarning")
[17:39:56.023]                       }
[17:39:56.023]                       else if (inherits(cond, "condition")) {
[17:39:56.023]                         if (!is.null(pattern)) {
[17:39:56.023]                           computeRestarts <- base::computeRestarts
[17:39:56.023]                           grepl <- base::grepl
[17:39:56.023]                           restarts <- computeRestarts(cond)
[17:39:56.023]                           for (restart in restarts) {
[17:39:56.023]                             name <- restart$name
[17:39:56.023]                             if (is.null(name)) 
[17:39:56.023]                               next
[17:39:56.023]                             if (!grepl(pattern, name)) 
[17:39:56.023]                               next
[17:39:56.023]                             invokeRestart(restart)
[17:39:56.023]                             muffled <- TRUE
[17:39:56.023]                             break
[17:39:56.023]                           }
[17:39:56.023]                         }
[17:39:56.023]                       }
[17:39:56.023]                       invisible(muffled)
[17:39:56.023]                     }
[17:39:56.023]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.023]                   }
[17:39:56.023]                 }
[17:39:56.023]             }
[17:39:56.023]         }))
[17:39:56.023]     }, error = function(ex) {
[17:39:56.023]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.023]                 ...future.rng), started = ...future.startTime, 
[17:39:56.023]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.023]             version = "1.8"), class = "FutureResult")
[17:39:56.023]     }, finally = {
[17:39:56.023]         if (!identical(...future.workdir, getwd())) 
[17:39:56.023]             setwd(...future.workdir)
[17:39:56.023]         {
[17:39:56.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.023]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.023]             }
[17:39:56.023]             base::options(...future.oldOptions)
[17:39:56.023]             if (.Platform$OS.type == "windows") {
[17:39:56.023]                 old_names <- names(...future.oldEnvVars)
[17:39:56.023]                 envs <- base::Sys.getenv()
[17:39:56.023]                 names <- names(envs)
[17:39:56.023]                 common <- intersect(names, old_names)
[17:39:56.023]                 added <- setdiff(names, old_names)
[17:39:56.023]                 removed <- setdiff(old_names, names)
[17:39:56.023]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.023]                   envs[common]]
[17:39:56.023]                 NAMES <- toupper(changed)
[17:39:56.023]                 args <- list()
[17:39:56.023]                 for (kk in seq_along(NAMES)) {
[17:39:56.023]                   name <- changed[[kk]]
[17:39:56.023]                   NAME <- NAMES[[kk]]
[17:39:56.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.023]                     next
[17:39:56.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.023]                 }
[17:39:56.023]                 NAMES <- toupper(added)
[17:39:56.023]                 for (kk in seq_along(NAMES)) {
[17:39:56.023]                   name <- added[[kk]]
[17:39:56.023]                   NAME <- NAMES[[kk]]
[17:39:56.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.023]                     next
[17:39:56.023]                   args[[name]] <- ""
[17:39:56.023]                 }
[17:39:56.023]                 NAMES <- toupper(removed)
[17:39:56.023]                 for (kk in seq_along(NAMES)) {
[17:39:56.023]                   name <- removed[[kk]]
[17:39:56.023]                   NAME <- NAMES[[kk]]
[17:39:56.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.023]                     next
[17:39:56.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.023]                 }
[17:39:56.023]                 if (length(args) > 0) 
[17:39:56.023]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.023]             }
[17:39:56.023]             else {
[17:39:56.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.023]             }
[17:39:56.023]             {
[17:39:56.023]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.023]                   0L) {
[17:39:56.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.023]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.023]                   base::options(opts)
[17:39:56.023]                 }
[17:39:56.023]                 {
[17:39:56.023]                   {
[17:39:56.023]                     NULL
[17:39:56.023]                     RNGkind("Mersenne-Twister")
[17:39:56.023]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:56.023]                       inherits = FALSE)
[17:39:56.023]                   }
[17:39:56.023]                   options(future.plan = NULL)
[17:39:56.023]                   if (is.na(NA_character_)) 
[17:39:56.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.023]                     .init = FALSE)
[17:39:56.023]                 }
[17:39:56.023]             }
[17:39:56.023]         }
[17:39:56.023]     })
[17:39:56.023]     if (TRUE) {
[17:39:56.023]         base::sink(type = "output", split = FALSE)
[17:39:56.023]         if (TRUE) {
[17:39:56.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.023]         }
[17:39:56.023]         else {
[17:39:56.023]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.023]         }
[17:39:56.023]         base::close(...future.stdout)
[17:39:56.023]         ...future.stdout <- NULL
[17:39:56.023]     }
[17:39:56.023]     ...future.result$conditions <- ...future.conditions
[17:39:56.023]     ...future.result$finished <- base::Sys.time()
[17:39:56.023]     ...future.result
[17:39:56.023] }
[17:39:56.024] plan(): Setting new future strategy stack:
[17:39:56.024] List of future strategies:
[17:39:56.024] 1. sequential:
[17:39:56.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.024]    - tweaked: FALSE
[17:39:56.024]    - call: NULL
[17:39:56.025] plan(): nbrOfWorkers() = 1
[17:39:56.026] plan(): Setting new future strategy stack:
[17:39:56.026] List of future strategies:
[17:39:56.026] 1. sequential:
[17:39:56.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.026]    - tweaked: FALSE
[17:39:56.026]    - call: plan(strategy)
[17:39:56.026] plan(): nbrOfWorkers() = 1
[17:39:56.026] SequentialFuture started (and completed)
[17:39:56.026] - Launch lazy future ... done
[17:39:56.026] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.027] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.027] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.028] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:39:56.028] Searching for globals ... DONE
[17:39:56.029] Resolving globals: TRUE
[17:39:56.029] Resolving any globals that are futures ...
[17:39:56.029] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:39:56.029] Resolving any globals that are futures ... DONE
[17:39:56.029] Resolving futures part of globals (recursively) ...
[17:39:56.029] resolve() on list ...
[17:39:56.029]  recursive: 99
[17:39:56.029]  length: 1
[17:39:56.030]  elements: ‘x’
[17:39:56.030]  length: 0 (resolved future 1)
[17:39:56.030] resolve() on list ... DONE
[17:39:56.030] - globals: [1] ‘x’
[17:39:56.030] Resolving futures part of globals (recursively) ... DONE
[17:39:56.030] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.030] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:39:56.030] - globals: [1] ‘x’
[17:39:56.031] 
[17:39:56.031] getGlobalsAndPackages() ... DONE
[17:39:56.031] run() for ‘Future’ ...
[17:39:56.031] - state: ‘created’
[17:39:56.031] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:56.031] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:56.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:56.031]   - Field: ‘label’
[17:39:56.032]   - Field: ‘local’
[17:39:56.032]   - Field: ‘owner’
[17:39:56.032]   - Field: ‘envir’
[17:39:56.032]   - Field: ‘packages’
[17:39:56.032]   - Field: ‘gc’
[17:39:56.032]   - Field: ‘conditions’
[17:39:56.032]   - Field: ‘expr’
[17:39:56.032]   - Field: ‘uuid’
[17:39:56.032]   - Field: ‘seed’
[17:39:56.032]   - Field: ‘version’
[17:39:56.032]   - Field: ‘result’
[17:39:56.033]   - Field: ‘asynchronous’
[17:39:56.033]   - Field: ‘calls’
[17:39:56.033]   - Field: ‘globals’
[17:39:56.033]   - Field: ‘stdout’
[17:39:56.033]   - Field: ‘earlySignal’
[17:39:56.033]   - Field: ‘lazy’
[17:39:56.033]   - Field: ‘state’
[17:39:56.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:56.033] - Launch lazy future ...
[17:39:56.033] Packages needed by the future expression (n = 0): <none>
[17:39:56.033] Packages needed by future strategies (n = 0): <none>
[17:39:56.034] {
[17:39:56.034]     {
[17:39:56.034]         {
[17:39:56.034]             ...future.startTime <- base::Sys.time()
[17:39:56.034]             {
[17:39:56.034]                 {
[17:39:56.034]                   {
[17:39:56.034]                     base::local({
[17:39:56.034]                       has_future <- base::requireNamespace("future", 
[17:39:56.034]                         quietly = TRUE)
[17:39:56.034]                       if (has_future) {
[17:39:56.034]                         ns <- base::getNamespace("future")
[17:39:56.034]                         version <- ns[[".package"]][["version"]]
[17:39:56.034]                         if (is.null(version)) 
[17:39:56.034]                           version <- utils::packageVersion("future")
[17:39:56.034]                       }
[17:39:56.034]                       else {
[17:39:56.034]                         version <- NULL
[17:39:56.034]                       }
[17:39:56.034]                       if (!has_future || version < "1.8.0") {
[17:39:56.034]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.034]                           "", base::R.version$version.string), 
[17:39:56.034]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:56.034]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.034]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.034]                             "release", "version")], collapse = " "), 
[17:39:56.034]                           hostname = base::Sys.info()[["nodename"]])
[17:39:56.034]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.034]                           info)
[17:39:56.034]                         info <- base::paste(info, collapse = "; ")
[17:39:56.034]                         if (!has_future) {
[17:39:56.034]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.034]                             info)
[17:39:56.034]                         }
[17:39:56.034]                         else {
[17:39:56.034]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.034]                             info, version)
[17:39:56.034]                         }
[17:39:56.034]                         base::stop(msg)
[17:39:56.034]                       }
[17:39:56.034]                     })
[17:39:56.034]                   }
[17:39:56.034]                   ...future.strategy.old <- future::plan("list")
[17:39:56.034]                   options(future.plan = NULL)
[17:39:56.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.034]                 }
[17:39:56.034]                 ...future.workdir <- getwd()
[17:39:56.034]             }
[17:39:56.034]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.034]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.034]         }
[17:39:56.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.034]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.034]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.034]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.034]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.034]             base::names(...future.oldOptions))
[17:39:56.034]     }
[17:39:56.034]     if (FALSE) {
[17:39:56.034]     }
[17:39:56.034]     else {
[17:39:56.034]         if (TRUE) {
[17:39:56.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.034]                 open = "w")
[17:39:56.034]         }
[17:39:56.034]         else {
[17:39:56.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.034]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.034]         }
[17:39:56.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.034]             base::sink(type = "output", split = FALSE)
[17:39:56.034]             base::close(...future.stdout)
[17:39:56.034]         }, add = TRUE)
[17:39:56.034]     }
[17:39:56.034]     ...future.frame <- base::sys.nframe()
[17:39:56.034]     ...future.conditions <- base::list()
[17:39:56.034]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.034]     if (FALSE) {
[17:39:56.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.034]     }
[17:39:56.034]     ...future.result <- base::tryCatch({
[17:39:56.034]         base::withCallingHandlers({
[17:39:56.034]             ...future.value <- base::withVisible(base::local({
[17:39:56.034]                 x <- x + 1
[17:39:56.034]                 x
[17:39:56.034]             }))
[17:39:56.034]             future::FutureResult(value = ...future.value$value, 
[17:39:56.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.034]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.034]                     ...future.globalenv.names))
[17:39:56.034]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.034]         }, condition = base::local({
[17:39:56.034]             c <- base::c
[17:39:56.034]             inherits <- base::inherits
[17:39:56.034]             invokeRestart <- base::invokeRestart
[17:39:56.034]             length <- base::length
[17:39:56.034]             list <- base::list
[17:39:56.034]             seq.int <- base::seq.int
[17:39:56.034]             signalCondition <- base::signalCondition
[17:39:56.034]             sys.calls <- base::sys.calls
[17:39:56.034]             `[[` <- base::`[[`
[17:39:56.034]             `+` <- base::`+`
[17:39:56.034]             `<<-` <- base::`<<-`
[17:39:56.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.034]                   3L)]
[17:39:56.034]             }
[17:39:56.034]             function(cond) {
[17:39:56.034]                 is_error <- inherits(cond, "error")
[17:39:56.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.034]                   NULL)
[17:39:56.034]                 if (is_error) {
[17:39:56.034]                   sessionInformation <- function() {
[17:39:56.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.034]                       search = base::search(), system = base::Sys.info())
[17:39:56.034]                   }
[17:39:56.034]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.034]                     cond$call), session = sessionInformation(), 
[17:39:56.034]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.034]                   signalCondition(cond)
[17:39:56.034]                 }
[17:39:56.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.034]                 "immediateCondition"))) {
[17:39:56.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.034]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.034]                   if (TRUE && !signal) {
[17:39:56.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.034]                     {
[17:39:56.034]                       inherits <- base::inherits
[17:39:56.034]                       invokeRestart <- base::invokeRestart
[17:39:56.034]                       is.null <- base::is.null
[17:39:56.034]                       muffled <- FALSE
[17:39:56.034]                       if (inherits(cond, "message")) {
[17:39:56.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.034]                         if (muffled) 
[17:39:56.034]                           invokeRestart("muffleMessage")
[17:39:56.034]                       }
[17:39:56.034]                       else if (inherits(cond, "warning")) {
[17:39:56.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.034]                         if (muffled) 
[17:39:56.034]                           invokeRestart("muffleWarning")
[17:39:56.034]                       }
[17:39:56.034]                       else if (inherits(cond, "condition")) {
[17:39:56.034]                         if (!is.null(pattern)) {
[17:39:56.034]                           computeRestarts <- base::computeRestarts
[17:39:56.034]                           grepl <- base::grepl
[17:39:56.034]                           restarts <- computeRestarts(cond)
[17:39:56.034]                           for (restart in restarts) {
[17:39:56.034]                             name <- restart$name
[17:39:56.034]                             if (is.null(name)) 
[17:39:56.034]                               next
[17:39:56.034]                             if (!grepl(pattern, name)) 
[17:39:56.034]                               next
[17:39:56.034]                             invokeRestart(restart)
[17:39:56.034]                             muffled <- TRUE
[17:39:56.034]                             break
[17:39:56.034]                           }
[17:39:56.034]                         }
[17:39:56.034]                       }
[17:39:56.034]                       invisible(muffled)
[17:39:56.034]                     }
[17:39:56.034]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.034]                   }
[17:39:56.034]                 }
[17:39:56.034]                 else {
[17:39:56.034]                   if (TRUE) {
[17:39:56.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.034]                     {
[17:39:56.034]                       inherits <- base::inherits
[17:39:56.034]                       invokeRestart <- base::invokeRestart
[17:39:56.034]                       is.null <- base::is.null
[17:39:56.034]                       muffled <- FALSE
[17:39:56.034]                       if (inherits(cond, "message")) {
[17:39:56.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.034]                         if (muffled) 
[17:39:56.034]                           invokeRestart("muffleMessage")
[17:39:56.034]                       }
[17:39:56.034]                       else if (inherits(cond, "warning")) {
[17:39:56.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.034]                         if (muffled) 
[17:39:56.034]                           invokeRestart("muffleWarning")
[17:39:56.034]                       }
[17:39:56.034]                       else if (inherits(cond, "condition")) {
[17:39:56.034]                         if (!is.null(pattern)) {
[17:39:56.034]                           computeRestarts <- base::computeRestarts
[17:39:56.034]                           grepl <- base::grepl
[17:39:56.034]                           restarts <- computeRestarts(cond)
[17:39:56.034]                           for (restart in restarts) {
[17:39:56.034]                             name <- restart$name
[17:39:56.034]                             if (is.null(name)) 
[17:39:56.034]                               next
[17:39:56.034]                             if (!grepl(pattern, name)) 
[17:39:56.034]                               next
[17:39:56.034]                             invokeRestart(restart)
[17:39:56.034]                             muffled <- TRUE
[17:39:56.034]                             break
[17:39:56.034]                           }
[17:39:56.034]                         }
[17:39:56.034]                       }
[17:39:56.034]                       invisible(muffled)
[17:39:56.034]                     }
[17:39:56.034]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.034]                   }
[17:39:56.034]                 }
[17:39:56.034]             }
[17:39:56.034]         }))
[17:39:56.034]     }, error = function(ex) {
[17:39:56.034]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.034]                 ...future.rng), started = ...future.startTime, 
[17:39:56.034]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.034]             version = "1.8"), class = "FutureResult")
[17:39:56.034]     }, finally = {
[17:39:56.034]         if (!identical(...future.workdir, getwd())) 
[17:39:56.034]             setwd(...future.workdir)
[17:39:56.034]         {
[17:39:56.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.034]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.034]             }
[17:39:56.034]             base::options(...future.oldOptions)
[17:39:56.034]             if (.Platform$OS.type == "windows") {
[17:39:56.034]                 old_names <- names(...future.oldEnvVars)
[17:39:56.034]                 envs <- base::Sys.getenv()
[17:39:56.034]                 names <- names(envs)
[17:39:56.034]                 common <- intersect(names, old_names)
[17:39:56.034]                 added <- setdiff(names, old_names)
[17:39:56.034]                 removed <- setdiff(old_names, names)
[17:39:56.034]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.034]                   envs[common]]
[17:39:56.034]                 NAMES <- toupper(changed)
[17:39:56.034]                 args <- list()
[17:39:56.034]                 for (kk in seq_along(NAMES)) {
[17:39:56.034]                   name <- changed[[kk]]
[17:39:56.034]                   NAME <- NAMES[[kk]]
[17:39:56.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.034]                     next
[17:39:56.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.034]                 }
[17:39:56.034]                 NAMES <- toupper(added)
[17:39:56.034]                 for (kk in seq_along(NAMES)) {
[17:39:56.034]                   name <- added[[kk]]
[17:39:56.034]                   NAME <- NAMES[[kk]]
[17:39:56.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.034]                     next
[17:39:56.034]                   args[[name]] <- ""
[17:39:56.034]                 }
[17:39:56.034]                 NAMES <- toupper(removed)
[17:39:56.034]                 for (kk in seq_along(NAMES)) {
[17:39:56.034]                   name <- removed[[kk]]
[17:39:56.034]                   NAME <- NAMES[[kk]]
[17:39:56.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.034]                     next
[17:39:56.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.034]                 }
[17:39:56.034]                 if (length(args) > 0) 
[17:39:56.034]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.034]             }
[17:39:56.034]             else {
[17:39:56.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.034]             }
[17:39:56.034]             {
[17:39:56.034]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.034]                   0L) {
[17:39:56.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.034]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.034]                   base::options(opts)
[17:39:56.034]                 }
[17:39:56.034]                 {
[17:39:56.034]                   {
[17:39:56.034]                     NULL
[17:39:56.034]                     RNGkind("Mersenne-Twister")
[17:39:56.034]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:56.034]                       inherits = FALSE)
[17:39:56.034]                   }
[17:39:56.034]                   options(future.plan = NULL)
[17:39:56.034]                   if (is.na(NA_character_)) 
[17:39:56.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.034]                     .init = FALSE)
[17:39:56.034]                 }
[17:39:56.034]             }
[17:39:56.034]         }
[17:39:56.034]     })
[17:39:56.034]     if (TRUE) {
[17:39:56.034]         base::sink(type = "output", split = FALSE)
[17:39:56.034]         if (TRUE) {
[17:39:56.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.034]         }
[17:39:56.034]         else {
[17:39:56.034]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.034]         }
[17:39:56.034]         base::close(...future.stdout)
[17:39:56.034]         ...future.stdout <- NULL
[17:39:56.034]     }
[17:39:56.034]     ...future.result$conditions <- ...future.conditions
[17:39:56.034]     ...future.result$finished <- base::Sys.time()
[17:39:56.034]     ...future.result
[17:39:56.034] }
[17:39:56.035] assign_globals() ...
[17:39:56.035] List of 1
[17:39:56.035]  $ x: num 1
[17:39:56.035]  - attr(*, "where")=List of 1
[17:39:56.035]   ..$ x:<environment: R_EmptyEnv> 
[17:39:56.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.035]  - attr(*, "resolved")= logi TRUE
[17:39:56.035]  - attr(*, "total_size")= num 56
[17:39:56.035]  - attr(*, "already-done")= logi TRUE
[17:39:56.038] - copied ‘x’ to environment
[17:39:56.038] assign_globals() ... done
[17:39:56.038] plan(): Setting new future strategy stack:
[17:39:56.038] List of future strategies:
[17:39:56.038] 1. sequential:
[17:39:56.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.038]    - tweaked: FALSE
[17:39:56.038]    - call: NULL
[17:39:56.038] plan(): nbrOfWorkers() = 1
[17:39:56.039] plan(): Setting new future strategy stack:
[17:39:56.039] List of future strategies:
[17:39:56.039] 1. sequential:
[17:39:56.039]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.039]    - tweaked: FALSE
[17:39:56.039]    - call: plan(strategy)
[17:39:56.040] plan(): nbrOfWorkers() = 1
[17:39:56.040] SequentialFuture started (and completed)
[17:39:56.040] - Launch lazy future ... done
[17:39:56.040] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.040] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.041] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.042] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:39:56.042] Searching for globals ... DONE
[17:39:56.042] Resolving globals: TRUE
[17:39:56.042] Resolving any globals that are futures ...
[17:39:56.043] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:39:56.043] Resolving any globals that are futures ... DONE
[17:39:56.043] Resolving futures part of globals (recursively) ...
[17:39:56.043] resolve() on list ...
[17:39:56.043]  recursive: 99
[17:39:56.043]  length: 1
[17:39:56.043]  elements: ‘x’
[17:39:56.044]  length: 0 (resolved future 1)
[17:39:56.044] resolve() on list ... DONE
[17:39:56.044] - globals: [1] ‘x’
[17:39:56.044] Resolving futures part of globals (recursively) ... DONE
[17:39:56.044] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:39:56.044] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:39:56.044] - globals: [1] ‘x’
[17:39:56.044] 
[17:39:56.045] getGlobalsAndPackages() ... DONE
[17:39:56.045] run() for ‘Future’ ...
[17:39:56.045] - state: ‘created’
[17:39:56.045] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:56.045] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:56.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:56.045]   - Field: ‘label’
[17:39:56.045]   - Field: ‘local’
[17:39:56.046]   - Field: ‘owner’
[17:39:56.046]   - Field: ‘envir’
[17:39:56.046]   - Field: ‘packages’
[17:39:56.046]   - Field: ‘gc’
[17:39:56.046]   - Field: ‘conditions’
[17:39:56.046]   - Field: ‘expr’
[17:39:56.046]   - Field: ‘uuid’
[17:39:56.046]   - Field: ‘seed’
[17:39:56.046]   - Field: ‘version’
[17:39:56.046]   - Field: ‘result’
[17:39:56.046]   - Field: ‘asynchronous’
[17:39:56.047]   - Field: ‘calls’
[17:39:56.047]   - Field: ‘globals’
[17:39:56.048]   - Field: ‘stdout’
[17:39:56.048]   - Field: ‘earlySignal’
[17:39:56.048]   - Field: ‘lazy’
[17:39:56.048]   - Field: ‘state’
[17:39:56.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:56.048] - Launch lazy future ...
[17:39:56.048] Packages needed by the future expression (n = 0): <none>
[17:39:56.048] Packages needed by future strategies (n = 0): <none>
[17:39:56.049] {
[17:39:56.049]     {
[17:39:56.049]         {
[17:39:56.049]             ...future.startTime <- base::Sys.time()
[17:39:56.049]             {
[17:39:56.049]                 {
[17:39:56.049]                   {
[17:39:56.049]                     base::local({
[17:39:56.049]                       has_future <- base::requireNamespace("future", 
[17:39:56.049]                         quietly = TRUE)
[17:39:56.049]                       if (has_future) {
[17:39:56.049]                         ns <- base::getNamespace("future")
[17:39:56.049]                         version <- ns[[".package"]][["version"]]
[17:39:56.049]                         if (is.null(version)) 
[17:39:56.049]                           version <- utils::packageVersion("future")
[17:39:56.049]                       }
[17:39:56.049]                       else {
[17:39:56.049]                         version <- NULL
[17:39:56.049]                       }
[17:39:56.049]                       if (!has_future || version < "1.8.0") {
[17:39:56.049]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.049]                           "", base::R.version$version.string), 
[17:39:56.049]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:56.049]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.049]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.049]                             "release", "version")], collapse = " "), 
[17:39:56.049]                           hostname = base::Sys.info()[["nodename"]])
[17:39:56.049]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.049]                           info)
[17:39:56.049]                         info <- base::paste(info, collapse = "; ")
[17:39:56.049]                         if (!has_future) {
[17:39:56.049]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.049]                             info)
[17:39:56.049]                         }
[17:39:56.049]                         else {
[17:39:56.049]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.049]                             info, version)
[17:39:56.049]                         }
[17:39:56.049]                         base::stop(msg)
[17:39:56.049]                       }
[17:39:56.049]                     })
[17:39:56.049]                   }
[17:39:56.049]                   ...future.strategy.old <- future::plan("list")
[17:39:56.049]                   options(future.plan = NULL)
[17:39:56.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.049]                 }
[17:39:56.049]                 ...future.workdir <- getwd()
[17:39:56.049]             }
[17:39:56.049]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.049]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.049]         }
[17:39:56.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.049]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.049]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.049]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.049]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.049]             base::names(...future.oldOptions))
[17:39:56.049]     }
[17:39:56.049]     if (FALSE) {
[17:39:56.049]     }
[17:39:56.049]     else {
[17:39:56.049]         if (TRUE) {
[17:39:56.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.049]                 open = "w")
[17:39:56.049]         }
[17:39:56.049]         else {
[17:39:56.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.049]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.049]         }
[17:39:56.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.049]             base::sink(type = "output", split = FALSE)
[17:39:56.049]             base::close(...future.stdout)
[17:39:56.049]         }, add = TRUE)
[17:39:56.049]     }
[17:39:56.049]     ...future.frame <- base::sys.nframe()
[17:39:56.049]     ...future.conditions <- base::list()
[17:39:56.049]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.049]     if (FALSE) {
[17:39:56.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.049]     }
[17:39:56.049]     ...future.result <- base::tryCatch({
[17:39:56.049]         base::withCallingHandlers({
[17:39:56.049]             ...future.value <- base::withVisible(base::local({
[17:39:56.049]                 x <- x()
[17:39:56.049]                 x
[17:39:56.049]             }))
[17:39:56.049]             future::FutureResult(value = ...future.value$value, 
[17:39:56.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.049]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.049]                     ...future.globalenv.names))
[17:39:56.049]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.049]         }, condition = base::local({
[17:39:56.049]             c <- base::c
[17:39:56.049]             inherits <- base::inherits
[17:39:56.049]             invokeRestart <- base::invokeRestart
[17:39:56.049]             length <- base::length
[17:39:56.049]             list <- base::list
[17:39:56.049]             seq.int <- base::seq.int
[17:39:56.049]             signalCondition <- base::signalCondition
[17:39:56.049]             sys.calls <- base::sys.calls
[17:39:56.049]             `[[` <- base::`[[`
[17:39:56.049]             `+` <- base::`+`
[17:39:56.049]             `<<-` <- base::`<<-`
[17:39:56.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.049]                   3L)]
[17:39:56.049]             }
[17:39:56.049]             function(cond) {
[17:39:56.049]                 is_error <- inherits(cond, "error")
[17:39:56.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.049]                   NULL)
[17:39:56.049]                 if (is_error) {
[17:39:56.049]                   sessionInformation <- function() {
[17:39:56.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.049]                       search = base::search(), system = base::Sys.info())
[17:39:56.049]                   }
[17:39:56.049]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.049]                     cond$call), session = sessionInformation(), 
[17:39:56.049]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.049]                   signalCondition(cond)
[17:39:56.049]                 }
[17:39:56.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.049]                 "immediateCondition"))) {
[17:39:56.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.049]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.049]                   if (TRUE && !signal) {
[17:39:56.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.049]                     {
[17:39:56.049]                       inherits <- base::inherits
[17:39:56.049]                       invokeRestart <- base::invokeRestart
[17:39:56.049]                       is.null <- base::is.null
[17:39:56.049]                       muffled <- FALSE
[17:39:56.049]                       if (inherits(cond, "message")) {
[17:39:56.049]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.049]                         if (muffled) 
[17:39:56.049]                           invokeRestart("muffleMessage")
[17:39:56.049]                       }
[17:39:56.049]                       else if (inherits(cond, "warning")) {
[17:39:56.049]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.049]                         if (muffled) 
[17:39:56.049]                           invokeRestart("muffleWarning")
[17:39:56.049]                       }
[17:39:56.049]                       else if (inherits(cond, "condition")) {
[17:39:56.049]                         if (!is.null(pattern)) {
[17:39:56.049]                           computeRestarts <- base::computeRestarts
[17:39:56.049]                           grepl <- base::grepl
[17:39:56.049]                           restarts <- computeRestarts(cond)
[17:39:56.049]                           for (restart in restarts) {
[17:39:56.049]                             name <- restart$name
[17:39:56.049]                             if (is.null(name)) 
[17:39:56.049]                               next
[17:39:56.049]                             if (!grepl(pattern, name)) 
[17:39:56.049]                               next
[17:39:56.049]                             invokeRestart(restart)
[17:39:56.049]                             muffled <- TRUE
[17:39:56.049]                             break
[17:39:56.049]                           }
[17:39:56.049]                         }
[17:39:56.049]                       }
[17:39:56.049]                       invisible(muffled)
[17:39:56.049]                     }
[17:39:56.049]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.049]                   }
[17:39:56.049]                 }
[17:39:56.049]                 else {
[17:39:56.049]                   if (TRUE) {
[17:39:56.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.049]                     {
[17:39:56.049]                       inherits <- base::inherits
[17:39:56.049]                       invokeRestart <- base::invokeRestart
[17:39:56.049]                       is.null <- base::is.null
[17:39:56.049]                       muffled <- FALSE
[17:39:56.049]                       if (inherits(cond, "message")) {
[17:39:56.049]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.049]                         if (muffled) 
[17:39:56.049]                           invokeRestart("muffleMessage")
[17:39:56.049]                       }
[17:39:56.049]                       else if (inherits(cond, "warning")) {
[17:39:56.049]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.049]                         if (muffled) 
[17:39:56.049]                           invokeRestart("muffleWarning")
[17:39:56.049]                       }
[17:39:56.049]                       else if (inherits(cond, "condition")) {
[17:39:56.049]                         if (!is.null(pattern)) {
[17:39:56.049]                           computeRestarts <- base::computeRestarts
[17:39:56.049]                           grepl <- base::grepl
[17:39:56.049]                           restarts <- computeRestarts(cond)
[17:39:56.049]                           for (restart in restarts) {
[17:39:56.049]                             name <- restart$name
[17:39:56.049]                             if (is.null(name)) 
[17:39:56.049]                               next
[17:39:56.049]                             if (!grepl(pattern, name)) 
[17:39:56.049]                               next
[17:39:56.049]                             invokeRestart(restart)
[17:39:56.049]                             muffled <- TRUE
[17:39:56.049]                             break
[17:39:56.049]                           }
[17:39:56.049]                         }
[17:39:56.049]                       }
[17:39:56.049]                       invisible(muffled)
[17:39:56.049]                     }
[17:39:56.049]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.049]                   }
[17:39:56.049]                 }
[17:39:56.049]             }
[17:39:56.049]         }))
[17:39:56.049]     }, error = function(ex) {
[17:39:56.049]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.049]                 ...future.rng), started = ...future.startTime, 
[17:39:56.049]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.049]             version = "1.8"), class = "FutureResult")
[17:39:56.049]     }, finally = {
[17:39:56.049]         if (!identical(...future.workdir, getwd())) 
[17:39:56.049]             setwd(...future.workdir)
[17:39:56.049]         {
[17:39:56.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.049]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.049]             }
[17:39:56.049]             base::options(...future.oldOptions)
[17:39:56.049]             if (.Platform$OS.type == "windows") {
[17:39:56.049]                 old_names <- names(...future.oldEnvVars)
[17:39:56.049]                 envs <- base::Sys.getenv()
[17:39:56.049]                 names <- names(envs)
[17:39:56.049]                 common <- intersect(names, old_names)
[17:39:56.049]                 added <- setdiff(names, old_names)
[17:39:56.049]                 removed <- setdiff(old_names, names)
[17:39:56.049]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.049]                   envs[common]]
[17:39:56.049]                 NAMES <- toupper(changed)
[17:39:56.049]                 args <- list()
[17:39:56.049]                 for (kk in seq_along(NAMES)) {
[17:39:56.049]                   name <- changed[[kk]]
[17:39:56.049]                   NAME <- NAMES[[kk]]
[17:39:56.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.049]                     next
[17:39:56.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.049]                 }
[17:39:56.049]                 NAMES <- toupper(added)
[17:39:56.049]                 for (kk in seq_along(NAMES)) {
[17:39:56.049]                   name <- added[[kk]]
[17:39:56.049]                   NAME <- NAMES[[kk]]
[17:39:56.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.049]                     next
[17:39:56.049]                   args[[name]] <- ""
[17:39:56.049]                 }
[17:39:56.049]                 NAMES <- toupper(removed)
[17:39:56.049]                 for (kk in seq_along(NAMES)) {
[17:39:56.049]                   name <- removed[[kk]]
[17:39:56.049]                   NAME <- NAMES[[kk]]
[17:39:56.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.049]                     next
[17:39:56.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.049]                 }
[17:39:56.049]                 if (length(args) > 0) 
[17:39:56.049]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.049]             }
[17:39:56.049]             else {
[17:39:56.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.049]             }
[17:39:56.049]             {
[17:39:56.049]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.049]                   0L) {
[17:39:56.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.049]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.049]                   base::options(opts)
[17:39:56.049]                 }
[17:39:56.049]                 {
[17:39:56.049]                   {
[17:39:56.049]                     NULL
[17:39:56.049]                     RNGkind("Mersenne-Twister")
[17:39:56.049]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:56.049]                       inherits = FALSE)
[17:39:56.049]                   }
[17:39:56.049]                   options(future.plan = NULL)
[17:39:56.049]                   if (is.na(NA_character_)) 
[17:39:56.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.049]                     .init = FALSE)
[17:39:56.049]                 }
[17:39:56.049]             }
[17:39:56.049]         }
[17:39:56.049]     })
[17:39:56.049]     if (TRUE) {
[17:39:56.049]         base::sink(type = "output", split = FALSE)
[17:39:56.049]         if (TRUE) {
[17:39:56.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.049]         }
[17:39:56.049]         else {
[17:39:56.049]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.049]         }
[17:39:56.049]         base::close(...future.stdout)
[17:39:56.049]         ...future.stdout <- NULL
[17:39:56.049]     }
[17:39:56.049]     ...future.result$conditions <- ...future.conditions
[17:39:56.049]     ...future.result$finished <- base::Sys.time()
[17:39:56.049]     ...future.result
[17:39:56.049] }
[17:39:56.050] assign_globals() ...
[17:39:56.050] List of 1
[17:39:56.050]  $ x:function ()  
[17:39:56.050]  - attr(*, "where")=List of 1
[17:39:56.050]   ..$ x:<environment: R_EmptyEnv> 
[17:39:56.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.050]  - attr(*, "resolved")= logi TRUE
[17:39:56.050]  - attr(*, "total_size")= num 1032
[17:39:56.050]  - attr(*, "already-done")= logi TRUE
[17:39:56.053] - reassign environment for ‘x’
[17:39:56.053] - copied ‘x’ to environment
[17:39:56.053] assign_globals() ... done
[17:39:56.053] plan(): Setting new future strategy stack:
[17:39:56.053] List of future strategies:
[17:39:56.053] 1. sequential:
[17:39:56.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.053]    - tweaked: FALSE
[17:39:56.053]    - call: NULL
[17:39:56.054] plan(): nbrOfWorkers() = 1
[17:39:56.054] plan(): Setting new future strategy stack:
[17:39:56.054] List of future strategies:
[17:39:56.054] 1. sequential:
[17:39:56.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.054]    - tweaked: FALSE
[17:39:56.054]    - call: plan(strategy)
[17:39:56.055] plan(): nbrOfWorkers() = 1
[17:39:56.055] SequentialFuture started (and completed)
[17:39:56.055] - Launch lazy future ... done
[17:39:56.055] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[17:39:56.064] plan(): Setting new future strategy stack:
[17:39:56.064] List of future strategies:
[17:39:56.064] 1. multicore:
[17:39:56.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.064]    - tweaked: FALSE
[17:39:56.064]    - call: plan(strategy)
[17:39:56.068] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.068] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.068] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.069] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:39:56.070] Searching for globals ... DONE
[17:39:56.070] Resolving globals: TRUE
[17:39:56.070] Resolving any globals that are futures ...
[17:39:56.070] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:39:56.070] Resolving any globals that are futures ... DONE
[17:39:56.070] 
[17:39:56.070] 
[17:39:56.070] getGlobalsAndPackages() ... DONE
[17:39:56.071] run() for ‘Future’ ...
[17:39:56.071] - state: ‘created’
[17:39:56.071] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.074] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.075]   - Field: ‘label’
[17:39:56.075]   - Field: ‘local’
[17:39:56.075]   - Field: ‘owner’
[17:39:56.075]   - Field: ‘envir’
[17:39:56.075]   - Field: ‘workers’
[17:39:56.075]   - Field: ‘packages’
[17:39:56.075]   - Field: ‘gc’
[17:39:56.075]   - Field: ‘job’
[17:39:56.075]   - Field: ‘conditions’
[17:39:56.075]   - Field: ‘expr’
[17:39:56.075]   - Field: ‘uuid’
[17:39:56.076]   - Field: ‘seed’
[17:39:56.076]   - Field: ‘version’
[17:39:56.076]   - Field: ‘result’
[17:39:56.076]   - Field: ‘asynchronous’
[17:39:56.076]   - Field: ‘calls’
[17:39:56.076]   - Field: ‘globals’
[17:39:56.076]   - Field: ‘stdout’
[17:39:56.076]   - Field: ‘earlySignal’
[17:39:56.076]   - Field: ‘lazy’
[17:39:56.076]   - Field: ‘state’
[17:39:56.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.077] - Launch lazy future ...
[17:39:56.077] Packages needed by the future expression (n = 0): <none>
[17:39:56.078] Packages needed by future strategies (n = 0): <none>
[17:39:56.078] {
[17:39:56.078]     {
[17:39:56.078]         {
[17:39:56.078]             ...future.startTime <- base::Sys.time()
[17:39:56.078]             {
[17:39:56.078]                 {
[17:39:56.078]                   {
[17:39:56.078]                     {
[17:39:56.078]                       base::local({
[17:39:56.078]                         has_future <- base::requireNamespace("future", 
[17:39:56.078]                           quietly = TRUE)
[17:39:56.078]                         if (has_future) {
[17:39:56.078]                           ns <- base::getNamespace("future")
[17:39:56.078]                           version <- ns[[".package"]][["version"]]
[17:39:56.078]                           if (is.null(version)) 
[17:39:56.078]                             version <- utils::packageVersion("future")
[17:39:56.078]                         }
[17:39:56.078]                         else {
[17:39:56.078]                           version <- NULL
[17:39:56.078]                         }
[17:39:56.078]                         if (!has_future || version < "1.8.0") {
[17:39:56.078]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.078]                             "", base::R.version$version.string), 
[17:39:56.078]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.078]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.078]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.078]                               "release", "version")], collapse = " "), 
[17:39:56.078]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.078]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.078]                             info)
[17:39:56.078]                           info <- base::paste(info, collapse = "; ")
[17:39:56.078]                           if (!has_future) {
[17:39:56.078]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.078]                               info)
[17:39:56.078]                           }
[17:39:56.078]                           else {
[17:39:56.078]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.078]                               info, version)
[17:39:56.078]                           }
[17:39:56.078]                           base::stop(msg)
[17:39:56.078]                         }
[17:39:56.078]                       })
[17:39:56.078]                     }
[17:39:56.078]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.078]                     base::options(mc.cores = 1L)
[17:39:56.078]                   }
[17:39:56.078]                   ...future.strategy.old <- future::plan("list")
[17:39:56.078]                   options(future.plan = NULL)
[17:39:56.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.078]                 }
[17:39:56.078]                 ...future.workdir <- getwd()
[17:39:56.078]             }
[17:39:56.078]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.078]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.078]         }
[17:39:56.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.078]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.078]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.078]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.078]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.078]             base::names(...future.oldOptions))
[17:39:56.078]     }
[17:39:56.078]     if (FALSE) {
[17:39:56.078]     }
[17:39:56.078]     else {
[17:39:56.078]         if (TRUE) {
[17:39:56.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.078]                 open = "w")
[17:39:56.078]         }
[17:39:56.078]         else {
[17:39:56.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.078]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.078]         }
[17:39:56.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.078]             base::sink(type = "output", split = FALSE)
[17:39:56.078]             base::close(...future.stdout)
[17:39:56.078]         }, add = TRUE)
[17:39:56.078]     }
[17:39:56.078]     ...future.frame <- base::sys.nframe()
[17:39:56.078]     ...future.conditions <- base::list()
[17:39:56.078]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.078]     if (FALSE) {
[17:39:56.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.078]     }
[17:39:56.078]     ...future.result <- base::tryCatch({
[17:39:56.078]         base::withCallingHandlers({
[17:39:56.078]             ...future.value <- base::withVisible(base::local({
[17:39:56.078]                 withCallingHandlers({
[17:39:56.078]                   {
[17:39:56.078]                     b <- a
[17:39:56.078]                     a <- 2
[17:39:56.078]                     a * b
[17:39:56.078]                   }
[17:39:56.078]                 }, immediateCondition = function(cond) {
[17:39:56.078]                   save_rds <- function (object, pathname, ...) 
[17:39:56.078]                   {
[17:39:56.078]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.078]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.078]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.078]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.078]                         fi_tmp[["mtime"]])
[17:39:56.078]                     }
[17:39:56.078]                     tryCatch({
[17:39:56.078]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.078]                     }, error = function(ex) {
[17:39:56.078]                       msg <- conditionMessage(ex)
[17:39:56.078]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.078]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.078]                         fi_tmp[["mtime"]], msg)
[17:39:56.078]                       ex$message <- msg
[17:39:56.078]                       stop(ex)
[17:39:56.078]                     })
[17:39:56.078]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.078]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.078]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.078]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.078]                       fi <- file.info(pathname)
[17:39:56.078]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.078]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.078]                         fi[["size"]], fi[["mtime"]])
[17:39:56.078]                       stop(msg)
[17:39:56.078]                     }
[17:39:56.078]                     invisible(pathname)
[17:39:56.078]                   }
[17:39:56.078]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.078]                     rootPath = tempdir()) 
[17:39:56.078]                   {
[17:39:56.078]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.078]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.078]                       tmpdir = path, fileext = ".rds")
[17:39:56.078]                     save_rds(obj, file)
[17:39:56.078]                   }
[17:39:56.078]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.078]                   {
[17:39:56.078]                     inherits <- base::inherits
[17:39:56.078]                     invokeRestart <- base::invokeRestart
[17:39:56.078]                     is.null <- base::is.null
[17:39:56.078]                     muffled <- FALSE
[17:39:56.078]                     if (inherits(cond, "message")) {
[17:39:56.078]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.078]                       if (muffled) 
[17:39:56.078]                         invokeRestart("muffleMessage")
[17:39:56.078]                     }
[17:39:56.078]                     else if (inherits(cond, "warning")) {
[17:39:56.078]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.078]                       if (muffled) 
[17:39:56.078]                         invokeRestart("muffleWarning")
[17:39:56.078]                     }
[17:39:56.078]                     else if (inherits(cond, "condition")) {
[17:39:56.078]                       if (!is.null(pattern)) {
[17:39:56.078]                         computeRestarts <- base::computeRestarts
[17:39:56.078]                         grepl <- base::grepl
[17:39:56.078]                         restarts <- computeRestarts(cond)
[17:39:56.078]                         for (restart in restarts) {
[17:39:56.078]                           name <- restart$name
[17:39:56.078]                           if (is.null(name)) 
[17:39:56.078]                             next
[17:39:56.078]                           if (!grepl(pattern, name)) 
[17:39:56.078]                             next
[17:39:56.078]                           invokeRestart(restart)
[17:39:56.078]                           muffled <- TRUE
[17:39:56.078]                           break
[17:39:56.078]                         }
[17:39:56.078]                       }
[17:39:56.078]                     }
[17:39:56.078]                     invisible(muffled)
[17:39:56.078]                   }
[17:39:56.078]                   muffleCondition(cond)
[17:39:56.078]                 })
[17:39:56.078]             }))
[17:39:56.078]             future::FutureResult(value = ...future.value$value, 
[17:39:56.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.078]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.078]                     ...future.globalenv.names))
[17:39:56.078]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.078]         }, condition = base::local({
[17:39:56.078]             c <- base::c
[17:39:56.078]             inherits <- base::inherits
[17:39:56.078]             invokeRestart <- base::invokeRestart
[17:39:56.078]             length <- base::length
[17:39:56.078]             list <- base::list
[17:39:56.078]             seq.int <- base::seq.int
[17:39:56.078]             signalCondition <- base::signalCondition
[17:39:56.078]             sys.calls <- base::sys.calls
[17:39:56.078]             `[[` <- base::`[[`
[17:39:56.078]             `+` <- base::`+`
[17:39:56.078]             `<<-` <- base::`<<-`
[17:39:56.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.078]                   3L)]
[17:39:56.078]             }
[17:39:56.078]             function(cond) {
[17:39:56.078]                 is_error <- inherits(cond, "error")
[17:39:56.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.078]                   NULL)
[17:39:56.078]                 if (is_error) {
[17:39:56.078]                   sessionInformation <- function() {
[17:39:56.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.078]                       search = base::search(), system = base::Sys.info())
[17:39:56.078]                   }
[17:39:56.078]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.078]                     cond$call), session = sessionInformation(), 
[17:39:56.078]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.078]                   signalCondition(cond)
[17:39:56.078]                 }
[17:39:56.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.078]                 "immediateCondition"))) {
[17:39:56.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.078]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.078]                   if (TRUE && !signal) {
[17:39:56.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.078]                     {
[17:39:56.078]                       inherits <- base::inherits
[17:39:56.078]                       invokeRestart <- base::invokeRestart
[17:39:56.078]                       is.null <- base::is.null
[17:39:56.078]                       muffled <- FALSE
[17:39:56.078]                       if (inherits(cond, "message")) {
[17:39:56.078]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.078]                         if (muffled) 
[17:39:56.078]                           invokeRestart("muffleMessage")
[17:39:56.078]                       }
[17:39:56.078]                       else if (inherits(cond, "warning")) {
[17:39:56.078]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.078]                         if (muffled) 
[17:39:56.078]                           invokeRestart("muffleWarning")
[17:39:56.078]                       }
[17:39:56.078]                       else if (inherits(cond, "condition")) {
[17:39:56.078]                         if (!is.null(pattern)) {
[17:39:56.078]                           computeRestarts <- base::computeRestarts
[17:39:56.078]                           grepl <- base::grepl
[17:39:56.078]                           restarts <- computeRestarts(cond)
[17:39:56.078]                           for (restart in restarts) {
[17:39:56.078]                             name <- restart$name
[17:39:56.078]                             if (is.null(name)) 
[17:39:56.078]                               next
[17:39:56.078]                             if (!grepl(pattern, name)) 
[17:39:56.078]                               next
[17:39:56.078]                             invokeRestart(restart)
[17:39:56.078]                             muffled <- TRUE
[17:39:56.078]                             break
[17:39:56.078]                           }
[17:39:56.078]                         }
[17:39:56.078]                       }
[17:39:56.078]                       invisible(muffled)
[17:39:56.078]                     }
[17:39:56.078]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.078]                   }
[17:39:56.078]                 }
[17:39:56.078]                 else {
[17:39:56.078]                   if (TRUE) {
[17:39:56.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.078]                     {
[17:39:56.078]                       inherits <- base::inherits
[17:39:56.078]                       invokeRestart <- base::invokeRestart
[17:39:56.078]                       is.null <- base::is.null
[17:39:56.078]                       muffled <- FALSE
[17:39:56.078]                       if (inherits(cond, "message")) {
[17:39:56.078]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.078]                         if (muffled) 
[17:39:56.078]                           invokeRestart("muffleMessage")
[17:39:56.078]                       }
[17:39:56.078]                       else if (inherits(cond, "warning")) {
[17:39:56.078]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.078]                         if (muffled) 
[17:39:56.078]                           invokeRestart("muffleWarning")
[17:39:56.078]                       }
[17:39:56.078]                       else if (inherits(cond, "condition")) {
[17:39:56.078]                         if (!is.null(pattern)) {
[17:39:56.078]                           computeRestarts <- base::computeRestarts
[17:39:56.078]                           grepl <- base::grepl
[17:39:56.078]                           restarts <- computeRestarts(cond)
[17:39:56.078]                           for (restart in restarts) {
[17:39:56.078]                             name <- restart$name
[17:39:56.078]                             if (is.null(name)) 
[17:39:56.078]                               next
[17:39:56.078]                             if (!grepl(pattern, name)) 
[17:39:56.078]                               next
[17:39:56.078]                             invokeRestart(restart)
[17:39:56.078]                             muffled <- TRUE
[17:39:56.078]                             break
[17:39:56.078]                           }
[17:39:56.078]                         }
[17:39:56.078]                       }
[17:39:56.078]                       invisible(muffled)
[17:39:56.078]                     }
[17:39:56.078]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.078]                   }
[17:39:56.078]                 }
[17:39:56.078]             }
[17:39:56.078]         }))
[17:39:56.078]     }, error = function(ex) {
[17:39:56.078]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.078]                 ...future.rng), started = ...future.startTime, 
[17:39:56.078]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.078]             version = "1.8"), class = "FutureResult")
[17:39:56.078]     }, finally = {
[17:39:56.078]         if (!identical(...future.workdir, getwd())) 
[17:39:56.078]             setwd(...future.workdir)
[17:39:56.078]         {
[17:39:56.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.078]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.078]             }
[17:39:56.078]             base::options(...future.oldOptions)
[17:39:56.078]             if (.Platform$OS.type == "windows") {
[17:39:56.078]                 old_names <- names(...future.oldEnvVars)
[17:39:56.078]                 envs <- base::Sys.getenv()
[17:39:56.078]                 names <- names(envs)
[17:39:56.078]                 common <- intersect(names, old_names)
[17:39:56.078]                 added <- setdiff(names, old_names)
[17:39:56.078]                 removed <- setdiff(old_names, names)
[17:39:56.078]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.078]                   envs[common]]
[17:39:56.078]                 NAMES <- toupper(changed)
[17:39:56.078]                 args <- list()
[17:39:56.078]                 for (kk in seq_along(NAMES)) {
[17:39:56.078]                   name <- changed[[kk]]
[17:39:56.078]                   NAME <- NAMES[[kk]]
[17:39:56.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.078]                     next
[17:39:56.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.078]                 }
[17:39:56.078]                 NAMES <- toupper(added)
[17:39:56.078]                 for (kk in seq_along(NAMES)) {
[17:39:56.078]                   name <- added[[kk]]
[17:39:56.078]                   NAME <- NAMES[[kk]]
[17:39:56.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.078]                     next
[17:39:56.078]                   args[[name]] <- ""
[17:39:56.078]                 }
[17:39:56.078]                 NAMES <- toupper(removed)
[17:39:56.078]                 for (kk in seq_along(NAMES)) {
[17:39:56.078]                   name <- removed[[kk]]
[17:39:56.078]                   NAME <- NAMES[[kk]]
[17:39:56.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.078]                     next
[17:39:56.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.078]                 }
[17:39:56.078]                 if (length(args) > 0) 
[17:39:56.078]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.078]             }
[17:39:56.078]             else {
[17:39:56.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.078]             }
[17:39:56.078]             {
[17:39:56.078]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.078]                   0L) {
[17:39:56.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.078]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.078]                   base::options(opts)
[17:39:56.078]                 }
[17:39:56.078]                 {
[17:39:56.078]                   {
[17:39:56.078]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.078]                     NULL
[17:39:56.078]                   }
[17:39:56.078]                   options(future.plan = NULL)
[17:39:56.078]                   if (is.na(NA_character_)) 
[17:39:56.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.078]                     .init = FALSE)
[17:39:56.078]                 }
[17:39:56.078]             }
[17:39:56.078]         }
[17:39:56.078]     })
[17:39:56.078]     if (TRUE) {
[17:39:56.078]         base::sink(type = "output", split = FALSE)
[17:39:56.078]         if (TRUE) {
[17:39:56.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.078]         }
[17:39:56.078]         else {
[17:39:56.078]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.078]         }
[17:39:56.078]         base::close(...future.stdout)
[17:39:56.078]         ...future.stdout <- NULL
[17:39:56.078]     }
[17:39:56.078]     ...future.result$conditions <- ...future.conditions
[17:39:56.078]     ...future.result$finished <- base::Sys.time()
[17:39:56.078]     ...future.result
[17:39:56.078] }
[17:39:56.080] requestCore(): workers = 2
[17:39:56.083] MulticoreFuture started
[17:39:56.083] - Launch lazy future ... done
[17:39:56.084] plan(): Setting new future strategy stack:
[17:39:56.084] run() for ‘MulticoreFuture’ ... done
[17:39:56.084] List of future strategies:
[17:39:56.084] 1. sequential:
[17:39:56.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.084]    - tweaked: FALSE
[17:39:56.084]    - call: NULL
[17:39:56.085] result() for MulticoreFuture ...
[17:39:56.085] plan(): nbrOfWorkers() = 1
[17:39:56.093] plan(): Setting new future strategy stack:
[17:39:56.093] List of future strategies:
[17:39:56.093] 1. multicore:
[17:39:56.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.093]    - tweaked: FALSE
[17:39:56.093]    - call: plan(strategy)
[17:39:56.099] plan(): nbrOfWorkers() = 2
[17:39:56.105] result() for MulticoreFuture ...
[17:39:56.105] result() for MulticoreFuture ... done
[17:39:56.105] result() for MulticoreFuture ... done
[17:39:56.105] result() for MulticoreFuture ...
[17:39:56.106] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.106] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.106] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.108] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:39:56.108] Searching for globals ... DONE
[17:39:56.108] Resolving globals: TRUE
[17:39:56.108] Resolving any globals that are futures ...
[17:39:56.109] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:39:56.109] Resolving any globals that are futures ... DONE
[17:39:56.109] 
[17:39:56.109] 
[17:39:56.109] getGlobalsAndPackages() ... DONE
[17:39:56.110] run() for ‘Future’ ...
[17:39:56.110] - state: ‘created’
[17:39:56.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.114] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.114]   - Field: ‘label’
[17:39:56.114]   - Field: ‘local’
[17:39:56.114]   - Field: ‘owner’
[17:39:56.114]   - Field: ‘envir’
[17:39:56.115]   - Field: ‘workers’
[17:39:56.115]   - Field: ‘packages’
[17:39:56.115]   - Field: ‘gc’
[17:39:56.115]   - Field: ‘job’
[17:39:56.115]   - Field: ‘conditions’
[17:39:56.115]   - Field: ‘expr’
[17:39:56.115]   - Field: ‘uuid’
[17:39:56.115]   - Field: ‘seed’
[17:39:56.115]   - Field: ‘version’
[17:39:56.116]   - Field: ‘result’
[17:39:56.116]   - Field: ‘asynchronous’
[17:39:56.116]   - Field: ‘calls’
[17:39:56.116]   - Field: ‘globals’
[17:39:56.116]   - Field: ‘stdout’
[17:39:56.116]   - Field: ‘earlySignal’
[17:39:56.116]   - Field: ‘lazy’
[17:39:56.116]   - Field: ‘state’
[17:39:56.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.117] - Launch lazy future ...
[17:39:56.117] Packages needed by the future expression (n = 0): <none>
[17:39:56.117] Packages needed by future strategies (n = 0): <none>
[17:39:56.117] {
[17:39:56.117]     {
[17:39:56.117]         {
[17:39:56.117]             ...future.startTime <- base::Sys.time()
[17:39:56.117]             {
[17:39:56.117]                 {
[17:39:56.117]                   {
[17:39:56.117]                     {
[17:39:56.117]                       base::local({
[17:39:56.117]                         has_future <- base::requireNamespace("future", 
[17:39:56.117]                           quietly = TRUE)
[17:39:56.117]                         if (has_future) {
[17:39:56.117]                           ns <- base::getNamespace("future")
[17:39:56.117]                           version <- ns[[".package"]][["version"]]
[17:39:56.117]                           if (is.null(version)) 
[17:39:56.117]                             version <- utils::packageVersion("future")
[17:39:56.117]                         }
[17:39:56.117]                         else {
[17:39:56.117]                           version <- NULL
[17:39:56.117]                         }
[17:39:56.117]                         if (!has_future || version < "1.8.0") {
[17:39:56.117]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.117]                             "", base::R.version$version.string), 
[17:39:56.117]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.117]                               "release", "version")], collapse = " "), 
[17:39:56.117]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.117]                             info)
[17:39:56.117]                           info <- base::paste(info, collapse = "; ")
[17:39:56.117]                           if (!has_future) {
[17:39:56.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.117]                               info)
[17:39:56.117]                           }
[17:39:56.117]                           else {
[17:39:56.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.117]                               info, version)
[17:39:56.117]                           }
[17:39:56.117]                           base::stop(msg)
[17:39:56.117]                         }
[17:39:56.117]                       })
[17:39:56.117]                     }
[17:39:56.117]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.117]                     base::options(mc.cores = 1L)
[17:39:56.117]                   }
[17:39:56.117]                   ...future.strategy.old <- future::plan("list")
[17:39:56.117]                   options(future.plan = NULL)
[17:39:56.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.117]                 }
[17:39:56.117]                 ...future.workdir <- getwd()
[17:39:56.117]             }
[17:39:56.117]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.117]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.117]         }
[17:39:56.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.117]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.117]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.117]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.117]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.117]             base::names(...future.oldOptions))
[17:39:56.117]     }
[17:39:56.117]     if (FALSE) {
[17:39:56.117]     }
[17:39:56.117]     else {
[17:39:56.117]         if (TRUE) {
[17:39:56.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.117]                 open = "w")
[17:39:56.117]         }
[17:39:56.117]         else {
[17:39:56.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.117]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.117]         }
[17:39:56.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.117]             base::sink(type = "output", split = FALSE)
[17:39:56.117]             base::close(...future.stdout)
[17:39:56.117]         }, add = TRUE)
[17:39:56.117]     }
[17:39:56.117]     ...future.frame <- base::sys.nframe()
[17:39:56.117]     ...future.conditions <- base::list()
[17:39:56.117]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.117]     if (FALSE) {
[17:39:56.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.117]     }
[17:39:56.117]     ...future.result <- base::tryCatch({
[17:39:56.117]         base::withCallingHandlers({
[17:39:56.117]             ...future.value <- base::withVisible(base::local({
[17:39:56.117]                 withCallingHandlers({
[17:39:56.117]                   {
[17:39:56.117]                     b <- a
[17:39:56.117]                     a <- 2
[17:39:56.117]                     a * b
[17:39:56.117]                   }
[17:39:56.117]                 }, immediateCondition = function(cond) {
[17:39:56.117]                   save_rds <- function (object, pathname, ...) 
[17:39:56.117]                   {
[17:39:56.117]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.117]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.117]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.117]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.117]                         fi_tmp[["mtime"]])
[17:39:56.117]                     }
[17:39:56.117]                     tryCatch({
[17:39:56.117]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.117]                     }, error = function(ex) {
[17:39:56.117]                       msg <- conditionMessage(ex)
[17:39:56.117]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.117]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.117]                         fi_tmp[["mtime"]], msg)
[17:39:56.117]                       ex$message <- msg
[17:39:56.117]                       stop(ex)
[17:39:56.117]                     })
[17:39:56.117]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.117]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.117]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.117]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.117]                       fi <- file.info(pathname)
[17:39:56.117]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.117]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.117]                         fi[["size"]], fi[["mtime"]])
[17:39:56.117]                       stop(msg)
[17:39:56.117]                     }
[17:39:56.117]                     invisible(pathname)
[17:39:56.117]                   }
[17:39:56.117]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.117]                     rootPath = tempdir()) 
[17:39:56.117]                   {
[17:39:56.117]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.117]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.117]                       tmpdir = path, fileext = ".rds")
[17:39:56.117]                     save_rds(obj, file)
[17:39:56.117]                   }
[17:39:56.117]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.117]                   {
[17:39:56.117]                     inherits <- base::inherits
[17:39:56.117]                     invokeRestart <- base::invokeRestart
[17:39:56.117]                     is.null <- base::is.null
[17:39:56.117]                     muffled <- FALSE
[17:39:56.117]                     if (inherits(cond, "message")) {
[17:39:56.117]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.117]                       if (muffled) 
[17:39:56.117]                         invokeRestart("muffleMessage")
[17:39:56.117]                     }
[17:39:56.117]                     else if (inherits(cond, "warning")) {
[17:39:56.117]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.117]                       if (muffled) 
[17:39:56.117]                         invokeRestart("muffleWarning")
[17:39:56.117]                     }
[17:39:56.117]                     else if (inherits(cond, "condition")) {
[17:39:56.117]                       if (!is.null(pattern)) {
[17:39:56.117]                         computeRestarts <- base::computeRestarts
[17:39:56.117]                         grepl <- base::grepl
[17:39:56.117]                         restarts <- computeRestarts(cond)
[17:39:56.117]                         for (restart in restarts) {
[17:39:56.117]                           name <- restart$name
[17:39:56.117]                           if (is.null(name)) 
[17:39:56.117]                             next
[17:39:56.117]                           if (!grepl(pattern, name)) 
[17:39:56.117]                             next
[17:39:56.117]                           invokeRestart(restart)
[17:39:56.117]                           muffled <- TRUE
[17:39:56.117]                           break
[17:39:56.117]                         }
[17:39:56.117]                       }
[17:39:56.117]                     }
[17:39:56.117]                     invisible(muffled)
[17:39:56.117]                   }
[17:39:56.117]                   muffleCondition(cond)
[17:39:56.117]                 })
[17:39:56.117]             }))
[17:39:56.117]             future::FutureResult(value = ...future.value$value, 
[17:39:56.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.117]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.117]                     ...future.globalenv.names))
[17:39:56.117]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.117]         }, condition = base::local({
[17:39:56.117]             c <- base::c
[17:39:56.117]             inherits <- base::inherits
[17:39:56.117]             invokeRestart <- base::invokeRestart
[17:39:56.117]             length <- base::length
[17:39:56.117]             list <- base::list
[17:39:56.117]             seq.int <- base::seq.int
[17:39:56.117]             signalCondition <- base::signalCondition
[17:39:56.117]             sys.calls <- base::sys.calls
[17:39:56.117]             `[[` <- base::`[[`
[17:39:56.117]             `+` <- base::`+`
[17:39:56.117]             `<<-` <- base::`<<-`
[17:39:56.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.117]                   3L)]
[17:39:56.117]             }
[17:39:56.117]             function(cond) {
[17:39:56.117]                 is_error <- inherits(cond, "error")
[17:39:56.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.117]                   NULL)
[17:39:56.117]                 if (is_error) {
[17:39:56.117]                   sessionInformation <- function() {
[17:39:56.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.117]                       search = base::search(), system = base::Sys.info())
[17:39:56.117]                   }
[17:39:56.117]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.117]                     cond$call), session = sessionInformation(), 
[17:39:56.117]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.117]                   signalCondition(cond)
[17:39:56.117]                 }
[17:39:56.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.117]                 "immediateCondition"))) {
[17:39:56.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.117]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.117]                   if (TRUE && !signal) {
[17:39:56.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.117]                     {
[17:39:56.117]                       inherits <- base::inherits
[17:39:56.117]                       invokeRestart <- base::invokeRestart
[17:39:56.117]                       is.null <- base::is.null
[17:39:56.117]                       muffled <- FALSE
[17:39:56.117]                       if (inherits(cond, "message")) {
[17:39:56.117]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.117]                         if (muffled) 
[17:39:56.117]                           invokeRestart("muffleMessage")
[17:39:56.117]                       }
[17:39:56.117]                       else if (inherits(cond, "warning")) {
[17:39:56.117]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.117]                         if (muffled) 
[17:39:56.117]                           invokeRestart("muffleWarning")
[17:39:56.117]                       }
[17:39:56.117]                       else if (inherits(cond, "condition")) {
[17:39:56.117]                         if (!is.null(pattern)) {
[17:39:56.117]                           computeRestarts <- base::computeRestarts
[17:39:56.117]                           grepl <- base::grepl
[17:39:56.117]                           restarts <- computeRestarts(cond)
[17:39:56.117]                           for (restart in restarts) {
[17:39:56.117]                             name <- restart$name
[17:39:56.117]                             if (is.null(name)) 
[17:39:56.117]                               next
[17:39:56.117]                             if (!grepl(pattern, name)) 
[17:39:56.117]                               next
[17:39:56.117]                             invokeRestart(restart)
[17:39:56.117]                             muffled <- TRUE
[17:39:56.117]                             break
[17:39:56.117]                           }
[17:39:56.117]                         }
[17:39:56.117]                       }
[17:39:56.117]                       invisible(muffled)
[17:39:56.117]                     }
[17:39:56.117]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.117]                   }
[17:39:56.117]                 }
[17:39:56.117]                 else {
[17:39:56.117]                   if (TRUE) {
[17:39:56.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.117]                     {
[17:39:56.117]                       inherits <- base::inherits
[17:39:56.117]                       invokeRestart <- base::invokeRestart
[17:39:56.117]                       is.null <- base::is.null
[17:39:56.117]                       muffled <- FALSE
[17:39:56.117]                       if (inherits(cond, "message")) {
[17:39:56.117]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.117]                         if (muffled) 
[17:39:56.117]                           invokeRestart("muffleMessage")
[17:39:56.117]                       }
[17:39:56.117]                       else if (inherits(cond, "warning")) {
[17:39:56.117]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.117]                         if (muffled) 
[17:39:56.117]                           invokeRestart("muffleWarning")
[17:39:56.117]                       }
[17:39:56.117]                       else if (inherits(cond, "condition")) {
[17:39:56.117]                         if (!is.null(pattern)) {
[17:39:56.117]                           computeRestarts <- base::computeRestarts
[17:39:56.117]                           grepl <- base::grepl
[17:39:56.117]                           restarts <- computeRestarts(cond)
[17:39:56.117]                           for (restart in restarts) {
[17:39:56.117]                             name <- restart$name
[17:39:56.117]                             if (is.null(name)) 
[17:39:56.117]                               next
[17:39:56.117]                             if (!grepl(pattern, name)) 
[17:39:56.117]                               next
[17:39:56.117]                             invokeRestart(restart)
[17:39:56.117]                             muffled <- TRUE
[17:39:56.117]                             break
[17:39:56.117]                           }
[17:39:56.117]                         }
[17:39:56.117]                       }
[17:39:56.117]                       invisible(muffled)
[17:39:56.117]                     }
[17:39:56.117]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.117]                   }
[17:39:56.117]                 }
[17:39:56.117]             }
[17:39:56.117]         }))
[17:39:56.117]     }, error = function(ex) {
[17:39:56.117]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.117]                 ...future.rng), started = ...future.startTime, 
[17:39:56.117]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.117]             version = "1.8"), class = "FutureResult")
[17:39:56.117]     }, finally = {
[17:39:56.117]         if (!identical(...future.workdir, getwd())) 
[17:39:56.117]             setwd(...future.workdir)
[17:39:56.117]         {
[17:39:56.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.117]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.117]             }
[17:39:56.117]             base::options(...future.oldOptions)
[17:39:56.117]             if (.Platform$OS.type == "windows") {
[17:39:56.117]                 old_names <- names(...future.oldEnvVars)
[17:39:56.117]                 envs <- base::Sys.getenv()
[17:39:56.117]                 names <- names(envs)
[17:39:56.117]                 common <- intersect(names, old_names)
[17:39:56.117]                 added <- setdiff(names, old_names)
[17:39:56.117]                 removed <- setdiff(old_names, names)
[17:39:56.117]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.117]                   envs[common]]
[17:39:56.117]                 NAMES <- toupper(changed)
[17:39:56.117]                 args <- list()
[17:39:56.117]                 for (kk in seq_along(NAMES)) {
[17:39:56.117]                   name <- changed[[kk]]
[17:39:56.117]                   NAME <- NAMES[[kk]]
[17:39:56.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.117]                     next
[17:39:56.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.117]                 }
[17:39:56.117]                 NAMES <- toupper(added)
[17:39:56.117]                 for (kk in seq_along(NAMES)) {
[17:39:56.117]                   name <- added[[kk]]
[17:39:56.117]                   NAME <- NAMES[[kk]]
[17:39:56.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.117]                     next
[17:39:56.117]                   args[[name]] <- ""
[17:39:56.117]                 }
[17:39:56.117]                 NAMES <- toupper(removed)
[17:39:56.117]                 for (kk in seq_along(NAMES)) {
[17:39:56.117]                   name <- removed[[kk]]
[17:39:56.117]                   NAME <- NAMES[[kk]]
[17:39:56.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.117]                     next
[17:39:56.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.117]                 }
[17:39:56.117]                 if (length(args) > 0) 
[17:39:56.117]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.117]             }
[17:39:56.117]             else {
[17:39:56.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.117]             }
[17:39:56.117]             {
[17:39:56.117]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.117]                   0L) {
[17:39:56.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.117]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.117]                   base::options(opts)
[17:39:56.117]                 }
[17:39:56.117]                 {
[17:39:56.117]                   {
[17:39:56.117]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.117]                     NULL
[17:39:56.117]                   }
[17:39:56.117]                   options(future.plan = NULL)
[17:39:56.117]                   if (is.na(NA_character_)) 
[17:39:56.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.117]                     .init = FALSE)
[17:39:56.117]                 }
[17:39:56.117]             }
[17:39:56.117]         }
[17:39:56.117]     })
[17:39:56.117]     if (TRUE) {
[17:39:56.117]         base::sink(type = "output", split = FALSE)
[17:39:56.117]         if (TRUE) {
[17:39:56.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.117]         }
[17:39:56.117]         else {
[17:39:56.117]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.117]         }
[17:39:56.117]         base::close(...future.stdout)
[17:39:56.117]         ...future.stdout <- NULL
[17:39:56.117]     }
[17:39:56.117]     ...future.result$conditions <- ...future.conditions
[17:39:56.117]     ...future.result$finished <- base::Sys.time()
[17:39:56.117]     ...future.result
[17:39:56.117] }
[17:39:56.120] requestCore(): workers = 2
[17:39:56.122] MulticoreFuture started
[17:39:56.122] - Launch lazy future ... done
[17:39:56.122] run() for ‘MulticoreFuture’ ... done
[17:39:56.122] result() for MulticoreFuture ...
[17:39:56.123] plan(): Setting new future strategy stack:
[17:39:56.123] List of future strategies:
[17:39:56.123] 1. sequential:
[17:39:56.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.123]    - tweaked: FALSE
[17:39:56.123]    - call: NULL
[17:39:56.124] plan(): nbrOfWorkers() = 1
[17:39:56.126] plan(): Setting new future strategy stack:
[17:39:56.126] List of future strategies:
[17:39:56.126] 1. multicore:
[17:39:56.126]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.126]    - tweaked: FALSE
[17:39:56.126]    - call: plan(strategy)
[17:39:56.131] plan(): nbrOfWorkers() = 2
[17:39:56.138] result() for MulticoreFuture ...
[17:39:56.138] result() for MulticoreFuture ... done
[17:39:56.138] signalConditions() ...
[17:39:56.138]  - include = ‘immediateCondition’
[17:39:56.138]  - exclude = 
[17:39:56.138]  - resignal = FALSE
[17:39:56.138]  - Number of conditions: 1
[17:39:56.138] signalConditions() ... done
[17:39:56.139] result() for MulticoreFuture ... done
[17:39:56.139] result() for MulticoreFuture ...
[17:39:56.139] result() for MulticoreFuture ... done
[17:39:56.139] signalConditions() ...
[17:39:56.139]  - include = ‘immediateCondition’
[17:39:56.139]  - exclude = 
[17:39:56.139]  - resignal = FALSE
[17:39:56.139]  - Number of conditions: 1
[17:39:56.140] signalConditions() ... done
[17:39:56.140] Future state: ‘finished’
[17:39:56.140] result() for MulticoreFuture ...
[17:39:56.140] result() for MulticoreFuture ... done
[17:39:56.140] signalConditions() ...
[17:39:56.140]  - include = ‘condition’
[17:39:56.140]  - exclude = ‘immediateCondition’
[17:39:56.140]  - resignal = TRUE
[17:39:56.141]  - Number of conditions: 1
[17:39:56.141]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:56.141] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:56"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.169] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.169] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.171] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.171] Searching for globals ... DONE
[17:39:56.171] Resolving globals: TRUE
[17:39:56.171] Resolving any globals that are futures ...
[17:39:56.171] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.171] Resolving any globals that are futures ... DONE
[17:39:56.171] Resolving futures part of globals (recursively) ...
[17:39:56.172] resolve() on list ...
[17:39:56.172]  recursive: 99
[17:39:56.172]  length: 1
[17:39:56.172]  elements: ‘ii’
[17:39:56.172]  length: 0 (resolved future 1)
[17:39:56.172] resolve() on list ... DONE
[17:39:56.172] - globals: [1] ‘ii’
[17:39:56.172] Resolving futures part of globals (recursively) ... DONE
[17:39:56.173] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.173] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.173] - globals: [1] ‘ii’
[17:39:56.173] 
[17:39:56.173] getGlobalsAndPackages() ... DONE
[17:39:56.173] run() for ‘Future’ ...
[17:39:56.174] - state: ‘created’
[17:39:56.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.177] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.178]   - Field: ‘label’
[17:39:56.178]   - Field: ‘local’
[17:39:56.178]   - Field: ‘owner’
[17:39:56.178]   - Field: ‘envir’
[17:39:56.178]   - Field: ‘workers’
[17:39:56.178]   - Field: ‘packages’
[17:39:56.179]   - Field: ‘gc’
[17:39:56.179]   - Field: ‘job’
[17:39:56.180]   - Field: ‘conditions’
[17:39:56.180]   - Field: ‘expr’
[17:39:56.180]   - Field: ‘uuid’
[17:39:56.180]   - Field: ‘seed’
[17:39:56.180]   - Field: ‘version’
[17:39:56.180]   - Field: ‘result’
[17:39:56.180]   - Field: ‘asynchronous’
[17:39:56.180]   - Field: ‘calls’
[17:39:56.180]   - Field: ‘globals’
[17:39:56.180]   - Field: ‘stdout’
[17:39:56.181]   - Field: ‘earlySignal’
[17:39:56.181]   - Field: ‘lazy’
[17:39:56.181]   - Field: ‘state’
[17:39:56.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.181] - Launch lazy future ...
[17:39:56.181] Packages needed by the future expression (n = 0): <none>
[17:39:56.181] Packages needed by future strategies (n = 0): <none>
[17:39:56.182] {
[17:39:56.182]     {
[17:39:56.182]         {
[17:39:56.182]             ...future.startTime <- base::Sys.time()
[17:39:56.182]             {
[17:39:56.182]                 {
[17:39:56.182]                   {
[17:39:56.182]                     {
[17:39:56.182]                       base::local({
[17:39:56.182]                         has_future <- base::requireNamespace("future", 
[17:39:56.182]                           quietly = TRUE)
[17:39:56.182]                         if (has_future) {
[17:39:56.182]                           ns <- base::getNamespace("future")
[17:39:56.182]                           version <- ns[[".package"]][["version"]]
[17:39:56.182]                           if (is.null(version)) 
[17:39:56.182]                             version <- utils::packageVersion("future")
[17:39:56.182]                         }
[17:39:56.182]                         else {
[17:39:56.182]                           version <- NULL
[17:39:56.182]                         }
[17:39:56.182]                         if (!has_future || version < "1.8.0") {
[17:39:56.182]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.182]                             "", base::R.version$version.string), 
[17:39:56.182]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.182]                               "release", "version")], collapse = " "), 
[17:39:56.182]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.182]                             info)
[17:39:56.182]                           info <- base::paste(info, collapse = "; ")
[17:39:56.182]                           if (!has_future) {
[17:39:56.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.182]                               info)
[17:39:56.182]                           }
[17:39:56.182]                           else {
[17:39:56.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.182]                               info, version)
[17:39:56.182]                           }
[17:39:56.182]                           base::stop(msg)
[17:39:56.182]                         }
[17:39:56.182]                       })
[17:39:56.182]                     }
[17:39:56.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.182]                     base::options(mc.cores = 1L)
[17:39:56.182]                   }
[17:39:56.182]                   ...future.strategy.old <- future::plan("list")
[17:39:56.182]                   options(future.plan = NULL)
[17:39:56.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.182]                 }
[17:39:56.182]                 ...future.workdir <- getwd()
[17:39:56.182]             }
[17:39:56.182]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.182]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.182]         }
[17:39:56.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.182]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.182]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.182]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.182]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.182]             base::names(...future.oldOptions))
[17:39:56.182]     }
[17:39:56.182]     if (FALSE) {
[17:39:56.182]     }
[17:39:56.182]     else {
[17:39:56.182]         if (TRUE) {
[17:39:56.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.182]                 open = "w")
[17:39:56.182]         }
[17:39:56.182]         else {
[17:39:56.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.182]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.182]         }
[17:39:56.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.182]             base::sink(type = "output", split = FALSE)
[17:39:56.182]             base::close(...future.stdout)
[17:39:56.182]         }, add = TRUE)
[17:39:56.182]     }
[17:39:56.182]     ...future.frame <- base::sys.nframe()
[17:39:56.182]     ...future.conditions <- base::list()
[17:39:56.182]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.182]     if (FALSE) {
[17:39:56.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.182]     }
[17:39:56.182]     ...future.result <- base::tryCatch({
[17:39:56.182]         base::withCallingHandlers({
[17:39:56.182]             ...future.value <- base::withVisible(base::local({
[17:39:56.182]                 withCallingHandlers({
[17:39:56.182]                   {
[17:39:56.182]                     b <- a * ii
[17:39:56.182]                     a <- 0
[17:39:56.182]                     b
[17:39:56.182]                   }
[17:39:56.182]                 }, immediateCondition = function(cond) {
[17:39:56.182]                   save_rds <- function (object, pathname, ...) 
[17:39:56.182]                   {
[17:39:56.182]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.182]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.182]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.182]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.182]                         fi_tmp[["mtime"]])
[17:39:56.182]                     }
[17:39:56.182]                     tryCatch({
[17:39:56.182]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.182]                     }, error = function(ex) {
[17:39:56.182]                       msg <- conditionMessage(ex)
[17:39:56.182]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.182]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.182]                         fi_tmp[["mtime"]], msg)
[17:39:56.182]                       ex$message <- msg
[17:39:56.182]                       stop(ex)
[17:39:56.182]                     })
[17:39:56.182]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.182]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.182]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.182]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.182]                       fi <- file.info(pathname)
[17:39:56.182]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.182]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.182]                         fi[["size"]], fi[["mtime"]])
[17:39:56.182]                       stop(msg)
[17:39:56.182]                     }
[17:39:56.182]                     invisible(pathname)
[17:39:56.182]                   }
[17:39:56.182]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.182]                     rootPath = tempdir()) 
[17:39:56.182]                   {
[17:39:56.182]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.182]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.182]                       tmpdir = path, fileext = ".rds")
[17:39:56.182]                     save_rds(obj, file)
[17:39:56.182]                   }
[17:39:56.182]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.182]                   {
[17:39:56.182]                     inherits <- base::inherits
[17:39:56.182]                     invokeRestart <- base::invokeRestart
[17:39:56.182]                     is.null <- base::is.null
[17:39:56.182]                     muffled <- FALSE
[17:39:56.182]                     if (inherits(cond, "message")) {
[17:39:56.182]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.182]                       if (muffled) 
[17:39:56.182]                         invokeRestart("muffleMessage")
[17:39:56.182]                     }
[17:39:56.182]                     else if (inherits(cond, "warning")) {
[17:39:56.182]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.182]                       if (muffled) 
[17:39:56.182]                         invokeRestart("muffleWarning")
[17:39:56.182]                     }
[17:39:56.182]                     else if (inherits(cond, "condition")) {
[17:39:56.182]                       if (!is.null(pattern)) {
[17:39:56.182]                         computeRestarts <- base::computeRestarts
[17:39:56.182]                         grepl <- base::grepl
[17:39:56.182]                         restarts <- computeRestarts(cond)
[17:39:56.182]                         for (restart in restarts) {
[17:39:56.182]                           name <- restart$name
[17:39:56.182]                           if (is.null(name)) 
[17:39:56.182]                             next
[17:39:56.182]                           if (!grepl(pattern, name)) 
[17:39:56.182]                             next
[17:39:56.182]                           invokeRestart(restart)
[17:39:56.182]                           muffled <- TRUE
[17:39:56.182]                           break
[17:39:56.182]                         }
[17:39:56.182]                       }
[17:39:56.182]                     }
[17:39:56.182]                     invisible(muffled)
[17:39:56.182]                   }
[17:39:56.182]                   muffleCondition(cond)
[17:39:56.182]                 })
[17:39:56.182]             }))
[17:39:56.182]             future::FutureResult(value = ...future.value$value, 
[17:39:56.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.182]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.182]                     ...future.globalenv.names))
[17:39:56.182]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.182]         }, condition = base::local({
[17:39:56.182]             c <- base::c
[17:39:56.182]             inherits <- base::inherits
[17:39:56.182]             invokeRestart <- base::invokeRestart
[17:39:56.182]             length <- base::length
[17:39:56.182]             list <- base::list
[17:39:56.182]             seq.int <- base::seq.int
[17:39:56.182]             signalCondition <- base::signalCondition
[17:39:56.182]             sys.calls <- base::sys.calls
[17:39:56.182]             `[[` <- base::`[[`
[17:39:56.182]             `+` <- base::`+`
[17:39:56.182]             `<<-` <- base::`<<-`
[17:39:56.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.182]                   3L)]
[17:39:56.182]             }
[17:39:56.182]             function(cond) {
[17:39:56.182]                 is_error <- inherits(cond, "error")
[17:39:56.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.182]                   NULL)
[17:39:56.182]                 if (is_error) {
[17:39:56.182]                   sessionInformation <- function() {
[17:39:56.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.182]                       search = base::search(), system = base::Sys.info())
[17:39:56.182]                   }
[17:39:56.182]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.182]                     cond$call), session = sessionInformation(), 
[17:39:56.182]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.182]                   signalCondition(cond)
[17:39:56.182]                 }
[17:39:56.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.182]                 "immediateCondition"))) {
[17:39:56.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.182]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.182]                   if (TRUE && !signal) {
[17:39:56.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.182]                     {
[17:39:56.182]                       inherits <- base::inherits
[17:39:56.182]                       invokeRestart <- base::invokeRestart
[17:39:56.182]                       is.null <- base::is.null
[17:39:56.182]                       muffled <- FALSE
[17:39:56.182]                       if (inherits(cond, "message")) {
[17:39:56.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.182]                         if (muffled) 
[17:39:56.182]                           invokeRestart("muffleMessage")
[17:39:56.182]                       }
[17:39:56.182]                       else if (inherits(cond, "warning")) {
[17:39:56.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.182]                         if (muffled) 
[17:39:56.182]                           invokeRestart("muffleWarning")
[17:39:56.182]                       }
[17:39:56.182]                       else if (inherits(cond, "condition")) {
[17:39:56.182]                         if (!is.null(pattern)) {
[17:39:56.182]                           computeRestarts <- base::computeRestarts
[17:39:56.182]                           grepl <- base::grepl
[17:39:56.182]                           restarts <- computeRestarts(cond)
[17:39:56.182]                           for (restart in restarts) {
[17:39:56.182]                             name <- restart$name
[17:39:56.182]                             if (is.null(name)) 
[17:39:56.182]                               next
[17:39:56.182]                             if (!grepl(pattern, name)) 
[17:39:56.182]                               next
[17:39:56.182]                             invokeRestart(restart)
[17:39:56.182]                             muffled <- TRUE
[17:39:56.182]                             break
[17:39:56.182]                           }
[17:39:56.182]                         }
[17:39:56.182]                       }
[17:39:56.182]                       invisible(muffled)
[17:39:56.182]                     }
[17:39:56.182]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.182]                   }
[17:39:56.182]                 }
[17:39:56.182]                 else {
[17:39:56.182]                   if (TRUE) {
[17:39:56.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.182]                     {
[17:39:56.182]                       inherits <- base::inherits
[17:39:56.182]                       invokeRestart <- base::invokeRestart
[17:39:56.182]                       is.null <- base::is.null
[17:39:56.182]                       muffled <- FALSE
[17:39:56.182]                       if (inherits(cond, "message")) {
[17:39:56.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.182]                         if (muffled) 
[17:39:56.182]                           invokeRestart("muffleMessage")
[17:39:56.182]                       }
[17:39:56.182]                       else if (inherits(cond, "warning")) {
[17:39:56.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.182]                         if (muffled) 
[17:39:56.182]                           invokeRestart("muffleWarning")
[17:39:56.182]                       }
[17:39:56.182]                       else if (inherits(cond, "condition")) {
[17:39:56.182]                         if (!is.null(pattern)) {
[17:39:56.182]                           computeRestarts <- base::computeRestarts
[17:39:56.182]                           grepl <- base::grepl
[17:39:56.182]                           restarts <- computeRestarts(cond)
[17:39:56.182]                           for (restart in restarts) {
[17:39:56.182]                             name <- restart$name
[17:39:56.182]                             if (is.null(name)) 
[17:39:56.182]                               next
[17:39:56.182]                             if (!grepl(pattern, name)) 
[17:39:56.182]                               next
[17:39:56.182]                             invokeRestart(restart)
[17:39:56.182]                             muffled <- TRUE
[17:39:56.182]                             break
[17:39:56.182]                           }
[17:39:56.182]                         }
[17:39:56.182]                       }
[17:39:56.182]                       invisible(muffled)
[17:39:56.182]                     }
[17:39:56.182]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.182]                   }
[17:39:56.182]                 }
[17:39:56.182]             }
[17:39:56.182]         }))
[17:39:56.182]     }, error = function(ex) {
[17:39:56.182]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.182]                 ...future.rng), started = ...future.startTime, 
[17:39:56.182]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.182]             version = "1.8"), class = "FutureResult")
[17:39:56.182]     }, finally = {
[17:39:56.182]         if (!identical(...future.workdir, getwd())) 
[17:39:56.182]             setwd(...future.workdir)
[17:39:56.182]         {
[17:39:56.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.182]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.182]             }
[17:39:56.182]             base::options(...future.oldOptions)
[17:39:56.182]             if (.Platform$OS.type == "windows") {
[17:39:56.182]                 old_names <- names(...future.oldEnvVars)
[17:39:56.182]                 envs <- base::Sys.getenv()
[17:39:56.182]                 names <- names(envs)
[17:39:56.182]                 common <- intersect(names, old_names)
[17:39:56.182]                 added <- setdiff(names, old_names)
[17:39:56.182]                 removed <- setdiff(old_names, names)
[17:39:56.182]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.182]                   envs[common]]
[17:39:56.182]                 NAMES <- toupper(changed)
[17:39:56.182]                 args <- list()
[17:39:56.182]                 for (kk in seq_along(NAMES)) {
[17:39:56.182]                   name <- changed[[kk]]
[17:39:56.182]                   NAME <- NAMES[[kk]]
[17:39:56.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.182]                     next
[17:39:56.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.182]                 }
[17:39:56.182]                 NAMES <- toupper(added)
[17:39:56.182]                 for (kk in seq_along(NAMES)) {
[17:39:56.182]                   name <- added[[kk]]
[17:39:56.182]                   NAME <- NAMES[[kk]]
[17:39:56.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.182]                     next
[17:39:56.182]                   args[[name]] <- ""
[17:39:56.182]                 }
[17:39:56.182]                 NAMES <- toupper(removed)
[17:39:56.182]                 for (kk in seq_along(NAMES)) {
[17:39:56.182]                   name <- removed[[kk]]
[17:39:56.182]                   NAME <- NAMES[[kk]]
[17:39:56.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.182]                     next
[17:39:56.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.182]                 }
[17:39:56.182]                 if (length(args) > 0) 
[17:39:56.182]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.182]             }
[17:39:56.182]             else {
[17:39:56.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.182]             }
[17:39:56.182]             {
[17:39:56.182]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.182]                   0L) {
[17:39:56.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.182]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.182]                   base::options(opts)
[17:39:56.182]                 }
[17:39:56.182]                 {
[17:39:56.182]                   {
[17:39:56.182]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.182]                     NULL
[17:39:56.182]                   }
[17:39:56.182]                   options(future.plan = NULL)
[17:39:56.182]                   if (is.na(NA_character_)) 
[17:39:56.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.182]                     .init = FALSE)
[17:39:56.182]                 }
[17:39:56.182]             }
[17:39:56.182]         }
[17:39:56.182]     })
[17:39:56.182]     if (TRUE) {
[17:39:56.182]         base::sink(type = "output", split = FALSE)
[17:39:56.182]         if (TRUE) {
[17:39:56.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.182]         }
[17:39:56.182]         else {
[17:39:56.182]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.182]         }
[17:39:56.182]         base::close(...future.stdout)
[17:39:56.182]         ...future.stdout <- NULL
[17:39:56.182]     }
[17:39:56.182]     ...future.result$conditions <- ...future.conditions
[17:39:56.182]     ...future.result$finished <- base::Sys.time()
[17:39:56.182]     ...future.result
[17:39:56.182] }
[17:39:56.184] assign_globals() ...
[17:39:56.184] List of 1
[17:39:56.184]  $ ii: int 1
[17:39:56.184]  - attr(*, "where")=List of 1
[17:39:56.184]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.184]  - attr(*, "resolved")= logi TRUE
[17:39:56.184]  - attr(*, "total_size")= num 56
[17:39:56.184]  - attr(*, "already-done")= logi TRUE
[17:39:56.186] - copied ‘ii’ to environment
[17:39:56.186] assign_globals() ... done
[17:39:56.187] requestCore(): workers = 2
[17:39:56.188] MulticoreFuture started
[17:39:56.189] - Launch lazy future ... done
[17:39:56.189] run() for ‘MulticoreFuture’ ... done
[17:39:56.190] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.191] getGlobalsAndPackages() ...
[17:39:56.190] List of future strategies:
[17:39:56.190] 1. sequential:
[17:39:56.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.190]    - tweaked: FALSE
[17:39:56.190]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.191] plan(): nbrOfWorkers() = 1
[17:39:56.191] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.193] plan(): Setting new future strategy stack:
[17:39:56.193] List of future strategies:
[17:39:56.193] 1. multicore:
[17:39:56.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.193]    - tweaked: FALSE
[17:39:56.193]    - call: plan(strategy)
[17:39:56.194] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.194] Searching for globals ... DONE
[17:39:56.194] Resolving globals: TRUE
[17:39:56.194] Resolving any globals that are futures ...
[17:39:56.194] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.195] Resolving any globals that are futures ... DONE
[17:39:56.195] Resolving futures part of globals (recursively) ...
[17:39:56.196] resolve() on list ...
[17:39:56.196]  recursive: 99
[17:39:56.196]  length: 1
[17:39:56.197]  elements: ‘ii’
[17:39:56.197]  length: 0 (resolved future 1)
[17:39:56.197] resolve() on list ... DONE
[17:39:56.198] - globals: [1] ‘ii’
[17:39:56.198] Resolving futures part of globals (recursively) ... DONE
[17:39:56.198] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.199] plan(): nbrOfWorkers() = 2
[17:39:56.199] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.199] - globals: [1] ‘ii’
[17:39:56.199] 
[17:39:56.199] getGlobalsAndPackages() ... DONE
[17:39:56.200] run() for ‘Future’ ...
[17:39:56.200] - state: ‘created’
[17:39:56.200] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.205] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.205]   - Field: ‘label’
[17:39:56.205]   - Field: ‘local’
[17:39:56.205]   - Field: ‘owner’
[17:39:56.205]   - Field: ‘envir’
[17:39:56.206]   - Field: ‘workers’
[17:39:56.206]   - Field: ‘packages’
[17:39:56.206]   - Field: ‘gc’
[17:39:56.206]   - Field: ‘job’
[17:39:56.206]   - Field: ‘conditions’
[17:39:56.206]   - Field: ‘expr’
[17:39:56.206]   - Field: ‘uuid’
[17:39:56.206]   - Field: ‘seed’
[17:39:56.207]   - Field: ‘version’
[17:39:56.207]   - Field: ‘result’
[17:39:56.207]   - Field: ‘asynchronous’
[17:39:56.207]   - Field: ‘calls’
[17:39:56.207]   - Field: ‘globals’
[17:39:56.207]   - Field: ‘stdout’
[17:39:56.207]   - Field: ‘earlySignal’
[17:39:56.208]   - Field: ‘lazy’
[17:39:56.208]   - Field: ‘state’
[17:39:56.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.208] - Launch lazy future ...
[17:39:56.208] Packages needed by the future expression (n = 0): <none>
[17:39:56.209] Packages needed by future strategies (n = 0): <none>
[17:39:56.209] {
[17:39:56.209]     {
[17:39:56.209]         {
[17:39:56.209]             ...future.startTime <- base::Sys.time()
[17:39:56.209]             {
[17:39:56.209]                 {
[17:39:56.209]                   {
[17:39:56.209]                     {
[17:39:56.209]                       base::local({
[17:39:56.209]                         has_future <- base::requireNamespace("future", 
[17:39:56.209]                           quietly = TRUE)
[17:39:56.209]                         if (has_future) {
[17:39:56.209]                           ns <- base::getNamespace("future")
[17:39:56.209]                           version <- ns[[".package"]][["version"]]
[17:39:56.209]                           if (is.null(version)) 
[17:39:56.209]                             version <- utils::packageVersion("future")
[17:39:56.209]                         }
[17:39:56.209]                         else {
[17:39:56.209]                           version <- NULL
[17:39:56.209]                         }
[17:39:56.209]                         if (!has_future || version < "1.8.0") {
[17:39:56.209]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.209]                             "", base::R.version$version.string), 
[17:39:56.209]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.209]                               "release", "version")], collapse = " "), 
[17:39:56.209]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.209]                             info)
[17:39:56.209]                           info <- base::paste(info, collapse = "; ")
[17:39:56.209]                           if (!has_future) {
[17:39:56.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.209]                               info)
[17:39:56.209]                           }
[17:39:56.209]                           else {
[17:39:56.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.209]                               info, version)
[17:39:56.209]                           }
[17:39:56.209]                           base::stop(msg)
[17:39:56.209]                         }
[17:39:56.209]                       })
[17:39:56.209]                     }
[17:39:56.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.209]                     base::options(mc.cores = 1L)
[17:39:56.209]                   }
[17:39:56.209]                   ...future.strategy.old <- future::plan("list")
[17:39:56.209]                   options(future.plan = NULL)
[17:39:56.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.209]                 }
[17:39:56.209]                 ...future.workdir <- getwd()
[17:39:56.209]             }
[17:39:56.209]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.209]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.209]         }
[17:39:56.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.209]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.209]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.209]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.209]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.209]             base::names(...future.oldOptions))
[17:39:56.209]     }
[17:39:56.209]     if (FALSE) {
[17:39:56.209]     }
[17:39:56.209]     else {
[17:39:56.209]         if (TRUE) {
[17:39:56.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.209]                 open = "w")
[17:39:56.209]         }
[17:39:56.209]         else {
[17:39:56.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.209]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.209]         }
[17:39:56.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.209]             base::sink(type = "output", split = FALSE)
[17:39:56.209]             base::close(...future.stdout)
[17:39:56.209]         }, add = TRUE)
[17:39:56.209]     }
[17:39:56.209]     ...future.frame <- base::sys.nframe()
[17:39:56.209]     ...future.conditions <- base::list()
[17:39:56.209]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.209]     if (FALSE) {
[17:39:56.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.209]     }
[17:39:56.209]     ...future.result <- base::tryCatch({
[17:39:56.209]         base::withCallingHandlers({
[17:39:56.209]             ...future.value <- base::withVisible(base::local({
[17:39:56.209]                 withCallingHandlers({
[17:39:56.209]                   {
[17:39:56.209]                     b <- a * ii
[17:39:56.209]                     a <- 0
[17:39:56.209]                     b
[17:39:56.209]                   }
[17:39:56.209]                 }, immediateCondition = function(cond) {
[17:39:56.209]                   save_rds <- function (object, pathname, ...) 
[17:39:56.209]                   {
[17:39:56.209]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.209]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.209]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.209]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.209]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.209]                         fi_tmp[["mtime"]])
[17:39:56.209]                     }
[17:39:56.209]                     tryCatch({
[17:39:56.209]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.209]                     }, error = function(ex) {
[17:39:56.209]                       msg <- conditionMessage(ex)
[17:39:56.209]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.209]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.209]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.209]                         fi_tmp[["mtime"]], msg)
[17:39:56.209]                       ex$message <- msg
[17:39:56.209]                       stop(ex)
[17:39:56.209]                     })
[17:39:56.209]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.209]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.209]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.209]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.209]                       fi <- file.info(pathname)
[17:39:56.209]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.209]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.209]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.209]                         fi[["size"]], fi[["mtime"]])
[17:39:56.209]                       stop(msg)
[17:39:56.209]                     }
[17:39:56.209]                     invisible(pathname)
[17:39:56.209]                   }
[17:39:56.209]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.209]                     rootPath = tempdir()) 
[17:39:56.209]                   {
[17:39:56.209]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.209]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.209]                       tmpdir = path, fileext = ".rds")
[17:39:56.209]                     save_rds(obj, file)
[17:39:56.209]                   }
[17:39:56.209]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.209]                   {
[17:39:56.209]                     inherits <- base::inherits
[17:39:56.209]                     invokeRestart <- base::invokeRestart
[17:39:56.209]                     is.null <- base::is.null
[17:39:56.209]                     muffled <- FALSE
[17:39:56.209]                     if (inherits(cond, "message")) {
[17:39:56.209]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.209]                       if (muffled) 
[17:39:56.209]                         invokeRestart("muffleMessage")
[17:39:56.209]                     }
[17:39:56.209]                     else if (inherits(cond, "warning")) {
[17:39:56.209]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.209]                       if (muffled) 
[17:39:56.209]                         invokeRestart("muffleWarning")
[17:39:56.209]                     }
[17:39:56.209]                     else if (inherits(cond, "condition")) {
[17:39:56.209]                       if (!is.null(pattern)) {
[17:39:56.209]                         computeRestarts <- base::computeRestarts
[17:39:56.209]                         grepl <- base::grepl
[17:39:56.209]                         restarts <- computeRestarts(cond)
[17:39:56.209]                         for (restart in restarts) {
[17:39:56.209]                           name <- restart$name
[17:39:56.209]                           if (is.null(name)) 
[17:39:56.209]                             next
[17:39:56.209]                           if (!grepl(pattern, name)) 
[17:39:56.209]                             next
[17:39:56.209]                           invokeRestart(restart)
[17:39:56.209]                           muffled <- TRUE
[17:39:56.209]                           break
[17:39:56.209]                         }
[17:39:56.209]                       }
[17:39:56.209]                     }
[17:39:56.209]                     invisible(muffled)
[17:39:56.209]                   }
[17:39:56.209]                   muffleCondition(cond)
[17:39:56.209]                 })
[17:39:56.209]             }))
[17:39:56.209]             future::FutureResult(value = ...future.value$value, 
[17:39:56.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.209]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.209]                     ...future.globalenv.names))
[17:39:56.209]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.209]         }, condition = base::local({
[17:39:56.209]             c <- base::c
[17:39:56.209]             inherits <- base::inherits
[17:39:56.209]             invokeRestart <- base::invokeRestart
[17:39:56.209]             length <- base::length
[17:39:56.209]             list <- base::list
[17:39:56.209]             seq.int <- base::seq.int
[17:39:56.209]             signalCondition <- base::signalCondition
[17:39:56.209]             sys.calls <- base::sys.calls
[17:39:56.209]             `[[` <- base::`[[`
[17:39:56.209]             `+` <- base::`+`
[17:39:56.209]             `<<-` <- base::`<<-`
[17:39:56.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.209]                   3L)]
[17:39:56.209]             }
[17:39:56.209]             function(cond) {
[17:39:56.209]                 is_error <- inherits(cond, "error")
[17:39:56.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.209]                   NULL)
[17:39:56.209]                 if (is_error) {
[17:39:56.209]                   sessionInformation <- function() {
[17:39:56.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.209]                       search = base::search(), system = base::Sys.info())
[17:39:56.209]                   }
[17:39:56.209]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.209]                     cond$call), session = sessionInformation(), 
[17:39:56.209]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.209]                   signalCondition(cond)
[17:39:56.209]                 }
[17:39:56.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.209]                 "immediateCondition"))) {
[17:39:56.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.209]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.209]                   if (TRUE && !signal) {
[17:39:56.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.209]                     {
[17:39:56.209]                       inherits <- base::inherits
[17:39:56.209]                       invokeRestart <- base::invokeRestart
[17:39:56.209]                       is.null <- base::is.null
[17:39:56.209]                       muffled <- FALSE
[17:39:56.209]                       if (inherits(cond, "message")) {
[17:39:56.209]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.209]                         if (muffled) 
[17:39:56.209]                           invokeRestart("muffleMessage")
[17:39:56.209]                       }
[17:39:56.209]                       else if (inherits(cond, "warning")) {
[17:39:56.209]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.209]                         if (muffled) 
[17:39:56.209]                           invokeRestart("muffleWarning")
[17:39:56.209]                       }
[17:39:56.209]                       else if (inherits(cond, "condition")) {
[17:39:56.209]                         if (!is.null(pattern)) {
[17:39:56.209]                           computeRestarts <- base::computeRestarts
[17:39:56.209]                           grepl <- base::grepl
[17:39:56.209]                           restarts <- computeRestarts(cond)
[17:39:56.209]                           for (restart in restarts) {
[17:39:56.209]                             name <- restart$name
[17:39:56.209]                             if (is.null(name)) 
[17:39:56.209]                               next
[17:39:56.209]                             if (!grepl(pattern, name)) 
[17:39:56.209]                               next
[17:39:56.209]                             invokeRestart(restart)
[17:39:56.209]                             muffled <- TRUE
[17:39:56.209]                             break
[17:39:56.209]                           }
[17:39:56.209]                         }
[17:39:56.209]                       }
[17:39:56.209]                       invisible(muffled)
[17:39:56.209]                     }
[17:39:56.209]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.209]                   }
[17:39:56.209]                 }
[17:39:56.209]                 else {
[17:39:56.209]                   if (TRUE) {
[17:39:56.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.209]                     {
[17:39:56.209]                       inherits <- base::inherits
[17:39:56.209]                       invokeRestart <- base::invokeRestart
[17:39:56.209]                       is.null <- base::is.null
[17:39:56.209]                       muffled <- FALSE
[17:39:56.209]                       if (inherits(cond, "message")) {
[17:39:56.209]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.209]                         if (muffled) 
[17:39:56.209]                           invokeRestart("muffleMessage")
[17:39:56.209]                       }
[17:39:56.209]                       else if (inherits(cond, "warning")) {
[17:39:56.209]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.209]                         if (muffled) 
[17:39:56.209]                           invokeRestart("muffleWarning")
[17:39:56.209]                       }
[17:39:56.209]                       else if (inherits(cond, "condition")) {
[17:39:56.209]                         if (!is.null(pattern)) {
[17:39:56.209]                           computeRestarts <- base::computeRestarts
[17:39:56.209]                           grepl <- base::grepl
[17:39:56.209]                           restarts <- computeRestarts(cond)
[17:39:56.209]                           for (restart in restarts) {
[17:39:56.209]                             name <- restart$name
[17:39:56.209]                             if (is.null(name)) 
[17:39:56.209]                               next
[17:39:56.209]                             if (!grepl(pattern, name)) 
[17:39:56.209]                               next
[17:39:56.209]                             invokeRestart(restart)
[17:39:56.209]                             muffled <- TRUE
[17:39:56.209]                             break
[17:39:56.209]                           }
[17:39:56.209]                         }
[17:39:56.209]                       }
[17:39:56.209]                       invisible(muffled)
[17:39:56.209]                     }
[17:39:56.209]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.209]                   }
[17:39:56.209]                 }
[17:39:56.209]             }
[17:39:56.209]         }))
[17:39:56.209]     }, error = function(ex) {
[17:39:56.209]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.209]                 ...future.rng), started = ...future.startTime, 
[17:39:56.209]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.209]             version = "1.8"), class = "FutureResult")
[17:39:56.209]     }, finally = {
[17:39:56.209]         if (!identical(...future.workdir, getwd())) 
[17:39:56.209]             setwd(...future.workdir)
[17:39:56.209]         {
[17:39:56.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.209]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.209]             }
[17:39:56.209]             base::options(...future.oldOptions)
[17:39:56.209]             if (.Platform$OS.type == "windows") {
[17:39:56.209]                 old_names <- names(...future.oldEnvVars)
[17:39:56.209]                 envs <- base::Sys.getenv()
[17:39:56.209]                 names <- names(envs)
[17:39:56.209]                 common <- intersect(names, old_names)
[17:39:56.209]                 added <- setdiff(names, old_names)
[17:39:56.209]                 removed <- setdiff(old_names, names)
[17:39:56.209]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.209]                   envs[common]]
[17:39:56.209]                 NAMES <- toupper(changed)
[17:39:56.209]                 args <- list()
[17:39:56.209]                 for (kk in seq_along(NAMES)) {
[17:39:56.209]                   name <- changed[[kk]]
[17:39:56.209]                   NAME <- NAMES[[kk]]
[17:39:56.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.209]                     next
[17:39:56.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.209]                 }
[17:39:56.209]                 NAMES <- toupper(added)
[17:39:56.209]                 for (kk in seq_along(NAMES)) {
[17:39:56.209]                   name <- added[[kk]]
[17:39:56.209]                   NAME <- NAMES[[kk]]
[17:39:56.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.209]                     next
[17:39:56.209]                   args[[name]] <- ""
[17:39:56.209]                 }
[17:39:56.209]                 NAMES <- toupper(removed)
[17:39:56.209]                 for (kk in seq_along(NAMES)) {
[17:39:56.209]                   name <- removed[[kk]]
[17:39:56.209]                   NAME <- NAMES[[kk]]
[17:39:56.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.209]                     next
[17:39:56.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.209]                 }
[17:39:56.209]                 if (length(args) > 0) 
[17:39:56.209]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.209]             }
[17:39:56.209]             else {
[17:39:56.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.209]             }
[17:39:56.209]             {
[17:39:56.209]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.209]                   0L) {
[17:39:56.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.209]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.209]                   base::options(opts)
[17:39:56.209]                 }
[17:39:56.209]                 {
[17:39:56.209]                   {
[17:39:56.209]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.209]                     NULL
[17:39:56.209]                   }
[17:39:56.209]                   options(future.plan = NULL)
[17:39:56.209]                   if (is.na(NA_character_)) 
[17:39:56.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.209]                     .init = FALSE)
[17:39:56.209]                 }
[17:39:56.209]             }
[17:39:56.209]         }
[17:39:56.209]     })
[17:39:56.209]     if (TRUE) {
[17:39:56.209]         base::sink(type = "output", split = FALSE)
[17:39:56.209]         if (TRUE) {
[17:39:56.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.209]         }
[17:39:56.209]         else {
[17:39:56.209]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.209]         }
[17:39:56.209]         base::close(...future.stdout)
[17:39:56.209]         ...future.stdout <- NULL
[17:39:56.209]     }
[17:39:56.209]     ...future.result$conditions <- ...future.conditions
[17:39:56.209]     ...future.result$finished <- base::Sys.time()
[17:39:56.209]     ...future.result
[17:39:56.209] }
[17:39:56.213] assign_globals() ...
[17:39:56.213] List of 1
[17:39:56.213]  $ ii: int 2
[17:39:56.213]  - attr(*, "where")=List of 1
[17:39:56.213]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.213]  - attr(*, "resolved")= logi TRUE
[17:39:56.213]  - attr(*, "total_size")= num 56
[17:39:56.213]  - attr(*, "already-done")= logi TRUE
[17:39:56.216] - copied ‘ii’ to environment
[17:39:56.217] assign_globals() ... done
[17:39:56.217] requestCore(): workers = 2
[17:39:56.219] MulticoreFuture started
[17:39:56.219] - Launch lazy future ... done
[17:39:56.220] run() for ‘MulticoreFuture’ ... done
[17:39:56.220] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.221] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.220] List of future strategies:
[17:39:56.220] 1. sequential:
[17:39:56.220]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.220]    - tweaked: FALSE
[17:39:56.220]    - call: NULL
[17:39:56.221] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.221] plan(): nbrOfWorkers() = 1
[17:39:56.223] plan(): Setting new future strategy stack:
[17:39:56.224] List of future strategies:
[17:39:56.224] 1. multicore:
[17:39:56.224]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.224]    - tweaked: FALSE
[17:39:56.224]    - call: plan(strategy)
[17:39:56.224] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.224] Searching for globals ... DONE
[17:39:56.224] Resolving globals: TRUE
[17:39:56.224] Resolving any globals that are futures ...
[17:39:56.225] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.225] Resolving any globals that are futures ... DONE
[17:39:56.228] plan(): nbrOfWorkers() = 2
[17:39:56.230] Resolving futures part of globals (recursively) ...
[17:39:56.231] resolve() on list ...
[17:39:56.231]  recursive: 99
[17:39:56.231]  length: 1
[17:39:56.231]  elements: ‘ii’
[17:39:56.232]  length: 0 (resolved future 1)
[17:39:56.232] resolve() on list ... DONE
[17:39:56.232] - globals: [1] ‘ii’
[17:39:56.233] Resolving futures part of globals (recursively) ... DONE
[17:39:56.233] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.234] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.234] - globals: [1] ‘ii’
[17:39:56.235] 
[17:39:56.235] getGlobalsAndPackages() ... DONE
[17:39:56.236] run() for ‘Future’ ...
[17:39:56.236] - state: ‘created’
[17:39:56.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.241]   - Field: ‘label’
[17:39:56.241]   - Field: ‘local’
[17:39:56.241]   - Field: ‘owner’
[17:39:56.241]   - Field: ‘envir’
[17:39:56.241]   - Field: ‘workers’
[17:39:56.241]   - Field: ‘packages’
[17:39:56.241]   - Field: ‘gc’
[17:39:56.242]   - Field: ‘job’
[17:39:56.242]   - Field: ‘conditions’
[17:39:56.242]   - Field: ‘expr’
[17:39:56.242]   - Field: ‘uuid’
[17:39:56.242]   - Field: ‘seed’
[17:39:56.242]   - Field: ‘version’
[17:39:56.243]   - Field: ‘result’
[17:39:56.243]   - Field: ‘asynchronous’
[17:39:56.243]   - Field: ‘calls’
[17:39:56.243]   - Field: ‘globals’
[17:39:56.243]   - Field: ‘stdout’
[17:39:56.243]   - Field: ‘earlySignal’
[17:39:56.243]   - Field: ‘lazy’
[17:39:56.243]   - Field: ‘state’
[17:39:56.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.244] - Launch lazy future ...
[17:39:56.244] Packages needed by the future expression (n = 0): <none>
[17:39:56.244] Packages needed by future strategies (n = 0): <none>
[17:39:56.245] {
[17:39:56.245]     {
[17:39:56.245]         {
[17:39:56.245]             ...future.startTime <- base::Sys.time()
[17:39:56.245]             {
[17:39:56.245]                 {
[17:39:56.245]                   {
[17:39:56.245]                     {
[17:39:56.245]                       base::local({
[17:39:56.245]                         has_future <- base::requireNamespace("future", 
[17:39:56.245]                           quietly = TRUE)
[17:39:56.245]                         if (has_future) {
[17:39:56.245]                           ns <- base::getNamespace("future")
[17:39:56.245]                           version <- ns[[".package"]][["version"]]
[17:39:56.245]                           if (is.null(version)) 
[17:39:56.245]                             version <- utils::packageVersion("future")
[17:39:56.245]                         }
[17:39:56.245]                         else {
[17:39:56.245]                           version <- NULL
[17:39:56.245]                         }
[17:39:56.245]                         if (!has_future || version < "1.8.0") {
[17:39:56.245]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.245]                             "", base::R.version$version.string), 
[17:39:56.245]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.245]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.245]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.245]                               "release", "version")], collapse = " "), 
[17:39:56.245]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.245]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.245]                             info)
[17:39:56.245]                           info <- base::paste(info, collapse = "; ")
[17:39:56.245]                           if (!has_future) {
[17:39:56.245]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.245]                               info)
[17:39:56.245]                           }
[17:39:56.245]                           else {
[17:39:56.245]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.245]                               info, version)
[17:39:56.245]                           }
[17:39:56.245]                           base::stop(msg)
[17:39:56.245]                         }
[17:39:56.245]                       })
[17:39:56.245]                     }
[17:39:56.245]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.245]                     base::options(mc.cores = 1L)
[17:39:56.245]                   }
[17:39:56.245]                   ...future.strategy.old <- future::plan("list")
[17:39:56.245]                   options(future.plan = NULL)
[17:39:56.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.245]                 }
[17:39:56.245]                 ...future.workdir <- getwd()
[17:39:56.245]             }
[17:39:56.245]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.245]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.245]         }
[17:39:56.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.245]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.245]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.245]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.245]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.245]             base::names(...future.oldOptions))
[17:39:56.245]     }
[17:39:56.245]     if (FALSE) {
[17:39:56.245]     }
[17:39:56.245]     else {
[17:39:56.245]         if (TRUE) {
[17:39:56.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.245]                 open = "w")
[17:39:56.245]         }
[17:39:56.245]         else {
[17:39:56.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.245]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.245]         }
[17:39:56.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.245]             base::sink(type = "output", split = FALSE)
[17:39:56.245]             base::close(...future.stdout)
[17:39:56.245]         }, add = TRUE)
[17:39:56.245]     }
[17:39:56.245]     ...future.frame <- base::sys.nframe()
[17:39:56.245]     ...future.conditions <- base::list()
[17:39:56.245]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.245]     if (FALSE) {
[17:39:56.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.245]     }
[17:39:56.245]     ...future.result <- base::tryCatch({
[17:39:56.245]         base::withCallingHandlers({
[17:39:56.245]             ...future.value <- base::withVisible(base::local({
[17:39:56.245]                 withCallingHandlers({
[17:39:56.245]                   {
[17:39:56.245]                     b <- a * ii
[17:39:56.245]                     a <- 0
[17:39:56.245]                     b
[17:39:56.245]                   }
[17:39:56.245]                 }, immediateCondition = function(cond) {
[17:39:56.245]                   save_rds <- function (object, pathname, ...) 
[17:39:56.245]                   {
[17:39:56.245]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.245]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.245]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.245]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.245]                         fi_tmp[["mtime"]])
[17:39:56.245]                     }
[17:39:56.245]                     tryCatch({
[17:39:56.245]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.245]                     }, error = function(ex) {
[17:39:56.245]                       msg <- conditionMessage(ex)
[17:39:56.245]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.245]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.245]                         fi_tmp[["mtime"]], msg)
[17:39:56.245]                       ex$message <- msg
[17:39:56.245]                       stop(ex)
[17:39:56.245]                     })
[17:39:56.245]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.245]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.245]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.245]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.245]                       fi <- file.info(pathname)
[17:39:56.245]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.245]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.245]                         fi[["size"]], fi[["mtime"]])
[17:39:56.245]                       stop(msg)
[17:39:56.245]                     }
[17:39:56.245]                     invisible(pathname)
[17:39:56.245]                   }
[17:39:56.245]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.245]                     rootPath = tempdir()) 
[17:39:56.245]                   {
[17:39:56.245]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.245]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.245]                       tmpdir = path, fileext = ".rds")
[17:39:56.245]                     save_rds(obj, file)
[17:39:56.245]                   }
[17:39:56.245]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.245]                   {
[17:39:56.245]                     inherits <- base::inherits
[17:39:56.245]                     invokeRestart <- base::invokeRestart
[17:39:56.245]                     is.null <- base::is.null
[17:39:56.245]                     muffled <- FALSE
[17:39:56.245]                     if (inherits(cond, "message")) {
[17:39:56.245]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.245]                       if (muffled) 
[17:39:56.245]                         invokeRestart("muffleMessage")
[17:39:56.245]                     }
[17:39:56.245]                     else if (inherits(cond, "warning")) {
[17:39:56.245]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.245]                       if (muffled) 
[17:39:56.245]                         invokeRestart("muffleWarning")
[17:39:56.245]                     }
[17:39:56.245]                     else if (inherits(cond, "condition")) {
[17:39:56.245]                       if (!is.null(pattern)) {
[17:39:56.245]                         computeRestarts <- base::computeRestarts
[17:39:56.245]                         grepl <- base::grepl
[17:39:56.245]                         restarts <- computeRestarts(cond)
[17:39:56.245]                         for (restart in restarts) {
[17:39:56.245]                           name <- restart$name
[17:39:56.245]                           if (is.null(name)) 
[17:39:56.245]                             next
[17:39:56.245]                           if (!grepl(pattern, name)) 
[17:39:56.245]                             next
[17:39:56.245]                           invokeRestart(restart)
[17:39:56.245]                           muffled <- TRUE
[17:39:56.245]                           break
[17:39:56.245]                         }
[17:39:56.245]                       }
[17:39:56.245]                     }
[17:39:56.245]                     invisible(muffled)
[17:39:56.245]                   }
[17:39:56.245]                   muffleCondition(cond)
[17:39:56.245]                 })
[17:39:56.245]             }))
[17:39:56.245]             future::FutureResult(value = ...future.value$value, 
[17:39:56.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.245]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.245]                     ...future.globalenv.names))
[17:39:56.245]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.245]         }, condition = base::local({
[17:39:56.245]             c <- base::c
[17:39:56.245]             inherits <- base::inherits
[17:39:56.245]             invokeRestart <- base::invokeRestart
[17:39:56.245]             length <- base::length
[17:39:56.245]             list <- base::list
[17:39:56.245]             seq.int <- base::seq.int
[17:39:56.245]             signalCondition <- base::signalCondition
[17:39:56.245]             sys.calls <- base::sys.calls
[17:39:56.245]             `[[` <- base::`[[`
[17:39:56.245]             `+` <- base::`+`
[17:39:56.245]             `<<-` <- base::`<<-`
[17:39:56.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.245]                   3L)]
[17:39:56.245]             }
[17:39:56.245]             function(cond) {
[17:39:56.245]                 is_error <- inherits(cond, "error")
[17:39:56.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.245]                   NULL)
[17:39:56.245]                 if (is_error) {
[17:39:56.245]                   sessionInformation <- function() {
[17:39:56.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.245]                       search = base::search(), system = base::Sys.info())
[17:39:56.245]                   }
[17:39:56.245]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.245]                     cond$call), session = sessionInformation(), 
[17:39:56.245]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.245]                   signalCondition(cond)
[17:39:56.245]                 }
[17:39:56.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.245]                 "immediateCondition"))) {
[17:39:56.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.245]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.245]                   if (TRUE && !signal) {
[17:39:56.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.245]                     {
[17:39:56.245]                       inherits <- base::inherits
[17:39:56.245]                       invokeRestart <- base::invokeRestart
[17:39:56.245]                       is.null <- base::is.null
[17:39:56.245]                       muffled <- FALSE
[17:39:56.245]                       if (inherits(cond, "message")) {
[17:39:56.245]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.245]                         if (muffled) 
[17:39:56.245]                           invokeRestart("muffleMessage")
[17:39:56.245]                       }
[17:39:56.245]                       else if (inherits(cond, "warning")) {
[17:39:56.245]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.245]                         if (muffled) 
[17:39:56.245]                           invokeRestart("muffleWarning")
[17:39:56.245]                       }
[17:39:56.245]                       else if (inherits(cond, "condition")) {
[17:39:56.245]                         if (!is.null(pattern)) {
[17:39:56.245]                           computeRestarts <- base::computeRestarts
[17:39:56.245]                           grepl <- base::grepl
[17:39:56.245]                           restarts <- computeRestarts(cond)
[17:39:56.245]                           for (restart in restarts) {
[17:39:56.245]                             name <- restart$name
[17:39:56.245]                             if (is.null(name)) 
[17:39:56.245]                               next
[17:39:56.245]                             if (!grepl(pattern, name)) 
[17:39:56.245]                               next
[17:39:56.245]                             invokeRestart(restart)
[17:39:56.245]                             muffled <- TRUE
[17:39:56.245]                             break
[17:39:56.245]                           }
[17:39:56.245]                         }
[17:39:56.245]                       }
[17:39:56.245]                       invisible(muffled)
[17:39:56.245]                     }
[17:39:56.245]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.245]                   }
[17:39:56.245]                 }
[17:39:56.245]                 else {
[17:39:56.245]                   if (TRUE) {
[17:39:56.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.245]                     {
[17:39:56.245]                       inherits <- base::inherits
[17:39:56.245]                       invokeRestart <- base::invokeRestart
[17:39:56.245]                       is.null <- base::is.null
[17:39:56.245]                       muffled <- FALSE
[17:39:56.245]                       if (inherits(cond, "message")) {
[17:39:56.245]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.245]                         if (muffled) 
[17:39:56.245]                           invokeRestart("muffleMessage")
[17:39:56.245]                       }
[17:39:56.245]                       else if (inherits(cond, "warning")) {
[17:39:56.245]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.245]                         if (muffled) 
[17:39:56.245]                           invokeRestart("muffleWarning")
[17:39:56.245]                       }
[17:39:56.245]                       else if (inherits(cond, "condition")) {
[17:39:56.245]                         if (!is.null(pattern)) {
[17:39:56.245]                           computeRestarts <- base::computeRestarts
[17:39:56.245]                           grepl <- base::grepl
[17:39:56.245]                           restarts <- computeRestarts(cond)
[17:39:56.245]                           for (restart in restarts) {
[17:39:56.245]                             name <- restart$name
[17:39:56.245]                             if (is.null(name)) 
[17:39:56.245]                               next
[17:39:56.245]                             if (!grepl(pattern, name)) 
[17:39:56.245]                               next
[17:39:56.245]                             invokeRestart(restart)
[17:39:56.245]                             muffled <- TRUE
[17:39:56.245]                             break
[17:39:56.245]                           }
[17:39:56.245]                         }
[17:39:56.245]                       }
[17:39:56.245]                       invisible(muffled)
[17:39:56.245]                     }
[17:39:56.245]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.245]                   }
[17:39:56.245]                 }
[17:39:56.245]             }
[17:39:56.245]         }))
[17:39:56.245]     }, error = function(ex) {
[17:39:56.245]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.245]                 ...future.rng), started = ...future.startTime, 
[17:39:56.245]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.245]             version = "1.8"), class = "FutureResult")
[17:39:56.245]     }, finally = {
[17:39:56.245]         if (!identical(...future.workdir, getwd())) 
[17:39:56.245]             setwd(...future.workdir)
[17:39:56.245]         {
[17:39:56.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.245]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.245]             }
[17:39:56.245]             base::options(...future.oldOptions)
[17:39:56.245]             if (.Platform$OS.type == "windows") {
[17:39:56.245]                 old_names <- names(...future.oldEnvVars)
[17:39:56.245]                 envs <- base::Sys.getenv()
[17:39:56.245]                 names <- names(envs)
[17:39:56.245]                 common <- intersect(names, old_names)
[17:39:56.245]                 added <- setdiff(names, old_names)
[17:39:56.245]                 removed <- setdiff(old_names, names)
[17:39:56.245]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.245]                   envs[common]]
[17:39:56.245]                 NAMES <- toupper(changed)
[17:39:56.245]                 args <- list()
[17:39:56.245]                 for (kk in seq_along(NAMES)) {
[17:39:56.245]                   name <- changed[[kk]]
[17:39:56.245]                   NAME <- NAMES[[kk]]
[17:39:56.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.245]                     next
[17:39:56.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.245]                 }
[17:39:56.245]                 NAMES <- toupper(added)
[17:39:56.245]                 for (kk in seq_along(NAMES)) {
[17:39:56.245]                   name <- added[[kk]]
[17:39:56.245]                   NAME <- NAMES[[kk]]
[17:39:56.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.245]                     next
[17:39:56.245]                   args[[name]] <- ""
[17:39:56.245]                 }
[17:39:56.245]                 NAMES <- toupper(removed)
[17:39:56.245]                 for (kk in seq_along(NAMES)) {
[17:39:56.245]                   name <- removed[[kk]]
[17:39:56.245]                   NAME <- NAMES[[kk]]
[17:39:56.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.245]                     next
[17:39:56.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.245]                 }
[17:39:56.245]                 if (length(args) > 0) 
[17:39:56.245]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.245]             }
[17:39:56.245]             else {
[17:39:56.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.245]             }
[17:39:56.245]             {
[17:39:56.245]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.245]                   0L) {
[17:39:56.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.245]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.245]                   base::options(opts)
[17:39:56.245]                 }
[17:39:56.245]                 {
[17:39:56.245]                   {
[17:39:56.245]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.245]                     NULL
[17:39:56.245]                   }
[17:39:56.245]                   options(future.plan = NULL)
[17:39:56.245]                   if (is.na(NA_character_)) 
[17:39:56.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.245]                     .init = FALSE)
[17:39:56.245]                 }
[17:39:56.245]             }
[17:39:56.245]         }
[17:39:56.245]     })
[17:39:56.245]     if (TRUE) {
[17:39:56.245]         base::sink(type = "output", split = FALSE)
[17:39:56.245]         if (TRUE) {
[17:39:56.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.245]         }
[17:39:56.245]         else {
[17:39:56.245]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.245]         }
[17:39:56.245]         base::close(...future.stdout)
[17:39:56.245]         ...future.stdout <- NULL
[17:39:56.245]     }
[17:39:56.245]     ...future.result$conditions <- ...future.conditions
[17:39:56.245]     ...future.result$finished <- base::Sys.time()
[17:39:56.245]     ...future.result
[17:39:56.245] }
[17:39:56.247] assign_globals() ...
[17:39:56.248] List of 1
[17:39:56.248]  $ ii: int 3
[17:39:56.248]  - attr(*, "where")=List of 1
[17:39:56.248]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.248]  - attr(*, "resolved")= logi TRUE
[17:39:56.248]  - attr(*, "total_size")= num 56
[17:39:56.248]  - attr(*, "already-done")= logi TRUE
[17:39:56.251] - copied ‘ii’ to environment
[17:39:56.251] assign_globals() ... done
[17:39:56.251] requestCore(): workers = 2
[17:39:56.252] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:56.263] result() for MulticoreFuture ...
[17:39:56.263] result() for MulticoreFuture ...
[17:39:56.264] result() for MulticoreFuture ... done
[17:39:56.264] result() for MulticoreFuture ... done
[17:39:56.264] result() for MulticoreFuture ...
[17:39:56.264] result() for MulticoreFuture ... done
[17:39:56.266] MulticoreFuture started
[17:39:56.267] - Launch lazy future ... done
[17:39:56.267] run() for ‘MulticoreFuture’ ... done
[17:39:56.268] plan(): Setting new future strategy stack:
[17:39:56.268] result() for MulticoreFuture ...
[17:39:56.268] result() for MulticoreFuture ... done
[17:39:56.269] result() for MulticoreFuture ...
[17:39:56.269] result() for MulticoreFuture ... done
[17:39:56.268] List of future strategies:
[17:39:56.268] 1. sequential:
[17:39:56.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.268]    - tweaked: FALSE
[17:39:56.268]    - call: NULL
[17:39:56.269] result() for MulticoreFuture ...
[17:39:56.269] plan(): nbrOfWorkers() = 1
[17:39:56.271] result() for MulticoreFuture ...
[17:39:56.271] result() for MulticoreFuture ... done
[17:39:56.271] result() for MulticoreFuture ... done
[17:39:56.271] result() for MulticoreFuture ...
[17:39:56.272] result() for MulticoreFuture ... done
[17:39:56.272] result() for MulticoreFuture ...
[17:39:56.272] plan(): Setting new future strategy stack:
[17:39:56.272] List of future strategies:
[17:39:56.272] 1. multicore:
[17:39:56.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.272]    - tweaked: FALSE
[17:39:56.272]    - call: plan(strategy)
[17:39:56.278] plan(): nbrOfWorkers() = 2
[17:39:56.279] result() for MulticoreFuture ...
[17:39:56.279] result() for MulticoreFuture ... done
[17:39:56.279] result() for MulticoreFuture ... done
[17:39:56.279] result() for MulticoreFuture ...
[17:39:56.279] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.280] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.280] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.282] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.283] Searching for globals ... DONE
[17:39:56.283] Resolving globals: TRUE
[17:39:56.283] Resolving any globals that are futures ...
[17:39:56.283] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.283] Resolving any globals that are futures ... DONE
[17:39:56.283] Resolving futures part of globals (recursively) ...
[17:39:56.284] resolve() on list ...
[17:39:56.284]  recursive: 99
[17:39:56.284]  length: 1
[17:39:56.284]  elements: ‘ii’
[17:39:56.284]  length: 0 (resolved future 1)
[17:39:56.284] resolve() on list ... DONE
[17:39:56.285] - globals: [1] ‘ii’
[17:39:56.285] Resolving futures part of globals (recursively) ... DONE
[17:39:56.285] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.285] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.285] - globals: [1] ‘ii’
[17:39:56.286] 
[17:39:56.286] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.286] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.287] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.288] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.288] Searching for globals ... DONE
[17:39:56.289] Resolving globals: TRUE
[17:39:56.289] Resolving any globals that are futures ...
[17:39:56.289] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.289] Resolving any globals that are futures ... DONE
[17:39:56.289] Resolving futures part of globals (recursively) ...
[17:39:56.292] resolve() on list ...
[17:39:56.292]  recursive: 99
[17:39:56.292]  length: 1
[17:39:56.292]  elements: ‘ii’
[17:39:56.293]  length: 0 (resolved future 1)
[17:39:56.293] resolve() on list ... DONE
[17:39:56.293] - globals: [1] ‘ii’
[17:39:56.293] Resolving futures part of globals (recursively) ... DONE
[17:39:56.293] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.294] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.294] - globals: [1] ‘ii’
[17:39:56.294] 
[17:39:56.294] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.295] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.295] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.297] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.297] Searching for globals ... DONE
[17:39:56.297] Resolving globals: TRUE
[17:39:56.297] Resolving any globals that are futures ...
[17:39:56.297] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:56.297] Resolving any globals that are futures ... DONE
[17:39:56.298] Resolving futures part of globals (recursively) ...
[17:39:56.298] resolve() on list ...
[17:39:56.298]  recursive: 99
[17:39:56.298]  length: 1
[17:39:56.298]  elements: ‘ii’
[17:39:56.298]  length: 0 (resolved future 1)
[17:39:56.299] resolve() on list ... DONE
[17:39:56.299] - globals: [1] ‘ii’
[17:39:56.299] Resolving futures part of globals (recursively) ... DONE
[17:39:56.299] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.299] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.299] - globals: [1] ‘ii’
[17:39:56.300] 
[17:39:56.300] getGlobalsAndPackages() ... DONE
[17:39:56.300] run() for ‘Future’ ...
[17:39:56.300] - state: ‘created’
[17:39:56.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.304]   - Field: ‘label’
[17:39:56.304]   - Field: ‘local’
[17:39:56.305]   - Field: ‘owner’
[17:39:56.305]   - Field: ‘envir’
[17:39:56.305]   - Field: ‘workers’
[17:39:56.305]   - Field: ‘packages’
[17:39:56.305]   - Field: ‘gc’
[17:39:56.305]   - Field: ‘job’
[17:39:56.305]   - Field: ‘conditions’
[17:39:56.305]   - Field: ‘expr’
[17:39:56.305]   - Field: ‘uuid’
[17:39:56.306]   - Field: ‘seed’
[17:39:56.306]   - Field: ‘version’
[17:39:56.306]   - Field: ‘result’
[17:39:56.306]   - Field: ‘asynchronous’
[17:39:56.306]   - Field: ‘calls’
[17:39:56.306]   - Field: ‘globals’
[17:39:56.306]   - Field: ‘stdout’
[17:39:56.306]   - Field: ‘earlySignal’
[17:39:56.306]   - Field: ‘lazy’
[17:39:56.306]   - Field: ‘state’
[17:39:56.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.307] - Launch lazy future ...
[17:39:56.307] Packages needed by the future expression (n = 0): <none>
[17:39:56.307] Packages needed by future strategies (n = 0): <none>
[17:39:56.308] {
[17:39:56.308]     {
[17:39:56.308]         {
[17:39:56.308]             ...future.startTime <- base::Sys.time()
[17:39:56.308]             {
[17:39:56.308]                 {
[17:39:56.308]                   {
[17:39:56.308]                     {
[17:39:56.308]                       base::local({
[17:39:56.308]                         has_future <- base::requireNamespace("future", 
[17:39:56.308]                           quietly = TRUE)
[17:39:56.308]                         if (has_future) {
[17:39:56.308]                           ns <- base::getNamespace("future")
[17:39:56.308]                           version <- ns[[".package"]][["version"]]
[17:39:56.308]                           if (is.null(version)) 
[17:39:56.308]                             version <- utils::packageVersion("future")
[17:39:56.308]                         }
[17:39:56.308]                         else {
[17:39:56.308]                           version <- NULL
[17:39:56.308]                         }
[17:39:56.308]                         if (!has_future || version < "1.8.0") {
[17:39:56.308]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.308]                             "", base::R.version$version.string), 
[17:39:56.308]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.308]                               "release", "version")], collapse = " "), 
[17:39:56.308]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.308]                             info)
[17:39:56.308]                           info <- base::paste(info, collapse = "; ")
[17:39:56.308]                           if (!has_future) {
[17:39:56.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.308]                               info)
[17:39:56.308]                           }
[17:39:56.308]                           else {
[17:39:56.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.308]                               info, version)
[17:39:56.308]                           }
[17:39:56.308]                           base::stop(msg)
[17:39:56.308]                         }
[17:39:56.308]                       })
[17:39:56.308]                     }
[17:39:56.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.308]                     base::options(mc.cores = 1L)
[17:39:56.308]                   }
[17:39:56.308]                   ...future.strategy.old <- future::plan("list")
[17:39:56.308]                   options(future.plan = NULL)
[17:39:56.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.308]                 }
[17:39:56.308]                 ...future.workdir <- getwd()
[17:39:56.308]             }
[17:39:56.308]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.308]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.308]         }
[17:39:56.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.308]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.308]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.308]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.308]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.308]             base::names(...future.oldOptions))
[17:39:56.308]     }
[17:39:56.308]     if (FALSE) {
[17:39:56.308]     }
[17:39:56.308]     else {
[17:39:56.308]         if (TRUE) {
[17:39:56.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.308]                 open = "w")
[17:39:56.308]         }
[17:39:56.308]         else {
[17:39:56.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.308]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.308]         }
[17:39:56.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.308]             base::sink(type = "output", split = FALSE)
[17:39:56.308]             base::close(...future.stdout)
[17:39:56.308]         }, add = TRUE)
[17:39:56.308]     }
[17:39:56.308]     ...future.frame <- base::sys.nframe()
[17:39:56.308]     ...future.conditions <- base::list()
[17:39:56.308]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.308]     if (FALSE) {
[17:39:56.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.308]     }
[17:39:56.308]     ...future.result <- base::tryCatch({
[17:39:56.308]         base::withCallingHandlers({
[17:39:56.308]             ...future.value <- base::withVisible(base::local({
[17:39:56.308]                 withCallingHandlers({
[17:39:56.308]                   {
[17:39:56.308]                     b <- a * ii
[17:39:56.308]                     a <- 0
[17:39:56.308]                     b
[17:39:56.308]                   }
[17:39:56.308]                 }, immediateCondition = function(cond) {
[17:39:56.308]                   save_rds <- function (object, pathname, ...) 
[17:39:56.308]                   {
[17:39:56.308]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.308]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.308]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.308]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.308]                         fi_tmp[["mtime"]])
[17:39:56.308]                     }
[17:39:56.308]                     tryCatch({
[17:39:56.308]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.308]                     }, error = function(ex) {
[17:39:56.308]                       msg <- conditionMessage(ex)
[17:39:56.308]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.308]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.308]                         fi_tmp[["mtime"]], msg)
[17:39:56.308]                       ex$message <- msg
[17:39:56.308]                       stop(ex)
[17:39:56.308]                     })
[17:39:56.308]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.308]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.308]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.308]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.308]                       fi <- file.info(pathname)
[17:39:56.308]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.308]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.308]                         fi[["size"]], fi[["mtime"]])
[17:39:56.308]                       stop(msg)
[17:39:56.308]                     }
[17:39:56.308]                     invisible(pathname)
[17:39:56.308]                   }
[17:39:56.308]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.308]                     rootPath = tempdir()) 
[17:39:56.308]                   {
[17:39:56.308]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.308]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.308]                       tmpdir = path, fileext = ".rds")
[17:39:56.308]                     save_rds(obj, file)
[17:39:56.308]                   }
[17:39:56.308]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.308]                   {
[17:39:56.308]                     inherits <- base::inherits
[17:39:56.308]                     invokeRestart <- base::invokeRestart
[17:39:56.308]                     is.null <- base::is.null
[17:39:56.308]                     muffled <- FALSE
[17:39:56.308]                     if (inherits(cond, "message")) {
[17:39:56.308]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.308]                       if (muffled) 
[17:39:56.308]                         invokeRestart("muffleMessage")
[17:39:56.308]                     }
[17:39:56.308]                     else if (inherits(cond, "warning")) {
[17:39:56.308]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.308]                       if (muffled) 
[17:39:56.308]                         invokeRestart("muffleWarning")
[17:39:56.308]                     }
[17:39:56.308]                     else if (inherits(cond, "condition")) {
[17:39:56.308]                       if (!is.null(pattern)) {
[17:39:56.308]                         computeRestarts <- base::computeRestarts
[17:39:56.308]                         grepl <- base::grepl
[17:39:56.308]                         restarts <- computeRestarts(cond)
[17:39:56.308]                         for (restart in restarts) {
[17:39:56.308]                           name <- restart$name
[17:39:56.308]                           if (is.null(name)) 
[17:39:56.308]                             next
[17:39:56.308]                           if (!grepl(pattern, name)) 
[17:39:56.308]                             next
[17:39:56.308]                           invokeRestart(restart)
[17:39:56.308]                           muffled <- TRUE
[17:39:56.308]                           break
[17:39:56.308]                         }
[17:39:56.308]                       }
[17:39:56.308]                     }
[17:39:56.308]                     invisible(muffled)
[17:39:56.308]                   }
[17:39:56.308]                   muffleCondition(cond)
[17:39:56.308]                 })
[17:39:56.308]             }))
[17:39:56.308]             future::FutureResult(value = ...future.value$value, 
[17:39:56.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.308]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.308]                     ...future.globalenv.names))
[17:39:56.308]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.308]         }, condition = base::local({
[17:39:56.308]             c <- base::c
[17:39:56.308]             inherits <- base::inherits
[17:39:56.308]             invokeRestart <- base::invokeRestart
[17:39:56.308]             length <- base::length
[17:39:56.308]             list <- base::list
[17:39:56.308]             seq.int <- base::seq.int
[17:39:56.308]             signalCondition <- base::signalCondition
[17:39:56.308]             sys.calls <- base::sys.calls
[17:39:56.308]             `[[` <- base::`[[`
[17:39:56.308]             `+` <- base::`+`
[17:39:56.308]             `<<-` <- base::`<<-`
[17:39:56.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.308]                   3L)]
[17:39:56.308]             }
[17:39:56.308]             function(cond) {
[17:39:56.308]                 is_error <- inherits(cond, "error")
[17:39:56.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.308]                   NULL)
[17:39:56.308]                 if (is_error) {
[17:39:56.308]                   sessionInformation <- function() {
[17:39:56.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.308]                       search = base::search(), system = base::Sys.info())
[17:39:56.308]                   }
[17:39:56.308]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.308]                     cond$call), session = sessionInformation(), 
[17:39:56.308]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.308]                   signalCondition(cond)
[17:39:56.308]                 }
[17:39:56.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.308]                 "immediateCondition"))) {
[17:39:56.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.308]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.308]                   if (TRUE && !signal) {
[17:39:56.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.308]                     {
[17:39:56.308]                       inherits <- base::inherits
[17:39:56.308]                       invokeRestart <- base::invokeRestart
[17:39:56.308]                       is.null <- base::is.null
[17:39:56.308]                       muffled <- FALSE
[17:39:56.308]                       if (inherits(cond, "message")) {
[17:39:56.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.308]                         if (muffled) 
[17:39:56.308]                           invokeRestart("muffleMessage")
[17:39:56.308]                       }
[17:39:56.308]                       else if (inherits(cond, "warning")) {
[17:39:56.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.308]                         if (muffled) 
[17:39:56.308]                           invokeRestart("muffleWarning")
[17:39:56.308]                       }
[17:39:56.308]                       else if (inherits(cond, "condition")) {
[17:39:56.308]                         if (!is.null(pattern)) {
[17:39:56.308]                           computeRestarts <- base::computeRestarts
[17:39:56.308]                           grepl <- base::grepl
[17:39:56.308]                           restarts <- computeRestarts(cond)
[17:39:56.308]                           for (restart in restarts) {
[17:39:56.308]                             name <- restart$name
[17:39:56.308]                             if (is.null(name)) 
[17:39:56.308]                               next
[17:39:56.308]                             if (!grepl(pattern, name)) 
[17:39:56.308]                               next
[17:39:56.308]                             invokeRestart(restart)
[17:39:56.308]                             muffled <- TRUE
[17:39:56.308]                             break
[17:39:56.308]                           }
[17:39:56.308]                         }
[17:39:56.308]                       }
[17:39:56.308]                       invisible(muffled)
[17:39:56.308]                     }
[17:39:56.308]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.308]                   }
[17:39:56.308]                 }
[17:39:56.308]                 else {
[17:39:56.308]                   if (TRUE) {
[17:39:56.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.308]                     {
[17:39:56.308]                       inherits <- base::inherits
[17:39:56.308]                       invokeRestart <- base::invokeRestart
[17:39:56.308]                       is.null <- base::is.null
[17:39:56.308]                       muffled <- FALSE
[17:39:56.308]                       if (inherits(cond, "message")) {
[17:39:56.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.308]                         if (muffled) 
[17:39:56.308]                           invokeRestart("muffleMessage")
[17:39:56.308]                       }
[17:39:56.308]                       else if (inherits(cond, "warning")) {
[17:39:56.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.308]                         if (muffled) 
[17:39:56.308]                           invokeRestart("muffleWarning")
[17:39:56.308]                       }
[17:39:56.308]                       else if (inherits(cond, "condition")) {
[17:39:56.308]                         if (!is.null(pattern)) {
[17:39:56.308]                           computeRestarts <- base::computeRestarts
[17:39:56.308]                           grepl <- base::grepl
[17:39:56.308]                           restarts <- computeRestarts(cond)
[17:39:56.308]                           for (restart in restarts) {
[17:39:56.308]                             name <- restart$name
[17:39:56.308]                             if (is.null(name)) 
[17:39:56.308]                               next
[17:39:56.308]                             if (!grepl(pattern, name)) 
[17:39:56.308]                               next
[17:39:56.308]                             invokeRestart(restart)
[17:39:56.308]                             muffled <- TRUE
[17:39:56.308]                             break
[17:39:56.308]                           }
[17:39:56.308]                         }
[17:39:56.308]                       }
[17:39:56.308]                       invisible(muffled)
[17:39:56.308]                     }
[17:39:56.308]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.308]                   }
[17:39:56.308]                 }
[17:39:56.308]             }
[17:39:56.308]         }))
[17:39:56.308]     }, error = function(ex) {
[17:39:56.308]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.308]                 ...future.rng), started = ...future.startTime, 
[17:39:56.308]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.308]             version = "1.8"), class = "FutureResult")
[17:39:56.308]     }, finally = {
[17:39:56.308]         if (!identical(...future.workdir, getwd())) 
[17:39:56.308]             setwd(...future.workdir)
[17:39:56.308]         {
[17:39:56.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.308]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.308]             }
[17:39:56.308]             base::options(...future.oldOptions)
[17:39:56.308]             if (.Platform$OS.type == "windows") {
[17:39:56.308]                 old_names <- names(...future.oldEnvVars)
[17:39:56.308]                 envs <- base::Sys.getenv()
[17:39:56.308]                 names <- names(envs)
[17:39:56.308]                 common <- intersect(names, old_names)
[17:39:56.308]                 added <- setdiff(names, old_names)
[17:39:56.308]                 removed <- setdiff(old_names, names)
[17:39:56.308]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.308]                   envs[common]]
[17:39:56.308]                 NAMES <- toupper(changed)
[17:39:56.308]                 args <- list()
[17:39:56.308]                 for (kk in seq_along(NAMES)) {
[17:39:56.308]                   name <- changed[[kk]]
[17:39:56.308]                   NAME <- NAMES[[kk]]
[17:39:56.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.308]                     next
[17:39:56.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.308]                 }
[17:39:56.308]                 NAMES <- toupper(added)
[17:39:56.308]                 for (kk in seq_along(NAMES)) {
[17:39:56.308]                   name <- added[[kk]]
[17:39:56.308]                   NAME <- NAMES[[kk]]
[17:39:56.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.308]                     next
[17:39:56.308]                   args[[name]] <- ""
[17:39:56.308]                 }
[17:39:56.308]                 NAMES <- toupper(removed)
[17:39:56.308]                 for (kk in seq_along(NAMES)) {
[17:39:56.308]                   name <- removed[[kk]]
[17:39:56.308]                   NAME <- NAMES[[kk]]
[17:39:56.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.308]                     next
[17:39:56.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.308]                 }
[17:39:56.308]                 if (length(args) > 0) 
[17:39:56.308]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.308]             }
[17:39:56.308]             else {
[17:39:56.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.308]             }
[17:39:56.308]             {
[17:39:56.308]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.308]                   0L) {
[17:39:56.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.308]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.308]                   base::options(opts)
[17:39:56.308]                 }
[17:39:56.308]                 {
[17:39:56.308]                   {
[17:39:56.308]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.308]                     NULL
[17:39:56.308]                   }
[17:39:56.308]                   options(future.plan = NULL)
[17:39:56.308]                   if (is.na(NA_character_)) 
[17:39:56.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.308]                     .init = FALSE)
[17:39:56.308]                 }
[17:39:56.308]             }
[17:39:56.308]         }
[17:39:56.308]     })
[17:39:56.308]     if (TRUE) {
[17:39:56.308]         base::sink(type = "output", split = FALSE)
[17:39:56.308]         if (TRUE) {
[17:39:56.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.308]         }
[17:39:56.308]         else {
[17:39:56.308]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.308]         }
[17:39:56.308]         base::close(...future.stdout)
[17:39:56.308]         ...future.stdout <- NULL
[17:39:56.308]     }
[17:39:56.308]     ...future.result$conditions <- ...future.conditions
[17:39:56.308]     ...future.result$finished <- base::Sys.time()
[17:39:56.308]     ...future.result
[17:39:56.308] }
[17:39:56.310] assign_globals() ...
[17:39:56.310] List of 1
[17:39:56.310]  $ ii: int 1
[17:39:56.310]  - attr(*, "where")=List of 1
[17:39:56.310]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.310]  - attr(*, "resolved")= logi TRUE
[17:39:56.310]  - attr(*, "total_size")= num 56
[17:39:56.310]  - attr(*, "already-done")= logi TRUE
[17:39:56.312] - copied ‘ii’ to environment
[17:39:56.312] assign_globals() ... done
[17:39:56.313] requestCore(): workers = 2
[17:39:56.314] MulticoreFuture started
[17:39:56.315] - Launch lazy future ... done
[17:39:56.315] run() for ‘MulticoreFuture’ ... done
[17:39:56.315] result() for MulticoreFuture ...
[17:39:56.315] plan(): Setting new future strategy stack:
[17:39:56.315] List of future strategies:
[17:39:56.315] 1. sequential:
[17:39:56.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.315]    - tweaked: FALSE
[17:39:56.315]    - call: NULL
[17:39:56.317] plan(): nbrOfWorkers() = 1
[17:39:56.319] plan(): Setting new future strategy stack:
[17:39:56.319] List of future strategies:
[17:39:56.319] 1. multicore:
[17:39:56.319]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.319]    - tweaked: FALSE
[17:39:56.319]    - call: plan(strategy)
[17:39:56.324] plan(): nbrOfWorkers() = 2
[17:39:56.330] result() for MulticoreFuture ...
[17:39:56.330] result() for MulticoreFuture ... done
[17:39:56.330] signalConditions() ...
[17:39:56.330]  - include = ‘immediateCondition’
[17:39:56.330]  - exclude = 
[17:39:56.330]  - resignal = FALSE
[17:39:56.330]  - Number of conditions: 1
[17:39:56.330] signalConditions() ... done
[17:39:56.331] result() for MulticoreFuture ... done
[17:39:56.331] result() for MulticoreFuture ...
[17:39:56.331] result() for MulticoreFuture ... done
[17:39:56.331] signalConditions() ...
[17:39:56.331]  - include = ‘immediateCondition’
[17:39:56.331]  - exclude = 
[17:39:56.331]  - resignal = FALSE
[17:39:56.331]  - Number of conditions: 1
[17:39:56.331] signalConditions() ... done
[17:39:56.332] Future state: ‘finished’
[17:39:56.332] result() for MulticoreFuture ...
[17:39:56.332] result() for MulticoreFuture ... done
[17:39:56.332] signalConditions() ...
[17:39:56.332]  - include = ‘condition’
[17:39:56.332]  - exclude = ‘immediateCondition’
[17:39:56.332]  - resignal = TRUE
[17:39:56.332]  - Number of conditions: 1
[17:39:56.333]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:56.333] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:56"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.363] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.364] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.364] 
[17:39:56.364] Searching for globals ... DONE
[17:39:56.364] - globals: [0] <none>
[17:39:56.365] getGlobalsAndPackages() ... DONE
[17:39:56.365] run() for ‘Future’ ...
[17:39:56.365] - state: ‘created’
[17:39:56.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.369]   - Field: ‘label’
[17:39:56.369]   - Field: ‘local’
[17:39:56.369]   - Field: ‘owner’
[17:39:56.369]   - Field: ‘envir’
[17:39:56.369]   - Field: ‘workers’
[17:39:56.369]   - Field: ‘packages’
[17:39:56.370]   - Field: ‘gc’
[17:39:56.370]   - Field: ‘job’
[17:39:56.370]   - Field: ‘conditions’
[17:39:56.370]   - Field: ‘expr’
[17:39:56.370]   - Field: ‘uuid’
[17:39:56.370]   - Field: ‘seed’
[17:39:56.370]   - Field: ‘version’
[17:39:56.370]   - Field: ‘result’
[17:39:56.370]   - Field: ‘asynchronous’
[17:39:56.370]   - Field: ‘calls’
[17:39:56.370]   - Field: ‘globals’
[17:39:56.371]   - Field: ‘stdout’
[17:39:56.371]   - Field: ‘earlySignal’
[17:39:56.371]   - Field: ‘lazy’
[17:39:56.371]   - Field: ‘state’
[17:39:56.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.371] - Launch lazy future ...
[17:39:56.371] Packages needed by the future expression (n = 0): <none>
[17:39:56.371] Packages needed by future strategies (n = 0): <none>
[17:39:56.372] {
[17:39:56.372]     {
[17:39:56.372]         {
[17:39:56.372]             ...future.startTime <- base::Sys.time()
[17:39:56.372]             {
[17:39:56.372]                 {
[17:39:56.372]                   {
[17:39:56.372]                     {
[17:39:56.372]                       base::local({
[17:39:56.372]                         has_future <- base::requireNamespace("future", 
[17:39:56.372]                           quietly = TRUE)
[17:39:56.372]                         if (has_future) {
[17:39:56.372]                           ns <- base::getNamespace("future")
[17:39:56.372]                           version <- ns[[".package"]][["version"]]
[17:39:56.372]                           if (is.null(version)) 
[17:39:56.372]                             version <- utils::packageVersion("future")
[17:39:56.372]                         }
[17:39:56.372]                         else {
[17:39:56.372]                           version <- NULL
[17:39:56.372]                         }
[17:39:56.372]                         if (!has_future || version < "1.8.0") {
[17:39:56.372]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.372]                             "", base::R.version$version.string), 
[17:39:56.372]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.372]                               "release", "version")], collapse = " "), 
[17:39:56.372]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.372]                             info)
[17:39:56.372]                           info <- base::paste(info, collapse = "; ")
[17:39:56.372]                           if (!has_future) {
[17:39:56.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.372]                               info)
[17:39:56.372]                           }
[17:39:56.372]                           else {
[17:39:56.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.372]                               info, version)
[17:39:56.372]                           }
[17:39:56.372]                           base::stop(msg)
[17:39:56.372]                         }
[17:39:56.372]                       })
[17:39:56.372]                     }
[17:39:56.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.372]                     base::options(mc.cores = 1L)
[17:39:56.372]                   }
[17:39:56.372]                   ...future.strategy.old <- future::plan("list")
[17:39:56.372]                   options(future.plan = NULL)
[17:39:56.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.372]                 }
[17:39:56.372]                 ...future.workdir <- getwd()
[17:39:56.372]             }
[17:39:56.372]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.372]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.372]         }
[17:39:56.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.372]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.372]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.372]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.372]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.372]             base::names(...future.oldOptions))
[17:39:56.372]     }
[17:39:56.372]     if (FALSE) {
[17:39:56.372]     }
[17:39:56.372]     else {
[17:39:56.372]         if (TRUE) {
[17:39:56.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.372]                 open = "w")
[17:39:56.372]         }
[17:39:56.372]         else {
[17:39:56.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.372]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.372]         }
[17:39:56.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.372]             base::sink(type = "output", split = FALSE)
[17:39:56.372]             base::close(...future.stdout)
[17:39:56.372]         }, add = TRUE)
[17:39:56.372]     }
[17:39:56.372]     ...future.frame <- base::sys.nframe()
[17:39:56.372]     ...future.conditions <- base::list()
[17:39:56.372]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.372]     if (FALSE) {
[17:39:56.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.372]     }
[17:39:56.372]     ...future.result <- base::tryCatch({
[17:39:56.372]         base::withCallingHandlers({
[17:39:56.372]             ...future.value <- base::withVisible(base::local({
[17:39:56.372]                 withCallingHandlers({
[17:39:56.372]                   1
[17:39:56.372]                 }, immediateCondition = function(cond) {
[17:39:56.372]                   save_rds <- function (object, pathname, ...) 
[17:39:56.372]                   {
[17:39:56.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.372]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.372]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.372]                         fi_tmp[["mtime"]])
[17:39:56.372]                     }
[17:39:56.372]                     tryCatch({
[17:39:56.372]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.372]                     }, error = function(ex) {
[17:39:56.372]                       msg <- conditionMessage(ex)
[17:39:56.372]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.372]                         fi_tmp[["mtime"]], msg)
[17:39:56.372]                       ex$message <- msg
[17:39:56.372]                       stop(ex)
[17:39:56.372]                     })
[17:39:56.372]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.372]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.372]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.372]                       fi <- file.info(pathname)
[17:39:56.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.372]                         fi[["size"]], fi[["mtime"]])
[17:39:56.372]                       stop(msg)
[17:39:56.372]                     }
[17:39:56.372]                     invisible(pathname)
[17:39:56.372]                   }
[17:39:56.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.372]                     rootPath = tempdir()) 
[17:39:56.372]                   {
[17:39:56.372]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.372]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.372]                       tmpdir = path, fileext = ".rds")
[17:39:56.372]                     save_rds(obj, file)
[17:39:56.372]                   }
[17:39:56.372]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.372]                   {
[17:39:56.372]                     inherits <- base::inherits
[17:39:56.372]                     invokeRestart <- base::invokeRestart
[17:39:56.372]                     is.null <- base::is.null
[17:39:56.372]                     muffled <- FALSE
[17:39:56.372]                     if (inherits(cond, "message")) {
[17:39:56.372]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.372]                       if (muffled) 
[17:39:56.372]                         invokeRestart("muffleMessage")
[17:39:56.372]                     }
[17:39:56.372]                     else if (inherits(cond, "warning")) {
[17:39:56.372]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.372]                       if (muffled) 
[17:39:56.372]                         invokeRestart("muffleWarning")
[17:39:56.372]                     }
[17:39:56.372]                     else if (inherits(cond, "condition")) {
[17:39:56.372]                       if (!is.null(pattern)) {
[17:39:56.372]                         computeRestarts <- base::computeRestarts
[17:39:56.372]                         grepl <- base::grepl
[17:39:56.372]                         restarts <- computeRestarts(cond)
[17:39:56.372]                         for (restart in restarts) {
[17:39:56.372]                           name <- restart$name
[17:39:56.372]                           if (is.null(name)) 
[17:39:56.372]                             next
[17:39:56.372]                           if (!grepl(pattern, name)) 
[17:39:56.372]                             next
[17:39:56.372]                           invokeRestart(restart)
[17:39:56.372]                           muffled <- TRUE
[17:39:56.372]                           break
[17:39:56.372]                         }
[17:39:56.372]                       }
[17:39:56.372]                     }
[17:39:56.372]                     invisible(muffled)
[17:39:56.372]                   }
[17:39:56.372]                   muffleCondition(cond)
[17:39:56.372]                 })
[17:39:56.372]             }))
[17:39:56.372]             future::FutureResult(value = ...future.value$value, 
[17:39:56.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.372]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.372]                     ...future.globalenv.names))
[17:39:56.372]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.372]         }, condition = base::local({
[17:39:56.372]             c <- base::c
[17:39:56.372]             inherits <- base::inherits
[17:39:56.372]             invokeRestart <- base::invokeRestart
[17:39:56.372]             length <- base::length
[17:39:56.372]             list <- base::list
[17:39:56.372]             seq.int <- base::seq.int
[17:39:56.372]             signalCondition <- base::signalCondition
[17:39:56.372]             sys.calls <- base::sys.calls
[17:39:56.372]             `[[` <- base::`[[`
[17:39:56.372]             `+` <- base::`+`
[17:39:56.372]             `<<-` <- base::`<<-`
[17:39:56.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.372]                   3L)]
[17:39:56.372]             }
[17:39:56.372]             function(cond) {
[17:39:56.372]                 is_error <- inherits(cond, "error")
[17:39:56.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.372]                   NULL)
[17:39:56.372]                 if (is_error) {
[17:39:56.372]                   sessionInformation <- function() {
[17:39:56.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.372]                       search = base::search(), system = base::Sys.info())
[17:39:56.372]                   }
[17:39:56.372]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.372]                     cond$call), session = sessionInformation(), 
[17:39:56.372]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.372]                   signalCondition(cond)
[17:39:56.372]                 }
[17:39:56.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.372]                 "immediateCondition"))) {
[17:39:56.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.372]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.372]                   if (TRUE && !signal) {
[17:39:56.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.372]                     {
[17:39:56.372]                       inherits <- base::inherits
[17:39:56.372]                       invokeRestart <- base::invokeRestart
[17:39:56.372]                       is.null <- base::is.null
[17:39:56.372]                       muffled <- FALSE
[17:39:56.372]                       if (inherits(cond, "message")) {
[17:39:56.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.372]                         if (muffled) 
[17:39:56.372]                           invokeRestart("muffleMessage")
[17:39:56.372]                       }
[17:39:56.372]                       else if (inherits(cond, "warning")) {
[17:39:56.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.372]                         if (muffled) 
[17:39:56.372]                           invokeRestart("muffleWarning")
[17:39:56.372]                       }
[17:39:56.372]                       else if (inherits(cond, "condition")) {
[17:39:56.372]                         if (!is.null(pattern)) {
[17:39:56.372]                           computeRestarts <- base::computeRestarts
[17:39:56.372]                           grepl <- base::grepl
[17:39:56.372]                           restarts <- computeRestarts(cond)
[17:39:56.372]                           for (restart in restarts) {
[17:39:56.372]                             name <- restart$name
[17:39:56.372]                             if (is.null(name)) 
[17:39:56.372]                               next
[17:39:56.372]                             if (!grepl(pattern, name)) 
[17:39:56.372]                               next
[17:39:56.372]                             invokeRestart(restart)
[17:39:56.372]                             muffled <- TRUE
[17:39:56.372]                             break
[17:39:56.372]                           }
[17:39:56.372]                         }
[17:39:56.372]                       }
[17:39:56.372]                       invisible(muffled)
[17:39:56.372]                     }
[17:39:56.372]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.372]                   }
[17:39:56.372]                 }
[17:39:56.372]                 else {
[17:39:56.372]                   if (TRUE) {
[17:39:56.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.372]                     {
[17:39:56.372]                       inherits <- base::inherits
[17:39:56.372]                       invokeRestart <- base::invokeRestart
[17:39:56.372]                       is.null <- base::is.null
[17:39:56.372]                       muffled <- FALSE
[17:39:56.372]                       if (inherits(cond, "message")) {
[17:39:56.372]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.372]                         if (muffled) 
[17:39:56.372]                           invokeRestart("muffleMessage")
[17:39:56.372]                       }
[17:39:56.372]                       else if (inherits(cond, "warning")) {
[17:39:56.372]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.372]                         if (muffled) 
[17:39:56.372]                           invokeRestart("muffleWarning")
[17:39:56.372]                       }
[17:39:56.372]                       else if (inherits(cond, "condition")) {
[17:39:56.372]                         if (!is.null(pattern)) {
[17:39:56.372]                           computeRestarts <- base::computeRestarts
[17:39:56.372]                           grepl <- base::grepl
[17:39:56.372]                           restarts <- computeRestarts(cond)
[17:39:56.372]                           for (restart in restarts) {
[17:39:56.372]                             name <- restart$name
[17:39:56.372]                             if (is.null(name)) 
[17:39:56.372]                               next
[17:39:56.372]                             if (!grepl(pattern, name)) 
[17:39:56.372]                               next
[17:39:56.372]                             invokeRestart(restart)
[17:39:56.372]                             muffled <- TRUE
[17:39:56.372]                             break
[17:39:56.372]                           }
[17:39:56.372]                         }
[17:39:56.372]                       }
[17:39:56.372]                       invisible(muffled)
[17:39:56.372]                     }
[17:39:56.372]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.372]                   }
[17:39:56.372]                 }
[17:39:56.372]             }
[17:39:56.372]         }))
[17:39:56.372]     }, error = function(ex) {
[17:39:56.372]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.372]                 ...future.rng), started = ...future.startTime, 
[17:39:56.372]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.372]             version = "1.8"), class = "FutureResult")
[17:39:56.372]     }, finally = {
[17:39:56.372]         if (!identical(...future.workdir, getwd())) 
[17:39:56.372]             setwd(...future.workdir)
[17:39:56.372]         {
[17:39:56.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.372]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.372]             }
[17:39:56.372]             base::options(...future.oldOptions)
[17:39:56.372]             if (.Platform$OS.type == "windows") {
[17:39:56.372]                 old_names <- names(...future.oldEnvVars)
[17:39:56.372]                 envs <- base::Sys.getenv()
[17:39:56.372]                 names <- names(envs)
[17:39:56.372]                 common <- intersect(names, old_names)
[17:39:56.372]                 added <- setdiff(names, old_names)
[17:39:56.372]                 removed <- setdiff(old_names, names)
[17:39:56.372]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.372]                   envs[common]]
[17:39:56.372]                 NAMES <- toupper(changed)
[17:39:56.372]                 args <- list()
[17:39:56.372]                 for (kk in seq_along(NAMES)) {
[17:39:56.372]                   name <- changed[[kk]]
[17:39:56.372]                   NAME <- NAMES[[kk]]
[17:39:56.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.372]                     next
[17:39:56.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.372]                 }
[17:39:56.372]                 NAMES <- toupper(added)
[17:39:56.372]                 for (kk in seq_along(NAMES)) {
[17:39:56.372]                   name <- added[[kk]]
[17:39:56.372]                   NAME <- NAMES[[kk]]
[17:39:56.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.372]                     next
[17:39:56.372]                   args[[name]] <- ""
[17:39:56.372]                 }
[17:39:56.372]                 NAMES <- toupper(removed)
[17:39:56.372]                 for (kk in seq_along(NAMES)) {
[17:39:56.372]                   name <- removed[[kk]]
[17:39:56.372]                   NAME <- NAMES[[kk]]
[17:39:56.372]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.372]                     next
[17:39:56.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.372]                 }
[17:39:56.372]                 if (length(args) > 0) 
[17:39:56.372]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.372]             }
[17:39:56.372]             else {
[17:39:56.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.372]             }
[17:39:56.372]             {
[17:39:56.372]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.372]                   0L) {
[17:39:56.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.372]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.372]                   base::options(opts)
[17:39:56.372]                 }
[17:39:56.372]                 {
[17:39:56.372]                   {
[17:39:56.372]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.372]                     NULL
[17:39:56.372]                   }
[17:39:56.372]                   options(future.plan = NULL)
[17:39:56.372]                   if (is.na(NA_character_)) 
[17:39:56.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.372]                     .init = FALSE)
[17:39:56.372]                 }
[17:39:56.372]             }
[17:39:56.372]         }
[17:39:56.372]     })
[17:39:56.372]     if (TRUE) {
[17:39:56.372]         base::sink(type = "output", split = FALSE)
[17:39:56.372]         if (TRUE) {
[17:39:56.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.372]         }
[17:39:56.372]         else {
[17:39:56.372]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.372]         }
[17:39:56.372]         base::close(...future.stdout)
[17:39:56.372]         ...future.stdout <- NULL
[17:39:56.372]     }
[17:39:56.372]     ...future.result$conditions <- ...future.conditions
[17:39:56.372]     ...future.result$finished <- base::Sys.time()
[17:39:56.372]     ...future.result
[17:39:56.372] }
[17:39:56.374] requestCore(): workers = 2
[17:39:56.376] MulticoreFuture started
[17:39:56.376] - Launch lazy future ... done
[17:39:56.376] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.377] plan(): Setting new future strategy stack:
[17:39:56.377] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.378] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.377] List of future strategies:
[17:39:56.377] 1. sequential:
[17:39:56.377]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.377]    - tweaked: FALSE
[17:39:56.377]    - call: NULL
[17:39:56.378] plan(): nbrOfWorkers() = 1
[17:39:56.379] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:56.380] Searching for globals ... DONE
[17:39:56.380] Resolving globals: TRUE
[17:39:56.380] Resolving any globals that are futures ...
[17:39:56.380] plan(): Setting new future strategy stack:
[17:39:56.380] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:56.380] Resolving any globals that are futures ... DONE
[17:39:56.380] List of future strategies:
[17:39:56.380] 1. multicore:
[17:39:56.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.380]    - tweaked: FALSE
[17:39:56.380]    - call: plan(strategy)
[17:39:56.381] Resolving futures part of globals (recursively) ...
[17:39:56.382] resolve() on list ...
[17:39:56.382]  recursive: 99
[17:39:56.382]  length: 1
[17:39:56.382]  elements: ‘a’
[17:39:56.385] plan(): nbrOfWorkers() = 2
[17:39:56.386] Future #1
[17:39:56.386] result() for MulticoreFuture ...
[17:39:56.387] result() for MulticoreFuture ...
[17:39:56.387] result() for MulticoreFuture ... done
[17:39:56.387] result() for MulticoreFuture ... done
[17:39:56.387] result() for MulticoreFuture ...
[17:39:56.387] result() for MulticoreFuture ... done
[17:39:56.388] A MulticoreFuture was resolved
[17:39:56.388]  length: 0 (resolved future 1)
[17:39:56.388] resolve() on list ... DONE
[17:39:56.388] - globals: [1] ‘a’
[17:39:56.388] Resolving futures part of globals (recursively) ... DONE
[17:39:56.389] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:39:56.390] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:39:56.390] - globals: [1] ‘a’
[17:39:56.390] - packages: [1] ‘future’
[17:39:56.390] getGlobalsAndPackages() ... DONE
[17:39:56.391] run() for ‘Future’ ...
[17:39:56.391] - state: ‘created’
[17:39:56.391] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.397] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.397]   - Field: ‘label’
[17:39:56.397]   - Field: ‘local’
[17:39:56.397]   - Field: ‘owner’
[17:39:56.398]   - Field: ‘envir’
[17:39:56.398]   - Field: ‘workers’
[17:39:56.398]   - Field: ‘packages’
[17:39:56.398]   - Field: ‘gc’
[17:39:56.398]   - Field: ‘job’
[17:39:56.398]   - Field: ‘conditions’
[17:39:56.398]   - Field: ‘expr’
[17:39:56.399]   - Field: ‘uuid’
[17:39:56.399]   - Field: ‘seed’
[17:39:56.399]   - Field: ‘version’
[17:39:56.399]   - Field: ‘result’
[17:39:56.399]   - Field: ‘asynchronous’
[17:39:56.399]   - Field: ‘calls’
[17:39:56.399]   - Field: ‘globals’
[17:39:56.399]   - Field: ‘stdout’
[17:39:56.400]   - Field: ‘earlySignal’
[17:39:56.400]   - Field: ‘lazy’
[17:39:56.402]   - Field: ‘state’
[17:39:56.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.402] - Launch lazy future ...
[17:39:56.403] Packages needed by the future expression (n = 1): ‘future’
[17:39:56.403] Packages needed by future strategies (n = 0): <none>
[17:39:56.404] {
[17:39:56.404]     {
[17:39:56.404]         {
[17:39:56.404]             ...future.startTime <- base::Sys.time()
[17:39:56.404]             {
[17:39:56.404]                 {
[17:39:56.404]                   {
[17:39:56.404]                     {
[17:39:56.404]                       {
[17:39:56.404]                         base::local({
[17:39:56.404]                           has_future <- base::requireNamespace("future", 
[17:39:56.404]                             quietly = TRUE)
[17:39:56.404]                           if (has_future) {
[17:39:56.404]                             ns <- base::getNamespace("future")
[17:39:56.404]                             version <- ns[[".package"]][["version"]]
[17:39:56.404]                             if (is.null(version)) 
[17:39:56.404]                               version <- utils::packageVersion("future")
[17:39:56.404]                           }
[17:39:56.404]                           else {
[17:39:56.404]                             version <- NULL
[17:39:56.404]                           }
[17:39:56.404]                           if (!has_future || version < "1.8.0") {
[17:39:56.404]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.404]                               "", base::R.version$version.string), 
[17:39:56.404]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:56.404]                                 base::R.version$platform, 8 * 
[17:39:56.404]                                   base::.Machine$sizeof.pointer), 
[17:39:56.404]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.404]                                 "release", "version")], collapse = " "), 
[17:39:56.404]                               hostname = base::Sys.info()[["nodename"]])
[17:39:56.404]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.404]                               info)
[17:39:56.404]                             info <- base::paste(info, collapse = "; ")
[17:39:56.404]                             if (!has_future) {
[17:39:56.404]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.404]                                 info)
[17:39:56.404]                             }
[17:39:56.404]                             else {
[17:39:56.404]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.404]                                 info, version)
[17:39:56.404]                             }
[17:39:56.404]                             base::stop(msg)
[17:39:56.404]                           }
[17:39:56.404]                         })
[17:39:56.404]                       }
[17:39:56.404]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.404]                       base::options(mc.cores = 1L)
[17:39:56.404]                     }
[17:39:56.404]                     base::local({
[17:39:56.404]                       for (pkg in "future") {
[17:39:56.404]                         base::loadNamespace(pkg)
[17:39:56.404]                         base::library(pkg, character.only = TRUE)
[17:39:56.404]                       }
[17:39:56.404]                     })
[17:39:56.404]                   }
[17:39:56.404]                   ...future.strategy.old <- future::plan("list")
[17:39:56.404]                   options(future.plan = NULL)
[17:39:56.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.404]                 }
[17:39:56.404]                 ...future.workdir <- getwd()
[17:39:56.404]             }
[17:39:56.404]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.404]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.404]         }
[17:39:56.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.404]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.404]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.404]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.404]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.404]             base::names(...future.oldOptions))
[17:39:56.404]     }
[17:39:56.404]     if (FALSE) {
[17:39:56.404]     }
[17:39:56.404]     else {
[17:39:56.404]         if (TRUE) {
[17:39:56.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.404]                 open = "w")
[17:39:56.404]         }
[17:39:56.404]         else {
[17:39:56.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.404]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.404]         }
[17:39:56.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.404]             base::sink(type = "output", split = FALSE)
[17:39:56.404]             base::close(...future.stdout)
[17:39:56.404]         }, add = TRUE)
[17:39:56.404]     }
[17:39:56.404]     ...future.frame <- base::sys.nframe()
[17:39:56.404]     ...future.conditions <- base::list()
[17:39:56.404]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.404]     if (FALSE) {
[17:39:56.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.404]     }
[17:39:56.404]     ...future.result <- base::tryCatch({
[17:39:56.404]         base::withCallingHandlers({
[17:39:56.404]             ...future.value <- base::withVisible(base::local({
[17:39:56.404]                 withCallingHandlers({
[17:39:56.404]                   value(a) + 1
[17:39:56.404]                 }, immediateCondition = function(cond) {
[17:39:56.404]                   save_rds <- function (object, pathname, ...) 
[17:39:56.404]                   {
[17:39:56.404]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.404]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.404]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.404]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.404]                         fi_tmp[["mtime"]])
[17:39:56.404]                     }
[17:39:56.404]                     tryCatch({
[17:39:56.404]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.404]                     }, error = function(ex) {
[17:39:56.404]                       msg <- conditionMessage(ex)
[17:39:56.404]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.404]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.404]                         fi_tmp[["mtime"]], msg)
[17:39:56.404]                       ex$message <- msg
[17:39:56.404]                       stop(ex)
[17:39:56.404]                     })
[17:39:56.404]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.404]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.404]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.404]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.404]                       fi <- file.info(pathname)
[17:39:56.404]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.404]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.404]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.404]                         fi[["size"]], fi[["mtime"]])
[17:39:56.404]                       stop(msg)
[17:39:56.404]                     }
[17:39:56.404]                     invisible(pathname)
[17:39:56.404]                   }
[17:39:56.404]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.404]                     rootPath = tempdir()) 
[17:39:56.404]                   {
[17:39:56.404]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.404]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.404]                       tmpdir = path, fileext = ".rds")
[17:39:56.404]                     save_rds(obj, file)
[17:39:56.404]                   }
[17:39:56.404]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.404]                   {
[17:39:56.404]                     inherits <- base::inherits
[17:39:56.404]                     invokeRestart <- base::invokeRestart
[17:39:56.404]                     is.null <- base::is.null
[17:39:56.404]                     muffled <- FALSE
[17:39:56.404]                     if (inherits(cond, "message")) {
[17:39:56.404]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.404]                       if (muffled) 
[17:39:56.404]                         invokeRestart("muffleMessage")
[17:39:56.404]                     }
[17:39:56.404]                     else if (inherits(cond, "warning")) {
[17:39:56.404]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.404]                       if (muffled) 
[17:39:56.404]                         invokeRestart("muffleWarning")
[17:39:56.404]                     }
[17:39:56.404]                     else if (inherits(cond, "condition")) {
[17:39:56.404]                       if (!is.null(pattern)) {
[17:39:56.404]                         computeRestarts <- base::computeRestarts
[17:39:56.404]                         grepl <- base::grepl
[17:39:56.404]                         restarts <- computeRestarts(cond)
[17:39:56.404]                         for (restart in restarts) {
[17:39:56.404]                           name <- restart$name
[17:39:56.404]                           if (is.null(name)) 
[17:39:56.404]                             next
[17:39:56.404]                           if (!grepl(pattern, name)) 
[17:39:56.404]                             next
[17:39:56.404]                           invokeRestart(restart)
[17:39:56.404]                           muffled <- TRUE
[17:39:56.404]                           break
[17:39:56.404]                         }
[17:39:56.404]                       }
[17:39:56.404]                     }
[17:39:56.404]                     invisible(muffled)
[17:39:56.404]                   }
[17:39:56.404]                   muffleCondition(cond)
[17:39:56.404]                 })
[17:39:56.404]             }))
[17:39:56.404]             future::FutureResult(value = ...future.value$value, 
[17:39:56.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.404]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.404]                     ...future.globalenv.names))
[17:39:56.404]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.404]         }, condition = base::local({
[17:39:56.404]             c <- base::c
[17:39:56.404]             inherits <- base::inherits
[17:39:56.404]             invokeRestart <- base::invokeRestart
[17:39:56.404]             length <- base::length
[17:39:56.404]             list <- base::list
[17:39:56.404]             seq.int <- base::seq.int
[17:39:56.404]             signalCondition <- base::signalCondition
[17:39:56.404]             sys.calls <- base::sys.calls
[17:39:56.404]             `[[` <- base::`[[`
[17:39:56.404]             `+` <- base::`+`
[17:39:56.404]             `<<-` <- base::`<<-`
[17:39:56.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.404]                   3L)]
[17:39:56.404]             }
[17:39:56.404]             function(cond) {
[17:39:56.404]                 is_error <- inherits(cond, "error")
[17:39:56.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.404]                   NULL)
[17:39:56.404]                 if (is_error) {
[17:39:56.404]                   sessionInformation <- function() {
[17:39:56.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.404]                       search = base::search(), system = base::Sys.info())
[17:39:56.404]                   }
[17:39:56.404]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.404]                     cond$call), session = sessionInformation(), 
[17:39:56.404]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.404]                   signalCondition(cond)
[17:39:56.404]                 }
[17:39:56.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.404]                 "immediateCondition"))) {
[17:39:56.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.404]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.404]                   if (TRUE && !signal) {
[17:39:56.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.404]                     {
[17:39:56.404]                       inherits <- base::inherits
[17:39:56.404]                       invokeRestart <- base::invokeRestart
[17:39:56.404]                       is.null <- base::is.null
[17:39:56.404]                       muffled <- FALSE
[17:39:56.404]                       if (inherits(cond, "message")) {
[17:39:56.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.404]                         if (muffled) 
[17:39:56.404]                           invokeRestart("muffleMessage")
[17:39:56.404]                       }
[17:39:56.404]                       else if (inherits(cond, "warning")) {
[17:39:56.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.404]                         if (muffled) 
[17:39:56.404]                           invokeRestart("muffleWarning")
[17:39:56.404]                       }
[17:39:56.404]                       else if (inherits(cond, "condition")) {
[17:39:56.404]                         if (!is.null(pattern)) {
[17:39:56.404]                           computeRestarts <- base::computeRestarts
[17:39:56.404]                           grepl <- base::grepl
[17:39:56.404]                           restarts <- computeRestarts(cond)
[17:39:56.404]                           for (restart in restarts) {
[17:39:56.404]                             name <- restart$name
[17:39:56.404]                             if (is.null(name)) 
[17:39:56.404]                               next
[17:39:56.404]                             if (!grepl(pattern, name)) 
[17:39:56.404]                               next
[17:39:56.404]                             invokeRestart(restart)
[17:39:56.404]                             muffled <- TRUE
[17:39:56.404]                             break
[17:39:56.404]                           }
[17:39:56.404]                         }
[17:39:56.404]                       }
[17:39:56.404]                       invisible(muffled)
[17:39:56.404]                     }
[17:39:56.404]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.404]                   }
[17:39:56.404]                 }
[17:39:56.404]                 else {
[17:39:56.404]                   if (TRUE) {
[17:39:56.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.404]                     {
[17:39:56.404]                       inherits <- base::inherits
[17:39:56.404]                       invokeRestart <- base::invokeRestart
[17:39:56.404]                       is.null <- base::is.null
[17:39:56.404]                       muffled <- FALSE
[17:39:56.404]                       if (inherits(cond, "message")) {
[17:39:56.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.404]                         if (muffled) 
[17:39:56.404]                           invokeRestart("muffleMessage")
[17:39:56.404]                       }
[17:39:56.404]                       else if (inherits(cond, "warning")) {
[17:39:56.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.404]                         if (muffled) 
[17:39:56.404]                           invokeRestart("muffleWarning")
[17:39:56.404]                       }
[17:39:56.404]                       else if (inherits(cond, "condition")) {
[17:39:56.404]                         if (!is.null(pattern)) {
[17:39:56.404]                           computeRestarts <- base::computeRestarts
[17:39:56.404]                           grepl <- base::grepl
[17:39:56.404]                           restarts <- computeRestarts(cond)
[17:39:56.404]                           for (restart in restarts) {
[17:39:56.404]                             name <- restart$name
[17:39:56.404]                             if (is.null(name)) 
[17:39:56.404]                               next
[17:39:56.404]                             if (!grepl(pattern, name)) 
[17:39:56.404]                               next
[17:39:56.404]                             invokeRestart(restart)
[17:39:56.404]                             muffled <- TRUE
[17:39:56.404]                             break
[17:39:56.404]                           }
[17:39:56.404]                         }
[17:39:56.404]                       }
[17:39:56.404]                       invisible(muffled)
[17:39:56.404]                     }
[17:39:56.404]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.404]                   }
[17:39:56.404]                 }
[17:39:56.404]             }
[17:39:56.404]         }))
[17:39:56.404]     }, error = function(ex) {
[17:39:56.404]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.404]                 ...future.rng), started = ...future.startTime, 
[17:39:56.404]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.404]             version = "1.8"), class = "FutureResult")
[17:39:56.404]     }, finally = {
[17:39:56.404]         if (!identical(...future.workdir, getwd())) 
[17:39:56.404]             setwd(...future.workdir)
[17:39:56.404]         {
[17:39:56.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.404]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.404]             }
[17:39:56.404]             base::options(...future.oldOptions)
[17:39:56.404]             if (.Platform$OS.type == "windows") {
[17:39:56.404]                 old_names <- names(...future.oldEnvVars)
[17:39:56.404]                 envs <- base::Sys.getenv()
[17:39:56.404]                 names <- names(envs)
[17:39:56.404]                 common <- intersect(names, old_names)
[17:39:56.404]                 added <- setdiff(names, old_names)
[17:39:56.404]                 removed <- setdiff(old_names, names)
[17:39:56.404]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.404]                   envs[common]]
[17:39:56.404]                 NAMES <- toupper(changed)
[17:39:56.404]                 args <- list()
[17:39:56.404]                 for (kk in seq_along(NAMES)) {
[17:39:56.404]                   name <- changed[[kk]]
[17:39:56.404]                   NAME <- NAMES[[kk]]
[17:39:56.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.404]                     next
[17:39:56.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.404]                 }
[17:39:56.404]                 NAMES <- toupper(added)
[17:39:56.404]                 for (kk in seq_along(NAMES)) {
[17:39:56.404]                   name <- added[[kk]]
[17:39:56.404]                   NAME <- NAMES[[kk]]
[17:39:56.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.404]                     next
[17:39:56.404]                   args[[name]] <- ""
[17:39:56.404]                 }
[17:39:56.404]                 NAMES <- toupper(removed)
[17:39:56.404]                 for (kk in seq_along(NAMES)) {
[17:39:56.404]                   name <- removed[[kk]]
[17:39:56.404]                   NAME <- NAMES[[kk]]
[17:39:56.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.404]                     next
[17:39:56.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.404]                 }
[17:39:56.404]                 if (length(args) > 0) 
[17:39:56.404]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.404]             }
[17:39:56.404]             else {
[17:39:56.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.404]             }
[17:39:56.404]             {
[17:39:56.404]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.404]                   0L) {
[17:39:56.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.404]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.404]                   base::options(opts)
[17:39:56.404]                 }
[17:39:56.404]                 {
[17:39:56.404]                   {
[17:39:56.404]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.404]                     NULL
[17:39:56.404]                   }
[17:39:56.404]                   options(future.plan = NULL)
[17:39:56.404]                   if (is.na(NA_character_)) 
[17:39:56.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.404]                     .init = FALSE)
[17:39:56.404]                 }
[17:39:56.404]             }
[17:39:56.404]         }
[17:39:56.404]     })
[17:39:56.404]     if (TRUE) {
[17:39:56.404]         base::sink(type = "output", split = FALSE)
[17:39:56.404]         if (TRUE) {
[17:39:56.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.404]         }
[17:39:56.404]         else {
[17:39:56.404]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.404]         }
[17:39:56.404]         base::close(...future.stdout)
[17:39:56.404]         ...future.stdout <- NULL
[17:39:56.404]     }
[17:39:56.404]     ...future.result$conditions <- ...future.conditions
[17:39:56.404]     ...future.result$finished <- base::Sys.time()
[17:39:56.404]     ...future.result
[17:39:56.404] }
[17:39:56.406] assign_globals() ...
[17:39:56.406] List of 1
[17:39:56.406]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd687d150> 
[17:39:56.406]  - attr(*, "where")=List of 1
[17:39:56.406]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.406]  - attr(*, "resolved")= logi TRUE
[17:39:56.406]  - attr(*, "total_size")= num 10816
[17:39:56.406]  - attr(*, "already-done")= logi TRUE
[17:39:56.410] - copied ‘a’ to environment
[17:39:56.410] assign_globals() ... done
[17:39:56.410] requestCore(): workers = 2
[17:39:56.412] MulticoreFuture started
[17:39:56.412] - Launch lazy future ... done
[17:39:56.412] run() for ‘MulticoreFuture’ ... done
[17:39:56.413] result() for MulticoreFuture ...
[17:39:56.413] plan(): Setting new future strategy stack:
[17:39:56.414] List of future strategies:
[17:39:56.414] 1. sequential:
[17:39:56.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.414]    - tweaked: FALSE
[17:39:56.414]    - call: NULL
[17:39:56.415] plan(): nbrOfWorkers() = 1
[17:39:56.418] plan(): Setting new future strategy stack:
[17:39:56.418] List of future strategies:
[17:39:56.418] 1. multicore:
[17:39:56.418]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.418]    - tweaked: FALSE
[17:39:56.418]    - call: plan(strategy)
[17:39:56.424] plan(): nbrOfWorkers() = 2
[17:39:56.425] result() for MulticoreFuture ...
[17:39:56.425] result() for MulticoreFuture ... done
[17:39:56.425] signalConditions() ...
[17:39:56.426]  - include = ‘immediateCondition’
[17:39:56.426]  - exclude = 
[17:39:56.426]  - resignal = FALSE
[17:39:56.426]  - Number of conditions: 4
[17:39:56.426] signalConditions() ... done
[17:39:56.426] result() for MulticoreFuture ... done
[17:39:56.426] result() for MulticoreFuture ...
[17:39:56.427] result() for MulticoreFuture ... done
[17:39:56.427] signalConditions() ...
[17:39:56.427]  - include = ‘immediateCondition’
[17:39:56.427]  - exclude = 
[17:39:56.427]  - resignal = FALSE
[17:39:56.427]  - Number of conditions: 4
[17:39:56.427] signalConditions() ... done
[17:39:56.427] Future state: ‘finished’
[17:39:56.428] result() for MulticoreFuture ...
[17:39:56.428] result() for MulticoreFuture ... done
[17:39:56.428] signalConditions() ...
[17:39:56.428]  - include = ‘condition’
[17:39:56.428]  - exclude = ‘immediateCondition’
[17:39:56.428]  - resignal = TRUE
[17:39:56.428]  - Number of conditions: 4
[17:39:56.428]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.416] result() for MulticoreFuture ...
[17:39:56.429]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.416] result() for MulticoreFuture ... done
[17:39:56.429]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.417] result() for MulticoreFuture ...
[17:39:56.429]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.417] result() for MulticoreFuture ... done
[17:39:56.429] signalConditions() ... done
value(b) = 2
[17:39:56.429] result() for MulticoreFuture ...
[17:39:56.429] result() for MulticoreFuture ... done
[17:39:56.430] result() for MulticoreFuture ...
[17:39:56.430] result() for MulticoreFuture ... done
[17:39:56.430] signalConditions() ...
[17:39:56.430]  - include = ‘immediateCondition’
[17:39:56.430]  - exclude = 
[17:39:56.430]  - resignal = FALSE
[17:39:56.430]  - Number of conditions: 4
[17:39:56.430] signalConditions() ... done
[17:39:56.430] Future state: ‘finished’
[17:39:56.431] result() for MulticoreFuture ...
[17:39:56.431] result() for MulticoreFuture ... done
[17:39:56.431] signalConditions() ...
[17:39:56.431]  - include = ‘condition’
[17:39:56.431]  - exclude = ‘immediateCondition’
[17:39:56.431]  - resignal = TRUE
[17:39:56.431]  - Number of conditions: 4
[17:39:56.431]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.416] result() for MulticoreFuture ...
[17:39:56.431]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.416] result() for MulticoreFuture ... done
[17:39:56.432]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.417] result() for MulticoreFuture ...
[17:39:56.432]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.417] result() for MulticoreFuture ... done
[17:39:56.432] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.432] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.433] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.433] 
[17:39:56.433] Searching for globals ... DONE
[17:39:56.434] - globals: [0] <none>
[17:39:56.434] getGlobalsAndPackages() ... DONE
[17:39:56.434] run() for ‘Future’ ...
[17:39:56.434] - state: ‘created’
[17:39:56.434] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.439]   - Field: ‘label’
[17:39:56.439]   - Field: ‘local’
[17:39:56.439]   - Field: ‘owner’
[17:39:56.439]   - Field: ‘envir’
[17:39:56.439]   - Field: ‘workers’
[17:39:56.439]   - Field: ‘packages’
[17:39:56.439]   - Field: ‘gc’
[17:39:56.440]   - Field: ‘job’
[17:39:56.440]   - Field: ‘conditions’
[17:39:56.440]   - Field: ‘expr’
[17:39:56.440]   - Field: ‘uuid’
[17:39:56.440]   - Field: ‘seed’
[17:39:56.440]   - Field: ‘version’
[17:39:56.440]   - Field: ‘result’
[17:39:56.440]   - Field: ‘asynchronous’
[17:39:56.440]   - Field: ‘calls’
[17:39:56.441]   - Field: ‘globals’
[17:39:56.441]   - Field: ‘stdout’
[17:39:56.441]   - Field: ‘earlySignal’
[17:39:56.441]   - Field: ‘lazy’
[17:39:56.441]   - Field: ‘state’
[17:39:56.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.441] - Launch lazy future ...
[17:39:56.442] Packages needed by the future expression (n = 0): <none>
[17:39:56.442] Packages needed by future strategies (n = 0): <none>
[17:39:56.442] {
[17:39:56.442]     {
[17:39:56.442]         {
[17:39:56.442]             ...future.startTime <- base::Sys.time()
[17:39:56.442]             {
[17:39:56.442]                 {
[17:39:56.442]                   {
[17:39:56.442]                     {
[17:39:56.442]                       base::local({
[17:39:56.442]                         has_future <- base::requireNamespace("future", 
[17:39:56.442]                           quietly = TRUE)
[17:39:56.442]                         if (has_future) {
[17:39:56.442]                           ns <- base::getNamespace("future")
[17:39:56.442]                           version <- ns[[".package"]][["version"]]
[17:39:56.442]                           if (is.null(version)) 
[17:39:56.442]                             version <- utils::packageVersion("future")
[17:39:56.442]                         }
[17:39:56.442]                         else {
[17:39:56.442]                           version <- NULL
[17:39:56.442]                         }
[17:39:56.442]                         if (!has_future || version < "1.8.0") {
[17:39:56.442]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.442]                             "", base::R.version$version.string), 
[17:39:56.442]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.442]                               "release", "version")], collapse = " "), 
[17:39:56.442]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.442]                             info)
[17:39:56.442]                           info <- base::paste(info, collapse = "; ")
[17:39:56.442]                           if (!has_future) {
[17:39:56.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.442]                               info)
[17:39:56.442]                           }
[17:39:56.442]                           else {
[17:39:56.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.442]                               info, version)
[17:39:56.442]                           }
[17:39:56.442]                           base::stop(msg)
[17:39:56.442]                         }
[17:39:56.442]                       })
[17:39:56.442]                     }
[17:39:56.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.442]                     base::options(mc.cores = 1L)
[17:39:56.442]                   }
[17:39:56.442]                   ...future.strategy.old <- future::plan("list")
[17:39:56.442]                   options(future.plan = NULL)
[17:39:56.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.442]                 }
[17:39:56.442]                 ...future.workdir <- getwd()
[17:39:56.442]             }
[17:39:56.442]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.442]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.442]         }
[17:39:56.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.442]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.442]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.442]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.442]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.442]             base::names(...future.oldOptions))
[17:39:56.442]     }
[17:39:56.442]     if (FALSE) {
[17:39:56.442]     }
[17:39:56.442]     else {
[17:39:56.442]         if (TRUE) {
[17:39:56.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.442]                 open = "w")
[17:39:56.442]         }
[17:39:56.442]         else {
[17:39:56.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.442]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.442]         }
[17:39:56.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.442]             base::sink(type = "output", split = FALSE)
[17:39:56.442]             base::close(...future.stdout)
[17:39:56.442]         }, add = TRUE)
[17:39:56.442]     }
[17:39:56.442]     ...future.frame <- base::sys.nframe()
[17:39:56.442]     ...future.conditions <- base::list()
[17:39:56.442]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.442]     if (FALSE) {
[17:39:56.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.442]     }
[17:39:56.442]     ...future.result <- base::tryCatch({
[17:39:56.442]         base::withCallingHandlers({
[17:39:56.442]             ...future.value <- base::withVisible(base::local({
[17:39:56.442]                 withCallingHandlers({
[17:39:56.442]                   1
[17:39:56.442]                 }, immediateCondition = function(cond) {
[17:39:56.442]                   save_rds <- function (object, pathname, ...) 
[17:39:56.442]                   {
[17:39:56.442]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.442]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.442]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.442]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.442]                         fi_tmp[["mtime"]])
[17:39:56.442]                     }
[17:39:56.442]                     tryCatch({
[17:39:56.442]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.442]                     }, error = function(ex) {
[17:39:56.442]                       msg <- conditionMessage(ex)
[17:39:56.442]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.442]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.442]                         fi_tmp[["mtime"]], msg)
[17:39:56.442]                       ex$message <- msg
[17:39:56.442]                       stop(ex)
[17:39:56.442]                     })
[17:39:56.442]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.442]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.442]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.442]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.442]                       fi <- file.info(pathname)
[17:39:56.442]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.442]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.442]                         fi[["size"]], fi[["mtime"]])
[17:39:56.442]                       stop(msg)
[17:39:56.442]                     }
[17:39:56.442]                     invisible(pathname)
[17:39:56.442]                   }
[17:39:56.442]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.442]                     rootPath = tempdir()) 
[17:39:56.442]                   {
[17:39:56.442]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.442]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.442]                       tmpdir = path, fileext = ".rds")
[17:39:56.442]                     save_rds(obj, file)
[17:39:56.442]                   }
[17:39:56.442]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.442]                   {
[17:39:56.442]                     inherits <- base::inherits
[17:39:56.442]                     invokeRestart <- base::invokeRestart
[17:39:56.442]                     is.null <- base::is.null
[17:39:56.442]                     muffled <- FALSE
[17:39:56.442]                     if (inherits(cond, "message")) {
[17:39:56.442]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.442]                       if (muffled) 
[17:39:56.442]                         invokeRestart("muffleMessage")
[17:39:56.442]                     }
[17:39:56.442]                     else if (inherits(cond, "warning")) {
[17:39:56.442]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.442]                       if (muffled) 
[17:39:56.442]                         invokeRestart("muffleWarning")
[17:39:56.442]                     }
[17:39:56.442]                     else if (inherits(cond, "condition")) {
[17:39:56.442]                       if (!is.null(pattern)) {
[17:39:56.442]                         computeRestarts <- base::computeRestarts
[17:39:56.442]                         grepl <- base::grepl
[17:39:56.442]                         restarts <- computeRestarts(cond)
[17:39:56.442]                         for (restart in restarts) {
[17:39:56.442]                           name <- restart$name
[17:39:56.442]                           if (is.null(name)) 
[17:39:56.442]                             next
[17:39:56.442]                           if (!grepl(pattern, name)) 
[17:39:56.442]                             next
[17:39:56.442]                           invokeRestart(restart)
[17:39:56.442]                           muffled <- TRUE
[17:39:56.442]                           break
[17:39:56.442]                         }
[17:39:56.442]                       }
[17:39:56.442]                     }
[17:39:56.442]                     invisible(muffled)
[17:39:56.442]                   }
[17:39:56.442]                   muffleCondition(cond)
[17:39:56.442]                 })
[17:39:56.442]             }))
[17:39:56.442]             future::FutureResult(value = ...future.value$value, 
[17:39:56.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.442]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.442]                     ...future.globalenv.names))
[17:39:56.442]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.442]         }, condition = base::local({
[17:39:56.442]             c <- base::c
[17:39:56.442]             inherits <- base::inherits
[17:39:56.442]             invokeRestart <- base::invokeRestart
[17:39:56.442]             length <- base::length
[17:39:56.442]             list <- base::list
[17:39:56.442]             seq.int <- base::seq.int
[17:39:56.442]             signalCondition <- base::signalCondition
[17:39:56.442]             sys.calls <- base::sys.calls
[17:39:56.442]             `[[` <- base::`[[`
[17:39:56.442]             `+` <- base::`+`
[17:39:56.442]             `<<-` <- base::`<<-`
[17:39:56.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.442]                   3L)]
[17:39:56.442]             }
[17:39:56.442]             function(cond) {
[17:39:56.442]                 is_error <- inherits(cond, "error")
[17:39:56.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.442]                   NULL)
[17:39:56.442]                 if (is_error) {
[17:39:56.442]                   sessionInformation <- function() {
[17:39:56.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.442]                       search = base::search(), system = base::Sys.info())
[17:39:56.442]                   }
[17:39:56.442]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.442]                     cond$call), session = sessionInformation(), 
[17:39:56.442]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.442]                   signalCondition(cond)
[17:39:56.442]                 }
[17:39:56.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.442]                 "immediateCondition"))) {
[17:39:56.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.442]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.442]                   if (TRUE && !signal) {
[17:39:56.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.442]                     {
[17:39:56.442]                       inherits <- base::inherits
[17:39:56.442]                       invokeRestart <- base::invokeRestart
[17:39:56.442]                       is.null <- base::is.null
[17:39:56.442]                       muffled <- FALSE
[17:39:56.442]                       if (inherits(cond, "message")) {
[17:39:56.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.442]                         if (muffled) 
[17:39:56.442]                           invokeRestart("muffleMessage")
[17:39:56.442]                       }
[17:39:56.442]                       else if (inherits(cond, "warning")) {
[17:39:56.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.442]                         if (muffled) 
[17:39:56.442]                           invokeRestart("muffleWarning")
[17:39:56.442]                       }
[17:39:56.442]                       else if (inherits(cond, "condition")) {
[17:39:56.442]                         if (!is.null(pattern)) {
[17:39:56.442]                           computeRestarts <- base::computeRestarts
[17:39:56.442]                           grepl <- base::grepl
[17:39:56.442]                           restarts <- computeRestarts(cond)
[17:39:56.442]                           for (restart in restarts) {
[17:39:56.442]                             name <- restart$name
[17:39:56.442]                             if (is.null(name)) 
[17:39:56.442]                               next
[17:39:56.442]                             if (!grepl(pattern, name)) 
[17:39:56.442]                               next
[17:39:56.442]                             invokeRestart(restart)
[17:39:56.442]                             muffled <- TRUE
[17:39:56.442]                             break
[17:39:56.442]                           }
[17:39:56.442]                         }
[17:39:56.442]                       }
[17:39:56.442]                       invisible(muffled)
[17:39:56.442]                     }
[17:39:56.442]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.442]                   }
[17:39:56.442]                 }
[17:39:56.442]                 else {
[17:39:56.442]                   if (TRUE) {
[17:39:56.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.442]                     {
[17:39:56.442]                       inherits <- base::inherits
[17:39:56.442]                       invokeRestart <- base::invokeRestart
[17:39:56.442]                       is.null <- base::is.null
[17:39:56.442]                       muffled <- FALSE
[17:39:56.442]                       if (inherits(cond, "message")) {
[17:39:56.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.442]                         if (muffled) 
[17:39:56.442]                           invokeRestart("muffleMessage")
[17:39:56.442]                       }
[17:39:56.442]                       else if (inherits(cond, "warning")) {
[17:39:56.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.442]                         if (muffled) 
[17:39:56.442]                           invokeRestart("muffleWarning")
[17:39:56.442]                       }
[17:39:56.442]                       else if (inherits(cond, "condition")) {
[17:39:56.442]                         if (!is.null(pattern)) {
[17:39:56.442]                           computeRestarts <- base::computeRestarts
[17:39:56.442]                           grepl <- base::grepl
[17:39:56.442]                           restarts <- computeRestarts(cond)
[17:39:56.442]                           for (restart in restarts) {
[17:39:56.442]                             name <- restart$name
[17:39:56.442]                             if (is.null(name)) 
[17:39:56.442]                               next
[17:39:56.442]                             if (!grepl(pattern, name)) 
[17:39:56.442]                               next
[17:39:56.442]                             invokeRestart(restart)
[17:39:56.442]                             muffled <- TRUE
[17:39:56.442]                             break
[17:39:56.442]                           }
[17:39:56.442]                         }
[17:39:56.442]                       }
[17:39:56.442]                       invisible(muffled)
[17:39:56.442]                     }
[17:39:56.442]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.442]                   }
[17:39:56.442]                 }
[17:39:56.442]             }
[17:39:56.442]         }))
[17:39:56.442]     }, error = function(ex) {
[17:39:56.442]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.442]                 ...future.rng), started = ...future.startTime, 
[17:39:56.442]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.442]             version = "1.8"), class = "FutureResult")
[17:39:56.442]     }, finally = {
[17:39:56.442]         if (!identical(...future.workdir, getwd())) 
[17:39:56.442]             setwd(...future.workdir)
[17:39:56.442]         {
[17:39:56.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.442]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.442]             }
[17:39:56.442]             base::options(...future.oldOptions)
[17:39:56.442]             if (.Platform$OS.type == "windows") {
[17:39:56.442]                 old_names <- names(...future.oldEnvVars)
[17:39:56.442]                 envs <- base::Sys.getenv()
[17:39:56.442]                 names <- names(envs)
[17:39:56.442]                 common <- intersect(names, old_names)
[17:39:56.442]                 added <- setdiff(names, old_names)
[17:39:56.442]                 removed <- setdiff(old_names, names)
[17:39:56.442]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.442]                   envs[common]]
[17:39:56.442]                 NAMES <- toupper(changed)
[17:39:56.442]                 args <- list()
[17:39:56.442]                 for (kk in seq_along(NAMES)) {
[17:39:56.442]                   name <- changed[[kk]]
[17:39:56.442]                   NAME <- NAMES[[kk]]
[17:39:56.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.442]                     next
[17:39:56.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.442]                 }
[17:39:56.442]                 NAMES <- toupper(added)
[17:39:56.442]                 for (kk in seq_along(NAMES)) {
[17:39:56.442]                   name <- added[[kk]]
[17:39:56.442]                   NAME <- NAMES[[kk]]
[17:39:56.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.442]                     next
[17:39:56.442]                   args[[name]] <- ""
[17:39:56.442]                 }
[17:39:56.442]                 NAMES <- toupper(removed)
[17:39:56.442]                 for (kk in seq_along(NAMES)) {
[17:39:56.442]                   name <- removed[[kk]]
[17:39:56.442]                   NAME <- NAMES[[kk]]
[17:39:56.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.442]                     next
[17:39:56.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.442]                 }
[17:39:56.442]                 if (length(args) > 0) 
[17:39:56.442]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.442]             }
[17:39:56.442]             else {
[17:39:56.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.442]             }
[17:39:56.442]             {
[17:39:56.442]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.442]                   0L) {
[17:39:56.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.442]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.442]                   base::options(opts)
[17:39:56.442]                 }
[17:39:56.442]                 {
[17:39:56.442]                   {
[17:39:56.442]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.442]                     NULL
[17:39:56.442]                   }
[17:39:56.442]                   options(future.plan = NULL)
[17:39:56.442]                   if (is.na(NA_character_)) 
[17:39:56.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.442]                     .init = FALSE)
[17:39:56.442]                 }
[17:39:56.442]             }
[17:39:56.442]         }
[17:39:56.442]     })
[17:39:56.442]     if (TRUE) {
[17:39:56.442]         base::sink(type = "output", split = FALSE)
[17:39:56.442]         if (TRUE) {
[17:39:56.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.442]         }
[17:39:56.442]         else {
[17:39:56.442]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.442]         }
[17:39:56.442]         base::close(...future.stdout)
[17:39:56.442]         ...future.stdout <- NULL
[17:39:56.442]     }
[17:39:56.442]     ...future.result$conditions <- ...future.conditions
[17:39:56.442]     ...future.result$finished <- base::Sys.time()
[17:39:56.442]     ...future.result
[17:39:56.442] }
[17:39:56.445] requestCore(): workers = 2
[17:39:56.447] MulticoreFuture started
[17:39:56.447] - Launch lazy future ... done
[17:39:56.447] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.448] plan(): Setting new future strategy stack:
[17:39:56.448] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.448] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.448] List of future strategies:
[17:39:56.448] 1. sequential:
[17:39:56.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.448]    - tweaked: FALSE
[17:39:56.448]    - call: NULL
[17:39:56.449] plan(): nbrOfWorkers() = 1
[17:39:56.450] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:56.450] Searching for globals ... DONE
[17:39:56.450] Resolving globals: TRUE
[17:39:56.451] Resolving any globals that are futures ...
[17:39:56.451] plan(): Setting new future strategy stack:
[17:39:56.451] List of future strategies:
[17:39:56.451] 1. multicore:
[17:39:56.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.451]    - tweaked: FALSE
[17:39:56.451]    - call: plan(strategy)
[17:39:56.451] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:56.455] Resolving any globals that are futures ... DONE
[17:39:56.456] Resolving futures part of globals (recursively) ...
[17:39:56.457] resolve() on list ...
[17:39:56.457]  recursive: 99
[17:39:56.458]  length: 1
[17:39:56.458]  elements: ‘a’
[17:39:56.458] plan(): nbrOfWorkers() = 2
[17:39:56.459] Future #1
[17:39:56.459] result() for MulticoreFuture ...
[17:39:56.461] result() for MulticoreFuture ...
[17:39:56.461] result() for MulticoreFuture ... done
[17:39:56.461] result() for MulticoreFuture ... done
[17:39:56.461] result() for MulticoreFuture ...
[17:39:56.462] result() for MulticoreFuture ... done
[17:39:56.462] A MulticoreFuture was resolved
[17:39:56.462]  length: 0 (resolved future 1)
[17:39:56.462] resolve() on list ... DONE
[17:39:56.462] - globals: [1] ‘a’
[17:39:56.462] Resolving futures part of globals (recursively) ... DONE
[17:39:56.464] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:39:56.464] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:39:56.464] - globals: [1] ‘a’
[17:39:56.464] - packages: [1] ‘future’
[17:39:56.465] getGlobalsAndPackages() ... DONE
[17:39:56.465] run() for ‘Future’ ...
[17:39:56.465] - state: ‘created’
[17:39:56.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.470]   - Field: ‘label’
[17:39:56.470]   - Field: ‘local’
[17:39:56.470]   - Field: ‘owner’
[17:39:56.471]   - Field: ‘envir’
[17:39:56.471]   - Field: ‘workers’
[17:39:56.471]   - Field: ‘packages’
[17:39:56.471]   - Field: ‘gc’
[17:39:56.471]   - Field: ‘job’
[17:39:56.471]   - Field: ‘conditions’
[17:39:56.471]   - Field: ‘expr’
[17:39:56.471]   - Field: ‘uuid’
[17:39:56.472]   - Field: ‘seed’
[17:39:56.472]   - Field: ‘version’
[17:39:56.472]   - Field: ‘result’
[17:39:56.472]   - Field: ‘asynchronous’
[17:39:56.472]   - Field: ‘calls’
[17:39:56.472]   - Field: ‘globals’
[17:39:56.472]   - Field: ‘stdout’
[17:39:56.472]   - Field: ‘earlySignal’
[17:39:56.472]   - Field: ‘lazy’
[17:39:56.473]   - Field: ‘state’
[17:39:56.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.473] - Launch lazy future ...
[17:39:56.473] Packages needed by the future expression (n = 1): ‘future’
[17:39:56.473] Packages needed by future strategies (n = 0): <none>
[17:39:56.474] {
[17:39:56.474]     {
[17:39:56.474]         {
[17:39:56.474]             ...future.startTime <- base::Sys.time()
[17:39:56.474]             {
[17:39:56.474]                 {
[17:39:56.474]                   {
[17:39:56.474]                     {
[17:39:56.474]                       {
[17:39:56.474]                         base::local({
[17:39:56.474]                           has_future <- base::requireNamespace("future", 
[17:39:56.474]                             quietly = TRUE)
[17:39:56.474]                           if (has_future) {
[17:39:56.474]                             ns <- base::getNamespace("future")
[17:39:56.474]                             version <- ns[[".package"]][["version"]]
[17:39:56.474]                             if (is.null(version)) 
[17:39:56.474]                               version <- utils::packageVersion("future")
[17:39:56.474]                           }
[17:39:56.474]                           else {
[17:39:56.474]                             version <- NULL
[17:39:56.474]                           }
[17:39:56.474]                           if (!has_future || version < "1.8.0") {
[17:39:56.474]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.474]                               "", base::R.version$version.string), 
[17:39:56.474]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:56.474]                                 base::R.version$platform, 8 * 
[17:39:56.474]                                   base::.Machine$sizeof.pointer), 
[17:39:56.474]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.474]                                 "release", "version")], collapse = " "), 
[17:39:56.474]                               hostname = base::Sys.info()[["nodename"]])
[17:39:56.474]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.474]                               info)
[17:39:56.474]                             info <- base::paste(info, collapse = "; ")
[17:39:56.474]                             if (!has_future) {
[17:39:56.474]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.474]                                 info)
[17:39:56.474]                             }
[17:39:56.474]                             else {
[17:39:56.474]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.474]                                 info, version)
[17:39:56.474]                             }
[17:39:56.474]                             base::stop(msg)
[17:39:56.474]                           }
[17:39:56.474]                         })
[17:39:56.474]                       }
[17:39:56.474]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.474]                       base::options(mc.cores = 1L)
[17:39:56.474]                     }
[17:39:56.474]                     base::local({
[17:39:56.474]                       for (pkg in "future") {
[17:39:56.474]                         base::loadNamespace(pkg)
[17:39:56.474]                         base::library(pkg, character.only = TRUE)
[17:39:56.474]                       }
[17:39:56.474]                     })
[17:39:56.474]                   }
[17:39:56.474]                   ...future.strategy.old <- future::plan("list")
[17:39:56.474]                   options(future.plan = NULL)
[17:39:56.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.474]                 }
[17:39:56.474]                 ...future.workdir <- getwd()
[17:39:56.474]             }
[17:39:56.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.474]         }
[17:39:56.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.474]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.474]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.474]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.474]             base::names(...future.oldOptions))
[17:39:56.474]     }
[17:39:56.474]     if (FALSE) {
[17:39:56.474]     }
[17:39:56.474]     else {
[17:39:56.474]         if (TRUE) {
[17:39:56.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.474]                 open = "w")
[17:39:56.474]         }
[17:39:56.474]         else {
[17:39:56.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.474]         }
[17:39:56.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.474]             base::sink(type = "output", split = FALSE)
[17:39:56.474]             base::close(...future.stdout)
[17:39:56.474]         }, add = TRUE)
[17:39:56.474]     }
[17:39:56.474]     ...future.frame <- base::sys.nframe()
[17:39:56.474]     ...future.conditions <- base::list()
[17:39:56.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.474]     if (FALSE) {
[17:39:56.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.474]     }
[17:39:56.474]     ...future.result <- base::tryCatch({
[17:39:56.474]         base::withCallingHandlers({
[17:39:56.474]             ...future.value <- base::withVisible(base::local({
[17:39:56.474]                 withCallingHandlers({
[17:39:56.474]                   value(a) + 1
[17:39:56.474]                 }, immediateCondition = function(cond) {
[17:39:56.474]                   save_rds <- function (object, pathname, ...) 
[17:39:56.474]                   {
[17:39:56.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.474]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.474]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.474]                         fi_tmp[["mtime"]])
[17:39:56.474]                     }
[17:39:56.474]                     tryCatch({
[17:39:56.474]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.474]                     }, error = function(ex) {
[17:39:56.474]                       msg <- conditionMessage(ex)
[17:39:56.474]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.474]                         fi_tmp[["mtime"]], msg)
[17:39:56.474]                       ex$message <- msg
[17:39:56.474]                       stop(ex)
[17:39:56.474]                     })
[17:39:56.474]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.474]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.474]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.474]                       fi <- file.info(pathname)
[17:39:56.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.474]                         fi[["size"]], fi[["mtime"]])
[17:39:56.474]                       stop(msg)
[17:39:56.474]                     }
[17:39:56.474]                     invisible(pathname)
[17:39:56.474]                   }
[17:39:56.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.474]                     rootPath = tempdir()) 
[17:39:56.474]                   {
[17:39:56.474]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.474]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.474]                       tmpdir = path, fileext = ".rds")
[17:39:56.474]                     save_rds(obj, file)
[17:39:56.474]                   }
[17:39:56.474]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.474]                   {
[17:39:56.474]                     inherits <- base::inherits
[17:39:56.474]                     invokeRestart <- base::invokeRestart
[17:39:56.474]                     is.null <- base::is.null
[17:39:56.474]                     muffled <- FALSE
[17:39:56.474]                     if (inherits(cond, "message")) {
[17:39:56.474]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.474]                       if (muffled) 
[17:39:56.474]                         invokeRestart("muffleMessage")
[17:39:56.474]                     }
[17:39:56.474]                     else if (inherits(cond, "warning")) {
[17:39:56.474]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.474]                       if (muffled) 
[17:39:56.474]                         invokeRestart("muffleWarning")
[17:39:56.474]                     }
[17:39:56.474]                     else if (inherits(cond, "condition")) {
[17:39:56.474]                       if (!is.null(pattern)) {
[17:39:56.474]                         computeRestarts <- base::computeRestarts
[17:39:56.474]                         grepl <- base::grepl
[17:39:56.474]                         restarts <- computeRestarts(cond)
[17:39:56.474]                         for (restart in restarts) {
[17:39:56.474]                           name <- restart$name
[17:39:56.474]                           if (is.null(name)) 
[17:39:56.474]                             next
[17:39:56.474]                           if (!grepl(pattern, name)) 
[17:39:56.474]                             next
[17:39:56.474]                           invokeRestart(restart)
[17:39:56.474]                           muffled <- TRUE
[17:39:56.474]                           break
[17:39:56.474]                         }
[17:39:56.474]                       }
[17:39:56.474]                     }
[17:39:56.474]                     invisible(muffled)
[17:39:56.474]                   }
[17:39:56.474]                   muffleCondition(cond)
[17:39:56.474]                 })
[17:39:56.474]             }))
[17:39:56.474]             future::FutureResult(value = ...future.value$value, 
[17:39:56.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.474]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.474]                     ...future.globalenv.names))
[17:39:56.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.474]         }, condition = base::local({
[17:39:56.474]             c <- base::c
[17:39:56.474]             inherits <- base::inherits
[17:39:56.474]             invokeRestart <- base::invokeRestart
[17:39:56.474]             length <- base::length
[17:39:56.474]             list <- base::list
[17:39:56.474]             seq.int <- base::seq.int
[17:39:56.474]             signalCondition <- base::signalCondition
[17:39:56.474]             sys.calls <- base::sys.calls
[17:39:56.474]             `[[` <- base::`[[`
[17:39:56.474]             `+` <- base::`+`
[17:39:56.474]             `<<-` <- base::`<<-`
[17:39:56.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.474]                   3L)]
[17:39:56.474]             }
[17:39:56.474]             function(cond) {
[17:39:56.474]                 is_error <- inherits(cond, "error")
[17:39:56.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.474]                   NULL)
[17:39:56.474]                 if (is_error) {
[17:39:56.474]                   sessionInformation <- function() {
[17:39:56.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.474]                       search = base::search(), system = base::Sys.info())
[17:39:56.474]                   }
[17:39:56.474]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.474]                     cond$call), session = sessionInformation(), 
[17:39:56.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.474]                   signalCondition(cond)
[17:39:56.474]                 }
[17:39:56.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.474]                 "immediateCondition"))) {
[17:39:56.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.474]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.474]                   if (TRUE && !signal) {
[17:39:56.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.474]                     {
[17:39:56.474]                       inherits <- base::inherits
[17:39:56.474]                       invokeRestart <- base::invokeRestart
[17:39:56.474]                       is.null <- base::is.null
[17:39:56.474]                       muffled <- FALSE
[17:39:56.474]                       if (inherits(cond, "message")) {
[17:39:56.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.474]                         if (muffled) 
[17:39:56.474]                           invokeRestart("muffleMessage")
[17:39:56.474]                       }
[17:39:56.474]                       else if (inherits(cond, "warning")) {
[17:39:56.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.474]                         if (muffled) 
[17:39:56.474]                           invokeRestart("muffleWarning")
[17:39:56.474]                       }
[17:39:56.474]                       else if (inherits(cond, "condition")) {
[17:39:56.474]                         if (!is.null(pattern)) {
[17:39:56.474]                           computeRestarts <- base::computeRestarts
[17:39:56.474]                           grepl <- base::grepl
[17:39:56.474]                           restarts <- computeRestarts(cond)
[17:39:56.474]                           for (restart in restarts) {
[17:39:56.474]                             name <- restart$name
[17:39:56.474]                             if (is.null(name)) 
[17:39:56.474]                               next
[17:39:56.474]                             if (!grepl(pattern, name)) 
[17:39:56.474]                               next
[17:39:56.474]                             invokeRestart(restart)
[17:39:56.474]                             muffled <- TRUE
[17:39:56.474]                             break
[17:39:56.474]                           }
[17:39:56.474]                         }
[17:39:56.474]                       }
[17:39:56.474]                       invisible(muffled)
[17:39:56.474]                     }
[17:39:56.474]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.474]                   }
[17:39:56.474]                 }
[17:39:56.474]                 else {
[17:39:56.474]                   if (TRUE) {
[17:39:56.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.474]                     {
[17:39:56.474]                       inherits <- base::inherits
[17:39:56.474]                       invokeRestart <- base::invokeRestart
[17:39:56.474]                       is.null <- base::is.null
[17:39:56.474]                       muffled <- FALSE
[17:39:56.474]                       if (inherits(cond, "message")) {
[17:39:56.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.474]                         if (muffled) 
[17:39:56.474]                           invokeRestart("muffleMessage")
[17:39:56.474]                       }
[17:39:56.474]                       else if (inherits(cond, "warning")) {
[17:39:56.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.474]                         if (muffled) 
[17:39:56.474]                           invokeRestart("muffleWarning")
[17:39:56.474]                       }
[17:39:56.474]                       else if (inherits(cond, "condition")) {
[17:39:56.474]                         if (!is.null(pattern)) {
[17:39:56.474]                           computeRestarts <- base::computeRestarts
[17:39:56.474]                           grepl <- base::grepl
[17:39:56.474]                           restarts <- computeRestarts(cond)
[17:39:56.474]                           for (restart in restarts) {
[17:39:56.474]                             name <- restart$name
[17:39:56.474]                             if (is.null(name)) 
[17:39:56.474]                               next
[17:39:56.474]                             if (!grepl(pattern, name)) 
[17:39:56.474]                               next
[17:39:56.474]                             invokeRestart(restart)
[17:39:56.474]                             muffled <- TRUE
[17:39:56.474]                             break
[17:39:56.474]                           }
[17:39:56.474]                         }
[17:39:56.474]                       }
[17:39:56.474]                       invisible(muffled)
[17:39:56.474]                     }
[17:39:56.474]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.474]                   }
[17:39:56.474]                 }
[17:39:56.474]             }
[17:39:56.474]         }))
[17:39:56.474]     }, error = function(ex) {
[17:39:56.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.474]                 ...future.rng), started = ...future.startTime, 
[17:39:56.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.474]             version = "1.8"), class = "FutureResult")
[17:39:56.474]     }, finally = {
[17:39:56.474]         if (!identical(...future.workdir, getwd())) 
[17:39:56.474]             setwd(...future.workdir)
[17:39:56.474]         {
[17:39:56.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.474]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.474]             }
[17:39:56.474]             base::options(...future.oldOptions)
[17:39:56.474]             if (.Platform$OS.type == "windows") {
[17:39:56.474]                 old_names <- names(...future.oldEnvVars)
[17:39:56.474]                 envs <- base::Sys.getenv()
[17:39:56.474]                 names <- names(envs)
[17:39:56.474]                 common <- intersect(names, old_names)
[17:39:56.474]                 added <- setdiff(names, old_names)
[17:39:56.474]                 removed <- setdiff(old_names, names)
[17:39:56.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.474]                   envs[common]]
[17:39:56.474]                 NAMES <- toupper(changed)
[17:39:56.474]                 args <- list()
[17:39:56.474]                 for (kk in seq_along(NAMES)) {
[17:39:56.474]                   name <- changed[[kk]]
[17:39:56.474]                   NAME <- NAMES[[kk]]
[17:39:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.474]                     next
[17:39:56.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.474]                 }
[17:39:56.474]                 NAMES <- toupper(added)
[17:39:56.474]                 for (kk in seq_along(NAMES)) {
[17:39:56.474]                   name <- added[[kk]]
[17:39:56.474]                   NAME <- NAMES[[kk]]
[17:39:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.474]                     next
[17:39:56.474]                   args[[name]] <- ""
[17:39:56.474]                 }
[17:39:56.474]                 NAMES <- toupper(removed)
[17:39:56.474]                 for (kk in seq_along(NAMES)) {
[17:39:56.474]                   name <- removed[[kk]]
[17:39:56.474]                   NAME <- NAMES[[kk]]
[17:39:56.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.474]                     next
[17:39:56.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.474]                 }
[17:39:56.474]                 if (length(args) > 0) 
[17:39:56.474]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.474]             }
[17:39:56.474]             else {
[17:39:56.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.474]             }
[17:39:56.474]             {
[17:39:56.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.474]                   0L) {
[17:39:56.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.474]                   base::options(opts)
[17:39:56.474]                 }
[17:39:56.474]                 {
[17:39:56.474]                   {
[17:39:56.474]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.474]                     NULL
[17:39:56.474]                   }
[17:39:56.474]                   options(future.plan = NULL)
[17:39:56.474]                   if (is.na(NA_character_)) 
[17:39:56.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.474]                     .init = FALSE)
[17:39:56.474]                 }
[17:39:56.474]             }
[17:39:56.474]         }
[17:39:56.474]     })
[17:39:56.474]     if (TRUE) {
[17:39:56.474]         base::sink(type = "output", split = FALSE)
[17:39:56.474]         if (TRUE) {
[17:39:56.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.474]         }
[17:39:56.474]         else {
[17:39:56.474]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.474]         }
[17:39:56.474]         base::close(...future.stdout)
[17:39:56.474]         ...future.stdout <- NULL
[17:39:56.474]     }
[17:39:56.474]     ...future.result$conditions <- ...future.conditions
[17:39:56.474]     ...future.result$finished <- base::Sys.time()
[17:39:56.474]     ...future.result
[17:39:56.474] }
[17:39:56.476] assign_globals() ...
[17:39:56.476] List of 1
[17:39:56.476]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd7ecde90> 
[17:39:56.476]  - attr(*, "where")=List of 1
[17:39:56.476]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.476]  - attr(*, "resolved")= logi TRUE
[17:39:56.476]  - attr(*, "total_size")= num 10816
[17:39:56.476]  - attr(*, "already-done")= logi TRUE
[17:39:56.479] - copied ‘a’ to environment
[17:39:56.479] assign_globals() ... done
[17:39:56.479] requestCore(): workers = 2
[17:39:56.481] MulticoreFuture started
[17:39:56.482] - Launch lazy future ... done
[17:39:56.482] run() for ‘MulticoreFuture’ ... done
[17:39:56.482] result() for MulticoreFuture ...
[17:39:56.483] plan(): Setting new future strategy stack:
[17:39:56.483] List of future strategies:
[17:39:56.483] 1. sequential:
[17:39:56.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.483]    - tweaked: FALSE
[17:39:56.483]    - call: NULL
[17:39:56.484] plan(): nbrOfWorkers() = 1
[17:39:56.487] plan(): Setting new future strategy stack:
[17:39:56.487] List of future strategies:
[17:39:56.487] 1. multicore:
[17:39:56.487]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.487]    - tweaked: FALSE
[17:39:56.487]    - call: plan(strategy)
[17:39:56.492] plan(): nbrOfWorkers() = 2
[17:39:56.493] result() for MulticoreFuture ...
[17:39:56.493] result() for MulticoreFuture ... done
[17:39:56.493] signalConditions() ...
[17:39:56.493]  - include = ‘immediateCondition’
[17:39:56.494]  - exclude = 
[17:39:56.494]  - resignal = FALSE
[17:39:56.494]  - Number of conditions: 4
[17:39:56.494] signalConditions() ... done
[17:39:56.494] result() for MulticoreFuture ... done
[17:39:56.494] result() for MulticoreFuture ...
[17:39:56.494] result() for MulticoreFuture ... done
[17:39:56.494] signalConditions() ...
[17:39:56.495]  - include = ‘immediateCondition’
[17:39:56.495]  - exclude = 
[17:39:56.495]  - resignal = FALSE
[17:39:56.495]  - Number of conditions: 4
[17:39:56.495] signalConditions() ... done
[17:39:56.495] Future state: ‘finished’
[17:39:56.495] result() for MulticoreFuture ...
[17:39:56.495] result() for MulticoreFuture ... done
[17:39:56.496] signalConditions() ...
[17:39:56.496]  - include = ‘condition’
[17:39:56.496]  - exclude = ‘immediateCondition’
[17:39:56.496]  - resignal = TRUE
[17:39:56.496]  - Number of conditions: 4
[17:39:56.496]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.485] result() for MulticoreFuture ...
[17:39:56.496]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.486] result() for MulticoreFuture ... done
[17:39:56.496]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.486] result() for MulticoreFuture ...
[17:39:56.497]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.486] result() for MulticoreFuture ... done
[17:39:56.497] signalConditions() ... done
value(b) = 2
[17:39:56.497] result() for MulticoreFuture ...
[17:39:56.497] result() for MulticoreFuture ... done
[17:39:56.497] result() for MulticoreFuture ...
[17:39:56.497] result() for MulticoreFuture ... done
[17:39:56.497] signalConditions() ...
[17:39:56.498]  - include = ‘immediateCondition’
[17:39:56.498]  - exclude = 
[17:39:56.498]  - resignal = FALSE
[17:39:56.498]  - Number of conditions: 4
[17:39:56.498] signalConditions() ... done
[17:39:56.498] Future state: ‘finished’
[17:39:56.498] result() for MulticoreFuture ...
[17:39:56.498] result() for MulticoreFuture ... done
[17:39:56.498] signalConditions() ...
[17:39:56.499]  - include = ‘condition’
[17:39:56.499]  - exclude = ‘immediateCondition’
[17:39:56.499]  - resignal = TRUE
[17:39:56.499]  - Number of conditions: 4
[17:39:56.499]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.485] result() for MulticoreFuture ...
[17:39:56.499]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.486] result() for MulticoreFuture ... done
[17:39:56.499]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.486] result() for MulticoreFuture ...
[17:39:56.499]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.486] result() for MulticoreFuture ... done
[17:39:56.500] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.500] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.500] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.503] 
[17:39:56.503] Searching for globals ... DONE
[17:39:56.504] - globals: [0] <none>
[17:39:56.504] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.504] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.505] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.506] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:56.506] Searching for globals ... DONE
[17:39:56.507] Resolving globals: TRUE
[17:39:56.507] Resolving any globals that are futures ...
[17:39:56.507] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:56.507] Resolving any globals that are futures ... DONE
[17:39:56.507] Resolving futures part of globals (recursively) ...
[17:39:56.508] resolve() on list ...
[17:39:56.508]  recursive: 99
[17:39:56.508]  length: 1
[17:39:56.508]  elements: ‘a’
[17:39:56.508] run() for ‘Future’ ...
[17:39:56.508] - state: ‘created’
[17:39:56.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.513]   - Field: ‘label’
[17:39:56.513]   - Field: ‘local’
[17:39:56.513]   - Field: ‘owner’
[17:39:56.513]   - Field: ‘envir’
[17:39:56.513]   - Field: ‘workers’
[17:39:56.513]   - Field: ‘packages’
[17:39:56.513]   - Field: ‘gc’
[17:39:56.513]   - Field: ‘job’
[17:39:56.514]   - Field: ‘conditions’
[17:39:56.514]   - Field: ‘expr’
[17:39:56.514]   - Field: ‘uuid’
[17:39:56.514]   - Field: ‘seed’
[17:39:56.514]   - Field: ‘version’
[17:39:56.514]   - Field: ‘result’
[17:39:56.514]   - Field: ‘asynchronous’
[17:39:56.514]   - Field: ‘calls’
[17:39:56.514]   - Field: ‘globals’
[17:39:56.514]   - Field: ‘stdout’
[17:39:56.515]   - Field: ‘earlySignal’
[17:39:56.515]   - Field: ‘lazy’
[17:39:56.515]   - Field: ‘state’
[17:39:56.515] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.515] - Launch lazy future ...
[17:39:56.515] Packages needed by the future expression (n = 0): <none>
[17:39:56.515] Packages needed by future strategies (n = 0): <none>
[17:39:56.516] {
[17:39:56.516]     {
[17:39:56.516]         {
[17:39:56.516]             ...future.startTime <- base::Sys.time()
[17:39:56.516]             {
[17:39:56.516]                 {
[17:39:56.516]                   {
[17:39:56.516]                     {
[17:39:56.516]                       base::local({
[17:39:56.516]                         has_future <- base::requireNamespace("future", 
[17:39:56.516]                           quietly = TRUE)
[17:39:56.516]                         if (has_future) {
[17:39:56.516]                           ns <- base::getNamespace("future")
[17:39:56.516]                           version <- ns[[".package"]][["version"]]
[17:39:56.516]                           if (is.null(version)) 
[17:39:56.516]                             version <- utils::packageVersion("future")
[17:39:56.516]                         }
[17:39:56.516]                         else {
[17:39:56.516]                           version <- NULL
[17:39:56.516]                         }
[17:39:56.516]                         if (!has_future || version < "1.8.0") {
[17:39:56.516]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.516]                             "", base::R.version$version.string), 
[17:39:56.516]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.516]                               "release", "version")], collapse = " "), 
[17:39:56.516]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.516]                             info)
[17:39:56.516]                           info <- base::paste(info, collapse = "; ")
[17:39:56.516]                           if (!has_future) {
[17:39:56.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.516]                               info)
[17:39:56.516]                           }
[17:39:56.516]                           else {
[17:39:56.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.516]                               info, version)
[17:39:56.516]                           }
[17:39:56.516]                           base::stop(msg)
[17:39:56.516]                         }
[17:39:56.516]                       })
[17:39:56.516]                     }
[17:39:56.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.516]                     base::options(mc.cores = 1L)
[17:39:56.516]                   }
[17:39:56.516]                   ...future.strategy.old <- future::plan("list")
[17:39:56.516]                   options(future.plan = NULL)
[17:39:56.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.516]                 }
[17:39:56.516]                 ...future.workdir <- getwd()
[17:39:56.516]             }
[17:39:56.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.516]         }
[17:39:56.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.516]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.516]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.516]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.516]             base::names(...future.oldOptions))
[17:39:56.516]     }
[17:39:56.516]     if (FALSE) {
[17:39:56.516]     }
[17:39:56.516]     else {
[17:39:56.516]         if (TRUE) {
[17:39:56.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.516]                 open = "w")
[17:39:56.516]         }
[17:39:56.516]         else {
[17:39:56.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.516]         }
[17:39:56.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.516]             base::sink(type = "output", split = FALSE)
[17:39:56.516]             base::close(...future.stdout)
[17:39:56.516]         }, add = TRUE)
[17:39:56.516]     }
[17:39:56.516]     ...future.frame <- base::sys.nframe()
[17:39:56.516]     ...future.conditions <- base::list()
[17:39:56.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.516]     if (FALSE) {
[17:39:56.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.516]     }
[17:39:56.516]     ...future.result <- base::tryCatch({
[17:39:56.516]         base::withCallingHandlers({
[17:39:56.516]             ...future.value <- base::withVisible(base::local({
[17:39:56.516]                 withCallingHandlers({
[17:39:56.516]                   1
[17:39:56.516]                 }, immediateCondition = function(cond) {
[17:39:56.516]                   save_rds <- function (object, pathname, ...) 
[17:39:56.516]                   {
[17:39:56.516]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.516]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.516]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.516]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.516]                         fi_tmp[["mtime"]])
[17:39:56.516]                     }
[17:39:56.516]                     tryCatch({
[17:39:56.516]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.516]                     }, error = function(ex) {
[17:39:56.516]                       msg <- conditionMessage(ex)
[17:39:56.516]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.516]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.516]                         fi_tmp[["mtime"]], msg)
[17:39:56.516]                       ex$message <- msg
[17:39:56.516]                       stop(ex)
[17:39:56.516]                     })
[17:39:56.516]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.516]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.516]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.516]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.516]                       fi <- file.info(pathname)
[17:39:56.516]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.516]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.516]                         fi[["size"]], fi[["mtime"]])
[17:39:56.516]                       stop(msg)
[17:39:56.516]                     }
[17:39:56.516]                     invisible(pathname)
[17:39:56.516]                   }
[17:39:56.516]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.516]                     rootPath = tempdir()) 
[17:39:56.516]                   {
[17:39:56.516]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.516]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.516]                       tmpdir = path, fileext = ".rds")
[17:39:56.516]                     save_rds(obj, file)
[17:39:56.516]                   }
[17:39:56.516]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.516]                   {
[17:39:56.516]                     inherits <- base::inherits
[17:39:56.516]                     invokeRestart <- base::invokeRestart
[17:39:56.516]                     is.null <- base::is.null
[17:39:56.516]                     muffled <- FALSE
[17:39:56.516]                     if (inherits(cond, "message")) {
[17:39:56.516]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.516]                       if (muffled) 
[17:39:56.516]                         invokeRestart("muffleMessage")
[17:39:56.516]                     }
[17:39:56.516]                     else if (inherits(cond, "warning")) {
[17:39:56.516]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.516]                       if (muffled) 
[17:39:56.516]                         invokeRestart("muffleWarning")
[17:39:56.516]                     }
[17:39:56.516]                     else if (inherits(cond, "condition")) {
[17:39:56.516]                       if (!is.null(pattern)) {
[17:39:56.516]                         computeRestarts <- base::computeRestarts
[17:39:56.516]                         grepl <- base::grepl
[17:39:56.516]                         restarts <- computeRestarts(cond)
[17:39:56.516]                         for (restart in restarts) {
[17:39:56.516]                           name <- restart$name
[17:39:56.516]                           if (is.null(name)) 
[17:39:56.516]                             next
[17:39:56.516]                           if (!grepl(pattern, name)) 
[17:39:56.516]                             next
[17:39:56.516]                           invokeRestart(restart)
[17:39:56.516]                           muffled <- TRUE
[17:39:56.516]                           break
[17:39:56.516]                         }
[17:39:56.516]                       }
[17:39:56.516]                     }
[17:39:56.516]                     invisible(muffled)
[17:39:56.516]                   }
[17:39:56.516]                   muffleCondition(cond)
[17:39:56.516]                 })
[17:39:56.516]             }))
[17:39:56.516]             future::FutureResult(value = ...future.value$value, 
[17:39:56.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.516]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.516]                     ...future.globalenv.names))
[17:39:56.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.516]         }, condition = base::local({
[17:39:56.516]             c <- base::c
[17:39:56.516]             inherits <- base::inherits
[17:39:56.516]             invokeRestart <- base::invokeRestart
[17:39:56.516]             length <- base::length
[17:39:56.516]             list <- base::list
[17:39:56.516]             seq.int <- base::seq.int
[17:39:56.516]             signalCondition <- base::signalCondition
[17:39:56.516]             sys.calls <- base::sys.calls
[17:39:56.516]             `[[` <- base::`[[`
[17:39:56.516]             `+` <- base::`+`
[17:39:56.516]             `<<-` <- base::`<<-`
[17:39:56.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.516]                   3L)]
[17:39:56.516]             }
[17:39:56.516]             function(cond) {
[17:39:56.516]                 is_error <- inherits(cond, "error")
[17:39:56.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.516]                   NULL)
[17:39:56.516]                 if (is_error) {
[17:39:56.516]                   sessionInformation <- function() {
[17:39:56.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.516]                       search = base::search(), system = base::Sys.info())
[17:39:56.516]                   }
[17:39:56.516]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.516]                     cond$call), session = sessionInformation(), 
[17:39:56.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.516]                   signalCondition(cond)
[17:39:56.516]                 }
[17:39:56.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.516]                 "immediateCondition"))) {
[17:39:56.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.516]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.516]                   if (TRUE && !signal) {
[17:39:56.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.516]                     {
[17:39:56.516]                       inherits <- base::inherits
[17:39:56.516]                       invokeRestart <- base::invokeRestart
[17:39:56.516]                       is.null <- base::is.null
[17:39:56.516]                       muffled <- FALSE
[17:39:56.516]                       if (inherits(cond, "message")) {
[17:39:56.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.516]                         if (muffled) 
[17:39:56.516]                           invokeRestart("muffleMessage")
[17:39:56.516]                       }
[17:39:56.516]                       else if (inherits(cond, "warning")) {
[17:39:56.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.516]                         if (muffled) 
[17:39:56.516]                           invokeRestart("muffleWarning")
[17:39:56.516]                       }
[17:39:56.516]                       else if (inherits(cond, "condition")) {
[17:39:56.516]                         if (!is.null(pattern)) {
[17:39:56.516]                           computeRestarts <- base::computeRestarts
[17:39:56.516]                           grepl <- base::grepl
[17:39:56.516]                           restarts <- computeRestarts(cond)
[17:39:56.516]                           for (restart in restarts) {
[17:39:56.516]                             name <- restart$name
[17:39:56.516]                             if (is.null(name)) 
[17:39:56.516]                               next
[17:39:56.516]                             if (!grepl(pattern, name)) 
[17:39:56.516]                               next
[17:39:56.516]                             invokeRestart(restart)
[17:39:56.516]                             muffled <- TRUE
[17:39:56.516]                             break
[17:39:56.516]                           }
[17:39:56.516]                         }
[17:39:56.516]                       }
[17:39:56.516]                       invisible(muffled)
[17:39:56.516]                     }
[17:39:56.516]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.516]                   }
[17:39:56.516]                 }
[17:39:56.516]                 else {
[17:39:56.516]                   if (TRUE) {
[17:39:56.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.516]                     {
[17:39:56.516]                       inherits <- base::inherits
[17:39:56.516]                       invokeRestart <- base::invokeRestart
[17:39:56.516]                       is.null <- base::is.null
[17:39:56.516]                       muffled <- FALSE
[17:39:56.516]                       if (inherits(cond, "message")) {
[17:39:56.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.516]                         if (muffled) 
[17:39:56.516]                           invokeRestart("muffleMessage")
[17:39:56.516]                       }
[17:39:56.516]                       else if (inherits(cond, "warning")) {
[17:39:56.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.516]                         if (muffled) 
[17:39:56.516]                           invokeRestart("muffleWarning")
[17:39:56.516]                       }
[17:39:56.516]                       else if (inherits(cond, "condition")) {
[17:39:56.516]                         if (!is.null(pattern)) {
[17:39:56.516]                           computeRestarts <- base::computeRestarts
[17:39:56.516]                           grepl <- base::grepl
[17:39:56.516]                           restarts <- computeRestarts(cond)
[17:39:56.516]                           for (restart in restarts) {
[17:39:56.516]                             name <- restart$name
[17:39:56.516]                             if (is.null(name)) 
[17:39:56.516]                               next
[17:39:56.516]                             if (!grepl(pattern, name)) 
[17:39:56.516]                               next
[17:39:56.516]                             invokeRestart(restart)
[17:39:56.516]                             muffled <- TRUE
[17:39:56.516]                             break
[17:39:56.516]                           }
[17:39:56.516]                         }
[17:39:56.516]                       }
[17:39:56.516]                       invisible(muffled)
[17:39:56.516]                     }
[17:39:56.516]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.516]                   }
[17:39:56.516]                 }
[17:39:56.516]             }
[17:39:56.516]         }))
[17:39:56.516]     }, error = function(ex) {
[17:39:56.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.516]                 ...future.rng), started = ...future.startTime, 
[17:39:56.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.516]             version = "1.8"), class = "FutureResult")
[17:39:56.516]     }, finally = {
[17:39:56.516]         if (!identical(...future.workdir, getwd())) 
[17:39:56.516]             setwd(...future.workdir)
[17:39:56.516]         {
[17:39:56.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.516]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.516]             }
[17:39:56.516]             base::options(...future.oldOptions)
[17:39:56.516]             if (.Platform$OS.type == "windows") {
[17:39:56.516]                 old_names <- names(...future.oldEnvVars)
[17:39:56.516]                 envs <- base::Sys.getenv()
[17:39:56.516]                 names <- names(envs)
[17:39:56.516]                 common <- intersect(names, old_names)
[17:39:56.516]                 added <- setdiff(names, old_names)
[17:39:56.516]                 removed <- setdiff(old_names, names)
[17:39:56.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.516]                   envs[common]]
[17:39:56.516]                 NAMES <- toupper(changed)
[17:39:56.516]                 args <- list()
[17:39:56.516]                 for (kk in seq_along(NAMES)) {
[17:39:56.516]                   name <- changed[[kk]]
[17:39:56.516]                   NAME <- NAMES[[kk]]
[17:39:56.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.516]                     next
[17:39:56.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.516]                 }
[17:39:56.516]                 NAMES <- toupper(added)
[17:39:56.516]                 for (kk in seq_along(NAMES)) {
[17:39:56.516]                   name <- added[[kk]]
[17:39:56.516]                   NAME <- NAMES[[kk]]
[17:39:56.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.516]                     next
[17:39:56.516]                   args[[name]] <- ""
[17:39:56.516]                 }
[17:39:56.516]                 NAMES <- toupper(removed)
[17:39:56.516]                 for (kk in seq_along(NAMES)) {
[17:39:56.516]                   name <- removed[[kk]]
[17:39:56.516]                   NAME <- NAMES[[kk]]
[17:39:56.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.516]                     next
[17:39:56.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.516]                 }
[17:39:56.516]                 if (length(args) > 0) 
[17:39:56.516]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.516]             }
[17:39:56.516]             else {
[17:39:56.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.516]             }
[17:39:56.516]             {
[17:39:56.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.516]                   0L) {
[17:39:56.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.516]                   base::options(opts)
[17:39:56.516]                 }
[17:39:56.516]                 {
[17:39:56.516]                   {
[17:39:56.516]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.516]                     NULL
[17:39:56.516]                   }
[17:39:56.516]                   options(future.plan = NULL)
[17:39:56.516]                   if (is.na(NA_character_)) 
[17:39:56.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.516]                     .init = FALSE)
[17:39:56.516]                 }
[17:39:56.516]             }
[17:39:56.516]         }
[17:39:56.516]     })
[17:39:56.516]     if (TRUE) {
[17:39:56.516]         base::sink(type = "output", split = FALSE)
[17:39:56.516]         if (TRUE) {
[17:39:56.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.516]         }
[17:39:56.516]         else {
[17:39:56.516]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.516]         }
[17:39:56.516]         base::close(...future.stdout)
[17:39:56.516]         ...future.stdout <- NULL
[17:39:56.516]     }
[17:39:56.516]     ...future.result$conditions <- ...future.conditions
[17:39:56.516]     ...future.result$finished <- base::Sys.time()
[17:39:56.516]     ...future.result
[17:39:56.516] }
[17:39:56.518] requestCore(): workers = 2
[17:39:56.520] MulticoreFuture started
[17:39:56.520] - Launch lazy future ... done
[17:39:56.520] run() for ‘MulticoreFuture’ ... done
[17:39:56.521] plan(): Setting new future strategy stack:
[17:39:56.521] List of future strategies:
[17:39:56.521] 1. sequential:
[17:39:56.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.521]    - tweaked: FALSE
[17:39:56.521]    - call: NULL
[17:39:56.522] plan(): nbrOfWorkers() = 1
[17:39:56.525] plan(): Setting new future strategy stack:
[17:39:56.525] List of future strategies:
[17:39:56.525] 1. multicore:
[17:39:56.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.525]    - tweaked: FALSE
[17:39:56.525]    - call: plan(strategy)
[17:39:56.530] plan(): nbrOfWorkers() = 2
[17:39:56.531] Future #1
[17:39:56.531] result() for MulticoreFuture ...
[17:39:56.532] result() for MulticoreFuture ...
[17:39:56.532] result() for MulticoreFuture ... done
[17:39:56.532] result() for MulticoreFuture ... done
[17:39:56.532] result() for MulticoreFuture ...
[17:39:56.532] result() for MulticoreFuture ... done
[17:39:56.532] A MulticoreFuture was resolved
[17:39:56.533]  length: 0 (resolved future 1)
[17:39:56.533] resolve() on list ... DONE
[17:39:56.533] - globals: [1] ‘a’
[17:39:56.533] Resolving futures part of globals (recursively) ... DONE
[17:39:56.534] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:39:56.535] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:39:56.535] - globals: [1] ‘a’
[17:39:56.535] - packages: [1] ‘future’
[17:39:56.535] getGlobalsAndPackages() ... DONE
[17:39:56.536] run() for ‘Future’ ...
[17:39:56.536] - state: ‘created’
[17:39:56.536] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.540] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.540]   - Field: ‘label’
[17:39:56.540]   - Field: ‘local’
[17:39:56.540]   - Field: ‘owner’
[17:39:56.541]   - Field: ‘envir’
[17:39:56.541]   - Field: ‘workers’
[17:39:56.541]   - Field: ‘packages’
[17:39:56.541]   - Field: ‘gc’
[17:39:56.541]   - Field: ‘job’
[17:39:56.541]   - Field: ‘conditions’
[17:39:56.541]   - Field: ‘expr’
[17:39:56.541]   - Field: ‘uuid’
[17:39:56.542]   - Field: ‘seed’
[17:39:56.542]   - Field: ‘version’
[17:39:56.542]   - Field: ‘result’
[17:39:56.542]   - Field: ‘asynchronous’
[17:39:56.542]   - Field: ‘calls’
[17:39:56.542]   - Field: ‘globals’
[17:39:56.542]   - Field: ‘stdout’
[17:39:56.542]   - Field: ‘earlySignal’
[17:39:56.542]   - Field: ‘lazy’
[17:39:56.543]   - Field: ‘state’
[17:39:56.543] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.543] - Launch lazy future ...
[17:39:56.543] Packages needed by the future expression (n = 1): ‘future’
[17:39:56.543] Packages needed by future strategies (n = 0): <none>
[17:39:56.544] {
[17:39:56.544]     {
[17:39:56.544]         {
[17:39:56.544]             ...future.startTime <- base::Sys.time()
[17:39:56.544]             {
[17:39:56.544]                 {
[17:39:56.544]                   {
[17:39:56.544]                     {
[17:39:56.544]                       {
[17:39:56.544]                         base::local({
[17:39:56.544]                           has_future <- base::requireNamespace("future", 
[17:39:56.544]                             quietly = TRUE)
[17:39:56.544]                           if (has_future) {
[17:39:56.544]                             ns <- base::getNamespace("future")
[17:39:56.544]                             version <- ns[[".package"]][["version"]]
[17:39:56.544]                             if (is.null(version)) 
[17:39:56.544]                               version <- utils::packageVersion("future")
[17:39:56.544]                           }
[17:39:56.544]                           else {
[17:39:56.544]                             version <- NULL
[17:39:56.544]                           }
[17:39:56.544]                           if (!has_future || version < "1.8.0") {
[17:39:56.544]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.544]                               "", base::R.version$version.string), 
[17:39:56.544]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:56.544]                                 base::R.version$platform, 8 * 
[17:39:56.544]                                   base::.Machine$sizeof.pointer), 
[17:39:56.544]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.544]                                 "release", "version")], collapse = " "), 
[17:39:56.544]                               hostname = base::Sys.info()[["nodename"]])
[17:39:56.544]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.544]                               info)
[17:39:56.544]                             info <- base::paste(info, collapse = "; ")
[17:39:56.544]                             if (!has_future) {
[17:39:56.544]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.544]                                 info)
[17:39:56.544]                             }
[17:39:56.544]                             else {
[17:39:56.544]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.544]                                 info, version)
[17:39:56.544]                             }
[17:39:56.544]                             base::stop(msg)
[17:39:56.544]                           }
[17:39:56.544]                         })
[17:39:56.544]                       }
[17:39:56.544]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.544]                       base::options(mc.cores = 1L)
[17:39:56.544]                     }
[17:39:56.544]                     base::local({
[17:39:56.544]                       for (pkg in "future") {
[17:39:56.544]                         base::loadNamespace(pkg)
[17:39:56.544]                         base::library(pkg, character.only = TRUE)
[17:39:56.544]                       }
[17:39:56.544]                     })
[17:39:56.544]                   }
[17:39:56.544]                   ...future.strategy.old <- future::plan("list")
[17:39:56.544]                   options(future.plan = NULL)
[17:39:56.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.544]                 }
[17:39:56.544]                 ...future.workdir <- getwd()
[17:39:56.544]             }
[17:39:56.544]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.544]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.544]         }
[17:39:56.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.544]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.544]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.544]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.544]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.544]             base::names(...future.oldOptions))
[17:39:56.544]     }
[17:39:56.544]     if (FALSE) {
[17:39:56.544]     }
[17:39:56.544]     else {
[17:39:56.544]         if (TRUE) {
[17:39:56.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.544]                 open = "w")
[17:39:56.544]         }
[17:39:56.544]         else {
[17:39:56.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.544]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.544]         }
[17:39:56.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.544]             base::sink(type = "output", split = FALSE)
[17:39:56.544]             base::close(...future.stdout)
[17:39:56.544]         }, add = TRUE)
[17:39:56.544]     }
[17:39:56.544]     ...future.frame <- base::sys.nframe()
[17:39:56.544]     ...future.conditions <- base::list()
[17:39:56.544]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.544]     if (FALSE) {
[17:39:56.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.544]     }
[17:39:56.544]     ...future.result <- base::tryCatch({
[17:39:56.544]         base::withCallingHandlers({
[17:39:56.544]             ...future.value <- base::withVisible(base::local({
[17:39:56.544]                 withCallingHandlers({
[17:39:56.544]                   value(a) + 1
[17:39:56.544]                 }, immediateCondition = function(cond) {
[17:39:56.544]                   save_rds <- function (object, pathname, ...) 
[17:39:56.544]                   {
[17:39:56.544]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.544]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.544]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.544]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.544]                         fi_tmp[["mtime"]])
[17:39:56.544]                     }
[17:39:56.544]                     tryCatch({
[17:39:56.544]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.544]                     }, error = function(ex) {
[17:39:56.544]                       msg <- conditionMessage(ex)
[17:39:56.544]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.544]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.544]                         fi_tmp[["mtime"]], msg)
[17:39:56.544]                       ex$message <- msg
[17:39:56.544]                       stop(ex)
[17:39:56.544]                     })
[17:39:56.544]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.544]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.544]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.544]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.544]                       fi <- file.info(pathname)
[17:39:56.544]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.544]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.544]                         fi[["size"]], fi[["mtime"]])
[17:39:56.544]                       stop(msg)
[17:39:56.544]                     }
[17:39:56.544]                     invisible(pathname)
[17:39:56.544]                   }
[17:39:56.544]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.544]                     rootPath = tempdir()) 
[17:39:56.544]                   {
[17:39:56.544]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.544]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.544]                       tmpdir = path, fileext = ".rds")
[17:39:56.544]                     save_rds(obj, file)
[17:39:56.544]                   }
[17:39:56.544]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.544]                   {
[17:39:56.544]                     inherits <- base::inherits
[17:39:56.544]                     invokeRestart <- base::invokeRestart
[17:39:56.544]                     is.null <- base::is.null
[17:39:56.544]                     muffled <- FALSE
[17:39:56.544]                     if (inherits(cond, "message")) {
[17:39:56.544]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.544]                       if (muffled) 
[17:39:56.544]                         invokeRestart("muffleMessage")
[17:39:56.544]                     }
[17:39:56.544]                     else if (inherits(cond, "warning")) {
[17:39:56.544]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.544]                       if (muffled) 
[17:39:56.544]                         invokeRestart("muffleWarning")
[17:39:56.544]                     }
[17:39:56.544]                     else if (inherits(cond, "condition")) {
[17:39:56.544]                       if (!is.null(pattern)) {
[17:39:56.544]                         computeRestarts <- base::computeRestarts
[17:39:56.544]                         grepl <- base::grepl
[17:39:56.544]                         restarts <- computeRestarts(cond)
[17:39:56.544]                         for (restart in restarts) {
[17:39:56.544]                           name <- restart$name
[17:39:56.544]                           if (is.null(name)) 
[17:39:56.544]                             next
[17:39:56.544]                           if (!grepl(pattern, name)) 
[17:39:56.544]                             next
[17:39:56.544]                           invokeRestart(restart)
[17:39:56.544]                           muffled <- TRUE
[17:39:56.544]                           break
[17:39:56.544]                         }
[17:39:56.544]                       }
[17:39:56.544]                     }
[17:39:56.544]                     invisible(muffled)
[17:39:56.544]                   }
[17:39:56.544]                   muffleCondition(cond)
[17:39:56.544]                 })
[17:39:56.544]             }))
[17:39:56.544]             future::FutureResult(value = ...future.value$value, 
[17:39:56.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.544]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.544]                     ...future.globalenv.names))
[17:39:56.544]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.544]         }, condition = base::local({
[17:39:56.544]             c <- base::c
[17:39:56.544]             inherits <- base::inherits
[17:39:56.544]             invokeRestart <- base::invokeRestart
[17:39:56.544]             length <- base::length
[17:39:56.544]             list <- base::list
[17:39:56.544]             seq.int <- base::seq.int
[17:39:56.544]             signalCondition <- base::signalCondition
[17:39:56.544]             sys.calls <- base::sys.calls
[17:39:56.544]             `[[` <- base::`[[`
[17:39:56.544]             `+` <- base::`+`
[17:39:56.544]             `<<-` <- base::`<<-`
[17:39:56.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.544]                   3L)]
[17:39:56.544]             }
[17:39:56.544]             function(cond) {
[17:39:56.544]                 is_error <- inherits(cond, "error")
[17:39:56.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.544]                   NULL)
[17:39:56.544]                 if (is_error) {
[17:39:56.544]                   sessionInformation <- function() {
[17:39:56.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.544]                       search = base::search(), system = base::Sys.info())
[17:39:56.544]                   }
[17:39:56.544]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.544]                     cond$call), session = sessionInformation(), 
[17:39:56.544]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.544]                   signalCondition(cond)
[17:39:56.544]                 }
[17:39:56.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.544]                 "immediateCondition"))) {
[17:39:56.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.544]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.544]                   if (TRUE && !signal) {
[17:39:56.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.544]                     {
[17:39:56.544]                       inherits <- base::inherits
[17:39:56.544]                       invokeRestart <- base::invokeRestart
[17:39:56.544]                       is.null <- base::is.null
[17:39:56.544]                       muffled <- FALSE
[17:39:56.544]                       if (inherits(cond, "message")) {
[17:39:56.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.544]                         if (muffled) 
[17:39:56.544]                           invokeRestart("muffleMessage")
[17:39:56.544]                       }
[17:39:56.544]                       else if (inherits(cond, "warning")) {
[17:39:56.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.544]                         if (muffled) 
[17:39:56.544]                           invokeRestart("muffleWarning")
[17:39:56.544]                       }
[17:39:56.544]                       else if (inherits(cond, "condition")) {
[17:39:56.544]                         if (!is.null(pattern)) {
[17:39:56.544]                           computeRestarts <- base::computeRestarts
[17:39:56.544]                           grepl <- base::grepl
[17:39:56.544]                           restarts <- computeRestarts(cond)
[17:39:56.544]                           for (restart in restarts) {
[17:39:56.544]                             name <- restart$name
[17:39:56.544]                             if (is.null(name)) 
[17:39:56.544]                               next
[17:39:56.544]                             if (!grepl(pattern, name)) 
[17:39:56.544]                               next
[17:39:56.544]                             invokeRestart(restart)
[17:39:56.544]                             muffled <- TRUE
[17:39:56.544]                             break
[17:39:56.544]                           }
[17:39:56.544]                         }
[17:39:56.544]                       }
[17:39:56.544]                       invisible(muffled)
[17:39:56.544]                     }
[17:39:56.544]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.544]                   }
[17:39:56.544]                 }
[17:39:56.544]                 else {
[17:39:56.544]                   if (TRUE) {
[17:39:56.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.544]                     {
[17:39:56.544]                       inherits <- base::inherits
[17:39:56.544]                       invokeRestart <- base::invokeRestart
[17:39:56.544]                       is.null <- base::is.null
[17:39:56.544]                       muffled <- FALSE
[17:39:56.544]                       if (inherits(cond, "message")) {
[17:39:56.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.544]                         if (muffled) 
[17:39:56.544]                           invokeRestart("muffleMessage")
[17:39:56.544]                       }
[17:39:56.544]                       else if (inherits(cond, "warning")) {
[17:39:56.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.544]                         if (muffled) 
[17:39:56.544]                           invokeRestart("muffleWarning")
[17:39:56.544]                       }
[17:39:56.544]                       else if (inherits(cond, "condition")) {
[17:39:56.544]                         if (!is.null(pattern)) {
[17:39:56.544]                           computeRestarts <- base::computeRestarts
[17:39:56.544]                           grepl <- base::grepl
[17:39:56.544]                           restarts <- computeRestarts(cond)
[17:39:56.544]                           for (restart in restarts) {
[17:39:56.544]                             name <- restart$name
[17:39:56.544]                             if (is.null(name)) 
[17:39:56.544]                               next
[17:39:56.544]                             if (!grepl(pattern, name)) 
[17:39:56.544]                               next
[17:39:56.544]                             invokeRestart(restart)
[17:39:56.544]                             muffled <- TRUE
[17:39:56.544]                             break
[17:39:56.544]                           }
[17:39:56.544]                         }
[17:39:56.544]                       }
[17:39:56.544]                       invisible(muffled)
[17:39:56.544]                     }
[17:39:56.544]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.544]                   }
[17:39:56.544]                 }
[17:39:56.544]             }
[17:39:56.544]         }))
[17:39:56.544]     }, error = function(ex) {
[17:39:56.544]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.544]                 ...future.rng), started = ...future.startTime, 
[17:39:56.544]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.544]             version = "1.8"), class = "FutureResult")
[17:39:56.544]     }, finally = {
[17:39:56.544]         if (!identical(...future.workdir, getwd())) 
[17:39:56.544]             setwd(...future.workdir)
[17:39:56.544]         {
[17:39:56.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.544]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.544]             }
[17:39:56.544]             base::options(...future.oldOptions)
[17:39:56.544]             if (.Platform$OS.type == "windows") {
[17:39:56.544]                 old_names <- names(...future.oldEnvVars)
[17:39:56.544]                 envs <- base::Sys.getenv()
[17:39:56.544]                 names <- names(envs)
[17:39:56.544]                 common <- intersect(names, old_names)
[17:39:56.544]                 added <- setdiff(names, old_names)
[17:39:56.544]                 removed <- setdiff(old_names, names)
[17:39:56.544]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.544]                   envs[common]]
[17:39:56.544]                 NAMES <- toupper(changed)
[17:39:56.544]                 args <- list()
[17:39:56.544]                 for (kk in seq_along(NAMES)) {
[17:39:56.544]                   name <- changed[[kk]]
[17:39:56.544]                   NAME <- NAMES[[kk]]
[17:39:56.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.544]                     next
[17:39:56.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.544]                 }
[17:39:56.544]                 NAMES <- toupper(added)
[17:39:56.544]                 for (kk in seq_along(NAMES)) {
[17:39:56.544]                   name <- added[[kk]]
[17:39:56.544]                   NAME <- NAMES[[kk]]
[17:39:56.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.544]                     next
[17:39:56.544]                   args[[name]] <- ""
[17:39:56.544]                 }
[17:39:56.544]                 NAMES <- toupper(removed)
[17:39:56.544]                 for (kk in seq_along(NAMES)) {
[17:39:56.544]                   name <- removed[[kk]]
[17:39:56.544]                   NAME <- NAMES[[kk]]
[17:39:56.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.544]                     next
[17:39:56.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.544]                 }
[17:39:56.544]                 if (length(args) > 0) 
[17:39:56.544]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.544]             }
[17:39:56.544]             else {
[17:39:56.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.544]             }
[17:39:56.544]             {
[17:39:56.544]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.544]                   0L) {
[17:39:56.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.544]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.544]                   base::options(opts)
[17:39:56.544]                 }
[17:39:56.544]                 {
[17:39:56.544]                   {
[17:39:56.544]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.544]                     NULL
[17:39:56.544]                   }
[17:39:56.544]                   options(future.plan = NULL)
[17:39:56.544]                   if (is.na(NA_character_)) 
[17:39:56.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.544]                     .init = FALSE)
[17:39:56.544]                 }
[17:39:56.544]             }
[17:39:56.544]         }
[17:39:56.544]     })
[17:39:56.544]     if (TRUE) {
[17:39:56.544]         base::sink(type = "output", split = FALSE)
[17:39:56.544]         if (TRUE) {
[17:39:56.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.544]         }
[17:39:56.544]         else {
[17:39:56.544]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.544]         }
[17:39:56.544]         base::close(...future.stdout)
[17:39:56.544]         ...future.stdout <- NULL
[17:39:56.544]     }
[17:39:56.544]     ...future.result$conditions <- ...future.conditions
[17:39:56.544]     ...future.result$finished <- base::Sys.time()
[17:39:56.544]     ...future.result
[17:39:56.544] }
[17:39:56.547] assign_globals() ...
[17:39:56.547] List of 1
[17:39:56.547]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd8be7430> 
[17:39:56.547]  - attr(*, "where")=List of 1
[17:39:56.547]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.547]  - attr(*, "resolved")= logi TRUE
[17:39:56.547]  - attr(*, "total_size")= num 10984
[17:39:56.547]  - attr(*, "already-done")= logi TRUE
[17:39:56.552] - copied ‘a’ to environment
[17:39:56.552] assign_globals() ... done
[17:39:56.552] requestCore(): workers = 2
[17:39:56.554] MulticoreFuture started
[17:39:56.555] - Launch lazy future ... done
[17:39:56.556] run() for ‘MulticoreFuture’ ... done
[17:39:56.556] result() for MulticoreFuture ...
[17:39:56.556] plan(): Setting new future strategy stack:
[17:39:56.557] List of future strategies:
[17:39:56.557] 1. sequential:
[17:39:56.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.557]    - tweaked: FALSE
[17:39:56.557]    - call: NULL
[17:39:56.558] plan(): nbrOfWorkers() = 1
[17:39:56.562] plan(): Setting new future strategy stack:
[17:39:56.562] List of future strategies:
[17:39:56.562] 1. multicore:
[17:39:56.562]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.562]    - tweaked: FALSE
[17:39:56.562]    - call: plan(strategy)
[17:39:56.568] plan(): nbrOfWorkers() = 2
[17:39:56.569] result() for MulticoreFuture ...
[17:39:56.569] result() for MulticoreFuture ... done
[17:39:56.569] signalConditions() ...
[17:39:56.570]  - include = ‘immediateCondition’
[17:39:56.570]  - exclude = 
[17:39:56.570]  - resignal = FALSE
[17:39:56.570]  - Number of conditions: 4
[17:39:56.570] signalConditions() ... done
[17:39:56.570] result() for MulticoreFuture ... done
[17:39:56.570] result() for MulticoreFuture ...
[17:39:56.571] result() for MulticoreFuture ... done
[17:39:56.571] signalConditions() ...
[17:39:56.571]  - include = ‘immediateCondition’
[17:39:56.571]  - exclude = 
[17:39:56.571]  - resignal = FALSE
[17:39:56.571]  - Number of conditions: 4
[17:39:56.571] signalConditions() ... done
[17:39:56.572] Future state: ‘finished’
[17:39:56.572] result() for MulticoreFuture ...
[17:39:56.572] result() for MulticoreFuture ... done
[17:39:56.572] signalConditions() ...
[17:39:56.572]  - include = ‘condition’
[17:39:56.572]  - exclude = ‘immediateCondition’
[17:39:56.572]  - resignal = TRUE
[17:39:56.572]  - Number of conditions: 4
[17:39:56.573]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.559] result() for MulticoreFuture ...
[17:39:56.573]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.560] result() for MulticoreFuture ... done
[17:39:56.573]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.560] result() for MulticoreFuture ...
[17:39:56.573]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.561] result() for MulticoreFuture ... done
[17:39:56.573] signalConditions() ... done
value(b) = 2
[17:39:56.574] result() for MulticoreFuture ...
[17:39:56.574] result() for MulticoreFuture ... done
[17:39:56.574] result() for MulticoreFuture ...
[17:39:56.574] result() for MulticoreFuture ... done
[17:39:56.574] signalConditions() ...
[17:39:56.574]  - include = ‘immediateCondition’
[17:39:56.574]  - exclude = 
[17:39:56.574]  - resignal = FALSE
[17:39:56.574]  - Number of conditions: 4
[17:39:56.575] signalConditions() ... done
[17:39:56.575] Future state: ‘finished’
[17:39:56.575] result() for MulticoreFuture ...
[17:39:56.575] result() for MulticoreFuture ... done
[17:39:56.575] signalConditions() ...
[17:39:56.575]  - include = ‘condition’
[17:39:56.575]  - exclude = ‘immediateCondition’
[17:39:56.575]  - resignal = TRUE
[17:39:56.575]  - Number of conditions: 4
[17:39:56.575]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.559] result() for MulticoreFuture ...
[17:39:56.576]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.560] result() for MulticoreFuture ... done
[17:39:56.576]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.560] result() for MulticoreFuture ...
[17:39:56.576]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.561] result() for MulticoreFuture ... done
[17:39:56.576] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.576] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.577] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.577] 
[17:39:56.578] Searching for globals ... DONE
[17:39:56.578] - globals: [0] <none>
[17:39:56.578] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.578] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.578] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.580] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:56.580] Searching for globals ... DONE
[17:39:56.580] Resolving globals: TRUE
[17:39:56.580] Resolving any globals that are futures ...
[17:39:56.580] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:56.580] Resolving any globals that are futures ... DONE
[17:39:56.581] Resolving futures part of globals (recursively) ...
[17:39:56.581] resolve() on list ...
[17:39:56.581]  recursive: 99
[17:39:56.581]  length: 1
[17:39:56.581]  elements: ‘a’
[17:39:56.581] run() for ‘Future’ ...
[17:39:56.581] - state: ‘created’
[17:39:56.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.586]   - Field: ‘label’
[17:39:56.586]   - Field: ‘local’
[17:39:56.586]   - Field: ‘owner’
[17:39:56.586]   - Field: ‘envir’
[17:39:56.586]   - Field: ‘workers’
[17:39:56.586]   - Field: ‘packages’
[17:39:56.586]   - Field: ‘gc’
[17:39:56.587]   - Field: ‘job’
[17:39:56.587]   - Field: ‘conditions’
[17:39:56.587]   - Field: ‘expr’
[17:39:56.587]   - Field: ‘uuid’
[17:39:56.587]   - Field: ‘seed’
[17:39:56.587]   - Field: ‘version’
[17:39:56.587]   - Field: ‘result’
[17:39:56.587]   - Field: ‘asynchronous’
[17:39:56.587]   - Field: ‘calls’
[17:39:56.588]   - Field: ‘globals’
[17:39:56.588]   - Field: ‘stdout’
[17:39:56.588]   - Field: ‘earlySignal’
[17:39:56.588]   - Field: ‘lazy’
[17:39:56.588]   - Field: ‘state’
[17:39:56.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.588] - Launch lazy future ...
[17:39:56.589] Packages needed by the future expression (n = 0): <none>
[17:39:56.589] Packages needed by future strategies (n = 0): <none>
[17:39:56.589] {
[17:39:56.589]     {
[17:39:56.589]         {
[17:39:56.589]             ...future.startTime <- base::Sys.time()
[17:39:56.589]             {
[17:39:56.589]                 {
[17:39:56.589]                   {
[17:39:56.589]                     {
[17:39:56.589]                       base::local({
[17:39:56.589]                         has_future <- base::requireNamespace("future", 
[17:39:56.589]                           quietly = TRUE)
[17:39:56.589]                         if (has_future) {
[17:39:56.589]                           ns <- base::getNamespace("future")
[17:39:56.589]                           version <- ns[[".package"]][["version"]]
[17:39:56.589]                           if (is.null(version)) 
[17:39:56.589]                             version <- utils::packageVersion("future")
[17:39:56.589]                         }
[17:39:56.589]                         else {
[17:39:56.589]                           version <- NULL
[17:39:56.589]                         }
[17:39:56.589]                         if (!has_future || version < "1.8.0") {
[17:39:56.589]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.589]                             "", base::R.version$version.string), 
[17:39:56.589]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.589]                               "release", "version")], collapse = " "), 
[17:39:56.589]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.589]                             info)
[17:39:56.589]                           info <- base::paste(info, collapse = "; ")
[17:39:56.589]                           if (!has_future) {
[17:39:56.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.589]                               info)
[17:39:56.589]                           }
[17:39:56.589]                           else {
[17:39:56.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.589]                               info, version)
[17:39:56.589]                           }
[17:39:56.589]                           base::stop(msg)
[17:39:56.589]                         }
[17:39:56.589]                       })
[17:39:56.589]                     }
[17:39:56.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.589]                     base::options(mc.cores = 1L)
[17:39:56.589]                   }
[17:39:56.589]                   ...future.strategy.old <- future::plan("list")
[17:39:56.589]                   options(future.plan = NULL)
[17:39:56.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.589]                 }
[17:39:56.589]                 ...future.workdir <- getwd()
[17:39:56.589]             }
[17:39:56.589]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.589]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.589]         }
[17:39:56.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.589]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.589]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.589]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.589]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.589]             base::names(...future.oldOptions))
[17:39:56.589]     }
[17:39:56.589]     if (FALSE) {
[17:39:56.589]     }
[17:39:56.589]     else {
[17:39:56.589]         if (TRUE) {
[17:39:56.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.589]                 open = "w")
[17:39:56.589]         }
[17:39:56.589]         else {
[17:39:56.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.589]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.589]         }
[17:39:56.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.589]             base::sink(type = "output", split = FALSE)
[17:39:56.589]             base::close(...future.stdout)
[17:39:56.589]         }, add = TRUE)
[17:39:56.589]     }
[17:39:56.589]     ...future.frame <- base::sys.nframe()
[17:39:56.589]     ...future.conditions <- base::list()
[17:39:56.589]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.589]     if (FALSE) {
[17:39:56.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.589]     }
[17:39:56.589]     ...future.result <- base::tryCatch({
[17:39:56.589]         base::withCallingHandlers({
[17:39:56.589]             ...future.value <- base::withVisible(base::local({
[17:39:56.589]                 withCallingHandlers({
[17:39:56.589]                   1
[17:39:56.589]                 }, immediateCondition = function(cond) {
[17:39:56.589]                   save_rds <- function (object, pathname, ...) 
[17:39:56.589]                   {
[17:39:56.589]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.589]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.589]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.589]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.589]                         fi_tmp[["mtime"]])
[17:39:56.589]                     }
[17:39:56.589]                     tryCatch({
[17:39:56.589]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.589]                     }, error = function(ex) {
[17:39:56.589]                       msg <- conditionMessage(ex)
[17:39:56.589]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.589]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.589]                         fi_tmp[["mtime"]], msg)
[17:39:56.589]                       ex$message <- msg
[17:39:56.589]                       stop(ex)
[17:39:56.589]                     })
[17:39:56.589]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.589]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.589]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.589]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.589]                       fi <- file.info(pathname)
[17:39:56.589]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.589]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.589]                         fi[["size"]], fi[["mtime"]])
[17:39:56.589]                       stop(msg)
[17:39:56.589]                     }
[17:39:56.589]                     invisible(pathname)
[17:39:56.589]                   }
[17:39:56.589]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.589]                     rootPath = tempdir()) 
[17:39:56.589]                   {
[17:39:56.589]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.589]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.589]                       tmpdir = path, fileext = ".rds")
[17:39:56.589]                     save_rds(obj, file)
[17:39:56.589]                   }
[17:39:56.589]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.589]                   {
[17:39:56.589]                     inherits <- base::inherits
[17:39:56.589]                     invokeRestart <- base::invokeRestart
[17:39:56.589]                     is.null <- base::is.null
[17:39:56.589]                     muffled <- FALSE
[17:39:56.589]                     if (inherits(cond, "message")) {
[17:39:56.589]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.589]                       if (muffled) 
[17:39:56.589]                         invokeRestart("muffleMessage")
[17:39:56.589]                     }
[17:39:56.589]                     else if (inherits(cond, "warning")) {
[17:39:56.589]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.589]                       if (muffled) 
[17:39:56.589]                         invokeRestart("muffleWarning")
[17:39:56.589]                     }
[17:39:56.589]                     else if (inherits(cond, "condition")) {
[17:39:56.589]                       if (!is.null(pattern)) {
[17:39:56.589]                         computeRestarts <- base::computeRestarts
[17:39:56.589]                         grepl <- base::grepl
[17:39:56.589]                         restarts <- computeRestarts(cond)
[17:39:56.589]                         for (restart in restarts) {
[17:39:56.589]                           name <- restart$name
[17:39:56.589]                           if (is.null(name)) 
[17:39:56.589]                             next
[17:39:56.589]                           if (!grepl(pattern, name)) 
[17:39:56.589]                             next
[17:39:56.589]                           invokeRestart(restart)
[17:39:56.589]                           muffled <- TRUE
[17:39:56.589]                           break
[17:39:56.589]                         }
[17:39:56.589]                       }
[17:39:56.589]                     }
[17:39:56.589]                     invisible(muffled)
[17:39:56.589]                   }
[17:39:56.589]                   muffleCondition(cond)
[17:39:56.589]                 })
[17:39:56.589]             }))
[17:39:56.589]             future::FutureResult(value = ...future.value$value, 
[17:39:56.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.589]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.589]                     ...future.globalenv.names))
[17:39:56.589]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.589]         }, condition = base::local({
[17:39:56.589]             c <- base::c
[17:39:56.589]             inherits <- base::inherits
[17:39:56.589]             invokeRestart <- base::invokeRestart
[17:39:56.589]             length <- base::length
[17:39:56.589]             list <- base::list
[17:39:56.589]             seq.int <- base::seq.int
[17:39:56.589]             signalCondition <- base::signalCondition
[17:39:56.589]             sys.calls <- base::sys.calls
[17:39:56.589]             `[[` <- base::`[[`
[17:39:56.589]             `+` <- base::`+`
[17:39:56.589]             `<<-` <- base::`<<-`
[17:39:56.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.589]                   3L)]
[17:39:56.589]             }
[17:39:56.589]             function(cond) {
[17:39:56.589]                 is_error <- inherits(cond, "error")
[17:39:56.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.589]                   NULL)
[17:39:56.589]                 if (is_error) {
[17:39:56.589]                   sessionInformation <- function() {
[17:39:56.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.589]                       search = base::search(), system = base::Sys.info())
[17:39:56.589]                   }
[17:39:56.589]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.589]                     cond$call), session = sessionInformation(), 
[17:39:56.589]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.589]                   signalCondition(cond)
[17:39:56.589]                 }
[17:39:56.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.589]                 "immediateCondition"))) {
[17:39:56.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.589]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.589]                   if (TRUE && !signal) {
[17:39:56.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.589]                     {
[17:39:56.589]                       inherits <- base::inherits
[17:39:56.589]                       invokeRestart <- base::invokeRestart
[17:39:56.589]                       is.null <- base::is.null
[17:39:56.589]                       muffled <- FALSE
[17:39:56.589]                       if (inherits(cond, "message")) {
[17:39:56.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.589]                         if (muffled) 
[17:39:56.589]                           invokeRestart("muffleMessage")
[17:39:56.589]                       }
[17:39:56.589]                       else if (inherits(cond, "warning")) {
[17:39:56.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.589]                         if (muffled) 
[17:39:56.589]                           invokeRestart("muffleWarning")
[17:39:56.589]                       }
[17:39:56.589]                       else if (inherits(cond, "condition")) {
[17:39:56.589]                         if (!is.null(pattern)) {
[17:39:56.589]                           computeRestarts <- base::computeRestarts
[17:39:56.589]                           grepl <- base::grepl
[17:39:56.589]                           restarts <- computeRestarts(cond)
[17:39:56.589]                           for (restart in restarts) {
[17:39:56.589]                             name <- restart$name
[17:39:56.589]                             if (is.null(name)) 
[17:39:56.589]                               next
[17:39:56.589]                             if (!grepl(pattern, name)) 
[17:39:56.589]                               next
[17:39:56.589]                             invokeRestart(restart)
[17:39:56.589]                             muffled <- TRUE
[17:39:56.589]                             break
[17:39:56.589]                           }
[17:39:56.589]                         }
[17:39:56.589]                       }
[17:39:56.589]                       invisible(muffled)
[17:39:56.589]                     }
[17:39:56.589]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.589]                   }
[17:39:56.589]                 }
[17:39:56.589]                 else {
[17:39:56.589]                   if (TRUE) {
[17:39:56.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.589]                     {
[17:39:56.589]                       inherits <- base::inherits
[17:39:56.589]                       invokeRestart <- base::invokeRestart
[17:39:56.589]                       is.null <- base::is.null
[17:39:56.589]                       muffled <- FALSE
[17:39:56.589]                       if (inherits(cond, "message")) {
[17:39:56.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.589]                         if (muffled) 
[17:39:56.589]                           invokeRestart("muffleMessage")
[17:39:56.589]                       }
[17:39:56.589]                       else if (inherits(cond, "warning")) {
[17:39:56.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.589]                         if (muffled) 
[17:39:56.589]                           invokeRestart("muffleWarning")
[17:39:56.589]                       }
[17:39:56.589]                       else if (inherits(cond, "condition")) {
[17:39:56.589]                         if (!is.null(pattern)) {
[17:39:56.589]                           computeRestarts <- base::computeRestarts
[17:39:56.589]                           grepl <- base::grepl
[17:39:56.589]                           restarts <- computeRestarts(cond)
[17:39:56.589]                           for (restart in restarts) {
[17:39:56.589]                             name <- restart$name
[17:39:56.589]                             if (is.null(name)) 
[17:39:56.589]                               next
[17:39:56.589]                             if (!grepl(pattern, name)) 
[17:39:56.589]                               next
[17:39:56.589]                             invokeRestart(restart)
[17:39:56.589]                             muffled <- TRUE
[17:39:56.589]                             break
[17:39:56.589]                           }
[17:39:56.589]                         }
[17:39:56.589]                       }
[17:39:56.589]                       invisible(muffled)
[17:39:56.589]                     }
[17:39:56.589]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.589]                   }
[17:39:56.589]                 }
[17:39:56.589]             }
[17:39:56.589]         }))
[17:39:56.589]     }, error = function(ex) {
[17:39:56.589]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.589]                 ...future.rng), started = ...future.startTime, 
[17:39:56.589]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.589]             version = "1.8"), class = "FutureResult")
[17:39:56.589]     }, finally = {
[17:39:56.589]         if (!identical(...future.workdir, getwd())) 
[17:39:56.589]             setwd(...future.workdir)
[17:39:56.589]         {
[17:39:56.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.589]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.589]             }
[17:39:56.589]             base::options(...future.oldOptions)
[17:39:56.589]             if (.Platform$OS.type == "windows") {
[17:39:56.589]                 old_names <- names(...future.oldEnvVars)
[17:39:56.589]                 envs <- base::Sys.getenv()
[17:39:56.589]                 names <- names(envs)
[17:39:56.589]                 common <- intersect(names, old_names)
[17:39:56.589]                 added <- setdiff(names, old_names)
[17:39:56.589]                 removed <- setdiff(old_names, names)
[17:39:56.589]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.589]                   envs[common]]
[17:39:56.589]                 NAMES <- toupper(changed)
[17:39:56.589]                 args <- list()
[17:39:56.589]                 for (kk in seq_along(NAMES)) {
[17:39:56.589]                   name <- changed[[kk]]
[17:39:56.589]                   NAME <- NAMES[[kk]]
[17:39:56.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.589]                     next
[17:39:56.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.589]                 }
[17:39:56.589]                 NAMES <- toupper(added)
[17:39:56.589]                 for (kk in seq_along(NAMES)) {
[17:39:56.589]                   name <- added[[kk]]
[17:39:56.589]                   NAME <- NAMES[[kk]]
[17:39:56.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.589]                     next
[17:39:56.589]                   args[[name]] <- ""
[17:39:56.589]                 }
[17:39:56.589]                 NAMES <- toupper(removed)
[17:39:56.589]                 for (kk in seq_along(NAMES)) {
[17:39:56.589]                   name <- removed[[kk]]
[17:39:56.589]                   NAME <- NAMES[[kk]]
[17:39:56.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.589]                     next
[17:39:56.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.589]                 }
[17:39:56.589]                 if (length(args) > 0) 
[17:39:56.589]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.589]             }
[17:39:56.589]             else {
[17:39:56.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.589]             }
[17:39:56.589]             {
[17:39:56.589]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.589]                   0L) {
[17:39:56.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.589]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.589]                   base::options(opts)
[17:39:56.589]                 }
[17:39:56.589]                 {
[17:39:56.589]                   {
[17:39:56.589]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.589]                     NULL
[17:39:56.589]                   }
[17:39:56.589]                   options(future.plan = NULL)
[17:39:56.589]                   if (is.na(NA_character_)) 
[17:39:56.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.589]                     .init = FALSE)
[17:39:56.589]                 }
[17:39:56.589]             }
[17:39:56.589]         }
[17:39:56.589]     })
[17:39:56.589]     if (TRUE) {
[17:39:56.589]         base::sink(type = "output", split = FALSE)
[17:39:56.589]         if (TRUE) {
[17:39:56.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.589]         }
[17:39:56.589]         else {
[17:39:56.589]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.589]         }
[17:39:56.589]         base::close(...future.stdout)
[17:39:56.589]         ...future.stdout <- NULL
[17:39:56.589]     }
[17:39:56.589]     ...future.result$conditions <- ...future.conditions
[17:39:56.589]     ...future.result$finished <- base::Sys.time()
[17:39:56.589]     ...future.result
[17:39:56.589] }
[17:39:56.592] requestCore(): workers = 2
[17:39:56.593] MulticoreFuture started
[17:39:56.594] - Launch lazy future ... done
[17:39:56.594] run() for ‘MulticoreFuture’ ... done
[17:39:56.594] plan(): Setting new future strategy stack:
[17:39:56.594] List of future strategies:
[17:39:56.594] 1. sequential:
[17:39:56.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.594]    - tweaked: FALSE
[17:39:56.594]    - call: NULL
[17:39:56.596] plan(): nbrOfWorkers() = 1
[17:39:56.598] plan(): Setting new future strategy stack:
[17:39:56.598] List of future strategies:
[17:39:56.598] 1. multicore:
[17:39:56.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.598]    - tweaked: FALSE
[17:39:56.598]    - call: plan(strategy)
[17:39:56.607] plan(): nbrOfWorkers() = 2
[17:39:56.615] Future #1
[17:39:56.615] result() for MulticoreFuture ...
[17:39:56.616] result() for MulticoreFuture ...
[17:39:56.616] result() for MulticoreFuture ... done
[17:39:56.617] result() for MulticoreFuture ... done
[17:39:56.617] result() for MulticoreFuture ...
[17:39:56.617] result() for MulticoreFuture ... done
[17:39:56.617] A MulticoreFuture was resolved
[17:39:56.617]  length: 0 (resolved future 1)
[17:39:56.617] resolve() on list ... DONE
[17:39:56.617] - globals: [1] ‘a’
[17:39:56.618] Resolving futures part of globals (recursively) ... DONE
[17:39:56.622] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:39:56.622] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:39:56.623] - globals: [1] ‘a’
[17:39:56.623] - packages: [1] ‘future’
[17:39:56.623] getGlobalsAndPackages() ... DONE
[17:39:56.623] run() for ‘Future’ ...
[17:39:56.624] - state: ‘created’
[17:39:56.624] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.628] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.628]   - Field: ‘label’
[17:39:56.628]   - Field: ‘local’
[17:39:56.628]   - Field: ‘owner’
[17:39:56.629]   - Field: ‘envir’
[17:39:56.629]   - Field: ‘workers’
[17:39:56.629]   - Field: ‘packages’
[17:39:56.629]   - Field: ‘gc’
[17:39:56.629]   - Field: ‘job’
[17:39:56.629]   - Field: ‘conditions’
[17:39:56.629]   - Field: ‘expr’
[17:39:56.629]   - Field: ‘uuid’
[17:39:56.630]   - Field: ‘seed’
[17:39:56.630]   - Field: ‘version’
[17:39:56.630]   - Field: ‘result’
[17:39:56.630]   - Field: ‘asynchronous’
[17:39:56.630]   - Field: ‘calls’
[17:39:56.630]   - Field: ‘globals’
[17:39:56.630]   - Field: ‘stdout’
[17:39:56.630]   - Field: ‘earlySignal’
[17:39:56.630]   - Field: ‘lazy’
[17:39:56.631]   - Field: ‘state’
[17:39:56.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.631] - Launch lazy future ...
[17:39:56.631] Packages needed by the future expression (n = 1): ‘future’
[17:39:56.631] Packages needed by future strategies (n = 0): <none>
[17:39:56.632] {
[17:39:56.632]     {
[17:39:56.632]         {
[17:39:56.632]             ...future.startTime <- base::Sys.time()
[17:39:56.632]             {
[17:39:56.632]                 {
[17:39:56.632]                   {
[17:39:56.632]                     {
[17:39:56.632]                       {
[17:39:56.632]                         base::local({
[17:39:56.632]                           has_future <- base::requireNamespace("future", 
[17:39:56.632]                             quietly = TRUE)
[17:39:56.632]                           if (has_future) {
[17:39:56.632]                             ns <- base::getNamespace("future")
[17:39:56.632]                             version <- ns[[".package"]][["version"]]
[17:39:56.632]                             if (is.null(version)) 
[17:39:56.632]                               version <- utils::packageVersion("future")
[17:39:56.632]                           }
[17:39:56.632]                           else {
[17:39:56.632]                             version <- NULL
[17:39:56.632]                           }
[17:39:56.632]                           if (!has_future || version < "1.8.0") {
[17:39:56.632]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.632]                               "", base::R.version$version.string), 
[17:39:56.632]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:56.632]                                 base::R.version$platform, 8 * 
[17:39:56.632]                                   base::.Machine$sizeof.pointer), 
[17:39:56.632]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.632]                                 "release", "version")], collapse = " "), 
[17:39:56.632]                               hostname = base::Sys.info()[["nodename"]])
[17:39:56.632]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.632]                               info)
[17:39:56.632]                             info <- base::paste(info, collapse = "; ")
[17:39:56.632]                             if (!has_future) {
[17:39:56.632]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.632]                                 info)
[17:39:56.632]                             }
[17:39:56.632]                             else {
[17:39:56.632]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.632]                                 info, version)
[17:39:56.632]                             }
[17:39:56.632]                             base::stop(msg)
[17:39:56.632]                           }
[17:39:56.632]                         })
[17:39:56.632]                       }
[17:39:56.632]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.632]                       base::options(mc.cores = 1L)
[17:39:56.632]                     }
[17:39:56.632]                     base::local({
[17:39:56.632]                       for (pkg in "future") {
[17:39:56.632]                         base::loadNamespace(pkg)
[17:39:56.632]                         base::library(pkg, character.only = TRUE)
[17:39:56.632]                       }
[17:39:56.632]                     })
[17:39:56.632]                   }
[17:39:56.632]                   ...future.strategy.old <- future::plan("list")
[17:39:56.632]                   options(future.plan = NULL)
[17:39:56.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.632]                 }
[17:39:56.632]                 ...future.workdir <- getwd()
[17:39:56.632]             }
[17:39:56.632]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.632]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.632]         }
[17:39:56.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.632]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.632]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.632]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.632]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.632]             base::names(...future.oldOptions))
[17:39:56.632]     }
[17:39:56.632]     if (FALSE) {
[17:39:56.632]     }
[17:39:56.632]     else {
[17:39:56.632]         if (TRUE) {
[17:39:56.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.632]                 open = "w")
[17:39:56.632]         }
[17:39:56.632]         else {
[17:39:56.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.632]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.632]         }
[17:39:56.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.632]             base::sink(type = "output", split = FALSE)
[17:39:56.632]             base::close(...future.stdout)
[17:39:56.632]         }, add = TRUE)
[17:39:56.632]     }
[17:39:56.632]     ...future.frame <- base::sys.nframe()
[17:39:56.632]     ...future.conditions <- base::list()
[17:39:56.632]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.632]     if (FALSE) {
[17:39:56.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.632]     }
[17:39:56.632]     ...future.result <- base::tryCatch({
[17:39:56.632]         base::withCallingHandlers({
[17:39:56.632]             ...future.value <- base::withVisible(base::local({
[17:39:56.632]                 withCallingHandlers({
[17:39:56.632]                   value(a) + 1
[17:39:56.632]                 }, immediateCondition = function(cond) {
[17:39:56.632]                   save_rds <- function (object, pathname, ...) 
[17:39:56.632]                   {
[17:39:56.632]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.632]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.632]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.632]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.632]                         fi_tmp[["mtime"]])
[17:39:56.632]                     }
[17:39:56.632]                     tryCatch({
[17:39:56.632]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.632]                     }, error = function(ex) {
[17:39:56.632]                       msg <- conditionMessage(ex)
[17:39:56.632]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.632]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.632]                         fi_tmp[["mtime"]], msg)
[17:39:56.632]                       ex$message <- msg
[17:39:56.632]                       stop(ex)
[17:39:56.632]                     })
[17:39:56.632]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.632]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.632]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.632]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.632]                       fi <- file.info(pathname)
[17:39:56.632]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.632]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.632]                         fi[["size"]], fi[["mtime"]])
[17:39:56.632]                       stop(msg)
[17:39:56.632]                     }
[17:39:56.632]                     invisible(pathname)
[17:39:56.632]                   }
[17:39:56.632]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.632]                     rootPath = tempdir()) 
[17:39:56.632]                   {
[17:39:56.632]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.632]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.632]                       tmpdir = path, fileext = ".rds")
[17:39:56.632]                     save_rds(obj, file)
[17:39:56.632]                   }
[17:39:56.632]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.632]                   {
[17:39:56.632]                     inherits <- base::inherits
[17:39:56.632]                     invokeRestart <- base::invokeRestart
[17:39:56.632]                     is.null <- base::is.null
[17:39:56.632]                     muffled <- FALSE
[17:39:56.632]                     if (inherits(cond, "message")) {
[17:39:56.632]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.632]                       if (muffled) 
[17:39:56.632]                         invokeRestart("muffleMessage")
[17:39:56.632]                     }
[17:39:56.632]                     else if (inherits(cond, "warning")) {
[17:39:56.632]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.632]                       if (muffled) 
[17:39:56.632]                         invokeRestart("muffleWarning")
[17:39:56.632]                     }
[17:39:56.632]                     else if (inherits(cond, "condition")) {
[17:39:56.632]                       if (!is.null(pattern)) {
[17:39:56.632]                         computeRestarts <- base::computeRestarts
[17:39:56.632]                         grepl <- base::grepl
[17:39:56.632]                         restarts <- computeRestarts(cond)
[17:39:56.632]                         for (restart in restarts) {
[17:39:56.632]                           name <- restart$name
[17:39:56.632]                           if (is.null(name)) 
[17:39:56.632]                             next
[17:39:56.632]                           if (!grepl(pattern, name)) 
[17:39:56.632]                             next
[17:39:56.632]                           invokeRestart(restart)
[17:39:56.632]                           muffled <- TRUE
[17:39:56.632]                           break
[17:39:56.632]                         }
[17:39:56.632]                       }
[17:39:56.632]                     }
[17:39:56.632]                     invisible(muffled)
[17:39:56.632]                   }
[17:39:56.632]                   muffleCondition(cond)
[17:39:56.632]                 })
[17:39:56.632]             }))
[17:39:56.632]             future::FutureResult(value = ...future.value$value, 
[17:39:56.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.632]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.632]                     ...future.globalenv.names))
[17:39:56.632]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.632]         }, condition = base::local({
[17:39:56.632]             c <- base::c
[17:39:56.632]             inherits <- base::inherits
[17:39:56.632]             invokeRestart <- base::invokeRestart
[17:39:56.632]             length <- base::length
[17:39:56.632]             list <- base::list
[17:39:56.632]             seq.int <- base::seq.int
[17:39:56.632]             signalCondition <- base::signalCondition
[17:39:56.632]             sys.calls <- base::sys.calls
[17:39:56.632]             `[[` <- base::`[[`
[17:39:56.632]             `+` <- base::`+`
[17:39:56.632]             `<<-` <- base::`<<-`
[17:39:56.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.632]                   3L)]
[17:39:56.632]             }
[17:39:56.632]             function(cond) {
[17:39:56.632]                 is_error <- inherits(cond, "error")
[17:39:56.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.632]                   NULL)
[17:39:56.632]                 if (is_error) {
[17:39:56.632]                   sessionInformation <- function() {
[17:39:56.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.632]                       search = base::search(), system = base::Sys.info())
[17:39:56.632]                   }
[17:39:56.632]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.632]                     cond$call), session = sessionInformation(), 
[17:39:56.632]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.632]                   signalCondition(cond)
[17:39:56.632]                 }
[17:39:56.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.632]                 "immediateCondition"))) {
[17:39:56.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.632]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.632]                   if (TRUE && !signal) {
[17:39:56.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.632]                     {
[17:39:56.632]                       inherits <- base::inherits
[17:39:56.632]                       invokeRestart <- base::invokeRestart
[17:39:56.632]                       is.null <- base::is.null
[17:39:56.632]                       muffled <- FALSE
[17:39:56.632]                       if (inherits(cond, "message")) {
[17:39:56.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.632]                         if (muffled) 
[17:39:56.632]                           invokeRestart("muffleMessage")
[17:39:56.632]                       }
[17:39:56.632]                       else if (inherits(cond, "warning")) {
[17:39:56.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.632]                         if (muffled) 
[17:39:56.632]                           invokeRestart("muffleWarning")
[17:39:56.632]                       }
[17:39:56.632]                       else if (inherits(cond, "condition")) {
[17:39:56.632]                         if (!is.null(pattern)) {
[17:39:56.632]                           computeRestarts <- base::computeRestarts
[17:39:56.632]                           grepl <- base::grepl
[17:39:56.632]                           restarts <- computeRestarts(cond)
[17:39:56.632]                           for (restart in restarts) {
[17:39:56.632]                             name <- restart$name
[17:39:56.632]                             if (is.null(name)) 
[17:39:56.632]                               next
[17:39:56.632]                             if (!grepl(pattern, name)) 
[17:39:56.632]                               next
[17:39:56.632]                             invokeRestart(restart)
[17:39:56.632]                             muffled <- TRUE
[17:39:56.632]                             break
[17:39:56.632]                           }
[17:39:56.632]                         }
[17:39:56.632]                       }
[17:39:56.632]                       invisible(muffled)
[17:39:56.632]                     }
[17:39:56.632]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.632]                   }
[17:39:56.632]                 }
[17:39:56.632]                 else {
[17:39:56.632]                   if (TRUE) {
[17:39:56.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.632]                     {
[17:39:56.632]                       inherits <- base::inherits
[17:39:56.632]                       invokeRestart <- base::invokeRestart
[17:39:56.632]                       is.null <- base::is.null
[17:39:56.632]                       muffled <- FALSE
[17:39:56.632]                       if (inherits(cond, "message")) {
[17:39:56.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.632]                         if (muffled) 
[17:39:56.632]                           invokeRestart("muffleMessage")
[17:39:56.632]                       }
[17:39:56.632]                       else if (inherits(cond, "warning")) {
[17:39:56.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.632]                         if (muffled) 
[17:39:56.632]                           invokeRestart("muffleWarning")
[17:39:56.632]                       }
[17:39:56.632]                       else if (inherits(cond, "condition")) {
[17:39:56.632]                         if (!is.null(pattern)) {
[17:39:56.632]                           computeRestarts <- base::computeRestarts
[17:39:56.632]                           grepl <- base::grepl
[17:39:56.632]                           restarts <- computeRestarts(cond)
[17:39:56.632]                           for (restart in restarts) {
[17:39:56.632]                             name <- restart$name
[17:39:56.632]                             if (is.null(name)) 
[17:39:56.632]                               next
[17:39:56.632]                             if (!grepl(pattern, name)) 
[17:39:56.632]                               next
[17:39:56.632]                             invokeRestart(restart)
[17:39:56.632]                             muffled <- TRUE
[17:39:56.632]                             break
[17:39:56.632]                           }
[17:39:56.632]                         }
[17:39:56.632]                       }
[17:39:56.632]                       invisible(muffled)
[17:39:56.632]                     }
[17:39:56.632]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.632]                   }
[17:39:56.632]                 }
[17:39:56.632]             }
[17:39:56.632]         }))
[17:39:56.632]     }, error = function(ex) {
[17:39:56.632]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.632]                 ...future.rng), started = ...future.startTime, 
[17:39:56.632]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.632]             version = "1.8"), class = "FutureResult")
[17:39:56.632]     }, finally = {
[17:39:56.632]         if (!identical(...future.workdir, getwd())) 
[17:39:56.632]             setwd(...future.workdir)
[17:39:56.632]         {
[17:39:56.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.632]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.632]             }
[17:39:56.632]             base::options(...future.oldOptions)
[17:39:56.632]             if (.Platform$OS.type == "windows") {
[17:39:56.632]                 old_names <- names(...future.oldEnvVars)
[17:39:56.632]                 envs <- base::Sys.getenv()
[17:39:56.632]                 names <- names(envs)
[17:39:56.632]                 common <- intersect(names, old_names)
[17:39:56.632]                 added <- setdiff(names, old_names)
[17:39:56.632]                 removed <- setdiff(old_names, names)
[17:39:56.632]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.632]                   envs[common]]
[17:39:56.632]                 NAMES <- toupper(changed)
[17:39:56.632]                 args <- list()
[17:39:56.632]                 for (kk in seq_along(NAMES)) {
[17:39:56.632]                   name <- changed[[kk]]
[17:39:56.632]                   NAME <- NAMES[[kk]]
[17:39:56.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.632]                     next
[17:39:56.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.632]                 }
[17:39:56.632]                 NAMES <- toupper(added)
[17:39:56.632]                 for (kk in seq_along(NAMES)) {
[17:39:56.632]                   name <- added[[kk]]
[17:39:56.632]                   NAME <- NAMES[[kk]]
[17:39:56.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.632]                     next
[17:39:56.632]                   args[[name]] <- ""
[17:39:56.632]                 }
[17:39:56.632]                 NAMES <- toupper(removed)
[17:39:56.632]                 for (kk in seq_along(NAMES)) {
[17:39:56.632]                   name <- removed[[kk]]
[17:39:56.632]                   NAME <- NAMES[[kk]]
[17:39:56.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.632]                     next
[17:39:56.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.632]                 }
[17:39:56.632]                 if (length(args) > 0) 
[17:39:56.632]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.632]             }
[17:39:56.632]             else {
[17:39:56.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.632]             }
[17:39:56.632]             {
[17:39:56.632]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.632]                   0L) {
[17:39:56.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.632]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.632]                   base::options(opts)
[17:39:56.632]                 }
[17:39:56.632]                 {
[17:39:56.632]                   {
[17:39:56.632]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.632]                     NULL
[17:39:56.632]                   }
[17:39:56.632]                   options(future.plan = NULL)
[17:39:56.632]                   if (is.na(NA_character_)) 
[17:39:56.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.632]                     .init = FALSE)
[17:39:56.632]                 }
[17:39:56.632]             }
[17:39:56.632]         }
[17:39:56.632]     })
[17:39:56.632]     if (TRUE) {
[17:39:56.632]         base::sink(type = "output", split = FALSE)
[17:39:56.632]         if (TRUE) {
[17:39:56.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.632]         }
[17:39:56.632]         else {
[17:39:56.632]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.632]         }
[17:39:56.632]         base::close(...future.stdout)
[17:39:56.632]         ...future.stdout <- NULL
[17:39:56.632]     }
[17:39:56.632]     ...future.result$conditions <- ...future.conditions
[17:39:56.632]     ...future.result$finished <- base::Sys.time()
[17:39:56.632]     ...future.result
[17:39:56.632] }
[17:39:56.634] assign_globals() ...
[17:39:56.634] List of 1
[17:39:56.634]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd6b1b610> 
[17:39:56.634]  - attr(*, "where")=List of 1
[17:39:56.634]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.634]  - attr(*, "resolved")= logi TRUE
[17:39:56.634]  - attr(*, "total_size")= num 10984
[17:39:56.634]  - attr(*, "already-done")= logi TRUE
[17:39:56.637] - copied ‘a’ to environment
[17:39:56.637] assign_globals() ... done
[17:39:56.637] requestCore(): workers = 2
[17:39:56.639] MulticoreFuture started
[17:39:56.639] - Launch lazy future ... done
[17:39:56.640] run() for ‘MulticoreFuture’ ... done
[17:39:56.640] result() for MulticoreFuture ...
[17:39:56.640] plan(): Setting new future strategy stack:
[17:39:56.641] List of future strategies:
[17:39:56.641] 1. sequential:
[17:39:56.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.641]    - tweaked: FALSE
[17:39:56.641]    - call: NULL
[17:39:56.642] plan(): nbrOfWorkers() = 1
[17:39:56.645] plan(): Setting new future strategy stack:
[17:39:56.645] List of future strategies:
[17:39:56.645] 1. multicore:
[17:39:56.645]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.645]    - tweaked: FALSE
[17:39:56.645]    - call: plan(strategy)
[17:39:56.650] plan(): nbrOfWorkers() = 2
[17:39:56.651] result() for MulticoreFuture ...
[17:39:56.651] result() for MulticoreFuture ... done
[17:39:56.651] signalConditions() ...
[17:39:56.651]  - include = ‘immediateCondition’
[17:39:56.652]  - exclude = 
[17:39:56.652]  - resignal = FALSE
[17:39:56.652]  - Number of conditions: 4
[17:39:56.652] signalConditions() ... done
[17:39:56.652] result() for MulticoreFuture ... done
[17:39:56.652] result() for MulticoreFuture ...
[17:39:56.652] result() for MulticoreFuture ... done
[17:39:56.653] signalConditions() ...
[17:39:56.653]  - include = ‘immediateCondition’
[17:39:56.653]  - exclude = 
[17:39:56.653]  - resignal = FALSE
[17:39:56.653]  - Number of conditions: 4
[17:39:56.653] signalConditions() ... done
[17:39:56.653] Future state: ‘finished’
[17:39:56.653] result() for MulticoreFuture ...
[17:39:56.653] result() for MulticoreFuture ... done
[17:39:56.654] signalConditions() ...
[17:39:56.654]  - include = ‘condition’
[17:39:56.654]  - exclude = ‘immediateCondition’
[17:39:56.654]  - resignal = TRUE
[17:39:56.654]  - Number of conditions: 4
[17:39:56.654]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.643] result() for MulticoreFuture ...
[17:39:56.654]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.643] result() for MulticoreFuture ... done
[17:39:56.654]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.644] result() for MulticoreFuture ...
[17:39:56.655]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.644] result() for MulticoreFuture ... done
[17:39:56.655] signalConditions() ... done
value(b) = 2
[17:39:56.655] result() for MulticoreFuture ...
[17:39:56.655] result() for MulticoreFuture ... done
[17:39:56.655] result() for MulticoreFuture ...
[17:39:56.655] result() for MulticoreFuture ... done
[17:39:56.655] signalConditions() ...
[17:39:56.656]  - include = ‘immediateCondition’
[17:39:56.656]  - exclude = 
[17:39:56.656]  - resignal = FALSE
[17:39:56.656]  - Number of conditions: 4
[17:39:56.656] signalConditions() ... done
[17:39:56.656] Future state: ‘finished’
[17:39:56.656] result() for MulticoreFuture ...
[17:39:56.656] result() for MulticoreFuture ... done
[17:39:56.656] signalConditions() ...
[17:39:56.657]  - include = ‘condition’
[17:39:56.657]  - exclude = ‘immediateCondition’
[17:39:56.657]  - resignal = TRUE
[17:39:56.657]  - Number of conditions: 4
[17:39:56.657]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.643] result() for MulticoreFuture ...
[17:39:56.657]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.643] result() for MulticoreFuture ... done
[17:39:56.657]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.644] result() for MulticoreFuture ...
[17:39:56.657]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:56.644] result() for MulticoreFuture ... done
[17:39:56.658] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.658] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.658] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:56.659] - globals found: [2] ‘{’, ‘pkg’
[17:39:56.660] Searching for globals ... DONE
[17:39:56.660] Resolving globals: TRUE
[17:39:56.660] Resolving any globals that are futures ...
[17:39:56.660] - globals: [2] ‘{’, ‘pkg’
[17:39:56.660] Resolving any globals that are futures ... DONE
[17:39:56.661] Resolving futures part of globals (recursively) ...
[17:39:56.661] resolve() on list ...
[17:39:56.661]  recursive: 99
[17:39:56.661]  length: 1
[17:39:56.661]  elements: ‘pkg’
[17:39:56.661]  length: 0 (resolved future 1)
[17:39:56.661] resolve() on list ... DONE
[17:39:56.662] - globals: [1] ‘pkg’
[17:39:56.662] Resolving futures part of globals (recursively) ... DONE
[17:39:56.664] The total size of the 1 globals is 112 bytes (112 bytes)
[17:39:56.665] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:39:56.665] - globals: [1] ‘pkg’
[17:39:56.665] 
[17:39:56.665] getGlobalsAndPackages() ... DONE
[17:39:56.666] Packages needed by the future expression (n = 0): <none>
[17:39:56.666] Packages needed by future strategies (n = 0): <none>
[17:39:56.667] {
[17:39:56.667]     {
[17:39:56.667]         {
[17:39:56.667]             ...future.startTime <- base::Sys.time()
[17:39:56.667]             {
[17:39:56.667]                 {
[17:39:56.667]                   {
[17:39:56.667]                     base::local({
[17:39:56.667]                       has_future <- base::requireNamespace("future", 
[17:39:56.667]                         quietly = TRUE)
[17:39:56.667]                       if (has_future) {
[17:39:56.667]                         ns <- base::getNamespace("future")
[17:39:56.667]                         version <- ns[[".package"]][["version"]]
[17:39:56.667]                         if (is.null(version)) 
[17:39:56.667]                           version <- utils::packageVersion("future")
[17:39:56.667]                       }
[17:39:56.667]                       else {
[17:39:56.667]                         version <- NULL
[17:39:56.667]                       }
[17:39:56.667]                       if (!has_future || version < "1.8.0") {
[17:39:56.667]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.667]                           "", base::R.version$version.string), 
[17:39:56.667]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:56.667]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.667]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.667]                             "release", "version")], collapse = " "), 
[17:39:56.667]                           hostname = base::Sys.info()[["nodename"]])
[17:39:56.667]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.667]                           info)
[17:39:56.667]                         info <- base::paste(info, collapse = "; ")
[17:39:56.667]                         if (!has_future) {
[17:39:56.667]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.667]                             info)
[17:39:56.667]                         }
[17:39:56.667]                         else {
[17:39:56.667]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.667]                             info, version)
[17:39:56.667]                         }
[17:39:56.667]                         base::stop(msg)
[17:39:56.667]                       }
[17:39:56.667]                     })
[17:39:56.667]                   }
[17:39:56.667]                   ...future.strategy.old <- future::plan("list")
[17:39:56.667]                   options(future.plan = NULL)
[17:39:56.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.667]                 }
[17:39:56.667]                 ...future.workdir <- getwd()
[17:39:56.667]             }
[17:39:56.667]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.667]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.667]         }
[17:39:56.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.667]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:56.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.667]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.667]             base::names(...future.oldOptions))
[17:39:56.667]     }
[17:39:56.667]     if (FALSE) {
[17:39:56.667]     }
[17:39:56.667]     else {
[17:39:56.667]         if (TRUE) {
[17:39:56.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.667]                 open = "w")
[17:39:56.667]         }
[17:39:56.667]         else {
[17:39:56.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.667]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.667]         }
[17:39:56.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.667]             base::sink(type = "output", split = FALSE)
[17:39:56.667]             base::close(...future.stdout)
[17:39:56.667]         }, add = TRUE)
[17:39:56.667]     }
[17:39:56.667]     ...future.frame <- base::sys.nframe()
[17:39:56.667]     ...future.conditions <- base::list()
[17:39:56.667]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.667]     if (FALSE) {
[17:39:56.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.667]     }
[17:39:56.667]     ...future.result <- base::tryCatch({
[17:39:56.667]         base::withCallingHandlers({
[17:39:56.667]             ...future.value <- base::withVisible(base::local({
[17:39:56.667]                 pkg
[17:39:56.667]             }))
[17:39:56.667]             future::FutureResult(value = ...future.value$value, 
[17:39:56.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.667]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.667]                     ...future.globalenv.names))
[17:39:56.667]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.667]         }, condition = base::local({
[17:39:56.667]             c <- base::c
[17:39:56.667]             inherits <- base::inherits
[17:39:56.667]             invokeRestart <- base::invokeRestart
[17:39:56.667]             length <- base::length
[17:39:56.667]             list <- base::list
[17:39:56.667]             seq.int <- base::seq.int
[17:39:56.667]             signalCondition <- base::signalCondition
[17:39:56.667]             sys.calls <- base::sys.calls
[17:39:56.667]             `[[` <- base::`[[`
[17:39:56.667]             `+` <- base::`+`
[17:39:56.667]             `<<-` <- base::`<<-`
[17:39:56.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.667]                   3L)]
[17:39:56.667]             }
[17:39:56.667]             function(cond) {
[17:39:56.667]                 is_error <- inherits(cond, "error")
[17:39:56.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.667]                   NULL)
[17:39:56.667]                 if (is_error) {
[17:39:56.667]                   sessionInformation <- function() {
[17:39:56.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.667]                       search = base::search(), system = base::Sys.info())
[17:39:56.667]                   }
[17:39:56.667]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.667]                     cond$call), session = sessionInformation(), 
[17:39:56.667]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.667]                   signalCondition(cond)
[17:39:56.667]                 }
[17:39:56.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.667]                 "immediateCondition"))) {
[17:39:56.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.667]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.667]                   if (TRUE && !signal) {
[17:39:56.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.667]                     {
[17:39:56.667]                       inherits <- base::inherits
[17:39:56.667]                       invokeRestart <- base::invokeRestart
[17:39:56.667]                       is.null <- base::is.null
[17:39:56.667]                       muffled <- FALSE
[17:39:56.667]                       if (inherits(cond, "message")) {
[17:39:56.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.667]                         if (muffled) 
[17:39:56.667]                           invokeRestart("muffleMessage")
[17:39:56.667]                       }
[17:39:56.667]                       else if (inherits(cond, "warning")) {
[17:39:56.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.667]                         if (muffled) 
[17:39:56.667]                           invokeRestart("muffleWarning")
[17:39:56.667]                       }
[17:39:56.667]                       else if (inherits(cond, "condition")) {
[17:39:56.667]                         if (!is.null(pattern)) {
[17:39:56.667]                           computeRestarts <- base::computeRestarts
[17:39:56.667]                           grepl <- base::grepl
[17:39:56.667]                           restarts <- computeRestarts(cond)
[17:39:56.667]                           for (restart in restarts) {
[17:39:56.667]                             name <- restart$name
[17:39:56.667]                             if (is.null(name)) 
[17:39:56.667]                               next
[17:39:56.667]                             if (!grepl(pattern, name)) 
[17:39:56.667]                               next
[17:39:56.667]                             invokeRestart(restart)
[17:39:56.667]                             muffled <- TRUE
[17:39:56.667]                             break
[17:39:56.667]                           }
[17:39:56.667]                         }
[17:39:56.667]                       }
[17:39:56.667]                       invisible(muffled)
[17:39:56.667]                     }
[17:39:56.667]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.667]                   }
[17:39:56.667]                 }
[17:39:56.667]                 else {
[17:39:56.667]                   if (TRUE) {
[17:39:56.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.667]                     {
[17:39:56.667]                       inherits <- base::inherits
[17:39:56.667]                       invokeRestart <- base::invokeRestart
[17:39:56.667]                       is.null <- base::is.null
[17:39:56.667]                       muffled <- FALSE
[17:39:56.667]                       if (inherits(cond, "message")) {
[17:39:56.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.667]                         if (muffled) 
[17:39:56.667]                           invokeRestart("muffleMessage")
[17:39:56.667]                       }
[17:39:56.667]                       else if (inherits(cond, "warning")) {
[17:39:56.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.667]                         if (muffled) 
[17:39:56.667]                           invokeRestart("muffleWarning")
[17:39:56.667]                       }
[17:39:56.667]                       else if (inherits(cond, "condition")) {
[17:39:56.667]                         if (!is.null(pattern)) {
[17:39:56.667]                           computeRestarts <- base::computeRestarts
[17:39:56.667]                           grepl <- base::grepl
[17:39:56.667]                           restarts <- computeRestarts(cond)
[17:39:56.667]                           for (restart in restarts) {
[17:39:56.667]                             name <- restart$name
[17:39:56.667]                             if (is.null(name)) 
[17:39:56.667]                               next
[17:39:56.667]                             if (!grepl(pattern, name)) 
[17:39:56.667]                               next
[17:39:56.667]                             invokeRestart(restart)
[17:39:56.667]                             muffled <- TRUE
[17:39:56.667]                             break
[17:39:56.667]                           }
[17:39:56.667]                         }
[17:39:56.667]                       }
[17:39:56.667]                       invisible(muffled)
[17:39:56.667]                     }
[17:39:56.667]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.667]                   }
[17:39:56.667]                 }
[17:39:56.667]             }
[17:39:56.667]         }))
[17:39:56.667]     }, error = function(ex) {
[17:39:56.667]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.667]                 ...future.rng), started = ...future.startTime, 
[17:39:56.667]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.667]             version = "1.8"), class = "FutureResult")
[17:39:56.667]     }, finally = {
[17:39:56.667]         if (!identical(...future.workdir, getwd())) 
[17:39:56.667]             setwd(...future.workdir)
[17:39:56.667]         {
[17:39:56.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.667]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.667]             }
[17:39:56.667]             base::options(...future.oldOptions)
[17:39:56.667]             if (.Platform$OS.type == "windows") {
[17:39:56.667]                 old_names <- names(...future.oldEnvVars)
[17:39:56.667]                 envs <- base::Sys.getenv()
[17:39:56.667]                 names <- names(envs)
[17:39:56.667]                 common <- intersect(names, old_names)
[17:39:56.667]                 added <- setdiff(names, old_names)
[17:39:56.667]                 removed <- setdiff(old_names, names)
[17:39:56.667]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.667]                   envs[common]]
[17:39:56.667]                 NAMES <- toupper(changed)
[17:39:56.667]                 args <- list()
[17:39:56.667]                 for (kk in seq_along(NAMES)) {
[17:39:56.667]                   name <- changed[[kk]]
[17:39:56.667]                   NAME <- NAMES[[kk]]
[17:39:56.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.667]                     next
[17:39:56.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.667]                 }
[17:39:56.667]                 NAMES <- toupper(added)
[17:39:56.667]                 for (kk in seq_along(NAMES)) {
[17:39:56.667]                   name <- added[[kk]]
[17:39:56.667]                   NAME <- NAMES[[kk]]
[17:39:56.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.667]                     next
[17:39:56.667]                   args[[name]] <- ""
[17:39:56.667]                 }
[17:39:56.667]                 NAMES <- toupper(removed)
[17:39:56.667]                 for (kk in seq_along(NAMES)) {
[17:39:56.667]                   name <- removed[[kk]]
[17:39:56.667]                   NAME <- NAMES[[kk]]
[17:39:56.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.667]                     next
[17:39:56.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.667]                 }
[17:39:56.667]                 if (length(args) > 0) 
[17:39:56.667]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.667]             }
[17:39:56.667]             else {
[17:39:56.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.667]             }
[17:39:56.667]             {
[17:39:56.667]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.667]                   0L) {
[17:39:56.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.667]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.667]                   base::options(opts)
[17:39:56.667]                 }
[17:39:56.667]                 {
[17:39:56.667]                   {
[17:39:56.667]                     NULL
[17:39:56.667]                     RNGkind("Mersenne-Twister")
[17:39:56.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:56.667]                       inherits = FALSE)
[17:39:56.667]                   }
[17:39:56.667]                   options(future.plan = NULL)
[17:39:56.667]                   if (is.na(NA_character_)) 
[17:39:56.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.667]                     .init = FALSE)
[17:39:56.667]                 }
[17:39:56.667]             }
[17:39:56.667]         }
[17:39:56.667]     })
[17:39:56.667]     if (TRUE) {
[17:39:56.667]         base::sink(type = "output", split = FALSE)
[17:39:56.667]         if (TRUE) {
[17:39:56.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.667]         }
[17:39:56.667]         else {
[17:39:56.667]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.667]         }
[17:39:56.667]         base::close(...future.stdout)
[17:39:56.667]         ...future.stdout <- NULL
[17:39:56.667]     }
[17:39:56.667]     ...future.result$conditions <- ...future.conditions
[17:39:56.667]     ...future.result$finished <- base::Sys.time()
[17:39:56.667]     ...future.result
[17:39:56.667] }
[17:39:56.668] assign_globals() ...
[17:39:56.669] List of 1
[17:39:56.669]  $ pkg: chr "foo"
[17:39:56.669]  - attr(*, "where")=List of 1
[17:39:56.669]   ..$ pkg:<environment: R_EmptyEnv> 
[17:39:56.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.669]  - attr(*, "resolved")= logi TRUE
[17:39:56.669]  - attr(*, "total_size")= num 112
[17:39:56.671] - copied ‘pkg’ to environment
[17:39:56.671] assign_globals() ... done
[17:39:56.672] plan(): Setting new future strategy stack:
[17:39:56.672] List of future strategies:
[17:39:56.672] 1. sequential:
[17:39:56.672]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.672]    - tweaked: FALSE
[17:39:56.672]    - call: NULL
[17:39:56.672] plan(): nbrOfWorkers() = 1
[17:39:56.673] plan(): Setting new future strategy stack:
[17:39:56.673] List of future strategies:
[17:39:56.673] 1. multicore:
[17:39:56.673]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.673]    - tweaked: FALSE
[17:39:56.673]    - call: plan(strategy)
[17:39:56.677] plan(): nbrOfWorkers() = 2
[17:39:56.677] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.678] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.678] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.680] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:56.680] Searching for globals ... DONE
[17:39:56.680] Resolving globals: TRUE
[17:39:56.681] Resolving any globals that are futures ...
[17:39:56.681] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:56.681] Resolving any globals that are futures ... DONE
[17:39:56.681] Resolving futures part of globals (recursively) ...
[17:39:56.681] resolve() on list ...
[17:39:56.681]  recursive: 99
[17:39:56.681]  length: 1
[17:39:56.682]  elements: ‘a’
[17:39:56.682]  length: 0 (resolved future 1)
[17:39:56.682] resolve() on list ... DONE
[17:39:56.682] - globals: [1] ‘a’
[17:39:56.682] Resolving futures part of globals (recursively) ... DONE
[17:39:56.682] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.682] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:39:56.682] - globals: [1] ‘a’
[17:39:56.683] 
[17:39:56.683] getGlobalsAndPackages() ... DONE
[17:39:56.683] run() for ‘Future’ ...
[17:39:56.683] - state: ‘created’
[17:39:56.683] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.686] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.687]   - Field: ‘label’
[17:39:56.687]   - Field: ‘local’
[17:39:56.687]   - Field: ‘owner’
[17:39:56.687]   - Field: ‘envir’
[17:39:56.687]   - Field: ‘workers’
[17:39:56.687]   - Field: ‘packages’
[17:39:56.687]   - Field: ‘gc’
[17:39:56.687]   - Field: ‘job’
[17:39:56.687]   - Field: ‘conditions’
[17:39:56.687]   - Field: ‘expr’
[17:39:56.688]   - Field: ‘uuid’
[17:39:56.688]   - Field: ‘seed’
[17:39:56.688]   - Field: ‘version’
[17:39:56.688]   - Field: ‘result’
[17:39:56.688]   - Field: ‘asynchronous’
[17:39:56.688]   - Field: ‘calls’
[17:39:56.688]   - Field: ‘globals’
[17:39:56.688]   - Field: ‘stdout’
[17:39:56.688]   - Field: ‘earlySignal’
[17:39:56.688]   - Field: ‘lazy’
[17:39:56.688]   - Field: ‘state’
[17:39:56.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.689] - Launch lazy future ...
[17:39:56.689] Packages needed by the future expression (n = 0): <none>
[17:39:56.689] Packages needed by future strategies (n = 0): <none>
[17:39:56.689] {
[17:39:56.689]     {
[17:39:56.689]         {
[17:39:56.689]             ...future.startTime <- base::Sys.time()
[17:39:56.689]             {
[17:39:56.689]                 {
[17:39:56.689]                   {
[17:39:56.689]                     {
[17:39:56.689]                       base::local({
[17:39:56.689]                         has_future <- base::requireNamespace("future", 
[17:39:56.689]                           quietly = TRUE)
[17:39:56.689]                         if (has_future) {
[17:39:56.689]                           ns <- base::getNamespace("future")
[17:39:56.689]                           version <- ns[[".package"]][["version"]]
[17:39:56.689]                           if (is.null(version)) 
[17:39:56.689]                             version <- utils::packageVersion("future")
[17:39:56.689]                         }
[17:39:56.689]                         else {
[17:39:56.689]                           version <- NULL
[17:39:56.689]                         }
[17:39:56.689]                         if (!has_future || version < "1.8.0") {
[17:39:56.689]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.689]                             "", base::R.version$version.string), 
[17:39:56.689]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.689]                               "release", "version")], collapse = " "), 
[17:39:56.689]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.689]                             info)
[17:39:56.689]                           info <- base::paste(info, collapse = "; ")
[17:39:56.689]                           if (!has_future) {
[17:39:56.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.689]                               info)
[17:39:56.689]                           }
[17:39:56.689]                           else {
[17:39:56.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.689]                               info, version)
[17:39:56.689]                           }
[17:39:56.689]                           base::stop(msg)
[17:39:56.689]                         }
[17:39:56.689]                       })
[17:39:56.689]                     }
[17:39:56.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.689]                     base::options(mc.cores = 1L)
[17:39:56.689]                   }
[17:39:56.689]                   ...future.strategy.old <- future::plan("list")
[17:39:56.689]                   options(future.plan = NULL)
[17:39:56.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.689]                 }
[17:39:56.689]                 ...future.workdir <- getwd()
[17:39:56.689]             }
[17:39:56.689]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.689]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.689]         }
[17:39:56.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.689]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.689]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.689]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.689]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.689]             base::names(...future.oldOptions))
[17:39:56.689]     }
[17:39:56.689]     if (FALSE) {
[17:39:56.689]     }
[17:39:56.689]     else {
[17:39:56.689]         if (TRUE) {
[17:39:56.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.689]                 open = "w")
[17:39:56.689]         }
[17:39:56.689]         else {
[17:39:56.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.689]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.689]         }
[17:39:56.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.689]             base::sink(type = "output", split = FALSE)
[17:39:56.689]             base::close(...future.stdout)
[17:39:56.689]         }, add = TRUE)
[17:39:56.689]     }
[17:39:56.689]     ...future.frame <- base::sys.nframe()
[17:39:56.689]     ...future.conditions <- base::list()
[17:39:56.689]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.689]     if (FALSE) {
[17:39:56.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.689]     }
[17:39:56.689]     ...future.result <- base::tryCatch({
[17:39:56.689]         base::withCallingHandlers({
[17:39:56.689]             ...future.value <- base::withVisible(base::local({
[17:39:56.689]                 withCallingHandlers({
[17:39:56.689]                   {
[17:39:56.689]                     b <- a
[17:39:56.689]                     a <- 2
[17:39:56.689]                     a * b
[17:39:56.689]                   }
[17:39:56.689]                 }, immediateCondition = function(cond) {
[17:39:56.689]                   save_rds <- function (object, pathname, ...) 
[17:39:56.689]                   {
[17:39:56.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.689]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.689]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.689]                         fi_tmp[["mtime"]])
[17:39:56.689]                     }
[17:39:56.689]                     tryCatch({
[17:39:56.689]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.689]                     }, error = function(ex) {
[17:39:56.689]                       msg <- conditionMessage(ex)
[17:39:56.689]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.689]                         fi_tmp[["mtime"]], msg)
[17:39:56.689]                       ex$message <- msg
[17:39:56.689]                       stop(ex)
[17:39:56.689]                     })
[17:39:56.689]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.689]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.689]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.689]                       fi <- file.info(pathname)
[17:39:56.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.689]                         fi[["size"]], fi[["mtime"]])
[17:39:56.689]                       stop(msg)
[17:39:56.689]                     }
[17:39:56.689]                     invisible(pathname)
[17:39:56.689]                   }
[17:39:56.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.689]                     rootPath = tempdir()) 
[17:39:56.689]                   {
[17:39:56.689]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.689]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.689]                       tmpdir = path, fileext = ".rds")
[17:39:56.689]                     save_rds(obj, file)
[17:39:56.689]                   }
[17:39:56.689]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.689]                   {
[17:39:56.689]                     inherits <- base::inherits
[17:39:56.689]                     invokeRestart <- base::invokeRestart
[17:39:56.689]                     is.null <- base::is.null
[17:39:56.689]                     muffled <- FALSE
[17:39:56.689]                     if (inherits(cond, "message")) {
[17:39:56.689]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.689]                       if (muffled) 
[17:39:56.689]                         invokeRestart("muffleMessage")
[17:39:56.689]                     }
[17:39:56.689]                     else if (inherits(cond, "warning")) {
[17:39:56.689]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.689]                       if (muffled) 
[17:39:56.689]                         invokeRestart("muffleWarning")
[17:39:56.689]                     }
[17:39:56.689]                     else if (inherits(cond, "condition")) {
[17:39:56.689]                       if (!is.null(pattern)) {
[17:39:56.689]                         computeRestarts <- base::computeRestarts
[17:39:56.689]                         grepl <- base::grepl
[17:39:56.689]                         restarts <- computeRestarts(cond)
[17:39:56.689]                         for (restart in restarts) {
[17:39:56.689]                           name <- restart$name
[17:39:56.689]                           if (is.null(name)) 
[17:39:56.689]                             next
[17:39:56.689]                           if (!grepl(pattern, name)) 
[17:39:56.689]                             next
[17:39:56.689]                           invokeRestart(restart)
[17:39:56.689]                           muffled <- TRUE
[17:39:56.689]                           break
[17:39:56.689]                         }
[17:39:56.689]                       }
[17:39:56.689]                     }
[17:39:56.689]                     invisible(muffled)
[17:39:56.689]                   }
[17:39:56.689]                   muffleCondition(cond)
[17:39:56.689]                 })
[17:39:56.689]             }))
[17:39:56.689]             future::FutureResult(value = ...future.value$value, 
[17:39:56.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.689]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.689]                     ...future.globalenv.names))
[17:39:56.689]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.689]         }, condition = base::local({
[17:39:56.689]             c <- base::c
[17:39:56.689]             inherits <- base::inherits
[17:39:56.689]             invokeRestart <- base::invokeRestart
[17:39:56.689]             length <- base::length
[17:39:56.689]             list <- base::list
[17:39:56.689]             seq.int <- base::seq.int
[17:39:56.689]             signalCondition <- base::signalCondition
[17:39:56.689]             sys.calls <- base::sys.calls
[17:39:56.689]             `[[` <- base::`[[`
[17:39:56.689]             `+` <- base::`+`
[17:39:56.689]             `<<-` <- base::`<<-`
[17:39:56.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.689]                   3L)]
[17:39:56.689]             }
[17:39:56.689]             function(cond) {
[17:39:56.689]                 is_error <- inherits(cond, "error")
[17:39:56.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.689]                   NULL)
[17:39:56.689]                 if (is_error) {
[17:39:56.689]                   sessionInformation <- function() {
[17:39:56.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.689]                       search = base::search(), system = base::Sys.info())
[17:39:56.689]                   }
[17:39:56.689]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.689]                     cond$call), session = sessionInformation(), 
[17:39:56.689]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.689]                   signalCondition(cond)
[17:39:56.689]                 }
[17:39:56.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.689]                 "immediateCondition"))) {
[17:39:56.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.689]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.689]                   if (TRUE && !signal) {
[17:39:56.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.689]                     {
[17:39:56.689]                       inherits <- base::inherits
[17:39:56.689]                       invokeRestart <- base::invokeRestart
[17:39:56.689]                       is.null <- base::is.null
[17:39:56.689]                       muffled <- FALSE
[17:39:56.689]                       if (inherits(cond, "message")) {
[17:39:56.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.689]                         if (muffled) 
[17:39:56.689]                           invokeRestart("muffleMessage")
[17:39:56.689]                       }
[17:39:56.689]                       else if (inherits(cond, "warning")) {
[17:39:56.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.689]                         if (muffled) 
[17:39:56.689]                           invokeRestart("muffleWarning")
[17:39:56.689]                       }
[17:39:56.689]                       else if (inherits(cond, "condition")) {
[17:39:56.689]                         if (!is.null(pattern)) {
[17:39:56.689]                           computeRestarts <- base::computeRestarts
[17:39:56.689]                           grepl <- base::grepl
[17:39:56.689]                           restarts <- computeRestarts(cond)
[17:39:56.689]                           for (restart in restarts) {
[17:39:56.689]                             name <- restart$name
[17:39:56.689]                             if (is.null(name)) 
[17:39:56.689]                               next
[17:39:56.689]                             if (!grepl(pattern, name)) 
[17:39:56.689]                               next
[17:39:56.689]                             invokeRestart(restart)
[17:39:56.689]                             muffled <- TRUE
[17:39:56.689]                             break
[17:39:56.689]                           }
[17:39:56.689]                         }
[17:39:56.689]                       }
[17:39:56.689]                       invisible(muffled)
[17:39:56.689]                     }
[17:39:56.689]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.689]                   }
[17:39:56.689]                 }
[17:39:56.689]                 else {
[17:39:56.689]                   if (TRUE) {
[17:39:56.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.689]                     {
[17:39:56.689]                       inherits <- base::inherits
[17:39:56.689]                       invokeRestart <- base::invokeRestart
[17:39:56.689]                       is.null <- base::is.null
[17:39:56.689]                       muffled <- FALSE
[17:39:56.689]                       if (inherits(cond, "message")) {
[17:39:56.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.689]                         if (muffled) 
[17:39:56.689]                           invokeRestart("muffleMessage")
[17:39:56.689]                       }
[17:39:56.689]                       else if (inherits(cond, "warning")) {
[17:39:56.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.689]                         if (muffled) 
[17:39:56.689]                           invokeRestart("muffleWarning")
[17:39:56.689]                       }
[17:39:56.689]                       else if (inherits(cond, "condition")) {
[17:39:56.689]                         if (!is.null(pattern)) {
[17:39:56.689]                           computeRestarts <- base::computeRestarts
[17:39:56.689]                           grepl <- base::grepl
[17:39:56.689]                           restarts <- computeRestarts(cond)
[17:39:56.689]                           for (restart in restarts) {
[17:39:56.689]                             name <- restart$name
[17:39:56.689]                             if (is.null(name)) 
[17:39:56.689]                               next
[17:39:56.689]                             if (!grepl(pattern, name)) 
[17:39:56.689]                               next
[17:39:56.689]                             invokeRestart(restart)
[17:39:56.689]                             muffled <- TRUE
[17:39:56.689]                             break
[17:39:56.689]                           }
[17:39:56.689]                         }
[17:39:56.689]                       }
[17:39:56.689]                       invisible(muffled)
[17:39:56.689]                     }
[17:39:56.689]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.689]                   }
[17:39:56.689]                 }
[17:39:56.689]             }
[17:39:56.689]         }))
[17:39:56.689]     }, error = function(ex) {
[17:39:56.689]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.689]                 ...future.rng), started = ...future.startTime, 
[17:39:56.689]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.689]             version = "1.8"), class = "FutureResult")
[17:39:56.689]     }, finally = {
[17:39:56.689]         if (!identical(...future.workdir, getwd())) 
[17:39:56.689]             setwd(...future.workdir)
[17:39:56.689]         {
[17:39:56.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.689]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.689]             }
[17:39:56.689]             base::options(...future.oldOptions)
[17:39:56.689]             if (.Platform$OS.type == "windows") {
[17:39:56.689]                 old_names <- names(...future.oldEnvVars)
[17:39:56.689]                 envs <- base::Sys.getenv()
[17:39:56.689]                 names <- names(envs)
[17:39:56.689]                 common <- intersect(names, old_names)
[17:39:56.689]                 added <- setdiff(names, old_names)
[17:39:56.689]                 removed <- setdiff(old_names, names)
[17:39:56.689]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.689]                   envs[common]]
[17:39:56.689]                 NAMES <- toupper(changed)
[17:39:56.689]                 args <- list()
[17:39:56.689]                 for (kk in seq_along(NAMES)) {
[17:39:56.689]                   name <- changed[[kk]]
[17:39:56.689]                   NAME <- NAMES[[kk]]
[17:39:56.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.689]                     next
[17:39:56.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.689]                 }
[17:39:56.689]                 NAMES <- toupper(added)
[17:39:56.689]                 for (kk in seq_along(NAMES)) {
[17:39:56.689]                   name <- added[[kk]]
[17:39:56.689]                   NAME <- NAMES[[kk]]
[17:39:56.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.689]                     next
[17:39:56.689]                   args[[name]] <- ""
[17:39:56.689]                 }
[17:39:56.689]                 NAMES <- toupper(removed)
[17:39:56.689]                 for (kk in seq_along(NAMES)) {
[17:39:56.689]                   name <- removed[[kk]]
[17:39:56.689]                   NAME <- NAMES[[kk]]
[17:39:56.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.689]                     next
[17:39:56.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.689]                 }
[17:39:56.689]                 if (length(args) > 0) 
[17:39:56.689]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.689]             }
[17:39:56.689]             else {
[17:39:56.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.689]             }
[17:39:56.689]             {
[17:39:56.689]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.689]                   0L) {
[17:39:56.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.689]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.689]                   base::options(opts)
[17:39:56.689]                 }
[17:39:56.689]                 {
[17:39:56.689]                   {
[17:39:56.689]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.689]                     NULL
[17:39:56.689]                   }
[17:39:56.689]                   options(future.plan = NULL)
[17:39:56.689]                   if (is.na(NA_character_)) 
[17:39:56.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.689]                     .init = FALSE)
[17:39:56.689]                 }
[17:39:56.689]             }
[17:39:56.689]         }
[17:39:56.689]     })
[17:39:56.689]     if (TRUE) {
[17:39:56.689]         base::sink(type = "output", split = FALSE)
[17:39:56.689]         if (TRUE) {
[17:39:56.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.689]         }
[17:39:56.689]         else {
[17:39:56.689]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.689]         }
[17:39:56.689]         base::close(...future.stdout)
[17:39:56.689]         ...future.stdout <- NULL
[17:39:56.689]     }
[17:39:56.689]     ...future.result$conditions <- ...future.conditions
[17:39:56.689]     ...future.result$finished <- base::Sys.time()
[17:39:56.689]     ...future.result
[17:39:56.689] }
[17:39:56.692] assign_globals() ...
[17:39:56.692] List of 1
[17:39:56.692]  $ a: num 3
[17:39:56.692]  - attr(*, "where")=List of 1
[17:39:56.692]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.692]  - attr(*, "resolved")= logi TRUE
[17:39:56.692]  - attr(*, "total_size")= num 56
[17:39:56.692]  - attr(*, "already-done")= logi TRUE
[17:39:56.695] - copied ‘a’ to environment
[17:39:56.695] assign_globals() ... done
[17:39:56.696] requestCore(): workers = 2
[17:39:56.697] MulticoreFuture started
[17:39:56.698] - Launch lazy future ... done
[17:39:56.698] run() for ‘MulticoreFuture’ ... done
[17:39:56.698] plan(): Setting new future strategy stack:
[17:39:56.699] result() for MulticoreFuture ...
[17:39:56.699] List of future strategies:
[17:39:56.699] 1. sequential:
[17:39:56.699]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.699]    - tweaked: FALSE
[17:39:56.699]    - call: NULL
[17:39:56.700] plan(): nbrOfWorkers() = 1
[17:39:56.702] plan(): Setting new future strategy stack:
[17:39:56.703] List of future strategies:
[17:39:56.703] 1. multicore:
[17:39:56.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.703]    - tweaked: FALSE
[17:39:56.703]    - call: plan(strategy)
[17:39:56.708] plan(): nbrOfWorkers() = 2
[17:39:56.709] result() for MulticoreFuture ...
[17:39:56.709] result() for MulticoreFuture ... done
[17:39:56.709] result() for MulticoreFuture ... done
[17:39:56.710] result() for MulticoreFuture ...
[17:39:56.710] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.711] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.711] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.713] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:56.714] Searching for globals ... DONE
[17:39:56.714] Resolving globals: TRUE
[17:39:56.714] Resolving any globals that are futures ...
[17:39:56.714] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:56.714] Resolving any globals that are futures ... DONE
[17:39:56.715] Resolving futures part of globals (recursively) ...
[17:39:56.715] resolve() on list ...
[17:39:56.715]  recursive: 99
[17:39:56.715]  length: 1
[17:39:56.715]  elements: ‘a’
[17:39:56.715]  length: 0 (resolved future 1)
[17:39:56.715] resolve() on list ... DONE
[17:39:56.716] - globals: [1] ‘a’
[17:39:56.716] Resolving futures part of globals (recursively) ... DONE
[17:39:56.716] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:56.716] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:39:56.716] - globals: [1] ‘a’
[17:39:56.717] 
[17:39:56.717] getGlobalsAndPackages() ... DONE
[17:39:56.717] run() for ‘Future’ ...
[17:39:56.717] - state: ‘created’
[17:39:56.717] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.721]   - Field: ‘label’
[17:39:56.722]   - Field: ‘local’
[17:39:56.722]   - Field: ‘owner’
[17:39:56.722]   - Field: ‘envir’
[17:39:56.722]   - Field: ‘workers’
[17:39:56.722]   - Field: ‘packages’
[17:39:56.722]   - Field: ‘gc’
[17:39:56.722]   - Field: ‘job’
[17:39:56.722]   - Field: ‘conditions’
[17:39:56.722]   - Field: ‘expr’
[17:39:56.723]   - Field: ‘uuid’
[17:39:56.723]   - Field: ‘seed’
[17:39:56.723]   - Field: ‘version’
[17:39:56.723]   - Field: ‘result’
[17:39:56.723]   - Field: ‘asynchronous’
[17:39:56.723]   - Field: ‘calls’
[17:39:56.723]   - Field: ‘globals’
[17:39:56.723]   - Field: ‘stdout’
[17:39:56.723]   - Field: ‘earlySignal’
[17:39:56.724]   - Field: ‘lazy’
[17:39:56.724]   - Field: ‘state’
[17:39:56.724] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.724] - Launch lazy future ...
[17:39:56.724] Packages needed by the future expression (n = 0): <none>
[17:39:56.724] Packages needed by future strategies (n = 0): <none>
[17:39:56.725] {
[17:39:56.725]     {
[17:39:56.725]         {
[17:39:56.725]             ...future.startTime <- base::Sys.time()
[17:39:56.725]             {
[17:39:56.725]                 {
[17:39:56.725]                   {
[17:39:56.725]                     {
[17:39:56.725]                       base::local({
[17:39:56.725]                         has_future <- base::requireNamespace("future", 
[17:39:56.725]                           quietly = TRUE)
[17:39:56.725]                         if (has_future) {
[17:39:56.725]                           ns <- base::getNamespace("future")
[17:39:56.725]                           version <- ns[[".package"]][["version"]]
[17:39:56.725]                           if (is.null(version)) 
[17:39:56.725]                             version <- utils::packageVersion("future")
[17:39:56.725]                         }
[17:39:56.725]                         else {
[17:39:56.725]                           version <- NULL
[17:39:56.725]                         }
[17:39:56.725]                         if (!has_future || version < "1.8.0") {
[17:39:56.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.725]                             "", base::R.version$version.string), 
[17:39:56.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.725]                               "release", "version")], collapse = " "), 
[17:39:56.725]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.725]                             info)
[17:39:56.725]                           info <- base::paste(info, collapse = "; ")
[17:39:56.725]                           if (!has_future) {
[17:39:56.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.725]                               info)
[17:39:56.725]                           }
[17:39:56.725]                           else {
[17:39:56.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.725]                               info, version)
[17:39:56.725]                           }
[17:39:56.725]                           base::stop(msg)
[17:39:56.725]                         }
[17:39:56.725]                       })
[17:39:56.725]                     }
[17:39:56.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.725]                     base::options(mc.cores = 1L)
[17:39:56.725]                   }
[17:39:56.725]                   ...future.strategy.old <- future::plan("list")
[17:39:56.725]                   options(future.plan = NULL)
[17:39:56.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.725]                 }
[17:39:56.725]                 ...future.workdir <- getwd()
[17:39:56.725]             }
[17:39:56.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.725]         }
[17:39:56.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.725]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.725]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.725]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.725]             base::names(...future.oldOptions))
[17:39:56.725]     }
[17:39:56.725]     if (FALSE) {
[17:39:56.725]     }
[17:39:56.725]     else {
[17:39:56.725]         if (TRUE) {
[17:39:56.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.725]                 open = "w")
[17:39:56.725]         }
[17:39:56.725]         else {
[17:39:56.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.725]         }
[17:39:56.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.725]             base::sink(type = "output", split = FALSE)
[17:39:56.725]             base::close(...future.stdout)
[17:39:56.725]         }, add = TRUE)
[17:39:56.725]     }
[17:39:56.725]     ...future.frame <- base::sys.nframe()
[17:39:56.725]     ...future.conditions <- base::list()
[17:39:56.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.725]     if (FALSE) {
[17:39:56.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.725]     }
[17:39:56.725]     ...future.result <- base::tryCatch({
[17:39:56.725]         base::withCallingHandlers({
[17:39:56.725]             ...future.value <- base::withVisible(base::local({
[17:39:56.725]                 withCallingHandlers({
[17:39:56.725]                   {
[17:39:56.725]                     b <- a
[17:39:56.725]                     a <- 2
[17:39:56.725]                     a * b
[17:39:56.725]                   }
[17:39:56.725]                 }, immediateCondition = function(cond) {
[17:39:56.725]                   save_rds <- function (object, pathname, ...) 
[17:39:56.725]                   {
[17:39:56.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.725]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.725]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.725]                         fi_tmp[["mtime"]])
[17:39:56.725]                     }
[17:39:56.725]                     tryCatch({
[17:39:56.725]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.725]                     }, error = function(ex) {
[17:39:56.725]                       msg <- conditionMessage(ex)
[17:39:56.725]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.725]                         fi_tmp[["mtime"]], msg)
[17:39:56.725]                       ex$message <- msg
[17:39:56.725]                       stop(ex)
[17:39:56.725]                     })
[17:39:56.725]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.725]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.725]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.725]                       fi <- file.info(pathname)
[17:39:56.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.725]                         fi[["size"]], fi[["mtime"]])
[17:39:56.725]                       stop(msg)
[17:39:56.725]                     }
[17:39:56.725]                     invisible(pathname)
[17:39:56.725]                   }
[17:39:56.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.725]                     rootPath = tempdir()) 
[17:39:56.725]                   {
[17:39:56.725]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.725]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.725]                       tmpdir = path, fileext = ".rds")
[17:39:56.725]                     save_rds(obj, file)
[17:39:56.725]                   }
[17:39:56.725]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.725]                   {
[17:39:56.725]                     inherits <- base::inherits
[17:39:56.725]                     invokeRestart <- base::invokeRestart
[17:39:56.725]                     is.null <- base::is.null
[17:39:56.725]                     muffled <- FALSE
[17:39:56.725]                     if (inherits(cond, "message")) {
[17:39:56.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.725]                       if (muffled) 
[17:39:56.725]                         invokeRestart("muffleMessage")
[17:39:56.725]                     }
[17:39:56.725]                     else if (inherits(cond, "warning")) {
[17:39:56.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.725]                       if (muffled) 
[17:39:56.725]                         invokeRestart("muffleWarning")
[17:39:56.725]                     }
[17:39:56.725]                     else if (inherits(cond, "condition")) {
[17:39:56.725]                       if (!is.null(pattern)) {
[17:39:56.725]                         computeRestarts <- base::computeRestarts
[17:39:56.725]                         grepl <- base::grepl
[17:39:56.725]                         restarts <- computeRestarts(cond)
[17:39:56.725]                         for (restart in restarts) {
[17:39:56.725]                           name <- restart$name
[17:39:56.725]                           if (is.null(name)) 
[17:39:56.725]                             next
[17:39:56.725]                           if (!grepl(pattern, name)) 
[17:39:56.725]                             next
[17:39:56.725]                           invokeRestart(restart)
[17:39:56.725]                           muffled <- TRUE
[17:39:56.725]                           break
[17:39:56.725]                         }
[17:39:56.725]                       }
[17:39:56.725]                     }
[17:39:56.725]                     invisible(muffled)
[17:39:56.725]                   }
[17:39:56.725]                   muffleCondition(cond)
[17:39:56.725]                 })
[17:39:56.725]             }))
[17:39:56.725]             future::FutureResult(value = ...future.value$value, 
[17:39:56.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.725]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.725]                     ...future.globalenv.names))
[17:39:56.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.725]         }, condition = base::local({
[17:39:56.725]             c <- base::c
[17:39:56.725]             inherits <- base::inherits
[17:39:56.725]             invokeRestart <- base::invokeRestart
[17:39:56.725]             length <- base::length
[17:39:56.725]             list <- base::list
[17:39:56.725]             seq.int <- base::seq.int
[17:39:56.725]             signalCondition <- base::signalCondition
[17:39:56.725]             sys.calls <- base::sys.calls
[17:39:56.725]             `[[` <- base::`[[`
[17:39:56.725]             `+` <- base::`+`
[17:39:56.725]             `<<-` <- base::`<<-`
[17:39:56.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.725]                   3L)]
[17:39:56.725]             }
[17:39:56.725]             function(cond) {
[17:39:56.725]                 is_error <- inherits(cond, "error")
[17:39:56.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.725]                   NULL)
[17:39:56.725]                 if (is_error) {
[17:39:56.725]                   sessionInformation <- function() {
[17:39:56.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.725]                       search = base::search(), system = base::Sys.info())
[17:39:56.725]                   }
[17:39:56.725]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.725]                     cond$call), session = sessionInformation(), 
[17:39:56.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.725]                   signalCondition(cond)
[17:39:56.725]                 }
[17:39:56.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.725]                 "immediateCondition"))) {
[17:39:56.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.725]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.725]                   if (TRUE && !signal) {
[17:39:56.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.725]                     {
[17:39:56.725]                       inherits <- base::inherits
[17:39:56.725]                       invokeRestart <- base::invokeRestart
[17:39:56.725]                       is.null <- base::is.null
[17:39:56.725]                       muffled <- FALSE
[17:39:56.725]                       if (inherits(cond, "message")) {
[17:39:56.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.725]                         if (muffled) 
[17:39:56.725]                           invokeRestart("muffleMessage")
[17:39:56.725]                       }
[17:39:56.725]                       else if (inherits(cond, "warning")) {
[17:39:56.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.725]                         if (muffled) 
[17:39:56.725]                           invokeRestart("muffleWarning")
[17:39:56.725]                       }
[17:39:56.725]                       else if (inherits(cond, "condition")) {
[17:39:56.725]                         if (!is.null(pattern)) {
[17:39:56.725]                           computeRestarts <- base::computeRestarts
[17:39:56.725]                           grepl <- base::grepl
[17:39:56.725]                           restarts <- computeRestarts(cond)
[17:39:56.725]                           for (restart in restarts) {
[17:39:56.725]                             name <- restart$name
[17:39:56.725]                             if (is.null(name)) 
[17:39:56.725]                               next
[17:39:56.725]                             if (!grepl(pattern, name)) 
[17:39:56.725]                               next
[17:39:56.725]                             invokeRestart(restart)
[17:39:56.725]                             muffled <- TRUE
[17:39:56.725]                             break
[17:39:56.725]                           }
[17:39:56.725]                         }
[17:39:56.725]                       }
[17:39:56.725]                       invisible(muffled)
[17:39:56.725]                     }
[17:39:56.725]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.725]                   }
[17:39:56.725]                 }
[17:39:56.725]                 else {
[17:39:56.725]                   if (TRUE) {
[17:39:56.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.725]                     {
[17:39:56.725]                       inherits <- base::inherits
[17:39:56.725]                       invokeRestart <- base::invokeRestart
[17:39:56.725]                       is.null <- base::is.null
[17:39:56.725]                       muffled <- FALSE
[17:39:56.725]                       if (inherits(cond, "message")) {
[17:39:56.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.725]                         if (muffled) 
[17:39:56.725]                           invokeRestart("muffleMessage")
[17:39:56.725]                       }
[17:39:56.725]                       else if (inherits(cond, "warning")) {
[17:39:56.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.725]                         if (muffled) 
[17:39:56.725]                           invokeRestart("muffleWarning")
[17:39:56.725]                       }
[17:39:56.725]                       else if (inherits(cond, "condition")) {
[17:39:56.725]                         if (!is.null(pattern)) {
[17:39:56.725]                           computeRestarts <- base::computeRestarts
[17:39:56.725]                           grepl <- base::grepl
[17:39:56.725]                           restarts <- computeRestarts(cond)
[17:39:56.725]                           for (restart in restarts) {
[17:39:56.725]                             name <- restart$name
[17:39:56.725]                             if (is.null(name)) 
[17:39:56.725]                               next
[17:39:56.725]                             if (!grepl(pattern, name)) 
[17:39:56.725]                               next
[17:39:56.725]                             invokeRestart(restart)
[17:39:56.725]                             muffled <- TRUE
[17:39:56.725]                             break
[17:39:56.725]                           }
[17:39:56.725]                         }
[17:39:56.725]                       }
[17:39:56.725]                       invisible(muffled)
[17:39:56.725]                     }
[17:39:56.725]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.725]                   }
[17:39:56.725]                 }
[17:39:56.725]             }
[17:39:56.725]         }))
[17:39:56.725]     }, error = function(ex) {
[17:39:56.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.725]                 ...future.rng), started = ...future.startTime, 
[17:39:56.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.725]             version = "1.8"), class = "FutureResult")
[17:39:56.725]     }, finally = {
[17:39:56.725]         if (!identical(...future.workdir, getwd())) 
[17:39:56.725]             setwd(...future.workdir)
[17:39:56.725]         {
[17:39:56.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.725]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.725]             }
[17:39:56.725]             base::options(...future.oldOptions)
[17:39:56.725]             if (.Platform$OS.type == "windows") {
[17:39:56.725]                 old_names <- names(...future.oldEnvVars)
[17:39:56.725]                 envs <- base::Sys.getenv()
[17:39:56.725]                 names <- names(envs)
[17:39:56.725]                 common <- intersect(names, old_names)
[17:39:56.725]                 added <- setdiff(names, old_names)
[17:39:56.725]                 removed <- setdiff(old_names, names)
[17:39:56.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.725]                   envs[common]]
[17:39:56.725]                 NAMES <- toupper(changed)
[17:39:56.725]                 args <- list()
[17:39:56.725]                 for (kk in seq_along(NAMES)) {
[17:39:56.725]                   name <- changed[[kk]]
[17:39:56.725]                   NAME <- NAMES[[kk]]
[17:39:56.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.725]                     next
[17:39:56.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.725]                 }
[17:39:56.725]                 NAMES <- toupper(added)
[17:39:56.725]                 for (kk in seq_along(NAMES)) {
[17:39:56.725]                   name <- added[[kk]]
[17:39:56.725]                   NAME <- NAMES[[kk]]
[17:39:56.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.725]                     next
[17:39:56.725]                   args[[name]] <- ""
[17:39:56.725]                 }
[17:39:56.725]                 NAMES <- toupper(removed)
[17:39:56.725]                 for (kk in seq_along(NAMES)) {
[17:39:56.725]                   name <- removed[[kk]]
[17:39:56.725]                   NAME <- NAMES[[kk]]
[17:39:56.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.725]                     next
[17:39:56.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.725]                 }
[17:39:56.725]                 if (length(args) > 0) 
[17:39:56.725]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.725]             }
[17:39:56.725]             else {
[17:39:56.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.725]             }
[17:39:56.725]             {
[17:39:56.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.725]                   0L) {
[17:39:56.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.725]                   base::options(opts)
[17:39:56.725]                 }
[17:39:56.725]                 {
[17:39:56.725]                   {
[17:39:56.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.725]                     NULL
[17:39:56.725]                   }
[17:39:56.725]                   options(future.plan = NULL)
[17:39:56.725]                   if (is.na(NA_character_)) 
[17:39:56.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.725]                     .init = FALSE)
[17:39:56.725]                 }
[17:39:56.725]             }
[17:39:56.725]         }
[17:39:56.725]     })
[17:39:56.725]     if (TRUE) {
[17:39:56.725]         base::sink(type = "output", split = FALSE)
[17:39:56.725]         if (TRUE) {
[17:39:56.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.725]         }
[17:39:56.725]         else {
[17:39:56.725]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.725]         }
[17:39:56.725]         base::close(...future.stdout)
[17:39:56.725]         ...future.stdout <- NULL
[17:39:56.725]     }
[17:39:56.725]     ...future.result$conditions <- ...future.conditions
[17:39:56.725]     ...future.result$finished <- base::Sys.time()
[17:39:56.725]     ...future.result
[17:39:56.725] }
[17:39:56.727] assign_globals() ...
[17:39:56.728] List of 1
[17:39:56.728]  $ a: num 3
[17:39:56.728]  - attr(*, "where")=List of 1
[17:39:56.728]   ..$ a:<environment: R_EmptyEnv> 
[17:39:56.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.728]  - attr(*, "resolved")= logi TRUE
[17:39:56.728]  - attr(*, "total_size")= num 56
[17:39:56.728]  - attr(*, "already-done")= logi TRUE
[17:39:56.731] - copied ‘a’ to environment
[17:39:56.731] assign_globals() ... done
[17:39:56.731] requestCore(): workers = 2
[17:39:56.733] MulticoreFuture started
[17:39:56.733] - Launch lazy future ... done
[17:39:56.733] run() for ‘MulticoreFuture’ ... done
[17:39:56.733] result() for MulticoreFuture ...
[17:39:56.734] plan(): Setting new future strategy stack:
[17:39:56.734] List of future strategies:
[17:39:56.734] 1. sequential:
[17:39:56.734]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.734]    - tweaked: FALSE
[17:39:56.734]    - call: NULL
[17:39:56.735] plan(): nbrOfWorkers() = 1
[17:39:56.737] plan(): Setting new future strategy stack:
[17:39:56.737] List of future strategies:
[17:39:56.737] 1. multicore:
[17:39:56.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.737]    - tweaked: FALSE
[17:39:56.737]    - call: plan(strategy)
[17:39:56.748] plan(): nbrOfWorkers() = 2
[17:39:56.749] result() for MulticoreFuture ...
[17:39:56.749] result() for MulticoreFuture ... done
[17:39:56.749] result() for MulticoreFuture ... done
[17:39:56.750] result() for MulticoreFuture ...
[17:39:56.750] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.751] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.753] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.757] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.757] Searching for globals ... DONE
[17:39:56.757] Resolving globals: TRUE
[17:39:56.757] Resolving any globals that are futures ...
[17:39:56.758] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.758] Resolving any globals that are futures ... DONE
[17:39:56.758] Resolving futures part of globals (recursively) ...
[17:39:56.759] resolve() on list ...
[17:39:56.759]  recursive: 99
[17:39:56.759]  length: 2
[17:39:56.759]  elements: ‘a’, ‘ii’
[17:39:56.759]  length: 1 (resolved future 1)
[17:39:56.759]  length: 0 (resolved future 2)
[17:39:56.759] resolve() on list ... DONE
[17:39:56.759] - globals: [2] ‘a’, ‘ii’
[17:39:56.760] Resolving futures part of globals (recursively) ... DONE
[17:39:56.760] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:56.760] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.760] - globals: [2] ‘a’, ‘ii’
[17:39:56.761] 
[17:39:56.761] getGlobalsAndPackages() ... DONE
[17:39:56.761] run() for ‘Future’ ...
[17:39:56.761] - state: ‘created’
[17:39:56.761] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.765] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.765]   - Field: ‘label’
[17:39:56.766]   - Field: ‘local’
[17:39:56.766]   - Field: ‘owner’
[17:39:56.766]   - Field: ‘envir’
[17:39:56.766]   - Field: ‘workers’
[17:39:56.766]   - Field: ‘packages’
[17:39:56.766]   - Field: ‘gc’
[17:39:56.766]   - Field: ‘job’
[17:39:56.766]   - Field: ‘conditions’
[17:39:56.766]   - Field: ‘expr’
[17:39:56.767]   - Field: ‘uuid’
[17:39:56.767]   - Field: ‘seed’
[17:39:56.767]   - Field: ‘version’
[17:39:56.767]   - Field: ‘result’
[17:39:56.767]   - Field: ‘asynchronous’
[17:39:56.767]   - Field: ‘calls’
[17:39:56.767]   - Field: ‘globals’
[17:39:56.767]   - Field: ‘stdout’
[17:39:56.767]   - Field: ‘earlySignal’
[17:39:56.768]   - Field: ‘lazy’
[17:39:56.768]   - Field: ‘state’
[17:39:56.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.768] - Launch lazy future ...
[17:39:56.768] Packages needed by the future expression (n = 0): <none>
[17:39:56.768] Packages needed by future strategies (n = 0): <none>
[17:39:56.769] {
[17:39:56.769]     {
[17:39:56.769]         {
[17:39:56.769]             ...future.startTime <- base::Sys.time()
[17:39:56.769]             {
[17:39:56.769]                 {
[17:39:56.769]                   {
[17:39:56.769]                     {
[17:39:56.769]                       base::local({
[17:39:56.769]                         has_future <- base::requireNamespace("future", 
[17:39:56.769]                           quietly = TRUE)
[17:39:56.769]                         if (has_future) {
[17:39:56.769]                           ns <- base::getNamespace("future")
[17:39:56.769]                           version <- ns[[".package"]][["version"]]
[17:39:56.769]                           if (is.null(version)) 
[17:39:56.769]                             version <- utils::packageVersion("future")
[17:39:56.769]                         }
[17:39:56.769]                         else {
[17:39:56.769]                           version <- NULL
[17:39:56.769]                         }
[17:39:56.769]                         if (!has_future || version < "1.8.0") {
[17:39:56.769]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.769]                             "", base::R.version$version.string), 
[17:39:56.769]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.769]                               "release", "version")], collapse = " "), 
[17:39:56.769]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.769]                             info)
[17:39:56.769]                           info <- base::paste(info, collapse = "; ")
[17:39:56.769]                           if (!has_future) {
[17:39:56.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.769]                               info)
[17:39:56.769]                           }
[17:39:56.769]                           else {
[17:39:56.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.769]                               info, version)
[17:39:56.769]                           }
[17:39:56.769]                           base::stop(msg)
[17:39:56.769]                         }
[17:39:56.769]                       })
[17:39:56.769]                     }
[17:39:56.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.769]                     base::options(mc.cores = 1L)
[17:39:56.769]                   }
[17:39:56.769]                   ...future.strategy.old <- future::plan("list")
[17:39:56.769]                   options(future.plan = NULL)
[17:39:56.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.769]                 }
[17:39:56.769]                 ...future.workdir <- getwd()
[17:39:56.769]             }
[17:39:56.769]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.769]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.769]         }
[17:39:56.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.769]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.769]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.769]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.769]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.769]             base::names(...future.oldOptions))
[17:39:56.769]     }
[17:39:56.769]     if (FALSE) {
[17:39:56.769]     }
[17:39:56.769]     else {
[17:39:56.769]         if (TRUE) {
[17:39:56.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.769]                 open = "w")
[17:39:56.769]         }
[17:39:56.769]         else {
[17:39:56.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.769]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.769]         }
[17:39:56.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.769]             base::sink(type = "output", split = FALSE)
[17:39:56.769]             base::close(...future.stdout)
[17:39:56.769]         }, add = TRUE)
[17:39:56.769]     }
[17:39:56.769]     ...future.frame <- base::sys.nframe()
[17:39:56.769]     ...future.conditions <- base::list()
[17:39:56.769]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.769]     if (FALSE) {
[17:39:56.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.769]     }
[17:39:56.769]     ...future.result <- base::tryCatch({
[17:39:56.769]         base::withCallingHandlers({
[17:39:56.769]             ...future.value <- base::withVisible(base::local({
[17:39:56.769]                 withCallingHandlers({
[17:39:56.769]                   {
[17:39:56.769]                     b <- a * ii
[17:39:56.769]                     a <- 0
[17:39:56.769]                     b
[17:39:56.769]                   }
[17:39:56.769]                 }, immediateCondition = function(cond) {
[17:39:56.769]                   save_rds <- function (object, pathname, ...) 
[17:39:56.769]                   {
[17:39:56.769]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.769]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.769]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.769]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.769]                         fi_tmp[["mtime"]])
[17:39:56.769]                     }
[17:39:56.769]                     tryCatch({
[17:39:56.769]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.769]                     }, error = function(ex) {
[17:39:56.769]                       msg <- conditionMessage(ex)
[17:39:56.769]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.769]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.769]                         fi_tmp[["mtime"]], msg)
[17:39:56.769]                       ex$message <- msg
[17:39:56.769]                       stop(ex)
[17:39:56.769]                     })
[17:39:56.769]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.769]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.769]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.769]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.769]                       fi <- file.info(pathname)
[17:39:56.769]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.769]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.769]                         fi[["size"]], fi[["mtime"]])
[17:39:56.769]                       stop(msg)
[17:39:56.769]                     }
[17:39:56.769]                     invisible(pathname)
[17:39:56.769]                   }
[17:39:56.769]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.769]                     rootPath = tempdir()) 
[17:39:56.769]                   {
[17:39:56.769]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.769]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.769]                       tmpdir = path, fileext = ".rds")
[17:39:56.769]                     save_rds(obj, file)
[17:39:56.769]                   }
[17:39:56.769]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.769]                   {
[17:39:56.769]                     inherits <- base::inherits
[17:39:56.769]                     invokeRestart <- base::invokeRestart
[17:39:56.769]                     is.null <- base::is.null
[17:39:56.769]                     muffled <- FALSE
[17:39:56.769]                     if (inherits(cond, "message")) {
[17:39:56.769]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.769]                       if (muffled) 
[17:39:56.769]                         invokeRestart("muffleMessage")
[17:39:56.769]                     }
[17:39:56.769]                     else if (inherits(cond, "warning")) {
[17:39:56.769]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.769]                       if (muffled) 
[17:39:56.769]                         invokeRestart("muffleWarning")
[17:39:56.769]                     }
[17:39:56.769]                     else if (inherits(cond, "condition")) {
[17:39:56.769]                       if (!is.null(pattern)) {
[17:39:56.769]                         computeRestarts <- base::computeRestarts
[17:39:56.769]                         grepl <- base::grepl
[17:39:56.769]                         restarts <- computeRestarts(cond)
[17:39:56.769]                         for (restart in restarts) {
[17:39:56.769]                           name <- restart$name
[17:39:56.769]                           if (is.null(name)) 
[17:39:56.769]                             next
[17:39:56.769]                           if (!grepl(pattern, name)) 
[17:39:56.769]                             next
[17:39:56.769]                           invokeRestart(restart)
[17:39:56.769]                           muffled <- TRUE
[17:39:56.769]                           break
[17:39:56.769]                         }
[17:39:56.769]                       }
[17:39:56.769]                     }
[17:39:56.769]                     invisible(muffled)
[17:39:56.769]                   }
[17:39:56.769]                   muffleCondition(cond)
[17:39:56.769]                 })
[17:39:56.769]             }))
[17:39:56.769]             future::FutureResult(value = ...future.value$value, 
[17:39:56.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.769]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.769]                     ...future.globalenv.names))
[17:39:56.769]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.769]         }, condition = base::local({
[17:39:56.769]             c <- base::c
[17:39:56.769]             inherits <- base::inherits
[17:39:56.769]             invokeRestart <- base::invokeRestart
[17:39:56.769]             length <- base::length
[17:39:56.769]             list <- base::list
[17:39:56.769]             seq.int <- base::seq.int
[17:39:56.769]             signalCondition <- base::signalCondition
[17:39:56.769]             sys.calls <- base::sys.calls
[17:39:56.769]             `[[` <- base::`[[`
[17:39:56.769]             `+` <- base::`+`
[17:39:56.769]             `<<-` <- base::`<<-`
[17:39:56.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.769]                   3L)]
[17:39:56.769]             }
[17:39:56.769]             function(cond) {
[17:39:56.769]                 is_error <- inherits(cond, "error")
[17:39:56.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.769]                   NULL)
[17:39:56.769]                 if (is_error) {
[17:39:56.769]                   sessionInformation <- function() {
[17:39:56.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.769]                       search = base::search(), system = base::Sys.info())
[17:39:56.769]                   }
[17:39:56.769]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.769]                     cond$call), session = sessionInformation(), 
[17:39:56.769]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.769]                   signalCondition(cond)
[17:39:56.769]                 }
[17:39:56.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.769]                 "immediateCondition"))) {
[17:39:56.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.769]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.769]                   if (TRUE && !signal) {
[17:39:56.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.769]                     {
[17:39:56.769]                       inherits <- base::inherits
[17:39:56.769]                       invokeRestart <- base::invokeRestart
[17:39:56.769]                       is.null <- base::is.null
[17:39:56.769]                       muffled <- FALSE
[17:39:56.769]                       if (inherits(cond, "message")) {
[17:39:56.769]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.769]                         if (muffled) 
[17:39:56.769]                           invokeRestart("muffleMessage")
[17:39:56.769]                       }
[17:39:56.769]                       else if (inherits(cond, "warning")) {
[17:39:56.769]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.769]                         if (muffled) 
[17:39:56.769]                           invokeRestart("muffleWarning")
[17:39:56.769]                       }
[17:39:56.769]                       else if (inherits(cond, "condition")) {
[17:39:56.769]                         if (!is.null(pattern)) {
[17:39:56.769]                           computeRestarts <- base::computeRestarts
[17:39:56.769]                           grepl <- base::grepl
[17:39:56.769]                           restarts <- computeRestarts(cond)
[17:39:56.769]                           for (restart in restarts) {
[17:39:56.769]                             name <- restart$name
[17:39:56.769]                             if (is.null(name)) 
[17:39:56.769]                               next
[17:39:56.769]                             if (!grepl(pattern, name)) 
[17:39:56.769]                               next
[17:39:56.769]                             invokeRestart(restart)
[17:39:56.769]                             muffled <- TRUE
[17:39:56.769]                             break
[17:39:56.769]                           }
[17:39:56.769]                         }
[17:39:56.769]                       }
[17:39:56.769]                       invisible(muffled)
[17:39:56.769]                     }
[17:39:56.769]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.769]                   }
[17:39:56.769]                 }
[17:39:56.769]                 else {
[17:39:56.769]                   if (TRUE) {
[17:39:56.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.769]                     {
[17:39:56.769]                       inherits <- base::inherits
[17:39:56.769]                       invokeRestart <- base::invokeRestart
[17:39:56.769]                       is.null <- base::is.null
[17:39:56.769]                       muffled <- FALSE
[17:39:56.769]                       if (inherits(cond, "message")) {
[17:39:56.769]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.769]                         if (muffled) 
[17:39:56.769]                           invokeRestart("muffleMessage")
[17:39:56.769]                       }
[17:39:56.769]                       else if (inherits(cond, "warning")) {
[17:39:56.769]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.769]                         if (muffled) 
[17:39:56.769]                           invokeRestart("muffleWarning")
[17:39:56.769]                       }
[17:39:56.769]                       else if (inherits(cond, "condition")) {
[17:39:56.769]                         if (!is.null(pattern)) {
[17:39:56.769]                           computeRestarts <- base::computeRestarts
[17:39:56.769]                           grepl <- base::grepl
[17:39:56.769]                           restarts <- computeRestarts(cond)
[17:39:56.769]                           for (restart in restarts) {
[17:39:56.769]                             name <- restart$name
[17:39:56.769]                             if (is.null(name)) 
[17:39:56.769]                               next
[17:39:56.769]                             if (!grepl(pattern, name)) 
[17:39:56.769]                               next
[17:39:56.769]                             invokeRestart(restart)
[17:39:56.769]                             muffled <- TRUE
[17:39:56.769]                             break
[17:39:56.769]                           }
[17:39:56.769]                         }
[17:39:56.769]                       }
[17:39:56.769]                       invisible(muffled)
[17:39:56.769]                     }
[17:39:56.769]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.769]                   }
[17:39:56.769]                 }
[17:39:56.769]             }
[17:39:56.769]         }))
[17:39:56.769]     }, error = function(ex) {
[17:39:56.769]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.769]                 ...future.rng), started = ...future.startTime, 
[17:39:56.769]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.769]             version = "1.8"), class = "FutureResult")
[17:39:56.769]     }, finally = {
[17:39:56.769]         if (!identical(...future.workdir, getwd())) 
[17:39:56.769]             setwd(...future.workdir)
[17:39:56.769]         {
[17:39:56.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.769]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.769]             }
[17:39:56.769]             base::options(...future.oldOptions)
[17:39:56.769]             if (.Platform$OS.type == "windows") {
[17:39:56.769]                 old_names <- names(...future.oldEnvVars)
[17:39:56.769]                 envs <- base::Sys.getenv()
[17:39:56.769]                 names <- names(envs)
[17:39:56.769]                 common <- intersect(names, old_names)
[17:39:56.769]                 added <- setdiff(names, old_names)
[17:39:56.769]                 removed <- setdiff(old_names, names)
[17:39:56.769]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.769]                   envs[common]]
[17:39:56.769]                 NAMES <- toupper(changed)
[17:39:56.769]                 args <- list()
[17:39:56.769]                 for (kk in seq_along(NAMES)) {
[17:39:56.769]                   name <- changed[[kk]]
[17:39:56.769]                   NAME <- NAMES[[kk]]
[17:39:56.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.769]                     next
[17:39:56.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.769]                 }
[17:39:56.769]                 NAMES <- toupper(added)
[17:39:56.769]                 for (kk in seq_along(NAMES)) {
[17:39:56.769]                   name <- added[[kk]]
[17:39:56.769]                   NAME <- NAMES[[kk]]
[17:39:56.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.769]                     next
[17:39:56.769]                   args[[name]] <- ""
[17:39:56.769]                 }
[17:39:56.769]                 NAMES <- toupper(removed)
[17:39:56.769]                 for (kk in seq_along(NAMES)) {
[17:39:56.769]                   name <- removed[[kk]]
[17:39:56.769]                   NAME <- NAMES[[kk]]
[17:39:56.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.769]                     next
[17:39:56.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.769]                 }
[17:39:56.769]                 if (length(args) > 0) 
[17:39:56.769]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.769]             }
[17:39:56.769]             else {
[17:39:56.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.769]             }
[17:39:56.769]             {
[17:39:56.769]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.769]                   0L) {
[17:39:56.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.769]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.769]                   base::options(opts)
[17:39:56.769]                 }
[17:39:56.769]                 {
[17:39:56.769]                   {
[17:39:56.769]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.769]                     NULL
[17:39:56.769]                   }
[17:39:56.769]                   options(future.plan = NULL)
[17:39:56.769]                   if (is.na(NA_character_)) 
[17:39:56.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.769]                     .init = FALSE)
[17:39:56.769]                 }
[17:39:56.769]             }
[17:39:56.769]         }
[17:39:56.769]     })
[17:39:56.769]     if (TRUE) {
[17:39:56.769]         base::sink(type = "output", split = FALSE)
[17:39:56.769]         if (TRUE) {
[17:39:56.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.769]         }
[17:39:56.769]         else {
[17:39:56.769]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.769]         }
[17:39:56.769]         base::close(...future.stdout)
[17:39:56.769]         ...future.stdout <- NULL
[17:39:56.769]     }
[17:39:56.769]     ...future.result$conditions <- ...future.conditions
[17:39:56.769]     ...future.result$finished <- base::Sys.time()
[17:39:56.769]     ...future.result
[17:39:56.769] }
[17:39:56.771] assign_globals() ...
[17:39:56.771] List of 2
[17:39:56.771]  $ a : num 1
[17:39:56.771]  $ ii: int 1
[17:39:56.771]  - attr(*, "where")=List of 2
[17:39:56.771]   ..$ a :<environment: R_EmptyEnv> 
[17:39:56.771]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.771]  - attr(*, "resolved")= logi TRUE
[17:39:56.771]  - attr(*, "total_size")= num 112
[17:39:56.771]  - attr(*, "already-done")= logi TRUE
[17:39:56.775] - copied ‘a’ to environment
[17:39:56.775] - copied ‘ii’ to environment
[17:39:56.775] assign_globals() ... done
[17:39:56.775] requestCore(): workers = 2
[17:39:56.777] MulticoreFuture started
[17:39:56.777] - Launch lazy future ... done
[17:39:56.777] run() for ‘MulticoreFuture’ ... done
[17:39:56.778] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.779] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.778] List of future strategies:
[17:39:56.778] 1. sequential:
[17:39:56.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.778]    - tweaked: FALSE
[17:39:56.778]    - call: NULL
[17:39:56.779] Searching for globals...
[17:39:56.779] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.781] plan(): Setting new future strategy stack:
[17:39:56.781] List of future strategies:
[17:39:56.781] 1. multicore:
[17:39:56.781]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.781]    - tweaked: FALSE
[17:39:56.781]    - call: plan(strategy)
[17:39:56.783] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.783] Searching for globals ... DONE
[17:39:56.783] Resolving globals: TRUE
[17:39:56.783] Resolving any globals that are futures ...
[17:39:56.783] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.784] Resolving any globals that are futures ... DONE
[17:39:56.786] plan(): nbrOfWorkers() = 2
[17:39:56.784] Resolving futures part of globals (recursively) ...
[17:39:56.789] resolve() on list ...
[17:39:56.789]  recursive: 99
[17:39:56.789]  length: 2
[17:39:56.790]  elements: ‘a’, ‘ii’
[17:39:56.790]  length: 1 (resolved future 1)
[17:39:56.790]  length: 0 (resolved future 2)
[17:39:56.791] resolve() on list ... DONE
[17:39:56.791] - globals: [2] ‘a’, ‘ii’
[17:39:56.791] Resolving futures part of globals (recursively) ... DONE
[17:39:56.792] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:56.793] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.793] - globals: [2] ‘a’, ‘ii’
[17:39:56.794] 
[17:39:56.794] getGlobalsAndPackages() ... DONE
[17:39:56.794] run() for ‘Future’ ...
[17:39:56.794] - state: ‘created’
[17:39:56.795] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.799] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.799]   - Field: ‘label’
[17:39:56.800]   - Field: ‘local’
[17:39:56.800]   - Field: ‘owner’
[17:39:56.800]   - Field: ‘envir’
[17:39:56.800]   - Field: ‘workers’
[17:39:56.800]   - Field: ‘packages’
[17:39:56.800]   - Field: ‘gc’
[17:39:56.801]   - Field: ‘job’
[17:39:56.801]   - Field: ‘conditions’
[17:39:56.801]   - Field: ‘expr’
[17:39:56.801]   - Field: ‘uuid’
[17:39:56.801]   - Field: ‘seed’
[17:39:56.801]   - Field: ‘version’
[17:39:56.801]   - Field: ‘result’
[17:39:56.802]   - Field: ‘asynchronous’
[17:39:56.802]   - Field: ‘calls’
[17:39:56.802]   - Field: ‘globals’
[17:39:56.802]   - Field: ‘stdout’
[17:39:56.802]   - Field: ‘earlySignal’
[17:39:56.802]   - Field: ‘lazy’
[17:39:56.802]   - Field: ‘state’
[17:39:56.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.803] - Launch lazy future ...
[17:39:56.803] Packages needed by the future expression (n = 0): <none>
[17:39:56.803] Packages needed by future strategies (n = 0): <none>
[17:39:56.804] {
[17:39:56.804]     {
[17:39:56.804]         {
[17:39:56.804]             ...future.startTime <- base::Sys.time()
[17:39:56.804]             {
[17:39:56.804]                 {
[17:39:56.804]                   {
[17:39:56.804]                     {
[17:39:56.804]                       base::local({
[17:39:56.804]                         has_future <- base::requireNamespace("future", 
[17:39:56.804]                           quietly = TRUE)
[17:39:56.804]                         if (has_future) {
[17:39:56.804]                           ns <- base::getNamespace("future")
[17:39:56.804]                           version <- ns[[".package"]][["version"]]
[17:39:56.804]                           if (is.null(version)) 
[17:39:56.804]                             version <- utils::packageVersion("future")
[17:39:56.804]                         }
[17:39:56.804]                         else {
[17:39:56.804]                           version <- NULL
[17:39:56.804]                         }
[17:39:56.804]                         if (!has_future || version < "1.8.0") {
[17:39:56.804]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.804]                             "", base::R.version$version.string), 
[17:39:56.804]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.804]                               "release", "version")], collapse = " "), 
[17:39:56.804]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.804]                             info)
[17:39:56.804]                           info <- base::paste(info, collapse = "; ")
[17:39:56.804]                           if (!has_future) {
[17:39:56.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.804]                               info)
[17:39:56.804]                           }
[17:39:56.804]                           else {
[17:39:56.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.804]                               info, version)
[17:39:56.804]                           }
[17:39:56.804]                           base::stop(msg)
[17:39:56.804]                         }
[17:39:56.804]                       })
[17:39:56.804]                     }
[17:39:56.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.804]                     base::options(mc.cores = 1L)
[17:39:56.804]                   }
[17:39:56.804]                   ...future.strategy.old <- future::plan("list")
[17:39:56.804]                   options(future.plan = NULL)
[17:39:56.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.804]                 }
[17:39:56.804]                 ...future.workdir <- getwd()
[17:39:56.804]             }
[17:39:56.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.804]         }
[17:39:56.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.804]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.804]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.804]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.804]             base::names(...future.oldOptions))
[17:39:56.804]     }
[17:39:56.804]     if (FALSE) {
[17:39:56.804]     }
[17:39:56.804]     else {
[17:39:56.804]         if (TRUE) {
[17:39:56.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.804]                 open = "w")
[17:39:56.804]         }
[17:39:56.804]         else {
[17:39:56.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.804]         }
[17:39:56.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.804]             base::sink(type = "output", split = FALSE)
[17:39:56.804]             base::close(...future.stdout)
[17:39:56.804]         }, add = TRUE)
[17:39:56.804]     }
[17:39:56.804]     ...future.frame <- base::sys.nframe()
[17:39:56.804]     ...future.conditions <- base::list()
[17:39:56.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.804]     if (FALSE) {
[17:39:56.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.804]     }
[17:39:56.804]     ...future.result <- base::tryCatch({
[17:39:56.804]         base::withCallingHandlers({
[17:39:56.804]             ...future.value <- base::withVisible(base::local({
[17:39:56.804]                 withCallingHandlers({
[17:39:56.804]                   {
[17:39:56.804]                     b <- a * ii
[17:39:56.804]                     a <- 0
[17:39:56.804]                     b
[17:39:56.804]                   }
[17:39:56.804]                 }, immediateCondition = function(cond) {
[17:39:56.804]                   save_rds <- function (object, pathname, ...) 
[17:39:56.804]                   {
[17:39:56.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.804]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.804]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.804]                         fi_tmp[["mtime"]])
[17:39:56.804]                     }
[17:39:56.804]                     tryCatch({
[17:39:56.804]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.804]                     }, error = function(ex) {
[17:39:56.804]                       msg <- conditionMessage(ex)
[17:39:56.804]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.804]                         fi_tmp[["mtime"]], msg)
[17:39:56.804]                       ex$message <- msg
[17:39:56.804]                       stop(ex)
[17:39:56.804]                     })
[17:39:56.804]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.804]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.804]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.804]                       fi <- file.info(pathname)
[17:39:56.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.804]                         fi[["size"]], fi[["mtime"]])
[17:39:56.804]                       stop(msg)
[17:39:56.804]                     }
[17:39:56.804]                     invisible(pathname)
[17:39:56.804]                   }
[17:39:56.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.804]                     rootPath = tempdir()) 
[17:39:56.804]                   {
[17:39:56.804]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.804]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.804]                       tmpdir = path, fileext = ".rds")
[17:39:56.804]                     save_rds(obj, file)
[17:39:56.804]                   }
[17:39:56.804]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.804]                   {
[17:39:56.804]                     inherits <- base::inherits
[17:39:56.804]                     invokeRestart <- base::invokeRestart
[17:39:56.804]                     is.null <- base::is.null
[17:39:56.804]                     muffled <- FALSE
[17:39:56.804]                     if (inherits(cond, "message")) {
[17:39:56.804]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.804]                       if (muffled) 
[17:39:56.804]                         invokeRestart("muffleMessage")
[17:39:56.804]                     }
[17:39:56.804]                     else if (inherits(cond, "warning")) {
[17:39:56.804]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.804]                       if (muffled) 
[17:39:56.804]                         invokeRestart("muffleWarning")
[17:39:56.804]                     }
[17:39:56.804]                     else if (inherits(cond, "condition")) {
[17:39:56.804]                       if (!is.null(pattern)) {
[17:39:56.804]                         computeRestarts <- base::computeRestarts
[17:39:56.804]                         grepl <- base::grepl
[17:39:56.804]                         restarts <- computeRestarts(cond)
[17:39:56.804]                         for (restart in restarts) {
[17:39:56.804]                           name <- restart$name
[17:39:56.804]                           if (is.null(name)) 
[17:39:56.804]                             next
[17:39:56.804]                           if (!grepl(pattern, name)) 
[17:39:56.804]                             next
[17:39:56.804]                           invokeRestart(restart)
[17:39:56.804]                           muffled <- TRUE
[17:39:56.804]                           break
[17:39:56.804]                         }
[17:39:56.804]                       }
[17:39:56.804]                     }
[17:39:56.804]                     invisible(muffled)
[17:39:56.804]                   }
[17:39:56.804]                   muffleCondition(cond)
[17:39:56.804]                 })
[17:39:56.804]             }))
[17:39:56.804]             future::FutureResult(value = ...future.value$value, 
[17:39:56.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.804]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.804]                     ...future.globalenv.names))
[17:39:56.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.804]         }, condition = base::local({
[17:39:56.804]             c <- base::c
[17:39:56.804]             inherits <- base::inherits
[17:39:56.804]             invokeRestart <- base::invokeRestart
[17:39:56.804]             length <- base::length
[17:39:56.804]             list <- base::list
[17:39:56.804]             seq.int <- base::seq.int
[17:39:56.804]             signalCondition <- base::signalCondition
[17:39:56.804]             sys.calls <- base::sys.calls
[17:39:56.804]             `[[` <- base::`[[`
[17:39:56.804]             `+` <- base::`+`
[17:39:56.804]             `<<-` <- base::`<<-`
[17:39:56.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.804]                   3L)]
[17:39:56.804]             }
[17:39:56.804]             function(cond) {
[17:39:56.804]                 is_error <- inherits(cond, "error")
[17:39:56.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.804]                   NULL)
[17:39:56.804]                 if (is_error) {
[17:39:56.804]                   sessionInformation <- function() {
[17:39:56.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.804]                       search = base::search(), system = base::Sys.info())
[17:39:56.804]                   }
[17:39:56.804]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.804]                     cond$call), session = sessionInformation(), 
[17:39:56.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.804]                   signalCondition(cond)
[17:39:56.804]                 }
[17:39:56.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.804]                 "immediateCondition"))) {
[17:39:56.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.804]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.804]                   if (TRUE && !signal) {
[17:39:56.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.804]                     {
[17:39:56.804]                       inherits <- base::inherits
[17:39:56.804]                       invokeRestart <- base::invokeRestart
[17:39:56.804]                       is.null <- base::is.null
[17:39:56.804]                       muffled <- FALSE
[17:39:56.804]                       if (inherits(cond, "message")) {
[17:39:56.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.804]                         if (muffled) 
[17:39:56.804]                           invokeRestart("muffleMessage")
[17:39:56.804]                       }
[17:39:56.804]                       else if (inherits(cond, "warning")) {
[17:39:56.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.804]                         if (muffled) 
[17:39:56.804]                           invokeRestart("muffleWarning")
[17:39:56.804]                       }
[17:39:56.804]                       else if (inherits(cond, "condition")) {
[17:39:56.804]                         if (!is.null(pattern)) {
[17:39:56.804]                           computeRestarts <- base::computeRestarts
[17:39:56.804]                           grepl <- base::grepl
[17:39:56.804]                           restarts <- computeRestarts(cond)
[17:39:56.804]                           for (restart in restarts) {
[17:39:56.804]                             name <- restart$name
[17:39:56.804]                             if (is.null(name)) 
[17:39:56.804]                               next
[17:39:56.804]                             if (!grepl(pattern, name)) 
[17:39:56.804]                               next
[17:39:56.804]                             invokeRestart(restart)
[17:39:56.804]                             muffled <- TRUE
[17:39:56.804]                             break
[17:39:56.804]                           }
[17:39:56.804]                         }
[17:39:56.804]                       }
[17:39:56.804]                       invisible(muffled)
[17:39:56.804]                     }
[17:39:56.804]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.804]                   }
[17:39:56.804]                 }
[17:39:56.804]                 else {
[17:39:56.804]                   if (TRUE) {
[17:39:56.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.804]                     {
[17:39:56.804]                       inherits <- base::inherits
[17:39:56.804]                       invokeRestart <- base::invokeRestart
[17:39:56.804]                       is.null <- base::is.null
[17:39:56.804]                       muffled <- FALSE
[17:39:56.804]                       if (inherits(cond, "message")) {
[17:39:56.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.804]                         if (muffled) 
[17:39:56.804]                           invokeRestart("muffleMessage")
[17:39:56.804]                       }
[17:39:56.804]                       else if (inherits(cond, "warning")) {
[17:39:56.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.804]                         if (muffled) 
[17:39:56.804]                           invokeRestart("muffleWarning")
[17:39:56.804]                       }
[17:39:56.804]                       else if (inherits(cond, "condition")) {
[17:39:56.804]                         if (!is.null(pattern)) {
[17:39:56.804]                           computeRestarts <- base::computeRestarts
[17:39:56.804]                           grepl <- base::grepl
[17:39:56.804]                           restarts <- computeRestarts(cond)
[17:39:56.804]                           for (restart in restarts) {
[17:39:56.804]                             name <- restart$name
[17:39:56.804]                             if (is.null(name)) 
[17:39:56.804]                               next
[17:39:56.804]                             if (!grepl(pattern, name)) 
[17:39:56.804]                               next
[17:39:56.804]                             invokeRestart(restart)
[17:39:56.804]                             muffled <- TRUE
[17:39:56.804]                             break
[17:39:56.804]                           }
[17:39:56.804]                         }
[17:39:56.804]                       }
[17:39:56.804]                       invisible(muffled)
[17:39:56.804]                     }
[17:39:56.804]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.804]                   }
[17:39:56.804]                 }
[17:39:56.804]             }
[17:39:56.804]         }))
[17:39:56.804]     }, error = function(ex) {
[17:39:56.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.804]                 ...future.rng), started = ...future.startTime, 
[17:39:56.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.804]             version = "1.8"), class = "FutureResult")
[17:39:56.804]     }, finally = {
[17:39:56.804]         if (!identical(...future.workdir, getwd())) 
[17:39:56.804]             setwd(...future.workdir)
[17:39:56.804]         {
[17:39:56.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.804]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.804]             }
[17:39:56.804]             base::options(...future.oldOptions)
[17:39:56.804]             if (.Platform$OS.type == "windows") {
[17:39:56.804]                 old_names <- names(...future.oldEnvVars)
[17:39:56.804]                 envs <- base::Sys.getenv()
[17:39:56.804]                 names <- names(envs)
[17:39:56.804]                 common <- intersect(names, old_names)
[17:39:56.804]                 added <- setdiff(names, old_names)
[17:39:56.804]                 removed <- setdiff(old_names, names)
[17:39:56.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.804]                   envs[common]]
[17:39:56.804]                 NAMES <- toupper(changed)
[17:39:56.804]                 args <- list()
[17:39:56.804]                 for (kk in seq_along(NAMES)) {
[17:39:56.804]                   name <- changed[[kk]]
[17:39:56.804]                   NAME <- NAMES[[kk]]
[17:39:56.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.804]                     next
[17:39:56.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.804]                 }
[17:39:56.804]                 NAMES <- toupper(added)
[17:39:56.804]                 for (kk in seq_along(NAMES)) {
[17:39:56.804]                   name <- added[[kk]]
[17:39:56.804]                   NAME <- NAMES[[kk]]
[17:39:56.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.804]                     next
[17:39:56.804]                   args[[name]] <- ""
[17:39:56.804]                 }
[17:39:56.804]                 NAMES <- toupper(removed)
[17:39:56.804]                 for (kk in seq_along(NAMES)) {
[17:39:56.804]                   name <- removed[[kk]]
[17:39:56.804]                   NAME <- NAMES[[kk]]
[17:39:56.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.804]                     next
[17:39:56.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.804]                 }
[17:39:56.804]                 if (length(args) > 0) 
[17:39:56.804]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.804]             }
[17:39:56.804]             else {
[17:39:56.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.804]             }
[17:39:56.804]             {
[17:39:56.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.804]                   0L) {
[17:39:56.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.804]                   base::options(opts)
[17:39:56.804]                 }
[17:39:56.804]                 {
[17:39:56.804]                   {
[17:39:56.804]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.804]                     NULL
[17:39:56.804]                   }
[17:39:56.804]                   options(future.plan = NULL)
[17:39:56.804]                   if (is.na(NA_character_)) 
[17:39:56.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.804]                     .init = FALSE)
[17:39:56.804]                 }
[17:39:56.804]             }
[17:39:56.804]         }
[17:39:56.804]     })
[17:39:56.804]     if (TRUE) {
[17:39:56.804]         base::sink(type = "output", split = FALSE)
[17:39:56.804]         if (TRUE) {
[17:39:56.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.804]         }
[17:39:56.804]         else {
[17:39:56.804]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.804]         }
[17:39:56.804]         base::close(...future.stdout)
[17:39:56.804]         ...future.stdout <- NULL
[17:39:56.804]     }
[17:39:56.804]     ...future.result$conditions <- ...future.conditions
[17:39:56.804]     ...future.result$finished <- base::Sys.time()
[17:39:56.804]     ...future.result
[17:39:56.804] }
[17:39:56.806] assign_globals() ...
[17:39:56.807] List of 2
[17:39:56.807]  $ a : num 1
[17:39:56.807]  $ ii: int 2
[17:39:56.807]  - attr(*, "where")=List of 2
[17:39:56.807]   ..$ a :<environment: R_EmptyEnv> 
[17:39:56.807]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.807]  - attr(*, "resolved")= logi TRUE
[17:39:56.807]  - attr(*, "total_size")= num 112
[17:39:56.807]  - attr(*, "already-done")= logi TRUE
[17:39:56.811] - copied ‘a’ to environment
[17:39:56.811] - copied ‘ii’ to environment
[17:39:56.811] assign_globals() ... done
[17:39:56.811] requestCore(): workers = 2
[17:39:56.813] MulticoreFuture started
[17:39:56.814] - Launch lazy future ... done
[17:39:56.814] run() for ‘MulticoreFuture’ ... done
[17:39:56.814] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.815] getGlobalsAndPackages() ...
[17:39:56.815] List of future strategies:
[17:39:56.815] 1. sequential:
[17:39:56.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.815]    - tweaked: FALSE
[17:39:56.815]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.816] Searching for globals...
[17:39:56.816] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.818] plan(): Setting new future strategy stack:
[17:39:56.818] List of future strategies:
[17:39:56.818] 1. multicore:
[17:39:56.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.818]    - tweaked: FALSE
[17:39:56.818]    - call: plan(strategy)
[17:39:56.819] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.819] Searching for globals ... DONE
[17:39:56.819] Resolving globals: TRUE
[17:39:56.820] Resolving any globals that are futures ...
[17:39:56.820] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.820] Resolving any globals that are futures ... DONE
[17:39:56.821] Resolving futures part of globals (recursively) ...
[17:39:56.821] resolve() on list ...
[17:39:56.821]  recursive: 99
[17:39:56.822]  length: 2
[17:39:56.822]  elements: ‘a’, ‘ii’
[17:39:56.822]  length: 1 (resolved future 1)
[17:39:56.822]  length: 0 (resolved future 2)
[17:39:56.822] resolve() on list ... DONE
[17:39:56.822] - globals: [2] ‘a’, ‘ii’
[17:39:56.822] plan(): nbrOfWorkers() = 2
[17:39:56.823] Resolving futures part of globals (recursively) ... DONE
[17:39:56.823] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:56.823] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.824] - globals: [2] ‘a’, ‘ii’
[17:39:56.824] 
[17:39:56.824] getGlobalsAndPackages() ... DONE
[17:39:56.824] run() for ‘Future’ ...
[17:39:56.825] - state: ‘created’
[17:39:56.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.832] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.833]   - Field: ‘label’
[17:39:56.834]   - Field: ‘local’
[17:39:56.834]   - Field: ‘owner’
[17:39:56.834]   - Field: ‘envir’
[17:39:56.834]   - Field: ‘workers’
[17:39:56.835]   - Field: ‘packages’
[17:39:56.835]   - Field: ‘gc’
[17:39:56.835]   - Field: ‘job’
[17:39:56.835]   - Field: ‘conditions’
[17:39:56.836]   - Field: ‘expr’
[17:39:56.836]   - Field: ‘uuid’
[17:39:56.836]   - Field: ‘seed’
[17:39:56.836]   - Field: ‘version’
[17:39:56.837]   - Field: ‘result’
[17:39:56.837]   - Field: ‘asynchronous’
[17:39:56.837]   - Field: ‘calls’
[17:39:56.837]   - Field: ‘globals’
[17:39:56.837]   - Field: ‘stdout’
[17:39:56.837]   - Field: ‘earlySignal’
[17:39:56.837]   - Field: ‘lazy’
[17:39:56.838]   - Field: ‘state’
[17:39:56.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.838] - Launch lazy future ...
[17:39:56.838] Packages needed by the future expression (n = 0): <none>
[17:39:56.839] Packages needed by future strategies (n = 0): <none>
[17:39:56.839] {
[17:39:56.839]     {
[17:39:56.839]         {
[17:39:56.839]             ...future.startTime <- base::Sys.time()
[17:39:56.839]             {
[17:39:56.839]                 {
[17:39:56.839]                   {
[17:39:56.839]                     {
[17:39:56.839]                       base::local({
[17:39:56.839]                         has_future <- base::requireNamespace("future", 
[17:39:56.839]                           quietly = TRUE)
[17:39:56.839]                         if (has_future) {
[17:39:56.839]                           ns <- base::getNamespace("future")
[17:39:56.839]                           version <- ns[[".package"]][["version"]]
[17:39:56.839]                           if (is.null(version)) 
[17:39:56.839]                             version <- utils::packageVersion("future")
[17:39:56.839]                         }
[17:39:56.839]                         else {
[17:39:56.839]                           version <- NULL
[17:39:56.839]                         }
[17:39:56.839]                         if (!has_future || version < "1.8.0") {
[17:39:56.839]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.839]                             "", base::R.version$version.string), 
[17:39:56.839]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.839]                               "release", "version")], collapse = " "), 
[17:39:56.839]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.839]                             info)
[17:39:56.839]                           info <- base::paste(info, collapse = "; ")
[17:39:56.839]                           if (!has_future) {
[17:39:56.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.839]                               info)
[17:39:56.839]                           }
[17:39:56.839]                           else {
[17:39:56.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.839]                               info, version)
[17:39:56.839]                           }
[17:39:56.839]                           base::stop(msg)
[17:39:56.839]                         }
[17:39:56.839]                       })
[17:39:56.839]                     }
[17:39:56.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.839]                     base::options(mc.cores = 1L)
[17:39:56.839]                   }
[17:39:56.839]                   ...future.strategy.old <- future::plan("list")
[17:39:56.839]                   options(future.plan = NULL)
[17:39:56.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.839]                 }
[17:39:56.839]                 ...future.workdir <- getwd()
[17:39:56.839]             }
[17:39:56.839]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.839]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.839]         }
[17:39:56.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.839]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.839]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.839]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.839]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.839]             base::names(...future.oldOptions))
[17:39:56.839]     }
[17:39:56.839]     if (FALSE) {
[17:39:56.839]     }
[17:39:56.839]     else {
[17:39:56.839]         if (TRUE) {
[17:39:56.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.839]                 open = "w")
[17:39:56.839]         }
[17:39:56.839]         else {
[17:39:56.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.839]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.839]         }
[17:39:56.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.839]             base::sink(type = "output", split = FALSE)
[17:39:56.839]             base::close(...future.stdout)
[17:39:56.839]         }, add = TRUE)
[17:39:56.839]     }
[17:39:56.839]     ...future.frame <- base::sys.nframe()
[17:39:56.839]     ...future.conditions <- base::list()
[17:39:56.839]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.839]     if (FALSE) {
[17:39:56.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.839]     }
[17:39:56.839]     ...future.result <- base::tryCatch({
[17:39:56.839]         base::withCallingHandlers({
[17:39:56.839]             ...future.value <- base::withVisible(base::local({
[17:39:56.839]                 withCallingHandlers({
[17:39:56.839]                   {
[17:39:56.839]                     b <- a * ii
[17:39:56.839]                     a <- 0
[17:39:56.839]                     b
[17:39:56.839]                   }
[17:39:56.839]                 }, immediateCondition = function(cond) {
[17:39:56.839]                   save_rds <- function (object, pathname, ...) 
[17:39:56.839]                   {
[17:39:56.839]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.839]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.839]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.839]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.839]                         fi_tmp[["mtime"]])
[17:39:56.839]                     }
[17:39:56.839]                     tryCatch({
[17:39:56.839]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.839]                     }, error = function(ex) {
[17:39:56.839]                       msg <- conditionMessage(ex)
[17:39:56.839]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.839]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.839]                         fi_tmp[["mtime"]], msg)
[17:39:56.839]                       ex$message <- msg
[17:39:56.839]                       stop(ex)
[17:39:56.839]                     })
[17:39:56.839]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.839]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.839]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.839]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.839]                       fi <- file.info(pathname)
[17:39:56.839]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.839]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.839]                         fi[["size"]], fi[["mtime"]])
[17:39:56.839]                       stop(msg)
[17:39:56.839]                     }
[17:39:56.839]                     invisible(pathname)
[17:39:56.839]                   }
[17:39:56.839]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.839]                     rootPath = tempdir()) 
[17:39:56.839]                   {
[17:39:56.839]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.839]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.839]                       tmpdir = path, fileext = ".rds")
[17:39:56.839]                     save_rds(obj, file)
[17:39:56.839]                   }
[17:39:56.839]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.839]                   {
[17:39:56.839]                     inherits <- base::inherits
[17:39:56.839]                     invokeRestart <- base::invokeRestart
[17:39:56.839]                     is.null <- base::is.null
[17:39:56.839]                     muffled <- FALSE
[17:39:56.839]                     if (inherits(cond, "message")) {
[17:39:56.839]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.839]                       if (muffled) 
[17:39:56.839]                         invokeRestart("muffleMessage")
[17:39:56.839]                     }
[17:39:56.839]                     else if (inherits(cond, "warning")) {
[17:39:56.839]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.839]                       if (muffled) 
[17:39:56.839]                         invokeRestart("muffleWarning")
[17:39:56.839]                     }
[17:39:56.839]                     else if (inherits(cond, "condition")) {
[17:39:56.839]                       if (!is.null(pattern)) {
[17:39:56.839]                         computeRestarts <- base::computeRestarts
[17:39:56.839]                         grepl <- base::grepl
[17:39:56.839]                         restarts <- computeRestarts(cond)
[17:39:56.839]                         for (restart in restarts) {
[17:39:56.839]                           name <- restart$name
[17:39:56.839]                           if (is.null(name)) 
[17:39:56.839]                             next
[17:39:56.839]                           if (!grepl(pattern, name)) 
[17:39:56.839]                             next
[17:39:56.839]                           invokeRestart(restart)
[17:39:56.839]                           muffled <- TRUE
[17:39:56.839]                           break
[17:39:56.839]                         }
[17:39:56.839]                       }
[17:39:56.839]                     }
[17:39:56.839]                     invisible(muffled)
[17:39:56.839]                   }
[17:39:56.839]                   muffleCondition(cond)
[17:39:56.839]                 })
[17:39:56.839]             }))
[17:39:56.839]             future::FutureResult(value = ...future.value$value, 
[17:39:56.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.839]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.839]                     ...future.globalenv.names))
[17:39:56.839]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.839]         }, condition = base::local({
[17:39:56.839]             c <- base::c
[17:39:56.839]             inherits <- base::inherits
[17:39:56.839]             invokeRestart <- base::invokeRestart
[17:39:56.839]             length <- base::length
[17:39:56.839]             list <- base::list
[17:39:56.839]             seq.int <- base::seq.int
[17:39:56.839]             signalCondition <- base::signalCondition
[17:39:56.839]             sys.calls <- base::sys.calls
[17:39:56.839]             `[[` <- base::`[[`
[17:39:56.839]             `+` <- base::`+`
[17:39:56.839]             `<<-` <- base::`<<-`
[17:39:56.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.839]                   3L)]
[17:39:56.839]             }
[17:39:56.839]             function(cond) {
[17:39:56.839]                 is_error <- inherits(cond, "error")
[17:39:56.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.839]                   NULL)
[17:39:56.839]                 if (is_error) {
[17:39:56.839]                   sessionInformation <- function() {
[17:39:56.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.839]                       search = base::search(), system = base::Sys.info())
[17:39:56.839]                   }
[17:39:56.839]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.839]                     cond$call), session = sessionInformation(), 
[17:39:56.839]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.839]                   signalCondition(cond)
[17:39:56.839]                 }
[17:39:56.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.839]                 "immediateCondition"))) {
[17:39:56.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.839]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.839]                   if (TRUE && !signal) {
[17:39:56.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.839]                     {
[17:39:56.839]                       inherits <- base::inherits
[17:39:56.839]                       invokeRestart <- base::invokeRestart
[17:39:56.839]                       is.null <- base::is.null
[17:39:56.839]                       muffled <- FALSE
[17:39:56.839]                       if (inherits(cond, "message")) {
[17:39:56.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.839]                         if (muffled) 
[17:39:56.839]                           invokeRestart("muffleMessage")
[17:39:56.839]                       }
[17:39:56.839]                       else if (inherits(cond, "warning")) {
[17:39:56.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.839]                         if (muffled) 
[17:39:56.839]                           invokeRestart("muffleWarning")
[17:39:56.839]                       }
[17:39:56.839]                       else if (inherits(cond, "condition")) {
[17:39:56.839]                         if (!is.null(pattern)) {
[17:39:56.839]                           computeRestarts <- base::computeRestarts
[17:39:56.839]                           grepl <- base::grepl
[17:39:56.839]                           restarts <- computeRestarts(cond)
[17:39:56.839]                           for (restart in restarts) {
[17:39:56.839]                             name <- restart$name
[17:39:56.839]                             if (is.null(name)) 
[17:39:56.839]                               next
[17:39:56.839]                             if (!grepl(pattern, name)) 
[17:39:56.839]                               next
[17:39:56.839]                             invokeRestart(restart)
[17:39:56.839]                             muffled <- TRUE
[17:39:56.839]                             break
[17:39:56.839]                           }
[17:39:56.839]                         }
[17:39:56.839]                       }
[17:39:56.839]                       invisible(muffled)
[17:39:56.839]                     }
[17:39:56.839]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.839]                   }
[17:39:56.839]                 }
[17:39:56.839]                 else {
[17:39:56.839]                   if (TRUE) {
[17:39:56.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.839]                     {
[17:39:56.839]                       inherits <- base::inherits
[17:39:56.839]                       invokeRestart <- base::invokeRestart
[17:39:56.839]                       is.null <- base::is.null
[17:39:56.839]                       muffled <- FALSE
[17:39:56.839]                       if (inherits(cond, "message")) {
[17:39:56.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.839]                         if (muffled) 
[17:39:56.839]                           invokeRestart("muffleMessage")
[17:39:56.839]                       }
[17:39:56.839]                       else if (inherits(cond, "warning")) {
[17:39:56.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.839]                         if (muffled) 
[17:39:56.839]                           invokeRestart("muffleWarning")
[17:39:56.839]                       }
[17:39:56.839]                       else if (inherits(cond, "condition")) {
[17:39:56.839]                         if (!is.null(pattern)) {
[17:39:56.839]                           computeRestarts <- base::computeRestarts
[17:39:56.839]                           grepl <- base::grepl
[17:39:56.839]                           restarts <- computeRestarts(cond)
[17:39:56.839]                           for (restart in restarts) {
[17:39:56.839]                             name <- restart$name
[17:39:56.839]                             if (is.null(name)) 
[17:39:56.839]                               next
[17:39:56.839]                             if (!grepl(pattern, name)) 
[17:39:56.839]                               next
[17:39:56.839]                             invokeRestart(restart)
[17:39:56.839]                             muffled <- TRUE
[17:39:56.839]                             break
[17:39:56.839]                           }
[17:39:56.839]                         }
[17:39:56.839]                       }
[17:39:56.839]                       invisible(muffled)
[17:39:56.839]                     }
[17:39:56.839]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.839]                   }
[17:39:56.839]                 }
[17:39:56.839]             }
[17:39:56.839]         }))
[17:39:56.839]     }, error = function(ex) {
[17:39:56.839]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.839]                 ...future.rng), started = ...future.startTime, 
[17:39:56.839]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.839]             version = "1.8"), class = "FutureResult")
[17:39:56.839]     }, finally = {
[17:39:56.839]         if (!identical(...future.workdir, getwd())) 
[17:39:56.839]             setwd(...future.workdir)
[17:39:56.839]         {
[17:39:56.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.839]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.839]             }
[17:39:56.839]             base::options(...future.oldOptions)
[17:39:56.839]             if (.Platform$OS.type == "windows") {
[17:39:56.839]                 old_names <- names(...future.oldEnvVars)
[17:39:56.839]                 envs <- base::Sys.getenv()
[17:39:56.839]                 names <- names(envs)
[17:39:56.839]                 common <- intersect(names, old_names)
[17:39:56.839]                 added <- setdiff(names, old_names)
[17:39:56.839]                 removed <- setdiff(old_names, names)
[17:39:56.839]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.839]                   envs[common]]
[17:39:56.839]                 NAMES <- toupper(changed)
[17:39:56.839]                 args <- list()
[17:39:56.839]                 for (kk in seq_along(NAMES)) {
[17:39:56.839]                   name <- changed[[kk]]
[17:39:56.839]                   NAME <- NAMES[[kk]]
[17:39:56.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.839]                     next
[17:39:56.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.839]                 }
[17:39:56.839]                 NAMES <- toupper(added)
[17:39:56.839]                 for (kk in seq_along(NAMES)) {
[17:39:56.839]                   name <- added[[kk]]
[17:39:56.839]                   NAME <- NAMES[[kk]]
[17:39:56.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.839]                     next
[17:39:56.839]                   args[[name]] <- ""
[17:39:56.839]                 }
[17:39:56.839]                 NAMES <- toupper(removed)
[17:39:56.839]                 for (kk in seq_along(NAMES)) {
[17:39:56.839]                   name <- removed[[kk]]
[17:39:56.839]                   NAME <- NAMES[[kk]]
[17:39:56.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.839]                     next
[17:39:56.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.839]                 }
[17:39:56.839]                 if (length(args) > 0) 
[17:39:56.839]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.839]             }
[17:39:56.839]             else {
[17:39:56.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.839]             }
[17:39:56.839]             {
[17:39:56.839]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.839]                   0L) {
[17:39:56.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.839]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.839]                   base::options(opts)
[17:39:56.839]                 }
[17:39:56.839]                 {
[17:39:56.839]                   {
[17:39:56.839]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.839]                     NULL
[17:39:56.839]                   }
[17:39:56.839]                   options(future.plan = NULL)
[17:39:56.839]                   if (is.na(NA_character_)) 
[17:39:56.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.839]                     .init = FALSE)
[17:39:56.839]                 }
[17:39:56.839]             }
[17:39:56.839]         }
[17:39:56.839]     })
[17:39:56.839]     if (TRUE) {
[17:39:56.839]         base::sink(type = "output", split = FALSE)
[17:39:56.839]         if (TRUE) {
[17:39:56.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.839]         }
[17:39:56.839]         else {
[17:39:56.839]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.839]         }
[17:39:56.839]         base::close(...future.stdout)
[17:39:56.839]         ...future.stdout <- NULL
[17:39:56.839]     }
[17:39:56.839]     ...future.result$conditions <- ...future.conditions
[17:39:56.839]     ...future.result$finished <- base::Sys.time()
[17:39:56.839]     ...future.result
[17:39:56.839] }
[17:39:56.842] assign_globals() ...
[17:39:56.842] List of 2
[17:39:56.842]  $ a : num 1
[17:39:56.842]  $ ii: int 3
[17:39:56.842]  - attr(*, "where")=List of 2
[17:39:56.842]   ..$ a :<environment: R_EmptyEnv> 
[17:39:56.842]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.842]  - attr(*, "resolved")= logi TRUE
[17:39:56.842]  - attr(*, "total_size")= num 112
[17:39:56.842]  - attr(*, "already-done")= logi TRUE
[17:39:56.846] - copied ‘a’ to environment
[17:39:56.847] - copied ‘ii’ to environment
[17:39:56.847] assign_globals() ... done
[17:39:56.847] requestCore(): workers = 2
[17:39:56.847] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:56.867] result() for MulticoreFuture ...
[17:39:56.875] result() for MulticoreFuture ...
[17:39:56.875] result() for MulticoreFuture ... done
[17:39:56.875] result() for MulticoreFuture ... done
[17:39:56.876] result() for MulticoreFuture ...
[17:39:56.876] result() for MulticoreFuture ... done
[17:39:56.879] MulticoreFuture started
[17:39:56.879] - Launch lazy future ... done
[17:39:56.879] run() for ‘MulticoreFuture’ ... done
[17:39:56.880] plan(): Setting new future strategy stack:
[17:39:56.880] result() for MulticoreFuture ...
[17:39:56.880] result() for MulticoreFuture ... done
[17:39:56.880] result() for MulticoreFuture ...
[17:39:56.881] result() for MulticoreFuture ... done
[17:39:56.880] List of future strategies:
[17:39:56.880] 1. sequential:
[17:39:56.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.880]    - tweaked: FALSE
[17:39:56.880]    - call: NULL
[17:39:56.881] result() for MulticoreFuture ...
[17:39:56.881] plan(): nbrOfWorkers() = 1
[17:39:56.882] result() for MulticoreFuture ...
[17:39:56.883] result() for MulticoreFuture ... done
[17:39:56.883] plan(): Setting new future strategy stack:
[17:39:56.883] result() for MulticoreFuture ... done
[17:39:56.884] result() for MulticoreFuture ...
[17:39:56.883] List of future strategies:
[17:39:56.883] 1. multicore:
[17:39:56.883]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.883]    - tweaked: FALSE
[17:39:56.883]    - call: plan(strategy)
[17:39:56.884] result() for MulticoreFuture ... done
[17:39:56.884] result() for MulticoreFuture ...
[17:39:56.888] plan(): nbrOfWorkers() = 2
[17:39:56.889] result() for MulticoreFuture ...
[17:39:56.890] result() for MulticoreFuture ... done
[17:39:56.890] result() for MulticoreFuture ... done
[17:39:56.890] result() for MulticoreFuture ...
[17:39:56.890] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.891] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.892] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.895] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.895] Searching for globals ... DONE
[17:39:56.895] Resolving globals: TRUE
[17:39:56.896] Resolving any globals that are futures ...
[17:39:56.896] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.896] Resolving any globals that are futures ... DONE
[17:39:56.896] Resolving futures part of globals (recursively) ...
[17:39:56.897] resolve() on list ...
[17:39:56.897]  recursive: 99
[17:39:56.897]  length: 2
[17:39:56.897]  elements: ‘a’, ‘ii’
[17:39:56.897]  length: 1 (resolved future 1)
[17:39:56.897]  length: 0 (resolved future 2)
[17:39:56.897] resolve() on list ... DONE
[17:39:56.897] - globals: [2] ‘a’, ‘ii’
[17:39:56.898] Resolving futures part of globals (recursively) ... DONE
[17:39:56.898] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:56.898] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.898] - globals: [2] ‘a’, ‘ii’
[17:39:56.899] 
[17:39:56.899] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.899] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.900] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.902] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.902] Searching for globals ... DONE
[17:39:56.902] Resolving globals: TRUE
[17:39:56.902] Resolving any globals that are futures ...
[17:39:56.902] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.902] Resolving any globals that are futures ... DONE
[17:39:56.903] Resolving futures part of globals (recursively) ...
[17:39:56.903] resolve() on list ...
[17:39:56.903]  recursive: 99
[17:39:56.903]  length: 2
[17:39:56.903]  elements: ‘a’, ‘ii’
[17:39:56.903]  length: 1 (resolved future 1)
[17:39:56.904]  length: 0 (resolved future 2)
[17:39:56.904] resolve() on list ... DONE
[17:39:56.904] - globals: [2] ‘a’, ‘ii’
[17:39:56.904] Resolving futures part of globals (recursively) ... DONE
[17:39:56.904] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:56.904] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.905] - globals: [2] ‘a’, ‘ii’
[17:39:56.905] 
[17:39:56.905] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:56.905] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:56.906] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:56.908] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.908] Searching for globals ... DONE
[17:39:56.908] Resolving globals: TRUE
[17:39:56.908] Resolving any globals that are futures ...
[17:39:56.908] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:56.908] Resolving any globals that are futures ... DONE
[17:39:56.909] Resolving futures part of globals (recursively) ...
[17:39:56.909] resolve() on list ...
[17:39:56.909]  recursive: 99
[17:39:56.909]  length: 2
[17:39:56.909]  elements: ‘a’, ‘ii’
[17:39:56.909]  length: 1 (resolved future 1)
[17:39:56.909]  length: 0 (resolved future 2)
[17:39:56.909] resolve() on list ... DONE
[17:39:56.910] - globals: [2] ‘a’, ‘ii’
[17:39:56.910] Resolving futures part of globals (recursively) ... DONE
[17:39:56.910] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:56.910] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:56.910] - globals: [2] ‘a’, ‘ii’
[17:39:56.910] 
[17:39:56.910] getGlobalsAndPackages() ... DONE
[17:39:56.911] run() for ‘Future’ ...
[17:39:56.911] - state: ‘created’
[17:39:56.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.915]   - Field: ‘label’
[17:39:56.915]   - Field: ‘local’
[17:39:56.915]   - Field: ‘owner’
[17:39:56.915]   - Field: ‘envir’
[17:39:56.916]   - Field: ‘workers’
[17:39:56.916]   - Field: ‘packages’
[17:39:56.916]   - Field: ‘gc’
[17:39:56.916]   - Field: ‘job’
[17:39:56.916]   - Field: ‘conditions’
[17:39:56.916]   - Field: ‘expr’
[17:39:56.916]   - Field: ‘uuid’
[17:39:56.916]   - Field: ‘seed’
[17:39:56.918]   - Field: ‘version’
[17:39:56.918]   - Field: ‘result’
[17:39:56.918]   - Field: ‘asynchronous’
[17:39:56.918]   - Field: ‘calls’
[17:39:56.919]   - Field: ‘globals’
[17:39:56.919]   - Field: ‘stdout’
[17:39:56.919]   - Field: ‘earlySignal’
[17:39:56.919]   - Field: ‘lazy’
[17:39:56.919]   - Field: ‘state’
[17:39:56.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.919] - Launch lazy future ...
[17:39:56.919] Packages needed by the future expression (n = 0): <none>
[17:39:56.920] Packages needed by future strategies (n = 0): <none>
[17:39:56.920] {
[17:39:56.920]     {
[17:39:56.920]         {
[17:39:56.920]             ...future.startTime <- base::Sys.time()
[17:39:56.920]             {
[17:39:56.920]                 {
[17:39:56.920]                   {
[17:39:56.920]                     {
[17:39:56.920]                       base::local({
[17:39:56.920]                         has_future <- base::requireNamespace("future", 
[17:39:56.920]                           quietly = TRUE)
[17:39:56.920]                         if (has_future) {
[17:39:56.920]                           ns <- base::getNamespace("future")
[17:39:56.920]                           version <- ns[[".package"]][["version"]]
[17:39:56.920]                           if (is.null(version)) 
[17:39:56.920]                             version <- utils::packageVersion("future")
[17:39:56.920]                         }
[17:39:56.920]                         else {
[17:39:56.920]                           version <- NULL
[17:39:56.920]                         }
[17:39:56.920]                         if (!has_future || version < "1.8.0") {
[17:39:56.920]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.920]                             "", base::R.version$version.string), 
[17:39:56.920]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.920]                               "release", "version")], collapse = " "), 
[17:39:56.920]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.920]                             info)
[17:39:56.920]                           info <- base::paste(info, collapse = "; ")
[17:39:56.920]                           if (!has_future) {
[17:39:56.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.920]                               info)
[17:39:56.920]                           }
[17:39:56.920]                           else {
[17:39:56.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.920]                               info, version)
[17:39:56.920]                           }
[17:39:56.920]                           base::stop(msg)
[17:39:56.920]                         }
[17:39:56.920]                       })
[17:39:56.920]                     }
[17:39:56.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.920]                     base::options(mc.cores = 1L)
[17:39:56.920]                   }
[17:39:56.920]                   ...future.strategy.old <- future::plan("list")
[17:39:56.920]                   options(future.plan = NULL)
[17:39:56.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.920]                 }
[17:39:56.920]                 ...future.workdir <- getwd()
[17:39:56.920]             }
[17:39:56.920]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.920]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.920]         }
[17:39:56.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.920]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.920]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.920]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.920]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.920]             base::names(...future.oldOptions))
[17:39:56.920]     }
[17:39:56.920]     if (FALSE) {
[17:39:56.920]     }
[17:39:56.920]     else {
[17:39:56.920]         if (TRUE) {
[17:39:56.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.920]                 open = "w")
[17:39:56.920]         }
[17:39:56.920]         else {
[17:39:56.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.920]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.920]         }
[17:39:56.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.920]             base::sink(type = "output", split = FALSE)
[17:39:56.920]             base::close(...future.stdout)
[17:39:56.920]         }, add = TRUE)
[17:39:56.920]     }
[17:39:56.920]     ...future.frame <- base::sys.nframe()
[17:39:56.920]     ...future.conditions <- base::list()
[17:39:56.920]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.920]     if (FALSE) {
[17:39:56.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.920]     }
[17:39:56.920]     ...future.result <- base::tryCatch({
[17:39:56.920]         base::withCallingHandlers({
[17:39:56.920]             ...future.value <- base::withVisible(base::local({
[17:39:56.920]                 withCallingHandlers({
[17:39:56.920]                   {
[17:39:56.920]                     b <- a * ii
[17:39:56.920]                     a <- 0
[17:39:56.920]                     b
[17:39:56.920]                   }
[17:39:56.920]                 }, immediateCondition = function(cond) {
[17:39:56.920]                   save_rds <- function (object, pathname, ...) 
[17:39:56.920]                   {
[17:39:56.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.920]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.920]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.920]                         fi_tmp[["mtime"]])
[17:39:56.920]                     }
[17:39:56.920]                     tryCatch({
[17:39:56.920]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.920]                     }, error = function(ex) {
[17:39:56.920]                       msg <- conditionMessage(ex)
[17:39:56.920]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.920]                         fi_tmp[["mtime"]], msg)
[17:39:56.920]                       ex$message <- msg
[17:39:56.920]                       stop(ex)
[17:39:56.920]                     })
[17:39:56.920]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.920]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.920]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.920]                       fi <- file.info(pathname)
[17:39:56.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.920]                         fi[["size"]], fi[["mtime"]])
[17:39:56.920]                       stop(msg)
[17:39:56.920]                     }
[17:39:56.920]                     invisible(pathname)
[17:39:56.920]                   }
[17:39:56.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.920]                     rootPath = tempdir()) 
[17:39:56.920]                   {
[17:39:56.920]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.920]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.920]                       tmpdir = path, fileext = ".rds")
[17:39:56.920]                     save_rds(obj, file)
[17:39:56.920]                   }
[17:39:56.920]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.920]                   {
[17:39:56.920]                     inherits <- base::inherits
[17:39:56.920]                     invokeRestart <- base::invokeRestart
[17:39:56.920]                     is.null <- base::is.null
[17:39:56.920]                     muffled <- FALSE
[17:39:56.920]                     if (inherits(cond, "message")) {
[17:39:56.920]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.920]                       if (muffled) 
[17:39:56.920]                         invokeRestart("muffleMessage")
[17:39:56.920]                     }
[17:39:56.920]                     else if (inherits(cond, "warning")) {
[17:39:56.920]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.920]                       if (muffled) 
[17:39:56.920]                         invokeRestart("muffleWarning")
[17:39:56.920]                     }
[17:39:56.920]                     else if (inherits(cond, "condition")) {
[17:39:56.920]                       if (!is.null(pattern)) {
[17:39:56.920]                         computeRestarts <- base::computeRestarts
[17:39:56.920]                         grepl <- base::grepl
[17:39:56.920]                         restarts <- computeRestarts(cond)
[17:39:56.920]                         for (restart in restarts) {
[17:39:56.920]                           name <- restart$name
[17:39:56.920]                           if (is.null(name)) 
[17:39:56.920]                             next
[17:39:56.920]                           if (!grepl(pattern, name)) 
[17:39:56.920]                             next
[17:39:56.920]                           invokeRestart(restart)
[17:39:56.920]                           muffled <- TRUE
[17:39:56.920]                           break
[17:39:56.920]                         }
[17:39:56.920]                       }
[17:39:56.920]                     }
[17:39:56.920]                     invisible(muffled)
[17:39:56.920]                   }
[17:39:56.920]                   muffleCondition(cond)
[17:39:56.920]                 })
[17:39:56.920]             }))
[17:39:56.920]             future::FutureResult(value = ...future.value$value, 
[17:39:56.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.920]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.920]                     ...future.globalenv.names))
[17:39:56.920]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.920]         }, condition = base::local({
[17:39:56.920]             c <- base::c
[17:39:56.920]             inherits <- base::inherits
[17:39:56.920]             invokeRestart <- base::invokeRestart
[17:39:56.920]             length <- base::length
[17:39:56.920]             list <- base::list
[17:39:56.920]             seq.int <- base::seq.int
[17:39:56.920]             signalCondition <- base::signalCondition
[17:39:56.920]             sys.calls <- base::sys.calls
[17:39:56.920]             `[[` <- base::`[[`
[17:39:56.920]             `+` <- base::`+`
[17:39:56.920]             `<<-` <- base::`<<-`
[17:39:56.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.920]                   3L)]
[17:39:56.920]             }
[17:39:56.920]             function(cond) {
[17:39:56.920]                 is_error <- inherits(cond, "error")
[17:39:56.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.920]                   NULL)
[17:39:56.920]                 if (is_error) {
[17:39:56.920]                   sessionInformation <- function() {
[17:39:56.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.920]                       search = base::search(), system = base::Sys.info())
[17:39:56.920]                   }
[17:39:56.920]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.920]                     cond$call), session = sessionInformation(), 
[17:39:56.920]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.920]                   signalCondition(cond)
[17:39:56.920]                 }
[17:39:56.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.920]                 "immediateCondition"))) {
[17:39:56.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.920]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.920]                   if (TRUE && !signal) {
[17:39:56.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.920]                     {
[17:39:56.920]                       inherits <- base::inherits
[17:39:56.920]                       invokeRestart <- base::invokeRestart
[17:39:56.920]                       is.null <- base::is.null
[17:39:56.920]                       muffled <- FALSE
[17:39:56.920]                       if (inherits(cond, "message")) {
[17:39:56.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.920]                         if (muffled) 
[17:39:56.920]                           invokeRestart("muffleMessage")
[17:39:56.920]                       }
[17:39:56.920]                       else if (inherits(cond, "warning")) {
[17:39:56.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.920]                         if (muffled) 
[17:39:56.920]                           invokeRestart("muffleWarning")
[17:39:56.920]                       }
[17:39:56.920]                       else if (inherits(cond, "condition")) {
[17:39:56.920]                         if (!is.null(pattern)) {
[17:39:56.920]                           computeRestarts <- base::computeRestarts
[17:39:56.920]                           grepl <- base::grepl
[17:39:56.920]                           restarts <- computeRestarts(cond)
[17:39:56.920]                           for (restart in restarts) {
[17:39:56.920]                             name <- restart$name
[17:39:56.920]                             if (is.null(name)) 
[17:39:56.920]                               next
[17:39:56.920]                             if (!grepl(pattern, name)) 
[17:39:56.920]                               next
[17:39:56.920]                             invokeRestart(restart)
[17:39:56.920]                             muffled <- TRUE
[17:39:56.920]                             break
[17:39:56.920]                           }
[17:39:56.920]                         }
[17:39:56.920]                       }
[17:39:56.920]                       invisible(muffled)
[17:39:56.920]                     }
[17:39:56.920]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.920]                   }
[17:39:56.920]                 }
[17:39:56.920]                 else {
[17:39:56.920]                   if (TRUE) {
[17:39:56.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.920]                     {
[17:39:56.920]                       inherits <- base::inherits
[17:39:56.920]                       invokeRestart <- base::invokeRestart
[17:39:56.920]                       is.null <- base::is.null
[17:39:56.920]                       muffled <- FALSE
[17:39:56.920]                       if (inherits(cond, "message")) {
[17:39:56.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.920]                         if (muffled) 
[17:39:56.920]                           invokeRestart("muffleMessage")
[17:39:56.920]                       }
[17:39:56.920]                       else if (inherits(cond, "warning")) {
[17:39:56.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.920]                         if (muffled) 
[17:39:56.920]                           invokeRestart("muffleWarning")
[17:39:56.920]                       }
[17:39:56.920]                       else if (inherits(cond, "condition")) {
[17:39:56.920]                         if (!is.null(pattern)) {
[17:39:56.920]                           computeRestarts <- base::computeRestarts
[17:39:56.920]                           grepl <- base::grepl
[17:39:56.920]                           restarts <- computeRestarts(cond)
[17:39:56.920]                           for (restart in restarts) {
[17:39:56.920]                             name <- restart$name
[17:39:56.920]                             if (is.null(name)) 
[17:39:56.920]                               next
[17:39:56.920]                             if (!grepl(pattern, name)) 
[17:39:56.920]                               next
[17:39:56.920]                             invokeRestart(restart)
[17:39:56.920]                             muffled <- TRUE
[17:39:56.920]                             break
[17:39:56.920]                           }
[17:39:56.920]                         }
[17:39:56.920]                       }
[17:39:56.920]                       invisible(muffled)
[17:39:56.920]                     }
[17:39:56.920]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.920]                   }
[17:39:56.920]                 }
[17:39:56.920]             }
[17:39:56.920]         }))
[17:39:56.920]     }, error = function(ex) {
[17:39:56.920]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.920]                 ...future.rng), started = ...future.startTime, 
[17:39:56.920]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.920]             version = "1.8"), class = "FutureResult")
[17:39:56.920]     }, finally = {
[17:39:56.920]         if (!identical(...future.workdir, getwd())) 
[17:39:56.920]             setwd(...future.workdir)
[17:39:56.920]         {
[17:39:56.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.920]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.920]             }
[17:39:56.920]             base::options(...future.oldOptions)
[17:39:56.920]             if (.Platform$OS.type == "windows") {
[17:39:56.920]                 old_names <- names(...future.oldEnvVars)
[17:39:56.920]                 envs <- base::Sys.getenv()
[17:39:56.920]                 names <- names(envs)
[17:39:56.920]                 common <- intersect(names, old_names)
[17:39:56.920]                 added <- setdiff(names, old_names)
[17:39:56.920]                 removed <- setdiff(old_names, names)
[17:39:56.920]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.920]                   envs[common]]
[17:39:56.920]                 NAMES <- toupper(changed)
[17:39:56.920]                 args <- list()
[17:39:56.920]                 for (kk in seq_along(NAMES)) {
[17:39:56.920]                   name <- changed[[kk]]
[17:39:56.920]                   NAME <- NAMES[[kk]]
[17:39:56.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.920]                     next
[17:39:56.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.920]                 }
[17:39:56.920]                 NAMES <- toupper(added)
[17:39:56.920]                 for (kk in seq_along(NAMES)) {
[17:39:56.920]                   name <- added[[kk]]
[17:39:56.920]                   NAME <- NAMES[[kk]]
[17:39:56.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.920]                     next
[17:39:56.920]                   args[[name]] <- ""
[17:39:56.920]                 }
[17:39:56.920]                 NAMES <- toupper(removed)
[17:39:56.920]                 for (kk in seq_along(NAMES)) {
[17:39:56.920]                   name <- removed[[kk]]
[17:39:56.920]                   NAME <- NAMES[[kk]]
[17:39:56.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.920]                     next
[17:39:56.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.920]                 }
[17:39:56.920]                 if (length(args) > 0) 
[17:39:56.920]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.920]             }
[17:39:56.920]             else {
[17:39:56.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.920]             }
[17:39:56.920]             {
[17:39:56.920]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.920]                   0L) {
[17:39:56.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.920]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.920]                   base::options(opts)
[17:39:56.920]                 }
[17:39:56.920]                 {
[17:39:56.920]                   {
[17:39:56.920]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.920]                     NULL
[17:39:56.920]                   }
[17:39:56.920]                   options(future.plan = NULL)
[17:39:56.920]                   if (is.na(NA_character_)) 
[17:39:56.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.920]                     .init = FALSE)
[17:39:56.920]                 }
[17:39:56.920]             }
[17:39:56.920]         }
[17:39:56.920]     })
[17:39:56.920]     if (TRUE) {
[17:39:56.920]         base::sink(type = "output", split = FALSE)
[17:39:56.920]         if (TRUE) {
[17:39:56.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.920]         }
[17:39:56.920]         else {
[17:39:56.920]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.920]         }
[17:39:56.920]         base::close(...future.stdout)
[17:39:56.920]         ...future.stdout <- NULL
[17:39:56.920]     }
[17:39:56.920]     ...future.result$conditions <- ...future.conditions
[17:39:56.920]     ...future.result$finished <- base::Sys.time()
[17:39:56.920]     ...future.result
[17:39:56.920] }
[17:39:56.922] assign_globals() ...
[17:39:56.923] List of 2
[17:39:56.923]  $ a : num 1
[17:39:56.923]  $ ii: int 1
[17:39:56.923]  - attr(*, "where")=List of 2
[17:39:56.923]   ..$ a :<environment: R_EmptyEnv> 
[17:39:56.923]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.923]  - attr(*, "resolved")= logi TRUE
[17:39:56.923]  - attr(*, "total_size")= num 112
[17:39:56.923]  - attr(*, "already-done")= logi TRUE
[17:39:56.926] - copied ‘a’ to environment
[17:39:56.926] - copied ‘ii’ to environment
[17:39:56.926] assign_globals() ... done
[17:39:56.926] requestCore(): workers = 2
[17:39:56.928] MulticoreFuture started
[17:39:56.929] - Launch lazy future ... done
[17:39:56.929] run() for ‘MulticoreFuture’ ... done
[17:39:56.929] plan(): Setting new future strategy stack:
[17:39:56.929] result() for MulticoreFuture ...
[17:39:56.929] List of future strategies:
[17:39:56.929] 1. sequential:
[17:39:56.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.929]    - tweaked: FALSE
[17:39:56.929]    - call: NULL
[17:39:56.931] plan(): nbrOfWorkers() = 1
[17:39:56.933] plan(): Setting new future strategy stack:
[17:39:56.934] List of future strategies:
[17:39:56.934] 1. multicore:
[17:39:56.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.934]    - tweaked: FALSE
[17:39:56.934]    - call: plan(strategy)
[17:39:56.939] plan(): nbrOfWorkers() = 2
[17:39:56.940] result() for MulticoreFuture ...
[17:39:56.940] result() for MulticoreFuture ... done
[17:39:56.941] result() for MulticoreFuture ... done
[17:39:56.941] result() for MulticoreFuture ...
[17:39:56.941] result() for MulticoreFuture ... done
[17:39:56.941] run() for ‘Future’ ...
[17:39:56.942] - state: ‘created’
[17:39:56.942] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.946] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.946]   - Field: ‘label’
[17:39:56.946]   - Field: ‘local’
[17:39:56.947]   - Field: ‘owner’
[17:39:56.947]   - Field: ‘envir’
[17:39:56.947]   - Field: ‘workers’
[17:39:56.947]   - Field: ‘packages’
[17:39:56.947]   - Field: ‘gc’
[17:39:56.947]   - Field: ‘job’
[17:39:56.947]   - Field: ‘conditions’
[17:39:56.947]   - Field: ‘expr’
[17:39:56.948]   - Field: ‘uuid’
[17:39:56.948]   - Field: ‘seed’
[17:39:56.948]   - Field: ‘version’
[17:39:56.948]   - Field: ‘result’
[17:39:56.948]   - Field: ‘asynchronous’
[17:39:56.948]   - Field: ‘calls’
[17:39:56.948]   - Field: ‘globals’
[17:39:56.948]   - Field: ‘stdout’
[17:39:56.949]   - Field: ‘earlySignal’
[17:39:56.949]   - Field: ‘lazy’
[17:39:56.949]   - Field: ‘state’
[17:39:56.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.949] - Launch lazy future ...
[17:39:56.949] Packages needed by the future expression (n = 0): <none>
[17:39:56.950] Packages needed by future strategies (n = 0): <none>
[17:39:56.950] {
[17:39:56.950]     {
[17:39:56.950]         {
[17:39:56.950]             ...future.startTime <- base::Sys.time()
[17:39:56.950]             {
[17:39:56.950]                 {
[17:39:56.950]                   {
[17:39:56.950]                     {
[17:39:56.950]                       base::local({
[17:39:56.950]                         has_future <- base::requireNamespace("future", 
[17:39:56.950]                           quietly = TRUE)
[17:39:56.950]                         if (has_future) {
[17:39:56.950]                           ns <- base::getNamespace("future")
[17:39:56.950]                           version <- ns[[".package"]][["version"]]
[17:39:56.950]                           if (is.null(version)) 
[17:39:56.950]                             version <- utils::packageVersion("future")
[17:39:56.950]                         }
[17:39:56.950]                         else {
[17:39:56.950]                           version <- NULL
[17:39:56.950]                         }
[17:39:56.950]                         if (!has_future || version < "1.8.0") {
[17:39:56.950]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.950]                             "", base::R.version$version.string), 
[17:39:56.950]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.950]                               "release", "version")], collapse = " "), 
[17:39:56.950]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.950]                             info)
[17:39:56.950]                           info <- base::paste(info, collapse = "; ")
[17:39:56.950]                           if (!has_future) {
[17:39:56.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.950]                               info)
[17:39:56.950]                           }
[17:39:56.950]                           else {
[17:39:56.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.950]                               info, version)
[17:39:56.950]                           }
[17:39:56.950]                           base::stop(msg)
[17:39:56.950]                         }
[17:39:56.950]                       })
[17:39:56.950]                     }
[17:39:56.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.950]                     base::options(mc.cores = 1L)
[17:39:56.950]                   }
[17:39:56.950]                   ...future.strategy.old <- future::plan("list")
[17:39:56.950]                   options(future.plan = NULL)
[17:39:56.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.950]                 }
[17:39:56.950]                 ...future.workdir <- getwd()
[17:39:56.950]             }
[17:39:56.950]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.950]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.950]         }
[17:39:56.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.950]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.950]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.950]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.950]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.950]             base::names(...future.oldOptions))
[17:39:56.950]     }
[17:39:56.950]     if (FALSE) {
[17:39:56.950]     }
[17:39:56.950]     else {
[17:39:56.950]         if (TRUE) {
[17:39:56.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.950]                 open = "w")
[17:39:56.950]         }
[17:39:56.950]         else {
[17:39:56.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.950]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.950]         }
[17:39:56.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.950]             base::sink(type = "output", split = FALSE)
[17:39:56.950]             base::close(...future.stdout)
[17:39:56.950]         }, add = TRUE)
[17:39:56.950]     }
[17:39:56.950]     ...future.frame <- base::sys.nframe()
[17:39:56.950]     ...future.conditions <- base::list()
[17:39:56.950]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.950]     if (FALSE) {
[17:39:56.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.950]     }
[17:39:56.950]     ...future.result <- base::tryCatch({
[17:39:56.950]         base::withCallingHandlers({
[17:39:56.950]             ...future.value <- base::withVisible(base::local({
[17:39:56.950]                 withCallingHandlers({
[17:39:56.950]                   {
[17:39:56.950]                     b <- a * ii
[17:39:56.950]                     a <- 0
[17:39:56.950]                     b
[17:39:56.950]                   }
[17:39:56.950]                 }, immediateCondition = function(cond) {
[17:39:56.950]                   save_rds <- function (object, pathname, ...) 
[17:39:56.950]                   {
[17:39:56.950]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.950]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.950]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.950]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.950]                         fi_tmp[["mtime"]])
[17:39:56.950]                     }
[17:39:56.950]                     tryCatch({
[17:39:56.950]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.950]                     }, error = function(ex) {
[17:39:56.950]                       msg <- conditionMessage(ex)
[17:39:56.950]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.950]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.950]                         fi_tmp[["mtime"]], msg)
[17:39:56.950]                       ex$message <- msg
[17:39:56.950]                       stop(ex)
[17:39:56.950]                     })
[17:39:56.950]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.950]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.950]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.950]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.950]                       fi <- file.info(pathname)
[17:39:56.950]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.950]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.950]                         fi[["size"]], fi[["mtime"]])
[17:39:56.950]                       stop(msg)
[17:39:56.950]                     }
[17:39:56.950]                     invisible(pathname)
[17:39:56.950]                   }
[17:39:56.950]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.950]                     rootPath = tempdir()) 
[17:39:56.950]                   {
[17:39:56.950]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.950]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.950]                       tmpdir = path, fileext = ".rds")
[17:39:56.950]                     save_rds(obj, file)
[17:39:56.950]                   }
[17:39:56.950]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.950]                   {
[17:39:56.950]                     inherits <- base::inherits
[17:39:56.950]                     invokeRestart <- base::invokeRestart
[17:39:56.950]                     is.null <- base::is.null
[17:39:56.950]                     muffled <- FALSE
[17:39:56.950]                     if (inherits(cond, "message")) {
[17:39:56.950]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.950]                       if (muffled) 
[17:39:56.950]                         invokeRestart("muffleMessage")
[17:39:56.950]                     }
[17:39:56.950]                     else if (inherits(cond, "warning")) {
[17:39:56.950]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.950]                       if (muffled) 
[17:39:56.950]                         invokeRestart("muffleWarning")
[17:39:56.950]                     }
[17:39:56.950]                     else if (inherits(cond, "condition")) {
[17:39:56.950]                       if (!is.null(pattern)) {
[17:39:56.950]                         computeRestarts <- base::computeRestarts
[17:39:56.950]                         grepl <- base::grepl
[17:39:56.950]                         restarts <- computeRestarts(cond)
[17:39:56.950]                         for (restart in restarts) {
[17:39:56.950]                           name <- restart$name
[17:39:56.950]                           if (is.null(name)) 
[17:39:56.950]                             next
[17:39:56.950]                           if (!grepl(pattern, name)) 
[17:39:56.950]                             next
[17:39:56.950]                           invokeRestart(restart)
[17:39:56.950]                           muffled <- TRUE
[17:39:56.950]                           break
[17:39:56.950]                         }
[17:39:56.950]                       }
[17:39:56.950]                     }
[17:39:56.950]                     invisible(muffled)
[17:39:56.950]                   }
[17:39:56.950]                   muffleCondition(cond)
[17:39:56.950]                 })
[17:39:56.950]             }))
[17:39:56.950]             future::FutureResult(value = ...future.value$value, 
[17:39:56.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.950]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.950]                     ...future.globalenv.names))
[17:39:56.950]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.950]         }, condition = base::local({
[17:39:56.950]             c <- base::c
[17:39:56.950]             inherits <- base::inherits
[17:39:56.950]             invokeRestart <- base::invokeRestart
[17:39:56.950]             length <- base::length
[17:39:56.950]             list <- base::list
[17:39:56.950]             seq.int <- base::seq.int
[17:39:56.950]             signalCondition <- base::signalCondition
[17:39:56.950]             sys.calls <- base::sys.calls
[17:39:56.950]             `[[` <- base::`[[`
[17:39:56.950]             `+` <- base::`+`
[17:39:56.950]             `<<-` <- base::`<<-`
[17:39:56.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.950]                   3L)]
[17:39:56.950]             }
[17:39:56.950]             function(cond) {
[17:39:56.950]                 is_error <- inherits(cond, "error")
[17:39:56.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.950]                   NULL)
[17:39:56.950]                 if (is_error) {
[17:39:56.950]                   sessionInformation <- function() {
[17:39:56.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.950]                       search = base::search(), system = base::Sys.info())
[17:39:56.950]                   }
[17:39:56.950]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.950]                     cond$call), session = sessionInformation(), 
[17:39:56.950]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.950]                   signalCondition(cond)
[17:39:56.950]                 }
[17:39:56.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.950]                 "immediateCondition"))) {
[17:39:56.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.950]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.950]                   if (TRUE && !signal) {
[17:39:56.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.950]                     {
[17:39:56.950]                       inherits <- base::inherits
[17:39:56.950]                       invokeRestart <- base::invokeRestart
[17:39:56.950]                       is.null <- base::is.null
[17:39:56.950]                       muffled <- FALSE
[17:39:56.950]                       if (inherits(cond, "message")) {
[17:39:56.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.950]                         if (muffled) 
[17:39:56.950]                           invokeRestart("muffleMessage")
[17:39:56.950]                       }
[17:39:56.950]                       else if (inherits(cond, "warning")) {
[17:39:56.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.950]                         if (muffled) 
[17:39:56.950]                           invokeRestart("muffleWarning")
[17:39:56.950]                       }
[17:39:56.950]                       else if (inherits(cond, "condition")) {
[17:39:56.950]                         if (!is.null(pattern)) {
[17:39:56.950]                           computeRestarts <- base::computeRestarts
[17:39:56.950]                           grepl <- base::grepl
[17:39:56.950]                           restarts <- computeRestarts(cond)
[17:39:56.950]                           for (restart in restarts) {
[17:39:56.950]                             name <- restart$name
[17:39:56.950]                             if (is.null(name)) 
[17:39:56.950]                               next
[17:39:56.950]                             if (!grepl(pattern, name)) 
[17:39:56.950]                               next
[17:39:56.950]                             invokeRestart(restart)
[17:39:56.950]                             muffled <- TRUE
[17:39:56.950]                             break
[17:39:56.950]                           }
[17:39:56.950]                         }
[17:39:56.950]                       }
[17:39:56.950]                       invisible(muffled)
[17:39:56.950]                     }
[17:39:56.950]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.950]                   }
[17:39:56.950]                 }
[17:39:56.950]                 else {
[17:39:56.950]                   if (TRUE) {
[17:39:56.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.950]                     {
[17:39:56.950]                       inherits <- base::inherits
[17:39:56.950]                       invokeRestart <- base::invokeRestart
[17:39:56.950]                       is.null <- base::is.null
[17:39:56.950]                       muffled <- FALSE
[17:39:56.950]                       if (inherits(cond, "message")) {
[17:39:56.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.950]                         if (muffled) 
[17:39:56.950]                           invokeRestart("muffleMessage")
[17:39:56.950]                       }
[17:39:56.950]                       else if (inherits(cond, "warning")) {
[17:39:56.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.950]                         if (muffled) 
[17:39:56.950]                           invokeRestart("muffleWarning")
[17:39:56.950]                       }
[17:39:56.950]                       else if (inherits(cond, "condition")) {
[17:39:56.950]                         if (!is.null(pattern)) {
[17:39:56.950]                           computeRestarts <- base::computeRestarts
[17:39:56.950]                           grepl <- base::grepl
[17:39:56.950]                           restarts <- computeRestarts(cond)
[17:39:56.950]                           for (restart in restarts) {
[17:39:56.950]                             name <- restart$name
[17:39:56.950]                             if (is.null(name)) 
[17:39:56.950]                               next
[17:39:56.950]                             if (!grepl(pattern, name)) 
[17:39:56.950]                               next
[17:39:56.950]                             invokeRestart(restart)
[17:39:56.950]                             muffled <- TRUE
[17:39:56.950]                             break
[17:39:56.950]                           }
[17:39:56.950]                         }
[17:39:56.950]                       }
[17:39:56.950]                       invisible(muffled)
[17:39:56.950]                     }
[17:39:56.950]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.950]                   }
[17:39:56.950]                 }
[17:39:56.950]             }
[17:39:56.950]         }))
[17:39:56.950]     }, error = function(ex) {
[17:39:56.950]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.950]                 ...future.rng), started = ...future.startTime, 
[17:39:56.950]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.950]             version = "1.8"), class = "FutureResult")
[17:39:56.950]     }, finally = {
[17:39:56.950]         if (!identical(...future.workdir, getwd())) 
[17:39:56.950]             setwd(...future.workdir)
[17:39:56.950]         {
[17:39:56.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.950]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.950]             }
[17:39:56.950]             base::options(...future.oldOptions)
[17:39:56.950]             if (.Platform$OS.type == "windows") {
[17:39:56.950]                 old_names <- names(...future.oldEnvVars)
[17:39:56.950]                 envs <- base::Sys.getenv()
[17:39:56.950]                 names <- names(envs)
[17:39:56.950]                 common <- intersect(names, old_names)
[17:39:56.950]                 added <- setdiff(names, old_names)
[17:39:56.950]                 removed <- setdiff(old_names, names)
[17:39:56.950]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.950]                   envs[common]]
[17:39:56.950]                 NAMES <- toupper(changed)
[17:39:56.950]                 args <- list()
[17:39:56.950]                 for (kk in seq_along(NAMES)) {
[17:39:56.950]                   name <- changed[[kk]]
[17:39:56.950]                   NAME <- NAMES[[kk]]
[17:39:56.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.950]                     next
[17:39:56.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.950]                 }
[17:39:56.950]                 NAMES <- toupper(added)
[17:39:56.950]                 for (kk in seq_along(NAMES)) {
[17:39:56.950]                   name <- added[[kk]]
[17:39:56.950]                   NAME <- NAMES[[kk]]
[17:39:56.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.950]                     next
[17:39:56.950]                   args[[name]] <- ""
[17:39:56.950]                 }
[17:39:56.950]                 NAMES <- toupper(removed)
[17:39:56.950]                 for (kk in seq_along(NAMES)) {
[17:39:56.950]                   name <- removed[[kk]]
[17:39:56.950]                   NAME <- NAMES[[kk]]
[17:39:56.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.950]                     next
[17:39:56.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.950]                 }
[17:39:56.950]                 if (length(args) > 0) 
[17:39:56.950]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.950]             }
[17:39:56.950]             else {
[17:39:56.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.950]             }
[17:39:56.950]             {
[17:39:56.950]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.950]                   0L) {
[17:39:56.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.950]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.950]                   base::options(opts)
[17:39:56.950]                 }
[17:39:56.950]                 {
[17:39:56.950]                   {
[17:39:56.950]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.950]                     NULL
[17:39:56.950]                   }
[17:39:56.950]                   options(future.plan = NULL)
[17:39:56.950]                   if (is.na(NA_character_)) 
[17:39:56.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.950]                     .init = FALSE)
[17:39:56.950]                 }
[17:39:56.950]             }
[17:39:56.950]         }
[17:39:56.950]     })
[17:39:56.950]     if (TRUE) {
[17:39:56.950]         base::sink(type = "output", split = FALSE)
[17:39:56.950]         if (TRUE) {
[17:39:56.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.950]         }
[17:39:56.950]         else {
[17:39:56.950]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.950]         }
[17:39:56.950]         base::close(...future.stdout)
[17:39:56.950]         ...future.stdout <- NULL
[17:39:56.950]     }
[17:39:56.950]     ...future.result$conditions <- ...future.conditions
[17:39:56.950]     ...future.result$finished <- base::Sys.time()
[17:39:56.950]     ...future.result
[17:39:56.950] }
[17:39:56.953] assign_globals() ...
[17:39:56.953] List of 2
[17:39:56.953]  $ a : num 1
[17:39:56.953]  $ ii: int 2
[17:39:56.953]  - attr(*, "where")=List of 2
[17:39:56.953]   ..$ a :<environment: R_EmptyEnv> 
[17:39:56.953]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.953]  - attr(*, "resolved")= logi TRUE
[17:39:56.953]  - attr(*, "total_size")= num 112
[17:39:56.953]  - attr(*, "already-done")= logi TRUE
[17:39:56.957] - copied ‘a’ to environment
[17:39:56.957] - copied ‘ii’ to environment
[17:39:56.957] assign_globals() ... done
[17:39:56.957] requestCore(): workers = 2
[17:39:56.959] MulticoreFuture started
[17:39:56.959] - Launch lazy future ... done
[17:39:56.959] run() for ‘MulticoreFuture’ ... done
[17:39:56.959] result() for MulticoreFuture ...
[17:39:56.960] plan(): Setting new future strategy stack:
[17:39:56.960] List of future strategies:
[17:39:56.960] 1. sequential:
[17:39:56.960]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.960]    - tweaked: FALSE
[17:39:56.960]    - call: NULL
[17:39:56.961] plan(): nbrOfWorkers() = 1
[17:39:56.963] plan(): Setting new future strategy stack:
[17:39:56.963] List of future strategies:
[17:39:56.963] 1. multicore:
[17:39:56.963]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.963]    - tweaked: FALSE
[17:39:56.963]    - call: plan(strategy)
[17:39:56.968] plan(): nbrOfWorkers() = 2
[17:39:56.969] result() for MulticoreFuture ...
[17:39:56.969] result() for MulticoreFuture ... done
[17:39:56.970] result() for MulticoreFuture ... done
[17:39:56.970] result() for MulticoreFuture ...
[17:39:56.970] result() for MulticoreFuture ... done
[17:39:56.970] run() for ‘Future’ ...
[17:39:56.970] - state: ‘created’
[17:39:56.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:56.974] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:56.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:56.975]   - Field: ‘label’
[17:39:56.975]   - Field: ‘local’
[17:39:56.975]   - Field: ‘owner’
[17:39:56.975]   - Field: ‘envir’
[17:39:56.975]   - Field: ‘workers’
[17:39:56.975]   - Field: ‘packages’
[17:39:56.976]   - Field: ‘gc’
[17:39:56.976]   - Field: ‘job’
[17:39:56.976]   - Field: ‘conditions’
[17:39:56.976]   - Field: ‘expr’
[17:39:56.976]   - Field: ‘uuid’
[17:39:56.976]   - Field: ‘seed’
[17:39:56.976]   - Field: ‘version’
[17:39:56.976]   - Field: ‘result’
[17:39:56.977]   - Field: ‘asynchronous’
[17:39:56.977]   - Field: ‘calls’
[17:39:56.977]   - Field: ‘globals’
[17:39:56.977]   - Field: ‘stdout’
[17:39:56.977]   - Field: ‘earlySignal’
[17:39:56.977]   - Field: ‘lazy’
[17:39:56.977]   - Field: ‘state’
[17:39:56.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:56.978] - Launch lazy future ...
[17:39:56.978] Packages needed by the future expression (n = 0): <none>
[17:39:56.978] Packages needed by future strategies (n = 0): <none>
[17:39:56.979] {
[17:39:56.979]     {
[17:39:56.979]         {
[17:39:56.979]             ...future.startTime <- base::Sys.time()
[17:39:56.979]             {
[17:39:56.979]                 {
[17:39:56.979]                   {
[17:39:56.979]                     {
[17:39:56.979]                       base::local({
[17:39:56.979]                         has_future <- base::requireNamespace("future", 
[17:39:56.979]                           quietly = TRUE)
[17:39:56.979]                         if (has_future) {
[17:39:56.979]                           ns <- base::getNamespace("future")
[17:39:56.979]                           version <- ns[[".package"]][["version"]]
[17:39:56.979]                           if (is.null(version)) 
[17:39:56.979]                             version <- utils::packageVersion("future")
[17:39:56.979]                         }
[17:39:56.979]                         else {
[17:39:56.979]                           version <- NULL
[17:39:56.979]                         }
[17:39:56.979]                         if (!has_future || version < "1.8.0") {
[17:39:56.979]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:56.979]                             "", base::R.version$version.string), 
[17:39:56.979]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:56.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:56.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:56.979]                               "release", "version")], collapse = " "), 
[17:39:56.979]                             hostname = base::Sys.info()[["nodename"]])
[17:39:56.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:56.979]                             info)
[17:39:56.979]                           info <- base::paste(info, collapse = "; ")
[17:39:56.979]                           if (!has_future) {
[17:39:56.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:56.979]                               info)
[17:39:56.979]                           }
[17:39:56.979]                           else {
[17:39:56.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:56.979]                               info, version)
[17:39:56.979]                           }
[17:39:56.979]                           base::stop(msg)
[17:39:56.979]                         }
[17:39:56.979]                       })
[17:39:56.979]                     }
[17:39:56.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:56.979]                     base::options(mc.cores = 1L)
[17:39:56.979]                   }
[17:39:56.979]                   ...future.strategy.old <- future::plan("list")
[17:39:56.979]                   options(future.plan = NULL)
[17:39:56.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:56.979]                 }
[17:39:56.979]                 ...future.workdir <- getwd()
[17:39:56.979]             }
[17:39:56.979]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:56.979]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:56.979]         }
[17:39:56.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:56.979]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:56.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:56.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:56.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:56.979]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:56.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:56.979]             base::names(...future.oldOptions))
[17:39:56.979]     }
[17:39:56.979]     if (FALSE) {
[17:39:56.979]     }
[17:39:56.979]     else {
[17:39:56.979]         if (TRUE) {
[17:39:56.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:56.979]                 open = "w")
[17:39:56.979]         }
[17:39:56.979]         else {
[17:39:56.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:56.979]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:56.979]         }
[17:39:56.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:56.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:56.979]             base::sink(type = "output", split = FALSE)
[17:39:56.979]             base::close(...future.stdout)
[17:39:56.979]         }, add = TRUE)
[17:39:56.979]     }
[17:39:56.979]     ...future.frame <- base::sys.nframe()
[17:39:56.979]     ...future.conditions <- base::list()
[17:39:56.979]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:56.979]     if (FALSE) {
[17:39:56.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:56.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:56.979]     }
[17:39:56.979]     ...future.result <- base::tryCatch({
[17:39:56.979]         base::withCallingHandlers({
[17:39:56.979]             ...future.value <- base::withVisible(base::local({
[17:39:56.979]                 withCallingHandlers({
[17:39:56.979]                   {
[17:39:56.979]                     b <- a * ii
[17:39:56.979]                     a <- 0
[17:39:56.979]                     b
[17:39:56.979]                   }
[17:39:56.979]                 }, immediateCondition = function(cond) {
[17:39:56.979]                   save_rds <- function (object, pathname, ...) 
[17:39:56.979]                   {
[17:39:56.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:56.979]                     if (file_test("-f", pathname_tmp)) {
[17:39:56.979]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:56.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.979]                         fi_tmp[["mtime"]])
[17:39:56.979]                     }
[17:39:56.979]                     tryCatch({
[17:39:56.979]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:56.979]                     }, error = function(ex) {
[17:39:56.979]                       msg <- conditionMessage(ex)
[17:39:56.979]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:56.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.979]                         fi_tmp[["mtime"]], msg)
[17:39:56.979]                       ex$message <- msg
[17:39:56.979]                       stop(ex)
[17:39:56.979]                     })
[17:39:56.979]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:56.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:56.979]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:56.979]                       fi_tmp <- file.info(pathname_tmp)
[17:39:56.979]                       fi <- file.info(pathname)
[17:39:56.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:56.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:56.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:56.979]                         fi[["size"]], fi[["mtime"]])
[17:39:56.979]                       stop(msg)
[17:39:56.979]                     }
[17:39:56.979]                     invisible(pathname)
[17:39:56.979]                   }
[17:39:56.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:56.979]                     rootPath = tempdir()) 
[17:39:56.979]                   {
[17:39:56.979]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:56.979]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:56.979]                       tmpdir = path, fileext = ".rds")
[17:39:56.979]                     save_rds(obj, file)
[17:39:56.979]                   }
[17:39:56.979]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:56.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.979]                   {
[17:39:56.979]                     inherits <- base::inherits
[17:39:56.979]                     invokeRestart <- base::invokeRestart
[17:39:56.979]                     is.null <- base::is.null
[17:39:56.979]                     muffled <- FALSE
[17:39:56.979]                     if (inherits(cond, "message")) {
[17:39:56.979]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:56.979]                       if (muffled) 
[17:39:56.979]                         invokeRestart("muffleMessage")
[17:39:56.979]                     }
[17:39:56.979]                     else if (inherits(cond, "warning")) {
[17:39:56.979]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:56.979]                       if (muffled) 
[17:39:56.979]                         invokeRestart("muffleWarning")
[17:39:56.979]                     }
[17:39:56.979]                     else if (inherits(cond, "condition")) {
[17:39:56.979]                       if (!is.null(pattern)) {
[17:39:56.979]                         computeRestarts <- base::computeRestarts
[17:39:56.979]                         grepl <- base::grepl
[17:39:56.979]                         restarts <- computeRestarts(cond)
[17:39:56.979]                         for (restart in restarts) {
[17:39:56.979]                           name <- restart$name
[17:39:56.979]                           if (is.null(name)) 
[17:39:56.979]                             next
[17:39:56.979]                           if (!grepl(pattern, name)) 
[17:39:56.979]                             next
[17:39:56.979]                           invokeRestart(restart)
[17:39:56.979]                           muffled <- TRUE
[17:39:56.979]                           break
[17:39:56.979]                         }
[17:39:56.979]                       }
[17:39:56.979]                     }
[17:39:56.979]                     invisible(muffled)
[17:39:56.979]                   }
[17:39:56.979]                   muffleCondition(cond)
[17:39:56.979]                 })
[17:39:56.979]             }))
[17:39:56.979]             future::FutureResult(value = ...future.value$value, 
[17:39:56.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.979]                   ...future.rng), globalenv = if (FALSE) 
[17:39:56.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:56.979]                     ...future.globalenv.names))
[17:39:56.979]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:56.979]         }, condition = base::local({
[17:39:56.979]             c <- base::c
[17:39:56.979]             inherits <- base::inherits
[17:39:56.979]             invokeRestart <- base::invokeRestart
[17:39:56.979]             length <- base::length
[17:39:56.979]             list <- base::list
[17:39:56.979]             seq.int <- base::seq.int
[17:39:56.979]             signalCondition <- base::signalCondition
[17:39:56.979]             sys.calls <- base::sys.calls
[17:39:56.979]             `[[` <- base::`[[`
[17:39:56.979]             `+` <- base::`+`
[17:39:56.979]             `<<-` <- base::`<<-`
[17:39:56.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:56.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:56.979]                   3L)]
[17:39:56.979]             }
[17:39:56.979]             function(cond) {
[17:39:56.979]                 is_error <- inherits(cond, "error")
[17:39:56.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:56.979]                   NULL)
[17:39:56.979]                 if (is_error) {
[17:39:56.979]                   sessionInformation <- function() {
[17:39:56.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:56.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:56.979]                       search = base::search(), system = base::Sys.info())
[17:39:56.979]                   }
[17:39:56.979]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:56.979]                     cond$call), session = sessionInformation(), 
[17:39:56.979]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:56.979]                   signalCondition(cond)
[17:39:56.979]                 }
[17:39:56.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:56.979]                 "immediateCondition"))) {
[17:39:56.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:56.979]                   ...future.conditions[[length(...future.conditions) + 
[17:39:56.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:56.979]                   if (TRUE && !signal) {
[17:39:56.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.979]                     {
[17:39:56.979]                       inherits <- base::inherits
[17:39:56.979]                       invokeRestart <- base::invokeRestart
[17:39:56.979]                       is.null <- base::is.null
[17:39:56.979]                       muffled <- FALSE
[17:39:56.979]                       if (inherits(cond, "message")) {
[17:39:56.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.979]                         if (muffled) 
[17:39:56.979]                           invokeRestart("muffleMessage")
[17:39:56.979]                       }
[17:39:56.979]                       else if (inherits(cond, "warning")) {
[17:39:56.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.979]                         if (muffled) 
[17:39:56.979]                           invokeRestart("muffleWarning")
[17:39:56.979]                       }
[17:39:56.979]                       else if (inherits(cond, "condition")) {
[17:39:56.979]                         if (!is.null(pattern)) {
[17:39:56.979]                           computeRestarts <- base::computeRestarts
[17:39:56.979]                           grepl <- base::grepl
[17:39:56.979]                           restarts <- computeRestarts(cond)
[17:39:56.979]                           for (restart in restarts) {
[17:39:56.979]                             name <- restart$name
[17:39:56.979]                             if (is.null(name)) 
[17:39:56.979]                               next
[17:39:56.979]                             if (!grepl(pattern, name)) 
[17:39:56.979]                               next
[17:39:56.979]                             invokeRestart(restart)
[17:39:56.979]                             muffled <- TRUE
[17:39:56.979]                             break
[17:39:56.979]                           }
[17:39:56.979]                         }
[17:39:56.979]                       }
[17:39:56.979]                       invisible(muffled)
[17:39:56.979]                     }
[17:39:56.979]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.979]                   }
[17:39:56.979]                 }
[17:39:56.979]                 else {
[17:39:56.979]                   if (TRUE) {
[17:39:56.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:56.979]                     {
[17:39:56.979]                       inherits <- base::inherits
[17:39:56.979]                       invokeRestart <- base::invokeRestart
[17:39:56.979]                       is.null <- base::is.null
[17:39:56.979]                       muffled <- FALSE
[17:39:56.979]                       if (inherits(cond, "message")) {
[17:39:56.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:56.979]                         if (muffled) 
[17:39:56.979]                           invokeRestart("muffleMessage")
[17:39:56.979]                       }
[17:39:56.979]                       else if (inherits(cond, "warning")) {
[17:39:56.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:56.979]                         if (muffled) 
[17:39:56.979]                           invokeRestart("muffleWarning")
[17:39:56.979]                       }
[17:39:56.979]                       else if (inherits(cond, "condition")) {
[17:39:56.979]                         if (!is.null(pattern)) {
[17:39:56.979]                           computeRestarts <- base::computeRestarts
[17:39:56.979]                           grepl <- base::grepl
[17:39:56.979]                           restarts <- computeRestarts(cond)
[17:39:56.979]                           for (restart in restarts) {
[17:39:56.979]                             name <- restart$name
[17:39:56.979]                             if (is.null(name)) 
[17:39:56.979]                               next
[17:39:56.979]                             if (!grepl(pattern, name)) 
[17:39:56.979]                               next
[17:39:56.979]                             invokeRestart(restart)
[17:39:56.979]                             muffled <- TRUE
[17:39:56.979]                             break
[17:39:56.979]                           }
[17:39:56.979]                         }
[17:39:56.979]                       }
[17:39:56.979]                       invisible(muffled)
[17:39:56.979]                     }
[17:39:56.979]                     muffleCondition(cond, pattern = "^muffle")
[17:39:56.979]                   }
[17:39:56.979]                 }
[17:39:56.979]             }
[17:39:56.979]         }))
[17:39:56.979]     }, error = function(ex) {
[17:39:56.979]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:56.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:56.979]                 ...future.rng), started = ...future.startTime, 
[17:39:56.979]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:56.979]             version = "1.8"), class = "FutureResult")
[17:39:56.979]     }, finally = {
[17:39:56.979]         if (!identical(...future.workdir, getwd())) 
[17:39:56.979]             setwd(...future.workdir)
[17:39:56.979]         {
[17:39:56.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:56.979]                 ...future.oldOptions$nwarnings <- NULL
[17:39:56.979]             }
[17:39:56.979]             base::options(...future.oldOptions)
[17:39:56.979]             if (.Platform$OS.type == "windows") {
[17:39:56.979]                 old_names <- names(...future.oldEnvVars)
[17:39:56.979]                 envs <- base::Sys.getenv()
[17:39:56.979]                 names <- names(envs)
[17:39:56.979]                 common <- intersect(names, old_names)
[17:39:56.979]                 added <- setdiff(names, old_names)
[17:39:56.979]                 removed <- setdiff(old_names, names)
[17:39:56.979]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:56.979]                   envs[common]]
[17:39:56.979]                 NAMES <- toupper(changed)
[17:39:56.979]                 args <- list()
[17:39:56.979]                 for (kk in seq_along(NAMES)) {
[17:39:56.979]                   name <- changed[[kk]]
[17:39:56.979]                   NAME <- NAMES[[kk]]
[17:39:56.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.979]                     next
[17:39:56.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.979]                 }
[17:39:56.979]                 NAMES <- toupper(added)
[17:39:56.979]                 for (kk in seq_along(NAMES)) {
[17:39:56.979]                   name <- added[[kk]]
[17:39:56.979]                   NAME <- NAMES[[kk]]
[17:39:56.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.979]                     next
[17:39:56.979]                   args[[name]] <- ""
[17:39:56.979]                 }
[17:39:56.979]                 NAMES <- toupper(removed)
[17:39:56.979]                 for (kk in seq_along(NAMES)) {
[17:39:56.979]                   name <- removed[[kk]]
[17:39:56.979]                   NAME <- NAMES[[kk]]
[17:39:56.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:56.979]                     next
[17:39:56.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:56.979]                 }
[17:39:56.979]                 if (length(args) > 0) 
[17:39:56.979]                   base::do.call(base::Sys.setenv, args = args)
[17:39:56.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:56.979]             }
[17:39:56.979]             else {
[17:39:56.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:56.979]             }
[17:39:56.979]             {
[17:39:56.979]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:56.979]                   0L) {
[17:39:56.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:56.979]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:56.979]                   base::options(opts)
[17:39:56.979]                 }
[17:39:56.979]                 {
[17:39:56.979]                   {
[17:39:56.979]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:56.979]                     NULL
[17:39:56.979]                   }
[17:39:56.979]                   options(future.plan = NULL)
[17:39:56.979]                   if (is.na(NA_character_)) 
[17:39:56.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:56.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:56.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:56.979]                     .init = FALSE)
[17:39:56.979]                 }
[17:39:56.979]             }
[17:39:56.979]         }
[17:39:56.979]     })
[17:39:56.979]     if (TRUE) {
[17:39:56.979]         base::sink(type = "output", split = FALSE)
[17:39:56.979]         if (TRUE) {
[17:39:56.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:56.979]         }
[17:39:56.979]         else {
[17:39:56.979]             ...future.result["stdout"] <- base::list(NULL)
[17:39:56.979]         }
[17:39:56.979]         base::close(...future.stdout)
[17:39:56.979]         ...future.stdout <- NULL
[17:39:56.979]     }
[17:39:56.979]     ...future.result$conditions <- ...future.conditions
[17:39:56.979]     ...future.result$finished <- base::Sys.time()
[17:39:56.979]     ...future.result
[17:39:56.979] }
[17:39:56.981] assign_globals() ...
[17:39:56.981] List of 2
[17:39:56.981]  $ a : num 1
[17:39:56.981]  $ ii: int 3
[17:39:56.981]  - attr(*, "where")=List of 2
[17:39:56.981]   ..$ a :<environment: R_EmptyEnv> 
[17:39:56.981]   ..$ ii:<environment: R_EmptyEnv> 
[17:39:56.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:56.981]  - attr(*, "resolved")= logi TRUE
[17:39:56.981]  - attr(*, "total_size")= num 112
[17:39:56.981]  - attr(*, "already-done")= logi TRUE
[17:39:56.988] - copied ‘a’ to environment
[17:39:56.988] - copied ‘ii’ to environment
[17:39:56.988] assign_globals() ... done
[17:39:56.988] requestCore(): workers = 2
[17:39:56.990] MulticoreFuture started
[17:39:56.990] - Launch lazy future ... done
[17:39:56.991] run() for ‘MulticoreFuture’ ... done
[17:39:56.991] result() for MulticoreFuture ...
[17:39:56.991] plan(): Setting new future strategy stack:
[17:39:56.991] List of future strategies:
[17:39:56.991] 1. sequential:
[17:39:56.991]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:56.991]    - tweaked: FALSE
[17:39:56.991]    - call: NULL
[17:39:56.993] plan(): nbrOfWorkers() = 1
[17:39:56.995] plan(): Setting new future strategy stack:
[17:39:56.995] List of future strategies:
[17:39:56.995] 1. multicore:
[17:39:56.995]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:56.995]    - tweaked: FALSE
[17:39:56.995]    - call: plan(strategy)
[17:39:57.002] plan(): nbrOfWorkers() = 2
[17:39:57.003] result() for MulticoreFuture ...
[17:39:57.004] result() for MulticoreFuture ... done
[17:39:57.004] result() for MulticoreFuture ... done
[17:39:57.004] result() for MulticoreFuture ...
[17:39:57.004] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.005] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.005] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.006] 
[17:39:57.006] Searching for globals ... DONE
[17:39:57.007] - globals: [0] <none>
[17:39:57.007] getGlobalsAndPackages() ... DONE
[17:39:57.007] run() for ‘Future’ ...
[17:39:57.007] - state: ‘created’
[17:39:57.007] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.012] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.012] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.012]   - Field: ‘label’
[17:39:57.012]   - Field: ‘local’
[17:39:57.012]   - Field: ‘owner’
[17:39:57.013]   - Field: ‘envir’
[17:39:57.013]   - Field: ‘workers’
[17:39:57.013]   - Field: ‘packages’
[17:39:57.013]   - Field: ‘gc’
[17:39:57.013]   - Field: ‘job’
[17:39:57.013]   - Field: ‘conditions’
[17:39:57.013]   - Field: ‘expr’
[17:39:57.013]   - Field: ‘uuid’
[17:39:57.014]   - Field: ‘seed’
[17:39:57.014]   - Field: ‘version’
[17:39:57.014]   - Field: ‘result’
[17:39:57.014]   - Field: ‘asynchronous’
[17:39:57.014]   - Field: ‘calls’
[17:39:57.014]   - Field: ‘globals’
[17:39:57.014]   - Field: ‘stdout’
[17:39:57.014]   - Field: ‘earlySignal’
[17:39:57.014]   - Field: ‘lazy’
[17:39:57.015]   - Field: ‘state’
[17:39:57.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.015] - Launch lazy future ...
[17:39:57.015] Packages needed by the future expression (n = 0): <none>
[17:39:57.015] Packages needed by future strategies (n = 0): <none>
[17:39:57.016] {
[17:39:57.016]     {
[17:39:57.016]         {
[17:39:57.016]             ...future.startTime <- base::Sys.time()
[17:39:57.016]             {
[17:39:57.016]                 {
[17:39:57.016]                   {
[17:39:57.016]                     {
[17:39:57.016]                       base::local({
[17:39:57.016]                         has_future <- base::requireNamespace("future", 
[17:39:57.016]                           quietly = TRUE)
[17:39:57.016]                         if (has_future) {
[17:39:57.016]                           ns <- base::getNamespace("future")
[17:39:57.016]                           version <- ns[[".package"]][["version"]]
[17:39:57.016]                           if (is.null(version)) 
[17:39:57.016]                             version <- utils::packageVersion("future")
[17:39:57.016]                         }
[17:39:57.016]                         else {
[17:39:57.016]                           version <- NULL
[17:39:57.016]                         }
[17:39:57.016]                         if (!has_future || version < "1.8.0") {
[17:39:57.016]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.016]                             "", base::R.version$version.string), 
[17:39:57.016]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.016]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.016]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.016]                               "release", "version")], collapse = " "), 
[17:39:57.016]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.016]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.016]                             info)
[17:39:57.016]                           info <- base::paste(info, collapse = "; ")
[17:39:57.016]                           if (!has_future) {
[17:39:57.016]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.016]                               info)
[17:39:57.016]                           }
[17:39:57.016]                           else {
[17:39:57.016]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.016]                               info, version)
[17:39:57.016]                           }
[17:39:57.016]                           base::stop(msg)
[17:39:57.016]                         }
[17:39:57.016]                       })
[17:39:57.016]                     }
[17:39:57.016]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.016]                     base::options(mc.cores = 1L)
[17:39:57.016]                   }
[17:39:57.016]                   ...future.strategy.old <- future::plan("list")
[17:39:57.016]                   options(future.plan = NULL)
[17:39:57.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.016]                 }
[17:39:57.016]                 ...future.workdir <- getwd()
[17:39:57.016]             }
[17:39:57.016]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.016]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.016]         }
[17:39:57.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.016]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.016]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.016]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.016]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.016]             base::names(...future.oldOptions))
[17:39:57.016]     }
[17:39:57.016]     if (FALSE) {
[17:39:57.016]     }
[17:39:57.016]     else {
[17:39:57.016]         if (TRUE) {
[17:39:57.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.016]                 open = "w")
[17:39:57.016]         }
[17:39:57.016]         else {
[17:39:57.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.016]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.016]         }
[17:39:57.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.016]             base::sink(type = "output", split = FALSE)
[17:39:57.016]             base::close(...future.stdout)
[17:39:57.016]         }, add = TRUE)
[17:39:57.016]     }
[17:39:57.016]     ...future.frame <- base::sys.nframe()
[17:39:57.016]     ...future.conditions <- base::list()
[17:39:57.016]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.016]     if (FALSE) {
[17:39:57.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.016]     }
[17:39:57.016]     ...future.result <- base::tryCatch({
[17:39:57.016]         base::withCallingHandlers({
[17:39:57.016]             ...future.value <- base::withVisible(base::local({
[17:39:57.016]                 withCallingHandlers({
[17:39:57.016]                   1
[17:39:57.016]                 }, immediateCondition = function(cond) {
[17:39:57.016]                   save_rds <- function (object, pathname, ...) 
[17:39:57.016]                   {
[17:39:57.016]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.016]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.016]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.016]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.016]                         fi_tmp[["mtime"]])
[17:39:57.016]                     }
[17:39:57.016]                     tryCatch({
[17:39:57.016]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.016]                     }, error = function(ex) {
[17:39:57.016]                       msg <- conditionMessage(ex)
[17:39:57.016]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.016]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.016]                         fi_tmp[["mtime"]], msg)
[17:39:57.016]                       ex$message <- msg
[17:39:57.016]                       stop(ex)
[17:39:57.016]                     })
[17:39:57.016]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.016]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.016]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.016]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.016]                       fi <- file.info(pathname)
[17:39:57.016]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.016]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.016]                         fi[["size"]], fi[["mtime"]])
[17:39:57.016]                       stop(msg)
[17:39:57.016]                     }
[17:39:57.016]                     invisible(pathname)
[17:39:57.016]                   }
[17:39:57.016]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.016]                     rootPath = tempdir()) 
[17:39:57.016]                   {
[17:39:57.016]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.016]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.016]                       tmpdir = path, fileext = ".rds")
[17:39:57.016]                     save_rds(obj, file)
[17:39:57.016]                   }
[17:39:57.016]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.016]                   {
[17:39:57.016]                     inherits <- base::inherits
[17:39:57.016]                     invokeRestart <- base::invokeRestart
[17:39:57.016]                     is.null <- base::is.null
[17:39:57.016]                     muffled <- FALSE
[17:39:57.016]                     if (inherits(cond, "message")) {
[17:39:57.016]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.016]                       if (muffled) 
[17:39:57.016]                         invokeRestart("muffleMessage")
[17:39:57.016]                     }
[17:39:57.016]                     else if (inherits(cond, "warning")) {
[17:39:57.016]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.016]                       if (muffled) 
[17:39:57.016]                         invokeRestart("muffleWarning")
[17:39:57.016]                     }
[17:39:57.016]                     else if (inherits(cond, "condition")) {
[17:39:57.016]                       if (!is.null(pattern)) {
[17:39:57.016]                         computeRestarts <- base::computeRestarts
[17:39:57.016]                         grepl <- base::grepl
[17:39:57.016]                         restarts <- computeRestarts(cond)
[17:39:57.016]                         for (restart in restarts) {
[17:39:57.016]                           name <- restart$name
[17:39:57.016]                           if (is.null(name)) 
[17:39:57.016]                             next
[17:39:57.016]                           if (!grepl(pattern, name)) 
[17:39:57.016]                             next
[17:39:57.016]                           invokeRestart(restart)
[17:39:57.016]                           muffled <- TRUE
[17:39:57.016]                           break
[17:39:57.016]                         }
[17:39:57.016]                       }
[17:39:57.016]                     }
[17:39:57.016]                     invisible(muffled)
[17:39:57.016]                   }
[17:39:57.016]                   muffleCondition(cond)
[17:39:57.016]                 })
[17:39:57.016]             }))
[17:39:57.016]             future::FutureResult(value = ...future.value$value, 
[17:39:57.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.016]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.016]                     ...future.globalenv.names))
[17:39:57.016]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.016]         }, condition = base::local({
[17:39:57.016]             c <- base::c
[17:39:57.016]             inherits <- base::inherits
[17:39:57.016]             invokeRestart <- base::invokeRestart
[17:39:57.016]             length <- base::length
[17:39:57.016]             list <- base::list
[17:39:57.016]             seq.int <- base::seq.int
[17:39:57.016]             signalCondition <- base::signalCondition
[17:39:57.016]             sys.calls <- base::sys.calls
[17:39:57.016]             `[[` <- base::`[[`
[17:39:57.016]             `+` <- base::`+`
[17:39:57.016]             `<<-` <- base::`<<-`
[17:39:57.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.016]                   3L)]
[17:39:57.016]             }
[17:39:57.016]             function(cond) {
[17:39:57.016]                 is_error <- inherits(cond, "error")
[17:39:57.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.016]                   NULL)
[17:39:57.016]                 if (is_error) {
[17:39:57.016]                   sessionInformation <- function() {
[17:39:57.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.016]                       search = base::search(), system = base::Sys.info())
[17:39:57.016]                   }
[17:39:57.016]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.016]                     cond$call), session = sessionInformation(), 
[17:39:57.016]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.016]                   signalCondition(cond)
[17:39:57.016]                 }
[17:39:57.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.016]                 "immediateCondition"))) {
[17:39:57.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.016]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.016]                   if (TRUE && !signal) {
[17:39:57.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.016]                     {
[17:39:57.016]                       inherits <- base::inherits
[17:39:57.016]                       invokeRestart <- base::invokeRestart
[17:39:57.016]                       is.null <- base::is.null
[17:39:57.016]                       muffled <- FALSE
[17:39:57.016]                       if (inherits(cond, "message")) {
[17:39:57.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.016]                         if (muffled) 
[17:39:57.016]                           invokeRestart("muffleMessage")
[17:39:57.016]                       }
[17:39:57.016]                       else if (inherits(cond, "warning")) {
[17:39:57.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.016]                         if (muffled) 
[17:39:57.016]                           invokeRestart("muffleWarning")
[17:39:57.016]                       }
[17:39:57.016]                       else if (inherits(cond, "condition")) {
[17:39:57.016]                         if (!is.null(pattern)) {
[17:39:57.016]                           computeRestarts <- base::computeRestarts
[17:39:57.016]                           grepl <- base::grepl
[17:39:57.016]                           restarts <- computeRestarts(cond)
[17:39:57.016]                           for (restart in restarts) {
[17:39:57.016]                             name <- restart$name
[17:39:57.016]                             if (is.null(name)) 
[17:39:57.016]                               next
[17:39:57.016]                             if (!grepl(pattern, name)) 
[17:39:57.016]                               next
[17:39:57.016]                             invokeRestart(restart)
[17:39:57.016]                             muffled <- TRUE
[17:39:57.016]                             break
[17:39:57.016]                           }
[17:39:57.016]                         }
[17:39:57.016]                       }
[17:39:57.016]                       invisible(muffled)
[17:39:57.016]                     }
[17:39:57.016]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.016]                   }
[17:39:57.016]                 }
[17:39:57.016]                 else {
[17:39:57.016]                   if (TRUE) {
[17:39:57.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.016]                     {
[17:39:57.016]                       inherits <- base::inherits
[17:39:57.016]                       invokeRestart <- base::invokeRestart
[17:39:57.016]                       is.null <- base::is.null
[17:39:57.016]                       muffled <- FALSE
[17:39:57.016]                       if (inherits(cond, "message")) {
[17:39:57.016]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.016]                         if (muffled) 
[17:39:57.016]                           invokeRestart("muffleMessage")
[17:39:57.016]                       }
[17:39:57.016]                       else if (inherits(cond, "warning")) {
[17:39:57.016]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.016]                         if (muffled) 
[17:39:57.016]                           invokeRestart("muffleWarning")
[17:39:57.016]                       }
[17:39:57.016]                       else if (inherits(cond, "condition")) {
[17:39:57.016]                         if (!is.null(pattern)) {
[17:39:57.016]                           computeRestarts <- base::computeRestarts
[17:39:57.016]                           grepl <- base::grepl
[17:39:57.016]                           restarts <- computeRestarts(cond)
[17:39:57.016]                           for (restart in restarts) {
[17:39:57.016]                             name <- restart$name
[17:39:57.016]                             if (is.null(name)) 
[17:39:57.016]                               next
[17:39:57.016]                             if (!grepl(pattern, name)) 
[17:39:57.016]                               next
[17:39:57.016]                             invokeRestart(restart)
[17:39:57.016]                             muffled <- TRUE
[17:39:57.016]                             break
[17:39:57.016]                           }
[17:39:57.016]                         }
[17:39:57.016]                       }
[17:39:57.016]                       invisible(muffled)
[17:39:57.016]                     }
[17:39:57.016]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.016]                   }
[17:39:57.016]                 }
[17:39:57.016]             }
[17:39:57.016]         }))
[17:39:57.016]     }, error = function(ex) {
[17:39:57.016]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.016]                 ...future.rng), started = ...future.startTime, 
[17:39:57.016]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.016]             version = "1.8"), class = "FutureResult")
[17:39:57.016]     }, finally = {
[17:39:57.016]         if (!identical(...future.workdir, getwd())) 
[17:39:57.016]             setwd(...future.workdir)
[17:39:57.016]         {
[17:39:57.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.016]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.016]             }
[17:39:57.016]             base::options(...future.oldOptions)
[17:39:57.016]             if (.Platform$OS.type == "windows") {
[17:39:57.016]                 old_names <- names(...future.oldEnvVars)
[17:39:57.016]                 envs <- base::Sys.getenv()
[17:39:57.016]                 names <- names(envs)
[17:39:57.016]                 common <- intersect(names, old_names)
[17:39:57.016]                 added <- setdiff(names, old_names)
[17:39:57.016]                 removed <- setdiff(old_names, names)
[17:39:57.016]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.016]                   envs[common]]
[17:39:57.016]                 NAMES <- toupper(changed)
[17:39:57.016]                 args <- list()
[17:39:57.016]                 for (kk in seq_along(NAMES)) {
[17:39:57.016]                   name <- changed[[kk]]
[17:39:57.016]                   NAME <- NAMES[[kk]]
[17:39:57.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.016]                     next
[17:39:57.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.016]                 }
[17:39:57.016]                 NAMES <- toupper(added)
[17:39:57.016]                 for (kk in seq_along(NAMES)) {
[17:39:57.016]                   name <- added[[kk]]
[17:39:57.016]                   NAME <- NAMES[[kk]]
[17:39:57.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.016]                     next
[17:39:57.016]                   args[[name]] <- ""
[17:39:57.016]                 }
[17:39:57.016]                 NAMES <- toupper(removed)
[17:39:57.016]                 for (kk in seq_along(NAMES)) {
[17:39:57.016]                   name <- removed[[kk]]
[17:39:57.016]                   NAME <- NAMES[[kk]]
[17:39:57.016]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.016]                     next
[17:39:57.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.016]                 }
[17:39:57.016]                 if (length(args) > 0) 
[17:39:57.016]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.016]             }
[17:39:57.016]             else {
[17:39:57.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.016]             }
[17:39:57.016]             {
[17:39:57.016]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.016]                   0L) {
[17:39:57.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.016]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.016]                   base::options(opts)
[17:39:57.016]                 }
[17:39:57.016]                 {
[17:39:57.016]                   {
[17:39:57.016]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.016]                     NULL
[17:39:57.016]                   }
[17:39:57.016]                   options(future.plan = NULL)
[17:39:57.016]                   if (is.na(NA_character_)) 
[17:39:57.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.016]                     .init = FALSE)
[17:39:57.016]                 }
[17:39:57.016]             }
[17:39:57.016]         }
[17:39:57.016]     })
[17:39:57.016]     if (TRUE) {
[17:39:57.016]         base::sink(type = "output", split = FALSE)
[17:39:57.016]         if (TRUE) {
[17:39:57.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.016]         }
[17:39:57.016]         else {
[17:39:57.016]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.016]         }
[17:39:57.016]         base::close(...future.stdout)
[17:39:57.016]         ...future.stdout <- NULL
[17:39:57.016]     }
[17:39:57.016]     ...future.result$conditions <- ...future.conditions
[17:39:57.016]     ...future.result$finished <- base::Sys.time()
[17:39:57.016]     ...future.result
[17:39:57.016] }
[17:39:57.018] requestCore(): workers = 2
[17:39:57.020] MulticoreFuture started
[17:39:57.021] - Launch lazy future ... done
[17:39:57.021] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.021] plan(): Setting new future strategy stack:
[17:39:57.021] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.022] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.022] List of future strategies:
[17:39:57.022] 1. sequential:
[17:39:57.022]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.022]    - tweaked: FALSE
[17:39:57.022]    - call: NULL
[17:39:57.023] plan(): nbrOfWorkers() = 1
[17:39:57.024] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:57.024] Searching for globals ... DONE
[17:39:57.024] Resolving globals: TRUE
[17:39:57.024] Resolving any globals that are futures ...
[17:39:57.024] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:57.025] plan(): Setting new future strategy stack:
[17:39:57.025] Resolving any globals that are futures ... DONE
[17:39:57.025] List of future strategies:
[17:39:57.025] 1. multicore:
[17:39:57.025]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.025]    - tweaked: FALSE
[17:39:57.025]    - call: plan(strategy)
[17:39:57.025] Resolving futures part of globals (recursively) ...
[17:39:57.026] resolve() on list ...
[17:39:57.026]  recursive: 99
[17:39:57.026]  length: 1
[17:39:57.026]  elements: ‘a’
[17:39:57.029] plan(): nbrOfWorkers() = 2
[17:39:57.030] Future #1
[17:39:57.030] result() for MulticoreFuture ...
[17:39:57.031] result() for MulticoreFuture ...
[17:39:57.031] result() for MulticoreFuture ... done
[17:39:57.031] result() for MulticoreFuture ... done
[17:39:57.032] result() for MulticoreFuture ...
[17:39:57.032] result() for MulticoreFuture ... done
[17:39:57.032] A MulticoreFuture was resolved
[17:39:57.032]  length: 0 (resolved future 1)
[17:39:57.032] resolve() on list ... DONE
[17:39:57.032] - globals: [1] ‘a’
[17:39:57.033] Resolving futures part of globals (recursively) ... DONE
[17:39:57.035] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[17:39:57.036] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:57.036] - globals: [1] ‘a’
[17:39:57.036] - packages: [1] ‘future’
[17:39:57.036] getGlobalsAndPackages() ... DONE
[17:39:57.036] run() for ‘Future’ ...
[17:39:57.037] - state: ‘created’
[17:39:57.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.041]   - Field: ‘label’
[17:39:57.041]   - Field: ‘local’
[17:39:57.042]   - Field: ‘owner’
[17:39:57.042]   - Field: ‘envir’
[17:39:57.042]   - Field: ‘workers’
[17:39:57.042]   - Field: ‘packages’
[17:39:57.042]   - Field: ‘gc’
[17:39:57.042]   - Field: ‘job’
[17:39:57.042]   - Field: ‘conditions’
[17:39:57.042]   - Field: ‘expr’
[17:39:57.043]   - Field: ‘uuid’
[17:39:57.043]   - Field: ‘seed’
[17:39:57.043]   - Field: ‘version’
[17:39:57.043]   - Field: ‘result’
[17:39:57.043]   - Field: ‘asynchronous’
[17:39:57.043]   - Field: ‘calls’
[17:39:57.043]   - Field: ‘globals’
[17:39:57.043]   - Field: ‘stdout’
[17:39:57.043]   - Field: ‘earlySignal’
[17:39:57.044]   - Field: ‘lazy’
[17:39:57.044]   - Field: ‘state’
[17:39:57.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.044] - Launch lazy future ...
[17:39:57.044] Packages needed by the future expression (n = 1): ‘future’
[17:39:57.044] Packages needed by future strategies (n = 0): <none>
[17:39:57.045] {
[17:39:57.045]     {
[17:39:57.045]         {
[17:39:57.045]             ...future.startTime <- base::Sys.time()
[17:39:57.045]             {
[17:39:57.045]                 {
[17:39:57.045]                   {
[17:39:57.045]                     {
[17:39:57.045]                       {
[17:39:57.045]                         base::local({
[17:39:57.045]                           has_future <- base::requireNamespace("future", 
[17:39:57.045]                             quietly = TRUE)
[17:39:57.045]                           if (has_future) {
[17:39:57.045]                             ns <- base::getNamespace("future")
[17:39:57.045]                             version <- ns[[".package"]][["version"]]
[17:39:57.045]                             if (is.null(version)) 
[17:39:57.045]                               version <- utils::packageVersion("future")
[17:39:57.045]                           }
[17:39:57.045]                           else {
[17:39:57.045]                             version <- NULL
[17:39:57.045]                           }
[17:39:57.045]                           if (!has_future || version < "1.8.0") {
[17:39:57.045]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.045]                               "", base::R.version$version.string), 
[17:39:57.045]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:57.045]                                 base::R.version$platform, 8 * 
[17:39:57.045]                                   base::.Machine$sizeof.pointer), 
[17:39:57.045]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.045]                                 "release", "version")], collapse = " "), 
[17:39:57.045]                               hostname = base::Sys.info()[["nodename"]])
[17:39:57.045]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.045]                               info)
[17:39:57.045]                             info <- base::paste(info, collapse = "; ")
[17:39:57.045]                             if (!has_future) {
[17:39:57.045]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.045]                                 info)
[17:39:57.045]                             }
[17:39:57.045]                             else {
[17:39:57.045]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.045]                                 info, version)
[17:39:57.045]                             }
[17:39:57.045]                             base::stop(msg)
[17:39:57.045]                           }
[17:39:57.045]                         })
[17:39:57.045]                       }
[17:39:57.045]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.045]                       base::options(mc.cores = 1L)
[17:39:57.045]                     }
[17:39:57.045]                     base::local({
[17:39:57.045]                       for (pkg in "future") {
[17:39:57.045]                         base::loadNamespace(pkg)
[17:39:57.045]                         base::library(pkg, character.only = TRUE)
[17:39:57.045]                       }
[17:39:57.045]                     })
[17:39:57.045]                   }
[17:39:57.045]                   ...future.strategy.old <- future::plan("list")
[17:39:57.045]                   options(future.plan = NULL)
[17:39:57.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.045]                 }
[17:39:57.045]                 ...future.workdir <- getwd()
[17:39:57.045]             }
[17:39:57.045]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.045]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.045]         }
[17:39:57.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.045]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.045]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.045]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.045]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.045]             base::names(...future.oldOptions))
[17:39:57.045]     }
[17:39:57.045]     if (FALSE) {
[17:39:57.045]     }
[17:39:57.045]     else {
[17:39:57.045]         if (TRUE) {
[17:39:57.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.045]                 open = "w")
[17:39:57.045]         }
[17:39:57.045]         else {
[17:39:57.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.045]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.045]         }
[17:39:57.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.045]             base::sink(type = "output", split = FALSE)
[17:39:57.045]             base::close(...future.stdout)
[17:39:57.045]         }, add = TRUE)
[17:39:57.045]     }
[17:39:57.045]     ...future.frame <- base::sys.nframe()
[17:39:57.045]     ...future.conditions <- base::list()
[17:39:57.045]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.045]     if (FALSE) {
[17:39:57.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.045]     }
[17:39:57.045]     ...future.result <- base::tryCatch({
[17:39:57.045]         base::withCallingHandlers({
[17:39:57.045]             ...future.value <- base::withVisible(base::local({
[17:39:57.045]                 withCallingHandlers({
[17:39:57.045]                   value(a) + 1
[17:39:57.045]                 }, immediateCondition = function(cond) {
[17:39:57.045]                   save_rds <- function (object, pathname, ...) 
[17:39:57.045]                   {
[17:39:57.045]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.045]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.045]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.045]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.045]                         fi_tmp[["mtime"]])
[17:39:57.045]                     }
[17:39:57.045]                     tryCatch({
[17:39:57.045]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.045]                     }, error = function(ex) {
[17:39:57.045]                       msg <- conditionMessage(ex)
[17:39:57.045]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.045]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.045]                         fi_tmp[["mtime"]], msg)
[17:39:57.045]                       ex$message <- msg
[17:39:57.045]                       stop(ex)
[17:39:57.045]                     })
[17:39:57.045]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.045]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.045]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.045]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.045]                       fi <- file.info(pathname)
[17:39:57.045]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.045]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.045]                         fi[["size"]], fi[["mtime"]])
[17:39:57.045]                       stop(msg)
[17:39:57.045]                     }
[17:39:57.045]                     invisible(pathname)
[17:39:57.045]                   }
[17:39:57.045]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.045]                     rootPath = tempdir()) 
[17:39:57.045]                   {
[17:39:57.045]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.045]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.045]                       tmpdir = path, fileext = ".rds")
[17:39:57.045]                     save_rds(obj, file)
[17:39:57.045]                   }
[17:39:57.045]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.045]                   {
[17:39:57.045]                     inherits <- base::inherits
[17:39:57.045]                     invokeRestart <- base::invokeRestart
[17:39:57.045]                     is.null <- base::is.null
[17:39:57.045]                     muffled <- FALSE
[17:39:57.045]                     if (inherits(cond, "message")) {
[17:39:57.045]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.045]                       if (muffled) 
[17:39:57.045]                         invokeRestart("muffleMessage")
[17:39:57.045]                     }
[17:39:57.045]                     else if (inherits(cond, "warning")) {
[17:39:57.045]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.045]                       if (muffled) 
[17:39:57.045]                         invokeRestart("muffleWarning")
[17:39:57.045]                     }
[17:39:57.045]                     else if (inherits(cond, "condition")) {
[17:39:57.045]                       if (!is.null(pattern)) {
[17:39:57.045]                         computeRestarts <- base::computeRestarts
[17:39:57.045]                         grepl <- base::grepl
[17:39:57.045]                         restarts <- computeRestarts(cond)
[17:39:57.045]                         for (restart in restarts) {
[17:39:57.045]                           name <- restart$name
[17:39:57.045]                           if (is.null(name)) 
[17:39:57.045]                             next
[17:39:57.045]                           if (!grepl(pattern, name)) 
[17:39:57.045]                             next
[17:39:57.045]                           invokeRestart(restart)
[17:39:57.045]                           muffled <- TRUE
[17:39:57.045]                           break
[17:39:57.045]                         }
[17:39:57.045]                       }
[17:39:57.045]                     }
[17:39:57.045]                     invisible(muffled)
[17:39:57.045]                   }
[17:39:57.045]                   muffleCondition(cond)
[17:39:57.045]                 })
[17:39:57.045]             }))
[17:39:57.045]             future::FutureResult(value = ...future.value$value, 
[17:39:57.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.045]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.045]                     ...future.globalenv.names))
[17:39:57.045]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.045]         }, condition = base::local({
[17:39:57.045]             c <- base::c
[17:39:57.045]             inherits <- base::inherits
[17:39:57.045]             invokeRestart <- base::invokeRestart
[17:39:57.045]             length <- base::length
[17:39:57.045]             list <- base::list
[17:39:57.045]             seq.int <- base::seq.int
[17:39:57.045]             signalCondition <- base::signalCondition
[17:39:57.045]             sys.calls <- base::sys.calls
[17:39:57.045]             `[[` <- base::`[[`
[17:39:57.045]             `+` <- base::`+`
[17:39:57.045]             `<<-` <- base::`<<-`
[17:39:57.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.045]                   3L)]
[17:39:57.045]             }
[17:39:57.045]             function(cond) {
[17:39:57.045]                 is_error <- inherits(cond, "error")
[17:39:57.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.045]                   NULL)
[17:39:57.045]                 if (is_error) {
[17:39:57.045]                   sessionInformation <- function() {
[17:39:57.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.045]                       search = base::search(), system = base::Sys.info())
[17:39:57.045]                   }
[17:39:57.045]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.045]                     cond$call), session = sessionInformation(), 
[17:39:57.045]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.045]                   signalCondition(cond)
[17:39:57.045]                 }
[17:39:57.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.045]                 "immediateCondition"))) {
[17:39:57.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.045]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.045]                   if (TRUE && !signal) {
[17:39:57.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.045]                     {
[17:39:57.045]                       inherits <- base::inherits
[17:39:57.045]                       invokeRestart <- base::invokeRestart
[17:39:57.045]                       is.null <- base::is.null
[17:39:57.045]                       muffled <- FALSE
[17:39:57.045]                       if (inherits(cond, "message")) {
[17:39:57.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.045]                         if (muffled) 
[17:39:57.045]                           invokeRestart("muffleMessage")
[17:39:57.045]                       }
[17:39:57.045]                       else if (inherits(cond, "warning")) {
[17:39:57.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.045]                         if (muffled) 
[17:39:57.045]                           invokeRestart("muffleWarning")
[17:39:57.045]                       }
[17:39:57.045]                       else if (inherits(cond, "condition")) {
[17:39:57.045]                         if (!is.null(pattern)) {
[17:39:57.045]                           computeRestarts <- base::computeRestarts
[17:39:57.045]                           grepl <- base::grepl
[17:39:57.045]                           restarts <- computeRestarts(cond)
[17:39:57.045]                           for (restart in restarts) {
[17:39:57.045]                             name <- restart$name
[17:39:57.045]                             if (is.null(name)) 
[17:39:57.045]                               next
[17:39:57.045]                             if (!grepl(pattern, name)) 
[17:39:57.045]                               next
[17:39:57.045]                             invokeRestart(restart)
[17:39:57.045]                             muffled <- TRUE
[17:39:57.045]                             break
[17:39:57.045]                           }
[17:39:57.045]                         }
[17:39:57.045]                       }
[17:39:57.045]                       invisible(muffled)
[17:39:57.045]                     }
[17:39:57.045]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.045]                   }
[17:39:57.045]                 }
[17:39:57.045]                 else {
[17:39:57.045]                   if (TRUE) {
[17:39:57.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.045]                     {
[17:39:57.045]                       inherits <- base::inherits
[17:39:57.045]                       invokeRestart <- base::invokeRestart
[17:39:57.045]                       is.null <- base::is.null
[17:39:57.045]                       muffled <- FALSE
[17:39:57.045]                       if (inherits(cond, "message")) {
[17:39:57.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.045]                         if (muffled) 
[17:39:57.045]                           invokeRestart("muffleMessage")
[17:39:57.045]                       }
[17:39:57.045]                       else if (inherits(cond, "warning")) {
[17:39:57.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.045]                         if (muffled) 
[17:39:57.045]                           invokeRestart("muffleWarning")
[17:39:57.045]                       }
[17:39:57.045]                       else if (inherits(cond, "condition")) {
[17:39:57.045]                         if (!is.null(pattern)) {
[17:39:57.045]                           computeRestarts <- base::computeRestarts
[17:39:57.045]                           grepl <- base::grepl
[17:39:57.045]                           restarts <- computeRestarts(cond)
[17:39:57.045]                           for (restart in restarts) {
[17:39:57.045]                             name <- restart$name
[17:39:57.045]                             if (is.null(name)) 
[17:39:57.045]                               next
[17:39:57.045]                             if (!grepl(pattern, name)) 
[17:39:57.045]                               next
[17:39:57.045]                             invokeRestart(restart)
[17:39:57.045]                             muffled <- TRUE
[17:39:57.045]                             break
[17:39:57.045]                           }
[17:39:57.045]                         }
[17:39:57.045]                       }
[17:39:57.045]                       invisible(muffled)
[17:39:57.045]                     }
[17:39:57.045]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.045]                   }
[17:39:57.045]                 }
[17:39:57.045]             }
[17:39:57.045]         }))
[17:39:57.045]     }, error = function(ex) {
[17:39:57.045]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.045]                 ...future.rng), started = ...future.startTime, 
[17:39:57.045]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.045]             version = "1.8"), class = "FutureResult")
[17:39:57.045]     }, finally = {
[17:39:57.045]         if (!identical(...future.workdir, getwd())) 
[17:39:57.045]             setwd(...future.workdir)
[17:39:57.045]         {
[17:39:57.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.045]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.045]             }
[17:39:57.045]             base::options(...future.oldOptions)
[17:39:57.045]             if (.Platform$OS.type == "windows") {
[17:39:57.045]                 old_names <- names(...future.oldEnvVars)
[17:39:57.045]                 envs <- base::Sys.getenv()
[17:39:57.045]                 names <- names(envs)
[17:39:57.045]                 common <- intersect(names, old_names)
[17:39:57.045]                 added <- setdiff(names, old_names)
[17:39:57.045]                 removed <- setdiff(old_names, names)
[17:39:57.045]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.045]                   envs[common]]
[17:39:57.045]                 NAMES <- toupper(changed)
[17:39:57.045]                 args <- list()
[17:39:57.045]                 for (kk in seq_along(NAMES)) {
[17:39:57.045]                   name <- changed[[kk]]
[17:39:57.045]                   NAME <- NAMES[[kk]]
[17:39:57.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.045]                     next
[17:39:57.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.045]                 }
[17:39:57.045]                 NAMES <- toupper(added)
[17:39:57.045]                 for (kk in seq_along(NAMES)) {
[17:39:57.045]                   name <- added[[kk]]
[17:39:57.045]                   NAME <- NAMES[[kk]]
[17:39:57.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.045]                     next
[17:39:57.045]                   args[[name]] <- ""
[17:39:57.045]                 }
[17:39:57.045]                 NAMES <- toupper(removed)
[17:39:57.045]                 for (kk in seq_along(NAMES)) {
[17:39:57.045]                   name <- removed[[kk]]
[17:39:57.045]                   NAME <- NAMES[[kk]]
[17:39:57.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.045]                     next
[17:39:57.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.045]                 }
[17:39:57.045]                 if (length(args) > 0) 
[17:39:57.045]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.045]             }
[17:39:57.045]             else {
[17:39:57.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.045]             }
[17:39:57.045]             {
[17:39:57.045]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.045]                   0L) {
[17:39:57.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.045]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.045]                   base::options(opts)
[17:39:57.045]                 }
[17:39:57.045]                 {
[17:39:57.045]                   {
[17:39:57.045]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.045]                     NULL
[17:39:57.045]                   }
[17:39:57.045]                   options(future.plan = NULL)
[17:39:57.045]                   if (is.na(NA_character_)) 
[17:39:57.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.045]                     .init = FALSE)
[17:39:57.045]                 }
[17:39:57.045]             }
[17:39:57.045]         }
[17:39:57.045]     })
[17:39:57.045]     if (TRUE) {
[17:39:57.045]         base::sink(type = "output", split = FALSE)
[17:39:57.045]         if (TRUE) {
[17:39:57.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.045]         }
[17:39:57.045]         else {
[17:39:57.045]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.045]         }
[17:39:57.045]         base::close(...future.stdout)
[17:39:57.045]         ...future.stdout <- NULL
[17:39:57.045]     }
[17:39:57.045]     ...future.result$conditions <- ...future.conditions
[17:39:57.045]     ...future.result$finished <- base::Sys.time()
[17:39:57.045]     ...future.result
[17:39:57.045] }
[17:39:57.048] assign_globals() ...
[17:39:57.048] List of 1
[17:39:57.048]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd8537e68> 
[17:39:57.048]  - attr(*, "where")=List of 1
[17:39:57.048]   ..$ a:<environment: R_EmptyEnv> 
[17:39:57.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.048]  - attr(*, "resolved")= logi TRUE
[17:39:57.048]  - attr(*, "total_size")= num 1647480
[17:39:57.048]  - attr(*, "already-done")= logi TRUE
[17:39:57.053] - copied ‘a’ to environment
[17:39:57.053] assign_globals() ... done
[17:39:57.054] requestCore(): workers = 2
[17:39:57.056] MulticoreFuture started
[17:39:57.056] - Launch lazy future ... done
[17:39:57.056] run() for ‘MulticoreFuture’ ... done
[17:39:57.057] result() for MulticoreFuture ...
[17:39:57.057] plan(): Setting new future strategy stack:
[17:39:57.057] List of future strategies:
[17:39:57.057] 1. sequential:
[17:39:57.057]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.057]    - tweaked: FALSE
[17:39:57.057]    - call: NULL
[17:39:57.058] plan(): nbrOfWorkers() = 1
[17:39:57.063] plan(): Setting new future strategy stack:
[17:39:57.063] List of future strategies:
[17:39:57.063] 1. multicore:
[17:39:57.063]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.063]    - tweaked: FALSE
[17:39:57.063]    - call: plan(strategy)
[17:39:57.070] plan(): nbrOfWorkers() = 2
[17:39:57.071] result() for MulticoreFuture ...
[17:39:57.071] result() for MulticoreFuture ... done
[17:39:57.071] signalConditions() ...
[17:39:57.072]  - include = ‘immediateCondition’
[17:39:57.072]  - exclude = 
[17:39:57.072]  - resignal = FALSE
[17:39:57.072]  - Number of conditions: 4
[17:39:57.072] signalConditions() ... done
[17:39:57.072] result() for MulticoreFuture ... done
[17:39:57.073] result() for MulticoreFuture ...
[17:39:57.073] result() for MulticoreFuture ... done
[17:39:57.073] signalConditions() ...
[17:39:57.073]  - include = ‘immediateCondition’
[17:39:57.073]  - exclude = 
[17:39:57.074]  - resignal = FALSE
[17:39:57.074]  - Number of conditions: 4
[17:39:57.074] signalConditions() ... done
[17:39:57.074] Future state: ‘finished’
[17:39:57.074] result() for MulticoreFuture ...
[17:39:57.075] result() for MulticoreFuture ... done
[17:39:57.075] signalConditions() ...
[17:39:57.075]  - include = ‘condition’
[17:39:57.075]  - exclude = ‘immediateCondition’
[17:39:57.075]  - resignal = TRUE
[17:39:57.075]  - Number of conditions: 4
[17:39:57.076]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.060] result() for MulticoreFuture ...
[17:39:57.076]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.060] result() for MulticoreFuture ... done
[17:39:57.076]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.061] result() for MulticoreFuture ...
[17:39:57.076]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.061] result() for MulticoreFuture ... done
[17:39:57.076] signalConditions() ... done
value(b) = 2
[17:39:57.077] result() for MulticoreFuture ...
[17:39:57.077] result() for MulticoreFuture ... done
[17:39:57.077] result() for MulticoreFuture ...
[17:39:57.077] result() for MulticoreFuture ... done
[17:39:57.077] signalConditions() ...
[17:39:57.077]  - include = ‘immediateCondition’
[17:39:57.077]  - exclude = 
[17:39:57.078]  - resignal = FALSE
[17:39:57.078]  - Number of conditions: 4
[17:39:57.078] signalConditions() ... done
[17:39:57.078] Future state: ‘finished’
[17:39:57.078] result() for MulticoreFuture ...
[17:39:57.078] result() for MulticoreFuture ... done
[17:39:57.078] signalConditions() ...
[17:39:57.078]  - include = ‘condition’
[17:39:57.079]  - exclude = ‘immediateCondition’
[17:39:57.079]  - resignal = TRUE
[17:39:57.079]  - Number of conditions: 4
[17:39:57.079]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.060] result() for MulticoreFuture ...
[17:39:57.079]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.060] result() for MulticoreFuture ... done
[17:39:57.079]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.061] result() for MulticoreFuture ...
[17:39:57.079]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.061] result() for MulticoreFuture ... done
[17:39:57.079] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.080] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.080] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.081] 
[17:39:57.081] Searching for globals ... DONE
[17:39:57.081] - globals: [0] <none>
[17:39:57.081] getGlobalsAndPackages() ... DONE
[17:39:57.081] run() for ‘Future’ ...
[17:39:57.081] - state: ‘created’
[17:39:57.082] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.086] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.086]   - Field: ‘label’
[17:39:57.086]   - Field: ‘local’
[17:39:57.086]   - Field: ‘owner’
[17:39:57.086]   - Field: ‘envir’
[17:39:57.086]   - Field: ‘workers’
[17:39:57.086]   - Field: ‘packages’
[17:39:57.087]   - Field: ‘gc’
[17:39:57.087]   - Field: ‘job’
[17:39:57.087]   - Field: ‘conditions’
[17:39:57.087]   - Field: ‘expr’
[17:39:57.087]   - Field: ‘uuid’
[17:39:57.087]   - Field: ‘seed’
[17:39:57.087]   - Field: ‘version’
[17:39:57.087]   - Field: ‘result’
[17:39:57.087]   - Field: ‘asynchronous’
[17:39:57.087]   - Field: ‘calls’
[17:39:57.088]   - Field: ‘globals’
[17:39:57.088]   - Field: ‘stdout’
[17:39:57.088]   - Field: ‘earlySignal’
[17:39:57.088]   - Field: ‘lazy’
[17:39:57.088]   - Field: ‘state’
[17:39:57.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.088] - Launch lazy future ...
[17:39:57.089] Packages needed by the future expression (n = 0): <none>
[17:39:57.089] Packages needed by future strategies (n = 0): <none>
[17:39:57.089] {
[17:39:57.089]     {
[17:39:57.089]         {
[17:39:57.089]             ...future.startTime <- base::Sys.time()
[17:39:57.089]             {
[17:39:57.089]                 {
[17:39:57.089]                   {
[17:39:57.089]                     {
[17:39:57.089]                       base::local({
[17:39:57.089]                         has_future <- base::requireNamespace("future", 
[17:39:57.089]                           quietly = TRUE)
[17:39:57.089]                         if (has_future) {
[17:39:57.089]                           ns <- base::getNamespace("future")
[17:39:57.089]                           version <- ns[[".package"]][["version"]]
[17:39:57.089]                           if (is.null(version)) 
[17:39:57.089]                             version <- utils::packageVersion("future")
[17:39:57.089]                         }
[17:39:57.089]                         else {
[17:39:57.089]                           version <- NULL
[17:39:57.089]                         }
[17:39:57.089]                         if (!has_future || version < "1.8.0") {
[17:39:57.089]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.089]                             "", base::R.version$version.string), 
[17:39:57.089]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.089]                               "release", "version")], collapse = " "), 
[17:39:57.089]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.089]                             info)
[17:39:57.089]                           info <- base::paste(info, collapse = "; ")
[17:39:57.089]                           if (!has_future) {
[17:39:57.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.089]                               info)
[17:39:57.089]                           }
[17:39:57.089]                           else {
[17:39:57.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.089]                               info, version)
[17:39:57.089]                           }
[17:39:57.089]                           base::stop(msg)
[17:39:57.089]                         }
[17:39:57.089]                       })
[17:39:57.089]                     }
[17:39:57.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.089]                     base::options(mc.cores = 1L)
[17:39:57.089]                   }
[17:39:57.089]                   ...future.strategy.old <- future::plan("list")
[17:39:57.089]                   options(future.plan = NULL)
[17:39:57.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.089]                 }
[17:39:57.089]                 ...future.workdir <- getwd()
[17:39:57.089]             }
[17:39:57.089]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.089]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.089]         }
[17:39:57.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.089]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.089]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.089]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.089]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.089]             base::names(...future.oldOptions))
[17:39:57.089]     }
[17:39:57.089]     if (FALSE) {
[17:39:57.089]     }
[17:39:57.089]     else {
[17:39:57.089]         if (TRUE) {
[17:39:57.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.089]                 open = "w")
[17:39:57.089]         }
[17:39:57.089]         else {
[17:39:57.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.089]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.089]         }
[17:39:57.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.089]             base::sink(type = "output", split = FALSE)
[17:39:57.089]             base::close(...future.stdout)
[17:39:57.089]         }, add = TRUE)
[17:39:57.089]     }
[17:39:57.089]     ...future.frame <- base::sys.nframe()
[17:39:57.089]     ...future.conditions <- base::list()
[17:39:57.089]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.089]     if (FALSE) {
[17:39:57.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.089]     }
[17:39:57.089]     ...future.result <- base::tryCatch({
[17:39:57.089]         base::withCallingHandlers({
[17:39:57.089]             ...future.value <- base::withVisible(base::local({
[17:39:57.089]                 withCallingHandlers({
[17:39:57.089]                   1
[17:39:57.089]                 }, immediateCondition = function(cond) {
[17:39:57.089]                   save_rds <- function (object, pathname, ...) 
[17:39:57.089]                   {
[17:39:57.089]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.089]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.089]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.089]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.089]                         fi_tmp[["mtime"]])
[17:39:57.089]                     }
[17:39:57.089]                     tryCatch({
[17:39:57.089]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.089]                     }, error = function(ex) {
[17:39:57.089]                       msg <- conditionMessage(ex)
[17:39:57.089]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.089]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.089]                         fi_tmp[["mtime"]], msg)
[17:39:57.089]                       ex$message <- msg
[17:39:57.089]                       stop(ex)
[17:39:57.089]                     })
[17:39:57.089]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.089]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.089]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.089]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.089]                       fi <- file.info(pathname)
[17:39:57.089]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.089]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.089]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.089]                         fi[["size"]], fi[["mtime"]])
[17:39:57.089]                       stop(msg)
[17:39:57.089]                     }
[17:39:57.089]                     invisible(pathname)
[17:39:57.089]                   }
[17:39:57.089]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.089]                     rootPath = tempdir()) 
[17:39:57.089]                   {
[17:39:57.089]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.089]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.089]                       tmpdir = path, fileext = ".rds")
[17:39:57.089]                     save_rds(obj, file)
[17:39:57.089]                   }
[17:39:57.089]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.089]                   {
[17:39:57.089]                     inherits <- base::inherits
[17:39:57.089]                     invokeRestart <- base::invokeRestart
[17:39:57.089]                     is.null <- base::is.null
[17:39:57.089]                     muffled <- FALSE
[17:39:57.089]                     if (inherits(cond, "message")) {
[17:39:57.089]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.089]                       if (muffled) 
[17:39:57.089]                         invokeRestart("muffleMessage")
[17:39:57.089]                     }
[17:39:57.089]                     else if (inherits(cond, "warning")) {
[17:39:57.089]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.089]                       if (muffled) 
[17:39:57.089]                         invokeRestart("muffleWarning")
[17:39:57.089]                     }
[17:39:57.089]                     else if (inherits(cond, "condition")) {
[17:39:57.089]                       if (!is.null(pattern)) {
[17:39:57.089]                         computeRestarts <- base::computeRestarts
[17:39:57.089]                         grepl <- base::grepl
[17:39:57.089]                         restarts <- computeRestarts(cond)
[17:39:57.089]                         for (restart in restarts) {
[17:39:57.089]                           name <- restart$name
[17:39:57.089]                           if (is.null(name)) 
[17:39:57.089]                             next
[17:39:57.089]                           if (!grepl(pattern, name)) 
[17:39:57.089]                             next
[17:39:57.089]                           invokeRestart(restart)
[17:39:57.089]                           muffled <- TRUE
[17:39:57.089]                           break
[17:39:57.089]                         }
[17:39:57.089]                       }
[17:39:57.089]                     }
[17:39:57.089]                     invisible(muffled)
[17:39:57.089]                   }
[17:39:57.089]                   muffleCondition(cond)
[17:39:57.089]                 })
[17:39:57.089]             }))
[17:39:57.089]             future::FutureResult(value = ...future.value$value, 
[17:39:57.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.089]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.089]                     ...future.globalenv.names))
[17:39:57.089]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.089]         }, condition = base::local({
[17:39:57.089]             c <- base::c
[17:39:57.089]             inherits <- base::inherits
[17:39:57.089]             invokeRestart <- base::invokeRestart
[17:39:57.089]             length <- base::length
[17:39:57.089]             list <- base::list
[17:39:57.089]             seq.int <- base::seq.int
[17:39:57.089]             signalCondition <- base::signalCondition
[17:39:57.089]             sys.calls <- base::sys.calls
[17:39:57.089]             `[[` <- base::`[[`
[17:39:57.089]             `+` <- base::`+`
[17:39:57.089]             `<<-` <- base::`<<-`
[17:39:57.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.089]                   3L)]
[17:39:57.089]             }
[17:39:57.089]             function(cond) {
[17:39:57.089]                 is_error <- inherits(cond, "error")
[17:39:57.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.089]                   NULL)
[17:39:57.089]                 if (is_error) {
[17:39:57.089]                   sessionInformation <- function() {
[17:39:57.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.089]                       search = base::search(), system = base::Sys.info())
[17:39:57.089]                   }
[17:39:57.089]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.089]                     cond$call), session = sessionInformation(), 
[17:39:57.089]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.089]                   signalCondition(cond)
[17:39:57.089]                 }
[17:39:57.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.089]                 "immediateCondition"))) {
[17:39:57.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.089]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.089]                   if (TRUE && !signal) {
[17:39:57.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.089]                     {
[17:39:57.089]                       inherits <- base::inherits
[17:39:57.089]                       invokeRestart <- base::invokeRestart
[17:39:57.089]                       is.null <- base::is.null
[17:39:57.089]                       muffled <- FALSE
[17:39:57.089]                       if (inherits(cond, "message")) {
[17:39:57.089]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.089]                         if (muffled) 
[17:39:57.089]                           invokeRestart("muffleMessage")
[17:39:57.089]                       }
[17:39:57.089]                       else if (inherits(cond, "warning")) {
[17:39:57.089]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.089]                         if (muffled) 
[17:39:57.089]                           invokeRestart("muffleWarning")
[17:39:57.089]                       }
[17:39:57.089]                       else if (inherits(cond, "condition")) {
[17:39:57.089]                         if (!is.null(pattern)) {
[17:39:57.089]                           computeRestarts <- base::computeRestarts
[17:39:57.089]                           grepl <- base::grepl
[17:39:57.089]                           restarts <- computeRestarts(cond)
[17:39:57.089]                           for (restart in restarts) {
[17:39:57.089]                             name <- restart$name
[17:39:57.089]                             if (is.null(name)) 
[17:39:57.089]                               next
[17:39:57.089]                             if (!grepl(pattern, name)) 
[17:39:57.089]                               next
[17:39:57.089]                             invokeRestart(restart)
[17:39:57.089]                             muffled <- TRUE
[17:39:57.089]                             break
[17:39:57.089]                           }
[17:39:57.089]                         }
[17:39:57.089]                       }
[17:39:57.089]                       invisible(muffled)
[17:39:57.089]                     }
[17:39:57.089]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.089]                   }
[17:39:57.089]                 }
[17:39:57.089]                 else {
[17:39:57.089]                   if (TRUE) {
[17:39:57.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.089]                     {
[17:39:57.089]                       inherits <- base::inherits
[17:39:57.089]                       invokeRestart <- base::invokeRestart
[17:39:57.089]                       is.null <- base::is.null
[17:39:57.089]                       muffled <- FALSE
[17:39:57.089]                       if (inherits(cond, "message")) {
[17:39:57.089]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.089]                         if (muffled) 
[17:39:57.089]                           invokeRestart("muffleMessage")
[17:39:57.089]                       }
[17:39:57.089]                       else if (inherits(cond, "warning")) {
[17:39:57.089]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.089]                         if (muffled) 
[17:39:57.089]                           invokeRestart("muffleWarning")
[17:39:57.089]                       }
[17:39:57.089]                       else if (inherits(cond, "condition")) {
[17:39:57.089]                         if (!is.null(pattern)) {
[17:39:57.089]                           computeRestarts <- base::computeRestarts
[17:39:57.089]                           grepl <- base::grepl
[17:39:57.089]                           restarts <- computeRestarts(cond)
[17:39:57.089]                           for (restart in restarts) {
[17:39:57.089]                             name <- restart$name
[17:39:57.089]                             if (is.null(name)) 
[17:39:57.089]                               next
[17:39:57.089]                             if (!grepl(pattern, name)) 
[17:39:57.089]                               next
[17:39:57.089]                             invokeRestart(restart)
[17:39:57.089]                             muffled <- TRUE
[17:39:57.089]                             break
[17:39:57.089]                           }
[17:39:57.089]                         }
[17:39:57.089]                       }
[17:39:57.089]                       invisible(muffled)
[17:39:57.089]                     }
[17:39:57.089]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.089]                   }
[17:39:57.089]                 }
[17:39:57.089]             }
[17:39:57.089]         }))
[17:39:57.089]     }, error = function(ex) {
[17:39:57.089]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.089]                 ...future.rng), started = ...future.startTime, 
[17:39:57.089]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.089]             version = "1.8"), class = "FutureResult")
[17:39:57.089]     }, finally = {
[17:39:57.089]         if (!identical(...future.workdir, getwd())) 
[17:39:57.089]             setwd(...future.workdir)
[17:39:57.089]         {
[17:39:57.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.089]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.089]             }
[17:39:57.089]             base::options(...future.oldOptions)
[17:39:57.089]             if (.Platform$OS.type == "windows") {
[17:39:57.089]                 old_names <- names(...future.oldEnvVars)
[17:39:57.089]                 envs <- base::Sys.getenv()
[17:39:57.089]                 names <- names(envs)
[17:39:57.089]                 common <- intersect(names, old_names)
[17:39:57.089]                 added <- setdiff(names, old_names)
[17:39:57.089]                 removed <- setdiff(old_names, names)
[17:39:57.089]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.089]                   envs[common]]
[17:39:57.089]                 NAMES <- toupper(changed)
[17:39:57.089]                 args <- list()
[17:39:57.089]                 for (kk in seq_along(NAMES)) {
[17:39:57.089]                   name <- changed[[kk]]
[17:39:57.089]                   NAME <- NAMES[[kk]]
[17:39:57.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.089]                     next
[17:39:57.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.089]                 }
[17:39:57.089]                 NAMES <- toupper(added)
[17:39:57.089]                 for (kk in seq_along(NAMES)) {
[17:39:57.089]                   name <- added[[kk]]
[17:39:57.089]                   NAME <- NAMES[[kk]]
[17:39:57.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.089]                     next
[17:39:57.089]                   args[[name]] <- ""
[17:39:57.089]                 }
[17:39:57.089]                 NAMES <- toupper(removed)
[17:39:57.089]                 for (kk in seq_along(NAMES)) {
[17:39:57.089]                   name <- removed[[kk]]
[17:39:57.089]                   NAME <- NAMES[[kk]]
[17:39:57.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.089]                     next
[17:39:57.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.089]                 }
[17:39:57.089]                 if (length(args) > 0) 
[17:39:57.089]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.089]             }
[17:39:57.089]             else {
[17:39:57.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.089]             }
[17:39:57.089]             {
[17:39:57.089]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.089]                   0L) {
[17:39:57.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.089]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.089]                   base::options(opts)
[17:39:57.089]                 }
[17:39:57.089]                 {
[17:39:57.089]                   {
[17:39:57.089]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.089]                     NULL
[17:39:57.089]                   }
[17:39:57.089]                   options(future.plan = NULL)
[17:39:57.089]                   if (is.na(NA_character_)) 
[17:39:57.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.089]                     .init = FALSE)
[17:39:57.089]                 }
[17:39:57.089]             }
[17:39:57.089]         }
[17:39:57.089]     })
[17:39:57.089]     if (TRUE) {
[17:39:57.089]         base::sink(type = "output", split = FALSE)
[17:39:57.089]         if (TRUE) {
[17:39:57.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.089]         }
[17:39:57.089]         else {
[17:39:57.089]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.089]         }
[17:39:57.089]         base::close(...future.stdout)
[17:39:57.089]         ...future.stdout <- NULL
[17:39:57.089]     }
[17:39:57.089]     ...future.result$conditions <- ...future.conditions
[17:39:57.089]     ...future.result$finished <- base::Sys.time()
[17:39:57.089]     ...future.result
[17:39:57.089] }
[17:39:57.092] requestCore(): workers = 2
[17:39:57.094] MulticoreFuture started
[17:39:57.094] - Launch lazy future ... done
[17:39:57.094] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.094] plan(): Setting new future strategy stack:
[17:39:57.095] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.095] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.095] List of future strategies:
[17:39:57.095] 1. sequential:
[17:39:57.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.095]    - tweaked: FALSE
[17:39:57.095]    - call: NULL
[17:39:57.096] plan(): nbrOfWorkers() = 1
[17:39:57.097] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:57.097] Searching for globals ... DONE
[17:39:57.097] Resolving globals: TRUE
[17:39:57.097] Resolving any globals that are futures ...
[17:39:57.097] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:57.098] Resolving any globals that are futures ... DONE
[17:39:57.098] plan(): Setting new future strategy stack:
[17:39:57.098] List of future strategies:
[17:39:57.098] 1. multicore:
[17:39:57.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.098]    - tweaked: FALSE
[17:39:57.098]    - call: plan(strategy)
[17:39:57.098] Resolving futures part of globals (recursively) ...
[17:39:57.099] resolve() on list ...
[17:39:57.099]  recursive: 99
[17:39:57.099]  length: 1
[17:39:57.099]  elements: ‘a’
[17:39:57.102] plan(): nbrOfWorkers() = 2
[17:39:57.103] Future #1
[17:39:57.103] result() for MulticoreFuture ...
[17:39:57.104] result() for MulticoreFuture ...
[17:39:57.104] result() for MulticoreFuture ... done
[17:39:57.104] result() for MulticoreFuture ... done
[17:39:57.104] result() for MulticoreFuture ...
[17:39:57.104] result() for MulticoreFuture ... done
[17:39:57.105] A MulticoreFuture was resolved
[17:39:57.105]  length: 0 (resolved future 1)
[17:39:57.105] resolve() on list ... DONE
[17:39:57.105] - globals: [1] ‘a’
[17:39:57.105] Resolving futures part of globals (recursively) ... DONE
[17:39:57.108] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[17:39:57.108] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:57.109] - globals: [1] ‘a’
[17:39:57.109] - packages: [1] ‘future’
[17:39:57.109] getGlobalsAndPackages() ... DONE
[17:39:57.109] run() for ‘Future’ ...
[17:39:57.109] - state: ‘created’
[17:39:57.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.116]   - Field: ‘label’
[17:39:57.116]   - Field: ‘local’
[17:39:57.117]   - Field: ‘owner’
[17:39:57.117]   - Field: ‘envir’
[17:39:57.117]   - Field: ‘workers’
[17:39:57.117]   - Field: ‘packages’
[17:39:57.117]   - Field: ‘gc’
[17:39:57.117]   - Field: ‘job’
[17:39:57.117]   - Field: ‘conditions’
[17:39:57.117]   - Field: ‘expr’
[17:39:57.117]   - Field: ‘uuid’
[17:39:57.118]   - Field: ‘seed’
[17:39:57.118]   - Field: ‘version’
[17:39:57.118]   - Field: ‘result’
[17:39:57.118]   - Field: ‘asynchronous’
[17:39:57.118]   - Field: ‘calls’
[17:39:57.118]   - Field: ‘globals’
[17:39:57.118]   - Field: ‘stdout’
[17:39:57.118]   - Field: ‘earlySignal’
[17:39:57.119]   - Field: ‘lazy’
[17:39:57.119]   - Field: ‘state’
[17:39:57.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.119] - Launch lazy future ...
[17:39:57.119] Packages needed by the future expression (n = 1): ‘future’
[17:39:57.119] Packages needed by future strategies (n = 0): <none>
[17:39:57.120] {
[17:39:57.120]     {
[17:39:57.120]         {
[17:39:57.120]             ...future.startTime <- base::Sys.time()
[17:39:57.120]             {
[17:39:57.120]                 {
[17:39:57.120]                   {
[17:39:57.120]                     {
[17:39:57.120]                       {
[17:39:57.120]                         base::local({
[17:39:57.120]                           has_future <- base::requireNamespace("future", 
[17:39:57.120]                             quietly = TRUE)
[17:39:57.120]                           if (has_future) {
[17:39:57.120]                             ns <- base::getNamespace("future")
[17:39:57.120]                             version <- ns[[".package"]][["version"]]
[17:39:57.120]                             if (is.null(version)) 
[17:39:57.120]                               version <- utils::packageVersion("future")
[17:39:57.120]                           }
[17:39:57.120]                           else {
[17:39:57.120]                             version <- NULL
[17:39:57.120]                           }
[17:39:57.120]                           if (!has_future || version < "1.8.0") {
[17:39:57.120]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.120]                               "", base::R.version$version.string), 
[17:39:57.120]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:57.120]                                 base::R.version$platform, 8 * 
[17:39:57.120]                                   base::.Machine$sizeof.pointer), 
[17:39:57.120]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.120]                                 "release", "version")], collapse = " "), 
[17:39:57.120]                               hostname = base::Sys.info()[["nodename"]])
[17:39:57.120]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.120]                               info)
[17:39:57.120]                             info <- base::paste(info, collapse = "; ")
[17:39:57.120]                             if (!has_future) {
[17:39:57.120]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.120]                                 info)
[17:39:57.120]                             }
[17:39:57.120]                             else {
[17:39:57.120]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.120]                                 info, version)
[17:39:57.120]                             }
[17:39:57.120]                             base::stop(msg)
[17:39:57.120]                           }
[17:39:57.120]                         })
[17:39:57.120]                       }
[17:39:57.120]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.120]                       base::options(mc.cores = 1L)
[17:39:57.120]                     }
[17:39:57.120]                     base::local({
[17:39:57.120]                       for (pkg in "future") {
[17:39:57.120]                         base::loadNamespace(pkg)
[17:39:57.120]                         base::library(pkg, character.only = TRUE)
[17:39:57.120]                       }
[17:39:57.120]                     })
[17:39:57.120]                   }
[17:39:57.120]                   ...future.strategy.old <- future::plan("list")
[17:39:57.120]                   options(future.plan = NULL)
[17:39:57.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.120]                 }
[17:39:57.120]                 ...future.workdir <- getwd()
[17:39:57.120]             }
[17:39:57.120]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.120]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.120]         }
[17:39:57.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.120]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.120]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.120]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.120]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.120]             base::names(...future.oldOptions))
[17:39:57.120]     }
[17:39:57.120]     if (FALSE) {
[17:39:57.120]     }
[17:39:57.120]     else {
[17:39:57.120]         if (TRUE) {
[17:39:57.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.120]                 open = "w")
[17:39:57.120]         }
[17:39:57.120]         else {
[17:39:57.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.120]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.120]         }
[17:39:57.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.120]             base::sink(type = "output", split = FALSE)
[17:39:57.120]             base::close(...future.stdout)
[17:39:57.120]         }, add = TRUE)
[17:39:57.120]     }
[17:39:57.120]     ...future.frame <- base::sys.nframe()
[17:39:57.120]     ...future.conditions <- base::list()
[17:39:57.120]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.120]     if (FALSE) {
[17:39:57.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.120]     }
[17:39:57.120]     ...future.result <- base::tryCatch({
[17:39:57.120]         base::withCallingHandlers({
[17:39:57.120]             ...future.value <- base::withVisible(base::local({
[17:39:57.120]                 withCallingHandlers({
[17:39:57.120]                   value(a) + 1
[17:39:57.120]                 }, immediateCondition = function(cond) {
[17:39:57.120]                   save_rds <- function (object, pathname, ...) 
[17:39:57.120]                   {
[17:39:57.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.120]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.120]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.120]                         fi_tmp[["mtime"]])
[17:39:57.120]                     }
[17:39:57.120]                     tryCatch({
[17:39:57.120]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.120]                     }, error = function(ex) {
[17:39:57.120]                       msg <- conditionMessage(ex)
[17:39:57.120]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.120]                         fi_tmp[["mtime"]], msg)
[17:39:57.120]                       ex$message <- msg
[17:39:57.120]                       stop(ex)
[17:39:57.120]                     })
[17:39:57.120]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.120]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.120]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.120]                       fi <- file.info(pathname)
[17:39:57.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.120]                         fi[["size"]], fi[["mtime"]])
[17:39:57.120]                       stop(msg)
[17:39:57.120]                     }
[17:39:57.120]                     invisible(pathname)
[17:39:57.120]                   }
[17:39:57.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.120]                     rootPath = tempdir()) 
[17:39:57.120]                   {
[17:39:57.120]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.120]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.120]                       tmpdir = path, fileext = ".rds")
[17:39:57.120]                     save_rds(obj, file)
[17:39:57.120]                   }
[17:39:57.120]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.120]                   {
[17:39:57.120]                     inherits <- base::inherits
[17:39:57.120]                     invokeRestart <- base::invokeRestart
[17:39:57.120]                     is.null <- base::is.null
[17:39:57.120]                     muffled <- FALSE
[17:39:57.120]                     if (inherits(cond, "message")) {
[17:39:57.120]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.120]                       if (muffled) 
[17:39:57.120]                         invokeRestart("muffleMessage")
[17:39:57.120]                     }
[17:39:57.120]                     else if (inherits(cond, "warning")) {
[17:39:57.120]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.120]                       if (muffled) 
[17:39:57.120]                         invokeRestart("muffleWarning")
[17:39:57.120]                     }
[17:39:57.120]                     else if (inherits(cond, "condition")) {
[17:39:57.120]                       if (!is.null(pattern)) {
[17:39:57.120]                         computeRestarts <- base::computeRestarts
[17:39:57.120]                         grepl <- base::grepl
[17:39:57.120]                         restarts <- computeRestarts(cond)
[17:39:57.120]                         for (restart in restarts) {
[17:39:57.120]                           name <- restart$name
[17:39:57.120]                           if (is.null(name)) 
[17:39:57.120]                             next
[17:39:57.120]                           if (!grepl(pattern, name)) 
[17:39:57.120]                             next
[17:39:57.120]                           invokeRestart(restart)
[17:39:57.120]                           muffled <- TRUE
[17:39:57.120]                           break
[17:39:57.120]                         }
[17:39:57.120]                       }
[17:39:57.120]                     }
[17:39:57.120]                     invisible(muffled)
[17:39:57.120]                   }
[17:39:57.120]                   muffleCondition(cond)
[17:39:57.120]                 })
[17:39:57.120]             }))
[17:39:57.120]             future::FutureResult(value = ...future.value$value, 
[17:39:57.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.120]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.120]                     ...future.globalenv.names))
[17:39:57.120]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.120]         }, condition = base::local({
[17:39:57.120]             c <- base::c
[17:39:57.120]             inherits <- base::inherits
[17:39:57.120]             invokeRestart <- base::invokeRestart
[17:39:57.120]             length <- base::length
[17:39:57.120]             list <- base::list
[17:39:57.120]             seq.int <- base::seq.int
[17:39:57.120]             signalCondition <- base::signalCondition
[17:39:57.120]             sys.calls <- base::sys.calls
[17:39:57.120]             `[[` <- base::`[[`
[17:39:57.120]             `+` <- base::`+`
[17:39:57.120]             `<<-` <- base::`<<-`
[17:39:57.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.120]                   3L)]
[17:39:57.120]             }
[17:39:57.120]             function(cond) {
[17:39:57.120]                 is_error <- inherits(cond, "error")
[17:39:57.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.120]                   NULL)
[17:39:57.120]                 if (is_error) {
[17:39:57.120]                   sessionInformation <- function() {
[17:39:57.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.120]                       search = base::search(), system = base::Sys.info())
[17:39:57.120]                   }
[17:39:57.120]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.120]                     cond$call), session = sessionInformation(), 
[17:39:57.120]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.120]                   signalCondition(cond)
[17:39:57.120]                 }
[17:39:57.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.120]                 "immediateCondition"))) {
[17:39:57.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.120]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.120]                   if (TRUE && !signal) {
[17:39:57.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.120]                     {
[17:39:57.120]                       inherits <- base::inherits
[17:39:57.120]                       invokeRestart <- base::invokeRestart
[17:39:57.120]                       is.null <- base::is.null
[17:39:57.120]                       muffled <- FALSE
[17:39:57.120]                       if (inherits(cond, "message")) {
[17:39:57.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.120]                         if (muffled) 
[17:39:57.120]                           invokeRestart("muffleMessage")
[17:39:57.120]                       }
[17:39:57.120]                       else if (inherits(cond, "warning")) {
[17:39:57.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.120]                         if (muffled) 
[17:39:57.120]                           invokeRestart("muffleWarning")
[17:39:57.120]                       }
[17:39:57.120]                       else if (inherits(cond, "condition")) {
[17:39:57.120]                         if (!is.null(pattern)) {
[17:39:57.120]                           computeRestarts <- base::computeRestarts
[17:39:57.120]                           grepl <- base::grepl
[17:39:57.120]                           restarts <- computeRestarts(cond)
[17:39:57.120]                           for (restart in restarts) {
[17:39:57.120]                             name <- restart$name
[17:39:57.120]                             if (is.null(name)) 
[17:39:57.120]                               next
[17:39:57.120]                             if (!grepl(pattern, name)) 
[17:39:57.120]                               next
[17:39:57.120]                             invokeRestart(restart)
[17:39:57.120]                             muffled <- TRUE
[17:39:57.120]                             break
[17:39:57.120]                           }
[17:39:57.120]                         }
[17:39:57.120]                       }
[17:39:57.120]                       invisible(muffled)
[17:39:57.120]                     }
[17:39:57.120]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.120]                   }
[17:39:57.120]                 }
[17:39:57.120]                 else {
[17:39:57.120]                   if (TRUE) {
[17:39:57.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.120]                     {
[17:39:57.120]                       inherits <- base::inherits
[17:39:57.120]                       invokeRestart <- base::invokeRestart
[17:39:57.120]                       is.null <- base::is.null
[17:39:57.120]                       muffled <- FALSE
[17:39:57.120]                       if (inherits(cond, "message")) {
[17:39:57.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.120]                         if (muffled) 
[17:39:57.120]                           invokeRestart("muffleMessage")
[17:39:57.120]                       }
[17:39:57.120]                       else if (inherits(cond, "warning")) {
[17:39:57.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.120]                         if (muffled) 
[17:39:57.120]                           invokeRestart("muffleWarning")
[17:39:57.120]                       }
[17:39:57.120]                       else if (inherits(cond, "condition")) {
[17:39:57.120]                         if (!is.null(pattern)) {
[17:39:57.120]                           computeRestarts <- base::computeRestarts
[17:39:57.120]                           grepl <- base::grepl
[17:39:57.120]                           restarts <- computeRestarts(cond)
[17:39:57.120]                           for (restart in restarts) {
[17:39:57.120]                             name <- restart$name
[17:39:57.120]                             if (is.null(name)) 
[17:39:57.120]                               next
[17:39:57.120]                             if (!grepl(pattern, name)) 
[17:39:57.120]                               next
[17:39:57.120]                             invokeRestart(restart)
[17:39:57.120]                             muffled <- TRUE
[17:39:57.120]                             break
[17:39:57.120]                           }
[17:39:57.120]                         }
[17:39:57.120]                       }
[17:39:57.120]                       invisible(muffled)
[17:39:57.120]                     }
[17:39:57.120]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.120]                   }
[17:39:57.120]                 }
[17:39:57.120]             }
[17:39:57.120]         }))
[17:39:57.120]     }, error = function(ex) {
[17:39:57.120]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.120]                 ...future.rng), started = ...future.startTime, 
[17:39:57.120]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.120]             version = "1.8"), class = "FutureResult")
[17:39:57.120]     }, finally = {
[17:39:57.120]         if (!identical(...future.workdir, getwd())) 
[17:39:57.120]             setwd(...future.workdir)
[17:39:57.120]         {
[17:39:57.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.120]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.120]             }
[17:39:57.120]             base::options(...future.oldOptions)
[17:39:57.120]             if (.Platform$OS.type == "windows") {
[17:39:57.120]                 old_names <- names(...future.oldEnvVars)
[17:39:57.120]                 envs <- base::Sys.getenv()
[17:39:57.120]                 names <- names(envs)
[17:39:57.120]                 common <- intersect(names, old_names)
[17:39:57.120]                 added <- setdiff(names, old_names)
[17:39:57.120]                 removed <- setdiff(old_names, names)
[17:39:57.120]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.120]                   envs[common]]
[17:39:57.120]                 NAMES <- toupper(changed)
[17:39:57.120]                 args <- list()
[17:39:57.120]                 for (kk in seq_along(NAMES)) {
[17:39:57.120]                   name <- changed[[kk]]
[17:39:57.120]                   NAME <- NAMES[[kk]]
[17:39:57.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.120]                     next
[17:39:57.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.120]                 }
[17:39:57.120]                 NAMES <- toupper(added)
[17:39:57.120]                 for (kk in seq_along(NAMES)) {
[17:39:57.120]                   name <- added[[kk]]
[17:39:57.120]                   NAME <- NAMES[[kk]]
[17:39:57.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.120]                     next
[17:39:57.120]                   args[[name]] <- ""
[17:39:57.120]                 }
[17:39:57.120]                 NAMES <- toupper(removed)
[17:39:57.120]                 for (kk in seq_along(NAMES)) {
[17:39:57.120]                   name <- removed[[kk]]
[17:39:57.120]                   NAME <- NAMES[[kk]]
[17:39:57.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.120]                     next
[17:39:57.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.120]                 }
[17:39:57.120]                 if (length(args) > 0) 
[17:39:57.120]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.120]             }
[17:39:57.120]             else {
[17:39:57.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.120]             }
[17:39:57.120]             {
[17:39:57.120]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.120]                   0L) {
[17:39:57.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.120]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.120]                   base::options(opts)
[17:39:57.120]                 }
[17:39:57.120]                 {
[17:39:57.120]                   {
[17:39:57.120]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.120]                     NULL
[17:39:57.120]                   }
[17:39:57.120]                   options(future.plan = NULL)
[17:39:57.120]                   if (is.na(NA_character_)) 
[17:39:57.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.120]                     .init = FALSE)
[17:39:57.120]                 }
[17:39:57.120]             }
[17:39:57.120]         }
[17:39:57.120]     })
[17:39:57.120]     if (TRUE) {
[17:39:57.120]         base::sink(type = "output", split = FALSE)
[17:39:57.120]         if (TRUE) {
[17:39:57.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.120]         }
[17:39:57.120]         else {
[17:39:57.120]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.120]         }
[17:39:57.120]         base::close(...future.stdout)
[17:39:57.120]         ...future.stdout <- NULL
[17:39:57.120]     }
[17:39:57.120]     ...future.result$conditions <- ...future.conditions
[17:39:57.120]     ...future.result$finished <- base::Sys.time()
[17:39:57.120]     ...future.result
[17:39:57.120] }
[17:39:57.122] assign_globals() ...
[17:39:57.123] List of 1
[17:39:57.123]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd6109718> 
[17:39:57.123]  - attr(*, "where")=List of 1
[17:39:57.123]   ..$ a:<environment: R_EmptyEnv> 
[17:39:57.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.123]  - attr(*, "resolved")= logi TRUE
[17:39:57.123]  - attr(*, "total_size")= num 1647480
[17:39:57.123]  - attr(*, "already-done")= logi TRUE
[17:39:57.126] - copied ‘a’ to environment
[17:39:57.126] assign_globals() ... done
[17:39:57.126] requestCore(): workers = 2
[17:39:57.128] MulticoreFuture started
[17:39:57.128] - Launch lazy future ... done
[17:39:57.129] run() for ‘MulticoreFuture’ ... done
[17:39:57.129] result() for MulticoreFuture ...
[17:39:57.129] plan(): Setting new future strategy stack:
[17:39:57.130] List of future strategies:
[17:39:57.130] 1. sequential:
[17:39:57.130]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.130]    - tweaked: FALSE
[17:39:57.130]    - call: NULL
[17:39:57.131] plan(): nbrOfWorkers() = 1
[17:39:57.134] plan(): Setting new future strategy stack:
[17:39:57.135] List of future strategies:
[17:39:57.135] 1. multicore:
[17:39:57.135]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.135]    - tweaked: FALSE
[17:39:57.135]    - call: plan(strategy)
[17:39:57.140] plan(): nbrOfWorkers() = 2
[17:39:57.141] result() for MulticoreFuture ...
[17:39:57.141] result() for MulticoreFuture ... done
[17:39:57.141] signalConditions() ...
[17:39:57.141]  - include = ‘immediateCondition’
[17:39:57.141]  - exclude = 
[17:39:57.141]  - resignal = FALSE
[17:39:57.142]  - Number of conditions: 4
[17:39:57.142] signalConditions() ... done
[17:39:57.142] result() for MulticoreFuture ... done
[17:39:57.142] result() for MulticoreFuture ...
[17:39:57.142] result() for MulticoreFuture ... done
[17:39:57.142] signalConditions() ...
[17:39:57.142]  - include = ‘immediateCondition’
[17:39:57.143]  - exclude = 
[17:39:57.143]  - resignal = FALSE
[17:39:57.143]  - Number of conditions: 4
[17:39:57.143] signalConditions() ... done
[17:39:57.143] Future state: ‘finished’
[17:39:57.143] result() for MulticoreFuture ...
[17:39:57.143] result() for MulticoreFuture ... done
[17:39:57.143] signalConditions() ...
[17:39:57.144]  - include = ‘condition’
[17:39:57.144]  - exclude = ‘immediateCondition’
[17:39:57.144]  - resignal = TRUE
[17:39:57.144]  - Number of conditions: 4
[17:39:57.144]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.132] result() for MulticoreFuture ...
[17:39:57.144]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.133] result() for MulticoreFuture ... done
[17:39:57.144]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.133] result() for MulticoreFuture ...
[17:39:57.145]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.133] result() for MulticoreFuture ... done
[17:39:57.145] signalConditions() ... done
value(b) = 2
[17:39:57.145] result() for MulticoreFuture ...
[17:39:57.145] result() for MulticoreFuture ... done
[17:39:57.145] result() for MulticoreFuture ...
[17:39:57.145] result() for MulticoreFuture ... done
[17:39:57.145] signalConditions() ...
[17:39:57.146]  - include = ‘immediateCondition’
[17:39:57.146]  - exclude = 
[17:39:57.146]  - resignal = FALSE
[17:39:57.146]  - Number of conditions: 4
[17:39:57.146] signalConditions() ... done
[17:39:57.146] Future state: ‘finished’
[17:39:57.146] result() for MulticoreFuture ...
[17:39:57.146] result() for MulticoreFuture ... done
[17:39:57.146] signalConditions() ...
[17:39:57.146]  - include = ‘condition’
[17:39:57.147]  - exclude = ‘immediateCondition’
[17:39:57.147]  - resignal = TRUE
[17:39:57.147]  - Number of conditions: 4
[17:39:57.147]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.132] result() for MulticoreFuture ...
[17:39:57.147]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.133] result() for MulticoreFuture ... done
[17:39:57.147]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.133] result() for MulticoreFuture ...
[17:39:57.147]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.133] result() for MulticoreFuture ... done
[17:39:57.148] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.148] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.148] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.149] 
[17:39:57.149] Searching for globals ... DONE
[17:39:57.149] - globals: [0] <none>
[17:39:57.149] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.149] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.150] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.151] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:57.151] Searching for globals ... DONE
[17:39:57.151] Resolving globals: TRUE
[17:39:57.151] Resolving any globals that are futures ...
[17:39:57.151] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:57.151] Resolving any globals that are futures ... DONE
[17:39:57.152] Resolving futures part of globals (recursively) ...
[17:39:57.152] resolve() on list ...
[17:39:57.152]  recursive: 99
[17:39:57.152]  length: 1
[17:39:57.152]  elements: ‘a’
[17:39:57.152] run() for ‘Future’ ...
[17:39:57.153] - state: ‘created’
[17:39:57.153] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.157] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.157]   - Field: ‘label’
[17:39:57.158]   - Field: ‘local’
[17:39:57.158]   - Field: ‘owner’
[17:39:57.158]   - Field: ‘envir’
[17:39:57.158]   - Field: ‘workers’
[17:39:57.158]   - Field: ‘packages’
[17:39:57.158]   - Field: ‘gc’
[17:39:57.158]   - Field: ‘job’
[17:39:57.158]   - Field: ‘conditions’
[17:39:57.159]   - Field: ‘expr’
[17:39:57.159]   - Field: ‘uuid’
[17:39:57.159]   - Field: ‘seed’
[17:39:57.159]   - Field: ‘version’
[17:39:57.159]   - Field: ‘result’
[17:39:57.159]   - Field: ‘asynchronous’
[17:39:57.159]   - Field: ‘calls’
[17:39:57.159]   - Field: ‘globals’
[17:39:57.160]   - Field: ‘stdout’
[17:39:57.160]   - Field: ‘earlySignal’
[17:39:57.160]   - Field: ‘lazy’
[17:39:57.160]   - Field: ‘state’
[17:39:57.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.160] - Launch lazy future ...
[17:39:57.161] Packages needed by the future expression (n = 0): <none>
[17:39:57.161] Packages needed by future strategies (n = 0): <none>
[17:39:57.161] {
[17:39:57.161]     {
[17:39:57.161]         {
[17:39:57.161]             ...future.startTime <- base::Sys.time()
[17:39:57.161]             {
[17:39:57.161]                 {
[17:39:57.161]                   {
[17:39:57.161]                     {
[17:39:57.161]                       base::local({
[17:39:57.161]                         has_future <- base::requireNamespace("future", 
[17:39:57.161]                           quietly = TRUE)
[17:39:57.161]                         if (has_future) {
[17:39:57.161]                           ns <- base::getNamespace("future")
[17:39:57.161]                           version <- ns[[".package"]][["version"]]
[17:39:57.161]                           if (is.null(version)) 
[17:39:57.161]                             version <- utils::packageVersion("future")
[17:39:57.161]                         }
[17:39:57.161]                         else {
[17:39:57.161]                           version <- NULL
[17:39:57.161]                         }
[17:39:57.161]                         if (!has_future || version < "1.8.0") {
[17:39:57.161]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.161]                             "", base::R.version$version.string), 
[17:39:57.161]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.161]                               "release", "version")], collapse = " "), 
[17:39:57.161]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.161]                             info)
[17:39:57.161]                           info <- base::paste(info, collapse = "; ")
[17:39:57.161]                           if (!has_future) {
[17:39:57.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.161]                               info)
[17:39:57.161]                           }
[17:39:57.161]                           else {
[17:39:57.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.161]                               info, version)
[17:39:57.161]                           }
[17:39:57.161]                           base::stop(msg)
[17:39:57.161]                         }
[17:39:57.161]                       })
[17:39:57.161]                     }
[17:39:57.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.161]                     base::options(mc.cores = 1L)
[17:39:57.161]                   }
[17:39:57.161]                   ...future.strategy.old <- future::plan("list")
[17:39:57.161]                   options(future.plan = NULL)
[17:39:57.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.161]                 }
[17:39:57.161]                 ...future.workdir <- getwd()
[17:39:57.161]             }
[17:39:57.161]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.161]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.161]         }
[17:39:57.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.161]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.161]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.161]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.161]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.161]             base::names(...future.oldOptions))
[17:39:57.161]     }
[17:39:57.161]     if (FALSE) {
[17:39:57.161]     }
[17:39:57.161]     else {
[17:39:57.161]         if (TRUE) {
[17:39:57.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.161]                 open = "w")
[17:39:57.161]         }
[17:39:57.161]         else {
[17:39:57.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.161]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.161]         }
[17:39:57.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.161]             base::sink(type = "output", split = FALSE)
[17:39:57.161]             base::close(...future.stdout)
[17:39:57.161]         }, add = TRUE)
[17:39:57.161]     }
[17:39:57.161]     ...future.frame <- base::sys.nframe()
[17:39:57.161]     ...future.conditions <- base::list()
[17:39:57.161]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.161]     if (FALSE) {
[17:39:57.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.161]     }
[17:39:57.161]     ...future.result <- base::tryCatch({
[17:39:57.161]         base::withCallingHandlers({
[17:39:57.161]             ...future.value <- base::withVisible(base::local({
[17:39:57.161]                 withCallingHandlers({
[17:39:57.161]                   1
[17:39:57.161]                 }, immediateCondition = function(cond) {
[17:39:57.161]                   save_rds <- function (object, pathname, ...) 
[17:39:57.161]                   {
[17:39:57.161]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.161]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.161]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.161]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.161]                         fi_tmp[["mtime"]])
[17:39:57.161]                     }
[17:39:57.161]                     tryCatch({
[17:39:57.161]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.161]                     }, error = function(ex) {
[17:39:57.161]                       msg <- conditionMessage(ex)
[17:39:57.161]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.161]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.161]                         fi_tmp[["mtime"]], msg)
[17:39:57.161]                       ex$message <- msg
[17:39:57.161]                       stop(ex)
[17:39:57.161]                     })
[17:39:57.161]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.161]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.161]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.161]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.161]                       fi <- file.info(pathname)
[17:39:57.161]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.161]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.161]                         fi[["size"]], fi[["mtime"]])
[17:39:57.161]                       stop(msg)
[17:39:57.161]                     }
[17:39:57.161]                     invisible(pathname)
[17:39:57.161]                   }
[17:39:57.161]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.161]                     rootPath = tempdir()) 
[17:39:57.161]                   {
[17:39:57.161]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.161]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.161]                       tmpdir = path, fileext = ".rds")
[17:39:57.161]                     save_rds(obj, file)
[17:39:57.161]                   }
[17:39:57.161]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.161]                   {
[17:39:57.161]                     inherits <- base::inherits
[17:39:57.161]                     invokeRestart <- base::invokeRestart
[17:39:57.161]                     is.null <- base::is.null
[17:39:57.161]                     muffled <- FALSE
[17:39:57.161]                     if (inherits(cond, "message")) {
[17:39:57.161]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.161]                       if (muffled) 
[17:39:57.161]                         invokeRestart("muffleMessage")
[17:39:57.161]                     }
[17:39:57.161]                     else if (inherits(cond, "warning")) {
[17:39:57.161]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.161]                       if (muffled) 
[17:39:57.161]                         invokeRestart("muffleWarning")
[17:39:57.161]                     }
[17:39:57.161]                     else if (inherits(cond, "condition")) {
[17:39:57.161]                       if (!is.null(pattern)) {
[17:39:57.161]                         computeRestarts <- base::computeRestarts
[17:39:57.161]                         grepl <- base::grepl
[17:39:57.161]                         restarts <- computeRestarts(cond)
[17:39:57.161]                         for (restart in restarts) {
[17:39:57.161]                           name <- restart$name
[17:39:57.161]                           if (is.null(name)) 
[17:39:57.161]                             next
[17:39:57.161]                           if (!grepl(pattern, name)) 
[17:39:57.161]                             next
[17:39:57.161]                           invokeRestart(restart)
[17:39:57.161]                           muffled <- TRUE
[17:39:57.161]                           break
[17:39:57.161]                         }
[17:39:57.161]                       }
[17:39:57.161]                     }
[17:39:57.161]                     invisible(muffled)
[17:39:57.161]                   }
[17:39:57.161]                   muffleCondition(cond)
[17:39:57.161]                 })
[17:39:57.161]             }))
[17:39:57.161]             future::FutureResult(value = ...future.value$value, 
[17:39:57.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.161]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.161]                     ...future.globalenv.names))
[17:39:57.161]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.161]         }, condition = base::local({
[17:39:57.161]             c <- base::c
[17:39:57.161]             inherits <- base::inherits
[17:39:57.161]             invokeRestart <- base::invokeRestart
[17:39:57.161]             length <- base::length
[17:39:57.161]             list <- base::list
[17:39:57.161]             seq.int <- base::seq.int
[17:39:57.161]             signalCondition <- base::signalCondition
[17:39:57.161]             sys.calls <- base::sys.calls
[17:39:57.161]             `[[` <- base::`[[`
[17:39:57.161]             `+` <- base::`+`
[17:39:57.161]             `<<-` <- base::`<<-`
[17:39:57.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.161]                   3L)]
[17:39:57.161]             }
[17:39:57.161]             function(cond) {
[17:39:57.161]                 is_error <- inherits(cond, "error")
[17:39:57.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.161]                   NULL)
[17:39:57.161]                 if (is_error) {
[17:39:57.161]                   sessionInformation <- function() {
[17:39:57.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.161]                       search = base::search(), system = base::Sys.info())
[17:39:57.161]                   }
[17:39:57.161]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.161]                     cond$call), session = sessionInformation(), 
[17:39:57.161]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.161]                   signalCondition(cond)
[17:39:57.161]                 }
[17:39:57.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.161]                 "immediateCondition"))) {
[17:39:57.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.161]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.161]                   if (TRUE && !signal) {
[17:39:57.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.161]                     {
[17:39:57.161]                       inherits <- base::inherits
[17:39:57.161]                       invokeRestart <- base::invokeRestart
[17:39:57.161]                       is.null <- base::is.null
[17:39:57.161]                       muffled <- FALSE
[17:39:57.161]                       if (inherits(cond, "message")) {
[17:39:57.161]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.161]                         if (muffled) 
[17:39:57.161]                           invokeRestart("muffleMessage")
[17:39:57.161]                       }
[17:39:57.161]                       else if (inherits(cond, "warning")) {
[17:39:57.161]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.161]                         if (muffled) 
[17:39:57.161]                           invokeRestart("muffleWarning")
[17:39:57.161]                       }
[17:39:57.161]                       else if (inherits(cond, "condition")) {
[17:39:57.161]                         if (!is.null(pattern)) {
[17:39:57.161]                           computeRestarts <- base::computeRestarts
[17:39:57.161]                           grepl <- base::grepl
[17:39:57.161]                           restarts <- computeRestarts(cond)
[17:39:57.161]                           for (restart in restarts) {
[17:39:57.161]                             name <- restart$name
[17:39:57.161]                             if (is.null(name)) 
[17:39:57.161]                               next
[17:39:57.161]                             if (!grepl(pattern, name)) 
[17:39:57.161]                               next
[17:39:57.161]                             invokeRestart(restart)
[17:39:57.161]                             muffled <- TRUE
[17:39:57.161]                             break
[17:39:57.161]                           }
[17:39:57.161]                         }
[17:39:57.161]                       }
[17:39:57.161]                       invisible(muffled)
[17:39:57.161]                     }
[17:39:57.161]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.161]                   }
[17:39:57.161]                 }
[17:39:57.161]                 else {
[17:39:57.161]                   if (TRUE) {
[17:39:57.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.161]                     {
[17:39:57.161]                       inherits <- base::inherits
[17:39:57.161]                       invokeRestart <- base::invokeRestart
[17:39:57.161]                       is.null <- base::is.null
[17:39:57.161]                       muffled <- FALSE
[17:39:57.161]                       if (inherits(cond, "message")) {
[17:39:57.161]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.161]                         if (muffled) 
[17:39:57.161]                           invokeRestart("muffleMessage")
[17:39:57.161]                       }
[17:39:57.161]                       else if (inherits(cond, "warning")) {
[17:39:57.161]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.161]                         if (muffled) 
[17:39:57.161]                           invokeRestart("muffleWarning")
[17:39:57.161]                       }
[17:39:57.161]                       else if (inherits(cond, "condition")) {
[17:39:57.161]                         if (!is.null(pattern)) {
[17:39:57.161]                           computeRestarts <- base::computeRestarts
[17:39:57.161]                           grepl <- base::grepl
[17:39:57.161]                           restarts <- computeRestarts(cond)
[17:39:57.161]                           for (restart in restarts) {
[17:39:57.161]                             name <- restart$name
[17:39:57.161]                             if (is.null(name)) 
[17:39:57.161]                               next
[17:39:57.161]                             if (!grepl(pattern, name)) 
[17:39:57.161]                               next
[17:39:57.161]                             invokeRestart(restart)
[17:39:57.161]                             muffled <- TRUE
[17:39:57.161]                             break
[17:39:57.161]                           }
[17:39:57.161]                         }
[17:39:57.161]                       }
[17:39:57.161]                       invisible(muffled)
[17:39:57.161]                     }
[17:39:57.161]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.161]                   }
[17:39:57.161]                 }
[17:39:57.161]             }
[17:39:57.161]         }))
[17:39:57.161]     }, error = function(ex) {
[17:39:57.161]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.161]                 ...future.rng), started = ...future.startTime, 
[17:39:57.161]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.161]             version = "1.8"), class = "FutureResult")
[17:39:57.161]     }, finally = {
[17:39:57.161]         if (!identical(...future.workdir, getwd())) 
[17:39:57.161]             setwd(...future.workdir)
[17:39:57.161]         {
[17:39:57.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.161]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.161]             }
[17:39:57.161]             base::options(...future.oldOptions)
[17:39:57.161]             if (.Platform$OS.type == "windows") {
[17:39:57.161]                 old_names <- names(...future.oldEnvVars)
[17:39:57.161]                 envs <- base::Sys.getenv()
[17:39:57.161]                 names <- names(envs)
[17:39:57.161]                 common <- intersect(names, old_names)
[17:39:57.161]                 added <- setdiff(names, old_names)
[17:39:57.161]                 removed <- setdiff(old_names, names)
[17:39:57.161]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.161]                   envs[common]]
[17:39:57.161]                 NAMES <- toupper(changed)
[17:39:57.161]                 args <- list()
[17:39:57.161]                 for (kk in seq_along(NAMES)) {
[17:39:57.161]                   name <- changed[[kk]]
[17:39:57.161]                   NAME <- NAMES[[kk]]
[17:39:57.161]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.161]                     next
[17:39:57.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.161]                 }
[17:39:57.161]                 NAMES <- toupper(added)
[17:39:57.161]                 for (kk in seq_along(NAMES)) {
[17:39:57.161]                   name <- added[[kk]]
[17:39:57.161]                   NAME <- NAMES[[kk]]
[17:39:57.161]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.161]                     next
[17:39:57.161]                   args[[name]] <- ""
[17:39:57.161]                 }
[17:39:57.161]                 NAMES <- toupper(removed)
[17:39:57.161]                 for (kk in seq_along(NAMES)) {
[17:39:57.161]                   name <- removed[[kk]]
[17:39:57.161]                   NAME <- NAMES[[kk]]
[17:39:57.161]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.161]                     next
[17:39:57.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.161]                 }
[17:39:57.161]                 if (length(args) > 0) 
[17:39:57.161]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.161]             }
[17:39:57.161]             else {
[17:39:57.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.161]             }
[17:39:57.161]             {
[17:39:57.161]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.161]                   0L) {
[17:39:57.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.161]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.161]                   base::options(opts)
[17:39:57.161]                 }
[17:39:57.161]                 {
[17:39:57.161]                   {
[17:39:57.161]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.161]                     NULL
[17:39:57.161]                   }
[17:39:57.161]                   options(future.plan = NULL)
[17:39:57.161]                   if (is.na(NA_character_)) 
[17:39:57.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.161]                     .init = FALSE)
[17:39:57.161]                 }
[17:39:57.161]             }
[17:39:57.161]         }
[17:39:57.161]     })
[17:39:57.161]     if (TRUE) {
[17:39:57.161]         base::sink(type = "output", split = FALSE)
[17:39:57.161]         if (TRUE) {
[17:39:57.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.161]         }
[17:39:57.161]         else {
[17:39:57.161]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.161]         }
[17:39:57.161]         base::close(...future.stdout)
[17:39:57.161]         ...future.stdout <- NULL
[17:39:57.161]     }
[17:39:57.161]     ...future.result$conditions <- ...future.conditions
[17:39:57.161]     ...future.result$finished <- base::Sys.time()
[17:39:57.161]     ...future.result
[17:39:57.161] }
[17:39:57.164] requestCore(): workers = 2
[17:39:57.166] MulticoreFuture started
[17:39:57.166] - Launch lazy future ... done
[17:39:57.166] run() for ‘MulticoreFuture’ ... done
[17:39:57.167] plan(): Setting new future strategy stack:
[17:39:57.167] List of future strategies:
[17:39:57.167] 1. sequential:
[17:39:57.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.167]    - tweaked: FALSE
[17:39:57.167]    - call: NULL
[17:39:57.174] plan(): nbrOfWorkers() = 1
[17:39:57.176] plan(): Setting new future strategy stack:
[17:39:57.176] List of future strategies:
[17:39:57.176] 1. multicore:
[17:39:57.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.176]    - tweaked: FALSE
[17:39:57.176]    - call: plan(strategy)
[17:39:57.181] plan(): nbrOfWorkers() = 2
[17:39:57.190] Future #1
[17:39:57.191] result() for MulticoreFuture ...
[17:39:57.192] result() for MulticoreFuture ...
[17:39:57.192] result() for MulticoreFuture ... done
[17:39:57.192] result() for MulticoreFuture ... done
[17:39:57.192] result() for MulticoreFuture ...
[17:39:57.192] result() for MulticoreFuture ... done
[17:39:57.193] A MulticoreFuture was resolved
[17:39:57.193]  length: 0 (resolved future 1)
[17:39:57.193] resolve() on list ... DONE
[17:39:57.193] - globals: [1] ‘a’
[17:39:57.194] Resolving futures part of globals (recursively) ... DONE
[17:39:57.197] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[17:39:57.198] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:57.198] - globals: [1] ‘a’
[17:39:57.198] - packages: [1] ‘future’
[17:39:57.199] getGlobalsAndPackages() ... DONE
[17:39:57.199] run() for ‘Future’ ...
[17:39:57.199] - state: ‘created’
[17:39:57.199] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.204] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.204]   - Field: ‘label’
[17:39:57.204]   - Field: ‘local’
[17:39:57.204]   - Field: ‘owner’
[17:39:57.204]   - Field: ‘envir’
[17:39:57.204]   - Field: ‘workers’
[17:39:57.204]   - Field: ‘packages’
[17:39:57.205]   - Field: ‘gc’
[17:39:57.205]   - Field: ‘job’
[17:39:57.205]   - Field: ‘conditions’
[17:39:57.205]   - Field: ‘expr’
[17:39:57.205]   - Field: ‘uuid’
[17:39:57.205]   - Field: ‘seed’
[17:39:57.205]   - Field: ‘version’
[17:39:57.205]   - Field: ‘result’
[17:39:57.205]   - Field: ‘asynchronous’
[17:39:57.206]   - Field: ‘calls’
[17:39:57.206]   - Field: ‘globals’
[17:39:57.206]   - Field: ‘stdout’
[17:39:57.206]   - Field: ‘earlySignal’
[17:39:57.206]   - Field: ‘lazy’
[17:39:57.206]   - Field: ‘state’
[17:39:57.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.206] - Launch lazy future ...
[17:39:57.207] Packages needed by the future expression (n = 1): ‘future’
[17:39:57.207] Packages needed by future strategies (n = 0): <none>
[17:39:57.207] {
[17:39:57.207]     {
[17:39:57.207]         {
[17:39:57.207]             ...future.startTime <- base::Sys.time()
[17:39:57.207]             {
[17:39:57.207]                 {
[17:39:57.207]                   {
[17:39:57.207]                     {
[17:39:57.207]                       {
[17:39:57.207]                         base::local({
[17:39:57.207]                           has_future <- base::requireNamespace("future", 
[17:39:57.207]                             quietly = TRUE)
[17:39:57.207]                           if (has_future) {
[17:39:57.207]                             ns <- base::getNamespace("future")
[17:39:57.207]                             version <- ns[[".package"]][["version"]]
[17:39:57.207]                             if (is.null(version)) 
[17:39:57.207]                               version <- utils::packageVersion("future")
[17:39:57.207]                           }
[17:39:57.207]                           else {
[17:39:57.207]                             version <- NULL
[17:39:57.207]                           }
[17:39:57.207]                           if (!has_future || version < "1.8.0") {
[17:39:57.207]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.207]                               "", base::R.version$version.string), 
[17:39:57.207]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:57.207]                                 base::R.version$platform, 8 * 
[17:39:57.207]                                   base::.Machine$sizeof.pointer), 
[17:39:57.207]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.207]                                 "release", "version")], collapse = " "), 
[17:39:57.207]                               hostname = base::Sys.info()[["nodename"]])
[17:39:57.207]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.207]                               info)
[17:39:57.207]                             info <- base::paste(info, collapse = "; ")
[17:39:57.207]                             if (!has_future) {
[17:39:57.207]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.207]                                 info)
[17:39:57.207]                             }
[17:39:57.207]                             else {
[17:39:57.207]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.207]                                 info, version)
[17:39:57.207]                             }
[17:39:57.207]                             base::stop(msg)
[17:39:57.207]                           }
[17:39:57.207]                         })
[17:39:57.207]                       }
[17:39:57.207]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.207]                       base::options(mc.cores = 1L)
[17:39:57.207]                     }
[17:39:57.207]                     base::local({
[17:39:57.207]                       for (pkg in "future") {
[17:39:57.207]                         base::loadNamespace(pkg)
[17:39:57.207]                         base::library(pkg, character.only = TRUE)
[17:39:57.207]                       }
[17:39:57.207]                     })
[17:39:57.207]                   }
[17:39:57.207]                   ...future.strategy.old <- future::plan("list")
[17:39:57.207]                   options(future.plan = NULL)
[17:39:57.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.207]                 }
[17:39:57.207]                 ...future.workdir <- getwd()
[17:39:57.207]             }
[17:39:57.207]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.207]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.207]         }
[17:39:57.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.207]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.207]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.207]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.207]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.207]             base::names(...future.oldOptions))
[17:39:57.207]     }
[17:39:57.207]     if (FALSE) {
[17:39:57.207]     }
[17:39:57.207]     else {
[17:39:57.207]         if (TRUE) {
[17:39:57.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.207]                 open = "w")
[17:39:57.207]         }
[17:39:57.207]         else {
[17:39:57.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.207]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.207]         }
[17:39:57.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.207]             base::sink(type = "output", split = FALSE)
[17:39:57.207]             base::close(...future.stdout)
[17:39:57.207]         }, add = TRUE)
[17:39:57.207]     }
[17:39:57.207]     ...future.frame <- base::sys.nframe()
[17:39:57.207]     ...future.conditions <- base::list()
[17:39:57.207]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.207]     if (FALSE) {
[17:39:57.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.207]     }
[17:39:57.207]     ...future.result <- base::tryCatch({
[17:39:57.207]         base::withCallingHandlers({
[17:39:57.207]             ...future.value <- base::withVisible(base::local({
[17:39:57.207]                 withCallingHandlers({
[17:39:57.207]                   value(a) + 1
[17:39:57.207]                 }, immediateCondition = function(cond) {
[17:39:57.207]                   save_rds <- function (object, pathname, ...) 
[17:39:57.207]                   {
[17:39:57.207]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.207]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.207]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.207]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.207]                         fi_tmp[["mtime"]])
[17:39:57.207]                     }
[17:39:57.207]                     tryCatch({
[17:39:57.207]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.207]                     }, error = function(ex) {
[17:39:57.207]                       msg <- conditionMessage(ex)
[17:39:57.207]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.207]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.207]                         fi_tmp[["mtime"]], msg)
[17:39:57.207]                       ex$message <- msg
[17:39:57.207]                       stop(ex)
[17:39:57.207]                     })
[17:39:57.207]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.207]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.207]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.207]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.207]                       fi <- file.info(pathname)
[17:39:57.207]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.207]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.207]                         fi[["size"]], fi[["mtime"]])
[17:39:57.207]                       stop(msg)
[17:39:57.207]                     }
[17:39:57.207]                     invisible(pathname)
[17:39:57.207]                   }
[17:39:57.207]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.207]                     rootPath = tempdir()) 
[17:39:57.207]                   {
[17:39:57.207]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.207]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.207]                       tmpdir = path, fileext = ".rds")
[17:39:57.207]                     save_rds(obj, file)
[17:39:57.207]                   }
[17:39:57.207]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.207]                   {
[17:39:57.207]                     inherits <- base::inherits
[17:39:57.207]                     invokeRestart <- base::invokeRestart
[17:39:57.207]                     is.null <- base::is.null
[17:39:57.207]                     muffled <- FALSE
[17:39:57.207]                     if (inherits(cond, "message")) {
[17:39:57.207]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.207]                       if (muffled) 
[17:39:57.207]                         invokeRestart("muffleMessage")
[17:39:57.207]                     }
[17:39:57.207]                     else if (inherits(cond, "warning")) {
[17:39:57.207]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.207]                       if (muffled) 
[17:39:57.207]                         invokeRestart("muffleWarning")
[17:39:57.207]                     }
[17:39:57.207]                     else if (inherits(cond, "condition")) {
[17:39:57.207]                       if (!is.null(pattern)) {
[17:39:57.207]                         computeRestarts <- base::computeRestarts
[17:39:57.207]                         grepl <- base::grepl
[17:39:57.207]                         restarts <- computeRestarts(cond)
[17:39:57.207]                         for (restart in restarts) {
[17:39:57.207]                           name <- restart$name
[17:39:57.207]                           if (is.null(name)) 
[17:39:57.207]                             next
[17:39:57.207]                           if (!grepl(pattern, name)) 
[17:39:57.207]                             next
[17:39:57.207]                           invokeRestart(restart)
[17:39:57.207]                           muffled <- TRUE
[17:39:57.207]                           break
[17:39:57.207]                         }
[17:39:57.207]                       }
[17:39:57.207]                     }
[17:39:57.207]                     invisible(muffled)
[17:39:57.207]                   }
[17:39:57.207]                   muffleCondition(cond)
[17:39:57.207]                 })
[17:39:57.207]             }))
[17:39:57.207]             future::FutureResult(value = ...future.value$value, 
[17:39:57.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.207]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.207]                     ...future.globalenv.names))
[17:39:57.207]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.207]         }, condition = base::local({
[17:39:57.207]             c <- base::c
[17:39:57.207]             inherits <- base::inherits
[17:39:57.207]             invokeRestart <- base::invokeRestart
[17:39:57.207]             length <- base::length
[17:39:57.207]             list <- base::list
[17:39:57.207]             seq.int <- base::seq.int
[17:39:57.207]             signalCondition <- base::signalCondition
[17:39:57.207]             sys.calls <- base::sys.calls
[17:39:57.207]             `[[` <- base::`[[`
[17:39:57.207]             `+` <- base::`+`
[17:39:57.207]             `<<-` <- base::`<<-`
[17:39:57.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.207]                   3L)]
[17:39:57.207]             }
[17:39:57.207]             function(cond) {
[17:39:57.207]                 is_error <- inherits(cond, "error")
[17:39:57.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.207]                   NULL)
[17:39:57.207]                 if (is_error) {
[17:39:57.207]                   sessionInformation <- function() {
[17:39:57.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.207]                       search = base::search(), system = base::Sys.info())
[17:39:57.207]                   }
[17:39:57.207]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.207]                     cond$call), session = sessionInformation(), 
[17:39:57.207]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.207]                   signalCondition(cond)
[17:39:57.207]                 }
[17:39:57.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.207]                 "immediateCondition"))) {
[17:39:57.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.207]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.207]                   if (TRUE && !signal) {
[17:39:57.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.207]                     {
[17:39:57.207]                       inherits <- base::inherits
[17:39:57.207]                       invokeRestart <- base::invokeRestart
[17:39:57.207]                       is.null <- base::is.null
[17:39:57.207]                       muffled <- FALSE
[17:39:57.207]                       if (inherits(cond, "message")) {
[17:39:57.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.207]                         if (muffled) 
[17:39:57.207]                           invokeRestart("muffleMessage")
[17:39:57.207]                       }
[17:39:57.207]                       else if (inherits(cond, "warning")) {
[17:39:57.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.207]                         if (muffled) 
[17:39:57.207]                           invokeRestart("muffleWarning")
[17:39:57.207]                       }
[17:39:57.207]                       else if (inherits(cond, "condition")) {
[17:39:57.207]                         if (!is.null(pattern)) {
[17:39:57.207]                           computeRestarts <- base::computeRestarts
[17:39:57.207]                           grepl <- base::grepl
[17:39:57.207]                           restarts <- computeRestarts(cond)
[17:39:57.207]                           for (restart in restarts) {
[17:39:57.207]                             name <- restart$name
[17:39:57.207]                             if (is.null(name)) 
[17:39:57.207]                               next
[17:39:57.207]                             if (!grepl(pattern, name)) 
[17:39:57.207]                               next
[17:39:57.207]                             invokeRestart(restart)
[17:39:57.207]                             muffled <- TRUE
[17:39:57.207]                             break
[17:39:57.207]                           }
[17:39:57.207]                         }
[17:39:57.207]                       }
[17:39:57.207]                       invisible(muffled)
[17:39:57.207]                     }
[17:39:57.207]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.207]                   }
[17:39:57.207]                 }
[17:39:57.207]                 else {
[17:39:57.207]                   if (TRUE) {
[17:39:57.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.207]                     {
[17:39:57.207]                       inherits <- base::inherits
[17:39:57.207]                       invokeRestart <- base::invokeRestart
[17:39:57.207]                       is.null <- base::is.null
[17:39:57.207]                       muffled <- FALSE
[17:39:57.207]                       if (inherits(cond, "message")) {
[17:39:57.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.207]                         if (muffled) 
[17:39:57.207]                           invokeRestart("muffleMessage")
[17:39:57.207]                       }
[17:39:57.207]                       else if (inherits(cond, "warning")) {
[17:39:57.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.207]                         if (muffled) 
[17:39:57.207]                           invokeRestart("muffleWarning")
[17:39:57.207]                       }
[17:39:57.207]                       else if (inherits(cond, "condition")) {
[17:39:57.207]                         if (!is.null(pattern)) {
[17:39:57.207]                           computeRestarts <- base::computeRestarts
[17:39:57.207]                           grepl <- base::grepl
[17:39:57.207]                           restarts <- computeRestarts(cond)
[17:39:57.207]                           for (restart in restarts) {
[17:39:57.207]                             name <- restart$name
[17:39:57.207]                             if (is.null(name)) 
[17:39:57.207]                               next
[17:39:57.207]                             if (!grepl(pattern, name)) 
[17:39:57.207]                               next
[17:39:57.207]                             invokeRestart(restart)
[17:39:57.207]                             muffled <- TRUE
[17:39:57.207]                             break
[17:39:57.207]                           }
[17:39:57.207]                         }
[17:39:57.207]                       }
[17:39:57.207]                       invisible(muffled)
[17:39:57.207]                     }
[17:39:57.207]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.207]                   }
[17:39:57.207]                 }
[17:39:57.207]             }
[17:39:57.207]         }))
[17:39:57.207]     }, error = function(ex) {
[17:39:57.207]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.207]                 ...future.rng), started = ...future.startTime, 
[17:39:57.207]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.207]             version = "1.8"), class = "FutureResult")
[17:39:57.207]     }, finally = {
[17:39:57.207]         if (!identical(...future.workdir, getwd())) 
[17:39:57.207]             setwd(...future.workdir)
[17:39:57.207]         {
[17:39:57.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.207]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.207]             }
[17:39:57.207]             base::options(...future.oldOptions)
[17:39:57.207]             if (.Platform$OS.type == "windows") {
[17:39:57.207]                 old_names <- names(...future.oldEnvVars)
[17:39:57.207]                 envs <- base::Sys.getenv()
[17:39:57.207]                 names <- names(envs)
[17:39:57.207]                 common <- intersect(names, old_names)
[17:39:57.207]                 added <- setdiff(names, old_names)
[17:39:57.207]                 removed <- setdiff(old_names, names)
[17:39:57.207]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.207]                   envs[common]]
[17:39:57.207]                 NAMES <- toupper(changed)
[17:39:57.207]                 args <- list()
[17:39:57.207]                 for (kk in seq_along(NAMES)) {
[17:39:57.207]                   name <- changed[[kk]]
[17:39:57.207]                   NAME <- NAMES[[kk]]
[17:39:57.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.207]                     next
[17:39:57.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.207]                 }
[17:39:57.207]                 NAMES <- toupper(added)
[17:39:57.207]                 for (kk in seq_along(NAMES)) {
[17:39:57.207]                   name <- added[[kk]]
[17:39:57.207]                   NAME <- NAMES[[kk]]
[17:39:57.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.207]                     next
[17:39:57.207]                   args[[name]] <- ""
[17:39:57.207]                 }
[17:39:57.207]                 NAMES <- toupper(removed)
[17:39:57.207]                 for (kk in seq_along(NAMES)) {
[17:39:57.207]                   name <- removed[[kk]]
[17:39:57.207]                   NAME <- NAMES[[kk]]
[17:39:57.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.207]                     next
[17:39:57.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.207]                 }
[17:39:57.207]                 if (length(args) > 0) 
[17:39:57.207]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.207]             }
[17:39:57.207]             else {
[17:39:57.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.207]             }
[17:39:57.207]             {
[17:39:57.207]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.207]                   0L) {
[17:39:57.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.207]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.207]                   base::options(opts)
[17:39:57.207]                 }
[17:39:57.207]                 {
[17:39:57.207]                   {
[17:39:57.207]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.207]                     NULL
[17:39:57.207]                   }
[17:39:57.207]                   options(future.plan = NULL)
[17:39:57.207]                   if (is.na(NA_character_)) 
[17:39:57.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.207]                     .init = FALSE)
[17:39:57.207]                 }
[17:39:57.207]             }
[17:39:57.207]         }
[17:39:57.207]     })
[17:39:57.207]     if (TRUE) {
[17:39:57.207]         base::sink(type = "output", split = FALSE)
[17:39:57.207]         if (TRUE) {
[17:39:57.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.207]         }
[17:39:57.207]         else {
[17:39:57.207]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.207]         }
[17:39:57.207]         base::close(...future.stdout)
[17:39:57.207]         ...future.stdout <- NULL
[17:39:57.207]     }
[17:39:57.207]     ...future.result$conditions <- ...future.conditions
[17:39:57.207]     ...future.result$finished <- base::Sys.time()
[17:39:57.207]     ...future.result
[17:39:57.207] }
[17:39:57.210] assign_globals() ...
[17:39:57.210] List of 1
[17:39:57.210]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd7df4d20> 
[17:39:57.210]  - attr(*, "where")=List of 1
[17:39:57.210]   ..$ a:<environment: R_EmptyEnv> 
[17:39:57.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.210]  - attr(*, "resolved")= logi TRUE
[17:39:57.210]  - attr(*, "total_size")= num 1647648
[17:39:57.210]  - attr(*, "already-done")= logi TRUE
[17:39:57.213] - copied ‘a’ to environment
[17:39:57.213] assign_globals() ... done
[17:39:57.213] requestCore(): workers = 2
[17:39:57.214] MulticoreFuture started
[17:39:57.215] - Launch lazy future ... done
[17:39:57.215] run() for ‘MulticoreFuture’ ... done
[17:39:57.215] result() for MulticoreFuture ...
[17:39:57.216] plan(): Setting new future strategy stack:
[17:39:57.216] List of future strategies:
[17:39:57.216] 1. sequential:
[17:39:57.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.216]    - tweaked: FALSE
[17:39:57.216]    - call: NULL
[17:39:57.217] plan(): nbrOfWorkers() = 1
[17:39:57.221] plan(): Setting new future strategy stack:
[17:39:57.221] List of future strategies:
[17:39:57.221] 1. multicore:
[17:39:57.221]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.221]    - tweaked: FALSE
[17:39:57.221]    - call: plan(strategy)
[17:39:57.226] plan(): nbrOfWorkers() = 2
[17:39:57.227] result() for MulticoreFuture ...
[17:39:57.227] result() for MulticoreFuture ... done
[17:39:57.227] signalConditions() ...
[17:39:57.227]  - include = ‘immediateCondition’
[17:39:57.227]  - exclude = 
[17:39:57.228]  - resignal = FALSE
[17:39:57.228]  - Number of conditions: 4
[17:39:57.228] signalConditions() ... done
[17:39:57.228] result() for MulticoreFuture ... done
[17:39:57.228] result() for MulticoreFuture ...
[17:39:57.228] result() for MulticoreFuture ... done
[17:39:57.228] signalConditions() ...
[17:39:57.228]  - include = ‘immediateCondition’
[17:39:57.229]  - exclude = 
[17:39:57.229]  - resignal = FALSE
[17:39:57.229]  - Number of conditions: 4
[17:39:57.229] signalConditions() ... done
[17:39:57.229] Future state: ‘finished’
[17:39:57.229] result() for MulticoreFuture ...
[17:39:57.229] result() for MulticoreFuture ... done
[17:39:57.229] signalConditions() ...
[17:39:57.230]  - include = ‘condition’
[17:39:57.230]  - exclude = ‘immediateCondition’
[17:39:57.230]  - resignal = TRUE
[17:39:57.230]  - Number of conditions: 4
[17:39:57.230]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ...
[17:39:57.230]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ... done
[17:39:57.230]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ...
[17:39:57.230]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ... done
[17:39:57.231] signalConditions() ... done
value(b) = 2
[17:39:57.231] result() for MulticoreFuture ...
[17:39:57.231] result() for MulticoreFuture ... done
[17:39:57.231] result() for MulticoreFuture ...
[17:39:57.231] result() for MulticoreFuture ... done
[17:39:57.231] signalConditions() ...
[17:39:57.231]  - include = ‘immediateCondition’
[17:39:57.231]  - exclude = 
[17:39:57.232]  - resignal = FALSE
[17:39:57.232]  - Number of conditions: 4
[17:39:57.232] signalConditions() ... done
[17:39:57.232] Future state: ‘finished’
[17:39:57.232] result() for MulticoreFuture ...
[17:39:57.232] result() for MulticoreFuture ... done
[17:39:57.232] signalConditions() ...
[17:39:57.232]  - include = ‘condition’
[17:39:57.233]  - exclude = ‘immediateCondition’
[17:39:57.233]  - resignal = TRUE
[17:39:57.233]  - Number of conditions: 4
[17:39:57.233]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ...
[17:39:57.233]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ... done
[17:39:57.233]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ...
[17:39:57.233]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.219] result() for MulticoreFuture ... done
[17:39:57.234] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.234] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.234] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.235] 
[17:39:57.235] Searching for globals ... DONE
[17:39:57.235] - globals: [0] <none>
[17:39:57.235] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.236] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.236] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.237] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:57.237] Searching for globals ... DONE
[17:39:57.237] Resolving globals: TRUE
[17:39:57.237] Resolving any globals that are futures ...
[17:39:57.237] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:57.237] Resolving any globals that are futures ... DONE
[17:39:57.238] Resolving futures part of globals (recursively) ...
[17:39:57.238] resolve() on list ...
[17:39:57.238]  recursive: 99
[17:39:57.238]  length: 1
[17:39:57.241]  elements: ‘a’
[17:39:57.241] run() for ‘Future’ ...
[17:39:57.241] - state: ‘created’
[17:39:57.241] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.246] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.246]   - Field: ‘label’
[17:39:57.246]   - Field: ‘local’
[17:39:57.246]   - Field: ‘owner’
[17:39:57.246]   - Field: ‘envir’
[17:39:57.246]   - Field: ‘workers’
[17:39:57.247]   - Field: ‘packages’
[17:39:57.247]   - Field: ‘gc’
[17:39:57.247]   - Field: ‘job’
[17:39:57.247]   - Field: ‘conditions’
[17:39:57.247]   - Field: ‘expr’
[17:39:57.247]   - Field: ‘uuid’
[17:39:57.247]   - Field: ‘seed’
[17:39:57.247]   - Field: ‘version’
[17:39:57.247]   - Field: ‘result’
[17:39:57.248]   - Field: ‘asynchronous’
[17:39:57.248]   - Field: ‘calls’
[17:39:57.248]   - Field: ‘globals’
[17:39:57.248]   - Field: ‘stdout’
[17:39:57.248]   - Field: ‘earlySignal’
[17:39:57.248]   - Field: ‘lazy’
[17:39:57.248]   - Field: ‘state’
[17:39:57.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.249] - Launch lazy future ...
[17:39:57.249] Packages needed by the future expression (n = 0): <none>
[17:39:57.249] Packages needed by future strategies (n = 0): <none>
[17:39:57.250] {
[17:39:57.250]     {
[17:39:57.250]         {
[17:39:57.250]             ...future.startTime <- base::Sys.time()
[17:39:57.250]             {
[17:39:57.250]                 {
[17:39:57.250]                   {
[17:39:57.250]                     {
[17:39:57.250]                       base::local({
[17:39:57.250]                         has_future <- base::requireNamespace("future", 
[17:39:57.250]                           quietly = TRUE)
[17:39:57.250]                         if (has_future) {
[17:39:57.250]                           ns <- base::getNamespace("future")
[17:39:57.250]                           version <- ns[[".package"]][["version"]]
[17:39:57.250]                           if (is.null(version)) 
[17:39:57.250]                             version <- utils::packageVersion("future")
[17:39:57.250]                         }
[17:39:57.250]                         else {
[17:39:57.250]                           version <- NULL
[17:39:57.250]                         }
[17:39:57.250]                         if (!has_future || version < "1.8.0") {
[17:39:57.250]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.250]                             "", base::R.version$version.string), 
[17:39:57.250]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.250]                               "release", "version")], collapse = " "), 
[17:39:57.250]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.250]                             info)
[17:39:57.250]                           info <- base::paste(info, collapse = "; ")
[17:39:57.250]                           if (!has_future) {
[17:39:57.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.250]                               info)
[17:39:57.250]                           }
[17:39:57.250]                           else {
[17:39:57.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.250]                               info, version)
[17:39:57.250]                           }
[17:39:57.250]                           base::stop(msg)
[17:39:57.250]                         }
[17:39:57.250]                       })
[17:39:57.250]                     }
[17:39:57.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.250]                     base::options(mc.cores = 1L)
[17:39:57.250]                   }
[17:39:57.250]                   ...future.strategy.old <- future::plan("list")
[17:39:57.250]                   options(future.plan = NULL)
[17:39:57.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.250]                 }
[17:39:57.250]                 ...future.workdir <- getwd()
[17:39:57.250]             }
[17:39:57.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.250]         }
[17:39:57.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.250]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.250]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.250]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.250]             base::names(...future.oldOptions))
[17:39:57.250]     }
[17:39:57.250]     if (FALSE) {
[17:39:57.250]     }
[17:39:57.250]     else {
[17:39:57.250]         if (TRUE) {
[17:39:57.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.250]                 open = "w")
[17:39:57.250]         }
[17:39:57.250]         else {
[17:39:57.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.250]         }
[17:39:57.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.250]             base::sink(type = "output", split = FALSE)
[17:39:57.250]             base::close(...future.stdout)
[17:39:57.250]         }, add = TRUE)
[17:39:57.250]     }
[17:39:57.250]     ...future.frame <- base::sys.nframe()
[17:39:57.250]     ...future.conditions <- base::list()
[17:39:57.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.250]     if (FALSE) {
[17:39:57.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.250]     }
[17:39:57.250]     ...future.result <- base::tryCatch({
[17:39:57.250]         base::withCallingHandlers({
[17:39:57.250]             ...future.value <- base::withVisible(base::local({
[17:39:57.250]                 withCallingHandlers({
[17:39:57.250]                   1
[17:39:57.250]                 }, immediateCondition = function(cond) {
[17:39:57.250]                   save_rds <- function (object, pathname, ...) 
[17:39:57.250]                   {
[17:39:57.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.250]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.250]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.250]                         fi_tmp[["mtime"]])
[17:39:57.250]                     }
[17:39:57.250]                     tryCatch({
[17:39:57.250]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.250]                     }, error = function(ex) {
[17:39:57.250]                       msg <- conditionMessage(ex)
[17:39:57.250]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.250]                         fi_tmp[["mtime"]], msg)
[17:39:57.250]                       ex$message <- msg
[17:39:57.250]                       stop(ex)
[17:39:57.250]                     })
[17:39:57.250]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.250]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.250]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.250]                       fi <- file.info(pathname)
[17:39:57.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.250]                         fi[["size"]], fi[["mtime"]])
[17:39:57.250]                       stop(msg)
[17:39:57.250]                     }
[17:39:57.250]                     invisible(pathname)
[17:39:57.250]                   }
[17:39:57.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.250]                     rootPath = tempdir()) 
[17:39:57.250]                   {
[17:39:57.250]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.250]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.250]                       tmpdir = path, fileext = ".rds")
[17:39:57.250]                     save_rds(obj, file)
[17:39:57.250]                   }
[17:39:57.250]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.250]                   {
[17:39:57.250]                     inherits <- base::inherits
[17:39:57.250]                     invokeRestart <- base::invokeRestart
[17:39:57.250]                     is.null <- base::is.null
[17:39:57.250]                     muffled <- FALSE
[17:39:57.250]                     if (inherits(cond, "message")) {
[17:39:57.250]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.250]                       if (muffled) 
[17:39:57.250]                         invokeRestart("muffleMessage")
[17:39:57.250]                     }
[17:39:57.250]                     else if (inherits(cond, "warning")) {
[17:39:57.250]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.250]                       if (muffled) 
[17:39:57.250]                         invokeRestart("muffleWarning")
[17:39:57.250]                     }
[17:39:57.250]                     else if (inherits(cond, "condition")) {
[17:39:57.250]                       if (!is.null(pattern)) {
[17:39:57.250]                         computeRestarts <- base::computeRestarts
[17:39:57.250]                         grepl <- base::grepl
[17:39:57.250]                         restarts <- computeRestarts(cond)
[17:39:57.250]                         for (restart in restarts) {
[17:39:57.250]                           name <- restart$name
[17:39:57.250]                           if (is.null(name)) 
[17:39:57.250]                             next
[17:39:57.250]                           if (!grepl(pattern, name)) 
[17:39:57.250]                             next
[17:39:57.250]                           invokeRestart(restart)
[17:39:57.250]                           muffled <- TRUE
[17:39:57.250]                           break
[17:39:57.250]                         }
[17:39:57.250]                       }
[17:39:57.250]                     }
[17:39:57.250]                     invisible(muffled)
[17:39:57.250]                   }
[17:39:57.250]                   muffleCondition(cond)
[17:39:57.250]                 })
[17:39:57.250]             }))
[17:39:57.250]             future::FutureResult(value = ...future.value$value, 
[17:39:57.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.250]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.250]                     ...future.globalenv.names))
[17:39:57.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.250]         }, condition = base::local({
[17:39:57.250]             c <- base::c
[17:39:57.250]             inherits <- base::inherits
[17:39:57.250]             invokeRestart <- base::invokeRestart
[17:39:57.250]             length <- base::length
[17:39:57.250]             list <- base::list
[17:39:57.250]             seq.int <- base::seq.int
[17:39:57.250]             signalCondition <- base::signalCondition
[17:39:57.250]             sys.calls <- base::sys.calls
[17:39:57.250]             `[[` <- base::`[[`
[17:39:57.250]             `+` <- base::`+`
[17:39:57.250]             `<<-` <- base::`<<-`
[17:39:57.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.250]                   3L)]
[17:39:57.250]             }
[17:39:57.250]             function(cond) {
[17:39:57.250]                 is_error <- inherits(cond, "error")
[17:39:57.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.250]                   NULL)
[17:39:57.250]                 if (is_error) {
[17:39:57.250]                   sessionInformation <- function() {
[17:39:57.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.250]                       search = base::search(), system = base::Sys.info())
[17:39:57.250]                   }
[17:39:57.250]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.250]                     cond$call), session = sessionInformation(), 
[17:39:57.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.250]                   signalCondition(cond)
[17:39:57.250]                 }
[17:39:57.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.250]                 "immediateCondition"))) {
[17:39:57.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.250]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.250]                   if (TRUE && !signal) {
[17:39:57.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.250]                     {
[17:39:57.250]                       inherits <- base::inherits
[17:39:57.250]                       invokeRestart <- base::invokeRestart
[17:39:57.250]                       is.null <- base::is.null
[17:39:57.250]                       muffled <- FALSE
[17:39:57.250]                       if (inherits(cond, "message")) {
[17:39:57.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.250]                         if (muffled) 
[17:39:57.250]                           invokeRestart("muffleMessage")
[17:39:57.250]                       }
[17:39:57.250]                       else if (inherits(cond, "warning")) {
[17:39:57.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.250]                         if (muffled) 
[17:39:57.250]                           invokeRestart("muffleWarning")
[17:39:57.250]                       }
[17:39:57.250]                       else if (inherits(cond, "condition")) {
[17:39:57.250]                         if (!is.null(pattern)) {
[17:39:57.250]                           computeRestarts <- base::computeRestarts
[17:39:57.250]                           grepl <- base::grepl
[17:39:57.250]                           restarts <- computeRestarts(cond)
[17:39:57.250]                           for (restart in restarts) {
[17:39:57.250]                             name <- restart$name
[17:39:57.250]                             if (is.null(name)) 
[17:39:57.250]                               next
[17:39:57.250]                             if (!grepl(pattern, name)) 
[17:39:57.250]                               next
[17:39:57.250]                             invokeRestart(restart)
[17:39:57.250]                             muffled <- TRUE
[17:39:57.250]                             break
[17:39:57.250]                           }
[17:39:57.250]                         }
[17:39:57.250]                       }
[17:39:57.250]                       invisible(muffled)
[17:39:57.250]                     }
[17:39:57.250]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.250]                   }
[17:39:57.250]                 }
[17:39:57.250]                 else {
[17:39:57.250]                   if (TRUE) {
[17:39:57.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.250]                     {
[17:39:57.250]                       inherits <- base::inherits
[17:39:57.250]                       invokeRestart <- base::invokeRestart
[17:39:57.250]                       is.null <- base::is.null
[17:39:57.250]                       muffled <- FALSE
[17:39:57.250]                       if (inherits(cond, "message")) {
[17:39:57.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.250]                         if (muffled) 
[17:39:57.250]                           invokeRestart("muffleMessage")
[17:39:57.250]                       }
[17:39:57.250]                       else if (inherits(cond, "warning")) {
[17:39:57.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.250]                         if (muffled) 
[17:39:57.250]                           invokeRestart("muffleWarning")
[17:39:57.250]                       }
[17:39:57.250]                       else if (inherits(cond, "condition")) {
[17:39:57.250]                         if (!is.null(pattern)) {
[17:39:57.250]                           computeRestarts <- base::computeRestarts
[17:39:57.250]                           grepl <- base::grepl
[17:39:57.250]                           restarts <- computeRestarts(cond)
[17:39:57.250]                           for (restart in restarts) {
[17:39:57.250]                             name <- restart$name
[17:39:57.250]                             if (is.null(name)) 
[17:39:57.250]                               next
[17:39:57.250]                             if (!grepl(pattern, name)) 
[17:39:57.250]                               next
[17:39:57.250]                             invokeRestart(restart)
[17:39:57.250]                             muffled <- TRUE
[17:39:57.250]                             break
[17:39:57.250]                           }
[17:39:57.250]                         }
[17:39:57.250]                       }
[17:39:57.250]                       invisible(muffled)
[17:39:57.250]                     }
[17:39:57.250]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.250]                   }
[17:39:57.250]                 }
[17:39:57.250]             }
[17:39:57.250]         }))
[17:39:57.250]     }, error = function(ex) {
[17:39:57.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.250]                 ...future.rng), started = ...future.startTime, 
[17:39:57.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.250]             version = "1.8"), class = "FutureResult")
[17:39:57.250]     }, finally = {
[17:39:57.250]         if (!identical(...future.workdir, getwd())) 
[17:39:57.250]             setwd(...future.workdir)
[17:39:57.250]         {
[17:39:57.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.250]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.250]             }
[17:39:57.250]             base::options(...future.oldOptions)
[17:39:57.250]             if (.Platform$OS.type == "windows") {
[17:39:57.250]                 old_names <- names(...future.oldEnvVars)
[17:39:57.250]                 envs <- base::Sys.getenv()
[17:39:57.250]                 names <- names(envs)
[17:39:57.250]                 common <- intersect(names, old_names)
[17:39:57.250]                 added <- setdiff(names, old_names)
[17:39:57.250]                 removed <- setdiff(old_names, names)
[17:39:57.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.250]                   envs[common]]
[17:39:57.250]                 NAMES <- toupper(changed)
[17:39:57.250]                 args <- list()
[17:39:57.250]                 for (kk in seq_along(NAMES)) {
[17:39:57.250]                   name <- changed[[kk]]
[17:39:57.250]                   NAME <- NAMES[[kk]]
[17:39:57.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.250]                     next
[17:39:57.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.250]                 }
[17:39:57.250]                 NAMES <- toupper(added)
[17:39:57.250]                 for (kk in seq_along(NAMES)) {
[17:39:57.250]                   name <- added[[kk]]
[17:39:57.250]                   NAME <- NAMES[[kk]]
[17:39:57.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.250]                     next
[17:39:57.250]                   args[[name]] <- ""
[17:39:57.250]                 }
[17:39:57.250]                 NAMES <- toupper(removed)
[17:39:57.250]                 for (kk in seq_along(NAMES)) {
[17:39:57.250]                   name <- removed[[kk]]
[17:39:57.250]                   NAME <- NAMES[[kk]]
[17:39:57.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.250]                     next
[17:39:57.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.250]                 }
[17:39:57.250]                 if (length(args) > 0) 
[17:39:57.250]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.250]             }
[17:39:57.250]             else {
[17:39:57.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.250]             }
[17:39:57.250]             {
[17:39:57.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.250]                   0L) {
[17:39:57.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.250]                   base::options(opts)
[17:39:57.250]                 }
[17:39:57.250]                 {
[17:39:57.250]                   {
[17:39:57.250]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.250]                     NULL
[17:39:57.250]                   }
[17:39:57.250]                   options(future.plan = NULL)
[17:39:57.250]                   if (is.na(NA_character_)) 
[17:39:57.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.250]                     .init = FALSE)
[17:39:57.250]                 }
[17:39:57.250]             }
[17:39:57.250]         }
[17:39:57.250]     })
[17:39:57.250]     if (TRUE) {
[17:39:57.250]         base::sink(type = "output", split = FALSE)
[17:39:57.250]         if (TRUE) {
[17:39:57.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.250]         }
[17:39:57.250]         else {
[17:39:57.250]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.250]         }
[17:39:57.250]         base::close(...future.stdout)
[17:39:57.250]         ...future.stdout <- NULL
[17:39:57.250]     }
[17:39:57.250]     ...future.result$conditions <- ...future.conditions
[17:39:57.250]     ...future.result$finished <- base::Sys.time()
[17:39:57.250]     ...future.result
[17:39:57.250] }
[17:39:57.252] requestCore(): workers = 2
[17:39:57.254] MulticoreFuture started
[17:39:57.255] - Launch lazy future ... done
[17:39:57.255] plan(): Setting new future strategy stack:
[17:39:57.255] run() for ‘MulticoreFuture’ ... done
[17:39:57.255] List of future strategies:
[17:39:57.255] 1. sequential:
[17:39:57.255]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.255]    - tweaked: FALSE
[17:39:57.255]    - call: NULL
[17:39:57.257] plan(): nbrOfWorkers() = 1
[17:39:57.260] plan(): Setting new future strategy stack:
[17:39:57.260] List of future strategies:
[17:39:57.260] 1. multicore:
[17:39:57.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.260]    - tweaked: FALSE
[17:39:57.260]    - call: plan(strategy)
[17:39:57.266] plan(): nbrOfWorkers() = 2
[17:39:57.277] Future #1
[17:39:57.277] result() for MulticoreFuture ...
[17:39:57.278] result() for MulticoreFuture ...
[17:39:57.278] result() for MulticoreFuture ... done
[17:39:57.278] result() for MulticoreFuture ... done
[17:39:57.278] result() for MulticoreFuture ...
[17:39:57.279] result() for MulticoreFuture ... done
[17:39:57.279] A MulticoreFuture was resolved
[17:39:57.279]  length: 0 (resolved future 1)
[17:39:57.279] resolve() on list ... DONE
[17:39:57.279] - globals: [1] ‘a’
[17:39:57.279] Resolving futures part of globals (recursively) ... DONE
[17:39:57.282] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[17:39:57.283] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:57.283] - globals: [1] ‘a’
[17:39:57.283] - packages: [1] ‘future’
[17:39:57.283] getGlobalsAndPackages() ... DONE
[17:39:57.283] run() for ‘Future’ ...
[17:39:57.284] - state: ‘created’
[17:39:57.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.288]   - Field: ‘label’
[17:39:57.288]   - Field: ‘local’
[17:39:57.288]   - Field: ‘owner’
[17:39:57.288]   - Field: ‘envir’
[17:39:57.288]   - Field: ‘workers’
[17:39:57.289]   - Field: ‘packages’
[17:39:57.289]   - Field: ‘gc’
[17:39:57.289]   - Field: ‘job’
[17:39:57.289]   - Field: ‘conditions’
[17:39:57.289]   - Field: ‘expr’
[17:39:57.289]   - Field: ‘uuid’
[17:39:57.289]   - Field: ‘seed’
[17:39:57.289]   - Field: ‘version’
[17:39:57.289]   - Field: ‘result’
[17:39:57.290]   - Field: ‘asynchronous’
[17:39:57.290]   - Field: ‘calls’
[17:39:57.290]   - Field: ‘globals’
[17:39:57.290]   - Field: ‘stdout’
[17:39:57.290]   - Field: ‘earlySignal’
[17:39:57.290]   - Field: ‘lazy’
[17:39:57.290]   - Field: ‘state’
[17:39:57.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.290] - Launch lazy future ...
[17:39:57.291] Packages needed by the future expression (n = 1): ‘future’
[17:39:57.291] Packages needed by future strategies (n = 0): <none>
[17:39:57.292] {
[17:39:57.292]     {
[17:39:57.292]         {
[17:39:57.292]             ...future.startTime <- base::Sys.time()
[17:39:57.292]             {
[17:39:57.292]                 {
[17:39:57.292]                   {
[17:39:57.292]                     {
[17:39:57.292]                       {
[17:39:57.292]                         base::local({
[17:39:57.292]                           has_future <- base::requireNamespace("future", 
[17:39:57.292]                             quietly = TRUE)
[17:39:57.292]                           if (has_future) {
[17:39:57.292]                             ns <- base::getNamespace("future")
[17:39:57.292]                             version <- ns[[".package"]][["version"]]
[17:39:57.292]                             if (is.null(version)) 
[17:39:57.292]                               version <- utils::packageVersion("future")
[17:39:57.292]                           }
[17:39:57.292]                           else {
[17:39:57.292]                             version <- NULL
[17:39:57.292]                           }
[17:39:57.292]                           if (!has_future || version < "1.8.0") {
[17:39:57.292]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.292]                               "", base::R.version$version.string), 
[17:39:57.292]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:57.292]                                 base::R.version$platform, 8 * 
[17:39:57.292]                                   base::.Machine$sizeof.pointer), 
[17:39:57.292]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.292]                                 "release", "version")], collapse = " "), 
[17:39:57.292]                               hostname = base::Sys.info()[["nodename"]])
[17:39:57.292]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.292]                               info)
[17:39:57.292]                             info <- base::paste(info, collapse = "; ")
[17:39:57.292]                             if (!has_future) {
[17:39:57.292]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.292]                                 info)
[17:39:57.292]                             }
[17:39:57.292]                             else {
[17:39:57.292]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.292]                                 info, version)
[17:39:57.292]                             }
[17:39:57.292]                             base::stop(msg)
[17:39:57.292]                           }
[17:39:57.292]                         })
[17:39:57.292]                       }
[17:39:57.292]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.292]                       base::options(mc.cores = 1L)
[17:39:57.292]                     }
[17:39:57.292]                     base::local({
[17:39:57.292]                       for (pkg in "future") {
[17:39:57.292]                         base::loadNamespace(pkg)
[17:39:57.292]                         base::library(pkg, character.only = TRUE)
[17:39:57.292]                       }
[17:39:57.292]                     })
[17:39:57.292]                   }
[17:39:57.292]                   ...future.strategy.old <- future::plan("list")
[17:39:57.292]                   options(future.plan = NULL)
[17:39:57.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.292]                 }
[17:39:57.292]                 ...future.workdir <- getwd()
[17:39:57.292]             }
[17:39:57.292]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.292]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.292]         }
[17:39:57.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.292]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.292]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.292]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.292]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.292]             base::names(...future.oldOptions))
[17:39:57.292]     }
[17:39:57.292]     if (FALSE) {
[17:39:57.292]     }
[17:39:57.292]     else {
[17:39:57.292]         if (TRUE) {
[17:39:57.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.292]                 open = "w")
[17:39:57.292]         }
[17:39:57.292]         else {
[17:39:57.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.292]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.292]         }
[17:39:57.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.292]             base::sink(type = "output", split = FALSE)
[17:39:57.292]             base::close(...future.stdout)
[17:39:57.292]         }, add = TRUE)
[17:39:57.292]     }
[17:39:57.292]     ...future.frame <- base::sys.nframe()
[17:39:57.292]     ...future.conditions <- base::list()
[17:39:57.292]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.292]     if (FALSE) {
[17:39:57.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.292]     }
[17:39:57.292]     ...future.result <- base::tryCatch({
[17:39:57.292]         base::withCallingHandlers({
[17:39:57.292]             ...future.value <- base::withVisible(base::local({
[17:39:57.292]                 withCallingHandlers({
[17:39:57.292]                   value(a) + 1
[17:39:57.292]                 }, immediateCondition = function(cond) {
[17:39:57.292]                   save_rds <- function (object, pathname, ...) 
[17:39:57.292]                   {
[17:39:57.292]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.292]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.292]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.292]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.292]                         fi_tmp[["mtime"]])
[17:39:57.292]                     }
[17:39:57.292]                     tryCatch({
[17:39:57.292]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.292]                     }, error = function(ex) {
[17:39:57.292]                       msg <- conditionMessage(ex)
[17:39:57.292]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.292]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.292]                         fi_tmp[["mtime"]], msg)
[17:39:57.292]                       ex$message <- msg
[17:39:57.292]                       stop(ex)
[17:39:57.292]                     })
[17:39:57.292]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.292]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.292]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.292]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.292]                       fi <- file.info(pathname)
[17:39:57.292]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.292]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.292]                         fi[["size"]], fi[["mtime"]])
[17:39:57.292]                       stop(msg)
[17:39:57.292]                     }
[17:39:57.292]                     invisible(pathname)
[17:39:57.292]                   }
[17:39:57.292]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.292]                     rootPath = tempdir()) 
[17:39:57.292]                   {
[17:39:57.292]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.292]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.292]                       tmpdir = path, fileext = ".rds")
[17:39:57.292]                     save_rds(obj, file)
[17:39:57.292]                   }
[17:39:57.292]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.292]                   {
[17:39:57.292]                     inherits <- base::inherits
[17:39:57.292]                     invokeRestart <- base::invokeRestart
[17:39:57.292]                     is.null <- base::is.null
[17:39:57.292]                     muffled <- FALSE
[17:39:57.292]                     if (inherits(cond, "message")) {
[17:39:57.292]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.292]                       if (muffled) 
[17:39:57.292]                         invokeRestart("muffleMessage")
[17:39:57.292]                     }
[17:39:57.292]                     else if (inherits(cond, "warning")) {
[17:39:57.292]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.292]                       if (muffled) 
[17:39:57.292]                         invokeRestart("muffleWarning")
[17:39:57.292]                     }
[17:39:57.292]                     else if (inherits(cond, "condition")) {
[17:39:57.292]                       if (!is.null(pattern)) {
[17:39:57.292]                         computeRestarts <- base::computeRestarts
[17:39:57.292]                         grepl <- base::grepl
[17:39:57.292]                         restarts <- computeRestarts(cond)
[17:39:57.292]                         for (restart in restarts) {
[17:39:57.292]                           name <- restart$name
[17:39:57.292]                           if (is.null(name)) 
[17:39:57.292]                             next
[17:39:57.292]                           if (!grepl(pattern, name)) 
[17:39:57.292]                             next
[17:39:57.292]                           invokeRestart(restart)
[17:39:57.292]                           muffled <- TRUE
[17:39:57.292]                           break
[17:39:57.292]                         }
[17:39:57.292]                       }
[17:39:57.292]                     }
[17:39:57.292]                     invisible(muffled)
[17:39:57.292]                   }
[17:39:57.292]                   muffleCondition(cond)
[17:39:57.292]                 })
[17:39:57.292]             }))
[17:39:57.292]             future::FutureResult(value = ...future.value$value, 
[17:39:57.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.292]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.292]                     ...future.globalenv.names))
[17:39:57.292]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.292]         }, condition = base::local({
[17:39:57.292]             c <- base::c
[17:39:57.292]             inherits <- base::inherits
[17:39:57.292]             invokeRestart <- base::invokeRestart
[17:39:57.292]             length <- base::length
[17:39:57.292]             list <- base::list
[17:39:57.292]             seq.int <- base::seq.int
[17:39:57.292]             signalCondition <- base::signalCondition
[17:39:57.292]             sys.calls <- base::sys.calls
[17:39:57.292]             `[[` <- base::`[[`
[17:39:57.292]             `+` <- base::`+`
[17:39:57.292]             `<<-` <- base::`<<-`
[17:39:57.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.292]                   3L)]
[17:39:57.292]             }
[17:39:57.292]             function(cond) {
[17:39:57.292]                 is_error <- inherits(cond, "error")
[17:39:57.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.292]                   NULL)
[17:39:57.292]                 if (is_error) {
[17:39:57.292]                   sessionInformation <- function() {
[17:39:57.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.292]                       search = base::search(), system = base::Sys.info())
[17:39:57.292]                   }
[17:39:57.292]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.292]                     cond$call), session = sessionInformation(), 
[17:39:57.292]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.292]                   signalCondition(cond)
[17:39:57.292]                 }
[17:39:57.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.292]                 "immediateCondition"))) {
[17:39:57.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.292]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.292]                   if (TRUE && !signal) {
[17:39:57.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.292]                     {
[17:39:57.292]                       inherits <- base::inherits
[17:39:57.292]                       invokeRestart <- base::invokeRestart
[17:39:57.292]                       is.null <- base::is.null
[17:39:57.292]                       muffled <- FALSE
[17:39:57.292]                       if (inherits(cond, "message")) {
[17:39:57.292]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.292]                         if (muffled) 
[17:39:57.292]                           invokeRestart("muffleMessage")
[17:39:57.292]                       }
[17:39:57.292]                       else if (inherits(cond, "warning")) {
[17:39:57.292]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.292]                         if (muffled) 
[17:39:57.292]                           invokeRestart("muffleWarning")
[17:39:57.292]                       }
[17:39:57.292]                       else if (inherits(cond, "condition")) {
[17:39:57.292]                         if (!is.null(pattern)) {
[17:39:57.292]                           computeRestarts <- base::computeRestarts
[17:39:57.292]                           grepl <- base::grepl
[17:39:57.292]                           restarts <- computeRestarts(cond)
[17:39:57.292]                           for (restart in restarts) {
[17:39:57.292]                             name <- restart$name
[17:39:57.292]                             if (is.null(name)) 
[17:39:57.292]                               next
[17:39:57.292]                             if (!grepl(pattern, name)) 
[17:39:57.292]                               next
[17:39:57.292]                             invokeRestart(restart)
[17:39:57.292]                             muffled <- TRUE
[17:39:57.292]                             break
[17:39:57.292]                           }
[17:39:57.292]                         }
[17:39:57.292]                       }
[17:39:57.292]                       invisible(muffled)
[17:39:57.292]                     }
[17:39:57.292]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.292]                   }
[17:39:57.292]                 }
[17:39:57.292]                 else {
[17:39:57.292]                   if (TRUE) {
[17:39:57.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.292]                     {
[17:39:57.292]                       inherits <- base::inherits
[17:39:57.292]                       invokeRestart <- base::invokeRestart
[17:39:57.292]                       is.null <- base::is.null
[17:39:57.292]                       muffled <- FALSE
[17:39:57.292]                       if (inherits(cond, "message")) {
[17:39:57.292]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.292]                         if (muffled) 
[17:39:57.292]                           invokeRestart("muffleMessage")
[17:39:57.292]                       }
[17:39:57.292]                       else if (inherits(cond, "warning")) {
[17:39:57.292]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.292]                         if (muffled) 
[17:39:57.292]                           invokeRestart("muffleWarning")
[17:39:57.292]                       }
[17:39:57.292]                       else if (inherits(cond, "condition")) {
[17:39:57.292]                         if (!is.null(pattern)) {
[17:39:57.292]                           computeRestarts <- base::computeRestarts
[17:39:57.292]                           grepl <- base::grepl
[17:39:57.292]                           restarts <- computeRestarts(cond)
[17:39:57.292]                           for (restart in restarts) {
[17:39:57.292]                             name <- restart$name
[17:39:57.292]                             if (is.null(name)) 
[17:39:57.292]                               next
[17:39:57.292]                             if (!grepl(pattern, name)) 
[17:39:57.292]                               next
[17:39:57.292]                             invokeRestart(restart)
[17:39:57.292]                             muffled <- TRUE
[17:39:57.292]                             break
[17:39:57.292]                           }
[17:39:57.292]                         }
[17:39:57.292]                       }
[17:39:57.292]                       invisible(muffled)
[17:39:57.292]                     }
[17:39:57.292]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.292]                   }
[17:39:57.292]                 }
[17:39:57.292]             }
[17:39:57.292]         }))
[17:39:57.292]     }, error = function(ex) {
[17:39:57.292]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.292]                 ...future.rng), started = ...future.startTime, 
[17:39:57.292]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.292]             version = "1.8"), class = "FutureResult")
[17:39:57.292]     }, finally = {
[17:39:57.292]         if (!identical(...future.workdir, getwd())) 
[17:39:57.292]             setwd(...future.workdir)
[17:39:57.292]         {
[17:39:57.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.292]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.292]             }
[17:39:57.292]             base::options(...future.oldOptions)
[17:39:57.292]             if (.Platform$OS.type == "windows") {
[17:39:57.292]                 old_names <- names(...future.oldEnvVars)
[17:39:57.292]                 envs <- base::Sys.getenv()
[17:39:57.292]                 names <- names(envs)
[17:39:57.292]                 common <- intersect(names, old_names)
[17:39:57.292]                 added <- setdiff(names, old_names)
[17:39:57.292]                 removed <- setdiff(old_names, names)
[17:39:57.292]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.292]                   envs[common]]
[17:39:57.292]                 NAMES <- toupper(changed)
[17:39:57.292]                 args <- list()
[17:39:57.292]                 for (kk in seq_along(NAMES)) {
[17:39:57.292]                   name <- changed[[kk]]
[17:39:57.292]                   NAME <- NAMES[[kk]]
[17:39:57.292]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.292]                     next
[17:39:57.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.292]                 }
[17:39:57.292]                 NAMES <- toupper(added)
[17:39:57.292]                 for (kk in seq_along(NAMES)) {
[17:39:57.292]                   name <- added[[kk]]
[17:39:57.292]                   NAME <- NAMES[[kk]]
[17:39:57.292]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.292]                     next
[17:39:57.292]                   args[[name]] <- ""
[17:39:57.292]                 }
[17:39:57.292]                 NAMES <- toupper(removed)
[17:39:57.292]                 for (kk in seq_along(NAMES)) {
[17:39:57.292]                   name <- removed[[kk]]
[17:39:57.292]                   NAME <- NAMES[[kk]]
[17:39:57.292]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.292]                     next
[17:39:57.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.292]                 }
[17:39:57.292]                 if (length(args) > 0) 
[17:39:57.292]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.292]             }
[17:39:57.292]             else {
[17:39:57.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.292]             }
[17:39:57.292]             {
[17:39:57.292]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.292]                   0L) {
[17:39:57.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.292]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.292]                   base::options(opts)
[17:39:57.292]                 }
[17:39:57.292]                 {
[17:39:57.292]                   {
[17:39:57.292]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.292]                     NULL
[17:39:57.292]                   }
[17:39:57.292]                   options(future.plan = NULL)
[17:39:57.292]                   if (is.na(NA_character_)) 
[17:39:57.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.292]                     .init = FALSE)
[17:39:57.292]                 }
[17:39:57.292]             }
[17:39:57.292]         }
[17:39:57.292]     })
[17:39:57.292]     if (TRUE) {
[17:39:57.292]         base::sink(type = "output", split = FALSE)
[17:39:57.292]         if (TRUE) {
[17:39:57.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.292]         }
[17:39:57.292]         else {
[17:39:57.292]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.292]         }
[17:39:57.292]         base::close(...future.stdout)
[17:39:57.292]         ...future.stdout <- NULL
[17:39:57.292]     }
[17:39:57.292]     ...future.result$conditions <- ...future.conditions
[17:39:57.292]     ...future.result$finished <- base::Sys.time()
[17:39:57.292]     ...future.result
[17:39:57.292] }
[17:39:57.294] assign_globals() ...
[17:39:57.294] List of 1
[17:39:57.294]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bfd8693860> 
[17:39:57.294]  - attr(*, "where")=List of 1
[17:39:57.294]   ..$ a:<environment: R_EmptyEnv> 
[17:39:57.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.294]  - attr(*, "resolved")= logi TRUE
[17:39:57.294]  - attr(*, "total_size")= num 1647648
[17:39:57.294]  - attr(*, "already-done")= logi TRUE
[17:39:57.297] - copied ‘a’ to environment
[17:39:57.297] assign_globals() ... done
[17:39:57.298] requestCore(): workers = 2
[17:39:57.299] MulticoreFuture started
[17:39:57.300] - Launch lazy future ... done
[17:39:57.300] run() for ‘MulticoreFuture’ ... done
[17:39:57.300] result() for MulticoreFuture ...
[17:39:57.301] plan(): Setting new future strategy stack:
[17:39:57.301] List of future strategies:
[17:39:57.301] 1. sequential:
[17:39:57.301]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.301]    - tweaked: FALSE
[17:39:57.301]    - call: NULL
[17:39:57.302] plan(): nbrOfWorkers() = 1
[17:39:57.305] plan(): Setting new future strategy stack:
[17:39:57.305] List of future strategies:
[17:39:57.305] 1. multicore:
[17:39:57.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.305]    - tweaked: FALSE
[17:39:57.305]    - call: plan(strategy)
[17:39:57.311] plan(): nbrOfWorkers() = 2
[17:39:57.312] result() for MulticoreFuture ...
[17:39:57.312] result() for MulticoreFuture ... done
[17:39:57.312] signalConditions() ...
[17:39:57.312]  - include = ‘immediateCondition’
[17:39:57.312]  - exclude = 
[17:39:57.313]  - resignal = FALSE
[17:39:57.313]  - Number of conditions: 4
[17:39:57.313] signalConditions() ... done
[17:39:57.313] result() for MulticoreFuture ... done
[17:39:57.313] result() for MulticoreFuture ...
[17:39:57.313] result() for MulticoreFuture ... done
[17:39:57.313] signalConditions() ...
[17:39:57.313]  - include = ‘immediateCondition’
[17:39:57.314]  - exclude = 
[17:39:57.314]  - resignal = FALSE
[17:39:57.314]  - Number of conditions: 4
[17:39:57.314] signalConditions() ... done
[17:39:57.314] Future state: ‘finished’
[17:39:57.314] result() for MulticoreFuture ...
[17:39:57.314] result() for MulticoreFuture ... done
[17:39:57.314] signalConditions() ...
[17:39:57.315]  - include = ‘condition’
[17:39:57.315]  - exclude = ‘immediateCondition’
[17:39:57.315]  - resignal = TRUE
[17:39:57.315]  - Number of conditions: 4
[17:39:57.315]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.303] result() for MulticoreFuture ...
[17:39:57.315]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.304] result() for MulticoreFuture ... done
[17:39:57.315]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.304] result() for MulticoreFuture ...
[17:39:57.315]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.304] result() for MulticoreFuture ... done
[17:39:57.316] signalConditions() ... done
value(b) = 2
[17:39:57.316] result() for MulticoreFuture ...
[17:39:57.316] result() for MulticoreFuture ... done
[17:39:57.319] result() for MulticoreFuture ...
[17:39:57.319] result() for MulticoreFuture ... done
[17:39:57.319] signalConditions() ...
[17:39:57.319]  - include = ‘immediateCondition’
[17:39:57.320]  - exclude = 
[17:39:57.320]  - resignal = FALSE
[17:39:57.320]  - Number of conditions: 4
[17:39:57.320] signalConditions() ... done
[17:39:57.320] Future state: ‘finished’
[17:39:57.320] result() for MulticoreFuture ...
[17:39:57.320] result() for MulticoreFuture ... done
[17:39:57.320] signalConditions() ...
[17:39:57.321]  - include = ‘condition’
[17:39:57.321]  - exclude = ‘immediateCondition’
[17:39:57.321]  - resignal = TRUE
[17:39:57.321]  - Number of conditions: 4
[17:39:57.321]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.303] result() for MulticoreFuture ...
[17:39:57.321]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.304] result() for MulticoreFuture ... done
[17:39:57.321]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.304] result() for MulticoreFuture ...
[17:39:57.322]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[17:39:57.304] result() for MulticoreFuture ... done
[17:39:57.322] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.322] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.322] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.324] - globals found: [2] ‘{’, ‘pkg’
[17:39:57.324] Searching for globals ... DONE
[17:39:57.324] Resolving globals: TRUE
[17:39:57.324] Resolving any globals that are futures ...
[17:39:57.324] - globals: [2] ‘{’, ‘pkg’
[17:39:57.324] Resolving any globals that are futures ... DONE
[17:39:57.325] Resolving futures part of globals (recursively) ...
[17:39:57.325] resolve() on list ...
[17:39:57.325]  recursive: 99
[17:39:57.325]  length: 1
[17:39:57.326]  elements: ‘pkg’
[17:39:57.326]  length: 0 (resolved future 1)
[17:39:57.326] resolve() on list ... DONE
[17:39:57.326] - globals: [1] ‘pkg’
[17:39:57.326] Resolving futures part of globals (recursively) ... DONE
[17:39:57.326] The total size of the 1 globals is 112 bytes (112 bytes)
[17:39:57.327] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:39:57.327] - globals: [1] ‘pkg’
[17:39:57.327] 
[17:39:57.327] getGlobalsAndPackages() ... DONE
[17:39:57.328] Packages needed by the future expression (n = 0): <none>
[17:39:57.328] Packages needed by future strategies (n = 0): <none>
[17:39:57.328] {
[17:39:57.328]     {
[17:39:57.328]         {
[17:39:57.328]             ...future.startTime <- base::Sys.time()
[17:39:57.328]             {
[17:39:57.328]                 {
[17:39:57.328]                   {
[17:39:57.328]                     base::local({
[17:39:57.328]                       has_future <- base::requireNamespace("future", 
[17:39:57.328]                         quietly = TRUE)
[17:39:57.328]                       if (has_future) {
[17:39:57.328]                         ns <- base::getNamespace("future")
[17:39:57.328]                         version <- ns[[".package"]][["version"]]
[17:39:57.328]                         if (is.null(version)) 
[17:39:57.328]                           version <- utils::packageVersion("future")
[17:39:57.328]                       }
[17:39:57.328]                       else {
[17:39:57.328]                         version <- NULL
[17:39:57.328]                       }
[17:39:57.328]                       if (!has_future || version < "1.8.0") {
[17:39:57.328]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.328]                           "", base::R.version$version.string), 
[17:39:57.328]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:57.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.328]                             "release", "version")], collapse = " "), 
[17:39:57.328]                           hostname = base::Sys.info()[["nodename"]])
[17:39:57.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.328]                           info)
[17:39:57.328]                         info <- base::paste(info, collapse = "; ")
[17:39:57.328]                         if (!has_future) {
[17:39:57.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.328]                             info)
[17:39:57.328]                         }
[17:39:57.328]                         else {
[17:39:57.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.328]                             info, version)
[17:39:57.328]                         }
[17:39:57.328]                         base::stop(msg)
[17:39:57.328]                       }
[17:39:57.328]                     })
[17:39:57.328]                   }
[17:39:57.328]                   ...future.strategy.old <- future::plan("list")
[17:39:57.328]                   options(future.plan = NULL)
[17:39:57.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.328]                 }
[17:39:57.328]                 ...future.workdir <- getwd()
[17:39:57.328]             }
[17:39:57.328]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.328]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.328]         }
[17:39:57.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.328]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.328]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.328]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.328]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.328]             base::names(...future.oldOptions))
[17:39:57.328]     }
[17:39:57.328]     if (FALSE) {
[17:39:57.328]     }
[17:39:57.328]     else {
[17:39:57.328]         if (TRUE) {
[17:39:57.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.328]                 open = "w")
[17:39:57.328]         }
[17:39:57.328]         else {
[17:39:57.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.328]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.328]         }
[17:39:57.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.328]             base::sink(type = "output", split = FALSE)
[17:39:57.328]             base::close(...future.stdout)
[17:39:57.328]         }, add = TRUE)
[17:39:57.328]     }
[17:39:57.328]     ...future.frame <- base::sys.nframe()
[17:39:57.328]     ...future.conditions <- base::list()
[17:39:57.328]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.328]     if (FALSE) {
[17:39:57.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.328]     }
[17:39:57.328]     ...future.result <- base::tryCatch({
[17:39:57.328]         base::withCallingHandlers({
[17:39:57.328]             ...future.value <- base::withVisible(base::local({
[17:39:57.328]                 pkg
[17:39:57.328]             }))
[17:39:57.328]             future::FutureResult(value = ...future.value$value, 
[17:39:57.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.328]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.328]                     ...future.globalenv.names))
[17:39:57.328]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.328]         }, condition = base::local({
[17:39:57.328]             c <- base::c
[17:39:57.328]             inherits <- base::inherits
[17:39:57.328]             invokeRestart <- base::invokeRestart
[17:39:57.328]             length <- base::length
[17:39:57.328]             list <- base::list
[17:39:57.328]             seq.int <- base::seq.int
[17:39:57.328]             signalCondition <- base::signalCondition
[17:39:57.328]             sys.calls <- base::sys.calls
[17:39:57.328]             `[[` <- base::`[[`
[17:39:57.328]             `+` <- base::`+`
[17:39:57.328]             `<<-` <- base::`<<-`
[17:39:57.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.328]                   3L)]
[17:39:57.328]             }
[17:39:57.328]             function(cond) {
[17:39:57.328]                 is_error <- inherits(cond, "error")
[17:39:57.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.328]                   NULL)
[17:39:57.328]                 if (is_error) {
[17:39:57.328]                   sessionInformation <- function() {
[17:39:57.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.328]                       search = base::search(), system = base::Sys.info())
[17:39:57.328]                   }
[17:39:57.328]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.328]                     cond$call), session = sessionInformation(), 
[17:39:57.328]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.328]                   signalCondition(cond)
[17:39:57.328]                 }
[17:39:57.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.328]                 "immediateCondition"))) {
[17:39:57.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.328]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.328]                   if (TRUE && !signal) {
[17:39:57.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.328]                     {
[17:39:57.328]                       inherits <- base::inherits
[17:39:57.328]                       invokeRestart <- base::invokeRestart
[17:39:57.328]                       is.null <- base::is.null
[17:39:57.328]                       muffled <- FALSE
[17:39:57.328]                       if (inherits(cond, "message")) {
[17:39:57.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.328]                         if (muffled) 
[17:39:57.328]                           invokeRestart("muffleMessage")
[17:39:57.328]                       }
[17:39:57.328]                       else if (inherits(cond, "warning")) {
[17:39:57.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.328]                         if (muffled) 
[17:39:57.328]                           invokeRestart("muffleWarning")
[17:39:57.328]                       }
[17:39:57.328]                       else if (inherits(cond, "condition")) {
[17:39:57.328]                         if (!is.null(pattern)) {
[17:39:57.328]                           computeRestarts <- base::computeRestarts
[17:39:57.328]                           grepl <- base::grepl
[17:39:57.328]                           restarts <- computeRestarts(cond)
[17:39:57.328]                           for (restart in restarts) {
[17:39:57.328]                             name <- restart$name
[17:39:57.328]                             if (is.null(name)) 
[17:39:57.328]                               next
[17:39:57.328]                             if (!grepl(pattern, name)) 
[17:39:57.328]                               next
[17:39:57.328]                             invokeRestart(restart)
[17:39:57.328]                             muffled <- TRUE
[17:39:57.328]                             break
[17:39:57.328]                           }
[17:39:57.328]                         }
[17:39:57.328]                       }
[17:39:57.328]                       invisible(muffled)
[17:39:57.328]                     }
[17:39:57.328]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.328]                   }
[17:39:57.328]                 }
[17:39:57.328]                 else {
[17:39:57.328]                   if (TRUE) {
[17:39:57.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.328]                     {
[17:39:57.328]                       inherits <- base::inherits
[17:39:57.328]                       invokeRestart <- base::invokeRestart
[17:39:57.328]                       is.null <- base::is.null
[17:39:57.328]                       muffled <- FALSE
[17:39:57.328]                       if (inherits(cond, "message")) {
[17:39:57.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.328]                         if (muffled) 
[17:39:57.328]                           invokeRestart("muffleMessage")
[17:39:57.328]                       }
[17:39:57.328]                       else if (inherits(cond, "warning")) {
[17:39:57.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.328]                         if (muffled) 
[17:39:57.328]                           invokeRestart("muffleWarning")
[17:39:57.328]                       }
[17:39:57.328]                       else if (inherits(cond, "condition")) {
[17:39:57.328]                         if (!is.null(pattern)) {
[17:39:57.328]                           computeRestarts <- base::computeRestarts
[17:39:57.328]                           grepl <- base::grepl
[17:39:57.328]                           restarts <- computeRestarts(cond)
[17:39:57.328]                           for (restart in restarts) {
[17:39:57.328]                             name <- restart$name
[17:39:57.328]                             if (is.null(name)) 
[17:39:57.328]                               next
[17:39:57.328]                             if (!grepl(pattern, name)) 
[17:39:57.328]                               next
[17:39:57.328]                             invokeRestart(restart)
[17:39:57.328]                             muffled <- TRUE
[17:39:57.328]                             break
[17:39:57.328]                           }
[17:39:57.328]                         }
[17:39:57.328]                       }
[17:39:57.328]                       invisible(muffled)
[17:39:57.328]                     }
[17:39:57.328]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.328]                   }
[17:39:57.328]                 }
[17:39:57.328]             }
[17:39:57.328]         }))
[17:39:57.328]     }, error = function(ex) {
[17:39:57.328]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.328]                 ...future.rng), started = ...future.startTime, 
[17:39:57.328]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.328]             version = "1.8"), class = "FutureResult")
[17:39:57.328]     }, finally = {
[17:39:57.328]         if (!identical(...future.workdir, getwd())) 
[17:39:57.328]             setwd(...future.workdir)
[17:39:57.328]         {
[17:39:57.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.328]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.328]             }
[17:39:57.328]             base::options(...future.oldOptions)
[17:39:57.328]             if (.Platform$OS.type == "windows") {
[17:39:57.328]                 old_names <- names(...future.oldEnvVars)
[17:39:57.328]                 envs <- base::Sys.getenv()
[17:39:57.328]                 names <- names(envs)
[17:39:57.328]                 common <- intersect(names, old_names)
[17:39:57.328]                 added <- setdiff(names, old_names)
[17:39:57.328]                 removed <- setdiff(old_names, names)
[17:39:57.328]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.328]                   envs[common]]
[17:39:57.328]                 NAMES <- toupper(changed)
[17:39:57.328]                 args <- list()
[17:39:57.328]                 for (kk in seq_along(NAMES)) {
[17:39:57.328]                   name <- changed[[kk]]
[17:39:57.328]                   NAME <- NAMES[[kk]]
[17:39:57.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.328]                     next
[17:39:57.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.328]                 }
[17:39:57.328]                 NAMES <- toupper(added)
[17:39:57.328]                 for (kk in seq_along(NAMES)) {
[17:39:57.328]                   name <- added[[kk]]
[17:39:57.328]                   NAME <- NAMES[[kk]]
[17:39:57.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.328]                     next
[17:39:57.328]                   args[[name]] <- ""
[17:39:57.328]                 }
[17:39:57.328]                 NAMES <- toupper(removed)
[17:39:57.328]                 for (kk in seq_along(NAMES)) {
[17:39:57.328]                   name <- removed[[kk]]
[17:39:57.328]                   NAME <- NAMES[[kk]]
[17:39:57.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.328]                     next
[17:39:57.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.328]                 }
[17:39:57.328]                 if (length(args) > 0) 
[17:39:57.328]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.328]             }
[17:39:57.328]             else {
[17:39:57.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.328]             }
[17:39:57.328]             {
[17:39:57.328]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.328]                   0L) {
[17:39:57.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.328]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.328]                   base::options(opts)
[17:39:57.328]                 }
[17:39:57.328]                 {
[17:39:57.328]                   {
[17:39:57.328]                     NULL
[17:39:57.328]                     RNGkind("Mersenne-Twister")
[17:39:57.328]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:57.328]                       inherits = FALSE)
[17:39:57.328]                   }
[17:39:57.328]                   options(future.plan = NULL)
[17:39:57.328]                   if (is.na(NA_character_)) 
[17:39:57.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.328]                     .init = FALSE)
[17:39:57.328]                 }
[17:39:57.328]             }
[17:39:57.328]         }
[17:39:57.328]     })
[17:39:57.328]     if (TRUE) {
[17:39:57.328]         base::sink(type = "output", split = FALSE)
[17:39:57.328]         if (TRUE) {
[17:39:57.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.328]         }
[17:39:57.328]         else {
[17:39:57.328]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.328]         }
[17:39:57.328]         base::close(...future.stdout)
[17:39:57.328]         ...future.stdout <- NULL
[17:39:57.328]     }
[17:39:57.328]     ...future.result$conditions <- ...future.conditions
[17:39:57.328]     ...future.result$finished <- base::Sys.time()
[17:39:57.328]     ...future.result
[17:39:57.328] }
[17:39:57.330] assign_globals() ...
[17:39:57.330] List of 1
[17:39:57.330]  $ pkg: chr "foo"
[17:39:57.330]  - attr(*, "where")=List of 1
[17:39:57.330]   ..$ pkg:<environment: R_EmptyEnv> 
[17:39:57.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.330]  - attr(*, "resolved")= logi TRUE
[17:39:57.330]  - attr(*, "total_size")= num 112
[17:39:57.333] - copied ‘pkg’ to environment
[17:39:57.333] assign_globals() ... done
[17:39:57.333] plan(): Setting new future strategy stack:
[17:39:57.333] List of future strategies:
[17:39:57.333] 1. sequential:
[17:39:57.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.333]    - tweaked: FALSE
[17:39:57.333]    - call: NULL
[17:39:57.334] plan(): nbrOfWorkers() = 1
[17:39:57.335] plan(): Setting new future strategy stack:
[17:39:57.335] List of future strategies:
[17:39:57.335] 1. multicore:
[17:39:57.335]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.335]    - tweaked: FALSE
[17:39:57.335]    - call: plan(strategy)
[17:39:57.338] plan(): nbrOfWorkers() = 2
[17:39:57.339] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.339] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.339] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.341] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:39:57.342] Searching for globals ... DONE
[17:39:57.342] Resolving globals: TRUE
[17:39:57.342] Resolving any globals that are futures ...
[17:39:57.342] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:39:57.342] Resolving any globals that are futures ... DONE
[17:39:57.342] 
[17:39:57.343] 
[17:39:57.343] getGlobalsAndPackages() ... DONE
[17:39:57.343] run() for ‘Future’ ...
[17:39:57.343] - state: ‘created’
[17:39:57.343] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.347]   - Field: ‘label’
[17:39:57.347]   - Field: ‘local’
[17:39:57.347]   - Field: ‘owner’
[17:39:57.347]   - Field: ‘envir’
[17:39:57.347]   - Field: ‘workers’
[17:39:57.347]   - Field: ‘packages’
[17:39:57.347]   - Field: ‘gc’
[17:39:57.347]   - Field: ‘job’
[17:39:57.348]   - Field: ‘conditions’
[17:39:57.348]   - Field: ‘expr’
[17:39:57.348]   - Field: ‘uuid’
[17:39:57.348]   - Field: ‘seed’
[17:39:57.348]   - Field: ‘version’
[17:39:57.348]   - Field: ‘result’
[17:39:57.348]   - Field: ‘asynchronous’
[17:39:57.348]   - Field: ‘calls’
[17:39:57.348]   - Field: ‘globals’
[17:39:57.348]   - Field: ‘stdout’
[17:39:57.349]   - Field: ‘earlySignal’
[17:39:57.349]   - Field: ‘lazy’
[17:39:57.349]   - Field: ‘state’
[17:39:57.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.349] - Launch lazy future ...
[17:39:57.349] Packages needed by the future expression (n = 0): <none>
[17:39:57.349] Packages needed by future strategies (n = 0): <none>
[17:39:57.350] {
[17:39:57.350]     {
[17:39:57.350]         {
[17:39:57.350]             ...future.startTime <- base::Sys.time()
[17:39:57.350]             {
[17:39:57.350]                 {
[17:39:57.350]                   {
[17:39:57.350]                     {
[17:39:57.350]                       base::local({
[17:39:57.350]                         has_future <- base::requireNamespace("future", 
[17:39:57.350]                           quietly = TRUE)
[17:39:57.350]                         if (has_future) {
[17:39:57.350]                           ns <- base::getNamespace("future")
[17:39:57.350]                           version <- ns[[".package"]][["version"]]
[17:39:57.350]                           if (is.null(version)) 
[17:39:57.350]                             version <- utils::packageVersion("future")
[17:39:57.350]                         }
[17:39:57.350]                         else {
[17:39:57.350]                           version <- NULL
[17:39:57.350]                         }
[17:39:57.350]                         if (!has_future || version < "1.8.0") {
[17:39:57.350]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.350]                             "", base::R.version$version.string), 
[17:39:57.350]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.350]                               "release", "version")], collapse = " "), 
[17:39:57.350]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.350]                             info)
[17:39:57.350]                           info <- base::paste(info, collapse = "; ")
[17:39:57.350]                           if (!has_future) {
[17:39:57.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.350]                               info)
[17:39:57.350]                           }
[17:39:57.350]                           else {
[17:39:57.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.350]                               info, version)
[17:39:57.350]                           }
[17:39:57.350]                           base::stop(msg)
[17:39:57.350]                         }
[17:39:57.350]                       })
[17:39:57.350]                     }
[17:39:57.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.350]                     base::options(mc.cores = 1L)
[17:39:57.350]                   }
[17:39:57.350]                   ...future.strategy.old <- future::plan("list")
[17:39:57.350]                   options(future.plan = NULL)
[17:39:57.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.350]                 }
[17:39:57.350]                 ...future.workdir <- getwd()
[17:39:57.350]             }
[17:39:57.350]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.350]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.350]         }
[17:39:57.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.350]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.350]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.350]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.350]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.350]             base::names(...future.oldOptions))
[17:39:57.350]     }
[17:39:57.350]     if (FALSE) {
[17:39:57.350]     }
[17:39:57.350]     else {
[17:39:57.350]         if (TRUE) {
[17:39:57.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.350]                 open = "w")
[17:39:57.350]         }
[17:39:57.350]         else {
[17:39:57.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.350]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.350]         }
[17:39:57.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.350]             base::sink(type = "output", split = FALSE)
[17:39:57.350]             base::close(...future.stdout)
[17:39:57.350]         }, add = TRUE)
[17:39:57.350]     }
[17:39:57.350]     ...future.frame <- base::sys.nframe()
[17:39:57.350]     ...future.conditions <- base::list()
[17:39:57.350]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.350]     if (FALSE) {
[17:39:57.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.350]     }
[17:39:57.350]     ...future.result <- base::tryCatch({
[17:39:57.350]         base::withCallingHandlers({
[17:39:57.350]             ...future.value <- base::withVisible(base::local({
[17:39:57.350]                 withCallingHandlers({
[17:39:57.350]                   {
[17:39:57.350]                     x <- 0
[17:39:57.350]                     x <- x + 1
[17:39:57.350]                     x
[17:39:57.350]                   }
[17:39:57.350]                 }, immediateCondition = function(cond) {
[17:39:57.350]                   save_rds <- function (object, pathname, ...) 
[17:39:57.350]                   {
[17:39:57.350]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.350]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.350]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.350]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.350]                         fi_tmp[["mtime"]])
[17:39:57.350]                     }
[17:39:57.350]                     tryCatch({
[17:39:57.350]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.350]                     }, error = function(ex) {
[17:39:57.350]                       msg <- conditionMessage(ex)
[17:39:57.350]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.350]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.350]                         fi_tmp[["mtime"]], msg)
[17:39:57.350]                       ex$message <- msg
[17:39:57.350]                       stop(ex)
[17:39:57.350]                     })
[17:39:57.350]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.350]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.350]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.350]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.350]                       fi <- file.info(pathname)
[17:39:57.350]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.350]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.350]                         fi[["size"]], fi[["mtime"]])
[17:39:57.350]                       stop(msg)
[17:39:57.350]                     }
[17:39:57.350]                     invisible(pathname)
[17:39:57.350]                   }
[17:39:57.350]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.350]                     rootPath = tempdir()) 
[17:39:57.350]                   {
[17:39:57.350]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.350]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.350]                       tmpdir = path, fileext = ".rds")
[17:39:57.350]                     save_rds(obj, file)
[17:39:57.350]                   }
[17:39:57.350]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.350]                   {
[17:39:57.350]                     inherits <- base::inherits
[17:39:57.350]                     invokeRestart <- base::invokeRestart
[17:39:57.350]                     is.null <- base::is.null
[17:39:57.350]                     muffled <- FALSE
[17:39:57.350]                     if (inherits(cond, "message")) {
[17:39:57.350]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.350]                       if (muffled) 
[17:39:57.350]                         invokeRestart("muffleMessage")
[17:39:57.350]                     }
[17:39:57.350]                     else if (inherits(cond, "warning")) {
[17:39:57.350]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.350]                       if (muffled) 
[17:39:57.350]                         invokeRestart("muffleWarning")
[17:39:57.350]                     }
[17:39:57.350]                     else if (inherits(cond, "condition")) {
[17:39:57.350]                       if (!is.null(pattern)) {
[17:39:57.350]                         computeRestarts <- base::computeRestarts
[17:39:57.350]                         grepl <- base::grepl
[17:39:57.350]                         restarts <- computeRestarts(cond)
[17:39:57.350]                         for (restart in restarts) {
[17:39:57.350]                           name <- restart$name
[17:39:57.350]                           if (is.null(name)) 
[17:39:57.350]                             next
[17:39:57.350]                           if (!grepl(pattern, name)) 
[17:39:57.350]                             next
[17:39:57.350]                           invokeRestart(restart)
[17:39:57.350]                           muffled <- TRUE
[17:39:57.350]                           break
[17:39:57.350]                         }
[17:39:57.350]                       }
[17:39:57.350]                     }
[17:39:57.350]                     invisible(muffled)
[17:39:57.350]                   }
[17:39:57.350]                   muffleCondition(cond)
[17:39:57.350]                 })
[17:39:57.350]             }))
[17:39:57.350]             future::FutureResult(value = ...future.value$value, 
[17:39:57.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.350]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.350]                     ...future.globalenv.names))
[17:39:57.350]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.350]         }, condition = base::local({
[17:39:57.350]             c <- base::c
[17:39:57.350]             inherits <- base::inherits
[17:39:57.350]             invokeRestart <- base::invokeRestart
[17:39:57.350]             length <- base::length
[17:39:57.350]             list <- base::list
[17:39:57.350]             seq.int <- base::seq.int
[17:39:57.350]             signalCondition <- base::signalCondition
[17:39:57.350]             sys.calls <- base::sys.calls
[17:39:57.350]             `[[` <- base::`[[`
[17:39:57.350]             `+` <- base::`+`
[17:39:57.350]             `<<-` <- base::`<<-`
[17:39:57.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.350]                   3L)]
[17:39:57.350]             }
[17:39:57.350]             function(cond) {
[17:39:57.350]                 is_error <- inherits(cond, "error")
[17:39:57.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.350]                   NULL)
[17:39:57.350]                 if (is_error) {
[17:39:57.350]                   sessionInformation <- function() {
[17:39:57.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.350]                       search = base::search(), system = base::Sys.info())
[17:39:57.350]                   }
[17:39:57.350]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.350]                     cond$call), session = sessionInformation(), 
[17:39:57.350]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.350]                   signalCondition(cond)
[17:39:57.350]                 }
[17:39:57.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.350]                 "immediateCondition"))) {
[17:39:57.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.350]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.350]                   if (TRUE && !signal) {
[17:39:57.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.350]                     {
[17:39:57.350]                       inherits <- base::inherits
[17:39:57.350]                       invokeRestart <- base::invokeRestart
[17:39:57.350]                       is.null <- base::is.null
[17:39:57.350]                       muffled <- FALSE
[17:39:57.350]                       if (inherits(cond, "message")) {
[17:39:57.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.350]                         if (muffled) 
[17:39:57.350]                           invokeRestart("muffleMessage")
[17:39:57.350]                       }
[17:39:57.350]                       else if (inherits(cond, "warning")) {
[17:39:57.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.350]                         if (muffled) 
[17:39:57.350]                           invokeRestart("muffleWarning")
[17:39:57.350]                       }
[17:39:57.350]                       else if (inherits(cond, "condition")) {
[17:39:57.350]                         if (!is.null(pattern)) {
[17:39:57.350]                           computeRestarts <- base::computeRestarts
[17:39:57.350]                           grepl <- base::grepl
[17:39:57.350]                           restarts <- computeRestarts(cond)
[17:39:57.350]                           for (restart in restarts) {
[17:39:57.350]                             name <- restart$name
[17:39:57.350]                             if (is.null(name)) 
[17:39:57.350]                               next
[17:39:57.350]                             if (!grepl(pattern, name)) 
[17:39:57.350]                               next
[17:39:57.350]                             invokeRestart(restart)
[17:39:57.350]                             muffled <- TRUE
[17:39:57.350]                             break
[17:39:57.350]                           }
[17:39:57.350]                         }
[17:39:57.350]                       }
[17:39:57.350]                       invisible(muffled)
[17:39:57.350]                     }
[17:39:57.350]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.350]                   }
[17:39:57.350]                 }
[17:39:57.350]                 else {
[17:39:57.350]                   if (TRUE) {
[17:39:57.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.350]                     {
[17:39:57.350]                       inherits <- base::inherits
[17:39:57.350]                       invokeRestart <- base::invokeRestart
[17:39:57.350]                       is.null <- base::is.null
[17:39:57.350]                       muffled <- FALSE
[17:39:57.350]                       if (inherits(cond, "message")) {
[17:39:57.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.350]                         if (muffled) 
[17:39:57.350]                           invokeRestart("muffleMessage")
[17:39:57.350]                       }
[17:39:57.350]                       else if (inherits(cond, "warning")) {
[17:39:57.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.350]                         if (muffled) 
[17:39:57.350]                           invokeRestart("muffleWarning")
[17:39:57.350]                       }
[17:39:57.350]                       else if (inherits(cond, "condition")) {
[17:39:57.350]                         if (!is.null(pattern)) {
[17:39:57.350]                           computeRestarts <- base::computeRestarts
[17:39:57.350]                           grepl <- base::grepl
[17:39:57.350]                           restarts <- computeRestarts(cond)
[17:39:57.350]                           for (restart in restarts) {
[17:39:57.350]                             name <- restart$name
[17:39:57.350]                             if (is.null(name)) 
[17:39:57.350]                               next
[17:39:57.350]                             if (!grepl(pattern, name)) 
[17:39:57.350]                               next
[17:39:57.350]                             invokeRestart(restart)
[17:39:57.350]                             muffled <- TRUE
[17:39:57.350]                             break
[17:39:57.350]                           }
[17:39:57.350]                         }
[17:39:57.350]                       }
[17:39:57.350]                       invisible(muffled)
[17:39:57.350]                     }
[17:39:57.350]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.350]                   }
[17:39:57.350]                 }
[17:39:57.350]             }
[17:39:57.350]         }))
[17:39:57.350]     }, error = function(ex) {
[17:39:57.350]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.350]                 ...future.rng), started = ...future.startTime, 
[17:39:57.350]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.350]             version = "1.8"), class = "FutureResult")
[17:39:57.350]     }, finally = {
[17:39:57.350]         if (!identical(...future.workdir, getwd())) 
[17:39:57.350]             setwd(...future.workdir)
[17:39:57.350]         {
[17:39:57.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.350]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.350]             }
[17:39:57.350]             base::options(...future.oldOptions)
[17:39:57.350]             if (.Platform$OS.type == "windows") {
[17:39:57.350]                 old_names <- names(...future.oldEnvVars)
[17:39:57.350]                 envs <- base::Sys.getenv()
[17:39:57.350]                 names <- names(envs)
[17:39:57.350]                 common <- intersect(names, old_names)
[17:39:57.350]                 added <- setdiff(names, old_names)
[17:39:57.350]                 removed <- setdiff(old_names, names)
[17:39:57.350]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.350]                   envs[common]]
[17:39:57.350]                 NAMES <- toupper(changed)
[17:39:57.350]                 args <- list()
[17:39:57.350]                 for (kk in seq_along(NAMES)) {
[17:39:57.350]                   name <- changed[[kk]]
[17:39:57.350]                   NAME <- NAMES[[kk]]
[17:39:57.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.350]                     next
[17:39:57.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.350]                 }
[17:39:57.350]                 NAMES <- toupper(added)
[17:39:57.350]                 for (kk in seq_along(NAMES)) {
[17:39:57.350]                   name <- added[[kk]]
[17:39:57.350]                   NAME <- NAMES[[kk]]
[17:39:57.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.350]                     next
[17:39:57.350]                   args[[name]] <- ""
[17:39:57.350]                 }
[17:39:57.350]                 NAMES <- toupper(removed)
[17:39:57.350]                 for (kk in seq_along(NAMES)) {
[17:39:57.350]                   name <- removed[[kk]]
[17:39:57.350]                   NAME <- NAMES[[kk]]
[17:39:57.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.350]                     next
[17:39:57.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.350]                 }
[17:39:57.350]                 if (length(args) > 0) 
[17:39:57.350]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.350]             }
[17:39:57.350]             else {
[17:39:57.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.350]             }
[17:39:57.350]             {
[17:39:57.350]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.350]                   0L) {
[17:39:57.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.350]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.350]                   base::options(opts)
[17:39:57.350]                 }
[17:39:57.350]                 {
[17:39:57.350]                   {
[17:39:57.350]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.350]                     NULL
[17:39:57.350]                   }
[17:39:57.350]                   options(future.plan = NULL)
[17:39:57.350]                   if (is.na(NA_character_)) 
[17:39:57.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.350]                     .init = FALSE)
[17:39:57.350]                 }
[17:39:57.350]             }
[17:39:57.350]         }
[17:39:57.350]     })
[17:39:57.350]     if (TRUE) {
[17:39:57.350]         base::sink(type = "output", split = FALSE)
[17:39:57.350]         if (TRUE) {
[17:39:57.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.350]         }
[17:39:57.350]         else {
[17:39:57.350]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.350]         }
[17:39:57.350]         base::close(...future.stdout)
[17:39:57.350]         ...future.stdout <- NULL
[17:39:57.350]     }
[17:39:57.350]     ...future.result$conditions <- ...future.conditions
[17:39:57.350]     ...future.result$finished <- base::Sys.time()
[17:39:57.350]     ...future.result
[17:39:57.350] }
[17:39:57.352] requestCore(): workers = 2
[17:39:57.354] MulticoreFuture started
[17:39:57.354] - Launch lazy future ... done
[17:39:57.354] run() for ‘MulticoreFuture’ ... done
[17:39:57.355] result() for MulticoreFuture ...
[17:39:57.355] plan(): Setting new future strategy stack:
[17:39:57.355] List of future strategies:
[17:39:57.355] 1. sequential:
[17:39:57.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.355]    - tweaked: FALSE
[17:39:57.355]    - call: NULL
[17:39:57.356] plan(): nbrOfWorkers() = 1
[17:39:57.358] plan(): Setting new future strategy stack:
[17:39:57.363] List of future strategies:
[17:39:57.363] 1. multicore:
[17:39:57.363]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.363]    - tweaked: FALSE
[17:39:57.363]    - call: plan(strategy)
[17:39:57.368] plan(): nbrOfWorkers() = 2
[17:39:57.369] result() for MulticoreFuture ...
[17:39:57.369] result() for MulticoreFuture ... done
[17:39:57.370] result() for MulticoreFuture ... done
[17:39:57.370] result() for MulticoreFuture ...
[17:39:57.370] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.373] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.373] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.376] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:39:57.376] Searching for globals ... DONE
[17:39:57.376] Resolving globals: TRUE
[17:39:57.376] Resolving any globals that are futures ...
[17:39:57.376] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:39:57.376] Resolving any globals that are futures ... DONE
[17:39:57.377] Resolving futures part of globals (recursively) ...
[17:39:57.377] resolve() on list ...
[17:39:57.377]  recursive: 99
[17:39:57.377]  length: 1
[17:39:57.378]  elements: ‘x’
[17:39:57.378]  length: 0 (resolved future 1)
[17:39:57.378] resolve() on list ... DONE
[17:39:57.378] - globals: [1] ‘x’
[17:39:57.378] Resolving futures part of globals (recursively) ... DONE
[17:39:57.379] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:57.379] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:39:57.379] - globals: [1] ‘x’
[17:39:57.379] 
[17:39:57.380] getGlobalsAndPackages() ... DONE
[17:39:57.380] run() for ‘Future’ ...
[17:39:57.380] - state: ‘created’
[17:39:57.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.384] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.385]   - Field: ‘label’
[17:39:57.385]   - Field: ‘local’
[17:39:57.385]   - Field: ‘owner’
[17:39:57.385]   - Field: ‘envir’
[17:39:57.385]   - Field: ‘workers’
[17:39:57.385]   - Field: ‘packages’
[17:39:57.385]   - Field: ‘gc’
[17:39:57.386]   - Field: ‘job’
[17:39:57.386]   - Field: ‘conditions’
[17:39:57.386]   - Field: ‘expr’
[17:39:57.386]   - Field: ‘uuid’
[17:39:57.386]   - Field: ‘seed’
[17:39:57.386]   - Field: ‘version’
[17:39:57.386]   - Field: ‘result’
[17:39:57.386]   - Field: ‘asynchronous’
[17:39:57.386]   - Field: ‘calls’
[17:39:57.387]   - Field: ‘globals’
[17:39:57.387]   - Field: ‘stdout’
[17:39:57.387]   - Field: ‘earlySignal’
[17:39:57.387]   - Field: ‘lazy’
[17:39:57.387]   - Field: ‘state’
[17:39:57.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.387] - Launch lazy future ...
[17:39:57.388] Packages needed by the future expression (n = 0): <none>
[17:39:57.388] Packages needed by future strategies (n = 0): <none>
[17:39:57.388] {
[17:39:57.388]     {
[17:39:57.388]         {
[17:39:57.388]             ...future.startTime <- base::Sys.time()
[17:39:57.388]             {
[17:39:57.388]                 {
[17:39:57.388]                   {
[17:39:57.388]                     {
[17:39:57.388]                       base::local({
[17:39:57.388]                         has_future <- base::requireNamespace("future", 
[17:39:57.388]                           quietly = TRUE)
[17:39:57.388]                         if (has_future) {
[17:39:57.388]                           ns <- base::getNamespace("future")
[17:39:57.388]                           version <- ns[[".package"]][["version"]]
[17:39:57.388]                           if (is.null(version)) 
[17:39:57.388]                             version <- utils::packageVersion("future")
[17:39:57.388]                         }
[17:39:57.388]                         else {
[17:39:57.388]                           version <- NULL
[17:39:57.388]                         }
[17:39:57.388]                         if (!has_future || version < "1.8.0") {
[17:39:57.388]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.388]                             "", base::R.version$version.string), 
[17:39:57.388]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.388]                               "release", "version")], collapse = " "), 
[17:39:57.388]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.388]                             info)
[17:39:57.388]                           info <- base::paste(info, collapse = "; ")
[17:39:57.388]                           if (!has_future) {
[17:39:57.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.388]                               info)
[17:39:57.388]                           }
[17:39:57.388]                           else {
[17:39:57.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.388]                               info, version)
[17:39:57.388]                           }
[17:39:57.388]                           base::stop(msg)
[17:39:57.388]                         }
[17:39:57.388]                       })
[17:39:57.388]                     }
[17:39:57.388]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.388]                     base::options(mc.cores = 1L)
[17:39:57.388]                   }
[17:39:57.388]                   ...future.strategy.old <- future::plan("list")
[17:39:57.388]                   options(future.plan = NULL)
[17:39:57.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.388]                 }
[17:39:57.388]                 ...future.workdir <- getwd()
[17:39:57.388]             }
[17:39:57.388]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.388]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.388]         }
[17:39:57.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.388]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.388]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.388]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.388]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.388]             base::names(...future.oldOptions))
[17:39:57.388]     }
[17:39:57.388]     if (FALSE) {
[17:39:57.388]     }
[17:39:57.388]     else {
[17:39:57.388]         if (TRUE) {
[17:39:57.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.388]                 open = "w")
[17:39:57.388]         }
[17:39:57.388]         else {
[17:39:57.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.388]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.388]         }
[17:39:57.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.388]             base::sink(type = "output", split = FALSE)
[17:39:57.388]             base::close(...future.stdout)
[17:39:57.388]         }, add = TRUE)
[17:39:57.388]     }
[17:39:57.388]     ...future.frame <- base::sys.nframe()
[17:39:57.388]     ...future.conditions <- base::list()
[17:39:57.388]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.388]     if (FALSE) {
[17:39:57.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.388]     }
[17:39:57.388]     ...future.result <- base::tryCatch({
[17:39:57.388]         base::withCallingHandlers({
[17:39:57.388]             ...future.value <- base::withVisible(base::local({
[17:39:57.388]                 withCallingHandlers({
[17:39:57.388]                   {
[17:39:57.388]                     x <- x + 1
[17:39:57.388]                     x
[17:39:57.388]                   }
[17:39:57.388]                 }, immediateCondition = function(cond) {
[17:39:57.388]                   save_rds <- function (object, pathname, ...) 
[17:39:57.388]                   {
[17:39:57.388]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.388]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.388]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.388]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.388]                         fi_tmp[["mtime"]])
[17:39:57.388]                     }
[17:39:57.388]                     tryCatch({
[17:39:57.388]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.388]                     }, error = function(ex) {
[17:39:57.388]                       msg <- conditionMessage(ex)
[17:39:57.388]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.388]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.388]                         fi_tmp[["mtime"]], msg)
[17:39:57.388]                       ex$message <- msg
[17:39:57.388]                       stop(ex)
[17:39:57.388]                     })
[17:39:57.388]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.388]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.388]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.388]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.388]                       fi <- file.info(pathname)
[17:39:57.388]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.388]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.388]                         fi[["size"]], fi[["mtime"]])
[17:39:57.388]                       stop(msg)
[17:39:57.388]                     }
[17:39:57.388]                     invisible(pathname)
[17:39:57.388]                   }
[17:39:57.388]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.388]                     rootPath = tempdir()) 
[17:39:57.388]                   {
[17:39:57.388]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.388]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.388]                       tmpdir = path, fileext = ".rds")
[17:39:57.388]                     save_rds(obj, file)
[17:39:57.388]                   }
[17:39:57.388]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.388]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.388]                   {
[17:39:57.388]                     inherits <- base::inherits
[17:39:57.388]                     invokeRestart <- base::invokeRestart
[17:39:57.388]                     is.null <- base::is.null
[17:39:57.388]                     muffled <- FALSE
[17:39:57.388]                     if (inherits(cond, "message")) {
[17:39:57.388]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.388]                       if (muffled) 
[17:39:57.388]                         invokeRestart("muffleMessage")
[17:39:57.388]                     }
[17:39:57.388]                     else if (inherits(cond, "warning")) {
[17:39:57.388]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.388]                       if (muffled) 
[17:39:57.388]                         invokeRestart("muffleWarning")
[17:39:57.388]                     }
[17:39:57.388]                     else if (inherits(cond, "condition")) {
[17:39:57.388]                       if (!is.null(pattern)) {
[17:39:57.388]                         computeRestarts <- base::computeRestarts
[17:39:57.388]                         grepl <- base::grepl
[17:39:57.388]                         restarts <- computeRestarts(cond)
[17:39:57.388]                         for (restart in restarts) {
[17:39:57.388]                           name <- restart$name
[17:39:57.388]                           if (is.null(name)) 
[17:39:57.388]                             next
[17:39:57.388]                           if (!grepl(pattern, name)) 
[17:39:57.388]                             next
[17:39:57.388]                           invokeRestart(restart)
[17:39:57.388]                           muffled <- TRUE
[17:39:57.388]                           break
[17:39:57.388]                         }
[17:39:57.388]                       }
[17:39:57.388]                     }
[17:39:57.388]                     invisible(muffled)
[17:39:57.388]                   }
[17:39:57.388]                   muffleCondition(cond)
[17:39:57.388]                 })
[17:39:57.388]             }))
[17:39:57.388]             future::FutureResult(value = ...future.value$value, 
[17:39:57.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.388]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.388]                     ...future.globalenv.names))
[17:39:57.388]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.388]         }, condition = base::local({
[17:39:57.388]             c <- base::c
[17:39:57.388]             inherits <- base::inherits
[17:39:57.388]             invokeRestart <- base::invokeRestart
[17:39:57.388]             length <- base::length
[17:39:57.388]             list <- base::list
[17:39:57.388]             seq.int <- base::seq.int
[17:39:57.388]             signalCondition <- base::signalCondition
[17:39:57.388]             sys.calls <- base::sys.calls
[17:39:57.388]             `[[` <- base::`[[`
[17:39:57.388]             `+` <- base::`+`
[17:39:57.388]             `<<-` <- base::`<<-`
[17:39:57.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.388]                   3L)]
[17:39:57.388]             }
[17:39:57.388]             function(cond) {
[17:39:57.388]                 is_error <- inherits(cond, "error")
[17:39:57.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.388]                   NULL)
[17:39:57.388]                 if (is_error) {
[17:39:57.388]                   sessionInformation <- function() {
[17:39:57.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.388]                       search = base::search(), system = base::Sys.info())
[17:39:57.388]                   }
[17:39:57.388]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.388]                     cond$call), session = sessionInformation(), 
[17:39:57.388]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.388]                   signalCondition(cond)
[17:39:57.388]                 }
[17:39:57.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.388]                 "immediateCondition"))) {
[17:39:57.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.388]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.388]                   if (TRUE && !signal) {
[17:39:57.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.388]                     {
[17:39:57.388]                       inherits <- base::inherits
[17:39:57.388]                       invokeRestart <- base::invokeRestart
[17:39:57.388]                       is.null <- base::is.null
[17:39:57.388]                       muffled <- FALSE
[17:39:57.388]                       if (inherits(cond, "message")) {
[17:39:57.388]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.388]                         if (muffled) 
[17:39:57.388]                           invokeRestart("muffleMessage")
[17:39:57.388]                       }
[17:39:57.388]                       else if (inherits(cond, "warning")) {
[17:39:57.388]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.388]                         if (muffled) 
[17:39:57.388]                           invokeRestart("muffleWarning")
[17:39:57.388]                       }
[17:39:57.388]                       else if (inherits(cond, "condition")) {
[17:39:57.388]                         if (!is.null(pattern)) {
[17:39:57.388]                           computeRestarts <- base::computeRestarts
[17:39:57.388]                           grepl <- base::grepl
[17:39:57.388]                           restarts <- computeRestarts(cond)
[17:39:57.388]                           for (restart in restarts) {
[17:39:57.388]                             name <- restart$name
[17:39:57.388]                             if (is.null(name)) 
[17:39:57.388]                               next
[17:39:57.388]                             if (!grepl(pattern, name)) 
[17:39:57.388]                               next
[17:39:57.388]                             invokeRestart(restart)
[17:39:57.388]                             muffled <- TRUE
[17:39:57.388]                             break
[17:39:57.388]                           }
[17:39:57.388]                         }
[17:39:57.388]                       }
[17:39:57.388]                       invisible(muffled)
[17:39:57.388]                     }
[17:39:57.388]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.388]                   }
[17:39:57.388]                 }
[17:39:57.388]                 else {
[17:39:57.388]                   if (TRUE) {
[17:39:57.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.388]                     {
[17:39:57.388]                       inherits <- base::inherits
[17:39:57.388]                       invokeRestart <- base::invokeRestart
[17:39:57.388]                       is.null <- base::is.null
[17:39:57.388]                       muffled <- FALSE
[17:39:57.388]                       if (inherits(cond, "message")) {
[17:39:57.388]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.388]                         if (muffled) 
[17:39:57.388]                           invokeRestart("muffleMessage")
[17:39:57.388]                       }
[17:39:57.388]                       else if (inherits(cond, "warning")) {
[17:39:57.388]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.388]                         if (muffled) 
[17:39:57.388]                           invokeRestart("muffleWarning")
[17:39:57.388]                       }
[17:39:57.388]                       else if (inherits(cond, "condition")) {
[17:39:57.388]                         if (!is.null(pattern)) {
[17:39:57.388]                           computeRestarts <- base::computeRestarts
[17:39:57.388]                           grepl <- base::grepl
[17:39:57.388]                           restarts <- computeRestarts(cond)
[17:39:57.388]                           for (restart in restarts) {
[17:39:57.388]                             name <- restart$name
[17:39:57.388]                             if (is.null(name)) 
[17:39:57.388]                               next
[17:39:57.388]                             if (!grepl(pattern, name)) 
[17:39:57.388]                               next
[17:39:57.388]                             invokeRestart(restart)
[17:39:57.388]                             muffled <- TRUE
[17:39:57.388]                             break
[17:39:57.388]                           }
[17:39:57.388]                         }
[17:39:57.388]                       }
[17:39:57.388]                       invisible(muffled)
[17:39:57.388]                     }
[17:39:57.388]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.388]                   }
[17:39:57.388]                 }
[17:39:57.388]             }
[17:39:57.388]         }))
[17:39:57.388]     }, error = function(ex) {
[17:39:57.388]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.388]                 ...future.rng), started = ...future.startTime, 
[17:39:57.388]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.388]             version = "1.8"), class = "FutureResult")
[17:39:57.388]     }, finally = {
[17:39:57.388]         if (!identical(...future.workdir, getwd())) 
[17:39:57.388]             setwd(...future.workdir)
[17:39:57.388]         {
[17:39:57.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.388]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.388]             }
[17:39:57.388]             base::options(...future.oldOptions)
[17:39:57.388]             if (.Platform$OS.type == "windows") {
[17:39:57.388]                 old_names <- names(...future.oldEnvVars)
[17:39:57.388]                 envs <- base::Sys.getenv()
[17:39:57.388]                 names <- names(envs)
[17:39:57.388]                 common <- intersect(names, old_names)
[17:39:57.388]                 added <- setdiff(names, old_names)
[17:39:57.388]                 removed <- setdiff(old_names, names)
[17:39:57.388]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.388]                   envs[common]]
[17:39:57.388]                 NAMES <- toupper(changed)
[17:39:57.388]                 args <- list()
[17:39:57.388]                 for (kk in seq_along(NAMES)) {
[17:39:57.388]                   name <- changed[[kk]]
[17:39:57.388]                   NAME <- NAMES[[kk]]
[17:39:57.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.388]                     next
[17:39:57.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.388]                 }
[17:39:57.388]                 NAMES <- toupper(added)
[17:39:57.388]                 for (kk in seq_along(NAMES)) {
[17:39:57.388]                   name <- added[[kk]]
[17:39:57.388]                   NAME <- NAMES[[kk]]
[17:39:57.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.388]                     next
[17:39:57.388]                   args[[name]] <- ""
[17:39:57.388]                 }
[17:39:57.388]                 NAMES <- toupper(removed)
[17:39:57.388]                 for (kk in seq_along(NAMES)) {
[17:39:57.388]                   name <- removed[[kk]]
[17:39:57.388]                   NAME <- NAMES[[kk]]
[17:39:57.388]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.388]                     next
[17:39:57.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.388]                 }
[17:39:57.388]                 if (length(args) > 0) 
[17:39:57.388]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.388]             }
[17:39:57.388]             else {
[17:39:57.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.388]             }
[17:39:57.388]             {
[17:39:57.388]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.388]                   0L) {
[17:39:57.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.388]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.388]                   base::options(opts)
[17:39:57.388]                 }
[17:39:57.388]                 {
[17:39:57.388]                   {
[17:39:57.388]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.388]                     NULL
[17:39:57.388]                   }
[17:39:57.388]                   options(future.plan = NULL)
[17:39:57.388]                   if (is.na(NA_character_)) 
[17:39:57.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.388]                     .init = FALSE)
[17:39:57.388]                 }
[17:39:57.388]             }
[17:39:57.388]         }
[17:39:57.388]     })
[17:39:57.388]     if (TRUE) {
[17:39:57.388]         base::sink(type = "output", split = FALSE)
[17:39:57.388]         if (TRUE) {
[17:39:57.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.388]         }
[17:39:57.388]         else {
[17:39:57.388]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.388]         }
[17:39:57.388]         base::close(...future.stdout)
[17:39:57.388]         ...future.stdout <- NULL
[17:39:57.388]     }
[17:39:57.388]     ...future.result$conditions <- ...future.conditions
[17:39:57.388]     ...future.result$finished <- base::Sys.time()
[17:39:57.388]     ...future.result
[17:39:57.388] }
[17:39:57.390] assign_globals() ...
[17:39:57.391] List of 1
[17:39:57.391]  $ x: num 1
[17:39:57.391]  - attr(*, "where")=List of 1
[17:39:57.391]   ..$ x:<environment: R_EmptyEnv> 
[17:39:57.391]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.391]  - attr(*, "resolved")= logi TRUE
[17:39:57.391]  - attr(*, "total_size")= num 56
[17:39:57.391]  - attr(*, "already-done")= logi TRUE
[17:39:57.393] - copied ‘x’ to environment
[17:39:57.393] assign_globals() ... done
[17:39:57.394] requestCore(): workers = 2
[17:39:57.395] MulticoreFuture started
[17:39:57.396] - Launch lazy future ... done
[17:39:57.396] run() for ‘MulticoreFuture’ ... done
[17:39:57.396] result() for MulticoreFuture ...
[17:39:57.396] plan(): Setting new future strategy stack:
[17:39:57.397] List of future strategies:
[17:39:57.397] 1. sequential:
[17:39:57.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.397]    - tweaked: FALSE
[17:39:57.397]    - call: NULL
[17:39:57.398] plan(): nbrOfWorkers() = 1
[17:39:57.400] plan(): Setting new future strategy stack:
[17:39:57.400] List of future strategies:
[17:39:57.400] 1. multicore:
[17:39:57.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.400]    - tweaked: FALSE
[17:39:57.400]    - call: plan(strategy)
[17:39:57.406] plan(): nbrOfWorkers() = 2
[17:39:57.407] result() for MulticoreFuture ...
[17:39:57.407] result() for MulticoreFuture ... done
[17:39:57.407] result() for MulticoreFuture ... done
[17:39:57.407] result() for MulticoreFuture ...
[17:39:57.407] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.408] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.408] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:57.411] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:39:57.411] Searching for globals ... DONE
[17:39:57.411] Resolving globals: TRUE
[17:39:57.411] Resolving any globals that are futures ...
[17:39:57.411] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:39:57.411] Resolving any globals that are futures ... DONE
[17:39:57.412] Resolving futures part of globals (recursively) ...
[17:39:57.412] resolve() on list ...
[17:39:57.412]  recursive: 99
[17:39:57.412]  length: 1
[17:39:57.412]  elements: ‘x’
[17:39:57.413]  length: 0 (resolved future 1)
[17:39:57.413] resolve() on list ... DONE
[17:39:57.413] - globals: [1] ‘x’
[17:39:57.413] Resolving futures part of globals (recursively) ... DONE
[17:39:57.413] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:39:57.414] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:39:57.414] - globals: [1] ‘x’
[17:39:57.414] 
[17:39:57.414] getGlobalsAndPackages() ... DONE
[17:39:57.414] run() for ‘Future’ ...
[17:39:57.415] - state: ‘created’
[17:39:57.415] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:57.419] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:57.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:57.419]   - Field: ‘label’
[17:39:57.419]   - Field: ‘local’
[17:39:57.420]   - Field: ‘owner’
[17:39:57.420]   - Field: ‘envir’
[17:39:57.420]   - Field: ‘workers’
[17:39:57.420]   - Field: ‘packages’
[17:39:57.420]   - Field: ‘gc’
[17:39:57.420]   - Field: ‘job’
[17:39:57.420]   - Field: ‘conditions’
[17:39:57.421]   - Field: ‘expr’
[17:39:57.421]   - Field: ‘uuid’
[17:39:57.421]   - Field: ‘seed’
[17:39:57.421]   - Field: ‘version’
[17:39:57.421]   - Field: ‘result’
[17:39:57.421]   - Field: ‘asynchronous’
[17:39:57.421]   - Field: ‘calls’
[17:39:57.421]   - Field: ‘globals’
[17:39:57.424]   - Field: ‘stdout’
[17:39:57.424]   - Field: ‘earlySignal’
[17:39:57.424]   - Field: ‘lazy’
[17:39:57.424]   - Field: ‘state’
[17:39:57.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:57.425] - Launch lazy future ...
[17:39:57.425] Packages needed by the future expression (n = 0): <none>
[17:39:57.425] Packages needed by future strategies (n = 0): <none>
[17:39:57.426] {
[17:39:57.426]     {
[17:39:57.426]         {
[17:39:57.426]             ...future.startTime <- base::Sys.time()
[17:39:57.426]             {
[17:39:57.426]                 {
[17:39:57.426]                   {
[17:39:57.426]                     {
[17:39:57.426]                       base::local({
[17:39:57.426]                         has_future <- base::requireNamespace("future", 
[17:39:57.426]                           quietly = TRUE)
[17:39:57.426]                         if (has_future) {
[17:39:57.426]                           ns <- base::getNamespace("future")
[17:39:57.426]                           version <- ns[[".package"]][["version"]]
[17:39:57.426]                           if (is.null(version)) 
[17:39:57.426]                             version <- utils::packageVersion("future")
[17:39:57.426]                         }
[17:39:57.426]                         else {
[17:39:57.426]                           version <- NULL
[17:39:57.426]                         }
[17:39:57.426]                         if (!has_future || version < "1.8.0") {
[17:39:57.426]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.426]                             "", base::R.version$version.string), 
[17:39:57.426]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.426]                               "release", "version")], collapse = " "), 
[17:39:57.426]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.426]                             info)
[17:39:57.426]                           info <- base::paste(info, collapse = "; ")
[17:39:57.426]                           if (!has_future) {
[17:39:57.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.426]                               info)
[17:39:57.426]                           }
[17:39:57.426]                           else {
[17:39:57.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.426]                               info, version)
[17:39:57.426]                           }
[17:39:57.426]                           base::stop(msg)
[17:39:57.426]                         }
[17:39:57.426]                       })
[17:39:57.426]                     }
[17:39:57.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.426]                     base::options(mc.cores = 1L)
[17:39:57.426]                   }
[17:39:57.426]                   ...future.strategy.old <- future::plan("list")
[17:39:57.426]                   options(future.plan = NULL)
[17:39:57.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.426]                 }
[17:39:57.426]                 ...future.workdir <- getwd()
[17:39:57.426]             }
[17:39:57.426]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.426]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.426]         }
[17:39:57.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.426]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.426]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.426]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.426]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.426]             base::names(...future.oldOptions))
[17:39:57.426]     }
[17:39:57.426]     if (FALSE) {
[17:39:57.426]     }
[17:39:57.426]     else {
[17:39:57.426]         if (TRUE) {
[17:39:57.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.426]                 open = "w")
[17:39:57.426]         }
[17:39:57.426]         else {
[17:39:57.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.426]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.426]         }
[17:39:57.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.426]             base::sink(type = "output", split = FALSE)
[17:39:57.426]             base::close(...future.stdout)
[17:39:57.426]         }, add = TRUE)
[17:39:57.426]     }
[17:39:57.426]     ...future.frame <- base::sys.nframe()
[17:39:57.426]     ...future.conditions <- base::list()
[17:39:57.426]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.426]     if (FALSE) {
[17:39:57.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.426]     }
[17:39:57.426]     ...future.result <- base::tryCatch({
[17:39:57.426]         base::withCallingHandlers({
[17:39:57.426]             ...future.value <- base::withVisible(base::local({
[17:39:57.426]                 withCallingHandlers({
[17:39:57.426]                   {
[17:39:57.426]                     x <- x()
[17:39:57.426]                     x
[17:39:57.426]                   }
[17:39:57.426]                 }, immediateCondition = function(cond) {
[17:39:57.426]                   save_rds <- function (object, pathname, ...) 
[17:39:57.426]                   {
[17:39:57.426]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:57.426]                     if (file_test("-f", pathname_tmp)) {
[17:39:57.426]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.426]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:57.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.426]                         fi_tmp[["mtime"]])
[17:39:57.426]                     }
[17:39:57.426]                     tryCatch({
[17:39:57.426]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:57.426]                     }, error = function(ex) {
[17:39:57.426]                       msg <- conditionMessage(ex)
[17:39:57.426]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.426]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:57.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.426]                         fi_tmp[["mtime"]], msg)
[17:39:57.426]                       ex$message <- msg
[17:39:57.426]                       stop(ex)
[17:39:57.426]                     })
[17:39:57.426]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:57.426]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:57.426]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:57.426]                       fi_tmp <- file.info(pathname_tmp)
[17:39:57.426]                       fi <- file.info(pathname)
[17:39:57.426]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:57.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:57.426]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:57.426]                         fi[["size"]], fi[["mtime"]])
[17:39:57.426]                       stop(msg)
[17:39:57.426]                     }
[17:39:57.426]                     invisible(pathname)
[17:39:57.426]                   }
[17:39:57.426]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:57.426]                     rootPath = tempdir()) 
[17:39:57.426]                   {
[17:39:57.426]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:57.426]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:57.426]                       tmpdir = path, fileext = ".rds")
[17:39:57.426]                     save_rds(obj, file)
[17:39:57.426]                   }
[17:39:57.426]                   saveImmediateCondition(cond, path = "/tmp/Rtmph9UX4I/.future/immediateConditions")
[17:39:57.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.426]                   {
[17:39:57.426]                     inherits <- base::inherits
[17:39:57.426]                     invokeRestart <- base::invokeRestart
[17:39:57.426]                     is.null <- base::is.null
[17:39:57.426]                     muffled <- FALSE
[17:39:57.426]                     if (inherits(cond, "message")) {
[17:39:57.426]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.426]                       if (muffled) 
[17:39:57.426]                         invokeRestart("muffleMessage")
[17:39:57.426]                     }
[17:39:57.426]                     else if (inherits(cond, "warning")) {
[17:39:57.426]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.426]                       if (muffled) 
[17:39:57.426]                         invokeRestart("muffleWarning")
[17:39:57.426]                     }
[17:39:57.426]                     else if (inherits(cond, "condition")) {
[17:39:57.426]                       if (!is.null(pattern)) {
[17:39:57.426]                         computeRestarts <- base::computeRestarts
[17:39:57.426]                         grepl <- base::grepl
[17:39:57.426]                         restarts <- computeRestarts(cond)
[17:39:57.426]                         for (restart in restarts) {
[17:39:57.426]                           name <- restart$name
[17:39:57.426]                           if (is.null(name)) 
[17:39:57.426]                             next
[17:39:57.426]                           if (!grepl(pattern, name)) 
[17:39:57.426]                             next
[17:39:57.426]                           invokeRestart(restart)
[17:39:57.426]                           muffled <- TRUE
[17:39:57.426]                           break
[17:39:57.426]                         }
[17:39:57.426]                       }
[17:39:57.426]                     }
[17:39:57.426]                     invisible(muffled)
[17:39:57.426]                   }
[17:39:57.426]                   muffleCondition(cond)
[17:39:57.426]                 })
[17:39:57.426]             }))
[17:39:57.426]             future::FutureResult(value = ...future.value$value, 
[17:39:57.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.426]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.426]                     ...future.globalenv.names))
[17:39:57.426]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.426]         }, condition = base::local({
[17:39:57.426]             c <- base::c
[17:39:57.426]             inherits <- base::inherits
[17:39:57.426]             invokeRestart <- base::invokeRestart
[17:39:57.426]             length <- base::length
[17:39:57.426]             list <- base::list
[17:39:57.426]             seq.int <- base::seq.int
[17:39:57.426]             signalCondition <- base::signalCondition
[17:39:57.426]             sys.calls <- base::sys.calls
[17:39:57.426]             `[[` <- base::`[[`
[17:39:57.426]             `+` <- base::`+`
[17:39:57.426]             `<<-` <- base::`<<-`
[17:39:57.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.426]                   3L)]
[17:39:57.426]             }
[17:39:57.426]             function(cond) {
[17:39:57.426]                 is_error <- inherits(cond, "error")
[17:39:57.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.426]                   NULL)
[17:39:57.426]                 if (is_error) {
[17:39:57.426]                   sessionInformation <- function() {
[17:39:57.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.426]                       search = base::search(), system = base::Sys.info())
[17:39:57.426]                   }
[17:39:57.426]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.426]                     cond$call), session = sessionInformation(), 
[17:39:57.426]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.426]                   signalCondition(cond)
[17:39:57.426]                 }
[17:39:57.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.426]                 "immediateCondition"))) {
[17:39:57.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.426]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.426]                   if (TRUE && !signal) {
[17:39:57.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.426]                     {
[17:39:57.426]                       inherits <- base::inherits
[17:39:57.426]                       invokeRestart <- base::invokeRestart
[17:39:57.426]                       is.null <- base::is.null
[17:39:57.426]                       muffled <- FALSE
[17:39:57.426]                       if (inherits(cond, "message")) {
[17:39:57.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.426]                         if (muffled) 
[17:39:57.426]                           invokeRestart("muffleMessage")
[17:39:57.426]                       }
[17:39:57.426]                       else if (inherits(cond, "warning")) {
[17:39:57.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.426]                         if (muffled) 
[17:39:57.426]                           invokeRestart("muffleWarning")
[17:39:57.426]                       }
[17:39:57.426]                       else if (inherits(cond, "condition")) {
[17:39:57.426]                         if (!is.null(pattern)) {
[17:39:57.426]                           computeRestarts <- base::computeRestarts
[17:39:57.426]                           grepl <- base::grepl
[17:39:57.426]                           restarts <- computeRestarts(cond)
[17:39:57.426]                           for (restart in restarts) {
[17:39:57.426]                             name <- restart$name
[17:39:57.426]                             if (is.null(name)) 
[17:39:57.426]                               next
[17:39:57.426]                             if (!grepl(pattern, name)) 
[17:39:57.426]                               next
[17:39:57.426]                             invokeRestart(restart)
[17:39:57.426]                             muffled <- TRUE
[17:39:57.426]                             break
[17:39:57.426]                           }
[17:39:57.426]                         }
[17:39:57.426]                       }
[17:39:57.426]                       invisible(muffled)
[17:39:57.426]                     }
[17:39:57.426]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.426]                   }
[17:39:57.426]                 }
[17:39:57.426]                 else {
[17:39:57.426]                   if (TRUE) {
[17:39:57.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.426]                     {
[17:39:57.426]                       inherits <- base::inherits
[17:39:57.426]                       invokeRestart <- base::invokeRestart
[17:39:57.426]                       is.null <- base::is.null
[17:39:57.426]                       muffled <- FALSE
[17:39:57.426]                       if (inherits(cond, "message")) {
[17:39:57.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.426]                         if (muffled) 
[17:39:57.426]                           invokeRestart("muffleMessage")
[17:39:57.426]                       }
[17:39:57.426]                       else if (inherits(cond, "warning")) {
[17:39:57.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.426]                         if (muffled) 
[17:39:57.426]                           invokeRestart("muffleWarning")
[17:39:57.426]                       }
[17:39:57.426]                       else if (inherits(cond, "condition")) {
[17:39:57.426]                         if (!is.null(pattern)) {
[17:39:57.426]                           computeRestarts <- base::computeRestarts
[17:39:57.426]                           grepl <- base::grepl
[17:39:57.426]                           restarts <- computeRestarts(cond)
[17:39:57.426]                           for (restart in restarts) {
[17:39:57.426]                             name <- restart$name
[17:39:57.426]                             if (is.null(name)) 
[17:39:57.426]                               next
[17:39:57.426]                             if (!grepl(pattern, name)) 
[17:39:57.426]                               next
[17:39:57.426]                             invokeRestart(restart)
[17:39:57.426]                             muffled <- TRUE
[17:39:57.426]                             break
[17:39:57.426]                           }
[17:39:57.426]                         }
[17:39:57.426]                       }
[17:39:57.426]                       invisible(muffled)
[17:39:57.426]                     }
[17:39:57.426]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.426]                   }
[17:39:57.426]                 }
[17:39:57.426]             }
[17:39:57.426]         }))
[17:39:57.426]     }, error = function(ex) {
[17:39:57.426]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.426]                 ...future.rng), started = ...future.startTime, 
[17:39:57.426]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.426]             version = "1.8"), class = "FutureResult")
[17:39:57.426]     }, finally = {
[17:39:57.426]         if (!identical(...future.workdir, getwd())) 
[17:39:57.426]             setwd(...future.workdir)
[17:39:57.426]         {
[17:39:57.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.426]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.426]             }
[17:39:57.426]             base::options(...future.oldOptions)
[17:39:57.426]             if (.Platform$OS.type == "windows") {
[17:39:57.426]                 old_names <- names(...future.oldEnvVars)
[17:39:57.426]                 envs <- base::Sys.getenv()
[17:39:57.426]                 names <- names(envs)
[17:39:57.426]                 common <- intersect(names, old_names)
[17:39:57.426]                 added <- setdiff(names, old_names)
[17:39:57.426]                 removed <- setdiff(old_names, names)
[17:39:57.426]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.426]                   envs[common]]
[17:39:57.426]                 NAMES <- toupper(changed)
[17:39:57.426]                 args <- list()
[17:39:57.426]                 for (kk in seq_along(NAMES)) {
[17:39:57.426]                   name <- changed[[kk]]
[17:39:57.426]                   NAME <- NAMES[[kk]]
[17:39:57.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.426]                     next
[17:39:57.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.426]                 }
[17:39:57.426]                 NAMES <- toupper(added)
[17:39:57.426]                 for (kk in seq_along(NAMES)) {
[17:39:57.426]                   name <- added[[kk]]
[17:39:57.426]                   NAME <- NAMES[[kk]]
[17:39:57.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.426]                     next
[17:39:57.426]                   args[[name]] <- ""
[17:39:57.426]                 }
[17:39:57.426]                 NAMES <- toupper(removed)
[17:39:57.426]                 for (kk in seq_along(NAMES)) {
[17:39:57.426]                   name <- removed[[kk]]
[17:39:57.426]                   NAME <- NAMES[[kk]]
[17:39:57.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.426]                     next
[17:39:57.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.426]                 }
[17:39:57.426]                 if (length(args) > 0) 
[17:39:57.426]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.426]             }
[17:39:57.426]             else {
[17:39:57.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.426]             }
[17:39:57.426]             {
[17:39:57.426]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.426]                   0L) {
[17:39:57.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.426]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.426]                   base::options(opts)
[17:39:57.426]                 }
[17:39:57.426]                 {
[17:39:57.426]                   {
[17:39:57.426]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.426]                     NULL
[17:39:57.426]                   }
[17:39:57.426]                   options(future.plan = NULL)
[17:39:57.426]                   if (is.na(NA_character_)) 
[17:39:57.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.426]                     .init = FALSE)
[17:39:57.426]                 }
[17:39:57.426]             }
[17:39:57.426]         }
[17:39:57.426]     })
[17:39:57.426]     if (TRUE) {
[17:39:57.426]         base::sink(type = "output", split = FALSE)
[17:39:57.426]         if (TRUE) {
[17:39:57.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.426]         }
[17:39:57.426]         else {
[17:39:57.426]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.426]         }
[17:39:57.426]         base::close(...future.stdout)
[17:39:57.426]         ...future.stdout <- NULL
[17:39:57.426]     }
[17:39:57.426]     ...future.result$conditions <- ...future.conditions
[17:39:57.426]     ...future.result$finished <- base::Sys.time()
[17:39:57.426]     ...future.result
[17:39:57.426] }
[17:39:57.428] assign_globals() ...
[17:39:57.428] List of 1
[17:39:57.428]  $ x:function ()  
[17:39:57.428]  - attr(*, "where")=List of 1
[17:39:57.428]   ..$ x:<environment: R_EmptyEnv> 
[17:39:57.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:57.428]  - attr(*, "resolved")= logi TRUE
[17:39:57.428]  - attr(*, "total_size")= num 1032
[17:39:57.428]  - attr(*, "already-done")= logi TRUE
[17:39:57.431] - reassign environment for ‘x’
[17:39:57.431] - copied ‘x’ to environment
[17:39:57.431] assign_globals() ... done
[17:39:57.432] requestCore(): workers = 2
[17:39:57.433] MulticoreFuture started
[17:39:57.434] - Launch lazy future ... done
[17:39:57.434] run() for ‘MulticoreFuture’ ... done
[17:39:57.435] plan(): Setting new future strategy stack:
[17:39:57.435] result() for MulticoreFuture ...
[17:39:57.435] List of future strategies:
[17:39:57.435] 1. sequential:
[17:39:57.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:57.435]    - tweaked: FALSE
[17:39:57.435]    - call: NULL
[17:39:57.437] plan(): nbrOfWorkers() = 1
[17:39:57.440] plan(): Setting new future strategy stack:
[17:39:57.440] List of future strategies:
[17:39:57.440] 1. multicore:
[17:39:57.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:57.440]    - tweaked: FALSE
[17:39:57.440]    - call: plan(strategy)
[17:39:57.445] plan(): nbrOfWorkers() = 2
[17:39:57.446] result() for MulticoreFuture ...
[17:39:57.446] result() for MulticoreFuture ... done
[17:39:57.446] result() for MulticoreFuture ... done
[17:39:57.447] result() for MulticoreFuture ...
[17:39:57.447] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[17:39:57.448] plan(): Setting new future strategy stack:
[17:39:57.448] List of future strategies:
[17:39:57.448] 1. multisession:
[17:39:57.448]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:57.448]    - tweaked: FALSE
[17:39:57.448]    - call: plan(strategy)
[17:39:57.449] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:57.449] multisession:
[17:39:57.449] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:57.449] - tweaked: FALSE
[17:39:57.449] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:57.456] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:57.456] Not searching for globals
[17:39:57.456] - globals: [0] <none>
[17:39:57.456] getGlobalsAndPackages() ... DONE
[17:39:57.457] [local output] makeClusterPSOCK() ...
[17:39:57.501] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:57.502] [local output] Base port: 11751
[17:39:57.502] [local output] Getting setup options for 2 cluster nodes ...
[17:39:57.502] [local output]  - Node 1 of 2 ...
[17:39:57.503] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:57.503] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmph9UX4I/worker.rank=1.parallelly.parent=44746.aeca236c0729.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmph9UX4I/worker.rank=1.parallelly.parent=44746.aeca236c0729.pid")'’
[17:39:57.690] - Possible to infer worker's PID: TRUE
[17:39:57.690] [local output] Rscript port: 11751

[17:39:57.690] [local output]  - Node 2 of 2 ...
[17:39:57.691] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:57.691] [local output] Rscript port: 11751

[17:39:57.692] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:57.692] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:57.692] [local output] Setting up PSOCK nodes in parallel
[17:39:57.692] List of 36
[17:39:57.692]  $ worker          : chr "localhost"
[17:39:57.692]   ..- attr(*, "localhost")= logi TRUE
[17:39:57.692]  $ master          : chr "localhost"
[17:39:57.692]  $ port            : int 11751
[17:39:57.692]  $ connectTimeout  : num 120
[17:39:57.692]  $ timeout         : num 2592000
[17:39:57.692]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:57.692]  $ homogeneous     : logi TRUE
[17:39:57.692]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:57.692]  $ rscript_envs    : NULL
[17:39:57.692]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:57.692]  $ rscript_startup : NULL
[17:39:57.692]  $ rscript_sh      : chr "sh"
[17:39:57.692]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:57.692]  $ methods         : logi TRUE
[17:39:57.692]  $ socketOptions   : chr "no-delay"
[17:39:57.692]  $ useXDR          : logi FALSE
[17:39:57.692]  $ outfile         : chr "/dev/null"
[17:39:57.692]  $ renice          : int NA
[17:39:57.692]  $ rshcmd          : NULL
[17:39:57.692]  $ user            : chr(0) 
[17:39:57.692]  $ revtunnel       : logi FALSE
[17:39:57.692]  $ rshlogfile      : NULL
[17:39:57.692]  $ rshopts         : chr(0) 
[17:39:57.692]  $ rank            : int 1
[17:39:57.692]  $ manual          : logi FALSE
[17:39:57.692]  $ dryrun          : logi FALSE
[17:39:57.692]  $ quiet           : logi FALSE
[17:39:57.692]  $ setup_strategy  : chr "parallel"
[17:39:57.692]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:57.692]  $ pidfile         : chr "/tmp/Rtmph9UX4I/worker.rank=1.parallelly.parent=44746.aeca236c0729.pid"
[17:39:57.692]  $ rshcmd_label    : NULL
[17:39:57.692]  $ rsh_call        : NULL
[17:39:57.692]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:57.692]  $ localMachine    : logi TRUE
[17:39:57.692]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:57.692]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:57.692]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:57.692]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:57.692]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:57.692]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:57.692]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:57.692]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:57.692]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:57.692]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:57.692]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:57.692]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:57.692]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:57.692]  $ arguments       :List of 28
[17:39:57.692]   ..$ worker          : chr "localhost"
[17:39:57.692]   ..$ master          : NULL
[17:39:57.692]   ..$ port            : int 11751
[17:39:57.692]   ..$ connectTimeout  : num 120
[17:39:57.692]   ..$ timeout         : num 2592000
[17:39:57.692]   ..$ rscript         : NULL
[17:39:57.692]   ..$ homogeneous     : NULL
[17:39:57.692]   ..$ rscript_args    : NULL
[17:39:57.692]   ..$ rscript_envs    : NULL
[17:39:57.692]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:57.692]   ..$ rscript_startup : NULL
[17:39:57.692]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:57.692]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:57.692]   ..$ methods         : logi TRUE
[17:39:57.692]   ..$ socketOptions   : chr "no-delay"
[17:39:57.692]   ..$ useXDR          : logi FALSE
[17:39:57.692]   ..$ outfile         : chr "/dev/null"
[17:39:57.692]   ..$ renice          : int NA
[17:39:57.692]   ..$ rshcmd          : NULL
[17:39:57.692]   ..$ user            : NULL
[17:39:57.692]   ..$ revtunnel       : logi NA
[17:39:57.692]   ..$ rshlogfile      : NULL
[17:39:57.692]   ..$ rshopts         : NULL
[17:39:57.692]   ..$ rank            : int 1
[17:39:57.692]   ..$ manual          : logi FALSE
[17:39:57.692]   ..$ dryrun          : logi FALSE
[17:39:57.692]   ..$ quiet           : logi FALSE
[17:39:57.692]   ..$ setup_strategy  : chr "parallel"
[17:39:57.692]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:57.709] [local output] System call to launch all workers:
[17:39:57.709] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmph9UX4I/worker.rank=1.parallelly.parent=44746.aeca236c0729.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11751 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:57.709] [local output] Starting PSOCK main server
[17:39:57.715] [local output] Workers launched
[17:39:57.716] [local output] Waiting for workers to connect back
[17:39:57.716]  - [local output] 0 workers out of 2 ready
[17:39:57.960]  - [local output] 0 workers out of 2 ready
[17:39:57.961]  - [local output] 1 workers out of 2 ready
[17:39:57.961]  - [local output] 2 workers out of 2 ready
[17:39:57.961] [local output] Launching of workers completed
[17:39:57.961] [local output] Collecting session information from workers
[17:39:57.962] [local output]  - Worker #1 of 2
[17:39:57.963] [local output]  - Worker #2 of 2
[17:39:57.963] [local output] makeClusterPSOCK() ... done
[17:39:57.974] Packages needed by the future expression (n = 0): <none>
[17:39:57.974] Packages needed by future strategies (n = 0): <none>
[17:39:57.974] {
[17:39:57.974]     {
[17:39:57.974]         {
[17:39:57.974]             ...future.startTime <- base::Sys.time()
[17:39:57.974]             {
[17:39:57.974]                 {
[17:39:57.974]                   {
[17:39:57.974]                     {
[17:39:57.974]                       base::local({
[17:39:57.974]                         has_future <- base::requireNamespace("future", 
[17:39:57.974]                           quietly = TRUE)
[17:39:57.974]                         if (has_future) {
[17:39:57.974]                           ns <- base::getNamespace("future")
[17:39:57.974]                           version <- ns[[".package"]][["version"]]
[17:39:57.974]                           if (is.null(version)) 
[17:39:57.974]                             version <- utils::packageVersion("future")
[17:39:57.974]                         }
[17:39:57.974]                         else {
[17:39:57.974]                           version <- NULL
[17:39:57.974]                         }
[17:39:57.974]                         if (!has_future || version < "1.8.0") {
[17:39:57.974]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:57.974]                             "", base::R.version$version.string), 
[17:39:57.974]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:57.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:57.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:57.974]                               "release", "version")], collapse = " "), 
[17:39:57.974]                             hostname = base::Sys.info()[["nodename"]])
[17:39:57.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:57.974]                             info)
[17:39:57.974]                           info <- base::paste(info, collapse = "; ")
[17:39:57.974]                           if (!has_future) {
[17:39:57.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:57.974]                               info)
[17:39:57.974]                           }
[17:39:57.974]                           else {
[17:39:57.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:57.974]                               info, version)
[17:39:57.974]                           }
[17:39:57.974]                           base::stop(msg)
[17:39:57.974]                         }
[17:39:57.974]                       })
[17:39:57.974]                     }
[17:39:57.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:57.974]                     base::options(mc.cores = 1L)
[17:39:57.974]                   }
[17:39:57.974]                   ...future.strategy.old <- future::plan("list")
[17:39:57.974]                   options(future.plan = NULL)
[17:39:57.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:57.974]                 }
[17:39:57.974]                 ...future.workdir <- getwd()
[17:39:57.974]             }
[17:39:57.974]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:57.974]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:57.974]         }
[17:39:57.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:57.974]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:57.974]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:57.974]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:57.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:57.974]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:57.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:57.974]             base::names(...future.oldOptions))
[17:39:57.974]     }
[17:39:57.974]     if (FALSE) {
[17:39:57.974]     }
[17:39:57.974]     else {
[17:39:57.974]         if (TRUE) {
[17:39:57.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:57.974]                 open = "w")
[17:39:57.974]         }
[17:39:57.974]         else {
[17:39:57.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:57.974]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:57.974]         }
[17:39:57.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:57.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:57.974]             base::sink(type = "output", split = FALSE)
[17:39:57.974]             base::close(...future.stdout)
[17:39:57.974]         }, add = TRUE)
[17:39:57.974]     }
[17:39:57.974]     ...future.frame <- base::sys.nframe()
[17:39:57.974]     ...future.conditions <- base::list()
[17:39:57.974]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:57.974]     if (FALSE) {
[17:39:57.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:57.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:57.974]     }
[17:39:57.974]     ...future.result <- base::tryCatch({
[17:39:57.974]         base::withCallingHandlers({
[17:39:57.974]             ...future.value <- base::withVisible(base::local({
[17:39:57.974]                 ...future.makeSendCondition <- base::local({
[17:39:57.974]                   sendCondition <- NULL
[17:39:57.974]                   function(frame = 1L) {
[17:39:57.974]                     if (is.function(sendCondition)) 
[17:39:57.974]                       return(sendCondition)
[17:39:57.974]                     ns <- getNamespace("parallel")
[17:39:57.974]                     if (exists("sendData", mode = "function", 
[17:39:57.974]                       envir = ns)) {
[17:39:57.974]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:57.974]                         envir = ns)
[17:39:57.974]                       envir <- sys.frame(frame)
[17:39:57.974]                       master <- NULL
[17:39:57.974]                       while (!identical(envir, .GlobalEnv) && 
[17:39:57.974]                         !identical(envir, emptyenv())) {
[17:39:57.974]                         if (exists("master", mode = "list", envir = envir, 
[17:39:57.974]                           inherits = FALSE)) {
[17:39:57.974]                           master <- get("master", mode = "list", 
[17:39:57.974]                             envir = envir, inherits = FALSE)
[17:39:57.974]                           if (inherits(master, c("SOCKnode", 
[17:39:57.974]                             "SOCK0node"))) {
[17:39:57.974]                             sendCondition <<- function(cond) {
[17:39:57.974]                               data <- list(type = "VALUE", value = cond, 
[17:39:57.974]                                 success = TRUE)
[17:39:57.974]                               parallel_sendData(master, data)
[17:39:57.974]                             }
[17:39:57.974]                             return(sendCondition)
[17:39:57.974]                           }
[17:39:57.974]                         }
[17:39:57.974]                         frame <- frame + 1L
[17:39:57.974]                         envir <- sys.frame(frame)
[17:39:57.974]                       }
[17:39:57.974]                     }
[17:39:57.974]                     sendCondition <<- function(cond) NULL
[17:39:57.974]                   }
[17:39:57.974]                 })
[17:39:57.974]                 withCallingHandlers({
[17:39:57.974]                   NA
[17:39:57.974]                 }, immediateCondition = function(cond) {
[17:39:57.974]                   sendCondition <- ...future.makeSendCondition()
[17:39:57.974]                   sendCondition(cond)
[17:39:57.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.974]                   {
[17:39:57.974]                     inherits <- base::inherits
[17:39:57.974]                     invokeRestart <- base::invokeRestart
[17:39:57.974]                     is.null <- base::is.null
[17:39:57.974]                     muffled <- FALSE
[17:39:57.974]                     if (inherits(cond, "message")) {
[17:39:57.974]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:57.974]                       if (muffled) 
[17:39:57.974]                         invokeRestart("muffleMessage")
[17:39:57.974]                     }
[17:39:57.974]                     else if (inherits(cond, "warning")) {
[17:39:57.974]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:57.974]                       if (muffled) 
[17:39:57.974]                         invokeRestart("muffleWarning")
[17:39:57.974]                     }
[17:39:57.974]                     else if (inherits(cond, "condition")) {
[17:39:57.974]                       if (!is.null(pattern)) {
[17:39:57.974]                         computeRestarts <- base::computeRestarts
[17:39:57.974]                         grepl <- base::grepl
[17:39:57.974]                         restarts <- computeRestarts(cond)
[17:39:57.974]                         for (restart in restarts) {
[17:39:57.974]                           name <- restart$name
[17:39:57.974]                           if (is.null(name)) 
[17:39:57.974]                             next
[17:39:57.974]                           if (!grepl(pattern, name)) 
[17:39:57.974]                             next
[17:39:57.974]                           invokeRestart(restart)
[17:39:57.974]                           muffled <- TRUE
[17:39:57.974]                           break
[17:39:57.974]                         }
[17:39:57.974]                       }
[17:39:57.974]                     }
[17:39:57.974]                     invisible(muffled)
[17:39:57.974]                   }
[17:39:57.974]                   muffleCondition(cond)
[17:39:57.974]                 })
[17:39:57.974]             }))
[17:39:57.974]             future::FutureResult(value = ...future.value$value, 
[17:39:57.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.974]                   ...future.rng), globalenv = if (FALSE) 
[17:39:57.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:57.974]                     ...future.globalenv.names))
[17:39:57.974]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:57.974]         }, condition = base::local({
[17:39:57.974]             c <- base::c
[17:39:57.974]             inherits <- base::inherits
[17:39:57.974]             invokeRestart <- base::invokeRestart
[17:39:57.974]             length <- base::length
[17:39:57.974]             list <- base::list
[17:39:57.974]             seq.int <- base::seq.int
[17:39:57.974]             signalCondition <- base::signalCondition
[17:39:57.974]             sys.calls <- base::sys.calls
[17:39:57.974]             `[[` <- base::`[[`
[17:39:57.974]             `+` <- base::`+`
[17:39:57.974]             `<<-` <- base::`<<-`
[17:39:57.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:57.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:57.974]                   3L)]
[17:39:57.974]             }
[17:39:57.974]             function(cond) {
[17:39:57.974]                 is_error <- inherits(cond, "error")
[17:39:57.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:57.974]                   NULL)
[17:39:57.974]                 if (is_error) {
[17:39:57.974]                   sessionInformation <- function() {
[17:39:57.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:57.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:57.974]                       search = base::search(), system = base::Sys.info())
[17:39:57.974]                   }
[17:39:57.974]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:57.974]                     cond$call), session = sessionInformation(), 
[17:39:57.974]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:57.974]                   signalCondition(cond)
[17:39:57.974]                 }
[17:39:57.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:57.974]                 "immediateCondition"))) {
[17:39:57.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:57.974]                   ...future.conditions[[length(...future.conditions) + 
[17:39:57.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:57.974]                   if (TRUE && !signal) {
[17:39:57.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.974]                     {
[17:39:57.974]                       inherits <- base::inherits
[17:39:57.974]                       invokeRestart <- base::invokeRestart
[17:39:57.974]                       is.null <- base::is.null
[17:39:57.974]                       muffled <- FALSE
[17:39:57.974]                       if (inherits(cond, "message")) {
[17:39:57.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.974]                         if (muffled) 
[17:39:57.974]                           invokeRestart("muffleMessage")
[17:39:57.974]                       }
[17:39:57.974]                       else if (inherits(cond, "warning")) {
[17:39:57.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.974]                         if (muffled) 
[17:39:57.974]                           invokeRestart("muffleWarning")
[17:39:57.974]                       }
[17:39:57.974]                       else if (inherits(cond, "condition")) {
[17:39:57.974]                         if (!is.null(pattern)) {
[17:39:57.974]                           computeRestarts <- base::computeRestarts
[17:39:57.974]                           grepl <- base::grepl
[17:39:57.974]                           restarts <- computeRestarts(cond)
[17:39:57.974]                           for (restart in restarts) {
[17:39:57.974]                             name <- restart$name
[17:39:57.974]                             if (is.null(name)) 
[17:39:57.974]                               next
[17:39:57.974]                             if (!grepl(pattern, name)) 
[17:39:57.974]                               next
[17:39:57.974]                             invokeRestart(restart)
[17:39:57.974]                             muffled <- TRUE
[17:39:57.974]                             break
[17:39:57.974]                           }
[17:39:57.974]                         }
[17:39:57.974]                       }
[17:39:57.974]                       invisible(muffled)
[17:39:57.974]                     }
[17:39:57.974]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.974]                   }
[17:39:57.974]                 }
[17:39:57.974]                 else {
[17:39:57.974]                   if (TRUE) {
[17:39:57.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:57.974]                     {
[17:39:57.974]                       inherits <- base::inherits
[17:39:57.974]                       invokeRestart <- base::invokeRestart
[17:39:57.974]                       is.null <- base::is.null
[17:39:57.974]                       muffled <- FALSE
[17:39:57.974]                       if (inherits(cond, "message")) {
[17:39:57.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:57.974]                         if (muffled) 
[17:39:57.974]                           invokeRestart("muffleMessage")
[17:39:57.974]                       }
[17:39:57.974]                       else if (inherits(cond, "warning")) {
[17:39:57.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:57.974]                         if (muffled) 
[17:39:57.974]                           invokeRestart("muffleWarning")
[17:39:57.974]                       }
[17:39:57.974]                       else if (inherits(cond, "condition")) {
[17:39:57.974]                         if (!is.null(pattern)) {
[17:39:57.974]                           computeRestarts <- base::computeRestarts
[17:39:57.974]                           grepl <- base::grepl
[17:39:57.974]                           restarts <- computeRestarts(cond)
[17:39:57.974]                           for (restart in restarts) {
[17:39:57.974]                             name <- restart$name
[17:39:57.974]                             if (is.null(name)) 
[17:39:57.974]                               next
[17:39:57.974]                             if (!grepl(pattern, name)) 
[17:39:57.974]                               next
[17:39:57.974]                             invokeRestart(restart)
[17:39:57.974]                             muffled <- TRUE
[17:39:57.974]                             break
[17:39:57.974]                           }
[17:39:57.974]                         }
[17:39:57.974]                       }
[17:39:57.974]                       invisible(muffled)
[17:39:57.974]                     }
[17:39:57.974]                     muffleCondition(cond, pattern = "^muffle")
[17:39:57.974]                   }
[17:39:57.974]                 }
[17:39:57.974]             }
[17:39:57.974]         }))
[17:39:57.974]     }, error = function(ex) {
[17:39:57.974]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:57.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:57.974]                 ...future.rng), started = ...future.startTime, 
[17:39:57.974]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:57.974]             version = "1.8"), class = "FutureResult")
[17:39:57.974]     }, finally = {
[17:39:57.974]         if (!identical(...future.workdir, getwd())) 
[17:39:57.974]             setwd(...future.workdir)
[17:39:57.974]         {
[17:39:57.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:57.974]                 ...future.oldOptions$nwarnings <- NULL
[17:39:57.974]             }
[17:39:57.974]             base::options(...future.oldOptions)
[17:39:57.974]             if (.Platform$OS.type == "windows") {
[17:39:57.974]                 old_names <- names(...future.oldEnvVars)
[17:39:57.974]                 envs <- base::Sys.getenv()
[17:39:57.974]                 names <- names(envs)
[17:39:57.974]                 common <- intersect(names, old_names)
[17:39:57.974]                 added <- setdiff(names, old_names)
[17:39:57.974]                 removed <- setdiff(old_names, names)
[17:39:57.974]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:57.974]                   envs[common]]
[17:39:57.974]                 NAMES <- toupper(changed)
[17:39:57.974]                 args <- list()
[17:39:57.974]                 for (kk in seq_along(NAMES)) {
[17:39:57.974]                   name <- changed[[kk]]
[17:39:57.974]                   NAME <- NAMES[[kk]]
[17:39:57.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.974]                     next
[17:39:57.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.974]                 }
[17:39:57.974]                 NAMES <- toupper(added)
[17:39:57.974]                 for (kk in seq_along(NAMES)) {
[17:39:57.974]                   name <- added[[kk]]
[17:39:57.974]                   NAME <- NAMES[[kk]]
[17:39:57.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.974]                     next
[17:39:57.974]                   args[[name]] <- ""
[17:39:57.974]                 }
[17:39:57.974]                 NAMES <- toupper(removed)
[17:39:57.974]                 for (kk in seq_along(NAMES)) {
[17:39:57.974]                   name <- removed[[kk]]
[17:39:57.974]                   NAME <- NAMES[[kk]]
[17:39:57.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:57.974]                     next
[17:39:57.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:57.974]                 }
[17:39:57.974]                 if (length(args) > 0) 
[17:39:57.974]                   base::do.call(base::Sys.setenv, args = args)
[17:39:57.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:57.974]             }
[17:39:57.974]             else {
[17:39:57.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:57.974]             }
[17:39:57.974]             {
[17:39:57.974]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:57.974]                   0L) {
[17:39:57.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:57.974]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:57.974]                   base::options(opts)
[17:39:57.974]                 }
[17:39:57.974]                 {
[17:39:57.974]                   {
[17:39:57.974]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:57.974]                     NULL
[17:39:57.974]                   }
[17:39:57.974]                   options(future.plan = NULL)
[17:39:57.974]                   if (is.na(NA_character_)) 
[17:39:57.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:57.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:57.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:57.974]                     .init = FALSE)
[17:39:57.974]                 }
[17:39:57.974]             }
[17:39:57.974]         }
[17:39:57.974]     })
[17:39:57.974]     if (TRUE) {
[17:39:57.974]         base::sink(type = "output", split = FALSE)
[17:39:57.974]         if (TRUE) {
[17:39:57.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:57.974]         }
[17:39:57.974]         else {
[17:39:57.974]             ...future.result["stdout"] <- base::list(NULL)
[17:39:57.974]         }
[17:39:57.974]         base::close(...future.stdout)
[17:39:57.974]         ...future.stdout <- NULL
[17:39:57.974]     }
[17:39:57.974]     ...future.result$conditions <- ...future.conditions
[17:39:57.974]     ...future.result$finished <- base::Sys.time()
[17:39:57.974]     ...future.result
[17:39:57.974] }
[17:39:58.025] MultisessionFuture started
[17:39:58.026] result() for ClusterFuture ...
[17:39:58.026] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.027] - Validating connection of MultisessionFuture
[17:39:58.057] - received message: FutureResult
[17:39:58.058] - Received FutureResult
[17:39:58.058] - Erased future from FutureRegistry
[17:39:58.058] result() for ClusterFuture ...
[17:39:58.058] - result already collected: FutureResult
[17:39:58.058] result() for ClusterFuture ... done
[17:39:58.058] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.058] result() for ClusterFuture ... done
[17:39:58.059] result() for ClusterFuture ...
[17:39:58.059] - result already collected: FutureResult
[17:39:58.059] result() for ClusterFuture ... done
[17:39:58.059] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:58.063] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.063] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.064] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.065] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:39:58.066] Searching for globals ... DONE
[17:39:58.066] Resolving globals: TRUE
[17:39:58.066] Resolving any globals that are futures ...
[17:39:58.066] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:39:58.066] Resolving any globals that are futures ... DONE
[17:39:58.066] 
[17:39:58.067] 
[17:39:58.067] getGlobalsAndPackages() ... DONE
[17:39:58.067] run() for ‘Future’ ...
[17:39:58.067] - state: ‘created’
[17:39:58.067] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.081] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.082]   - Field: ‘node’
[17:39:58.082]   - Field: ‘label’
[17:39:58.082]   - Field: ‘local’
[17:39:58.082]   - Field: ‘owner’
[17:39:58.082]   - Field: ‘envir’
[17:39:58.082]   - Field: ‘workers’
[17:39:58.082]   - Field: ‘packages’
[17:39:58.082]   - Field: ‘gc’
[17:39:58.082]   - Field: ‘conditions’
[17:39:58.083]   - Field: ‘persistent’
[17:39:58.083]   - Field: ‘expr’
[17:39:58.083]   - Field: ‘uuid’
[17:39:58.083]   - Field: ‘seed’
[17:39:58.083]   - Field: ‘version’
[17:39:58.083]   - Field: ‘result’
[17:39:58.083]   - Field: ‘asynchronous’
[17:39:58.083]   - Field: ‘calls’
[17:39:58.083]   - Field: ‘globals’
[17:39:58.084]   - Field: ‘stdout’
[17:39:58.084]   - Field: ‘earlySignal’
[17:39:58.084]   - Field: ‘lazy’
[17:39:58.084]   - Field: ‘state’
[17:39:58.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.084] - Launch lazy future ...
[17:39:58.084] Packages needed by the future expression (n = 0): <none>
[17:39:58.085] Packages needed by future strategies (n = 0): <none>
[17:39:58.085] {
[17:39:58.085]     {
[17:39:58.085]         {
[17:39:58.085]             ...future.startTime <- base::Sys.time()
[17:39:58.085]             {
[17:39:58.085]                 {
[17:39:58.085]                   {
[17:39:58.085]                     {
[17:39:58.085]                       base::local({
[17:39:58.085]                         has_future <- base::requireNamespace("future", 
[17:39:58.085]                           quietly = TRUE)
[17:39:58.085]                         if (has_future) {
[17:39:58.085]                           ns <- base::getNamespace("future")
[17:39:58.085]                           version <- ns[[".package"]][["version"]]
[17:39:58.085]                           if (is.null(version)) 
[17:39:58.085]                             version <- utils::packageVersion("future")
[17:39:58.085]                         }
[17:39:58.085]                         else {
[17:39:58.085]                           version <- NULL
[17:39:58.085]                         }
[17:39:58.085]                         if (!has_future || version < "1.8.0") {
[17:39:58.085]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.085]                             "", base::R.version$version.string), 
[17:39:58.085]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.085]                               "release", "version")], collapse = " "), 
[17:39:58.085]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.085]                             info)
[17:39:58.085]                           info <- base::paste(info, collapse = "; ")
[17:39:58.085]                           if (!has_future) {
[17:39:58.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.085]                               info)
[17:39:58.085]                           }
[17:39:58.085]                           else {
[17:39:58.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.085]                               info, version)
[17:39:58.085]                           }
[17:39:58.085]                           base::stop(msg)
[17:39:58.085]                         }
[17:39:58.085]                       })
[17:39:58.085]                     }
[17:39:58.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.085]                     base::options(mc.cores = 1L)
[17:39:58.085]                   }
[17:39:58.085]                   ...future.strategy.old <- future::plan("list")
[17:39:58.085]                   options(future.plan = NULL)
[17:39:58.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.085]                 }
[17:39:58.085]                 ...future.workdir <- getwd()
[17:39:58.085]             }
[17:39:58.085]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.085]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.085]         }
[17:39:58.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.085]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.085]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.085]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.085]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.085]             base::names(...future.oldOptions))
[17:39:58.085]     }
[17:39:58.085]     if (FALSE) {
[17:39:58.085]     }
[17:39:58.085]     else {
[17:39:58.085]         if (TRUE) {
[17:39:58.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.085]                 open = "w")
[17:39:58.085]         }
[17:39:58.085]         else {
[17:39:58.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.085]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.085]         }
[17:39:58.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.085]             base::sink(type = "output", split = FALSE)
[17:39:58.085]             base::close(...future.stdout)
[17:39:58.085]         }, add = TRUE)
[17:39:58.085]     }
[17:39:58.085]     ...future.frame <- base::sys.nframe()
[17:39:58.085]     ...future.conditions <- base::list()
[17:39:58.085]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.085]     if (FALSE) {
[17:39:58.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.085]     }
[17:39:58.085]     ...future.result <- base::tryCatch({
[17:39:58.085]         base::withCallingHandlers({
[17:39:58.085]             ...future.value <- base::withVisible(base::local({
[17:39:58.085]                 ...future.makeSendCondition <- base::local({
[17:39:58.085]                   sendCondition <- NULL
[17:39:58.085]                   function(frame = 1L) {
[17:39:58.085]                     if (is.function(sendCondition)) 
[17:39:58.085]                       return(sendCondition)
[17:39:58.085]                     ns <- getNamespace("parallel")
[17:39:58.085]                     if (exists("sendData", mode = "function", 
[17:39:58.085]                       envir = ns)) {
[17:39:58.085]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.085]                         envir = ns)
[17:39:58.085]                       envir <- sys.frame(frame)
[17:39:58.085]                       master <- NULL
[17:39:58.085]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.085]                         !identical(envir, emptyenv())) {
[17:39:58.085]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.085]                           inherits = FALSE)) {
[17:39:58.085]                           master <- get("master", mode = "list", 
[17:39:58.085]                             envir = envir, inherits = FALSE)
[17:39:58.085]                           if (inherits(master, c("SOCKnode", 
[17:39:58.085]                             "SOCK0node"))) {
[17:39:58.085]                             sendCondition <<- function(cond) {
[17:39:58.085]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.085]                                 success = TRUE)
[17:39:58.085]                               parallel_sendData(master, data)
[17:39:58.085]                             }
[17:39:58.085]                             return(sendCondition)
[17:39:58.085]                           }
[17:39:58.085]                         }
[17:39:58.085]                         frame <- frame + 1L
[17:39:58.085]                         envir <- sys.frame(frame)
[17:39:58.085]                       }
[17:39:58.085]                     }
[17:39:58.085]                     sendCondition <<- function(cond) NULL
[17:39:58.085]                   }
[17:39:58.085]                 })
[17:39:58.085]                 withCallingHandlers({
[17:39:58.085]                   {
[17:39:58.085]                     b <- a
[17:39:58.085]                     a <- 2
[17:39:58.085]                     a * b
[17:39:58.085]                   }
[17:39:58.085]                 }, immediateCondition = function(cond) {
[17:39:58.085]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.085]                   sendCondition(cond)
[17:39:58.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.085]                   {
[17:39:58.085]                     inherits <- base::inherits
[17:39:58.085]                     invokeRestart <- base::invokeRestart
[17:39:58.085]                     is.null <- base::is.null
[17:39:58.085]                     muffled <- FALSE
[17:39:58.085]                     if (inherits(cond, "message")) {
[17:39:58.085]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.085]                       if (muffled) 
[17:39:58.085]                         invokeRestart("muffleMessage")
[17:39:58.085]                     }
[17:39:58.085]                     else if (inherits(cond, "warning")) {
[17:39:58.085]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.085]                       if (muffled) 
[17:39:58.085]                         invokeRestart("muffleWarning")
[17:39:58.085]                     }
[17:39:58.085]                     else if (inherits(cond, "condition")) {
[17:39:58.085]                       if (!is.null(pattern)) {
[17:39:58.085]                         computeRestarts <- base::computeRestarts
[17:39:58.085]                         grepl <- base::grepl
[17:39:58.085]                         restarts <- computeRestarts(cond)
[17:39:58.085]                         for (restart in restarts) {
[17:39:58.085]                           name <- restart$name
[17:39:58.085]                           if (is.null(name)) 
[17:39:58.085]                             next
[17:39:58.085]                           if (!grepl(pattern, name)) 
[17:39:58.085]                             next
[17:39:58.085]                           invokeRestart(restart)
[17:39:58.085]                           muffled <- TRUE
[17:39:58.085]                           break
[17:39:58.085]                         }
[17:39:58.085]                       }
[17:39:58.085]                     }
[17:39:58.085]                     invisible(muffled)
[17:39:58.085]                   }
[17:39:58.085]                   muffleCondition(cond)
[17:39:58.085]                 })
[17:39:58.085]             }))
[17:39:58.085]             future::FutureResult(value = ...future.value$value, 
[17:39:58.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.085]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.085]                     ...future.globalenv.names))
[17:39:58.085]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.085]         }, condition = base::local({
[17:39:58.085]             c <- base::c
[17:39:58.085]             inherits <- base::inherits
[17:39:58.085]             invokeRestart <- base::invokeRestart
[17:39:58.085]             length <- base::length
[17:39:58.085]             list <- base::list
[17:39:58.085]             seq.int <- base::seq.int
[17:39:58.085]             signalCondition <- base::signalCondition
[17:39:58.085]             sys.calls <- base::sys.calls
[17:39:58.085]             `[[` <- base::`[[`
[17:39:58.085]             `+` <- base::`+`
[17:39:58.085]             `<<-` <- base::`<<-`
[17:39:58.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.085]                   3L)]
[17:39:58.085]             }
[17:39:58.085]             function(cond) {
[17:39:58.085]                 is_error <- inherits(cond, "error")
[17:39:58.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.085]                   NULL)
[17:39:58.085]                 if (is_error) {
[17:39:58.085]                   sessionInformation <- function() {
[17:39:58.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.085]                       search = base::search(), system = base::Sys.info())
[17:39:58.085]                   }
[17:39:58.085]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.085]                     cond$call), session = sessionInformation(), 
[17:39:58.085]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.085]                   signalCondition(cond)
[17:39:58.085]                 }
[17:39:58.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.085]                 "immediateCondition"))) {
[17:39:58.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.085]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.085]                   if (TRUE && !signal) {
[17:39:58.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.085]                     {
[17:39:58.085]                       inherits <- base::inherits
[17:39:58.085]                       invokeRestart <- base::invokeRestart
[17:39:58.085]                       is.null <- base::is.null
[17:39:58.085]                       muffled <- FALSE
[17:39:58.085]                       if (inherits(cond, "message")) {
[17:39:58.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.085]                         if (muffled) 
[17:39:58.085]                           invokeRestart("muffleMessage")
[17:39:58.085]                       }
[17:39:58.085]                       else if (inherits(cond, "warning")) {
[17:39:58.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.085]                         if (muffled) 
[17:39:58.085]                           invokeRestart("muffleWarning")
[17:39:58.085]                       }
[17:39:58.085]                       else if (inherits(cond, "condition")) {
[17:39:58.085]                         if (!is.null(pattern)) {
[17:39:58.085]                           computeRestarts <- base::computeRestarts
[17:39:58.085]                           grepl <- base::grepl
[17:39:58.085]                           restarts <- computeRestarts(cond)
[17:39:58.085]                           for (restart in restarts) {
[17:39:58.085]                             name <- restart$name
[17:39:58.085]                             if (is.null(name)) 
[17:39:58.085]                               next
[17:39:58.085]                             if (!grepl(pattern, name)) 
[17:39:58.085]                               next
[17:39:58.085]                             invokeRestart(restart)
[17:39:58.085]                             muffled <- TRUE
[17:39:58.085]                             break
[17:39:58.085]                           }
[17:39:58.085]                         }
[17:39:58.085]                       }
[17:39:58.085]                       invisible(muffled)
[17:39:58.085]                     }
[17:39:58.085]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.085]                   }
[17:39:58.085]                 }
[17:39:58.085]                 else {
[17:39:58.085]                   if (TRUE) {
[17:39:58.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.085]                     {
[17:39:58.085]                       inherits <- base::inherits
[17:39:58.085]                       invokeRestart <- base::invokeRestart
[17:39:58.085]                       is.null <- base::is.null
[17:39:58.085]                       muffled <- FALSE
[17:39:58.085]                       if (inherits(cond, "message")) {
[17:39:58.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.085]                         if (muffled) 
[17:39:58.085]                           invokeRestart("muffleMessage")
[17:39:58.085]                       }
[17:39:58.085]                       else if (inherits(cond, "warning")) {
[17:39:58.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.085]                         if (muffled) 
[17:39:58.085]                           invokeRestart("muffleWarning")
[17:39:58.085]                       }
[17:39:58.085]                       else if (inherits(cond, "condition")) {
[17:39:58.085]                         if (!is.null(pattern)) {
[17:39:58.085]                           computeRestarts <- base::computeRestarts
[17:39:58.085]                           grepl <- base::grepl
[17:39:58.085]                           restarts <- computeRestarts(cond)
[17:39:58.085]                           for (restart in restarts) {
[17:39:58.085]                             name <- restart$name
[17:39:58.085]                             if (is.null(name)) 
[17:39:58.085]                               next
[17:39:58.085]                             if (!grepl(pattern, name)) 
[17:39:58.085]                               next
[17:39:58.085]                             invokeRestart(restart)
[17:39:58.085]                             muffled <- TRUE
[17:39:58.085]                             break
[17:39:58.085]                           }
[17:39:58.085]                         }
[17:39:58.085]                       }
[17:39:58.085]                       invisible(muffled)
[17:39:58.085]                     }
[17:39:58.085]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.085]                   }
[17:39:58.085]                 }
[17:39:58.085]             }
[17:39:58.085]         }))
[17:39:58.085]     }, error = function(ex) {
[17:39:58.085]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.085]                 ...future.rng), started = ...future.startTime, 
[17:39:58.085]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.085]             version = "1.8"), class = "FutureResult")
[17:39:58.085]     }, finally = {
[17:39:58.085]         if (!identical(...future.workdir, getwd())) 
[17:39:58.085]             setwd(...future.workdir)
[17:39:58.085]         {
[17:39:58.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.085]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.085]             }
[17:39:58.085]             base::options(...future.oldOptions)
[17:39:58.085]             if (.Platform$OS.type == "windows") {
[17:39:58.085]                 old_names <- names(...future.oldEnvVars)
[17:39:58.085]                 envs <- base::Sys.getenv()
[17:39:58.085]                 names <- names(envs)
[17:39:58.085]                 common <- intersect(names, old_names)
[17:39:58.085]                 added <- setdiff(names, old_names)
[17:39:58.085]                 removed <- setdiff(old_names, names)
[17:39:58.085]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.085]                   envs[common]]
[17:39:58.085]                 NAMES <- toupper(changed)
[17:39:58.085]                 args <- list()
[17:39:58.085]                 for (kk in seq_along(NAMES)) {
[17:39:58.085]                   name <- changed[[kk]]
[17:39:58.085]                   NAME <- NAMES[[kk]]
[17:39:58.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.085]                     next
[17:39:58.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.085]                 }
[17:39:58.085]                 NAMES <- toupper(added)
[17:39:58.085]                 for (kk in seq_along(NAMES)) {
[17:39:58.085]                   name <- added[[kk]]
[17:39:58.085]                   NAME <- NAMES[[kk]]
[17:39:58.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.085]                     next
[17:39:58.085]                   args[[name]] <- ""
[17:39:58.085]                 }
[17:39:58.085]                 NAMES <- toupper(removed)
[17:39:58.085]                 for (kk in seq_along(NAMES)) {
[17:39:58.085]                   name <- removed[[kk]]
[17:39:58.085]                   NAME <- NAMES[[kk]]
[17:39:58.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.085]                     next
[17:39:58.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.085]                 }
[17:39:58.085]                 if (length(args) > 0) 
[17:39:58.085]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.085]             }
[17:39:58.085]             else {
[17:39:58.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.085]             }
[17:39:58.085]             {
[17:39:58.085]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.085]                   0L) {
[17:39:58.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.085]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.085]                   base::options(opts)
[17:39:58.085]                 }
[17:39:58.085]                 {
[17:39:58.085]                   {
[17:39:58.085]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.085]                     NULL
[17:39:58.085]                   }
[17:39:58.085]                   options(future.plan = NULL)
[17:39:58.085]                   if (is.na(NA_character_)) 
[17:39:58.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.085]                     .init = FALSE)
[17:39:58.085]                 }
[17:39:58.085]             }
[17:39:58.085]         }
[17:39:58.085]     })
[17:39:58.085]     if (TRUE) {
[17:39:58.085]         base::sink(type = "output", split = FALSE)
[17:39:58.085]         if (TRUE) {
[17:39:58.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.085]         }
[17:39:58.085]         else {
[17:39:58.085]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.085]         }
[17:39:58.085]         base::close(...future.stdout)
[17:39:58.085]         ...future.stdout <- NULL
[17:39:58.085]     }
[17:39:58.085]     ...future.result$conditions <- ...future.conditions
[17:39:58.085]     ...future.result$finished <- base::Sys.time()
[17:39:58.085]     ...future.result
[17:39:58.085] }
[17:39:58.088] MultisessionFuture started
[17:39:58.089] - Launch lazy future ... done
[17:39:58.089] run() for ‘MultisessionFuture’ ... done
[17:39:58.089] result() for ClusterFuture ...
[17:39:58.089] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.090] - Validating connection of MultisessionFuture
[17:39:58.091] - received message: FutureResult
[17:39:58.091] - Received FutureResult
[17:39:58.091] - Erased future from FutureRegistry
[17:39:58.092] result() for ClusterFuture ...
[17:39:58.092] - result already collected: FutureResult
[17:39:58.092] result() for ClusterFuture ... done
[17:39:58.092] signalConditions() ...
[17:39:58.092]  - include = ‘immediateCondition’
[17:39:58.092]  - exclude = 
[17:39:58.092]  - resignal = FALSE
[17:39:58.092]  - Number of conditions: 1
[17:39:58.093] signalConditions() ... done
[17:39:58.093] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.093] result() for ClusterFuture ... done
[17:39:58.093] result() for ClusterFuture ...
[17:39:58.093] - result already collected: FutureResult
[17:39:58.093] result() for ClusterFuture ... done
[17:39:58.093] signalConditions() ...
[17:39:58.093]  - include = ‘immediateCondition’
[17:39:58.093]  - exclude = 
[17:39:58.094]  - resignal = FALSE
[17:39:58.094]  - Number of conditions: 1
[17:39:58.094] signalConditions() ... done
[17:39:58.094] Future state: ‘finished’
[17:39:58.094] result() for ClusterFuture ...
[17:39:58.094] - result already collected: FutureResult
[17:39:58.094] result() for ClusterFuture ... done
[17:39:58.094] signalConditions() ...
[17:39:58.094]  - include = ‘condition’
[17:39:58.095]  - exclude = ‘immediateCondition’
[17:39:58.095]  - resignal = TRUE
[17:39:58.095]  - Number of conditions: 1
[17:39:58.095]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:58.095] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.111] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.111] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.113] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:39:58.113] Searching for globals ... DONE
[17:39:58.113] Resolving globals: TRUE
[17:39:58.113] Resolving any globals that are futures ...
[17:39:58.113] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:39:58.114] Resolving any globals that are futures ... DONE
[17:39:58.114] 
[17:39:58.114] 
[17:39:58.114] getGlobalsAndPackages() ... DONE
[17:39:58.115] run() for ‘Future’ ...
[17:39:58.115] - state: ‘created’
[17:39:58.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.129]   - Field: ‘node’
[17:39:58.130]   - Field: ‘label’
[17:39:58.130]   - Field: ‘local’
[17:39:58.130]   - Field: ‘owner’
[17:39:58.130]   - Field: ‘envir’
[17:39:58.130]   - Field: ‘workers’
[17:39:58.130]   - Field: ‘packages’
[17:39:58.130]   - Field: ‘gc’
[17:39:58.130]   - Field: ‘conditions’
[17:39:58.130]   - Field: ‘persistent’
[17:39:58.130]   - Field: ‘expr’
[17:39:58.131]   - Field: ‘uuid’
[17:39:58.131]   - Field: ‘seed’
[17:39:58.131]   - Field: ‘version’
[17:39:58.131]   - Field: ‘result’
[17:39:58.131]   - Field: ‘asynchronous’
[17:39:58.131]   - Field: ‘calls’
[17:39:58.131]   - Field: ‘globals’
[17:39:58.131]   - Field: ‘stdout’
[17:39:58.131]   - Field: ‘earlySignal’
[17:39:58.132]   - Field: ‘lazy’
[17:39:58.132]   - Field: ‘state’
[17:39:58.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.132] - Launch lazy future ...
[17:39:58.132] Packages needed by the future expression (n = 0): <none>
[17:39:58.132] Packages needed by future strategies (n = 0): <none>
[17:39:58.133] {
[17:39:58.133]     {
[17:39:58.133]         {
[17:39:58.133]             ...future.startTime <- base::Sys.time()
[17:39:58.133]             {
[17:39:58.133]                 {
[17:39:58.133]                   {
[17:39:58.133]                     {
[17:39:58.133]                       base::local({
[17:39:58.133]                         has_future <- base::requireNamespace("future", 
[17:39:58.133]                           quietly = TRUE)
[17:39:58.133]                         if (has_future) {
[17:39:58.133]                           ns <- base::getNamespace("future")
[17:39:58.133]                           version <- ns[[".package"]][["version"]]
[17:39:58.133]                           if (is.null(version)) 
[17:39:58.133]                             version <- utils::packageVersion("future")
[17:39:58.133]                         }
[17:39:58.133]                         else {
[17:39:58.133]                           version <- NULL
[17:39:58.133]                         }
[17:39:58.133]                         if (!has_future || version < "1.8.0") {
[17:39:58.133]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.133]                             "", base::R.version$version.string), 
[17:39:58.133]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.133]                               "release", "version")], collapse = " "), 
[17:39:58.133]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.133]                             info)
[17:39:58.133]                           info <- base::paste(info, collapse = "; ")
[17:39:58.133]                           if (!has_future) {
[17:39:58.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.133]                               info)
[17:39:58.133]                           }
[17:39:58.133]                           else {
[17:39:58.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.133]                               info, version)
[17:39:58.133]                           }
[17:39:58.133]                           base::stop(msg)
[17:39:58.133]                         }
[17:39:58.133]                       })
[17:39:58.133]                     }
[17:39:58.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.133]                     base::options(mc.cores = 1L)
[17:39:58.133]                   }
[17:39:58.133]                   ...future.strategy.old <- future::plan("list")
[17:39:58.133]                   options(future.plan = NULL)
[17:39:58.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.133]                 }
[17:39:58.133]                 ...future.workdir <- getwd()
[17:39:58.133]             }
[17:39:58.133]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.133]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.133]         }
[17:39:58.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.133]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.133]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.133]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.133]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.133]             base::names(...future.oldOptions))
[17:39:58.133]     }
[17:39:58.133]     if (FALSE) {
[17:39:58.133]     }
[17:39:58.133]     else {
[17:39:58.133]         if (TRUE) {
[17:39:58.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.133]                 open = "w")
[17:39:58.133]         }
[17:39:58.133]         else {
[17:39:58.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.133]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.133]         }
[17:39:58.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.133]             base::sink(type = "output", split = FALSE)
[17:39:58.133]             base::close(...future.stdout)
[17:39:58.133]         }, add = TRUE)
[17:39:58.133]     }
[17:39:58.133]     ...future.frame <- base::sys.nframe()
[17:39:58.133]     ...future.conditions <- base::list()
[17:39:58.133]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.133]     if (FALSE) {
[17:39:58.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.133]     }
[17:39:58.133]     ...future.result <- base::tryCatch({
[17:39:58.133]         base::withCallingHandlers({
[17:39:58.133]             ...future.value <- base::withVisible(base::local({
[17:39:58.133]                 ...future.makeSendCondition <- base::local({
[17:39:58.133]                   sendCondition <- NULL
[17:39:58.133]                   function(frame = 1L) {
[17:39:58.133]                     if (is.function(sendCondition)) 
[17:39:58.133]                       return(sendCondition)
[17:39:58.133]                     ns <- getNamespace("parallel")
[17:39:58.133]                     if (exists("sendData", mode = "function", 
[17:39:58.133]                       envir = ns)) {
[17:39:58.133]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.133]                         envir = ns)
[17:39:58.133]                       envir <- sys.frame(frame)
[17:39:58.133]                       master <- NULL
[17:39:58.133]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.133]                         !identical(envir, emptyenv())) {
[17:39:58.133]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.133]                           inherits = FALSE)) {
[17:39:58.133]                           master <- get("master", mode = "list", 
[17:39:58.133]                             envir = envir, inherits = FALSE)
[17:39:58.133]                           if (inherits(master, c("SOCKnode", 
[17:39:58.133]                             "SOCK0node"))) {
[17:39:58.133]                             sendCondition <<- function(cond) {
[17:39:58.133]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.133]                                 success = TRUE)
[17:39:58.133]                               parallel_sendData(master, data)
[17:39:58.133]                             }
[17:39:58.133]                             return(sendCondition)
[17:39:58.133]                           }
[17:39:58.133]                         }
[17:39:58.133]                         frame <- frame + 1L
[17:39:58.133]                         envir <- sys.frame(frame)
[17:39:58.133]                       }
[17:39:58.133]                     }
[17:39:58.133]                     sendCondition <<- function(cond) NULL
[17:39:58.133]                   }
[17:39:58.133]                 })
[17:39:58.133]                 withCallingHandlers({
[17:39:58.133]                   {
[17:39:58.133]                     b <- a
[17:39:58.133]                     a <- 2
[17:39:58.133]                     a * b
[17:39:58.133]                   }
[17:39:58.133]                 }, immediateCondition = function(cond) {
[17:39:58.133]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.133]                   sendCondition(cond)
[17:39:58.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.133]                   {
[17:39:58.133]                     inherits <- base::inherits
[17:39:58.133]                     invokeRestart <- base::invokeRestart
[17:39:58.133]                     is.null <- base::is.null
[17:39:58.133]                     muffled <- FALSE
[17:39:58.133]                     if (inherits(cond, "message")) {
[17:39:58.133]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.133]                       if (muffled) 
[17:39:58.133]                         invokeRestart("muffleMessage")
[17:39:58.133]                     }
[17:39:58.133]                     else if (inherits(cond, "warning")) {
[17:39:58.133]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.133]                       if (muffled) 
[17:39:58.133]                         invokeRestart("muffleWarning")
[17:39:58.133]                     }
[17:39:58.133]                     else if (inherits(cond, "condition")) {
[17:39:58.133]                       if (!is.null(pattern)) {
[17:39:58.133]                         computeRestarts <- base::computeRestarts
[17:39:58.133]                         grepl <- base::grepl
[17:39:58.133]                         restarts <- computeRestarts(cond)
[17:39:58.133]                         for (restart in restarts) {
[17:39:58.133]                           name <- restart$name
[17:39:58.133]                           if (is.null(name)) 
[17:39:58.133]                             next
[17:39:58.133]                           if (!grepl(pattern, name)) 
[17:39:58.133]                             next
[17:39:58.133]                           invokeRestart(restart)
[17:39:58.133]                           muffled <- TRUE
[17:39:58.133]                           break
[17:39:58.133]                         }
[17:39:58.133]                       }
[17:39:58.133]                     }
[17:39:58.133]                     invisible(muffled)
[17:39:58.133]                   }
[17:39:58.133]                   muffleCondition(cond)
[17:39:58.133]                 })
[17:39:58.133]             }))
[17:39:58.133]             future::FutureResult(value = ...future.value$value, 
[17:39:58.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.133]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.133]                     ...future.globalenv.names))
[17:39:58.133]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.133]         }, condition = base::local({
[17:39:58.133]             c <- base::c
[17:39:58.133]             inherits <- base::inherits
[17:39:58.133]             invokeRestart <- base::invokeRestart
[17:39:58.133]             length <- base::length
[17:39:58.133]             list <- base::list
[17:39:58.133]             seq.int <- base::seq.int
[17:39:58.133]             signalCondition <- base::signalCondition
[17:39:58.133]             sys.calls <- base::sys.calls
[17:39:58.133]             `[[` <- base::`[[`
[17:39:58.133]             `+` <- base::`+`
[17:39:58.133]             `<<-` <- base::`<<-`
[17:39:58.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.133]                   3L)]
[17:39:58.133]             }
[17:39:58.133]             function(cond) {
[17:39:58.133]                 is_error <- inherits(cond, "error")
[17:39:58.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.133]                   NULL)
[17:39:58.133]                 if (is_error) {
[17:39:58.133]                   sessionInformation <- function() {
[17:39:58.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.133]                       search = base::search(), system = base::Sys.info())
[17:39:58.133]                   }
[17:39:58.133]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.133]                     cond$call), session = sessionInformation(), 
[17:39:58.133]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.133]                   signalCondition(cond)
[17:39:58.133]                 }
[17:39:58.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.133]                 "immediateCondition"))) {
[17:39:58.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.133]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.133]                   if (TRUE && !signal) {
[17:39:58.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.133]                     {
[17:39:58.133]                       inherits <- base::inherits
[17:39:58.133]                       invokeRestart <- base::invokeRestart
[17:39:58.133]                       is.null <- base::is.null
[17:39:58.133]                       muffled <- FALSE
[17:39:58.133]                       if (inherits(cond, "message")) {
[17:39:58.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.133]                         if (muffled) 
[17:39:58.133]                           invokeRestart("muffleMessage")
[17:39:58.133]                       }
[17:39:58.133]                       else if (inherits(cond, "warning")) {
[17:39:58.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.133]                         if (muffled) 
[17:39:58.133]                           invokeRestart("muffleWarning")
[17:39:58.133]                       }
[17:39:58.133]                       else if (inherits(cond, "condition")) {
[17:39:58.133]                         if (!is.null(pattern)) {
[17:39:58.133]                           computeRestarts <- base::computeRestarts
[17:39:58.133]                           grepl <- base::grepl
[17:39:58.133]                           restarts <- computeRestarts(cond)
[17:39:58.133]                           for (restart in restarts) {
[17:39:58.133]                             name <- restart$name
[17:39:58.133]                             if (is.null(name)) 
[17:39:58.133]                               next
[17:39:58.133]                             if (!grepl(pattern, name)) 
[17:39:58.133]                               next
[17:39:58.133]                             invokeRestart(restart)
[17:39:58.133]                             muffled <- TRUE
[17:39:58.133]                             break
[17:39:58.133]                           }
[17:39:58.133]                         }
[17:39:58.133]                       }
[17:39:58.133]                       invisible(muffled)
[17:39:58.133]                     }
[17:39:58.133]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.133]                   }
[17:39:58.133]                 }
[17:39:58.133]                 else {
[17:39:58.133]                   if (TRUE) {
[17:39:58.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.133]                     {
[17:39:58.133]                       inherits <- base::inherits
[17:39:58.133]                       invokeRestart <- base::invokeRestart
[17:39:58.133]                       is.null <- base::is.null
[17:39:58.133]                       muffled <- FALSE
[17:39:58.133]                       if (inherits(cond, "message")) {
[17:39:58.133]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.133]                         if (muffled) 
[17:39:58.133]                           invokeRestart("muffleMessage")
[17:39:58.133]                       }
[17:39:58.133]                       else if (inherits(cond, "warning")) {
[17:39:58.133]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.133]                         if (muffled) 
[17:39:58.133]                           invokeRestart("muffleWarning")
[17:39:58.133]                       }
[17:39:58.133]                       else if (inherits(cond, "condition")) {
[17:39:58.133]                         if (!is.null(pattern)) {
[17:39:58.133]                           computeRestarts <- base::computeRestarts
[17:39:58.133]                           grepl <- base::grepl
[17:39:58.133]                           restarts <- computeRestarts(cond)
[17:39:58.133]                           for (restart in restarts) {
[17:39:58.133]                             name <- restart$name
[17:39:58.133]                             if (is.null(name)) 
[17:39:58.133]                               next
[17:39:58.133]                             if (!grepl(pattern, name)) 
[17:39:58.133]                               next
[17:39:58.133]                             invokeRestart(restart)
[17:39:58.133]                             muffled <- TRUE
[17:39:58.133]                             break
[17:39:58.133]                           }
[17:39:58.133]                         }
[17:39:58.133]                       }
[17:39:58.133]                       invisible(muffled)
[17:39:58.133]                     }
[17:39:58.133]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.133]                   }
[17:39:58.133]                 }
[17:39:58.133]             }
[17:39:58.133]         }))
[17:39:58.133]     }, error = function(ex) {
[17:39:58.133]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.133]                 ...future.rng), started = ...future.startTime, 
[17:39:58.133]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.133]             version = "1.8"), class = "FutureResult")
[17:39:58.133]     }, finally = {
[17:39:58.133]         if (!identical(...future.workdir, getwd())) 
[17:39:58.133]             setwd(...future.workdir)
[17:39:58.133]         {
[17:39:58.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.133]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.133]             }
[17:39:58.133]             base::options(...future.oldOptions)
[17:39:58.133]             if (.Platform$OS.type == "windows") {
[17:39:58.133]                 old_names <- names(...future.oldEnvVars)
[17:39:58.133]                 envs <- base::Sys.getenv()
[17:39:58.133]                 names <- names(envs)
[17:39:58.133]                 common <- intersect(names, old_names)
[17:39:58.133]                 added <- setdiff(names, old_names)
[17:39:58.133]                 removed <- setdiff(old_names, names)
[17:39:58.133]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.133]                   envs[common]]
[17:39:58.133]                 NAMES <- toupper(changed)
[17:39:58.133]                 args <- list()
[17:39:58.133]                 for (kk in seq_along(NAMES)) {
[17:39:58.133]                   name <- changed[[kk]]
[17:39:58.133]                   NAME <- NAMES[[kk]]
[17:39:58.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.133]                     next
[17:39:58.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.133]                 }
[17:39:58.133]                 NAMES <- toupper(added)
[17:39:58.133]                 for (kk in seq_along(NAMES)) {
[17:39:58.133]                   name <- added[[kk]]
[17:39:58.133]                   NAME <- NAMES[[kk]]
[17:39:58.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.133]                     next
[17:39:58.133]                   args[[name]] <- ""
[17:39:58.133]                 }
[17:39:58.133]                 NAMES <- toupper(removed)
[17:39:58.133]                 for (kk in seq_along(NAMES)) {
[17:39:58.133]                   name <- removed[[kk]]
[17:39:58.133]                   NAME <- NAMES[[kk]]
[17:39:58.133]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.133]                     next
[17:39:58.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.133]                 }
[17:39:58.133]                 if (length(args) > 0) 
[17:39:58.133]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.133]             }
[17:39:58.133]             else {
[17:39:58.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.133]             }
[17:39:58.133]             {
[17:39:58.133]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.133]                   0L) {
[17:39:58.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.133]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.133]                   base::options(opts)
[17:39:58.133]                 }
[17:39:58.133]                 {
[17:39:58.133]                   {
[17:39:58.133]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.133]                     NULL
[17:39:58.133]                   }
[17:39:58.133]                   options(future.plan = NULL)
[17:39:58.133]                   if (is.na(NA_character_)) 
[17:39:58.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.133]                     .init = FALSE)
[17:39:58.133]                 }
[17:39:58.133]             }
[17:39:58.133]         }
[17:39:58.133]     })
[17:39:58.133]     if (TRUE) {
[17:39:58.133]         base::sink(type = "output", split = FALSE)
[17:39:58.133]         if (TRUE) {
[17:39:58.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.133]         }
[17:39:58.133]         else {
[17:39:58.133]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.133]         }
[17:39:58.133]         base::close(...future.stdout)
[17:39:58.133]         ...future.stdout <- NULL
[17:39:58.133]     }
[17:39:58.133]     ...future.result$conditions <- ...future.conditions
[17:39:58.133]     ...future.result$finished <- base::Sys.time()
[17:39:58.133]     ...future.result
[17:39:58.133] }
[17:39:58.136] MultisessionFuture started
[17:39:58.136] - Launch lazy future ... done
[17:39:58.137] run() for ‘MultisessionFuture’ ... done
[17:39:58.137] result() for ClusterFuture ...
[17:39:58.137] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.137] - Validating connection of MultisessionFuture
[17:39:58.142] - received message: FutureResult
[17:39:58.142] - Received FutureResult
[17:39:58.144] - Erased future from FutureRegistry
[17:39:58.145] result() for ClusterFuture ...
[17:39:58.145] - result already collected: FutureResult
[17:39:58.145] result() for ClusterFuture ... done
[17:39:58.145] signalConditions() ...
[17:39:58.145]  - include = ‘immediateCondition’
[17:39:58.145]  - exclude = 
[17:39:58.145]  - resignal = FALSE
[17:39:58.145]  - Number of conditions: 1
[17:39:58.145] signalConditions() ... done
[17:39:58.145] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.145] result() for ClusterFuture ... done
[17:39:58.145] result() for ClusterFuture ...
[17:39:58.146] - result already collected: FutureResult
[17:39:58.146] result() for ClusterFuture ... done
[17:39:58.146] signalConditions() ...
[17:39:58.146]  - include = ‘immediateCondition’
[17:39:58.146]  - exclude = 
[17:39:58.146]  - resignal = FALSE
[17:39:58.146]  - Number of conditions: 1
[17:39:58.146] signalConditions() ... done
[17:39:58.146] Future state: ‘finished’
[17:39:58.146] result() for ClusterFuture ...
[17:39:58.146] - result already collected: FutureResult
[17:39:58.146] result() for ClusterFuture ... done
[17:39:58.147] signalConditions() ...
[17:39:58.147]  - include = ‘condition’
[17:39:58.147]  - exclude = ‘immediateCondition’
[17:39:58.147]  - resignal = TRUE
[17:39:58.147]  - Number of conditions: 1
[17:39:58.147]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:58.147] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.161] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.161] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.162] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.162] Searching for globals ... DONE
[17:39:58.162] Resolving globals: TRUE
[17:39:58.162] Resolving any globals that are futures ...
[17:39:58.162] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.163] Resolving any globals that are futures ... DONE
[17:39:58.163] Resolving futures part of globals (recursively) ...
[17:39:58.163] resolve() on list ...
[17:39:58.163]  recursive: 99
[17:39:58.163]  length: 1
[17:39:58.163]  elements: ‘ii’
[17:39:58.163]  length: 0 (resolved future 1)
[17:39:58.164] resolve() on list ... DONE
[17:39:58.164] - globals: [1] ‘ii’
[17:39:58.164] Resolving futures part of globals (recursively) ... DONE
[17:39:58.164] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:58.164] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:58.164] - globals: [1] ‘ii’
[17:39:58.164] 
[17:39:58.165] getGlobalsAndPackages() ... DONE
[17:39:58.165] run() for ‘Future’ ...
[17:39:58.165] - state: ‘created’
[17:39:58.165] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.178] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.179]   - Field: ‘node’
[17:39:58.179]   - Field: ‘label’
[17:39:58.179]   - Field: ‘local’
[17:39:58.179]   - Field: ‘owner’
[17:39:58.179]   - Field: ‘envir’
[17:39:58.179]   - Field: ‘workers’
[17:39:58.179]   - Field: ‘packages’
[17:39:58.179]   - Field: ‘gc’
[17:39:58.179]   - Field: ‘conditions’
[17:39:58.180]   - Field: ‘persistent’
[17:39:58.180]   - Field: ‘expr’
[17:39:58.180]   - Field: ‘uuid’
[17:39:58.180]   - Field: ‘seed’
[17:39:58.180]   - Field: ‘version’
[17:39:58.180]   - Field: ‘result’
[17:39:58.180]   - Field: ‘asynchronous’
[17:39:58.180]   - Field: ‘calls’
[17:39:58.180]   - Field: ‘globals’
[17:39:58.180]   - Field: ‘stdout’
[17:39:58.180]   - Field: ‘earlySignal’
[17:39:58.181]   - Field: ‘lazy’
[17:39:58.181]   - Field: ‘state’
[17:39:58.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.181] - Launch lazy future ...
[17:39:58.181] Packages needed by the future expression (n = 0): <none>
[17:39:58.181] Packages needed by future strategies (n = 0): <none>
[17:39:58.182] {
[17:39:58.182]     {
[17:39:58.182]         {
[17:39:58.182]             ...future.startTime <- base::Sys.time()
[17:39:58.182]             {
[17:39:58.182]                 {
[17:39:58.182]                   {
[17:39:58.182]                     {
[17:39:58.182]                       base::local({
[17:39:58.182]                         has_future <- base::requireNamespace("future", 
[17:39:58.182]                           quietly = TRUE)
[17:39:58.182]                         if (has_future) {
[17:39:58.182]                           ns <- base::getNamespace("future")
[17:39:58.182]                           version <- ns[[".package"]][["version"]]
[17:39:58.182]                           if (is.null(version)) 
[17:39:58.182]                             version <- utils::packageVersion("future")
[17:39:58.182]                         }
[17:39:58.182]                         else {
[17:39:58.182]                           version <- NULL
[17:39:58.182]                         }
[17:39:58.182]                         if (!has_future || version < "1.8.0") {
[17:39:58.182]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.182]                             "", base::R.version$version.string), 
[17:39:58.182]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.182]                               "release", "version")], collapse = " "), 
[17:39:58.182]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.182]                             info)
[17:39:58.182]                           info <- base::paste(info, collapse = "; ")
[17:39:58.182]                           if (!has_future) {
[17:39:58.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.182]                               info)
[17:39:58.182]                           }
[17:39:58.182]                           else {
[17:39:58.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.182]                               info, version)
[17:39:58.182]                           }
[17:39:58.182]                           base::stop(msg)
[17:39:58.182]                         }
[17:39:58.182]                       })
[17:39:58.182]                     }
[17:39:58.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.182]                     base::options(mc.cores = 1L)
[17:39:58.182]                   }
[17:39:58.182]                   ...future.strategy.old <- future::plan("list")
[17:39:58.182]                   options(future.plan = NULL)
[17:39:58.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.182]                 }
[17:39:58.182]                 ...future.workdir <- getwd()
[17:39:58.182]             }
[17:39:58.182]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.182]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.182]         }
[17:39:58.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.182]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.182]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.182]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.182]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.182]             base::names(...future.oldOptions))
[17:39:58.182]     }
[17:39:58.182]     if (FALSE) {
[17:39:58.182]     }
[17:39:58.182]     else {
[17:39:58.182]         if (TRUE) {
[17:39:58.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.182]                 open = "w")
[17:39:58.182]         }
[17:39:58.182]         else {
[17:39:58.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.182]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.182]         }
[17:39:58.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.182]             base::sink(type = "output", split = FALSE)
[17:39:58.182]             base::close(...future.stdout)
[17:39:58.182]         }, add = TRUE)
[17:39:58.182]     }
[17:39:58.182]     ...future.frame <- base::sys.nframe()
[17:39:58.182]     ...future.conditions <- base::list()
[17:39:58.182]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.182]     if (FALSE) {
[17:39:58.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.182]     }
[17:39:58.182]     ...future.result <- base::tryCatch({
[17:39:58.182]         base::withCallingHandlers({
[17:39:58.182]             ...future.value <- base::withVisible(base::local({
[17:39:58.182]                 ...future.makeSendCondition <- base::local({
[17:39:58.182]                   sendCondition <- NULL
[17:39:58.182]                   function(frame = 1L) {
[17:39:58.182]                     if (is.function(sendCondition)) 
[17:39:58.182]                       return(sendCondition)
[17:39:58.182]                     ns <- getNamespace("parallel")
[17:39:58.182]                     if (exists("sendData", mode = "function", 
[17:39:58.182]                       envir = ns)) {
[17:39:58.182]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.182]                         envir = ns)
[17:39:58.182]                       envir <- sys.frame(frame)
[17:39:58.182]                       master <- NULL
[17:39:58.182]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.182]                         !identical(envir, emptyenv())) {
[17:39:58.182]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.182]                           inherits = FALSE)) {
[17:39:58.182]                           master <- get("master", mode = "list", 
[17:39:58.182]                             envir = envir, inherits = FALSE)
[17:39:58.182]                           if (inherits(master, c("SOCKnode", 
[17:39:58.182]                             "SOCK0node"))) {
[17:39:58.182]                             sendCondition <<- function(cond) {
[17:39:58.182]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.182]                                 success = TRUE)
[17:39:58.182]                               parallel_sendData(master, data)
[17:39:58.182]                             }
[17:39:58.182]                             return(sendCondition)
[17:39:58.182]                           }
[17:39:58.182]                         }
[17:39:58.182]                         frame <- frame + 1L
[17:39:58.182]                         envir <- sys.frame(frame)
[17:39:58.182]                       }
[17:39:58.182]                     }
[17:39:58.182]                     sendCondition <<- function(cond) NULL
[17:39:58.182]                   }
[17:39:58.182]                 })
[17:39:58.182]                 withCallingHandlers({
[17:39:58.182]                   {
[17:39:58.182]                     b <- a * ii
[17:39:58.182]                     a <- 0
[17:39:58.182]                     b
[17:39:58.182]                   }
[17:39:58.182]                 }, immediateCondition = function(cond) {
[17:39:58.182]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.182]                   sendCondition(cond)
[17:39:58.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.182]                   {
[17:39:58.182]                     inherits <- base::inherits
[17:39:58.182]                     invokeRestart <- base::invokeRestart
[17:39:58.182]                     is.null <- base::is.null
[17:39:58.182]                     muffled <- FALSE
[17:39:58.182]                     if (inherits(cond, "message")) {
[17:39:58.182]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.182]                       if (muffled) 
[17:39:58.182]                         invokeRestart("muffleMessage")
[17:39:58.182]                     }
[17:39:58.182]                     else if (inherits(cond, "warning")) {
[17:39:58.182]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.182]                       if (muffled) 
[17:39:58.182]                         invokeRestart("muffleWarning")
[17:39:58.182]                     }
[17:39:58.182]                     else if (inherits(cond, "condition")) {
[17:39:58.182]                       if (!is.null(pattern)) {
[17:39:58.182]                         computeRestarts <- base::computeRestarts
[17:39:58.182]                         grepl <- base::grepl
[17:39:58.182]                         restarts <- computeRestarts(cond)
[17:39:58.182]                         for (restart in restarts) {
[17:39:58.182]                           name <- restart$name
[17:39:58.182]                           if (is.null(name)) 
[17:39:58.182]                             next
[17:39:58.182]                           if (!grepl(pattern, name)) 
[17:39:58.182]                             next
[17:39:58.182]                           invokeRestart(restart)
[17:39:58.182]                           muffled <- TRUE
[17:39:58.182]                           break
[17:39:58.182]                         }
[17:39:58.182]                       }
[17:39:58.182]                     }
[17:39:58.182]                     invisible(muffled)
[17:39:58.182]                   }
[17:39:58.182]                   muffleCondition(cond)
[17:39:58.182]                 })
[17:39:58.182]             }))
[17:39:58.182]             future::FutureResult(value = ...future.value$value, 
[17:39:58.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.182]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.182]                     ...future.globalenv.names))
[17:39:58.182]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.182]         }, condition = base::local({
[17:39:58.182]             c <- base::c
[17:39:58.182]             inherits <- base::inherits
[17:39:58.182]             invokeRestart <- base::invokeRestart
[17:39:58.182]             length <- base::length
[17:39:58.182]             list <- base::list
[17:39:58.182]             seq.int <- base::seq.int
[17:39:58.182]             signalCondition <- base::signalCondition
[17:39:58.182]             sys.calls <- base::sys.calls
[17:39:58.182]             `[[` <- base::`[[`
[17:39:58.182]             `+` <- base::`+`
[17:39:58.182]             `<<-` <- base::`<<-`
[17:39:58.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.182]                   3L)]
[17:39:58.182]             }
[17:39:58.182]             function(cond) {
[17:39:58.182]                 is_error <- inherits(cond, "error")
[17:39:58.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.182]                   NULL)
[17:39:58.182]                 if (is_error) {
[17:39:58.182]                   sessionInformation <- function() {
[17:39:58.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.182]                       search = base::search(), system = base::Sys.info())
[17:39:58.182]                   }
[17:39:58.182]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.182]                     cond$call), session = sessionInformation(), 
[17:39:58.182]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.182]                   signalCondition(cond)
[17:39:58.182]                 }
[17:39:58.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.182]                 "immediateCondition"))) {
[17:39:58.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.182]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.182]                   if (TRUE && !signal) {
[17:39:58.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.182]                     {
[17:39:58.182]                       inherits <- base::inherits
[17:39:58.182]                       invokeRestart <- base::invokeRestart
[17:39:58.182]                       is.null <- base::is.null
[17:39:58.182]                       muffled <- FALSE
[17:39:58.182]                       if (inherits(cond, "message")) {
[17:39:58.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.182]                         if (muffled) 
[17:39:58.182]                           invokeRestart("muffleMessage")
[17:39:58.182]                       }
[17:39:58.182]                       else if (inherits(cond, "warning")) {
[17:39:58.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.182]                         if (muffled) 
[17:39:58.182]                           invokeRestart("muffleWarning")
[17:39:58.182]                       }
[17:39:58.182]                       else if (inherits(cond, "condition")) {
[17:39:58.182]                         if (!is.null(pattern)) {
[17:39:58.182]                           computeRestarts <- base::computeRestarts
[17:39:58.182]                           grepl <- base::grepl
[17:39:58.182]                           restarts <- computeRestarts(cond)
[17:39:58.182]                           for (restart in restarts) {
[17:39:58.182]                             name <- restart$name
[17:39:58.182]                             if (is.null(name)) 
[17:39:58.182]                               next
[17:39:58.182]                             if (!grepl(pattern, name)) 
[17:39:58.182]                               next
[17:39:58.182]                             invokeRestart(restart)
[17:39:58.182]                             muffled <- TRUE
[17:39:58.182]                             break
[17:39:58.182]                           }
[17:39:58.182]                         }
[17:39:58.182]                       }
[17:39:58.182]                       invisible(muffled)
[17:39:58.182]                     }
[17:39:58.182]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.182]                   }
[17:39:58.182]                 }
[17:39:58.182]                 else {
[17:39:58.182]                   if (TRUE) {
[17:39:58.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.182]                     {
[17:39:58.182]                       inherits <- base::inherits
[17:39:58.182]                       invokeRestart <- base::invokeRestart
[17:39:58.182]                       is.null <- base::is.null
[17:39:58.182]                       muffled <- FALSE
[17:39:58.182]                       if (inherits(cond, "message")) {
[17:39:58.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.182]                         if (muffled) 
[17:39:58.182]                           invokeRestart("muffleMessage")
[17:39:58.182]                       }
[17:39:58.182]                       else if (inherits(cond, "warning")) {
[17:39:58.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.182]                         if (muffled) 
[17:39:58.182]                           invokeRestart("muffleWarning")
[17:39:58.182]                       }
[17:39:58.182]                       else if (inherits(cond, "condition")) {
[17:39:58.182]                         if (!is.null(pattern)) {
[17:39:58.182]                           computeRestarts <- base::computeRestarts
[17:39:58.182]                           grepl <- base::grepl
[17:39:58.182]                           restarts <- computeRestarts(cond)
[17:39:58.182]                           for (restart in restarts) {
[17:39:58.182]                             name <- restart$name
[17:39:58.182]                             if (is.null(name)) 
[17:39:58.182]                               next
[17:39:58.182]                             if (!grepl(pattern, name)) 
[17:39:58.182]                               next
[17:39:58.182]                             invokeRestart(restart)
[17:39:58.182]                             muffled <- TRUE
[17:39:58.182]                             break
[17:39:58.182]                           }
[17:39:58.182]                         }
[17:39:58.182]                       }
[17:39:58.182]                       invisible(muffled)
[17:39:58.182]                     }
[17:39:58.182]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.182]                   }
[17:39:58.182]                 }
[17:39:58.182]             }
[17:39:58.182]         }))
[17:39:58.182]     }, error = function(ex) {
[17:39:58.182]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.182]                 ...future.rng), started = ...future.startTime, 
[17:39:58.182]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.182]             version = "1.8"), class = "FutureResult")
[17:39:58.182]     }, finally = {
[17:39:58.182]         if (!identical(...future.workdir, getwd())) 
[17:39:58.182]             setwd(...future.workdir)
[17:39:58.182]         {
[17:39:58.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.182]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.182]             }
[17:39:58.182]             base::options(...future.oldOptions)
[17:39:58.182]             if (.Platform$OS.type == "windows") {
[17:39:58.182]                 old_names <- names(...future.oldEnvVars)
[17:39:58.182]                 envs <- base::Sys.getenv()
[17:39:58.182]                 names <- names(envs)
[17:39:58.182]                 common <- intersect(names, old_names)
[17:39:58.182]                 added <- setdiff(names, old_names)
[17:39:58.182]                 removed <- setdiff(old_names, names)
[17:39:58.182]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.182]                   envs[common]]
[17:39:58.182]                 NAMES <- toupper(changed)
[17:39:58.182]                 args <- list()
[17:39:58.182]                 for (kk in seq_along(NAMES)) {
[17:39:58.182]                   name <- changed[[kk]]
[17:39:58.182]                   NAME <- NAMES[[kk]]
[17:39:58.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.182]                     next
[17:39:58.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.182]                 }
[17:39:58.182]                 NAMES <- toupper(added)
[17:39:58.182]                 for (kk in seq_along(NAMES)) {
[17:39:58.182]                   name <- added[[kk]]
[17:39:58.182]                   NAME <- NAMES[[kk]]
[17:39:58.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.182]                     next
[17:39:58.182]                   args[[name]] <- ""
[17:39:58.182]                 }
[17:39:58.182]                 NAMES <- toupper(removed)
[17:39:58.182]                 for (kk in seq_along(NAMES)) {
[17:39:58.182]                   name <- removed[[kk]]
[17:39:58.182]                   NAME <- NAMES[[kk]]
[17:39:58.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.182]                     next
[17:39:58.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.182]                 }
[17:39:58.182]                 if (length(args) > 0) 
[17:39:58.182]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.182]             }
[17:39:58.182]             else {
[17:39:58.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.182]             }
[17:39:58.182]             {
[17:39:58.182]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.182]                   0L) {
[17:39:58.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.182]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.182]                   base::options(opts)
[17:39:58.182]                 }
[17:39:58.182]                 {
[17:39:58.182]                   {
[17:39:58.182]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.182]                     NULL
[17:39:58.182]                   }
[17:39:58.182]                   options(future.plan = NULL)
[17:39:58.182]                   if (is.na(NA_character_)) 
[17:39:58.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.182]                     .init = FALSE)
[17:39:58.182]                 }
[17:39:58.182]             }
[17:39:58.182]         }
[17:39:58.182]     })
[17:39:58.182]     if (TRUE) {
[17:39:58.182]         base::sink(type = "output", split = FALSE)
[17:39:58.182]         if (TRUE) {
[17:39:58.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.182]         }
[17:39:58.182]         else {
[17:39:58.182]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.182]         }
[17:39:58.182]         base::close(...future.stdout)
[17:39:58.182]         ...future.stdout <- NULL
[17:39:58.182]     }
[17:39:58.182]     ...future.result$conditions <- ...future.conditions
[17:39:58.182]     ...future.result$finished <- base::Sys.time()
[17:39:58.182]     ...future.result
[17:39:58.182] }
[17:39:58.184] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:39:58.184] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:39:58.185] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:58.185] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:39:58.185] MultisessionFuture started
[17:39:58.185] - Launch lazy future ... done
[17:39:58.186] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.186] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.187] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.189] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.189] Searching for globals ... DONE
[17:39:58.189] Resolving globals: TRUE
[17:39:58.189] Resolving any globals that are futures ...
[17:39:58.189] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.189] Resolving any globals that are futures ... DONE
[17:39:58.189] Resolving futures part of globals (recursively) ...
[17:39:58.190] resolve() on list ...
[17:39:58.190]  recursive: 99
[17:39:58.190]  length: 1
[17:39:58.190]  elements: ‘ii’
[17:39:58.190]  length: 0 (resolved future 1)
[17:39:58.190] resolve() on list ... DONE
[17:39:58.190] - globals: [1] ‘ii’
[17:39:58.190] Resolving futures part of globals (recursively) ... DONE
[17:39:58.190] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:58.191] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:58.191] - globals: [1] ‘ii’
[17:39:58.191] 
[17:39:58.191] getGlobalsAndPackages() ... DONE
[17:39:58.191] run() for ‘Future’ ...
[17:39:58.191] - state: ‘created’
[17:39:58.191] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.205] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.205]   - Field: ‘node’
[17:39:58.205]   - Field: ‘label’
[17:39:58.205]   - Field: ‘local’
[17:39:58.205]   - Field: ‘owner’
[17:39:58.205]   - Field: ‘envir’
[17:39:58.205]   - Field: ‘workers’
[17:39:58.206]   - Field: ‘packages’
[17:39:58.206]   - Field: ‘gc’
[17:39:58.206]   - Field: ‘conditions’
[17:39:58.206]   - Field: ‘persistent’
[17:39:58.206]   - Field: ‘expr’
[17:39:58.206]   - Field: ‘uuid’
[17:39:58.206]   - Field: ‘seed’
[17:39:58.206]   - Field: ‘version’
[17:39:58.206]   - Field: ‘result’
[17:39:58.206]   - Field: ‘asynchronous’
[17:39:58.206]   - Field: ‘calls’
[17:39:58.206]   - Field: ‘globals’
[17:39:58.207]   - Field: ‘stdout’
[17:39:58.207]   - Field: ‘earlySignal’
[17:39:58.207]   - Field: ‘lazy’
[17:39:58.207]   - Field: ‘state’
[17:39:58.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.207] - Launch lazy future ...
[17:39:58.207] Packages needed by the future expression (n = 0): <none>
[17:39:58.207] Packages needed by future strategies (n = 0): <none>
[17:39:58.208] {
[17:39:58.208]     {
[17:39:58.208]         {
[17:39:58.208]             ...future.startTime <- base::Sys.time()
[17:39:58.208]             {
[17:39:58.208]                 {
[17:39:58.208]                   {
[17:39:58.208]                     {
[17:39:58.208]                       base::local({
[17:39:58.208]                         has_future <- base::requireNamespace("future", 
[17:39:58.208]                           quietly = TRUE)
[17:39:58.208]                         if (has_future) {
[17:39:58.208]                           ns <- base::getNamespace("future")
[17:39:58.208]                           version <- ns[[".package"]][["version"]]
[17:39:58.208]                           if (is.null(version)) 
[17:39:58.208]                             version <- utils::packageVersion("future")
[17:39:58.208]                         }
[17:39:58.208]                         else {
[17:39:58.208]                           version <- NULL
[17:39:58.208]                         }
[17:39:58.208]                         if (!has_future || version < "1.8.0") {
[17:39:58.208]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.208]                             "", base::R.version$version.string), 
[17:39:58.208]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.208]                               "release", "version")], collapse = " "), 
[17:39:58.208]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.208]                             info)
[17:39:58.208]                           info <- base::paste(info, collapse = "; ")
[17:39:58.208]                           if (!has_future) {
[17:39:58.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.208]                               info)
[17:39:58.208]                           }
[17:39:58.208]                           else {
[17:39:58.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.208]                               info, version)
[17:39:58.208]                           }
[17:39:58.208]                           base::stop(msg)
[17:39:58.208]                         }
[17:39:58.208]                       })
[17:39:58.208]                     }
[17:39:58.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.208]                     base::options(mc.cores = 1L)
[17:39:58.208]                   }
[17:39:58.208]                   ...future.strategy.old <- future::plan("list")
[17:39:58.208]                   options(future.plan = NULL)
[17:39:58.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.208]                 }
[17:39:58.208]                 ...future.workdir <- getwd()
[17:39:58.208]             }
[17:39:58.208]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.208]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.208]         }
[17:39:58.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.208]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.208]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.208]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.208]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.208]             base::names(...future.oldOptions))
[17:39:58.208]     }
[17:39:58.208]     if (FALSE) {
[17:39:58.208]     }
[17:39:58.208]     else {
[17:39:58.208]         if (TRUE) {
[17:39:58.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.208]                 open = "w")
[17:39:58.208]         }
[17:39:58.208]         else {
[17:39:58.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.208]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.208]         }
[17:39:58.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.208]             base::sink(type = "output", split = FALSE)
[17:39:58.208]             base::close(...future.stdout)
[17:39:58.208]         }, add = TRUE)
[17:39:58.208]     }
[17:39:58.208]     ...future.frame <- base::sys.nframe()
[17:39:58.208]     ...future.conditions <- base::list()
[17:39:58.208]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.208]     if (FALSE) {
[17:39:58.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.208]     }
[17:39:58.208]     ...future.result <- base::tryCatch({
[17:39:58.208]         base::withCallingHandlers({
[17:39:58.208]             ...future.value <- base::withVisible(base::local({
[17:39:58.208]                 ...future.makeSendCondition <- base::local({
[17:39:58.208]                   sendCondition <- NULL
[17:39:58.208]                   function(frame = 1L) {
[17:39:58.208]                     if (is.function(sendCondition)) 
[17:39:58.208]                       return(sendCondition)
[17:39:58.208]                     ns <- getNamespace("parallel")
[17:39:58.208]                     if (exists("sendData", mode = "function", 
[17:39:58.208]                       envir = ns)) {
[17:39:58.208]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.208]                         envir = ns)
[17:39:58.208]                       envir <- sys.frame(frame)
[17:39:58.208]                       master <- NULL
[17:39:58.208]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.208]                         !identical(envir, emptyenv())) {
[17:39:58.208]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.208]                           inherits = FALSE)) {
[17:39:58.208]                           master <- get("master", mode = "list", 
[17:39:58.208]                             envir = envir, inherits = FALSE)
[17:39:58.208]                           if (inherits(master, c("SOCKnode", 
[17:39:58.208]                             "SOCK0node"))) {
[17:39:58.208]                             sendCondition <<- function(cond) {
[17:39:58.208]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.208]                                 success = TRUE)
[17:39:58.208]                               parallel_sendData(master, data)
[17:39:58.208]                             }
[17:39:58.208]                             return(sendCondition)
[17:39:58.208]                           }
[17:39:58.208]                         }
[17:39:58.208]                         frame <- frame + 1L
[17:39:58.208]                         envir <- sys.frame(frame)
[17:39:58.208]                       }
[17:39:58.208]                     }
[17:39:58.208]                     sendCondition <<- function(cond) NULL
[17:39:58.208]                   }
[17:39:58.208]                 })
[17:39:58.208]                 withCallingHandlers({
[17:39:58.208]                   {
[17:39:58.208]                     b <- a * ii
[17:39:58.208]                     a <- 0
[17:39:58.208]                     b
[17:39:58.208]                   }
[17:39:58.208]                 }, immediateCondition = function(cond) {
[17:39:58.208]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.208]                   sendCondition(cond)
[17:39:58.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.208]                   {
[17:39:58.208]                     inherits <- base::inherits
[17:39:58.208]                     invokeRestart <- base::invokeRestart
[17:39:58.208]                     is.null <- base::is.null
[17:39:58.208]                     muffled <- FALSE
[17:39:58.208]                     if (inherits(cond, "message")) {
[17:39:58.208]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.208]                       if (muffled) 
[17:39:58.208]                         invokeRestart("muffleMessage")
[17:39:58.208]                     }
[17:39:58.208]                     else if (inherits(cond, "warning")) {
[17:39:58.208]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.208]                       if (muffled) 
[17:39:58.208]                         invokeRestart("muffleWarning")
[17:39:58.208]                     }
[17:39:58.208]                     else if (inherits(cond, "condition")) {
[17:39:58.208]                       if (!is.null(pattern)) {
[17:39:58.208]                         computeRestarts <- base::computeRestarts
[17:39:58.208]                         grepl <- base::grepl
[17:39:58.208]                         restarts <- computeRestarts(cond)
[17:39:58.208]                         for (restart in restarts) {
[17:39:58.208]                           name <- restart$name
[17:39:58.208]                           if (is.null(name)) 
[17:39:58.208]                             next
[17:39:58.208]                           if (!grepl(pattern, name)) 
[17:39:58.208]                             next
[17:39:58.208]                           invokeRestart(restart)
[17:39:58.208]                           muffled <- TRUE
[17:39:58.208]                           break
[17:39:58.208]                         }
[17:39:58.208]                       }
[17:39:58.208]                     }
[17:39:58.208]                     invisible(muffled)
[17:39:58.208]                   }
[17:39:58.208]                   muffleCondition(cond)
[17:39:58.208]                 })
[17:39:58.208]             }))
[17:39:58.208]             future::FutureResult(value = ...future.value$value, 
[17:39:58.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.208]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.208]                     ...future.globalenv.names))
[17:39:58.208]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.208]         }, condition = base::local({
[17:39:58.208]             c <- base::c
[17:39:58.208]             inherits <- base::inherits
[17:39:58.208]             invokeRestart <- base::invokeRestart
[17:39:58.208]             length <- base::length
[17:39:58.208]             list <- base::list
[17:39:58.208]             seq.int <- base::seq.int
[17:39:58.208]             signalCondition <- base::signalCondition
[17:39:58.208]             sys.calls <- base::sys.calls
[17:39:58.208]             `[[` <- base::`[[`
[17:39:58.208]             `+` <- base::`+`
[17:39:58.208]             `<<-` <- base::`<<-`
[17:39:58.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.208]                   3L)]
[17:39:58.208]             }
[17:39:58.208]             function(cond) {
[17:39:58.208]                 is_error <- inherits(cond, "error")
[17:39:58.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.208]                   NULL)
[17:39:58.208]                 if (is_error) {
[17:39:58.208]                   sessionInformation <- function() {
[17:39:58.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.208]                       search = base::search(), system = base::Sys.info())
[17:39:58.208]                   }
[17:39:58.208]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.208]                     cond$call), session = sessionInformation(), 
[17:39:58.208]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.208]                   signalCondition(cond)
[17:39:58.208]                 }
[17:39:58.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.208]                 "immediateCondition"))) {
[17:39:58.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.208]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.208]                   if (TRUE && !signal) {
[17:39:58.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.208]                     {
[17:39:58.208]                       inherits <- base::inherits
[17:39:58.208]                       invokeRestart <- base::invokeRestart
[17:39:58.208]                       is.null <- base::is.null
[17:39:58.208]                       muffled <- FALSE
[17:39:58.208]                       if (inherits(cond, "message")) {
[17:39:58.208]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.208]                         if (muffled) 
[17:39:58.208]                           invokeRestart("muffleMessage")
[17:39:58.208]                       }
[17:39:58.208]                       else if (inherits(cond, "warning")) {
[17:39:58.208]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.208]                         if (muffled) 
[17:39:58.208]                           invokeRestart("muffleWarning")
[17:39:58.208]                       }
[17:39:58.208]                       else if (inherits(cond, "condition")) {
[17:39:58.208]                         if (!is.null(pattern)) {
[17:39:58.208]                           computeRestarts <- base::computeRestarts
[17:39:58.208]                           grepl <- base::grepl
[17:39:58.208]                           restarts <- computeRestarts(cond)
[17:39:58.208]                           for (restart in restarts) {
[17:39:58.208]                             name <- restart$name
[17:39:58.208]                             if (is.null(name)) 
[17:39:58.208]                               next
[17:39:58.208]                             if (!grepl(pattern, name)) 
[17:39:58.208]                               next
[17:39:58.208]                             invokeRestart(restart)
[17:39:58.208]                             muffled <- TRUE
[17:39:58.208]                             break
[17:39:58.208]                           }
[17:39:58.208]                         }
[17:39:58.208]                       }
[17:39:58.208]                       invisible(muffled)
[17:39:58.208]                     }
[17:39:58.208]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.208]                   }
[17:39:58.208]                 }
[17:39:58.208]                 else {
[17:39:58.208]                   if (TRUE) {
[17:39:58.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.208]                     {
[17:39:58.208]                       inherits <- base::inherits
[17:39:58.208]                       invokeRestart <- base::invokeRestart
[17:39:58.208]                       is.null <- base::is.null
[17:39:58.208]                       muffled <- FALSE
[17:39:58.208]                       if (inherits(cond, "message")) {
[17:39:58.208]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.208]                         if (muffled) 
[17:39:58.208]                           invokeRestart("muffleMessage")
[17:39:58.208]                       }
[17:39:58.208]                       else if (inherits(cond, "warning")) {
[17:39:58.208]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.208]                         if (muffled) 
[17:39:58.208]                           invokeRestart("muffleWarning")
[17:39:58.208]                       }
[17:39:58.208]                       else if (inherits(cond, "condition")) {
[17:39:58.208]                         if (!is.null(pattern)) {
[17:39:58.208]                           computeRestarts <- base::computeRestarts
[17:39:58.208]                           grepl <- base::grepl
[17:39:58.208]                           restarts <- computeRestarts(cond)
[17:39:58.208]                           for (restart in restarts) {
[17:39:58.208]                             name <- restart$name
[17:39:58.208]                             if (is.null(name)) 
[17:39:58.208]                               next
[17:39:58.208]                             if (!grepl(pattern, name)) 
[17:39:58.208]                               next
[17:39:58.208]                             invokeRestart(restart)
[17:39:58.208]                             muffled <- TRUE
[17:39:58.208]                             break
[17:39:58.208]                           }
[17:39:58.208]                         }
[17:39:58.208]                       }
[17:39:58.208]                       invisible(muffled)
[17:39:58.208]                     }
[17:39:58.208]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.208]                   }
[17:39:58.208]                 }
[17:39:58.208]             }
[17:39:58.208]         }))
[17:39:58.208]     }, error = function(ex) {
[17:39:58.208]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.208]                 ...future.rng), started = ...future.startTime, 
[17:39:58.208]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.208]             version = "1.8"), class = "FutureResult")
[17:39:58.208]     }, finally = {
[17:39:58.208]         if (!identical(...future.workdir, getwd())) 
[17:39:58.208]             setwd(...future.workdir)
[17:39:58.208]         {
[17:39:58.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.208]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.208]             }
[17:39:58.208]             base::options(...future.oldOptions)
[17:39:58.208]             if (.Platform$OS.type == "windows") {
[17:39:58.208]                 old_names <- names(...future.oldEnvVars)
[17:39:58.208]                 envs <- base::Sys.getenv()
[17:39:58.208]                 names <- names(envs)
[17:39:58.208]                 common <- intersect(names, old_names)
[17:39:58.208]                 added <- setdiff(names, old_names)
[17:39:58.208]                 removed <- setdiff(old_names, names)
[17:39:58.208]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.208]                   envs[common]]
[17:39:58.208]                 NAMES <- toupper(changed)
[17:39:58.208]                 args <- list()
[17:39:58.208]                 for (kk in seq_along(NAMES)) {
[17:39:58.208]                   name <- changed[[kk]]
[17:39:58.208]                   NAME <- NAMES[[kk]]
[17:39:58.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.208]                     next
[17:39:58.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.208]                 }
[17:39:58.208]                 NAMES <- toupper(added)
[17:39:58.208]                 for (kk in seq_along(NAMES)) {
[17:39:58.208]                   name <- added[[kk]]
[17:39:58.208]                   NAME <- NAMES[[kk]]
[17:39:58.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.208]                     next
[17:39:58.208]                   args[[name]] <- ""
[17:39:58.208]                 }
[17:39:58.208]                 NAMES <- toupper(removed)
[17:39:58.208]                 for (kk in seq_along(NAMES)) {
[17:39:58.208]                   name <- removed[[kk]]
[17:39:58.208]                   NAME <- NAMES[[kk]]
[17:39:58.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.208]                     next
[17:39:58.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.208]                 }
[17:39:58.208]                 if (length(args) > 0) 
[17:39:58.208]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.208]             }
[17:39:58.208]             else {
[17:39:58.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.208]             }
[17:39:58.208]             {
[17:39:58.208]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.208]                   0L) {
[17:39:58.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.208]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.208]                   base::options(opts)
[17:39:58.208]                 }
[17:39:58.208]                 {
[17:39:58.208]                   {
[17:39:58.208]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.208]                     NULL
[17:39:58.208]                   }
[17:39:58.208]                   options(future.plan = NULL)
[17:39:58.208]                   if (is.na(NA_character_)) 
[17:39:58.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.208]                     .init = FALSE)
[17:39:58.208]                 }
[17:39:58.208]             }
[17:39:58.208]         }
[17:39:58.208]     })
[17:39:58.208]     if (TRUE) {
[17:39:58.208]         base::sink(type = "output", split = FALSE)
[17:39:58.208]         if (TRUE) {
[17:39:58.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.208]         }
[17:39:58.208]         else {
[17:39:58.208]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.208]         }
[17:39:58.208]         base::close(...future.stdout)
[17:39:58.208]         ...future.stdout <- NULL
[17:39:58.208]     }
[17:39:58.208]     ...future.result$conditions <- ...future.conditions
[17:39:58.208]     ...future.result$finished <- base::Sys.time()
[17:39:58.208]     ...future.result
[17:39:58.208] }
[17:39:58.259] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:39:58.259] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:39:58.259] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:58.260] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:39:58.260] MultisessionFuture started
[17:39:58.260] - Launch lazy future ... done
[17:39:58.260] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.261] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.261] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.262] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.263] Searching for globals ... DONE
[17:39:58.263] Resolving globals: TRUE
[17:39:58.263] Resolving any globals that are futures ...
[17:39:58.263] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.263] Resolving any globals that are futures ... DONE
[17:39:58.263] Resolving futures part of globals (recursively) ...
[17:39:58.264] resolve() on list ...
[17:39:58.264]  recursive: 99
[17:39:58.264]  length: 1
[17:39:58.264]  elements: ‘ii’
[17:39:58.264]  length: 0 (resolved future 1)
[17:39:58.264] resolve() on list ... DONE
[17:39:58.264] - globals: [1] ‘ii’
[17:39:58.264] Resolving futures part of globals (recursively) ... DONE
[17:39:58.264] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:58.265] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:58.265] - globals: [1] ‘ii’
[17:39:58.265] 
[17:39:58.265] getGlobalsAndPackages() ... DONE
[17:39:58.265] run() for ‘Future’ ...
[17:39:58.265] - state: ‘created’
[17:39:58.266] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.279] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.279]   - Field: ‘node’
[17:39:58.280]   - Field: ‘label’
[17:39:58.280]   - Field: ‘local’
[17:39:58.280]   - Field: ‘owner’
[17:39:58.280]   - Field: ‘envir’
[17:39:58.280]   - Field: ‘workers’
[17:39:58.280]   - Field: ‘packages’
[17:39:58.280]   - Field: ‘gc’
[17:39:58.280]   - Field: ‘conditions’
[17:39:58.280]   - Field: ‘persistent’
[17:39:58.280]   - Field: ‘expr’
[17:39:58.280]   - Field: ‘uuid’
[17:39:58.281]   - Field: ‘seed’
[17:39:58.281]   - Field: ‘version’
[17:39:58.281]   - Field: ‘result’
[17:39:58.281]   - Field: ‘asynchronous’
[17:39:58.281]   - Field: ‘calls’
[17:39:58.281]   - Field: ‘globals’
[17:39:58.281]   - Field: ‘stdout’
[17:39:58.281]   - Field: ‘earlySignal’
[17:39:58.281]   - Field: ‘lazy’
[17:39:58.281]   - Field: ‘state’
[17:39:58.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.281] - Launch lazy future ...
[17:39:58.282] Packages needed by the future expression (n = 0): <none>
[17:39:58.282] Packages needed by future strategies (n = 0): <none>
[17:39:58.282] {
[17:39:58.282]     {
[17:39:58.282]         {
[17:39:58.282]             ...future.startTime <- base::Sys.time()
[17:39:58.282]             {
[17:39:58.282]                 {
[17:39:58.282]                   {
[17:39:58.282]                     {
[17:39:58.282]                       base::local({
[17:39:58.282]                         has_future <- base::requireNamespace("future", 
[17:39:58.282]                           quietly = TRUE)
[17:39:58.282]                         if (has_future) {
[17:39:58.282]                           ns <- base::getNamespace("future")
[17:39:58.282]                           version <- ns[[".package"]][["version"]]
[17:39:58.282]                           if (is.null(version)) 
[17:39:58.282]                             version <- utils::packageVersion("future")
[17:39:58.282]                         }
[17:39:58.282]                         else {
[17:39:58.282]                           version <- NULL
[17:39:58.282]                         }
[17:39:58.282]                         if (!has_future || version < "1.8.0") {
[17:39:58.282]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.282]                             "", base::R.version$version.string), 
[17:39:58.282]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.282]                               "release", "version")], collapse = " "), 
[17:39:58.282]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.282]                             info)
[17:39:58.282]                           info <- base::paste(info, collapse = "; ")
[17:39:58.282]                           if (!has_future) {
[17:39:58.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.282]                               info)
[17:39:58.282]                           }
[17:39:58.282]                           else {
[17:39:58.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.282]                               info, version)
[17:39:58.282]                           }
[17:39:58.282]                           base::stop(msg)
[17:39:58.282]                         }
[17:39:58.282]                       })
[17:39:58.282]                     }
[17:39:58.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.282]                     base::options(mc.cores = 1L)
[17:39:58.282]                   }
[17:39:58.282]                   ...future.strategy.old <- future::plan("list")
[17:39:58.282]                   options(future.plan = NULL)
[17:39:58.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.282]                 }
[17:39:58.282]                 ...future.workdir <- getwd()
[17:39:58.282]             }
[17:39:58.282]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.282]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.282]         }
[17:39:58.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.282]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.282]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.282]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.282]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.282]             base::names(...future.oldOptions))
[17:39:58.282]     }
[17:39:58.282]     if (FALSE) {
[17:39:58.282]     }
[17:39:58.282]     else {
[17:39:58.282]         if (TRUE) {
[17:39:58.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.282]                 open = "w")
[17:39:58.282]         }
[17:39:58.282]         else {
[17:39:58.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.282]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.282]         }
[17:39:58.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.282]             base::sink(type = "output", split = FALSE)
[17:39:58.282]             base::close(...future.stdout)
[17:39:58.282]         }, add = TRUE)
[17:39:58.282]     }
[17:39:58.282]     ...future.frame <- base::sys.nframe()
[17:39:58.282]     ...future.conditions <- base::list()
[17:39:58.282]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.282]     if (FALSE) {
[17:39:58.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.282]     }
[17:39:58.282]     ...future.result <- base::tryCatch({
[17:39:58.282]         base::withCallingHandlers({
[17:39:58.282]             ...future.value <- base::withVisible(base::local({
[17:39:58.282]                 ...future.makeSendCondition <- base::local({
[17:39:58.282]                   sendCondition <- NULL
[17:39:58.282]                   function(frame = 1L) {
[17:39:58.282]                     if (is.function(sendCondition)) 
[17:39:58.282]                       return(sendCondition)
[17:39:58.282]                     ns <- getNamespace("parallel")
[17:39:58.282]                     if (exists("sendData", mode = "function", 
[17:39:58.282]                       envir = ns)) {
[17:39:58.282]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.282]                         envir = ns)
[17:39:58.282]                       envir <- sys.frame(frame)
[17:39:58.282]                       master <- NULL
[17:39:58.282]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.282]                         !identical(envir, emptyenv())) {
[17:39:58.282]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.282]                           inherits = FALSE)) {
[17:39:58.282]                           master <- get("master", mode = "list", 
[17:39:58.282]                             envir = envir, inherits = FALSE)
[17:39:58.282]                           if (inherits(master, c("SOCKnode", 
[17:39:58.282]                             "SOCK0node"))) {
[17:39:58.282]                             sendCondition <<- function(cond) {
[17:39:58.282]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.282]                                 success = TRUE)
[17:39:58.282]                               parallel_sendData(master, data)
[17:39:58.282]                             }
[17:39:58.282]                             return(sendCondition)
[17:39:58.282]                           }
[17:39:58.282]                         }
[17:39:58.282]                         frame <- frame + 1L
[17:39:58.282]                         envir <- sys.frame(frame)
[17:39:58.282]                       }
[17:39:58.282]                     }
[17:39:58.282]                     sendCondition <<- function(cond) NULL
[17:39:58.282]                   }
[17:39:58.282]                 })
[17:39:58.282]                 withCallingHandlers({
[17:39:58.282]                   {
[17:39:58.282]                     b <- a * ii
[17:39:58.282]                     a <- 0
[17:39:58.282]                     b
[17:39:58.282]                   }
[17:39:58.282]                 }, immediateCondition = function(cond) {
[17:39:58.282]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.282]                   sendCondition(cond)
[17:39:58.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.282]                   {
[17:39:58.282]                     inherits <- base::inherits
[17:39:58.282]                     invokeRestart <- base::invokeRestart
[17:39:58.282]                     is.null <- base::is.null
[17:39:58.282]                     muffled <- FALSE
[17:39:58.282]                     if (inherits(cond, "message")) {
[17:39:58.282]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.282]                       if (muffled) 
[17:39:58.282]                         invokeRestart("muffleMessage")
[17:39:58.282]                     }
[17:39:58.282]                     else if (inherits(cond, "warning")) {
[17:39:58.282]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.282]                       if (muffled) 
[17:39:58.282]                         invokeRestart("muffleWarning")
[17:39:58.282]                     }
[17:39:58.282]                     else if (inherits(cond, "condition")) {
[17:39:58.282]                       if (!is.null(pattern)) {
[17:39:58.282]                         computeRestarts <- base::computeRestarts
[17:39:58.282]                         grepl <- base::grepl
[17:39:58.282]                         restarts <- computeRestarts(cond)
[17:39:58.282]                         for (restart in restarts) {
[17:39:58.282]                           name <- restart$name
[17:39:58.282]                           if (is.null(name)) 
[17:39:58.282]                             next
[17:39:58.282]                           if (!grepl(pattern, name)) 
[17:39:58.282]                             next
[17:39:58.282]                           invokeRestart(restart)
[17:39:58.282]                           muffled <- TRUE
[17:39:58.282]                           break
[17:39:58.282]                         }
[17:39:58.282]                       }
[17:39:58.282]                     }
[17:39:58.282]                     invisible(muffled)
[17:39:58.282]                   }
[17:39:58.282]                   muffleCondition(cond)
[17:39:58.282]                 })
[17:39:58.282]             }))
[17:39:58.282]             future::FutureResult(value = ...future.value$value, 
[17:39:58.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.282]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.282]                     ...future.globalenv.names))
[17:39:58.282]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.282]         }, condition = base::local({
[17:39:58.282]             c <- base::c
[17:39:58.282]             inherits <- base::inherits
[17:39:58.282]             invokeRestart <- base::invokeRestart
[17:39:58.282]             length <- base::length
[17:39:58.282]             list <- base::list
[17:39:58.282]             seq.int <- base::seq.int
[17:39:58.282]             signalCondition <- base::signalCondition
[17:39:58.282]             sys.calls <- base::sys.calls
[17:39:58.282]             `[[` <- base::`[[`
[17:39:58.282]             `+` <- base::`+`
[17:39:58.282]             `<<-` <- base::`<<-`
[17:39:58.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.282]                   3L)]
[17:39:58.282]             }
[17:39:58.282]             function(cond) {
[17:39:58.282]                 is_error <- inherits(cond, "error")
[17:39:58.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.282]                   NULL)
[17:39:58.282]                 if (is_error) {
[17:39:58.282]                   sessionInformation <- function() {
[17:39:58.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.282]                       search = base::search(), system = base::Sys.info())
[17:39:58.282]                   }
[17:39:58.282]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.282]                     cond$call), session = sessionInformation(), 
[17:39:58.282]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.282]                   signalCondition(cond)
[17:39:58.282]                 }
[17:39:58.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.282]                 "immediateCondition"))) {
[17:39:58.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.282]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.282]                   if (TRUE && !signal) {
[17:39:58.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.282]                     {
[17:39:58.282]                       inherits <- base::inherits
[17:39:58.282]                       invokeRestart <- base::invokeRestart
[17:39:58.282]                       is.null <- base::is.null
[17:39:58.282]                       muffled <- FALSE
[17:39:58.282]                       if (inherits(cond, "message")) {
[17:39:58.282]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.282]                         if (muffled) 
[17:39:58.282]                           invokeRestart("muffleMessage")
[17:39:58.282]                       }
[17:39:58.282]                       else if (inherits(cond, "warning")) {
[17:39:58.282]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.282]                         if (muffled) 
[17:39:58.282]                           invokeRestart("muffleWarning")
[17:39:58.282]                       }
[17:39:58.282]                       else if (inherits(cond, "condition")) {
[17:39:58.282]                         if (!is.null(pattern)) {
[17:39:58.282]                           computeRestarts <- base::computeRestarts
[17:39:58.282]                           grepl <- base::grepl
[17:39:58.282]                           restarts <- computeRestarts(cond)
[17:39:58.282]                           for (restart in restarts) {
[17:39:58.282]                             name <- restart$name
[17:39:58.282]                             if (is.null(name)) 
[17:39:58.282]                               next
[17:39:58.282]                             if (!grepl(pattern, name)) 
[17:39:58.282]                               next
[17:39:58.282]                             invokeRestart(restart)
[17:39:58.282]                             muffled <- TRUE
[17:39:58.282]                             break
[17:39:58.282]                           }
[17:39:58.282]                         }
[17:39:58.282]                       }
[17:39:58.282]                       invisible(muffled)
[17:39:58.282]                     }
[17:39:58.282]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.282]                   }
[17:39:58.282]                 }
[17:39:58.282]                 else {
[17:39:58.282]                   if (TRUE) {
[17:39:58.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.282]                     {
[17:39:58.282]                       inherits <- base::inherits
[17:39:58.282]                       invokeRestart <- base::invokeRestart
[17:39:58.282]                       is.null <- base::is.null
[17:39:58.282]                       muffled <- FALSE
[17:39:58.282]                       if (inherits(cond, "message")) {
[17:39:58.282]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.282]                         if (muffled) 
[17:39:58.282]                           invokeRestart("muffleMessage")
[17:39:58.282]                       }
[17:39:58.282]                       else if (inherits(cond, "warning")) {
[17:39:58.282]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.282]                         if (muffled) 
[17:39:58.282]                           invokeRestart("muffleWarning")
[17:39:58.282]                       }
[17:39:58.282]                       else if (inherits(cond, "condition")) {
[17:39:58.282]                         if (!is.null(pattern)) {
[17:39:58.282]                           computeRestarts <- base::computeRestarts
[17:39:58.282]                           grepl <- base::grepl
[17:39:58.282]                           restarts <- computeRestarts(cond)
[17:39:58.282]                           for (restart in restarts) {
[17:39:58.282]                             name <- restart$name
[17:39:58.282]                             if (is.null(name)) 
[17:39:58.282]                               next
[17:39:58.282]                             if (!grepl(pattern, name)) 
[17:39:58.282]                               next
[17:39:58.282]                             invokeRestart(restart)
[17:39:58.282]                             muffled <- TRUE
[17:39:58.282]                             break
[17:39:58.282]                           }
[17:39:58.282]                         }
[17:39:58.282]                       }
[17:39:58.282]                       invisible(muffled)
[17:39:58.282]                     }
[17:39:58.282]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.282]                   }
[17:39:58.282]                 }
[17:39:58.282]             }
[17:39:58.282]         }))
[17:39:58.282]     }, error = function(ex) {
[17:39:58.282]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.282]                 ...future.rng), started = ...future.startTime, 
[17:39:58.282]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.282]             version = "1.8"), class = "FutureResult")
[17:39:58.282]     }, finally = {
[17:39:58.282]         if (!identical(...future.workdir, getwd())) 
[17:39:58.282]             setwd(...future.workdir)
[17:39:58.282]         {
[17:39:58.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.282]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.282]             }
[17:39:58.282]             base::options(...future.oldOptions)
[17:39:58.282]             if (.Platform$OS.type == "windows") {
[17:39:58.282]                 old_names <- names(...future.oldEnvVars)
[17:39:58.282]                 envs <- base::Sys.getenv()
[17:39:58.282]                 names <- names(envs)
[17:39:58.282]                 common <- intersect(names, old_names)
[17:39:58.282]                 added <- setdiff(names, old_names)
[17:39:58.282]                 removed <- setdiff(old_names, names)
[17:39:58.282]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.282]                   envs[common]]
[17:39:58.282]                 NAMES <- toupper(changed)
[17:39:58.282]                 args <- list()
[17:39:58.282]                 for (kk in seq_along(NAMES)) {
[17:39:58.282]                   name <- changed[[kk]]
[17:39:58.282]                   NAME <- NAMES[[kk]]
[17:39:58.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.282]                     next
[17:39:58.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.282]                 }
[17:39:58.282]                 NAMES <- toupper(added)
[17:39:58.282]                 for (kk in seq_along(NAMES)) {
[17:39:58.282]                   name <- added[[kk]]
[17:39:58.282]                   NAME <- NAMES[[kk]]
[17:39:58.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.282]                     next
[17:39:58.282]                   args[[name]] <- ""
[17:39:58.282]                 }
[17:39:58.282]                 NAMES <- toupper(removed)
[17:39:58.282]                 for (kk in seq_along(NAMES)) {
[17:39:58.282]                   name <- removed[[kk]]
[17:39:58.282]                   NAME <- NAMES[[kk]]
[17:39:58.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.282]                     next
[17:39:58.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.282]                 }
[17:39:58.282]                 if (length(args) > 0) 
[17:39:58.282]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.282]             }
[17:39:58.282]             else {
[17:39:58.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.282]             }
[17:39:58.282]             {
[17:39:58.282]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.282]                   0L) {
[17:39:58.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.282]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.282]                   base::options(opts)
[17:39:58.282]                 }
[17:39:58.282]                 {
[17:39:58.282]                   {
[17:39:58.282]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.282]                     NULL
[17:39:58.282]                   }
[17:39:58.282]                   options(future.plan = NULL)
[17:39:58.282]                   if (is.na(NA_character_)) 
[17:39:58.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.282]                     .init = FALSE)
[17:39:58.282]                 }
[17:39:58.282]             }
[17:39:58.282]         }
[17:39:58.282]     })
[17:39:58.282]     if (TRUE) {
[17:39:58.282]         base::sink(type = "output", split = FALSE)
[17:39:58.282]         if (TRUE) {
[17:39:58.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.282]         }
[17:39:58.282]         else {
[17:39:58.282]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.282]         }
[17:39:58.282]         base::close(...future.stdout)
[17:39:58.282]         ...future.stdout <- NULL
[17:39:58.282]     }
[17:39:58.282]     ...future.result$conditions <- ...future.conditions
[17:39:58.282]     ...future.result$finished <- base::Sys.time()
[17:39:58.282]     ...future.result
[17:39:58.282] }
[17:39:58.284] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:58.295] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.295] - Validating connection of MultisessionFuture
[17:39:58.296] - received message: FutureResult
[17:39:58.296] - Received FutureResult
[17:39:58.296] - Erased future from FutureRegistry
[17:39:58.296] result() for ClusterFuture ...
[17:39:58.296] - result already collected: FutureResult
[17:39:58.296] result() for ClusterFuture ... done
[17:39:58.296] signalConditions() ...
[17:39:58.296]  - include = ‘immediateCondition’
[17:39:58.297]  - exclude = 
[17:39:58.297]  - resignal = FALSE
[17:39:58.297]  - Number of conditions: 1
[17:39:58.297] signalConditions() ... done
[17:39:58.297] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.297] result() for ClusterFuture ...
[17:39:58.297] - result already collected: FutureResult
[17:39:58.297] result() for ClusterFuture ... done
[17:39:58.297] result() for ClusterFuture ...
[17:39:58.297] - result already collected: FutureResult
[17:39:58.297] result() for ClusterFuture ... done
[17:39:58.298] signalConditions() ...
[17:39:58.298]  - include = ‘immediateCondition’
[17:39:58.298]  - exclude = 
[17:39:58.298]  - resignal = FALSE
[17:39:58.298]  - Number of conditions: 1
[17:39:58.298] signalConditions() ... done
[17:39:58.299] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:39:58.299] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:39:58.299] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:58.299] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:39:58.300] MultisessionFuture started
[17:39:58.300] - Launch lazy future ... done
[17:39:58.300] run() for ‘MultisessionFuture’ ... done
[17:39:58.300] result() for ClusterFuture ...
[17:39:58.301] - result already collected: FutureResult
[17:39:58.301] result() for ClusterFuture ... done
[17:39:58.301] result() for ClusterFuture ...
[17:39:58.301] - result already collected: FutureResult
[17:39:58.301] result() for ClusterFuture ... done
[17:39:58.301] signalConditions() ...
[17:39:58.301]  - include = ‘immediateCondition’
[17:39:58.302]  - exclude = 
[17:39:58.302]  - resignal = FALSE
[17:39:58.302]  - Number of conditions: 1
[17:39:58.302] signalConditions() ... done
[17:39:58.302] Future state: ‘finished’
[17:39:58.302] result() for ClusterFuture ...
[17:39:58.302] - result already collected: FutureResult
[17:39:58.303] result() for ClusterFuture ... done
[17:39:58.303] signalConditions() ...
[17:39:58.303]  - include = ‘condition’
[17:39:58.303]  - exclude = ‘immediateCondition’
[17:39:58.303]  - resignal = TRUE
[17:39:58.303]  - Number of conditions: 1
[17:39:58.303]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:58.303] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.318] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.318] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.320] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.320] Searching for globals ... DONE
[17:39:58.320] Resolving globals: TRUE
[17:39:58.320] Resolving any globals that are futures ...
[17:39:58.320] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.320] Resolving any globals that are futures ... DONE
[17:39:58.320] Resolving futures part of globals (recursively) ...
[17:39:58.321] resolve() on list ...
[17:39:58.321]  recursive: 99
[17:39:58.321]  length: 1
[17:39:58.321]  elements: ‘ii’
[17:39:58.321]  length: 0 (resolved future 1)
[17:39:58.321] resolve() on list ... DONE
[17:39:58.321] - globals: [1] ‘ii’
[17:39:58.321] Resolving futures part of globals (recursively) ... DONE
[17:39:58.321] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:58.322] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:58.322] - globals: [1] ‘ii’
[17:39:58.322] 
[17:39:58.322] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.323] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.323] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.324] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.324] Searching for globals ... DONE
[17:39:58.324] Resolving globals: TRUE
[17:39:58.324] Resolving any globals that are futures ...
[17:39:58.324] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.325] Resolving any globals that are futures ... DONE
[17:39:58.325] Resolving futures part of globals (recursively) ...
[17:39:58.325] resolve() on list ...
[17:39:58.325]  recursive: 99
[17:39:58.325]  length: 1
[17:39:58.325]  elements: ‘ii’
[17:39:58.325]  length: 0 (resolved future 1)
[17:39:58.326] resolve() on list ... DONE
[17:39:58.326] - globals: [1] ‘ii’
[17:39:58.326] Resolving futures part of globals (recursively) ... DONE
[17:39:58.326] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:58.326] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:58.326] - globals: [1] ‘ii’
[17:39:58.326] 
[17:39:58.326] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.327] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.327] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.328] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.329] Searching for globals ... DONE
[17:39:58.329] Resolving globals: TRUE
[17:39:58.329] Resolving any globals that are futures ...
[17:39:58.329] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:39:58.329] Resolving any globals that are futures ... DONE
[17:39:58.329] Resolving futures part of globals (recursively) ...
[17:39:58.329] resolve() on list ...
[17:39:58.330]  recursive: 99
[17:39:58.330]  length: 1
[17:39:58.330]  elements: ‘ii’
[17:39:58.330]  length: 0 (resolved future 1)
[17:39:58.330] resolve() on list ... DONE
[17:39:58.330] - globals: [1] ‘ii’
[17:39:58.330] Resolving futures part of globals (recursively) ... DONE
[17:39:58.330] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:58.330] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:39:58.331] - globals: [1] ‘ii’
[17:39:58.331] 
[17:39:58.331] getGlobalsAndPackages() ... DONE
[17:39:58.331] run() for ‘Future’ ...
[17:39:58.331] - state: ‘created’
[17:39:58.331] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.347] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.347]   - Field: ‘node’
[17:39:58.347]   - Field: ‘label’
[17:39:58.347]   - Field: ‘local’
[17:39:58.347]   - Field: ‘owner’
[17:39:58.348]   - Field: ‘envir’
[17:39:58.348]   - Field: ‘workers’
[17:39:58.348]   - Field: ‘packages’
[17:39:58.348]   - Field: ‘gc’
[17:39:58.348]   - Field: ‘conditions’
[17:39:58.348]   - Field: ‘persistent’
[17:39:58.348]   - Field: ‘expr’
[17:39:58.348]   - Field: ‘uuid’
[17:39:58.348]   - Field: ‘seed’
[17:39:58.348]   - Field: ‘version’
[17:39:58.348]   - Field: ‘result’
[17:39:58.349]   - Field: ‘asynchronous’
[17:39:58.349]   - Field: ‘calls’
[17:39:58.349]   - Field: ‘globals’
[17:39:58.349]   - Field: ‘stdout’
[17:39:58.349]   - Field: ‘earlySignal’
[17:39:58.349]   - Field: ‘lazy’
[17:39:58.349]   - Field: ‘state’
[17:39:58.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.349] - Launch lazy future ...
[17:39:58.350] Packages needed by the future expression (n = 0): <none>
[17:39:58.350] Packages needed by future strategies (n = 0): <none>
[17:39:58.350] {
[17:39:58.350]     {
[17:39:58.350]         {
[17:39:58.350]             ...future.startTime <- base::Sys.time()
[17:39:58.350]             {
[17:39:58.350]                 {
[17:39:58.350]                   {
[17:39:58.350]                     {
[17:39:58.350]                       base::local({
[17:39:58.350]                         has_future <- base::requireNamespace("future", 
[17:39:58.350]                           quietly = TRUE)
[17:39:58.350]                         if (has_future) {
[17:39:58.350]                           ns <- base::getNamespace("future")
[17:39:58.350]                           version <- ns[[".package"]][["version"]]
[17:39:58.350]                           if (is.null(version)) 
[17:39:58.350]                             version <- utils::packageVersion("future")
[17:39:58.350]                         }
[17:39:58.350]                         else {
[17:39:58.350]                           version <- NULL
[17:39:58.350]                         }
[17:39:58.350]                         if (!has_future || version < "1.8.0") {
[17:39:58.350]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.350]                             "", base::R.version$version.string), 
[17:39:58.350]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.350]                               "release", "version")], collapse = " "), 
[17:39:58.350]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.350]                             info)
[17:39:58.350]                           info <- base::paste(info, collapse = "; ")
[17:39:58.350]                           if (!has_future) {
[17:39:58.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.350]                               info)
[17:39:58.350]                           }
[17:39:58.350]                           else {
[17:39:58.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.350]                               info, version)
[17:39:58.350]                           }
[17:39:58.350]                           base::stop(msg)
[17:39:58.350]                         }
[17:39:58.350]                       })
[17:39:58.350]                     }
[17:39:58.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.350]                     base::options(mc.cores = 1L)
[17:39:58.350]                   }
[17:39:58.350]                   ...future.strategy.old <- future::plan("list")
[17:39:58.350]                   options(future.plan = NULL)
[17:39:58.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.350]                 }
[17:39:58.350]                 ...future.workdir <- getwd()
[17:39:58.350]             }
[17:39:58.350]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.350]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.350]         }
[17:39:58.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.350]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.350]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.350]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.350]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.350]             base::names(...future.oldOptions))
[17:39:58.350]     }
[17:39:58.350]     if (FALSE) {
[17:39:58.350]     }
[17:39:58.350]     else {
[17:39:58.350]         if (TRUE) {
[17:39:58.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.350]                 open = "w")
[17:39:58.350]         }
[17:39:58.350]         else {
[17:39:58.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.350]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.350]         }
[17:39:58.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.350]             base::sink(type = "output", split = FALSE)
[17:39:58.350]             base::close(...future.stdout)
[17:39:58.350]         }, add = TRUE)
[17:39:58.350]     }
[17:39:58.350]     ...future.frame <- base::sys.nframe()
[17:39:58.350]     ...future.conditions <- base::list()
[17:39:58.350]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.350]     if (FALSE) {
[17:39:58.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.350]     }
[17:39:58.350]     ...future.result <- base::tryCatch({
[17:39:58.350]         base::withCallingHandlers({
[17:39:58.350]             ...future.value <- base::withVisible(base::local({
[17:39:58.350]                 ...future.makeSendCondition <- base::local({
[17:39:58.350]                   sendCondition <- NULL
[17:39:58.350]                   function(frame = 1L) {
[17:39:58.350]                     if (is.function(sendCondition)) 
[17:39:58.350]                       return(sendCondition)
[17:39:58.350]                     ns <- getNamespace("parallel")
[17:39:58.350]                     if (exists("sendData", mode = "function", 
[17:39:58.350]                       envir = ns)) {
[17:39:58.350]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.350]                         envir = ns)
[17:39:58.350]                       envir <- sys.frame(frame)
[17:39:58.350]                       master <- NULL
[17:39:58.350]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.350]                         !identical(envir, emptyenv())) {
[17:39:58.350]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.350]                           inherits = FALSE)) {
[17:39:58.350]                           master <- get("master", mode = "list", 
[17:39:58.350]                             envir = envir, inherits = FALSE)
[17:39:58.350]                           if (inherits(master, c("SOCKnode", 
[17:39:58.350]                             "SOCK0node"))) {
[17:39:58.350]                             sendCondition <<- function(cond) {
[17:39:58.350]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.350]                                 success = TRUE)
[17:39:58.350]                               parallel_sendData(master, data)
[17:39:58.350]                             }
[17:39:58.350]                             return(sendCondition)
[17:39:58.350]                           }
[17:39:58.350]                         }
[17:39:58.350]                         frame <- frame + 1L
[17:39:58.350]                         envir <- sys.frame(frame)
[17:39:58.350]                       }
[17:39:58.350]                     }
[17:39:58.350]                     sendCondition <<- function(cond) NULL
[17:39:58.350]                   }
[17:39:58.350]                 })
[17:39:58.350]                 withCallingHandlers({
[17:39:58.350]                   {
[17:39:58.350]                     b <- a * ii
[17:39:58.350]                     a <- 0
[17:39:58.350]                     b
[17:39:58.350]                   }
[17:39:58.350]                 }, immediateCondition = function(cond) {
[17:39:58.350]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.350]                   sendCondition(cond)
[17:39:58.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.350]                   {
[17:39:58.350]                     inherits <- base::inherits
[17:39:58.350]                     invokeRestart <- base::invokeRestart
[17:39:58.350]                     is.null <- base::is.null
[17:39:58.350]                     muffled <- FALSE
[17:39:58.350]                     if (inherits(cond, "message")) {
[17:39:58.350]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.350]                       if (muffled) 
[17:39:58.350]                         invokeRestart("muffleMessage")
[17:39:58.350]                     }
[17:39:58.350]                     else if (inherits(cond, "warning")) {
[17:39:58.350]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.350]                       if (muffled) 
[17:39:58.350]                         invokeRestart("muffleWarning")
[17:39:58.350]                     }
[17:39:58.350]                     else if (inherits(cond, "condition")) {
[17:39:58.350]                       if (!is.null(pattern)) {
[17:39:58.350]                         computeRestarts <- base::computeRestarts
[17:39:58.350]                         grepl <- base::grepl
[17:39:58.350]                         restarts <- computeRestarts(cond)
[17:39:58.350]                         for (restart in restarts) {
[17:39:58.350]                           name <- restart$name
[17:39:58.350]                           if (is.null(name)) 
[17:39:58.350]                             next
[17:39:58.350]                           if (!grepl(pattern, name)) 
[17:39:58.350]                             next
[17:39:58.350]                           invokeRestart(restart)
[17:39:58.350]                           muffled <- TRUE
[17:39:58.350]                           break
[17:39:58.350]                         }
[17:39:58.350]                       }
[17:39:58.350]                     }
[17:39:58.350]                     invisible(muffled)
[17:39:58.350]                   }
[17:39:58.350]                   muffleCondition(cond)
[17:39:58.350]                 })
[17:39:58.350]             }))
[17:39:58.350]             future::FutureResult(value = ...future.value$value, 
[17:39:58.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.350]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.350]                     ...future.globalenv.names))
[17:39:58.350]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.350]         }, condition = base::local({
[17:39:58.350]             c <- base::c
[17:39:58.350]             inherits <- base::inherits
[17:39:58.350]             invokeRestart <- base::invokeRestart
[17:39:58.350]             length <- base::length
[17:39:58.350]             list <- base::list
[17:39:58.350]             seq.int <- base::seq.int
[17:39:58.350]             signalCondition <- base::signalCondition
[17:39:58.350]             sys.calls <- base::sys.calls
[17:39:58.350]             `[[` <- base::`[[`
[17:39:58.350]             `+` <- base::`+`
[17:39:58.350]             `<<-` <- base::`<<-`
[17:39:58.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.350]                   3L)]
[17:39:58.350]             }
[17:39:58.350]             function(cond) {
[17:39:58.350]                 is_error <- inherits(cond, "error")
[17:39:58.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.350]                   NULL)
[17:39:58.350]                 if (is_error) {
[17:39:58.350]                   sessionInformation <- function() {
[17:39:58.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.350]                       search = base::search(), system = base::Sys.info())
[17:39:58.350]                   }
[17:39:58.350]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.350]                     cond$call), session = sessionInformation(), 
[17:39:58.350]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.350]                   signalCondition(cond)
[17:39:58.350]                 }
[17:39:58.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.350]                 "immediateCondition"))) {
[17:39:58.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.350]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.350]                   if (TRUE && !signal) {
[17:39:58.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.350]                     {
[17:39:58.350]                       inherits <- base::inherits
[17:39:58.350]                       invokeRestart <- base::invokeRestart
[17:39:58.350]                       is.null <- base::is.null
[17:39:58.350]                       muffled <- FALSE
[17:39:58.350]                       if (inherits(cond, "message")) {
[17:39:58.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.350]                         if (muffled) 
[17:39:58.350]                           invokeRestart("muffleMessage")
[17:39:58.350]                       }
[17:39:58.350]                       else if (inherits(cond, "warning")) {
[17:39:58.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.350]                         if (muffled) 
[17:39:58.350]                           invokeRestart("muffleWarning")
[17:39:58.350]                       }
[17:39:58.350]                       else if (inherits(cond, "condition")) {
[17:39:58.350]                         if (!is.null(pattern)) {
[17:39:58.350]                           computeRestarts <- base::computeRestarts
[17:39:58.350]                           grepl <- base::grepl
[17:39:58.350]                           restarts <- computeRestarts(cond)
[17:39:58.350]                           for (restart in restarts) {
[17:39:58.350]                             name <- restart$name
[17:39:58.350]                             if (is.null(name)) 
[17:39:58.350]                               next
[17:39:58.350]                             if (!grepl(pattern, name)) 
[17:39:58.350]                               next
[17:39:58.350]                             invokeRestart(restart)
[17:39:58.350]                             muffled <- TRUE
[17:39:58.350]                             break
[17:39:58.350]                           }
[17:39:58.350]                         }
[17:39:58.350]                       }
[17:39:58.350]                       invisible(muffled)
[17:39:58.350]                     }
[17:39:58.350]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.350]                   }
[17:39:58.350]                 }
[17:39:58.350]                 else {
[17:39:58.350]                   if (TRUE) {
[17:39:58.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.350]                     {
[17:39:58.350]                       inherits <- base::inherits
[17:39:58.350]                       invokeRestart <- base::invokeRestart
[17:39:58.350]                       is.null <- base::is.null
[17:39:58.350]                       muffled <- FALSE
[17:39:58.350]                       if (inherits(cond, "message")) {
[17:39:58.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.350]                         if (muffled) 
[17:39:58.350]                           invokeRestart("muffleMessage")
[17:39:58.350]                       }
[17:39:58.350]                       else if (inherits(cond, "warning")) {
[17:39:58.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.350]                         if (muffled) 
[17:39:58.350]                           invokeRestart("muffleWarning")
[17:39:58.350]                       }
[17:39:58.350]                       else if (inherits(cond, "condition")) {
[17:39:58.350]                         if (!is.null(pattern)) {
[17:39:58.350]                           computeRestarts <- base::computeRestarts
[17:39:58.350]                           grepl <- base::grepl
[17:39:58.350]                           restarts <- computeRestarts(cond)
[17:39:58.350]                           for (restart in restarts) {
[17:39:58.350]                             name <- restart$name
[17:39:58.350]                             if (is.null(name)) 
[17:39:58.350]                               next
[17:39:58.350]                             if (!grepl(pattern, name)) 
[17:39:58.350]                               next
[17:39:58.350]                             invokeRestart(restart)
[17:39:58.350]                             muffled <- TRUE
[17:39:58.350]                             break
[17:39:58.350]                           }
[17:39:58.350]                         }
[17:39:58.350]                       }
[17:39:58.350]                       invisible(muffled)
[17:39:58.350]                     }
[17:39:58.350]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.350]                   }
[17:39:58.350]                 }
[17:39:58.350]             }
[17:39:58.350]         }))
[17:39:58.350]     }, error = function(ex) {
[17:39:58.350]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.350]                 ...future.rng), started = ...future.startTime, 
[17:39:58.350]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.350]             version = "1.8"), class = "FutureResult")
[17:39:58.350]     }, finally = {
[17:39:58.350]         if (!identical(...future.workdir, getwd())) 
[17:39:58.350]             setwd(...future.workdir)
[17:39:58.350]         {
[17:39:58.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.350]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.350]             }
[17:39:58.350]             base::options(...future.oldOptions)
[17:39:58.350]             if (.Platform$OS.type == "windows") {
[17:39:58.350]                 old_names <- names(...future.oldEnvVars)
[17:39:58.350]                 envs <- base::Sys.getenv()
[17:39:58.350]                 names <- names(envs)
[17:39:58.350]                 common <- intersect(names, old_names)
[17:39:58.350]                 added <- setdiff(names, old_names)
[17:39:58.350]                 removed <- setdiff(old_names, names)
[17:39:58.350]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.350]                   envs[common]]
[17:39:58.350]                 NAMES <- toupper(changed)
[17:39:58.350]                 args <- list()
[17:39:58.350]                 for (kk in seq_along(NAMES)) {
[17:39:58.350]                   name <- changed[[kk]]
[17:39:58.350]                   NAME <- NAMES[[kk]]
[17:39:58.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.350]                     next
[17:39:58.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.350]                 }
[17:39:58.350]                 NAMES <- toupper(added)
[17:39:58.350]                 for (kk in seq_along(NAMES)) {
[17:39:58.350]                   name <- added[[kk]]
[17:39:58.350]                   NAME <- NAMES[[kk]]
[17:39:58.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.350]                     next
[17:39:58.350]                   args[[name]] <- ""
[17:39:58.350]                 }
[17:39:58.350]                 NAMES <- toupper(removed)
[17:39:58.350]                 for (kk in seq_along(NAMES)) {
[17:39:58.350]                   name <- removed[[kk]]
[17:39:58.350]                   NAME <- NAMES[[kk]]
[17:39:58.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.350]                     next
[17:39:58.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.350]                 }
[17:39:58.350]                 if (length(args) > 0) 
[17:39:58.350]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.350]             }
[17:39:58.350]             else {
[17:39:58.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.350]             }
[17:39:58.350]             {
[17:39:58.350]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.350]                   0L) {
[17:39:58.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.350]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.350]                   base::options(opts)
[17:39:58.350]                 }
[17:39:58.350]                 {
[17:39:58.350]                   {
[17:39:58.350]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.350]                     NULL
[17:39:58.350]                   }
[17:39:58.350]                   options(future.plan = NULL)
[17:39:58.350]                   if (is.na(NA_character_)) 
[17:39:58.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.350]                     .init = FALSE)
[17:39:58.350]                 }
[17:39:58.350]             }
[17:39:58.350]         }
[17:39:58.350]     })
[17:39:58.350]     if (TRUE) {
[17:39:58.350]         base::sink(type = "output", split = FALSE)
[17:39:58.350]         if (TRUE) {
[17:39:58.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.350]         }
[17:39:58.350]         else {
[17:39:58.350]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.350]         }
[17:39:58.350]         base::close(...future.stdout)
[17:39:58.350]         ...future.stdout <- NULL
[17:39:58.350]     }
[17:39:58.350]     ...future.result$conditions <- ...future.conditions
[17:39:58.350]     ...future.result$finished <- base::Sys.time()
[17:39:58.350]     ...future.result
[17:39:58.350] }
[17:39:58.352] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:58.363] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.363] - Validating connection of MultisessionFuture
[17:39:58.363] - received message: FutureResult
[17:39:58.364] - Received FutureResult
[17:39:58.364] - Erased future from FutureRegistry
[17:39:58.364] result() for ClusterFuture ...
[17:39:58.364] - result already collected: FutureResult
[17:39:58.364] result() for ClusterFuture ... done
[17:39:58.364] signalConditions() ...
[17:39:58.364]  - include = ‘immediateCondition’
[17:39:58.364]  - exclude = 
[17:39:58.364]  - resignal = FALSE
[17:39:58.364]  - Number of conditions: 1
[17:39:58.364] signalConditions() ... done
[17:39:58.365] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.365] result() for ClusterFuture ...
[17:39:58.365] - result already collected: FutureResult
[17:39:58.365] result() for ClusterFuture ... done
[17:39:58.365] result() for ClusterFuture ...
[17:39:58.365] - result already collected: FutureResult
[17:39:58.365] result() for ClusterFuture ... done
[17:39:58.365] signalConditions() ...
[17:39:58.365]  - include = ‘immediateCondition’
[17:39:58.365]  - exclude = 
[17:39:58.365]  - resignal = FALSE
[17:39:58.366]  - Number of conditions: 1
[17:39:58.366] signalConditions() ... done
[17:39:58.366] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:39:58.366] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:39:58.367] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:58.367] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:39:58.367] MultisessionFuture started
[17:39:58.367] - Launch lazy future ... done
[17:39:58.367] run() for ‘MultisessionFuture’ ... done
[17:39:58.368] result() for ClusterFuture ...
[17:39:58.368] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.368] - Validating connection of MultisessionFuture
[17:39:58.369] - received message: FutureResult
[17:39:58.369] - Received FutureResult
[17:39:58.370] - Erased future from FutureRegistry
[17:39:58.370] result() for ClusterFuture ...
[17:39:58.370] - result already collected: FutureResult
[17:39:58.370] result() for ClusterFuture ... done
[17:39:58.370] signalConditions() ...
[17:39:58.370]  - include = ‘immediateCondition’
[17:39:58.370]  - exclude = 
[17:39:58.370]  - resignal = FALSE
[17:39:58.370]  - Number of conditions: 1
[17:39:58.370] signalConditions() ... done
[17:39:58.370] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.371] result() for ClusterFuture ... done
[17:39:58.371] result() for ClusterFuture ...
[17:39:58.371] - result already collected: FutureResult
[17:39:58.371] result() for ClusterFuture ... done
[17:39:58.371] signalConditions() ...
[17:39:58.371]  - include = ‘immediateCondition’
[17:39:58.371]  - exclude = 
[17:39:58.371]  - resignal = FALSE
[17:39:58.371]  - Number of conditions: 1
[17:39:58.371] signalConditions() ... done
[17:39:58.371] Future state: ‘finished’
[17:39:58.372] result() for ClusterFuture ...
[17:39:58.372] - result already collected: FutureResult
[17:39:58.372] result() for ClusterFuture ... done
[17:39:58.372] signalConditions() ...
[17:39:58.372]  - include = ‘condition’
[17:39:58.372]  - exclude = ‘immediateCondition’
[17:39:58.372]  - resignal = TRUE
[17:39:58.372]  - Number of conditions: 1
[17:39:58.372]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:39:58.372] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:39:58"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.386] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.386] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.386] 
[17:39:58.386] Searching for globals ... DONE
[17:39:58.387] - globals: [0] <none>
[17:39:58.387] getGlobalsAndPackages() ... DONE
[17:39:58.387] run() for ‘Future’ ...
[17:39:58.387] - state: ‘created’
[17:39:58.387] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.401]   - Field: ‘node’
[17:39:58.401]   - Field: ‘label’
[17:39:58.401]   - Field: ‘local’
[17:39:58.401]   - Field: ‘owner’
[17:39:58.401]   - Field: ‘envir’
[17:39:58.401]   - Field: ‘workers’
[17:39:58.401]   - Field: ‘packages’
[17:39:58.401]   - Field: ‘gc’
[17:39:58.402]   - Field: ‘conditions’
[17:39:58.402]   - Field: ‘persistent’
[17:39:58.402]   - Field: ‘expr’
[17:39:58.402]   - Field: ‘uuid’
[17:39:58.402]   - Field: ‘seed’
[17:39:58.402]   - Field: ‘version’
[17:39:58.402]   - Field: ‘result’
[17:39:58.402]   - Field: ‘asynchronous’
[17:39:58.402]   - Field: ‘calls’
[17:39:58.402]   - Field: ‘globals’
[17:39:58.402]   - Field: ‘stdout’
[17:39:58.402]   - Field: ‘earlySignal’
[17:39:58.403]   - Field: ‘lazy’
[17:39:58.403]   - Field: ‘state’
[17:39:58.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.403] - Launch lazy future ...
[17:39:58.403] Packages needed by the future expression (n = 0): <none>
[17:39:58.403] Packages needed by future strategies (n = 0): <none>
[17:39:58.404] {
[17:39:58.404]     {
[17:39:58.404]         {
[17:39:58.404]             ...future.startTime <- base::Sys.time()
[17:39:58.404]             {
[17:39:58.404]                 {
[17:39:58.404]                   {
[17:39:58.404]                     {
[17:39:58.404]                       base::local({
[17:39:58.404]                         has_future <- base::requireNamespace("future", 
[17:39:58.404]                           quietly = TRUE)
[17:39:58.404]                         if (has_future) {
[17:39:58.404]                           ns <- base::getNamespace("future")
[17:39:58.404]                           version <- ns[[".package"]][["version"]]
[17:39:58.404]                           if (is.null(version)) 
[17:39:58.404]                             version <- utils::packageVersion("future")
[17:39:58.404]                         }
[17:39:58.404]                         else {
[17:39:58.404]                           version <- NULL
[17:39:58.404]                         }
[17:39:58.404]                         if (!has_future || version < "1.8.0") {
[17:39:58.404]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.404]                             "", base::R.version$version.string), 
[17:39:58.404]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.404]                               "release", "version")], collapse = " "), 
[17:39:58.404]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.404]                             info)
[17:39:58.404]                           info <- base::paste(info, collapse = "; ")
[17:39:58.404]                           if (!has_future) {
[17:39:58.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.404]                               info)
[17:39:58.404]                           }
[17:39:58.404]                           else {
[17:39:58.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.404]                               info, version)
[17:39:58.404]                           }
[17:39:58.404]                           base::stop(msg)
[17:39:58.404]                         }
[17:39:58.404]                       })
[17:39:58.404]                     }
[17:39:58.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.404]                     base::options(mc.cores = 1L)
[17:39:58.404]                   }
[17:39:58.404]                   ...future.strategy.old <- future::plan("list")
[17:39:58.404]                   options(future.plan = NULL)
[17:39:58.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.404]                 }
[17:39:58.404]                 ...future.workdir <- getwd()
[17:39:58.404]             }
[17:39:58.404]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.404]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.404]         }
[17:39:58.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.404]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.404]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.404]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.404]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.404]             base::names(...future.oldOptions))
[17:39:58.404]     }
[17:39:58.404]     if (FALSE) {
[17:39:58.404]     }
[17:39:58.404]     else {
[17:39:58.404]         if (TRUE) {
[17:39:58.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.404]                 open = "w")
[17:39:58.404]         }
[17:39:58.404]         else {
[17:39:58.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.404]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.404]         }
[17:39:58.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.404]             base::sink(type = "output", split = FALSE)
[17:39:58.404]             base::close(...future.stdout)
[17:39:58.404]         }, add = TRUE)
[17:39:58.404]     }
[17:39:58.404]     ...future.frame <- base::sys.nframe()
[17:39:58.404]     ...future.conditions <- base::list()
[17:39:58.404]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.404]     if (FALSE) {
[17:39:58.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.404]     }
[17:39:58.404]     ...future.result <- base::tryCatch({
[17:39:58.404]         base::withCallingHandlers({
[17:39:58.404]             ...future.value <- base::withVisible(base::local({
[17:39:58.404]                 ...future.makeSendCondition <- base::local({
[17:39:58.404]                   sendCondition <- NULL
[17:39:58.404]                   function(frame = 1L) {
[17:39:58.404]                     if (is.function(sendCondition)) 
[17:39:58.404]                       return(sendCondition)
[17:39:58.404]                     ns <- getNamespace("parallel")
[17:39:58.404]                     if (exists("sendData", mode = "function", 
[17:39:58.404]                       envir = ns)) {
[17:39:58.404]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.404]                         envir = ns)
[17:39:58.404]                       envir <- sys.frame(frame)
[17:39:58.404]                       master <- NULL
[17:39:58.404]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.404]                         !identical(envir, emptyenv())) {
[17:39:58.404]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.404]                           inherits = FALSE)) {
[17:39:58.404]                           master <- get("master", mode = "list", 
[17:39:58.404]                             envir = envir, inherits = FALSE)
[17:39:58.404]                           if (inherits(master, c("SOCKnode", 
[17:39:58.404]                             "SOCK0node"))) {
[17:39:58.404]                             sendCondition <<- function(cond) {
[17:39:58.404]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.404]                                 success = TRUE)
[17:39:58.404]                               parallel_sendData(master, data)
[17:39:58.404]                             }
[17:39:58.404]                             return(sendCondition)
[17:39:58.404]                           }
[17:39:58.404]                         }
[17:39:58.404]                         frame <- frame + 1L
[17:39:58.404]                         envir <- sys.frame(frame)
[17:39:58.404]                       }
[17:39:58.404]                     }
[17:39:58.404]                     sendCondition <<- function(cond) NULL
[17:39:58.404]                   }
[17:39:58.404]                 })
[17:39:58.404]                 withCallingHandlers({
[17:39:58.404]                   1
[17:39:58.404]                 }, immediateCondition = function(cond) {
[17:39:58.404]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.404]                   sendCondition(cond)
[17:39:58.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.404]                   {
[17:39:58.404]                     inherits <- base::inherits
[17:39:58.404]                     invokeRestart <- base::invokeRestart
[17:39:58.404]                     is.null <- base::is.null
[17:39:58.404]                     muffled <- FALSE
[17:39:58.404]                     if (inherits(cond, "message")) {
[17:39:58.404]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.404]                       if (muffled) 
[17:39:58.404]                         invokeRestart("muffleMessage")
[17:39:58.404]                     }
[17:39:58.404]                     else if (inherits(cond, "warning")) {
[17:39:58.404]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.404]                       if (muffled) 
[17:39:58.404]                         invokeRestart("muffleWarning")
[17:39:58.404]                     }
[17:39:58.404]                     else if (inherits(cond, "condition")) {
[17:39:58.404]                       if (!is.null(pattern)) {
[17:39:58.404]                         computeRestarts <- base::computeRestarts
[17:39:58.404]                         grepl <- base::grepl
[17:39:58.404]                         restarts <- computeRestarts(cond)
[17:39:58.404]                         for (restart in restarts) {
[17:39:58.404]                           name <- restart$name
[17:39:58.404]                           if (is.null(name)) 
[17:39:58.404]                             next
[17:39:58.404]                           if (!grepl(pattern, name)) 
[17:39:58.404]                             next
[17:39:58.404]                           invokeRestart(restart)
[17:39:58.404]                           muffled <- TRUE
[17:39:58.404]                           break
[17:39:58.404]                         }
[17:39:58.404]                       }
[17:39:58.404]                     }
[17:39:58.404]                     invisible(muffled)
[17:39:58.404]                   }
[17:39:58.404]                   muffleCondition(cond)
[17:39:58.404]                 })
[17:39:58.404]             }))
[17:39:58.404]             future::FutureResult(value = ...future.value$value, 
[17:39:58.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.404]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.404]                     ...future.globalenv.names))
[17:39:58.404]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.404]         }, condition = base::local({
[17:39:58.404]             c <- base::c
[17:39:58.404]             inherits <- base::inherits
[17:39:58.404]             invokeRestart <- base::invokeRestart
[17:39:58.404]             length <- base::length
[17:39:58.404]             list <- base::list
[17:39:58.404]             seq.int <- base::seq.int
[17:39:58.404]             signalCondition <- base::signalCondition
[17:39:58.404]             sys.calls <- base::sys.calls
[17:39:58.404]             `[[` <- base::`[[`
[17:39:58.404]             `+` <- base::`+`
[17:39:58.404]             `<<-` <- base::`<<-`
[17:39:58.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.404]                   3L)]
[17:39:58.404]             }
[17:39:58.404]             function(cond) {
[17:39:58.404]                 is_error <- inherits(cond, "error")
[17:39:58.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.404]                   NULL)
[17:39:58.404]                 if (is_error) {
[17:39:58.404]                   sessionInformation <- function() {
[17:39:58.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.404]                       search = base::search(), system = base::Sys.info())
[17:39:58.404]                   }
[17:39:58.404]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.404]                     cond$call), session = sessionInformation(), 
[17:39:58.404]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.404]                   signalCondition(cond)
[17:39:58.404]                 }
[17:39:58.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.404]                 "immediateCondition"))) {
[17:39:58.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.404]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.404]                   if (TRUE && !signal) {
[17:39:58.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.404]                     {
[17:39:58.404]                       inherits <- base::inherits
[17:39:58.404]                       invokeRestart <- base::invokeRestart
[17:39:58.404]                       is.null <- base::is.null
[17:39:58.404]                       muffled <- FALSE
[17:39:58.404]                       if (inherits(cond, "message")) {
[17:39:58.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.404]                         if (muffled) 
[17:39:58.404]                           invokeRestart("muffleMessage")
[17:39:58.404]                       }
[17:39:58.404]                       else if (inherits(cond, "warning")) {
[17:39:58.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.404]                         if (muffled) 
[17:39:58.404]                           invokeRestart("muffleWarning")
[17:39:58.404]                       }
[17:39:58.404]                       else if (inherits(cond, "condition")) {
[17:39:58.404]                         if (!is.null(pattern)) {
[17:39:58.404]                           computeRestarts <- base::computeRestarts
[17:39:58.404]                           grepl <- base::grepl
[17:39:58.404]                           restarts <- computeRestarts(cond)
[17:39:58.404]                           for (restart in restarts) {
[17:39:58.404]                             name <- restart$name
[17:39:58.404]                             if (is.null(name)) 
[17:39:58.404]                               next
[17:39:58.404]                             if (!grepl(pattern, name)) 
[17:39:58.404]                               next
[17:39:58.404]                             invokeRestart(restart)
[17:39:58.404]                             muffled <- TRUE
[17:39:58.404]                             break
[17:39:58.404]                           }
[17:39:58.404]                         }
[17:39:58.404]                       }
[17:39:58.404]                       invisible(muffled)
[17:39:58.404]                     }
[17:39:58.404]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.404]                   }
[17:39:58.404]                 }
[17:39:58.404]                 else {
[17:39:58.404]                   if (TRUE) {
[17:39:58.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.404]                     {
[17:39:58.404]                       inherits <- base::inherits
[17:39:58.404]                       invokeRestart <- base::invokeRestart
[17:39:58.404]                       is.null <- base::is.null
[17:39:58.404]                       muffled <- FALSE
[17:39:58.404]                       if (inherits(cond, "message")) {
[17:39:58.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.404]                         if (muffled) 
[17:39:58.404]                           invokeRestart("muffleMessage")
[17:39:58.404]                       }
[17:39:58.404]                       else if (inherits(cond, "warning")) {
[17:39:58.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.404]                         if (muffled) 
[17:39:58.404]                           invokeRestart("muffleWarning")
[17:39:58.404]                       }
[17:39:58.404]                       else if (inherits(cond, "condition")) {
[17:39:58.404]                         if (!is.null(pattern)) {
[17:39:58.404]                           computeRestarts <- base::computeRestarts
[17:39:58.404]                           grepl <- base::grepl
[17:39:58.404]                           restarts <- computeRestarts(cond)
[17:39:58.404]                           for (restart in restarts) {
[17:39:58.404]                             name <- restart$name
[17:39:58.404]                             if (is.null(name)) 
[17:39:58.404]                               next
[17:39:58.404]                             if (!grepl(pattern, name)) 
[17:39:58.404]                               next
[17:39:58.404]                             invokeRestart(restart)
[17:39:58.404]                             muffled <- TRUE
[17:39:58.404]                             break
[17:39:58.404]                           }
[17:39:58.404]                         }
[17:39:58.404]                       }
[17:39:58.404]                       invisible(muffled)
[17:39:58.404]                     }
[17:39:58.404]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.404]                   }
[17:39:58.404]                 }
[17:39:58.404]             }
[17:39:58.404]         }))
[17:39:58.404]     }, error = function(ex) {
[17:39:58.404]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.404]                 ...future.rng), started = ...future.startTime, 
[17:39:58.404]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.404]             version = "1.8"), class = "FutureResult")
[17:39:58.404]     }, finally = {
[17:39:58.404]         if (!identical(...future.workdir, getwd())) 
[17:39:58.404]             setwd(...future.workdir)
[17:39:58.404]         {
[17:39:58.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.404]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.404]             }
[17:39:58.404]             base::options(...future.oldOptions)
[17:39:58.404]             if (.Platform$OS.type == "windows") {
[17:39:58.404]                 old_names <- names(...future.oldEnvVars)
[17:39:58.404]                 envs <- base::Sys.getenv()
[17:39:58.404]                 names <- names(envs)
[17:39:58.404]                 common <- intersect(names, old_names)
[17:39:58.404]                 added <- setdiff(names, old_names)
[17:39:58.404]                 removed <- setdiff(old_names, names)
[17:39:58.404]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.404]                   envs[common]]
[17:39:58.404]                 NAMES <- toupper(changed)
[17:39:58.404]                 args <- list()
[17:39:58.404]                 for (kk in seq_along(NAMES)) {
[17:39:58.404]                   name <- changed[[kk]]
[17:39:58.404]                   NAME <- NAMES[[kk]]
[17:39:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.404]                     next
[17:39:58.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.404]                 }
[17:39:58.404]                 NAMES <- toupper(added)
[17:39:58.404]                 for (kk in seq_along(NAMES)) {
[17:39:58.404]                   name <- added[[kk]]
[17:39:58.404]                   NAME <- NAMES[[kk]]
[17:39:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.404]                     next
[17:39:58.404]                   args[[name]] <- ""
[17:39:58.404]                 }
[17:39:58.404]                 NAMES <- toupper(removed)
[17:39:58.404]                 for (kk in seq_along(NAMES)) {
[17:39:58.404]                   name <- removed[[kk]]
[17:39:58.404]                   NAME <- NAMES[[kk]]
[17:39:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.404]                     next
[17:39:58.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.404]                 }
[17:39:58.404]                 if (length(args) > 0) 
[17:39:58.404]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.404]             }
[17:39:58.404]             else {
[17:39:58.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.404]             }
[17:39:58.404]             {
[17:39:58.404]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.404]                   0L) {
[17:39:58.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.404]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.404]                   base::options(opts)
[17:39:58.404]                 }
[17:39:58.404]                 {
[17:39:58.404]                   {
[17:39:58.404]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.404]                     NULL
[17:39:58.404]                   }
[17:39:58.404]                   options(future.plan = NULL)
[17:39:58.404]                   if (is.na(NA_character_)) 
[17:39:58.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.404]                     .init = FALSE)
[17:39:58.404]                 }
[17:39:58.404]             }
[17:39:58.404]         }
[17:39:58.404]     })
[17:39:58.404]     if (TRUE) {
[17:39:58.404]         base::sink(type = "output", split = FALSE)
[17:39:58.404]         if (TRUE) {
[17:39:58.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.404]         }
[17:39:58.404]         else {
[17:39:58.404]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.404]         }
[17:39:58.404]         base::close(...future.stdout)
[17:39:58.404]         ...future.stdout <- NULL
[17:39:58.404]     }
[17:39:58.404]     ...future.result$conditions <- ...future.conditions
[17:39:58.404]     ...future.result$finished <- base::Sys.time()
[17:39:58.404]     ...future.result
[17:39:58.404] }
[17:39:58.406] MultisessionFuture started
[17:39:58.406] - Launch lazy future ... done
[17:39:58.406] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.407] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.407] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.408] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:58.408] Searching for globals ... DONE
[17:39:58.408] Resolving globals: TRUE
[17:39:58.409] Resolving any globals that are futures ...
[17:39:58.409] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:58.409] Resolving any globals that are futures ... DONE
[17:39:58.409] Resolving futures part of globals (recursively) ...
[17:39:58.409] resolve() on list ...
[17:39:58.410]  recursive: 99
[17:39:58.410]  length: 1
[17:39:58.410]  elements: ‘a’
[17:39:58.413] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.413] - Validating connection of MultisessionFuture
[17:39:58.413] - received message: FutureResult
[17:39:58.413] - Received FutureResult
[17:39:58.413] - Erased future from FutureRegistry
[17:39:58.413] result() for ClusterFuture ...
[17:39:58.413] - result already collected: FutureResult
[17:39:58.413] result() for ClusterFuture ... done
[17:39:58.413] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.414] Future #1
[17:39:58.414] result() for ClusterFuture ...
[17:39:58.414] - result already collected: FutureResult
[17:39:58.414] result() for ClusterFuture ... done
[17:39:58.414] result() for ClusterFuture ...
[17:39:58.414] - result already collected: FutureResult
[17:39:58.414] result() for ClusterFuture ... done
[17:39:58.414] A MultisessionFuture was resolved
[17:39:58.414]  length: 0 (resolved future 1)
[17:39:58.414] resolve() on list ... DONE
[17:39:58.415] - globals: [1] ‘a’
[17:39:58.415] Resolving futures part of globals (recursively) ... DONE
[17:39:58.416] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:39:58.416] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:39:58.416] - globals: [1] ‘a’
[17:39:58.416] - packages: [1] ‘future’
[17:39:58.416] getGlobalsAndPackages() ... DONE
[17:39:58.417] run() for ‘Future’ ...
[17:39:58.417] - state: ‘created’
[17:39:58.417] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.430] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.431] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.431]   - Field: ‘node’
[17:39:58.431]   - Field: ‘label’
[17:39:58.431]   - Field: ‘local’
[17:39:58.431]   - Field: ‘owner’
[17:39:58.431]   - Field: ‘envir’
[17:39:58.431]   - Field: ‘workers’
[17:39:58.431]   - Field: ‘packages’
[17:39:58.431]   - Field: ‘gc’
[17:39:58.431]   - Field: ‘conditions’
[17:39:58.432]   - Field: ‘persistent’
[17:39:58.432]   - Field: ‘expr’
[17:39:58.432]   - Field: ‘uuid’
[17:39:58.432]   - Field: ‘seed’
[17:39:58.432]   - Field: ‘version’
[17:39:58.432]   - Field: ‘result’
[17:39:58.432]   - Field: ‘asynchronous’
[17:39:58.432]   - Field: ‘calls’
[17:39:58.432]   - Field: ‘globals’
[17:39:58.432]   - Field: ‘stdout’
[17:39:58.432]   - Field: ‘earlySignal’
[17:39:58.433]   - Field: ‘lazy’
[17:39:58.433]   - Field: ‘state’
[17:39:58.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.433] - Launch lazy future ...
[17:39:58.433] Packages needed by the future expression (n = 1): ‘future’
[17:39:58.433] Packages needed by future strategies (n = 0): <none>
[17:39:58.434] {
[17:39:58.434]     {
[17:39:58.434]         {
[17:39:58.434]             ...future.startTime <- base::Sys.time()
[17:39:58.434]             {
[17:39:58.434]                 {
[17:39:58.434]                   {
[17:39:58.434]                     {
[17:39:58.434]                       {
[17:39:58.434]                         base::local({
[17:39:58.434]                           has_future <- base::requireNamespace("future", 
[17:39:58.434]                             quietly = TRUE)
[17:39:58.434]                           if (has_future) {
[17:39:58.434]                             ns <- base::getNamespace("future")
[17:39:58.434]                             version <- ns[[".package"]][["version"]]
[17:39:58.434]                             if (is.null(version)) 
[17:39:58.434]                               version <- utils::packageVersion("future")
[17:39:58.434]                           }
[17:39:58.434]                           else {
[17:39:58.434]                             version <- NULL
[17:39:58.434]                           }
[17:39:58.434]                           if (!has_future || version < "1.8.0") {
[17:39:58.434]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.434]                               "", base::R.version$version.string), 
[17:39:58.434]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:58.434]                                 base::R.version$platform, 8 * 
[17:39:58.434]                                   base::.Machine$sizeof.pointer), 
[17:39:58.434]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.434]                                 "release", "version")], collapse = " "), 
[17:39:58.434]                               hostname = base::Sys.info()[["nodename"]])
[17:39:58.434]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.434]                               info)
[17:39:58.434]                             info <- base::paste(info, collapse = "; ")
[17:39:58.434]                             if (!has_future) {
[17:39:58.434]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.434]                                 info)
[17:39:58.434]                             }
[17:39:58.434]                             else {
[17:39:58.434]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.434]                                 info, version)
[17:39:58.434]                             }
[17:39:58.434]                             base::stop(msg)
[17:39:58.434]                           }
[17:39:58.434]                         })
[17:39:58.434]                       }
[17:39:58.434]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.434]                       base::options(mc.cores = 1L)
[17:39:58.434]                     }
[17:39:58.434]                     base::local({
[17:39:58.434]                       for (pkg in "future") {
[17:39:58.434]                         base::loadNamespace(pkg)
[17:39:58.434]                         base::library(pkg, character.only = TRUE)
[17:39:58.434]                       }
[17:39:58.434]                     })
[17:39:58.434]                   }
[17:39:58.434]                   ...future.strategy.old <- future::plan("list")
[17:39:58.434]                   options(future.plan = NULL)
[17:39:58.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.434]                 }
[17:39:58.434]                 ...future.workdir <- getwd()
[17:39:58.434]             }
[17:39:58.434]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.434]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.434]         }
[17:39:58.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.434]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.434]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.434]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.434]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.434]             base::names(...future.oldOptions))
[17:39:58.434]     }
[17:39:58.434]     if (FALSE) {
[17:39:58.434]     }
[17:39:58.434]     else {
[17:39:58.434]         if (TRUE) {
[17:39:58.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.434]                 open = "w")
[17:39:58.434]         }
[17:39:58.434]         else {
[17:39:58.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.434]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.434]         }
[17:39:58.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.434]             base::sink(type = "output", split = FALSE)
[17:39:58.434]             base::close(...future.stdout)
[17:39:58.434]         }, add = TRUE)
[17:39:58.434]     }
[17:39:58.434]     ...future.frame <- base::sys.nframe()
[17:39:58.434]     ...future.conditions <- base::list()
[17:39:58.434]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.434]     if (FALSE) {
[17:39:58.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.434]     }
[17:39:58.434]     ...future.result <- base::tryCatch({
[17:39:58.434]         base::withCallingHandlers({
[17:39:58.434]             ...future.value <- base::withVisible(base::local({
[17:39:58.434]                 ...future.makeSendCondition <- base::local({
[17:39:58.434]                   sendCondition <- NULL
[17:39:58.434]                   function(frame = 1L) {
[17:39:58.434]                     if (is.function(sendCondition)) 
[17:39:58.434]                       return(sendCondition)
[17:39:58.434]                     ns <- getNamespace("parallel")
[17:39:58.434]                     if (exists("sendData", mode = "function", 
[17:39:58.434]                       envir = ns)) {
[17:39:58.434]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.434]                         envir = ns)
[17:39:58.434]                       envir <- sys.frame(frame)
[17:39:58.434]                       master <- NULL
[17:39:58.434]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.434]                         !identical(envir, emptyenv())) {
[17:39:58.434]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.434]                           inherits = FALSE)) {
[17:39:58.434]                           master <- get("master", mode = "list", 
[17:39:58.434]                             envir = envir, inherits = FALSE)
[17:39:58.434]                           if (inherits(master, c("SOCKnode", 
[17:39:58.434]                             "SOCK0node"))) {
[17:39:58.434]                             sendCondition <<- function(cond) {
[17:39:58.434]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.434]                                 success = TRUE)
[17:39:58.434]                               parallel_sendData(master, data)
[17:39:58.434]                             }
[17:39:58.434]                             return(sendCondition)
[17:39:58.434]                           }
[17:39:58.434]                         }
[17:39:58.434]                         frame <- frame + 1L
[17:39:58.434]                         envir <- sys.frame(frame)
[17:39:58.434]                       }
[17:39:58.434]                     }
[17:39:58.434]                     sendCondition <<- function(cond) NULL
[17:39:58.434]                   }
[17:39:58.434]                 })
[17:39:58.434]                 withCallingHandlers({
[17:39:58.434]                   value(a) + 1
[17:39:58.434]                 }, immediateCondition = function(cond) {
[17:39:58.434]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.434]                   sendCondition(cond)
[17:39:58.434]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.434]                   {
[17:39:58.434]                     inherits <- base::inherits
[17:39:58.434]                     invokeRestart <- base::invokeRestart
[17:39:58.434]                     is.null <- base::is.null
[17:39:58.434]                     muffled <- FALSE
[17:39:58.434]                     if (inherits(cond, "message")) {
[17:39:58.434]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.434]                       if (muffled) 
[17:39:58.434]                         invokeRestart("muffleMessage")
[17:39:58.434]                     }
[17:39:58.434]                     else if (inherits(cond, "warning")) {
[17:39:58.434]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.434]                       if (muffled) 
[17:39:58.434]                         invokeRestart("muffleWarning")
[17:39:58.434]                     }
[17:39:58.434]                     else if (inherits(cond, "condition")) {
[17:39:58.434]                       if (!is.null(pattern)) {
[17:39:58.434]                         computeRestarts <- base::computeRestarts
[17:39:58.434]                         grepl <- base::grepl
[17:39:58.434]                         restarts <- computeRestarts(cond)
[17:39:58.434]                         for (restart in restarts) {
[17:39:58.434]                           name <- restart$name
[17:39:58.434]                           if (is.null(name)) 
[17:39:58.434]                             next
[17:39:58.434]                           if (!grepl(pattern, name)) 
[17:39:58.434]                             next
[17:39:58.434]                           invokeRestart(restart)
[17:39:58.434]                           muffled <- TRUE
[17:39:58.434]                           break
[17:39:58.434]                         }
[17:39:58.434]                       }
[17:39:58.434]                     }
[17:39:58.434]                     invisible(muffled)
[17:39:58.434]                   }
[17:39:58.434]                   muffleCondition(cond)
[17:39:58.434]                 })
[17:39:58.434]             }))
[17:39:58.434]             future::FutureResult(value = ...future.value$value, 
[17:39:58.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.434]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.434]                     ...future.globalenv.names))
[17:39:58.434]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.434]         }, condition = base::local({
[17:39:58.434]             c <- base::c
[17:39:58.434]             inherits <- base::inherits
[17:39:58.434]             invokeRestart <- base::invokeRestart
[17:39:58.434]             length <- base::length
[17:39:58.434]             list <- base::list
[17:39:58.434]             seq.int <- base::seq.int
[17:39:58.434]             signalCondition <- base::signalCondition
[17:39:58.434]             sys.calls <- base::sys.calls
[17:39:58.434]             `[[` <- base::`[[`
[17:39:58.434]             `+` <- base::`+`
[17:39:58.434]             `<<-` <- base::`<<-`
[17:39:58.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.434]                   3L)]
[17:39:58.434]             }
[17:39:58.434]             function(cond) {
[17:39:58.434]                 is_error <- inherits(cond, "error")
[17:39:58.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.434]                   NULL)
[17:39:58.434]                 if (is_error) {
[17:39:58.434]                   sessionInformation <- function() {
[17:39:58.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.434]                       search = base::search(), system = base::Sys.info())
[17:39:58.434]                   }
[17:39:58.434]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.434]                     cond$call), session = sessionInformation(), 
[17:39:58.434]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.434]                   signalCondition(cond)
[17:39:58.434]                 }
[17:39:58.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.434]                 "immediateCondition"))) {
[17:39:58.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.434]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.434]                   if (TRUE && !signal) {
[17:39:58.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.434]                     {
[17:39:58.434]                       inherits <- base::inherits
[17:39:58.434]                       invokeRestart <- base::invokeRestart
[17:39:58.434]                       is.null <- base::is.null
[17:39:58.434]                       muffled <- FALSE
[17:39:58.434]                       if (inherits(cond, "message")) {
[17:39:58.434]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.434]                         if (muffled) 
[17:39:58.434]                           invokeRestart("muffleMessage")
[17:39:58.434]                       }
[17:39:58.434]                       else if (inherits(cond, "warning")) {
[17:39:58.434]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.434]                         if (muffled) 
[17:39:58.434]                           invokeRestart("muffleWarning")
[17:39:58.434]                       }
[17:39:58.434]                       else if (inherits(cond, "condition")) {
[17:39:58.434]                         if (!is.null(pattern)) {
[17:39:58.434]                           computeRestarts <- base::computeRestarts
[17:39:58.434]                           grepl <- base::grepl
[17:39:58.434]                           restarts <- computeRestarts(cond)
[17:39:58.434]                           for (restart in restarts) {
[17:39:58.434]                             name <- restart$name
[17:39:58.434]                             if (is.null(name)) 
[17:39:58.434]                               next
[17:39:58.434]                             if (!grepl(pattern, name)) 
[17:39:58.434]                               next
[17:39:58.434]                             invokeRestart(restart)
[17:39:58.434]                             muffled <- TRUE
[17:39:58.434]                             break
[17:39:58.434]                           }
[17:39:58.434]                         }
[17:39:58.434]                       }
[17:39:58.434]                       invisible(muffled)
[17:39:58.434]                     }
[17:39:58.434]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.434]                   }
[17:39:58.434]                 }
[17:39:58.434]                 else {
[17:39:58.434]                   if (TRUE) {
[17:39:58.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.434]                     {
[17:39:58.434]                       inherits <- base::inherits
[17:39:58.434]                       invokeRestart <- base::invokeRestart
[17:39:58.434]                       is.null <- base::is.null
[17:39:58.434]                       muffled <- FALSE
[17:39:58.434]                       if (inherits(cond, "message")) {
[17:39:58.434]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.434]                         if (muffled) 
[17:39:58.434]                           invokeRestart("muffleMessage")
[17:39:58.434]                       }
[17:39:58.434]                       else if (inherits(cond, "warning")) {
[17:39:58.434]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.434]                         if (muffled) 
[17:39:58.434]                           invokeRestart("muffleWarning")
[17:39:58.434]                       }
[17:39:58.434]                       else if (inherits(cond, "condition")) {
[17:39:58.434]                         if (!is.null(pattern)) {
[17:39:58.434]                           computeRestarts <- base::computeRestarts
[17:39:58.434]                           grepl <- base::grepl
[17:39:58.434]                           restarts <- computeRestarts(cond)
[17:39:58.434]                           for (restart in restarts) {
[17:39:58.434]                             name <- restart$name
[17:39:58.434]                             if (is.null(name)) 
[17:39:58.434]                               next
[17:39:58.434]                             if (!grepl(pattern, name)) 
[17:39:58.434]                               next
[17:39:58.434]                             invokeRestart(restart)
[17:39:58.434]                             muffled <- TRUE
[17:39:58.434]                             break
[17:39:58.434]                           }
[17:39:58.434]                         }
[17:39:58.434]                       }
[17:39:58.434]                       invisible(muffled)
[17:39:58.434]                     }
[17:39:58.434]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.434]                   }
[17:39:58.434]                 }
[17:39:58.434]             }
[17:39:58.434]         }))
[17:39:58.434]     }, error = function(ex) {
[17:39:58.434]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.434]                 ...future.rng), started = ...future.startTime, 
[17:39:58.434]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.434]             version = "1.8"), class = "FutureResult")
[17:39:58.434]     }, finally = {
[17:39:58.434]         if (!identical(...future.workdir, getwd())) 
[17:39:58.434]             setwd(...future.workdir)
[17:39:58.434]         {
[17:39:58.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.434]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.434]             }
[17:39:58.434]             base::options(...future.oldOptions)
[17:39:58.434]             if (.Platform$OS.type == "windows") {
[17:39:58.434]                 old_names <- names(...future.oldEnvVars)
[17:39:58.434]                 envs <- base::Sys.getenv()
[17:39:58.434]                 names <- names(envs)
[17:39:58.434]                 common <- intersect(names, old_names)
[17:39:58.434]                 added <- setdiff(names, old_names)
[17:39:58.434]                 removed <- setdiff(old_names, names)
[17:39:58.434]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.434]                   envs[common]]
[17:39:58.434]                 NAMES <- toupper(changed)
[17:39:58.434]                 args <- list()
[17:39:58.434]                 for (kk in seq_along(NAMES)) {
[17:39:58.434]                   name <- changed[[kk]]
[17:39:58.434]                   NAME <- NAMES[[kk]]
[17:39:58.434]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.434]                     next
[17:39:58.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.434]                 }
[17:39:58.434]                 NAMES <- toupper(added)
[17:39:58.434]                 for (kk in seq_along(NAMES)) {
[17:39:58.434]                   name <- added[[kk]]
[17:39:58.434]                   NAME <- NAMES[[kk]]
[17:39:58.434]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.434]                     next
[17:39:58.434]                   args[[name]] <- ""
[17:39:58.434]                 }
[17:39:58.434]                 NAMES <- toupper(removed)
[17:39:58.434]                 for (kk in seq_along(NAMES)) {
[17:39:58.434]                   name <- removed[[kk]]
[17:39:58.434]                   NAME <- NAMES[[kk]]
[17:39:58.434]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.434]                     next
[17:39:58.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.434]                 }
[17:39:58.434]                 if (length(args) > 0) 
[17:39:58.434]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.434]             }
[17:39:58.434]             else {
[17:39:58.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.434]             }
[17:39:58.434]             {
[17:39:58.434]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.434]                   0L) {
[17:39:58.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.434]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.434]                   base::options(opts)
[17:39:58.434]                 }
[17:39:58.434]                 {
[17:39:58.434]                   {
[17:39:58.434]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.434]                     NULL
[17:39:58.434]                   }
[17:39:58.434]                   options(future.plan = NULL)
[17:39:58.434]                   if (is.na(NA_character_)) 
[17:39:58.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.434]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.434]                     .init = FALSE)
[17:39:58.434]                 }
[17:39:58.434]             }
[17:39:58.434]         }
[17:39:58.434]     })
[17:39:58.434]     if (TRUE) {
[17:39:58.434]         base::sink(type = "output", split = FALSE)
[17:39:58.434]         if (TRUE) {
[17:39:58.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.434]         }
[17:39:58.434]         else {
[17:39:58.434]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.434]         }
[17:39:58.434]         base::close(...future.stdout)
[17:39:58.434]         ...future.stdout <- NULL
[17:39:58.434]     }
[17:39:58.434]     ...future.result$conditions <- ...future.conditions
[17:39:58.434]     ...future.result$finished <- base::Sys.time()
[17:39:58.434]     ...future.result
[17:39:58.434] }
[17:39:58.436] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:39:58.439] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:39:58.493] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:39:58.493] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:39:58.493] MultisessionFuture started
[17:39:58.493] - Launch lazy future ... done
[17:39:58.494] run() for ‘MultisessionFuture’ ... done
[17:39:58.494] result() for ClusterFuture ...
[17:39:58.494] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.494] - Validating connection of MultisessionFuture
[17:39:58.542] - received message: FutureResult
[17:39:58.542] - Received FutureResult
[17:39:58.542] - Erased future from FutureRegistry
[17:39:58.542] result() for ClusterFuture ...
[17:39:58.542] - result already collected: FutureResult
[17:39:58.542] result() for ClusterFuture ... done
[17:39:58.542] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.542] result() for ClusterFuture ... done
[17:39:58.543] result() for ClusterFuture ...
[17:39:58.543] - result already collected: FutureResult
[17:39:58.543] result() for ClusterFuture ... done
value(b) = 2
[17:39:58.543] result() for ClusterFuture ...
[17:39:58.543] - result already collected: FutureResult
[17:39:58.543] result() for ClusterFuture ... done
[17:39:58.543] result() for ClusterFuture ...
[17:39:58.543] - result already collected: FutureResult
[17:39:58.543] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.544] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.544] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.544] 
[17:39:58.545] Searching for globals ... DONE
[17:39:58.545] - globals: [0] <none>
[17:39:58.545] getGlobalsAndPackages() ... DONE
[17:39:58.545] run() for ‘Future’ ...
[17:39:58.545] - state: ‘created’
[17:39:58.545] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.559] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.559]   - Field: ‘node’
[17:39:58.560]   - Field: ‘label’
[17:39:58.560]   - Field: ‘local’
[17:39:58.560]   - Field: ‘owner’
[17:39:58.560]   - Field: ‘envir’
[17:39:58.560]   - Field: ‘workers’
[17:39:58.560]   - Field: ‘packages’
[17:39:58.560]   - Field: ‘gc’
[17:39:58.560]   - Field: ‘conditions’
[17:39:58.560]   - Field: ‘persistent’
[17:39:58.560]   - Field: ‘expr’
[17:39:58.560]   - Field: ‘uuid’
[17:39:58.561]   - Field: ‘seed’
[17:39:58.561]   - Field: ‘version’
[17:39:58.561]   - Field: ‘result’
[17:39:58.561]   - Field: ‘asynchronous’
[17:39:58.561]   - Field: ‘calls’
[17:39:58.561]   - Field: ‘globals’
[17:39:58.561]   - Field: ‘stdout’
[17:39:58.561]   - Field: ‘earlySignal’
[17:39:58.561]   - Field: ‘lazy’
[17:39:58.561]   - Field: ‘state’
[17:39:58.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.561] - Launch lazy future ...
[17:39:58.562] Packages needed by the future expression (n = 0): <none>
[17:39:58.562] Packages needed by future strategies (n = 0): <none>
[17:39:58.562] {
[17:39:58.562]     {
[17:39:58.562]         {
[17:39:58.562]             ...future.startTime <- base::Sys.time()
[17:39:58.562]             {
[17:39:58.562]                 {
[17:39:58.562]                   {
[17:39:58.562]                     {
[17:39:58.562]                       base::local({
[17:39:58.562]                         has_future <- base::requireNamespace("future", 
[17:39:58.562]                           quietly = TRUE)
[17:39:58.562]                         if (has_future) {
[17:39:58.562]                           ns <- base::getNamespace("future")
[17:39:58.562]                           version <- ns[[".package"]][["version"]]
[17:39:58.562]                           if (is.null(version)) 
[17:39:58.562]                             version <- utils::packageVersion("future")
[17:39:58.562]                         }
[17:39:58.562]                         else {
[17:39:58.562]                           version <- NULL
[17:39:58.562]                         }
[17:39:58.562]                         if (!has_future || version < "1.8.0") {
[17:39:58.562]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.562]                             "", base::R.version$version.string), 
[17:39:58.562]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.562]                               "release", "version")], collapse = " "), 
[17:39:58.562]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.562]                             info)
[17:39:58.562]                           info <- base::paste(info, collapse = "; ")
[17:39:58.562]                           if (!has_future) {
[17:39:58.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.562]                               info)
[17:39:58.562]                           }
[17:39:58.562]                           else {
[17:39:58.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.562]                               info, version)
[17:39:58.562]                           }
[17:39:58.562]                           base::stop(msg)
[17:39:58.562]                         }
[17:39:58.562]                       })
[17:39:58.562]                     }
[17:39:58.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.562]                     base::options(mc.cores = 1L)
[17:39:58.562]                   }
[17:39:58.562]                   ...future.strategy.old <- future::plan("list")
[17:39:58.562]                   options(future.plan = NULL)
[17:39:58.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.562]                 }
[17:39:58.562]                 ...future.workdir <- getwd()
[17:39:58.562]             }
[17:39:58.562]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.562]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.562]         }
[17:39:58.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.562]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.562]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.562]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.562]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.562]             base::names(...future.oldOptions))
[17:39:58.562]     }
[17:39:58.562]     if (FALSE) {
[17:39:58.562]     }
[17:39:58.562]     else {
[17:39:58.562]         if (TRUE) {
[17:39:58.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.562]                 open = "w")
[17:39:58.562]         }
[17:39:58.562]         else {
[17:39:58.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.562]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.562]         }
[17:39:58.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.562]             base::sink(type = "output", split = FALSE)
[17:39:58.562]             base::close(...future.stdout)
[17:39:58.562]         }, add = TRUE)
[17:39:58.562]     }
[17:39:58.562]     ...future.frame <- base::sys.nframe()
[17:39:58.562]     ...future.conditions <- base::list()
[17:39:58.562]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.562]     if (FALSE) {
[17:39:58.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.562]     }
[17:39:58.562]     ...future.result <- base::tryCatch({
[17:39:58.562]         base::withCallingHandlers({
[17:39:58.562]             ...future.value <- base::withVisible(base::local({
[17:39:58.562]                 ...future.makeSendCondition <- base::local({
[17:39:58.562]                   sendCondition <- NULL
[17:39:58.562]                   function(frame = 1L) {
[17:39:58.562]                     if (is.function(sendCondition)) 
[17:39:58.562]                       return(sendCondition)
[17:39:58.562]                     ns <- getNamespace("parallel")
[17:39:58.562]                     if (exists("sendData", mode = "function", 
[17:39:58.562]                       envir = ns)) {
[17:39:58.562]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.562]                         envir = ns)
[17:39:58.562]                       envir <- sys.frame(frame)
[17:39:58.562]                       master <- NULL
[17:39:58.562]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.562]                         !identical(envir, emptyenv())) {
[17:39:58.562]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.562]                           inherits = FALSE)) {
[17:39:58.562]                           master <- get("master", mode = "list", 
[17:39:58.562]                             envir = envir, inherits = FALSE)
[17:39:58.562]                           if (inherits(master, c("SOCKnode", 
[17:39:58.562]                             "SOCK0node"))) {
[17:39:58.562]                             sendCondition <<- function(cond) {
[17:39:58.562]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.562]                                 success = TRUE)
[17:39:58.562]                               parallel_sendData(master, data)
[17:39:58.562]                             }
[17:39:58.562]                             return(sendCondition)
[17:39:58.562]                           }
[17:39:58.562]                         }
[17:39:58.562]                         frame <- frame + 1L
[17:39:58.562]                         envir <- sys.frame(frame)
[17:39:58.562]                       }
[17:39:58.562]                     }
[17:39:58.562]                     sendCondition <<- function(cond) NULL
[17:39:58.562]                   }
[17:39:58.562]                 })
[17:39:58.562]                 withCallingHandlers({
[17:39:58.562]                   1
[17:39:58.562]                 }, immediateCondition = function(cond) {
[17:39:58.562]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.562]                   sendCondition(cond)
[17:39:58.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.562]                   {
[17:39:58.562]                     inherits <- base::inherits
[17:39:58.562]                     invokeRestart <- base::invokeRestart
[17:39:58.562]                     is.null <- base::is.null
[17:39:58.562]                     muffled <- FALSE
[17:39:58.562]                     if (inherits(cond, "message")) {
[17:39:58.562]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.562]                       if (muffled) 
[17:39:58.562]                         invokeRestart("muffleMessage")
[17:39:58.562]                     }
[17:39:58.562]                     else if (inherits(cond, "warning")) {
[17:39:58.562]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.562]                       if (muffled) 
[17:39:58.562]                         invokeRestart("muffleWarning")
[17:39:58.562]                     }
[17:39:58.562]                     else if (inherits(cond, "condition")) {
[17:39:58.562]                       if (!is.null(pattern)) {
[17:39:58.562]                         computeRestarts <- base::computeRestarts
[17:39:58.562]                         grepl <- base::grepl
[17:39:58.562]                         restarts <- computeRestarts(cond)
[17:39:58.562]                         for (restart in restarts) {
[17:39:58.562]                           name <- restart$name
[17:39:58.562]                           if (is.null(name)) 
[17:39:58.562]                             next
[17:39:58.562]                           if (!grepl(pattern, name)) 
[17:39:58.562]                             next
[17:39:58.562]                           invokeRestart(restart)
[17:39:58.562]                           muffled <- TRUE
[17:39:58.562]                           break
[17:39:58.562]                         }
[17:39:58.562]                       }
[17:39:58.562]                     }
[17:39:58.562]                     invisible(muffled)
[17:39:58.562]                   }
[17:39:58.562]                   muffleCondition(cond)
[17:39:58.562]                 })
[17:39:58.562]             }))
[17:39:58.562]             future::FutureResult(value = ...future.value$value, 
[17:39:58.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.562]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.562]                     ...future.globalenv.names))
[17:39:58.562]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.562]         }, condition = base::local({
[17:39:58.562]             c <- base::c
[17:39:58.562]             inherits <- base::inherits
[17:39:58.562]             invokeRestart <- base::invokeRestart
[17:39:58.562]             length <- base::length
[17:39:58.562]             list <- base::list
[17:39:58.562]             seq.int <- base::seq.int
[17:39:58.562]             signalCondition <- base::signalCondition
[17:39:58.562]             sys.calls <- base::sys.calls
[17:39:58.562]             `[[` <- base::`[[`
[17:39:58.562]             `+` <- base::`+`
[17:39:58.562]             `<<-` <- base::`<<-`
[17:39:58.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.562]                   3L)]
[17:39:58.562]             }
[17:39:58.562]             function(cond) {
[17:39:58.562]                 is_error <- inherits(cond, "error")
[17:39:58.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.562]                   NULL)
[17:39:58.562]                 if (is_error) {
[17:39:58.562]                   sessionInformation <- function() {
[17:39:58.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.562]                       search = base::search(), system = base::Sys.info())
[17:39:58.562]                   }
[17:39:58.562]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.562]                     cond$call), session = sessionInformation(), 
[17:39:58.562]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.562]                   signalCondition(cond)
[17:39:58.562]                 }
[17:39:58.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.562]                 "immediateCondition"))) {
[17:39:58.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.562]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.562]                   if (TRUE && !signal) {
[17:39:58.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.562]                     {
[17:39:58.562]                       inherits <- base::inherits
[17:39:58.562]                       invokeRestart <- base::invokeRestart
[17:39:58.562]                       is.null <- base::is.null
[17:39:58.562]                       muffled <- FALSE
[17:39:58.562]                       if (inherits(cond, "message")) {
[17:39:58.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.562]                         if (muffled) 
[17:39:58.562]                           invokeRestart("muffleMessage")
[17:39:58.562]                       }
[17:39:58.562]                       else if (inherits(cond, "warning")) {
[17:39:58.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.562]                         if (muffled) 
[17:39:58.562]                           invokeRestart("muffleWarning")
[17:39:58.562]                       }
[17:39:58.562]                       else if (inherits(cond, "condition")) {
[17:39:58.562]                         if (!is.null(pattern)) {
[17:39:58.562]                           computeRestarts <- base::computeRestarts
[17:39:58.562]                           grepl <- base::grepl
[17:39:58.562]                           restarts <- computeRestarts(cond)
[17:39:58.562]                           for (restart in restarts) {
[17:39:58.562]                             name <- restart$name
[17:39:58.562]                             if (is.null(name)) 
[17:39:58.562]                               next
[17:39:58.562]                             if (!grepl(pattern, name)) 
[17:39:58.562]                               next
[17:39:58.562]                             invokeRestart(restart)
[17:39:58.562]                             muffled <- TRUE
[17:39:58.562]                             break
[17:39:58.562]                           }
[17:39:58.562]                         }
[17:39:58.562]                       }
[17:39:58.562]                       invisible(muffled)
[17:39:58.562]                     }
[17:39:58.562]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.562]                   }
[17:39:58.562]                 }
[17:39:58.562]                 else {
[17:39:58.562]                   if (TRUE) {
[17:39:58.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.562]                     {
[17:39:58.562]                       inherits <- base::inherits
[17:39:58.562]                       invokeRestart <- base::invokeRestart
[17:39:58.562]                       is.null <- base::is.null
[17:39:58.562]                       muffled <- FALSE
[17:39:58.562]                       if (inherits(cond, "message")) {
[17:39:58.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.562]                         if (muffled) 
[17:39:58.562]                           invokeRestart("muffleMessage")
[17:39:58.562]                       }
[17:39:58.562]                       else if (inherits(cond, "warning")) {
[17:39:58.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.562]                         if (muffled) 
[17:39:58.562]                           invokeRestart("muffleWarning")
[17:39:58.562]                       }
[17:39:58.562]                       else if (inherits(cond, "condition")) {
[17:39:58.562]                         if (!is.null(pattern)) {
[17:39:58.562]                           computeRestarts <- base::computeRestarts
[17:39:58.562]                           grepl <- base::grepl
[17:39:58.562]                           restarts <- computeRestarts(cond)
[17:39:58.562]                           for (restart in restarts) {
[17:39:58.562]                             name <- restart$name
[17:39:58.562]                             if (is.null(name)) 
[17:39:58.562]                               next
[17:39:58.562]                             if (!grepl(pattern, name)) 
[17:39:58.562]                               next
[17:39:58.562]                             invokeRestart(restart)
[17:39:58.562]                             muffled <- TRUE
[17:39:58.562]                             break
[17:39:58.562]                           }
[17:39:58.562]                         }
[17:39:58.562]                       }
[17:39:58.562]                       invisible(muffled)
[17:39:58.562]                     }
[17:39:58.562]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.562]                   }
[17:39:58.562]                 }
[17:39:58.562]             }
[17:39:58.562]         }))
[17:39:58.562]     }, error = function(ex) {
[17:39:58.562]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.562]                 ...future.rng), started = ...future.startTime, 
[17:39:58.562]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.562]             version = "1.8"), class = "FutureResult")
[17:39:58.562]     }, finally = {
[17:39:58.562]         if (!identical(...future.workdir, getwd())) 
[17:39:58.562]             setwd(...future.workdir)
[17:39:58.562]         {
[17:39:58.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.562]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.562]             }
[17:39:58.562]             base::options(...future.oldOptions)
[17:39:58.562]             if (.Platform$OS.type == "windows") {
[17:39:58.562]                 old_names <- names(...future.oldEnvVars)
[17:39:58.562]                 envs <- base::Sys.getenv()
[17:39:58.562]                 names <- names(envs)
[17:39:58.562]                 common <- intersect(names, old_names)
[17:39:58.562]                 added <- setdiff(names, old_names)
[17:39:58.562]                 removed <- setdiff(old_names, names)
[17:39:58.562]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.562]                   envs[common]]
[17:39:58.562]                 NAMES <- toupper(changed)
[17:39:58.562]                 args <- list()
[17:39:58.562]                 for (kk in seq_along(NAMES)) {
[17:39:58.562]                   name <- changed[[kk]]
[17:39:58.562]                   NAME <- NAMES[[kk]]
[17:39:58.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.562]                     next
[17:39:58.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.562]                 }
[17:39:58.562]                 NAMES <- toupper(added)
[17:39:58.562]                 for (kk in seq_along(NAMES)) {
[17:39:58.562]                   name <- added[[kk]]
[17:39:58.562]                   NAME <- NAMES[[kk]]
[17:39:58.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.562]                     next
[17:39:58.562]                   args[[name]] <- ""
[17:39:58.562]                 }
[17:39:58.562]                 NAMES <- toupper(removed)
[17:39:58.562]                 for (kk in seq_along(NAMES)) {
[17:39:58.562]                   name <- removed[[kk]]
[17:39:58.562]                   NAME <- NAMES[[kk]]
[17:39:58.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.562]                     next
[17:39:58.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.562]                 }
[17:39:58.562]                 if (length(args) > 0) 
[17:39:58.562]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.562]             }
[17:39:58.562]             else {
[17:39:58.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.562]             }
[17:39:58.562]             {
[17:39:58.562]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.562]                   0L) {
[17:39:58.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.562]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.562]                   base::options(opts)
[17:39:58.562]                 }
[17:39:58.562]                 {
[17:39:58.562]                   {
[17:39:58.562]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.562]                     NULL
[17:39:58.562]                   }
[17:39:58.562]                   options(future.plan = NULL)
[17:39:58.562]                   if (is.na(NA_character_)) 
[17:39:58.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.562]                     .init = FALSE)
[17:39:58.562]                 }
[17:39:58.562]             }
[17:39:58.562]         }
[17:39:58.562]     })
[17:39:58.562]     if (TRUE) {
[17:39:58.562]         base::sink(type = "output", split = FALSE)
[17:39:58.562]         if (TRUE) {
[17:39:58.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.562]         }
[17:39:58.562]         else {
[17:39:58.562]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.562]         }
[17:39:58.562]         base::close(...future.stdout)
[17:39:58.562]         ...future.stdout <- NULL
[17:39:58.562]     }
[17:39:58.562]     ...future.result$conditions <- ...future.conditions
[17:39:58.562]     ...future.result$finished <- base::Sys.time()
[17:39:58.562]     ...future.result
[17:39:58.562] }
[17:39:58.565] MultisessionFuture started
[17:39:58.565] - Launch lazy future ... done
[17:39:58.565] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.565] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.566] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.567] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:58.567] Searching for globals ... DONE
[17:39:58.567] Resolving globals: TRUE
[17:39:58.567] Resolving any globals that are futures ...
[17:39:58.567] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:58.567] Resolving any globals that are futures ... DONE
[17:39:58.567] Resolving futures part of globals (recursively) ...
[17:39:58.568] resolve() on list ...
[17:39:58.568]  recursive: 99
[17:39:58.568]  length: 1
[17:39:58.568]  elements: ‘a’
[17:39:58.610] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.610] - Validating connection of MultisessionFuture
[17:39:58.610] - received message: FutureResult
[17:39:58.610] - Received FutureResult
[17:39:58.611] - Erased future from FutureRegistry
[17:39:58.611] result() for ClusterFuture ...
[17:39:58.611] - result already collected: FutureResult
[17:39:58.611] result() for ClusterFuture ... done
[17:39:58.611] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.611] Future #1
[17:39:58.611] result() for ClusterFuture ...
[17:39:58.611] - result already collected: FutureResult
[17:39:58.611] result() for ClusterFuture ... done
[17:39:58.611] result() for ClusterFuture ...
[17:39:58.611] - result already collected: FutureResult
[17:39:58.611] result() for ClusterFuture ... done
[17:39:58.612] A MultisessionFuture was resolved
[17:39:58.612]  length: 0 (resolved future 1)
[17:39:58.612] resolve() on list ... DONE
[17:39:58.612] - globals: [1] ‘a’
[17:39:58.612] Resolving futures part of globals (recursively) ... DONE
[17:39:58.613] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:39:58.613] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:39:58.613] - globals: [1] ‘a’
[17:39:58.614] - packages: [1] ‘future’
[17:39:58.614] getGlobalsAndPackages() ... DONE
[17:39:58.614] run() for ‘Future’ ...
[17:39:58.614] - state: ‘created’
[17:39:58.614] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.629]   - Field: ‘node’
[17:39:58.629]   - Field: ‘label’
[17:39:58.629]   - Field: ‘local’
[17:39:58.629]   - Field: ‘owner’
[17:39:58.629]   - Field: ‘envir’
[17:39:58.629]   - Field: ‘workers’
[17:39:58.629]   - Field: ‘packages’
[17:39:58.629]   - Field: ‘gc’
[17:39:58.630]   - Field: ‘conditions’
[17:39:58.630]   - Field: ‘persistent’
[17:39:58.630]   - Field: ‘expr’
[17:39:58.630]   - Field: ‘uuid’
[17:39:58.630]   - Field: ‘seed’
[17:39:58.630]   - Field: ‘version’
[17:39:58.630]   - Field: ‘result’
[17:39:58.630]   - Field: ‘asynchronous’
[17:39:58.630]   - Field: ‘calls’
[17:39:58.630]   - Field: ‘globals’
[17:39:58.630]   - Field: ‘stdout’
[17:39:58.631]   - Field: ‘earlySignal’
[17:39:58.631]   - Field: ‘lazy’
[17:39:58.631]   - Field: ‘state’
[17:39:58.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.631] - Launch lazy future ...
[17:39:58.631] Packages needed by the future expression (n = 1): ‘future’
[17:39:58.631] Packages needed by future strategies (n = 0): <none>
[17:39:58.632] {
[17:39:58.632]     {
[17:39:58.632]         {
[17:39:58.632]             ...future.startTime <- base::Sys.time()
[17:39:58.632]             {
[17:39:58.632]                 {
[17:39:58.632]                   {
[17:39:58.632]                     {
[17:39:58.632]                       {
[17:39:58.632]                         base::local({
[17:39:58.632]                           has_future <- base::requireNamespace("future", 
[17:39:58.632]                             quietly = TRUE)
[17:39:58.632]                           if (has_future) {
[17:39:58.632]                             ns <- base::getNamespace("future")
[17:39:58.632]                             version <- ns[[".package"]][["version"]]
[17:39:58.632]                             if (is.null(version)) 
[17:39:58.632]                               version <- utils::packageVersion("future")
[17:39:58.632]                           }
[17:39:58.632]                           else {
[17:39:58.632]                             version <- NULL
[17:39:58.632]                           }
[17:39:58.632]                           if (!has_future || version < "1.8.0") {
[17:39:58.632]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.632]                               "", base::R.version$version.string), 
[17:39:58.632]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:58.632]                                 base::R.version$platform, 8 * 
[17:39:58.632]                                   base::.Machine$sizeof.pointer), 
[17:39:58.632]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.632]                                 "release", "version")], collapse = " "), 
[17:39:58.632]                               hostname = base::Sys.info()[["nodename"]])
[17:39:58.632]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.632]                               info)
[17:39:58.632]                             info <- base::paste(info, collapse = "; ")
[17:39:58.632]                             if (!has_future) {
[17:39:58.632]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.632]                                 info)
[17:39:58.632]                             }
[17:39:58.632]                             else {
[17:39:58.632]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.632]                                 info, version)
[17:39:58.632]                             }
[17:39:58.632]                             base::stop(msg)
[17:39:58.632]                           }
[17:39:58.632]                         })
[17:39:58.632]                       }
[17:39:58.632]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.632]                       base::options(mc.cores = 1L)
[17:39:58.632]                     }
[17:39:58.632]                     base::local({
[17:39:58.632]                       for (pkg in "future") {
[17:39:58.632]                         base::loadNamespace(pkg)
[17:39:58.632]                         base::library(pkg, character.only = TRUE)
[17:39:58.632]                       }
[17:39:58.632]                     })
[17:39:58.632]                   }
[17:39:58.632]                   ...future.strategy.old <- future::plan("list")
[17:39:58.632]                   options(future.plan = NULL)
[17:39:58.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.632]                 }
[17:39:58.632]                 ...future.workdir <- getwd()
[17:39:58.632]             }
[17:39:58.632]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.632]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.632]         }
[17:39:58.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.632]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.632]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.632]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.632]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.632]             base::names(...future.oldOptions))
[17:39:58.632]     }
[17:39:58.632]     if (FALSE) {
[17:39:58.632]     }
[17:39:58.632]     else {
[17:39:58.632]         if (TRUE) {
[17:39:58.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.632]                 open = "w")
[17:39:58.632]         }
[17:39:58.632]         else {
[17:39:58.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.632]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.632]         }
[17:39:58.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.632]             base::sink(type = "output", split = FALSE)
[17:39:58.632]             base::close(...future.stdout)
[17:39:58.632]         }, add = TRUE)
[17:39:58.632]     }
[17:39:58.632]     ...future.frame <- base::sys.nframe()
[17:39:58.632]     ...future.conditions <- base::list()
[17:39:58.632]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.632]     if (FALSE) {
[17:39:58.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.632]     }
[17:39:58.632]     ...future.result <- base::tryCatch({
[17:39:58.632]         base::withCallingHandlers({
[17:39:58.632]             ...future.value <- base::withVisible(base::local({
[17:39:58.632]                 ...future.makeSendCondition <- base::local({
[17:39:58.632]                   sendCondition <- NULL
[17:39:58.632]                   function(frame = 1L) {
[17:39:58.632]                     if (is.function(sendCondition)) 
[17:39:58.632]                       return(sendCondition)
[17:39:58.632]                     ns <- getNamespace("parallel")
[17:39:58.632]                     if (exists("sendData", mode = "function", 
[17:39:58.632]                       envir = ns)) {
[17:39:58.632]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.632]                         envir = ns)
[17:39:58.632]                       envir <- sys.frame(frame)
[17:39:58.632]                       master <- NULL
[17:39:58.632]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.632]                         !identical(envir, emptyenv())) {
[17:39:58.632]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.632]                           inherits = FALSE)) {
[17:39:58.632]                           master <- get("master", mode = "list", 
[17:39:58.632]                             envir = envir, inherits = FALSE)
[17:39:58.632]                           if (inherits(master, c("SOCKnode", 
[17:39:58.632]                             "SOCK0node"))) {
[17:39:58.632]                             sendCondition <<- function(cond) {
[17:39:58.632]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.632]                                 success = TRUE)
[17:39:58.632]                               parallel_sendData(master, data)
[17:39:58.632]                             }
[17:39:58.632]                             return(sendCondition)
[17:39:58.632]                           }
[17:39:58.632]                         }
[17:39:58.632]                         frame <- frame + 1L
[17:39:58.632]                         envir <- sys.frame(frame)
[17:39:58.632]                       }
[17:39:58.632]                     }
[17:39:58.632]                     sendCondition <<- function(cond) NULL
[17:39:58.632]                   }
[17:39:58.632]                 })
[17:39:58.632]                 withCallingHandlers({
[17:39:58.632]                   value(a) + 1
[17:39:58.632]                 }, immediateCondition = function(cond) {
[17:39:58.632]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.632]                   sendCondition(cond)
[17:39:58.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.632]                   {
[17:39:58.632]                     inherits <- base::inherits
[17:39:58.632]                     invokeRestart <- base::invokeRestart
[17:39:58.632]                     is.null <- base::is.null
[17:39:58.632]                     muffled <- FALSE
[17:39:58.632]                     if (inherits(cond, "message")) {
[17:39:58.632]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.632]                       if (muffled) 
[17:39:58.632]                         invokeRestart("muffleMessage")
[17:39:58.632]                     }
[17:39:58.632]                     else if (inherits(cond, "warning")) {
[17:39:58.632]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.632]                       if (muffled) 
[17:39:58.632]                         invokeRestart("muffleWarning")
[17:39:58.632]                     }
[17:39:58.632]                     else if (inherits(cond, "condition")) {
[17:39:58.632]                       if (!is.null(pattern)) {
[17:39:58.632]                         computeRestarts <- base::computeRestarts
[17:39:58.632]                         grepl <- base::grepl
[17:39:58.632]                         restarts <- computeRestarts(cond)
[17:39:58.632]                         for (restart in restarts) {
[17:39:58.632]                           name <- restart$name
[17:39:58.632]                           if (is.null(name)) 
[17:39:58.632]                             next
[17:39:58.632]                           if (!grepl(pattern, name)) 
[17:39:58.632]                             next
[17:39:58.632]                           invokeRestart(restart)
[17:39:58.632]                           muffled <- TRUE
[17:39:58.632]                           break
[17:39:58.632]                         }
[17:39:58.632]                       }
[17:39:58.632]                     }
[17:39:58.632]                     invisible(muffled)
[17:39:58.632]                   }
[17:39:58.632]                   muffleCondition(cond)
[17:39:58.632]                 })
[17:39:58.632]             }))
[17:39:58.632]             future::FutureResult(value = ...future.value$value, 
[17:39:58.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.632]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.632]                     ...future.globalenv.names))
[17:39:58.632]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.632]         }, condition = base::local({
[17:39:58.632]             c <- base::c
[17:39:58.632]             inherits <- base::inherits
[17:39:58.632]             invokeRestart <- base::invokeRestart
[17:39:58.632]             length <- base::length
[17:39:58.632]             list <- base::list
[17:39:58.632]             seq.int <- base::seq.int
[17:39:58.632]             signalCondition <- base::signalCondition
[17:39:58.632]             sys.calls <- base::sys.calls
[17:39:58.632]             `[[` <- base::`[[`
[17:39:58.632]             `+` <- base::`+`
[17:39:58.632]             `<<-` <- base::`<<-`
[17:39:58.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.632]                   3L)]
[17:39:58.632]             }
[17:39:58.632]             function(cond) {
[17:39:58.632]                 is_error <- inherits(cond, "error")
[17:39:58.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.632]                   NULL)
[17:39:58.632]                 if (is_error) {
[17:39:58.632]                   sessionInformation <- function() {
[17:39:58.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.632]                       search = base::search(), system = base::Sys.info())
[17:39:58.632]                   }
[17:39:58.632]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.632]                     cond$call), session = sessionInformation(), 
[17:39:58.632]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.632]                   signalCondition(cond)
[17:39:58.632]                 }
[17:39:58.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.632]                 "immediateCondition"))) {
[17:39:58.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.632]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.632]                   if (TRUE && !signal) {
[17:39:58.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.632]                     {
[17:39:58.632]                       inherits <- base::inherits
[17:39:58.632]                       invokeRestart <- base::invokeRestart
[17:39:58.632]                       is.null <- base::is.null
[17:39:58.632]                       muffled <- FALSE
[17:39:58.632]                       if (inherits(cond, "message")) {
[17:39:58.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.632]                         if (muffled) 
[17:39:58.632]                           invokeRestart("muffleMessage")
[17:39:58.632]                       }
[17:39:58.632]                       else if (inherits(cond, "warning")) {
[17:39:58.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.632]                         if (muffled) 
[17:39:58.632]                           invokeRestart("muffleWarning")
[17:39:58.632]                       }
[17:39:58.632]                       else if (inherits(cond, "condition")) {
[17:39:58.632]                         if (!is.null(pattern)) {
[17:39:58.632]                           computeRestarts <- base::computeRestarts
[17:39:58.632]                           grepl <- base::grepl
[17:39:58.632]                           restarts <- computeRestarts(cond)
[17:39:58.632]                           for (restart in restarts) {
[17:39:58.632]                             name <- restart$name
[17:39:58.632]                             if (is.null(name)) 
[17:39:58.632]                               next
[17:39:58.632]                             if (!grepl(pattern, name)) 
[17:39:58.632]                               next
[17:39:58.632]                             invokeRestart(restart)
[17:39:58.632]                             muffled <- TRUE
[17:39:58.632]                             break
[17:39:58.632]                           }
[17:39:58.632]                         }
[17:39:58.632]                       }
[17:39:58.632]                       invisible(muffled)
[17:39:58.632]                     }
[17:39:58.632]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.632]                   }
[17:39:58.632]                 }
[17:39:58.632]                 else {
[17:39:58.632]                   if (TRUE) {
[17:39:58.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.632]                     {
[17:39:58.632]                       inherits <- base::inherits
[17:39:58.632]                       invokeRestart <- base::invokeRestart
[17:39:58.632]                       is.null <- base::is.null
[17:39:58.632]                       muffled <- FALSE
[17:39:58.632]                       if (inherits(cond, "message")) {
[17:39:58.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.632]                         if (muffled) 
[17:39:58.632]                           invokeRestart("muffleMessage")
[17:39:58.632]                       }
[17:39:58.632]                       else if (inherits(cond, "warning")) {
[17:39:58.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.632]                         if (muffled) 
[17:39:58.632]                           invokeRestart("muffleWarning")
[17:39:58.632]                       }
[17:39:58.632]                       else if (inherits(cond, "condition")) {
[17:39:58.632]                         if (!is.null(pattern)) {
[17:39:58.632]                           computeRestarts <- base::computeRestarts
[17:39:58.632]                           grepl <- base::grepl
[17:39:58.632]                           restarts <- computeRestarts(cond)
[17:39:58.632]                           for (restart in restarts) {
[17:39:58.632]                             name <- restart$name
[17:39:58.632]                             if (is.null(name)) 
[17:39:58.632]                               next
[17:39:58.632]                             if (!grepl(pattern, name)) 
[17:39:58.632]                               next
[17:39:58.632]                             invokeRestart(restart)
[17:39:58.632]                             muffled <- TRUE
[17:39:58.632]                             break
[17:39:58.632]                           }
[17:39:58.632]                         }
[17:39:58.632]                       }
[17:39:58.632]                       invisible(muffled)
[17:39:58.632]                     }
[17:39:58.632]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.632]                   }
[17:39:58.632]                 }
[17:39:58.632]             }
[17:39:58.632]         }))
[17:39:58.632]     }, error = function(ex) {
[17:39:58.632]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.632]                 ...future.rng), started = ...future.startTime, 
[17:39:58.632]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.632]             version = "1.8"), class = "FutureResult")
[17:39:58.632]     }, finally = {
[17:39:58.632]         if (!identical(...future.workdir, getwd())) 
[17:39:58.632]             setwd(...future.workdir)
[17:39:58.632]         {
[17:39:58.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.632]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.632]             }
[17:39:58.632]             base::options(...future.oldOptions)
[17:39:58.632]             if (.Platform$OS.type == "windows") {
[17:39:58.632]                 old_names <- names(...future.oldEnvVars)
[17:39:58.632]                 envs <- base::Sys.getenv()
[17:39:58.632]                 names <- names(envs)
[17:39:58.632]                 common <- intersect(names, old_names)
[17:39:58.632]                 added <- setdiff(names, old_names)
[17:39:58.632]                 removed <- setdiff(old_names, names)
[17:39:58.632]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.632]                   envs[common]]
[17:39:58.632]                 NAMES <- toupper(changed)
[17:39:58.632]                 args <- list()
[17:39:58.632]                 for (kk in seq_along(NAMES)) {
[17:39:58.632]                   name <- changed[[kk]]
[17:39:58.632]                   NAME <- NAMES[[kk]]
[17:39:58.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.632]                     next
[17:39:58.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.632]                 }
[17:39:58.632]                 NAMES <- toupper(added)
[17:39:58.632]                 for (kk in seq_along(NAMES)) {
[17:39:58.632]                   name <- added[[kk]]
[17:39:58.632]                   NAME <- NAMES[[kk]]
[17:39:58.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.632]                     next
[17:39:58.632]                   args[[name]] <- ""
[17:39:58.632]                 }
[17:39:58.632]                 NAMES <- toupper(removed)
[17:39:58.632]                 for (kk in seq_along(NAMES)) {
[17:39:58.632]                   name <- removed[[kk]]
[17:39:58.632]                   NAME <- NAMES[[kk]]
[17:39:58.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.632]                     next
[17:39:58.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.632]                 }
[17:39:58.632]                 if (length(args) > 0) 
[17:39:58.632]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.632]             }
[17:39:58.632]             else {
[17:39:58.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.632]             }
[17:39:58.632]             {
[17:39:58.632]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.632]                   0L) {
[17:39:58.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.632]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.632]                   base::options(opts)
[17:39:58.632]                 }
[17:39:58.632]                 {
[17:39:58.632]                   {
[17:39:58.632]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.632]                     NULL
[17:39:58.632]                   }
[17:39:58.632]                   options(future.plan = NULL)
[17:39:58.632]                   if (is.na(NA_character_)) 
[17:39:58.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.632]                     .init = FALSE)
[17:39:58.632]                 }
[17:39:58.632]             }
[17:39:58.632]         }
[17:39:58.632]     })
[17:39:58.632]     if (TRUE) {
[17:39:58.632]         base::sink(type = "output", split = FALSE)
[17:39:58.632]         if (TRUE) {
[17:39:58.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.632]         }
[17:39:58.632]         else {
[17:39:58.632]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.632]         }
[17:39:58.632]         base::close(...future.stdout)
[17:39:58.632]         ...future.stdout <- NULL
[17:39:58.632]     }
[17:39:58.632]     ...future.result$conditions <- ...future.conditions
[17:39:58.632]     ...future.result$finished <- base::Sys.time()
[17:39:58.632]     ...future.result
[17:39:58.632] }
[17:39:58.634] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:39:58.635] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:39:58.689] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:39:58.689] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:39:58.689] MultisessionFuture started
[17:39:58.689] - Launch lazy future ... done
[17:39:58.690] run() for ‘MultisessionFuture’ ... done
[17:39:58.690] result() for ClusterFuture ...
[17:39:58.690] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.690] - Validating connection of MultisessionFuture
[17:39:58.735] - received message: FutureResult
[17:39:58.735] - Received FutureResult
[17:39:58.735] - Erased future from FutureRegistry
[17:39:58.735] result() for ClusterFuture ...
[17:39:58.735] - result already collected: FutureResult
[17:39:58.735] result() for ClusterFuture ... done
[17:39:58.735] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.735] result() for ClusterFuture ... done
[17:39:58.735] result() for ClusterFuture ...
[17:39:58.736] - result already collected: FutureResult
[17:39:58.736] result() for ClusterFuture ... done
value(b) = 2
[17:39:58.736] result() for ClusterFuture ...
[17:39:58.736] - result already collected: FutureResult
[17:39:58.736] result() for ClusterFuture ... done
[17:39:58.736] result() for ClusterFuture ...
[17:39:58.736] - result already collected: FutureResult
[17:39:58.736] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.737] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.737] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.737] 
[17:39:58.738] Searching for globals ... DONE
[17:39:58.738] - globals: [0] <none>
[17:39:58.738] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.738] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.738] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.739] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:58.739] Searching for globals ... DONE
[17:39:58.739] Resolving globals: TRUE
[17:39:58.740] Resolving any globals that are futures ...
[17:39:58.740] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:58.740] Resolving any globals that are futures ... DONE
[17:39:58.740] Resolving futures part of globals (recursively) ...
[17:39:58.740] resolve() on list ...
[17:39:58.740]  recursive: 99
[17:39:58.741]  length: 1
[17:39:58.741]  elements: ‘a’
[17:39:58.741] run() for ‘Future’ ...
[17:39:58.741] - state: ‘created’
[17:39:58.741] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.755] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.755]   - Field: ‘node’
[17:39:58.755]   - Field: ‘label’
[17:39:58.755]   - Field: ‘local’
[17:39:58.756]   - Field: ‘owner’
[17:39:58.756]   - Field: ‘envir’
[17:39:58.756]   - Field: ‘workers’
[17:39:58.756]   - Field: ‘packages’
[17:39:58.756]   - Field: ‘gc’
[17:39:58.756]   - Field: ‘conditions’
[17:39:58.756]   - Field: ‘persistent’
[17:39:58.756]   - Field: ‘expr’
[17:39:58.756]   - Field: ‘uuid’
[17:39:58.756]   - Field: ‘seed’
[17:39:58.756]   - Field: ‘version’
[17:39:58.757]   - Field: ‘result’
[17:39:58.757]   - Field: ‘asynchronous’
[17:39:58.757]   - Field: ‘calls’
[17:39:58.757]   - Field: ‘globals’
[17:39:58.757]   - Field: ‘stdout’
[17:39:58.757]   - Field: ‘earlySignal’
[17:39:58.757]   - Field: ‘lazy’
[17:39:58.757]   - Field: ‘state’
[17:39:58.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.757] - Launch lazy future ...
[17:39:58.758] Packages needed by the future expression (n = 0): <none>
[17:39:58.758] Packages needed by future strategies (n = 0): <none>
[17:39:58.758] {
[17:39:58.758]     {
[17:39:58.758]         {
[17:39:58.758]             ...future.startTime <- base::Sys.time()
[17:39:58.758]             {
[17:39:58.758]                 {
[17:39:58.758]                   {
[17:39:58.758]                     {
[17:39:58.758]                       base::local({
[17:39:58.758]                         has_future <- base::requireNamespace("future", 
[17:39:58.758]                           quietly = TRUE)
[17:39:58.758]                         if (has_future) {
[17:39:58.758]                           ns <- base::getNamespace("future")
[17:39:58.758]                           version <- ns[[".package"]][["version"]]
[17:39:58.758]                           if (is.null(version)) 
[17:39:58.758]                             version <- utils::packageVersion("future")
[17:39:58.758]                         }
[17:39:58.758]                         else {
[17:39:58.758]                           version <- NULL
[17:39:58.758]                         }
[17:39:58.758]                         if (!has_future || version < "1.8.0") {
[17:39:58.758]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.758]                             "", base::R.version$version.string), 
[17:39:58.758]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.758]                               "release", "version")], collapse = " "), 
[17:39:58.758]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.758]                             info)
[17:39:58.758]                           info <- base::paste(info, collapse = "; ")
[17:39:58.758]                           if (!has_future) {
[17:39:58.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.758]                               info)
[17:39:58.758]                           }
[17:39:58.758]                           else {
[17:39:58.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.758]                               info, version)
[17:39:58.758]                           }
[17:39:58.758]                           base::stop(msg)
[17:39:58.758]                         }
[17:39:58.758]                       })
[17:39:58.758]                     }
[17:39:58.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.758]                     base::options(mc.cores = 1L)
[17:39:58.758]                   }
[17:39:58.758]                   ...future.strategy.old <- future::plan("list")
[17:39:58.758]                   options(future.plan = NULL)
[17:39:58.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.758]                 }
[17:39:58.758]                 ...future.workdir <- getwd()
[17:39:58.758]             }
[17:39:58.758]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.758]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.758]         }
[17:39:58.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.758]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.758]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.758]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.758]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.758]             base::names(...future.oldOptions))
[17:39:58.758]     }
[17:39:58.758]     if (FALSE) {
[17:39:58.758]     }
[17:39:58.758]     else {
[17:39:58.758]         if (TRUE) {
[17:39:58.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.758]                 open = "w")
[17:39:58.758]         }
[17:39:58.758]         else {
[17:39:58.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.758]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.758]         }
[17:39:58.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.758]             base::sink(type = "output", split = FALSE)
[17:39:58.758]             base::close(...future.stdout)
[17:39:58.758]         }, add = TRUE)
[17:39:58.758]     }
[17:39:58.758]     ...future.frame <- base::sys.nframe()
[17:39:58.758]     ...future.conditions <- base::list()
[17:39:58.758]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.758]     if (FALSE) {
[17:39:58.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.758]     }
[17:39:58.758]     ...future.result <- base::tryCatch({
[17:39:58.758]         base::withCallingHandlers({
[17:39:58.758]             ...future.value <- base::withVisible(base::local({
[17:39:58.758]                 ...future.makeSendCondition <- base::local({
[17:39:58.758]                   sendCondition <- NULL
[17:39:58.758]                   function(frame = 1L) {
[17:39:58.758]                     if (is.function(sendCondition)) 
[17:39:58.758]                       return(sendCondition)
[17:39:58.758]                     ns <- getNamespace("parallel")
[17:39:58.758]                     if (exists("sendData", mode = "function", 
[17:39:58.758]                       envir = ns)) {
[17:39:58.758]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.758]                         envir = ns)
[17:39:58.758]                       envir <- sys.frame(frame)
[17:39:58.758]                       master <- NULL
[17:39:58.758]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.758]                         !identical(envir, emptyenv())) {
[17:39:58.758]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.758]                           inherits = FALSE)) {
[17:39:58.758]                           master <- get("master", mode = "list", 
[17:39:58.758]                             envir = envir, inherits = FALSE)
[17:39:58.758]                           if (inherits(master, c("SOCKnode", 
[17:39:58.758]                             "SOCK0node"))) {
[17:39:58.758]                             sendCondition <<- function(cond) {
[17:39:58.758]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.758]                                 success = TRUE)
[17:39:58.758]                               parallel_sendData(master, data)
[17:39:58.758]                             }
[17:39:58.758]                             return(sendCondition)
[17:39:58.758]                           }
[17:39:58.758]                         }
[17:39:58.758]                         frame <- frame + 1L
[17:39:58.758]                         envir <- sys.frame(frame)
[17:39:58.758]                       }
[17:39:58.758]                     }
[17:39:58.758]                     sendCondition <<- function(cond) NULL
[17:39:58.758]                   }
[17:39:58.758]                 })
[17:39:58.758]                 withCallingHandlers({
[17:39:58.758]                   1
[17:39:58.758]                 }, immediateCondition = function(cond) {
[17:39:58.758]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.758]                   sendCondition(cond)
[17:39:58.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.758]                   {
[17:39:58.758]                     inherits <- base::inherits
[17:39:58.758]                     invokeRestart <- base::invokeRestart
[17:39:58.758]                     is.null <- base::is.null
[17:39:58.758]                     muffled <- FALSE
[17:39:58.758]                     if (inherits(cond, "message")) {
[17:39:58.758]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.758]                       if (muffled) 
[17:39:58.758]                         invokeRestart("muffleMessage")
[17:39:58.758]                     }
[17:39:58.758]                     else if (inherits(cond, "warning")) {
[17:39:58.758]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.758]                       if (muffled) 
[17:39:58.758]                         invokeRestart("muffleWarning")
[17:39:58.758]                     }
[17:39:58.758]                     else if (inherits(cond, "condition")) {
[17:39:58.758]                       if (!is.null(pattern)) {
[17:39:58.758]                         computeRestarts <- base::computeRestarts
[17:39:58.758]                         grepl <- base::grepl
[17:39:58.758]                         restarts <- computeRestarts(cond)
[17:39:58.758]                         for (restart in restarts) {
[17:39:58.758]                           name <- restart$name
[17:39:58.758]                           if (is.null(name)) 
[17:39:58.758]                             next
[17:39:58.758]                           if (!grepl(pattern, name)) 
[17:39:58.758]                             next
[17:39:58.758]                           invokeRestart(restart)
[17:39:58.758]                           muffled <- TRUE
[17:39:58.758]                           break
[17:39:58.758]                         }
[17:39:58.758]                       }
[17:39:58.758]                     }
[17:39:58.758]                     invisible(muffled)
[17:39:58.758]                   }
[17:39:58.758]                   muffleCondition(cond)
[17:39:58.758]                 })
[17:39:58.758]             }))
[17:39:58.758]             future::FutureResult(value = ...future.value$value, 
[17:39:58.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.758]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.758]                     ...future.globalenv.names))
[17:39:58.758]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.758]         }, condition = base::local({
[17:39:58.758]             c <- base::c
[17:39:58.758]             inherits <- base::inherits
[17:39:58.758]             invokeRestart <- base::invokeRestart
[17:39:58.758]             length <- base::length
[17:39:58.758]             list <- base::list
[17:39:58.758]             seq.int <- base::seq.int
[17:39:58.758]             signalCondition <- base::signalCondition
[17:39:58.758]             sys.calls <- base::sys.calls
[17:39:58.758]             `[[` <- base::`[[`
[17:39:58.758]             `+` <- base::`+`
[17:39:58.758]             `<<-` <- base::`<<-`
[17:39:58.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.758]                   3L)]
[17:39:58.758]             }
[17:39:58.758]             function(cond) {
[17:39:58.758]                 is_error <- inherits(cond, "error")
[17:39:58.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.758]                   NULL)
[17:39:58.758]                 if (is_error) {
[17:39:58.758]                   sessionInformation <- function() {
[17:39:58.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.758]                       search = base::search(), system = base::Sys.info())
[17:39:58.758]                   }
[17:39:58.758]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.758]                     cond$call), session = sessionInformation(), 
[17:39:58.758]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.758]                   signalCondition(cond)
[17:39:58.758]                 }
[17:39:58.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.758]                 "immediateCondition"))) {
[17:39:58.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.758]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.758]                   if (TRUE && !signal) {
[17:39:58.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.758]                     {
[17:39:58.758]                       inherits <- base::inherits
[17:39:58.758]                       invokeRestart <- base::invokeRestart
[17:39:58.758]                       is.null <- base::is.null
[17:39:58.758]                       muffled <- FALSE
[17:39:58.758]                       if (inherits(cond, "message")) {
[17:39:58.758]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.758]                         if (muffled) 
[17:39:58.758]                           invokeRestart("muffleMessage")
[17:39:58.758]                       }
[17:39:58.758]                       else if (inherits(cond, "warning")) {
[17:39:58.758]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.758]                         if (muffled) 
[17:39:58.758]                           invokeRestart("muffleWarning")
[17:39:58.758]                       }
[17:39:58.758]                       else if (inherits(cond, "condition")) {
[17:39:58.758]                         if (!is.null(pattern)) {
[17:39:58.758]                           computeRestarts <- base::computeRestarts
[17:39:58.758]                           grepl <- base::grepl
[17:39:58.758]                           restarts <- computeRestarts(cond)
[17:39:58.758]                           for (restart in restarts) {
[17:39:58.758]                             name <- restart$name
[17:39:58.758]                             if (is.null(name)) 
[17:39:58.758]                               next
[17:39:58.758]                             if (!grepl(pattern, name)) 
[17:39:58.758]                               next
[17:39:58.758]                             invokeRestart(restart)
[17:39:58.758]                             muffled <- TRUE
[17:39:58.758]                             break
[17:39:58.758]                           }
[17:39:58.758]                         }
[17:39:58.758]                       }
[17:39:58.758]                       invisible(muffled)
[17:39:58.758]                     }
[17:39:58.758]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.758]                   }
[17:39:58.758]                 }
[17:39:58.758]                 else {
[17:39:58.758]                   if (TRUE) {
[17:39:58.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.758]                     {
[17:39:58.758]                       inherits <- base::inherits
[17:39:58.758]                       invokeRestart <- base::invokeRestart
[17:39:58.758]                       is.null <- base::is.null
[17:39:58.758]                       muffled <- FALSE
[17:39:58.758]                       if (inherits(cond, "message")) {
[17:39:58.758]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.758]                         if (muffled) 
[17:39:58.758]                           invokeRestart("muffleMessage")
[17:39:58.758]                       }
[17:39:58.758]                       else if (inherits(cond, "warning")) {
[17:39:58.758]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.758]                         if (muffled) 
[17:39:58.758]                           invokeRestart("muffleWarning")
[17:39:58.758]                       }
[17:39:58.758]                       else if (inherits(cond, "condition")) {
[17:39:58.758]                         if (!is.null(pattern)) {
[17:39:58.758]                           computeRestarts <- base::computeRestarts
[17:39:58.758]                           grepl <- base::grepl
[17:39:58.758]                           restarts <- computeRestarts(cond)
[17:39:58.758]                           for (restart in restarts) {
[17:39:58.758]                             name <- restart$name
[17:39:58.758]                             if (is.null(name)) 
[17:39:58.758]                               next
[17:39:58.758]                             if (!grepl(pattern, name)) 
[17:39:58.758]                               next
[17:39:58.758]                             invokeRestart(restart)
[17:39:58.758]                             muffled <- TRUE
[17:39:58.758]                             break
[17:39:58.758]                           }
[17:39:58.758]                         }
[17:39:58.758]                       }
[17:39:58.758]                       invisible(muffled)
[17:39:58.758]                     }
[17:39:58.758]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.758]                   }
[17:39:58.758]                 }
[17:39:58.758]             }
[17:39:58.758]         }))
[17:39:58.758]     }, error = function(ex) {
[17:39:58.758]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.758]                 ...future.rng), started = ...future.startTime, 
[17:39:58.758]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.758]             version = "1.8"), class = "FutureResult")
[17:39:58.758]     }, finally = {
[17:39:58.758]         if (!identical(...future.workdir, getwd())) 
[17:39:58.758]             setwd(...future.workdir)
[17:39:58.758]         {
[17:39:58.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.758]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.758]             }
[17:39:58.758]             base::options(...future.oldOptions)
[17:39:58.758]             if (.Platform$OS.type == "windows") {
[17:39:58.758]                 old_names <- names(...future.oldEnvVars)
[17:39:58.758]                 envs <- base::Sys.getenv()
[17:39:58.758]                 names <- names(envs)
[17:39:58.758]                 common <- intersect(names, old_names)
[17:39:58.758]                 added <- setdiff(names, old_names)
[17:39:58.758]                 removed <- setdiff(old_names, names)
[17:39:58.758]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.758]                   envs[common]]
[17:39:58.758]                 NAMES <- toupper(changed)
[17:39:58.758]                 args <- list()
[17:39:58.758]                 for (kk in seq_along(NAMES)) {
[17:39:58.758]                   name <- changed[[kk]]
[17:39:58.758]                   NAME <- NAMES[[kk]]
[17:39:58.758]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.758]                     next
[17:39:58.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.758]                 }
[17:39:58.758]                 NAMES <- toupper(added)
[17:39:58.758]                 for (kk in seq_along(NAMES)) {
[17:39:58.758]                   name <- added[[kk]]
[17:39:58.758]                   NAME <- NAMES[[kk]]
[17:39:58.758]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.758]                     next
[17:39:58.758]                   args[[name]] <- ""
[17:39:58.758]                 }
[17:39:58.758]                 NAMES <- toupper(removed)
[17:39:58.758]                 for (kk in seq_along(NAMES)) {
[17:39:58.758]                   name <- removed[[kk]]
[17:39:58.758]                   NAME <- NAMES[[kk]]
[17:39:58.758]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.758]                     next
[17:39:58.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.758]                 }
[17:39:58.758]                 if (length(args) > 0) 
[17:39:58.758]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.758]             }
[17:39:58.758]             else {
[17:39:58.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.758]             }
[17:39:58.758]             {
[17:39:58.758]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.758]                   0L) {
[17:39:58.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.758]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.758]                   base::options(opts)
[17:39:58.758]                 }
[17:39:58.758]                 {
[17:39:58.758]                   {
[17:39:58.758]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.758]                     NULL
[17:39:58.758]                   }
[17:39:58.758]                   options(future.plan = NULL)
[17:39:58.758]                   if (is.na(NA_character_)) 
[17:39:58.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.758]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.758]                     .init = FALSE)
[17:39:58.758]                 }
[17:39:58.758]             }
[17:39:58.758]         }
[17:39:58.758]     })
[17:39:58.758]     if (TRUE) {
[17:39:58.758]         base::sink(type = "output", split = FALSE)
[17:39:58.758]         if (TRUE) {
[17:39:58.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.758]         }
[17:39:58.758]         else {
[17:39:58.758]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.758]         }
[17:39:58.758]         base::close(...future.stdout)
[17:39:58.758]         ...future.stdout <- NULL
[17:39:58.758]     }
[17:39:58.758]     ...future.result$conditions <- ...future.conditions
[17:39:58.758]     ...future.result$finished <- base::Sys.time()
[17:39:58.758]     ...future.result
[17:39:58.758] }
[17:39:58.761] MultisessionFuture started
[17:39:58.761] - Launch lazy future ... done
[17:39:58.761] run() for ‘MultisessionFuture’ ... done
[17:39:58.806] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.806] - Validating connection of MultisessionFuture
[17:39:58.806] - received message: FutureResult
[17:39:58.807] - Received FutureResult
[17:39:58.807] - Erased future from FutureRegistry
[17:39:58.807] result() for ClusterFuture ...
[17:39:58.807] - result already collected: FutureResult
[17:39:58.807] result() for ClusterFuture ... done
[17:39:58.807] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.807] Future #1
[17:39:58.807] result() for ClusterFuture ...
[17:39:58.807] - result already collected: FutureResult
[17:39:58.808] result() for ClusterFuture ... done
[17:39:58.808] result() for ClusterFuture ...
[17:39:58.808] - result already collected: FutureResult
[17:39:58.808] result() for ClusterFuture ... done
[17:39:58.808] A MultisessionFuture was resolved
[17:39:58.808]  length: 0 (resolved future 1)
[17:39:58.808] resolve() on list ... DONE
[17:39:58.808] - globals: [1] ‘a’
[17:39:58.808] Resolving futures part of globals (recursively) ... DONE
[17:39:58.809] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:39:58.810] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:39:58.810] - globals: [1] ‘a’
[17:39:58.810] - packages: [1] ‘future’
[17:39:58.810] getGlobalsAndPackages() ... DONE
[17:39:58.810] run() for ‘Future’ ...
[17:39:58.810] - state: ‘created’
[17:39:58.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.825]   - Field: ‘node’
[17:39:58.825]   - Field: ‘label’
[17:39:58.825]   - Field: ‘local’
[17:39:58.825]   - Field: ‘owner’
[17:39:58.825]   - Field: ‘envir’
[17:39:58.825]   - Field: ‘workers’
[17:39:58.825]   - Field: ‘packages’
[17:39:58.826]   - Field: ‘gc’
[17:39:58.826]   - Field: ‘conditions’
[17:39:58.826]   - Field: ‘persistent’
[17:39:58.826]   - Field: ‘expr’
[17:39:58.826]   - Field: ‘uuid’
[17:39:58.826]   - Field: ‘seed’
[17:39:58.826]   - Field: ‘version’
[17:39:58.826]   - Field: ‘result’
[17:39:58.826]   - Field: ‘asynchronous’
[17:39:58.826]   - Field: ‘calls’
[17:39:58.826]   - Field: ‘globals’
[17:39:58.826]   - Field: ‘stdout’
[17:39:58.827]   - Field: ‘earlySignal’
[17:39:58.827]   - Field: ‘lazy’
[17:39:58.827]   - Field: ‘state’
[17:39:58.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.827] - Launch lazy future ...
[17:39:58.827] Packages needed by the future expression (n = 1): ‘future’
[17:39:58.827] Packages needed by future strategies (n = 0): <none>
[17:39:58.828] {
[17:39:58.828]     {
[17:39:58.828]         {
[17:39:58.828]             ...future.startTime <- base::Sys.time()
[17:39:58.828]             {
[17:39:58.828]                 {
[17:39:58.828]                   {
[17:39:58.828]                     {
[17:39:58.828]                       {
[17:39:58.828]                         base::local({
[17:39:58.828]                           has_future <- base::requireNamespace("future", 
[17:39:58.828]                             quietly = TRUE)
[17:39:58.828]                           if (has_future) {
[17:39:58.828]                             ns <- base::getNamespace("future")
[17:39:58.828]                             version <- ns[[".package"]][["version"]]
[17:39:58.828]                             if (is.null(version)) 
[17:39:58.828]                               version <- utils::packageVersion("future")
[17:39:58.828]                           }
[17:39:58.828]                           else {
[17:39:58.828]                             version <- NULL
[17:39:58.828]                           }
[17:39:58.828]                           if (!has_future || version < "1.8.0") {
[17:39:58.828]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.828]                               "", base::R.version$version.string), 
[17:39:58.828]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:58.828]                                 base::R.version$platform, 8 * 
[17:39:58.828]                                   base::.Machine$sizeof.pointer), 
[17:39:58.828]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.828]                                 "release", "version")], collapse = " "), 
[17:39:58.828]                               hostname = base::Sys.info()[["nodename"]])
[17:39:58.828]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.828]                               info)
[17:39:58.828]                             info <- base::paste(info, collapse = "; ")
[17:39:58.828]                             if (!has_future) {
[17:39:58.828]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.828]                                 info)
[17:39:58.828]                             }
[17:39:58.828]                             else {
[17:39:58.828]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.828]                                 info, version)
[17:39:58.828]                             }
[17:39:58.828]                             base::stop(msg)
[17:39:58.828]                           }
[17:39:58.828]                         })
[17:39:58.828]                       }
[17:39:58.828]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.828]                       base::options(mc.cores = 1L)
[17:39:58.828]                     }
[17:39:58.828]                     base::local({
[17:39:58.828]                       for (pkg in "future") {
[17:39:58.828]                         base::loadNamespace(pkg)
[17:39:58.828]                         base::library(pkg, character.only = TRUE)
[17:39:58.828]                       }
[17:39:58.828]                     })
[17:39:58.828]                   }
[17:39:58.828]                   ...future.strategy.old <- future::plan("list")
[17:39:58.828]                   options(future.plan = NULL)
[17:39:58.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.828]                 }
[17:39:58.828]                 ...future.workdir <- getwd()
[17:39:58.828]             }
[17:39:58.828]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.828]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.828]         }
[17:39:58.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.828]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.828]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.828]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.828]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.828]             base::names(...future.oldOptions))
[17:39:58.828]     }
[17:39:58.828]     if (FALSE) {
[17:39:58.828]     }
[17:39:58.828]     else {
[17:39:58.828]         if (TRUE) {
[17:39:58.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.828]                 open = "w")
[17:39:58.828]         }
[17:39:58.828]         else {
[17:39:58.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.828]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.828]         }
[17:39:58.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.828]             base::sink(type = "output", split = FALSE)
[17:39:58.828]             base::close(...future.stdout)
[17:39:58.828]         }, add = TRUE)
[17:39:58.828]     }
[17:39:58.828]     ...future.frame <- base::sys.nframe()
[17:39:58.828]     ...future.conditions <- base::list()
[17:39:58.828]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.828]     if (FALSE) {
[17:39:58.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.828]     }
[17:39:58.828]     ...future.result <- base::tryCatch({
[17:39:58.828]         base::withCallingHandlers({
[17:39:58.828]             ...future.value <- base::withVisible(base::local({
[17:39:58.828]                 ...future.makeSendCondition <- base::local({
[17:39:58.828]                   sendCondition <- NULL
[17:39:58.828]                   function(frame = 1L) {
[17:39:58.828]                     if (is.function(sendCondition)) 
[17:39:58.828]                       return(sendCondition)
[17:39:58.828]                     ns <- getNamespace("parallel")
[17:39:58.828]                     if (exists("sendData", mode = "function", 
[17:39:58.828]                       envir = ns)) {
[17:39:58.828]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.828]                         envir = ns)
[17:39:58.828]                       envir <- sys.frame(frame)
[17:39:58.828]                       master <- NULL
[17:39:58.828]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.828]                         !identical(envir, emptyenv())) {
[17:39:58.828]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.828]                           inherits = FALSE)) {
[17:39:58.828]                           master <- get("master", mode = "list", 
[17:39:58.828]                             envir = envir, inherits = FALSE)
[17:39:58.828]                           if (inherits(master, c("SOCKnode", 
[17:39:58.828]                             "SOCK0node"))) {
[17:39:58.828]                             sendCondition <<- function(cond) {
[17:39:58.828]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.828]                                 success = TRUE)
[17:39:58.828]                               parallel_sendData(master, data)
[17:39:58.828]                             }
[17:39:58.828]                             return(sendCondition)
[17:39:58.828]                           }
[17:39:58.828]                         }
[17:39:58.828]                         frame <- frame + 1L
[17:39:58.828]                         envir <- sys.frame(frame)
[17:39:58.828]                       }
[17:39:58.828]                     }
[17:39:58.828]                     sendCondition <<- function(cond) NULL
[17:39:58.828]                   }
[17:39:58.828]                 })
[17:39:58.828]                 withCallingHandlers({
[17:39:58.828]                   value(a) + 1
[17:39:58.828]                 }, immediateCondition = function(cond) {
[17:39:58.828]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.828]                   sendCondition(cond)
[17:39:58.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.828]                   {
[17:39:58.828]                     inherits <- base::inherits
[17:39:58.828]                     invokeRestart <- base::invokeRestart
[17:39:58.828]                     is.null <- base::is.null
[17:39:58.828]                     muffled <- FALSE
[17:39:58.828]                     if (inherits(cond, "message")) {
[17:39:58.828]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.828]                       if (muffled) 
[17:39:58.828]                         invokeRestart("muffleMessage")
[17:39:58.828]                     }
[17:39:58.828]                     else if (inherits(cond, "warning")) {
[17:39:58.828]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.828]                       if (muffled) 
[17:39:58.828]                         invokeRestart("muffleWarning")
[17:39:58.828]                     }
[17:39:58.828]                     else if (inherits(cond, "condition")) {
[17:39:58.828]                       if (!is.null(pattern)) {
[17:39:58.828]                         computeRestarts <- base::computeRestarts
[17:39:58.828]                         grepl <- base::grepl
[17:39:58.828]                         restarts <- computeRestarts(cond)
[17:39:58.828]                         for (restart in restarts) {
[17:39:58.828]                           name <- restart$name
[17:39:58.828]                           if (is.null(name)) 
[17:39:58.828]                             next
[17:39:58.828]                           if (!grepl(pattern, name)) 
[17:39:58.828]                             next
[17:39:58.828]                           invokeRestart(restart)
[17:39:58.828]                           muffled <- TRUE
[17:39:58.828]                           break
[17:39:58.828]                         }
[17:39:58.828]                       }
[17:39:58.828]                     }
[17:39:58.828]                     invisible(muffled)
[17:39:58.828]                   }
[17:39:58.828]                   muffleCondition(cond)
[17:39:58.828]                 })
[17:39:58.828]             }))
[17:39:58.828]             future::FutureResult(value = ...future.value$value, 
[17:39:58.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.828]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.828]                     ...future.globalenv.names))
[17:39:58.828]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.828]         }, condition = base::local({
[17:39:58.828]             c <- base::c
[17:39:58.828]             inherits <- base::inherits
[17:39:58.828]             invokeRestart <- base::invokeRestart
[17:39:58.828]             length <- base::length
[17:39:58.828]             list <- base::list
[17:39:58.828]             seq.int <- base::seq.int
[17:39:58.828]             signalCondition <- base::signalCondition
[17:39:58.828]             sys.calls <- base::sys.calls
[17:39:58.828]             `[[` <- base::`[[`
[17:39:58.828]             `+` <- base::`+`
[17:39:58.828]             `<<-` <- base::`<<-`
[17:39:58.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.828]                   3L)]
[17:39:58.828]             }
[17:39:58.828]             function(cond) {
[17:39:58.828]                 is_error <- inherits(cond, "error")
[17:39:58.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.828]                   NULL)
[17:39:58.828]                 if (is_error) {
[17:39:58.828]                   sessionInformation <- function() {
[17:39:58.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.828]                       search = base::search(), system = base::Sys.info())
[17:39:58.828]                   }
[17:39:58.828]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.828]                     cond$call), session = sessionInformation(), 
[17:39:58.828]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.828]                   signalCondition(cond)
[17:39:58.828]                 }
[17:39:58.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.828]                 "immediateCondition"))) {
[17:39:58.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.828]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.828]                   if (TRUE && !signal) {
[17:39:58.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.828]                     {
[17:39:58.828]                       inherits <- base::inherits
[17:39:58.828]                       invokeRestart <- base::invokeRestart
[17:39:58.828]                       is.null <- base::is.null
[17:39:58.828]                       muffled <- FALSE
[17:39:58.828]                       if (inherits(cond, "message")) {
[17:39:58.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.828]                         if (muffled) 
[17:39:58.828]                           invokeRestart("muffleMessage")
[17:39:58.828]                       }
[17:39:58.828]                       else if (inherits(cond, "warning")) {
[17:39:58.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.828]                         if (muffled) 
[17:39:58.828]                           invokeRestart("muffleWarning")
[17:39:58.828]                       }
[17:39:58.828]                       else if (inherits(cond, "condition")) {
[17:39:58.828]                         if (!is.null(pattern)) {
[17:39:58.828]                           computeRestarts <- base::computeRestarts
[17:39:58.828]                           grepl <- base::grepl
[17:39:58.828]                           restarts <- computeRestarts(cond)
[17:39:58.828]                           for (restart in restarts) {
[17:39:58.828]                             name <- restart$name
[17:39:58.828]                             if (is.null(name)) 
[17:39:58.828]                               next
[17:39:58.828]                             if (!grepl(pattern, name)) 
[17:39:58.828]                               next
[17:39:58.828]                             invokeRestart(restart)
[17:39:58.828]                             muffled <- TRUE
[17:39:58.828]                             break
[17:39:58.828]                           }
[17:39:58.828]                         }
[17:39:58.828]                       }
[17:39:58.828]                       invisible(muffled)
[17:39:58.828]                     }
[17:39:58.828]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.828]                   }
[17:39:58.828]                 }
[17:39:58.828]                 else {
[17:39:58.828]                   if (TRUE) {
[17:39:58.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.828]                     {
[17:39:58.828]                       inherits <- base::inherits
[17:39:58.828]                       invokeRestart <- base::invokeRestart
[17:39:58.828]                       is.null <- base::is.null
[17:39:58.828]                       muffled <- FALSE
[17:39:58.828]                       if (inherits(cond, "message")) {
[17:39:58.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.828]                         if (muffled) 
[17:39:58.828]                           invokeRestart("muffleMessage")
[17:39:58.828]                       }
[17:39:58.828]                       else if (inherits(cond, "warning")) {
[17:39:58.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.828]                         if (muffled) 
[17:39:58.828]                           invokeRestart("muffleWarning")
[17:39:58.828]                       }
[17:39:58.828]                       else if (inherits(cond, "condition")) {
[17:39:58.828]                         if (!is.null(pattern)) {
[17:39:58.828]                           computeRestarts <- base::computeRestarts
[17:39:58.828]                           grepl <- base::grepl
[17:39:58.828]                           restarts <- computeRestarts(cond)
[17:39:58.828]                           for (restart in restarts) {
[17:39:58.828]                             name <- restart$name
[17:39:58.828]                             if (is.null(name)) 
[17:39:58.828]                               next
[17:39:58.828]                             if (!grepl(pattern, name)) 
[17:39:58.828]                               next
[17:39:58.828]                             invokeRestart(restart)
[17:39:58.828]                             muffled <- TRUE
[17:39:58.828]                             break
[17:39:58.828]                           }
[17:39:58.828]                         }
[17:39:58.828]                       }
[17:39:58.828]                       invisible(muffled)
[17:39:58.828]                     }
[17:39:58.828]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.828]                   }
[17:39:58.828]                 }
[17:39:58.828]             }
[17:39:58.828]         }))
[17:39:58.828]     }, error = function(ex) {
[17:39:58.828]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.828]                 ...future.rng), started = ...future.startTime, 
[17:39:58.828]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.828]             version = "1.8"), class = "FutureResult")
[17:39:58.828]     }, finally = {
[17:39:58.828]         if (!identical(...future.workdir, getwd())) 
[17:39:58.828]             setwd(...future.workdir)
[17:39:58.828]         {
[17:39:58.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.828]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.828]             }
[17:39:58.828]             base::options(...future.oldOptions)
[17:39:58.828]             if (.Platform$OS.type == "windows") {
[17:39:58.828]                 old_names <- names(...future.oldEnvVars)
[17:39:58.828]                 envs <- base::Sys.getenv()
[17:39:58.828]                 names <- names(envs)
[17:39:58.828]                 common <- intersect(names, old_names)
[17:39:58.828]                 added <- setdiff(names, old_names)
[17:39:58.828]                 removed <- setdiff(old_names, names)
[17:39:58.828]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.828]                   envs[common]]
[17:39:58.828]                 NAMES <- toupper(changed)
[17:39:58.828]                 args <- list()
[17:39:58.828]                 for (kk in seq_along(NAMES)) {
[17:39:58.828]                   name <- changed[[kk]]
[17:39:58.828]                   NAME <- NAMES[[kk]]
[17:39:58.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.828]                     next
[17:39:58.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.828]                 }
[17:39:58.828]                 NAMES <- toupper(added)
[17:39:58.828]                 for (kk in seq_along(NAMES)) {
[17:39:58.828]                   name <- added[[kk]]
[17:39:58.828]                   NAME <- NAMES[[kk]]
[17:39:58.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.828]                     next
[17:39:58.828]                   args[[name]] <- ""
[17:39:58.828]                 }
[17:39:58.828]                 NAMES <- toupper(removed)
[17:39:58.828]                 for (kk in seq_along(NAMES)) {
[17:39:58.828]                   name <- removed[[kk]]
[17:39:58.828]                   NAME <- NAMES[[kk]]
[17:39:58.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.828]                     next
[17:39:58.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.828]                 }
[17:39:58.828]                 if (length(args) > 0) 
[17:39:58.828]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.828]             }
[17:39:58.828]             else {
[17:39:58.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.828]             }
[17:39:58.828]             {
[17:39:58.828]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.828]                   0L) {
[17:39:58.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.828]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.828]                   base::options(opts)
[17:39:58.828]                 }
[17:39:58.828]                 {
[17:39:58.828]                   {
[17:39:58.828]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.828]                     NULL
[17:39:58.828]                   }
[17:39:58.828]                   options(future.plan = NULL)
[17:39:58.828]                   if (is.na(NA_character_)) 
[17:39:58.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.828]                     .init = FALSE)
[17:39:58.828]                 }
[17:39:58.828]             }
[17:39:58.828]         }
[17:39:58.828]     })
[17:39:58.828]     if (TRUE) {
[17:39:58.828]         base::sink(type = "output", split = FALSE)
[17:39:58.828]         if (TRUE) {
[17:39:58.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.828]         }
[17:39:58.828]         else {
[17:39:58.828]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.828]         }
[17:39:58.828]         base::close(...future.stdout)
[17:39:58.828]         ...future.stdout <- NULL
[17:39:58.828]     }
[17:39:58.828]     ...future.result$conditions <- ...future.conditions
[17:39:58.828]     ...future.result$finished <- base::Sys.time()
[17:39:58.828]     ...future.result
[17:39:58.828] }
[17:39:58.830] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:39:58.831] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:39:58.885] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:39:58.885] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:39:58.885] MultisessionFuture started
[17:39:58.886] - Launch lazy future ... done
[17:39:58.886] run() for ‘MultisessionFuture’ ... done
[17:39:58.886] result() for ClusterFuture ...
[17:39:58.886] receiveMessageFromWorker() for ClusterFuture ...
[17:39:58.886] - Validating connection of MultisessionFuture
[17:39:58.930] - received message: FutureResult
[17:39:58.930] - Received FutureResult
[17:39:58.931] - Erased future from FutureRegistry
[17:39:58.931] result() for ClusterFuture ...
[17:39:58.931] - result already collected: FutureResult
[17:39:58.931] result() for ClusterFuture ... done
[17:39:58.931] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:58.931] result() for ClusterFuture ... done
[17:39:58.931] result() for ClusterFuture ...
[17:39:58.931] - result already collected: FutureResult
[17:39:58.931] result() for ClusterFuture ... done
value(b) = 2
[17:39:58.931] result() for ClusterFuture ...
[17:39:58.932] - result already collected: FutureResult
[17:39:58.932] result() for ClusterFuture ... done
[17:39:58.932] result() for ClusterFuture ...
[17:39:58.932] - result already collected: FutureResult
[17:39:58.932] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.932] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.932] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.933] 
[17:39:58.933] Searching for globals ... DONE
[17:39:58.933] - globals: [0] <none>
[17:39:58.933] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:58.934] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:58.934] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:58.935] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:58.935] Searching for globals ... DONE
[17:39:58.935] Resolving globals: TRUE
[17:39:58.935] Resolving any globals that are futures ...
[17:39:58.935] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:58.935] Resolving any globals that are futures ... DONE
[17:39:58.935] Resolving futures part of globals (recursively) ...
[17:39:58.936] resolve() on list ...
[17:39:58.936]  recursive: 99
[17:39:58.936]  length: 1
[17:39:58.936]  elements: ‘a’
[17:39:58.936] run() for ‘Future’ ...
[17:39:58.936] - state: ‘created’
[17:39:58.936] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:58.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:58.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:58.951]   - Field: ‘node’
[17:39:58.951]   - Field: ‘label’
[17:39:58.951]   - Field: ‘local’
[17:39:58.951]   - Field: ‘owner’
[17:39:58.951]   - Field: ‘envir’
[17:39:58.951]   - Field: ‘workers’
[17:39:58.951]   - Field: ‘packages’
[17:39:58.951]   - Field: ‘gc’
[17:39:58.952]   - Field: ‘conditions’
[17:39:58.952]   - Field: ‘persistent’
[17:39:58.952]   - Field: ‘expr’
[17:39:58.952]   - Field: ‘uuid’
[17:39:58.952]   - Field: ‘seed’
[17:39:58.952]   - Field: ‘version’
[17:39:58.952]   - Field: ‘result’
[17:39:58.952]   - Field: ‘asynchronous’
[17:39:58.952]   - Field: ‘calls’
[17:39:58.954]   - Field: ‘globals’
[17:39:58.954]   - Field: ‘stdout’
[17:39:58.955]   - Field: ‘earlySignal’
[17:39:58.955]   - Field: ‘lazy’
[17:39:58.955]   - Field: ‘state’
[17:39:58.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:58.955] - Launch lazy future ...
[17:39:58.955] Packages needed by the future expression (n = 0): <none>
[17:39:58.955] Packages needed by future strategies (n = 0): <none>
[17:39:58.956] {
[17:39:58.956]     {
[17:39:58.956]         {
[17:39:58.956]             ...future.startTime <- base::Sys.time()
[17:39:58.956]             {
[17:39:58.956]                 {
[17:39:58.956]                   {
[17:39:58.956]                     {
[17:39:58.956]                       base::local({
[17:39:58.956]                         has_future <- base::requireNamespace("future", 
[17:39:58.956]                           quietly = TRUE)
[17:39:58.956]                         if (has_future) {
[17:39:58.956]                           ns <- base::getNamespace("future")
[17:39:58.956]                           version <- ns[[".package"]][["version"]]
[17:39:58.956]                           if (is.null(version)) 
[17:39:58.956]                             version <- utils::packageVersion("future")
[17:39:58.956]                         }
[17:39:58.956]                         else {
[17:39:58.956]                           version <- NULL
[17:39:58.956]                         }
[17:39:58.956]                         if (!has_future || version < "1.8.0") {
[17:39:58.956]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:58.956]                             "", base::R.version$version.string), 
[17:39:58.956]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:58.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:58.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:58.956]                               "release", "version")], collapse = " "), 
[17:39:58.956]                             hostname = base::Sys.info()[["nodename"]])
[17:39:58.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:58.956]                             info)
[17:39:58.956]                           info <- base::paste(info, collapse = "; ")
[17:39:58.956]                           if (!has_future) {
[17:39:58.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:58.956]                               info)
[17:39:58.956]                           }
[17:39:58.956]                           else {
[17:39:58.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:58.956]                               info, version)
[17:39:58.956]                           }
[17:39:58.956]                           base::stop(msg)
[17:39:58.956]                         }
[17:39:58.956]                       })
[17:39:58.956]                     }
[17:39:58.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:58.956]                     base::options(mc.cores = 1L)
[17:39:58.956]                   }
[17:39:58.956]                   ...future.strategy.old <- future::plan("list")
[17:39:58.956]                   options(future.plan = NULL)
[17:39:58.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:58.956]                 }
[17:39:58.956]                 ...future.workdir <- getwd()
[17:39:58.956]             }
[17:39:58.956]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:58.956]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:58.956]         }
[17:39:58.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:58.956]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:58.956]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:58.956]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:58.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:58.956]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:58.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:58.956]             base::names(...future.oldOptions))
[17:39:58.956]     }
[17:39:58.956]     if (FALSE) {
[17:39:58.956]     }
[17:39:58.956]     else {
[17:39:58.956]         if (TRUE) {
[17:39:58.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:58.956]                 open = "w")
[17:39:58.956]         }
[17:39:58.956]         else {
[17:39:58.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:58.956]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:58.956]         }
[17:39:58.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:58.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:58.956]             base::sink(type = "output", split = FALSE)
[17:39:58.956]             base::close(...future.stdout)
[17:39:58.956]         }, add = TRUE)
[17:39:58.956]     }
[17:39:58.956]     ...future.frame <- base::sys.nframe()
[17:39:58.956]     ...future.conditions <- base::list()
[17:39:58.956]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:58.956]     if (FALSE) {
[17:39:58.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:58.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:58.956]     }
[17:39:58.956]     ...future.result <- base::tryCatch({
[17:39:58.956]         base::withCallingHandlers({
[17:39:58.956]             ...future.value <- base::withVisible(base::local({
[17:39:58.956]                 ...future.makeSendCondition <- base::local({
[17:39:58.956]                   sendCondition <- NULL
[17:39:58.956]                   function(frame = 1L) {
[17:39:58.956]                     if (is.function(sendCondition)) 
[17:39:58.956]                       return(sendCondition)
[17:39:58.956]                     ns <- getNamespace("parallel")
[17:39:58.956]                     if (exists("sendData", mode = "function", 
[17:39:58.956]                       envir = ns)) {
[17:39:58.956]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:58.956]                         envir = ns)
[17:39:58.956]                       envir <- sys.frame(frame)
[17:39:58.956]                       master <- NULL
[17:39:58.956]                       while (!identical(envir, .GlobalEnv) && 
[17:39:58.956]                         !identical(envir, emptyenv())) {
[17:39:58.956]                         if (exists("master", mode = "list", envir = envir, 
[17:39:58.956]                           inherits = FALSE)) {
[17:39:58.956]                           master <- get("master", mode = "list", 
[17:39:58.956]                             envir = envir, inherits = FALSE)
[17:39:58.956]                           if (inherits(master, c("SOCKnode", 
[17:39:58.956]                             "SOCK0node"))) {
[17:39:58.956]                             sendCondition <<- function(cond) {
[17:39:58.956]                               data <- list(type = "VALUE", value = cond, 
[17:39:58.956]                                 success = TRUE)
[17:39:58.956]                               parallel_sendData(master, data)
[17:39:58.956]                             }
[17:39:58.956]                             return(sendCondition)
[17:39:58.956]                           }
[17:39:58.956]                         }
[17:39:58.956]                         frame <- frame + 1L
[17:39:58.956]                         envir <- sys.frame(frame)
[17:39:58.956]                       }
[17:39:58.956]                     }
[17:39:58.956]                     sendCondition <<- function(cond) NULL
[17:39:58.956]                   }
[17:39:58.956]                 })
[17:39:58.956]                 withCallingHandlers({
[17:39:58.956]                   1
[17:39:58.956]                 }, immediateCondition = function(cond) {
[17:39:58.956]                   sendCondition <- ...future.makeSendCondition()
[17:39:58.956]                   sendCondition(cond)
[17:39:58.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.956]                   {
[17:39:58.956]                     inherits <- base::inherits
[17:39:58.956]                     invokeRestart <- base::invokeRestart
[17:39:58.956]                     is.null <- base::is.null
[17:39:58.956]                     muffled <- FALSE
[17:39:58.956]                     if (inherits(cond, "message")) {
[17:39:58.956]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:58.956]                       if (muffled) 
[17:39:58.956]                         invokeRestart("muffleMessage")
[17:39:58.956]                     }
[17:39:58.956]                     else if (inherits(cond, "warning")) {
[17:39:58.956]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:58.956]                       if (muffled) 
[17:39:58.956]                         invokeRestart("muffleWarning")
[17:39:58.956]                     }
[17:39:58.956]                     else if (inherits(cond, "condition")) {
[17:39:58.956]                       if (!is.null(pattern)) {
[17:39:58.956]                         computeRestarts <- base::computeRestarts
[17:39:58.956]                         grepl <- base::grepl
[17:39:58.956]                         restarts <- computeRestarts(cond)
[17:39:58.956]                         for (restart in restarts) {
[17:39:58.956]                           name <- restart$name
[17:39:58.956]                           if (is.null(name)) 
[17:39:58.956]                             next
[17:39:58.956]                           if (!grepl(pattern, name)) 
[17:39:58.956]                             next
[17:39:58.956]                           invokeRestart(restart)
[17:39:58.956]                           muffled <- TRUE
[17:39:58.956]                           break
[17:39:58.956]                         }
[17:39:58.956]                       }
[17:39:58.956]                     }
[17:39:58.956]                     invisible(muffled)
[17:39:58.956]                   }
[17:39:58.956]                   muffleCondition(cond)
[17:39:58.956]                 })
[17:39:58.956]             }))
[17:39:58.956]             future::FutureResult(value = ...future.value$value, 
[17:39:58.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.956]                   ...future.rng), globalenv = if (FALSE) 
[17:39:58.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:58.956]                     ...future.globalenv.names))
[17:39:58.956]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:58.956]         }, condition = base::local({
[17:39:58.956]             c <- base::c
[17:39:58.956]             inherits <- base::inherits
[17:39:58.956]             invokeRestart <- base::invokeRestart
[17:39:58.956]             length <- base::length
[17:39:58.956]             list <- base::list
[17:39:58.956]             seq.int <- base::seq.int
[17:39:58.956]             signalCondition <- base::signalCondition
[17:39:58.956]             sys.calls <- base::sys.calls
[17:39:58.956]             `[[` <- base::`[[`
[17:39:58.956]             `+` <- base::`+`
[17:39:58.956]             `<<-` <- base::`<<-`
[17:39:58.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:58.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:58.956]                   3L)]
[17:39:58.956]             }
[17:39:58.956]             function(cond) {
[17:39:58.956]                 is_error <- inherits(cond, "error")
[17:39:58.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:58.956]                   NULL)
[17:39:58.956]                 if (is_error) {
[17:39:58.956]                   sessionInformation <- function() {
[17:39:58.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:58.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:58.956]                       search = base::search(), system = base::Sys.info())
[17:39:58.956]                   }
[17:39:58.956]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:58.956]                     cond$call), session = sessionInformation(), 
[17:39:58.956]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:58.956]                   signalCondition(cond)
[17:39:58.956]                 }
[17:39:58.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:58.956]                 "immediateCondition"))) {
[17:39:58.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:58.956]                   ...future.conditions[[length(...future.conditions) + 
[17:39:58.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:58.956]                   if (TRUE && !signal) {
[17:39:58.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.956]                     {
[17:39:58.956]                       inherits <- base::inherits
[17:39:58.956]                       invokeRestart <- base::invokeRestart
[17:39:58.956]                       is.null <- base::is.null
[17:39:58.956]                       muffled <- FALSE
[17:39:58.956]                       if (inherits(cond, "message")) {
[17:39:58.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.956]                         if (muffled) 
[17:39:58.956]                           invokeRestart("muffleMessage")
[17:39:58.956]                       }
[17:39:58.956]                       else if (inherits(cond, "warning")) {
[17:39:58.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.956]                         if (muffled) 
[17:39:58.956]                           invokeRestart("muffleWarning")
[17:39:58.956]                       }
[17:39:58.956]                       else if (inherits(cond, "condition")) {
[17:39:58.956]                         if (!is.null(pattern)) {
[17:39:58.956]                           computeRestarts <- base::computeRestarts
[17:39:58.956]                           grepl <- base::grepl
[17:39:58.956]                           restarts <- computeRestarts(cond)
[17:39:58.956]                           for (restart in restarts) {
[17:39:58.956]                             name <- restart$name
[17:39:58.956]                             if (is.null(name)) 
[17:39:58.956]                               next
[17:39:58.956]                             if (!grepl(pattern, name)) 
[17:39:58.956]                               next
[17:39:58.956]                             invokeRestart(restart)
[17:39:58.956]                             muffled <- TRUE
[17:39:58.956]                             break
[17:39:58.956]                           }
[17:39:58.956]                         }
[17:39:58.956]                       }
[17:39:58.956]                       invisible(muffled)
[17:39:58.956]                     }
[17:39:58.956]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.956]                   }
[17:39:58.956]                 }
[17:39:58.956]                 else {
[17:39:58.956]                   if (TRUE) {
[17:39:58.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:58.956]                     {
[17:39:58.956]                       inherits <- base::inherits
[17:39:58.956]                       invokeRestart <- base::invokeRestart
[17:39:58.956]                       is.null <- base::is.null
[17:39:58.956]                       muffled <- FALSE
[17:39:58.956]                       if (inherits(cond, "message")) {
[17:39:58.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:58.956]                         if (muffled) 
[17:39:58.956]                           invokeRestart("muffleMessage")
[17:39:58.956]                       }
[17:39:58.956]                       else if (inherits(cond, "warning")) {
[17:39:58.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:58.956]                         if (muffled) 
[17:39:58.956]                           invokeRestart("muffleWarning")
[17:39:58.956]                       }
[17:39:58.956]                       else if (inherits(cond, "condition")) {
[17:39:58.956]                         if (!is.null(pattern)) {
[17:39:58.956]                           computeRestarts <- base::computeRestarts
[17:39:58.956]                           grepl <- base::grepl
[17:39:58.956]                           restarts <- computeRestarts(cond)
[17:39:58.956]                           for (restart in restarts) {
[17:39:58.956]                             name <- restart$name
[17:39:58.956]                             if (is.null(name)) 
[17:39:58.956]                               next
[17:39:58.956]                             if (!grepl(pattern, name)) 
[17:39:58.956]                               next
[17:39:58.956]                             invokeRestart(restart)
[17:39:58.956]                             muffled <- TRUE
[17:39:58.956]                             break
[17:39:58.956]                           }
[17:39:58.956]                         }
[17:39:58.956]                       }
[17:39:58.956]                       invisible(muffled)
[17:39:58.956]                     }
[17:39:58.956]                     muffleCondition(cond, pattern = "^muffle")
[17:39:58.956]                   }
[17:39:58.956]                 }
[17:39:58.956]             }
[17:39:58.956]         }))
[17:39:58.956]     }, error = function(ex) {
[17:39:58.956]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:58.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:58.956]                 ...future.rng), started = ...future.startTime, 
[17:39:58.956]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:58.956]             version = "1.8"), class = "FutureResult")
[17:39:58.956]     }, finally = {
[17:39:58.956]         if (!identical(...future.workdir, getwd())) 
[17:39:58.956]             setwd(...future.workdir)
[17:39:58.956]         {
[17:39:58.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:58.956]                 ...future.oldOptions$nwarnings <- NULL
[17:39:58.956]             }
[17:39:58.956]             base::options(...future.oldOptions)
[17:39:58.956]             if (.Platform$OS.type == "windows") {
[17:39:58.956]                 old_names <- names(...future.oldEnvVars)
[17:39:58.956]                 envs <- base::Sys.getenv()
[17:39:58.956]                 names <- names(envs)
[17:39:58.956]                 common <- intersect(names, old_names)
[17:39:58.956]                 added <- setdiff(names, old_names)
[17:39:58.956]                 removed <- setdiff(old_names, names)
[17:39:58.956]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:58.956]                   envs[common]]
[17:39:58.956]                 NAMES <- toupper(changed)
[17:39:58.956]                 args <- list()
[17:39:58.956]                 for (kk in seq_along(NAMES)) {
[17:39:58.956]                   name <- changed[[kk]]
[17:39:58.956]                   NAME <- NAMES[[kk]]
[17:39:58.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.956]                     next
[17:39:58.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.956]                 }
[17:39:58.956]                 NAMES <- toupper(added)
[17:39:58.956]                 for (kk in seq_along(NAMES)) {
[17:39:58.956]                   name <- added[[kk]]
[17:39:58.956]                   NAME <- NAMES[[kk]]
[17:39:58.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.956]                     next
[17:39:58.956]                   args[[name]] <- ""
[17:39:58.956]                 }
[17:39:58.956]                 NAMES <- toupper(removed)
[17:39:58.956]                 for (kk in seq_along(NAMES)) {
[17:39:58.956]                   name <- removed[[kk]]
[17:39:58.956]                   NAME <- NAMES[[kk]]
[17:39:58.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:58.956]                     next
[17:39:58.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:58.956]                 }
[17:39:58.956]                 if (length(args) > 0) 
[17:39:58.956]                   base::do.call(base::Sys.setenv, args = args)
[17:39:58.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:58.956]             }
[17:39:58.956]             else {
[17:39:58.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:58.956]             }
[17:39:58.956]             {
[17:39:58.956]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:58.956]                   0L) {
[17:39:58.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:58.956]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:58.956]                   base::options(opts)
[17:39:58.956]                 }
[17:39:58.956]                 {
[17:39:58.956]                   {
[17:39:58.956]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:58.956]                     NULL
[17:39:58.956]                   }
[17:39:58.956]                   options(future.plan = NULL)
[17:39:58.956]                   if (is.na(NA_character_)) 
[17:39:58.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:58.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:58.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:58.956]                     .init = FALSE)
[17:39:58.956]                 }
[17:39:58.956]             }
[17:39:58.956]         }
[17:39:58.956]     })
[17:39:58.956]     if (TRUE) {
[17:39:58.956]         base::sink(type = "output", split = FALSE)
[17:39:58.956]         if (TRUE) {
[17:39:58.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:58.956]         }
[17:39:58.956]         else {
[17:39:58.956]             ...future.result["stdout"] <- base::list(NULL)
[17:39:58.956]         }
[17:39:58.956]         base::close(...future.stdout)
[17:39:58.956]         ...future.stdout <- NULL
[17:39:58.956]     }
[17:39:58.956]     ...future.result$conditions <- ...future.conditions
[17:39:58.956]     ...future.result$finished <- base::Sys.time()
[17:39:58.956]     ...future.result
[17:39:58.956] }
[17:39:58.958] MultisessionFuture started
[17:39:58.959] - Launch lazy future ... done
[17:39:58.959] run() for ‘MultisessionFuture’ ... done
[17:39:59.002] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.002] - Validating connection of MultisessionFuture
[17:39:59.002] - received message: FutureResult
[17:39:59.003] - Received FutureResult
[17:39:59.003] - Erased future from FutureRegistry
[17:39:59.003] result() for ClusterFuture ...
[17:39:59.003] - result already collected: FutureResult
[17:39:59.003] result() for ClusterFuture ... done
[17:39:59.003] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.003] Future #1
[17:39:59.003] result() for ClusterFuture ...
[17:39:59.003] - result already collected: FutureResult
[17:39:59.004] result() for ClusterFuture ... done
[17:39:59.004] result() for ClusterFuture ...
[17:39:59.004] - result already collected: FutureResult
[17:39:59.004] result() for ClusterFuture ... done
[17:39:59.004] A MultisessionFuture was resolved
[17:39:59.004]  length: 0 (resolved future 1)
[17:39:59.004] resolve() on list ... DONE
[17:39:59.004] - globals: [1] ‘a’
[17:39:59.004] Resolving futures part of globals (recursively) ... DONE
[17:39:59.005] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:39:59.005] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:39:59.006] - globals: [1] ‘a’
[17:39:59.006] - packages: [1] ‘future’
[17:39:59.006] getGlobalsAndPackages() ... DONE
[17:39:59.006] run() for ‘Future’ ...
[17:39:59.006] - state: ‘created’
[17:39:59.006] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.020] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.020]   - Field: ‘node’
[17:39:59.020]   - Field: ‘label’
[17:39:59.020]   - Field: ‘local’
[17:39:59.020]   - Field: ‘owner’
[17:39:59.021]   - Field: ‘envir’
[17:39:59.021]   - Field: ‘workers’
[17:39:59.021]   - Field: ‘packages’
[17:39:59.021]   - Field: ‘gc’
[17:39:59.021]   - Field: ‘conditions’
[17:39:59.021]   - Field: ‘persistent’
[17:39:59.021]   - Field: ‘expr’
[17:39:59.021]   - Field: ‘uuid’
[17:39:59.021]   - Field: ‘seed’
[17:39:59.021]   - Field: ‘version’
[17:39:59.021]   - Field: ‘result’
[17:39:59.022]   - Field: ‘asynchronous’
[17:39:59.022]   - Field: ‘calls’
[17:39:59.022]   - Field: ‘globals’
[17:39:59.022]   - Field: ‘stdout’
[17:39:59.022]   - Field: ‘earlySignal’
[17:39:59.022]   - Field: ‘lazy’
[17:39:59.022]   - Field: ‘state’
[17:39:59.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.022] - Launch lazy future ...
[17:39:59.022] Packages needed by the future expression (n = 1): ‘future’
[17:39:59.023] Packages needed by future strategies (n = 0): <none>
[17:39:59.023] {
[17:39:59.023]     {
[17:39:59.023]         {
[17:39:59.023]             ...future.startTime <- base::Sys.time()
[17:39:59.023]             {
[17:39:59.023]                 {
[17:39:59.023]                   {
[17:39:59.023]                     {
[17:39:59.023]                       {
[17:39:59.023]                         base::local({
[17:39:59.023]                           has_future <- base::requireNamespace("future", 
[17:39:59.023]                             quietly = TRUE)
[17:39:59.023]                           if (has_future) {
[17:39:59.023]                             ns <- base::getNamespace("future")
[17:39:59.023]                             version <- ns[[".package"]][["version"]]
[17:39:59.023]                             if (is.null(version)) 
[17:39:59.023]                               version <- utils::packageVersion("future")
[17:39:59.023]                           }
[17:39:59.023]                           else {
[17:39:59.023]                             version <- NULL
[17:39:59.023]                           }
[17:39:59.023]                           if (!has_future || version < "1.8.0") {
[17:39:59.023]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.023]                               "", base::R.version$version.string), 
[17:39:59.023]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:59.023]                                 base::R.version$platform, 8 * 
[17:39:59.023]                                   base::.Machine$sizeof.pointer), 
[17:39:59.023]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.023]                                 "release", "version")], collapse = " "), 
[17:39:59.023]                               hostname = base::Sys.info()[["nodename"]])
[17:39:59.023]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.023]                               info)
[17:39:59.023]                             info <- base::paste(info, collapse = "; ")
[17:39:59.023]                             if (!has_future) {
[17:39:59.023]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.023]                                 info)
[17:39:59.023]                             }
[17:39:59.023]                             else {
[17:39:59.023]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.023]                                 info, version)
[17:39:59.023]                             }
[17:39:59.023]                             base::stop(msg)
[17:39:59.023]                           }
[17:39:59.023]                         })
[17:39:59.023]                       }
[17:39:59.023]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.023]                       base::options(mc.cores = 1L)
[17:39:59.023]                     }
[17:39:59.023]                     base::local({
[17:39:59.023]                       for (pkg in "future") {
[17:39:59.023]                         base::loadNamespace(pkg)
[17:39:59.023]                         base::library(pkg, character.only = TRUE)
[17:39:59.023]                       }
[17:39:59.023]                     })
[17:39:59.023]                   }
[17:39:59.023]                   ...future.strategy.old <- future::plan("list")
[17:39:59.023]                   options(future.plan = NULL)
[17:39:59.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.023]                 }
[17:39:59.023]                 ...future.workdir <- getwd()
[17:39:59.023]             }
[17:39:59.023]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.023]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.023]         }
[17:39:59.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.023]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:59.023]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.023]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.023]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.023]             base::names(...future.oldOptions))
[17:39:59.023]     }
[17:39:59.023]     if (FALSE) {
[17:39:59.023]     }
[17:39:59.023]     else {
[17:39:59.023]         if (TRUE) {
[17:39:59.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.023]                 open = "w")
[17:39:59.023]         }
[17:39:59.023]         else {
[17:39:59.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.023]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.023]         }
[17:39:59.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.023]             base::sink(type = "output", split = FALSE)
[17:39:59.023]             base::close(...future.stdout)
[17:39:59.023]         }, add = TRUE)
[17:39:59.023]     }
[17:39:59.023]     ...future.frame <- base::sys.nframe()
[17:39:59.023]     ...future.conditions <- base::list()
[17:39:59.023]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.023]     if (FALSE) {
[17:39:59.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.023]     }
[17:39:59.023]     ...future.result <- base::tryCatch({
[17:39:59.023]         base::withCallingHandlers({
[17:39:59.023]             ...future.value <- base::withVisible(base::local({
[17:39:59.023]                 ...future.makeSendCondition <- base::local({
[17:39:59.023]                   sendCondition <- NULL
[17:39:59.023]                   function(frame = 1L) {
[17:39:59.023]                     if (is.function(sendCondition)) 
[17:39:59.023]                       return(sendCondition)
[17:39:59.023]                     ns <- getNamespace("parallel")
[17:39:59.023]                     if (exists("sendData", mode = "function", 
[17:39:59.023]                       envir = ns)) {
[17:39:59.023]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.023]                         envir = ns)
[17:39:59.023]                       envir <- sys.frame(frame)
[17:39:59.023]                       master <- NULL
[17:39:59.023]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.023]                         !identical(envir, emptyenv())) {
[17:39:59.023]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.023]                           inherits = FALSE)) {
[17:39:59.023]                           master <- get("master", mode = "list", 
[17:39:59.023]                             envir = envir, inherits = FALSE)
[17:39:59.023]                           if (inherits(master, c("SOCKnode", 
[17:39:59.023]                             "SOCK0node"))) {
[17:39:59.023]                             sendCondition <<- function(cond) {
[17:39:59.023]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.023]                                 success = TRUE)
[17:39:59.023]                               parallel_sendData(master, data)
[17:39:59.023]                             }
[17:39:59.023]                             return(sendCondition)
[17:39:59.023]                           }
[17:39:59.023]                         }
[17:39:59.023]                         frame <- frame + 1L
[17:39:59.023]                         envir <- sys.frame(frame)
[17:39:59.023]                       }
[17:39:59.023]                     }
[17:39:59.023]                     sendCondition <<- function(cond) NULL
[17:39:59.023]                   }
[17:39:59.023]                 })
[17:39:59.023]                 withCallingHandlers({
[17:39:59.023]                   value(a) + 1
[17:39:59.023]                 }, immediateCondition = function(cond) {
[17:39:59.023]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.023]                   sendCondition(cond)
[17:39:59.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.023]                   {
[17:39:59.023]                     inherits <- base::inherits
[17:39:59.023]                     invokeRestart <- base::invokeRestart
[17:39:59.023]                     is.null <- base::is.null
[17:39:59.023]                     muffled <- FALSE
[17:39:59.023]                     if (inherits(cond, "message")) {
[17:39:59.023]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.023]                       if (muffled) 
[17:39:59.023]                         invokeRestart("muffleMessage")
[17:39:59.023]                     }
[17:39:59.023]                     else if (inherits(cond, "warning")) {
[17:39:59.023]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.023]                       if (muffled) 
[17:39:59.023]                         invokeRestart("muffleWarning")
[17:39:59.023]                     }
[17:39:59.023]                     else if (inherits(cond, "condition")) {
[17:39:59.023]                       if (!is.null(pattern)) {
[17:39:59.023]                         computeRestarts <- base::computeRestarts
[17:39:59.023]                         grepl <- base::grepl
[17:39:59.023]                         restarts <- computeRestarts(cond)
[17:39:59.023]                         for (restart in restarts) {
[17:39:59.023]                           name <- restart$name
[17:39:59.023]                           if (is.null(name)) 
[17:39:59.023]                             next
[17:39:59.023]                           if (!grepl(pattern, name)) 
[17:39:59.023]                             next
[17:39:59.023]                           invokeRestart(restart)
[17:39:59.023]                           muffled <- TRUE
[17:39:59.023]                           break
[17:39:59.023]                         }
[17:39:59.023]                       }
[17:39:59.023]                     }
[17:39:59.023]                     invisible(muffled)
[17:39:59.023]                   }
[17:39:59.023]                   muffleCondition(cond)
[17:39:59.023]                 })
[17:39:59.023]             }))
[17:39:59.023]             future::FutureResult(value = ...future.value$value, 
[17:39:59.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.023]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.023]                     ...future.globalenv.names))
[17:39:59.023]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.023]         }, condition = base::local({
[17:39:59.023]             c <- base::c
[17:39:59.023]             inherits <- base::inherits
[17:39:59.023]             invokeRestart <- base::invokeRestart
[17:39:59.023]             length <- base::length
[17:39:59.023]             list <- base::list
[17:39:59.023]             seq.int <- base::seq.int
[17:39:59.023]             signalCondition <- base::signalCondition
[17:39:59.023]             sys.calls <- base::sys.calls
[17:39:59.023]             `[[` <- base::`[[`
[17:39:59.023]             `+` <- base::`+`
[17:39:59.023]             `<<-` <- base::`<<-`
[17:39:59.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.023]                   3L)]
[17:39:59.023]             }
[17:39:59.023]             function(cond) {
[17:39:59.023]                 is_error <- inherits(cond, "error")
[17:39:59.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.023]                   NULL)
[17:39:59.023]                 if (is_error) {
[17:39:59.023]                   sessionInformation <- function() {
[17:39:59.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.023]                       search = base::search(), system = base::Sys.info())
[17:39:59.023]                   }
[17:39:59.023]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.023]                     cond$call), session = sessionInformation(), 
[17:39:59.023]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.023]                   signalCondition(cond)
[17:39:59.023]                 }
[17:39:59.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.023]                 "immediateCondition"))) {
[17:39:59.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.023]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.023]                   if (TRUE && !signal) {
[17:39:59.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.023]                     {
[17:39:59.023]                       inherits <- base::inherits
[17:39:59.023]                       invokeRestart <- base::invokeRestart
[17:39:59.023]                       is.null <- base::is.null
[17:39:59.023]                       muffled <- FALSE
[17:39:59.023]                       if (inherits(cond, "message")) {
[17:39:59.023]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.023]                         if (muffled) 
[17:39:59.023]                           invokeRestart("muffleMessage")
[17:39:59.023]                       }
[17:39:59.023]                       else if (inherits(cond, "warning")) {
[17:39:59.023]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.023]                         if (muffled) 
[17:39:59.023]                           invokeRestart("muffleWarning")
[17:39:59.023]                       }
[17:39:59.023]                       else if (inherits(cond, "condition")) {
[17:39:59.023]                         if (!is.null(pattern)) {
[17:39:59.023]                           computeRestarts <- base::computeRestarts
[17:39:59.023]                           grepl <- base::grepl
[17:39:59.023]                           restarts <- computeRestarts(cond)
[17:39:59.023]                           for (restart in restarts) {
[17:39:59.023]                             name <- restart$name
[17:39:59.023]                             if (is.null(name)) 
[17:39:59.023]                               next
[17:39:59.023]                             if (!grepl(pattern, name)) 
[17:39:59.023]                               next
[17:39:59.023]                             invokeRestart(restart)
[17:39:59.023]                             muffled <- TRUE
[17:39:59.023]                             break
[17:39:59.023]                           }
[17:39:59.023]                         }
[17:39:59.023]                       }
[17:39:59.023]                       invisible(muffled)
[17:39:59.023]                     }
[17:39:59.023]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.023]                   }
[17:39:59.023]                 }
[17:39:59.023]                 else {
[17:39:59.023]                   if (TRUE) {
[17:39:59.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.023]                     {
[17:39:59.023]                       inherits <- base::inherits
[17:39:59.023]                       invokeRestart <- base::invokeRestart
[17:39:59.023]                       is.null <- base::is.null
[17:39:59.023]                       muffled <- FALSE
[17:39:59.023]                       if (inherits(cond, "message")) {
[17:39:59.023]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.023]                         if (muffled) 
[17:39:59.023]                           invokeRestart("muffleMessage")
[17:39:59.023]                       }
[17:39:59.023]                       else if (inherits(cond, "warning")) {
[17:39:59.023]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.023]                         if (muffled) 
[17:39:59.023]                           invokeRestart("muffleWarning")
[17:39:59.023]                       }
[17:39:59.023]                       else if (inherits(cond, "condition")) {
[17:39:59.023]                         if (!is.null(pattern)) {
[17:39:59.023]                           computeRestarts <- base::computeRestarts
[17:39:59.023]                           grepl <- base::grepl
[17:39:59.023]                           restarts <- computeRestarts(cond)
[17:39:59.023]                           for (restart in restarts) {
[17:39:59.023]                             name <- restart$name
[17:39:59.023]                             if (is.null(name)) 
[17:39:59.023]                               next
[17:39:59.023]                             if (!grepl(pattern, name)) 
[17:39:59.023]                               next
[17:39:59.023]                             invokeRestart(restart)
[17:39:59.023]                             muffled <- TRUE
[17:39:59.023]                             break
[17:39:59.023]                           }
[17:39:59.023]                         }
[17:39:59.023]                       }
[17:39:59.023]                       invisible(muffled)
[17:39:59.023]                     }
[17:39:59.023]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.023]                   }
[17:39:59.023]                 }
[17:39:59.023]             }
[17:39:59.023]         }))
[17:39:59.023]     }, error = function(ex) {
[17:39:59.023]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.023]                 ...future.rng), started = ...future.startTime, 
[17:39:59.023]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.023]             version = "1.8"), class = "FutureResult")
[17:39:59.023]     }, finally = {
[17:39:59.023]         if (!identical(...future.workdir, getwd())) 
[17:39:59.023]             setwd(...future.workdir)
[17:39:59.023]         {
[17:39:59.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.023]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.023]             }
[17:39:59.023]             base::options(...future.oldOptions)
[17:39:59.023]             if (.Platform$OS.type == "windows") {
[17:39:59.023]                 old_names <- names(...future.oldEnvVars)
[17:39:59.023]                 envs <- base::Sys.getenv()
[17:39:59.023]                 names <- names(envs)
[17:39:59.023]                 common <- intersect(names, old_names)
[17:39:59.023]                 added <- setdiff(names, old_names)
[17:39:59.023]                 removed <- setdiff(old_names, names)
[17:39:59.023]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.023]                   envs[common]]
[17:39:59.023]                 NAMES <- toupper(changed)
[17:39:59.023]                 args <- list()
[17:39:59.023]                 for (kk in seq_along(NAMES)) {
[17:39:59.023]                   name <- changed[[kk]]
[17:39:59.023]                   NAME <- NAMES[[kk]]
[17:39:59.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.023]                     next
[17:39:59.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.023]                 }
[17:39:59.023]                 NAMES <- toupper(added)
[17:39:59.023]                 for (kk in seq_along(NAMES)) {
[17:39:59.023]                   name <- added[[kk]]
[17:39:59.023]                   NAME <- NAMES[[kk]]
[17:39:59.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.023]                     next
[17:39:59.023]                   args[[name]] <- ""
[17:39:59.023]                 }
[17:39:59.023]                 NAMES <- toupper(removed)
[17:39:59.023]                 for (kk in seq_along(NAMES)) {
[17:39:59.023]                   name <- removed[[kk]]
[17:39:59.023]                   NAME <- NAMES[[kk]]
[17:39:59.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.023]                     next
[17:39:59.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.023]                 }
[17:39:59.023]                 if (length(args) > 0) 
[17:39:59.023]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.023]             }
[17:39:59.023]             else {
[17:39:59.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.023]             }
[17:39:59.023]             {
[17:39:59.023]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.023]                   0L) {
[17:39:59.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.023]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.023]                   base::options(opts)
[17:39:59.023]                 }
[17:39:59.023]                 {
[17:39:59.023]                   {
[17:39:59.023]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.023]                     NULL
[17:39:59.023]                   }
[17:39:59.023]                   options(future.plan = NULL)
[17:39:59.023]                   if (is.na(NA_character_)) 
[17:39:59.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.023]                     .init = FALSE)
[17:39:59.023]                 }
[17:39:59.023]             }
[17:39:59.023]         }
[17:39:59.023]     })
[17:39:59.023]     if (TRUE) {
[17:39:59.023]         base::sink(type = "output", split = FALSE)
[17:39:59.023]         if (TRUE) {
[17:39:59.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.023]         }
[17:39:59.023]         else {
[17:39:59.023]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.023]         }
[17:39:59.023]         base::close(...future.stdout)
[17:39:59.023]         ...future.stdout <- NULL
[17:39:59.023]     }
[17:39:59.023]     ...future.result$conditions <- ...future.conditions
[17:39:59.023]     ...future.result$finished <- base::Sys.time()
[17:39:59.023]     ...future.result
[17:39:59.023] }
[17:39:59.025] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:39:59.026] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:39:59.077] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:39:59.077] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:39:59.077] MultisessionFuture started
[17:39:59.078] - Launch lazy future ... done
[17:39:59.078] run() for ‘MultisessionFuture’ ... done
[17:39:59.078] result() for ClusterFuture ...
[17:39:59.078] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.078] - Validating connection of MultisessionFuture
[17:39:59.122] - received message: FutureResult
[17:39:59.122] - Received FutureResult
[17:39:59.123] - Erased future from FutureRegistry
[17:39:59.123] result() for ClusterFuture ...
[17:39:59.123] - result already collected: FutureResult
[17:39:59.123] result() for ClusterFuture ... done
[17:39:59.123] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.123] result() for ClusterFuture ... done
[17:39:59.123] result() for ClusterFuture ...
[17:39:59.123] - result already collected: FutureResult
[17:39:59.123] result() for ClusterFuture ... done
value(b) = 2
[17:39:59.123] result() for ClusterFuture ...
[17:39:59.124] - result already collected: FutureResult
[17:39:59.124] result() for ClusterFuture ... done
[17:39:59.124] result() for ClusterFuture ...
[17:39:59.124] - result already collected: FutureResult
[17:39:59.124] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.124] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.124] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:39:59.125] - globals found: [2] ‘{’, ‘pkg’
[17:39:59.125] Searching for globals ... DONE
[17:39:59.125] Resolving globals: TRUE
[17:39:59.125] Resolving any globals that are futures ...
[17:39:59.126] - globals: [2] ‘{’, ‘pkg’
[17:39:59.126] Resolving any globals that are futures ... DONE
[17:39:59.126] Resolving futures part of globals (recursively) ...
[17:39:59.126] resolve() on list ...
[17:39:59.126]  recursive: 99
[17:39:59.126]  length: 1
[17:39:59.126]  elements: ‘pkg’
[17:39:59.127]  length: 0 (resolved future 1)
[17:39:59.127] resolve() on list ... DONE
[17:39:59.127] - globals: [1] ‘pkg’
[17:39:59.127] Resolving futures part of globals (recursively) ... DONE
[17:39:59.127] The total size of the 1 globals is 112 bytes (112 bytes)
[17:39:59.127] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:39:59.127] - globals: [1] ‘pkg’
[17:39:59.127] 
[17:39:59.128] getGlobalsAndPackages() ... DONE
[17:39:59.128] Packages needed by the future expression (n = 0): <none>
[17:39:59.128] Packages needed by future strategies (n = 0): <none>
[17:39:59.128] {
[17:39:59.128]     {
[17:39:59.128]         {
[17:39:59.128]             ...future.startTime <- base::Sys.time()
[17:39:59.128]             {
[17:39:59.128]                 {
[17:39:59.128]                   {
[17:39:59.128]                     base::local({
[17:39:59.128]                       has_future <- base::requireNamespace("future", 
[17:39:59.128]                         quietly = TRUE)
[17:39:59.128]                       if (has_future) {
[17:39:59.128]                         ns <- base::getNamespace("future")
[17:39:59.128]                         version <- ns[[".package"]][["version"]]
[17:39:59.128]                         if (is.null(version)) 
[17:39:59.128]                           version <- utils::packageVersion("future")
[17:39:59.128]                       }
[17:39:59.128]                       else {
[17:39:59.128]                         version <- NULL
[17:39:59.128]                       }
[17:39:59.128]                       if (!has_future || version < "1.8.0") {
[17:39:59.128]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.128]                           "", base::R.version$version.string), 
[17:39:59.128]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:59.128]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.128]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.128]                             "release", "version")], collapse = " "), 
[17:39:59.128]                           hostname = base::Sys.info()[["nodename"]])
[17:39:59.128]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.128]                           info)
[17:39:59.128]                         info <- base::paste(info, collapse = "; ")
[17:39:59.128]                         if (!has_future) {
[17:39:59.128]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.128]                             info)
[17:39:59.128]                         }
[17:39:59.128]                         else {
[17:39:59.128]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.128]                             info, version)
[17:39:59.128]                         }
[17:39:59.128]                         base::stop(msg)
[17:39:59.128]                       }
[17:39:59.128]                     })
[17:39:59.128]                   }
[17:39:59.128]                   ...future.strategy.old <- future::plan("list")
[17:39:59.128]                   options(future.plan = NULL)
[17:39:59.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.128]                 }
[17:39:59.128]                 ...future.workdir <- getwd()
[17:39:59.128]             }
[17:39:59.128]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.128]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.128]         }
[17:39:59.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.128]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:39:59.128]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.128]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.128]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.128]             base::names(...future.oldOptions))
[17:39:59.128]     }
[17:39:59.128]     if (FALSE) {
[17:39:59.128]     }
[17:39:59.128]     else {
[17:39:59.128]         if (TRUE) {
[17:39:59.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.128]                 open = "w")
[17:39:59.128]         }
[17:39:59.128]         else {
[17:39:59.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.128]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.128]         }
[17:39:59.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.128]             base::sink(type = "output", split = FALSE)
[17:39:59.128]             base::close(...future.stdout)
[17:39:59.128]         }, add = TRUE)
[17:39:59.128]     }
[17:39:59.128]     ...future.frame <- base::sys.nframe()
[17:39:59.128]     ...future.conditions <- base::list()
[17:39:59.128]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.128]     if (FALSE) {
[17:39:59.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.128]     }
[17:39:59.128]     ...future.result <- base::tryCatch({
[17:39:59.128]         base::withCallingHandlers({
[17:39:59.128]             ...future.value <- base::withVisible(base::local({
[17:39:59.128]                 pkg
[17:39:59.128]             }))
[17:39:59.128]             future::FutureResult(value = ...future.value$value, 
[17:39:59.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.128]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.128]                     ...future.globalenv.names))
[17:39:59.128]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.128]         }, condition = base::local({
[17:39:59.128]             c <- base::c
[17:39:59.128]             inherits <- base::inherits
[17:39:59.128]             invokeRestart <- base::invokeRestart
[17:39:59.128]             length <- base::length
[17:39:59.128]             list <- base::list
[17:39:59.128]             seq.int <- base::seq.int
[17:39:59.128]             signalCondition <- base::signalCondition
[17:39:59.128]             sys.calls <- base::sys.calls
[17:39:59.128]             `[[` <- base::`[[`
[17:39:59.128]             `+` <- base::`+`
[17:39:59.128]             `<<-` <- base::`<<-`
[17:39:59.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.128]                   3L)]
[17:39:59.128]             }
[17:39:59.128]             function(cond) {
[17:39:59.128]                 is_error <- inherits(cond, "error")
[17:39:59.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.128]                   NULL)
[17:39:59.128]                 if (is_error) {
[17:39:59.128]                   sessionInformation <- function() {
[17:39:59.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.128]                       search = base::search(), system = base::Sys.info())
[17:39:59.128]                   }
[17:39:59.128]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.128]                     cond$call), session = sessionInformation(), 
[17:39:59.128]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.128]                   signalCondition(cond)
[17:39:59.128]                 }
[17:39:59.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.128]                 "immediateCondition"))) {
[17:39:59.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.128]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.128]                   if (TRUE && !signal) {
[17:39:59.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.128]                     {
[17:39:59.128]                       inherits <- base::inherits
[17:39:59.128]                       invokeRestart <- base::invokeRestart
[17:39:59.128]                       is.null <- base::is.null
[17:39:59.128]                       muffled <- FALSE
[17:39:59.128]                       if (inherits(cond, "message")) {
[17:39:59.128]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.128]                         if (muffled) 
[17:39:59.128]                           invokeRestart("muffleMessage")
[17:39:59.128]                       }
[17:39:59.128]                       else if (inherits(cond, "warning")) {
[17:39:59.128]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.128]                         if (muffled) 
[17:39:59.128]                           invokeRestart("muffleWarning")
[17:39:59.128]                       }
[17:39:59.128]                       else if (inherits(cond, "condition")) {
[17:39:59.128]                         if (!is.null(pattern)) {
[17:39:59.128]                           computeRestarts <- base::computeRestarts
[17:39:59.128]                           grepl <- base::grepl
[17:39:59.128]                           restarts <- computeRestarts(cond)
[17:39:59.128]                           for (restart in restarts) {
[17:39:59.128]                             name <- restart$name
[17:39:59.128]                             if (is.null(name)) 
[17:39:59.128]                               next
[17:39:59.128]                             if (!grepl(pattern, name)) 
[17:39:59.128]                               next
[17:39:59.128]                             invokeRestart(restart)
[17:39:59.128]                             muffled <- TRUE
[17:39:59.128]                             break
[17:39:59.128]                           }
[17:39:59.128]                         }
[17:39:59.128]                       }
[17:39:59.128]                       invisible(muffled)
[17:39:59.128]                     }
[17:39:59.128]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.128]                   }
[17:39:59.128]                 }
[17:39:59.128]                 else {
[17:39:59.128]                   if (TRUE) {
[17:39:59.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.128]                     {
[17:39:59.128]                       inherits <- base::inherits
[17:39:59.128]                       invokeRestart <- base::invokeRestart
[17:39:59.128]                       is.null <- base::is.null
[17:39:59.128]                       muffled <- FALSE
[17:39:59.128]                       if (inherits(cond, "message")) {
[17:39:59.128]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.128]                         if (muffled) 
[17:39:59.128]                           invokeRestart("muffleMessage")
[17:39:59.128]                       }
[17:39:59.128]                       else if (inherits(cond, "warning")) {
[17:39:59.128]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.128]                         if (muffled) 
[17:39:59.128]                           invokeRestart("muffleWarning")
[17:39:59.128]                       }
[17:39:59.128]                       else if (inherits(cond, "condition")) {
[17:39:59.128]                         if (!is.null(pattern)) {
[17:39:59.128]                           computeRestarts <- base::computeRestarts
[17:39:59.128]                           grepl <- base::grepl
[17:39:59.128]                           restarts <- computeRestarts(cond)
[17:39:59.128]                           for (restart in restarts) {
[17:39:59.128]                             name <- restart$name
[17:39:59.128]                             if (is.null(name)) 
[17:39:59.128]                               next
[17:39:59.128]                             if (!grepl(pattern, name)) 
[17:39:59.128]                               next
[17:39:59.128]                             invokeRestart(restart)
[17:39:59.128]                             muffled <- TRUE
[17:39:59.128]                             break
[17:39:59.128]                           }
[17:39:59.128]                         }
[17:39:59.128]                       }
[17:39:59.128]                       invisible(muffled)
[17:39:59.128]                     }
[17:39:59.128]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.128]                   }
[17:39:59.128]                 }
[17:39:59.128]             }
[17:39:59.128]         }))
[17:39:59.128]     }, error = function(ex) {
[17:39:59.128]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.128]                 ...future.rng), started = ...future.startTime, 
[17:39:59.128]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.128]             version = "1.8"), class = "FutureResult")
[17:39:59.128]     }, finally = {
[17:39:59.128]         if (!identical(...future.workdir, getwd())) 
[17:39:59.128]             setwd(...future.workdir)
[17:39:59.128]         {
[17:39:59.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.128]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.128]             }
[17:39:59.128]             base::options(...future.oldOptions)
[17:39:59.128]             if (.Platform$OS.type == "windows") {
[17:39:59.128]                 old_names <- names(...future.oldEnvVars)
[17:39:59.128]                 envs <- base::Sys.getenv()
[17:39:59.128]                 names <- names(envs)
[17:39:59.128]                 common <- intersect(names, old_names)
[17:39:59.128]                 added <- setdiff(names, old_names)
[17:39:59.128]                 removed <- setdiff(old_names, names)
[17:39:59.128]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.128]                   envs[common]]
[17:39:59.128]                 NAMES <- toupper(changed)
[17:39:59.128]                 args <- list()
[17:39:59.128]                 for (kk in seq_along(NAMES)) {
[17:39:59.128]                   name <- changed[[kk]]
[17:39:59.128]                   NAME <- NAMES[[kk]]
[17:39:59.128]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.128]                     next
[17:39:59.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.128]                 }
[17:39:59.128]                 NAMES <- toupper(added)
[17:39:59.128]                 for (kk in seq_along(NAMES)) {
[17:39:59.128]                   name <- added[[kk]]
[17:39:59.128]                   NAME <- NAMES[[kk]]
[17:39:59.128]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.128]                     next
[17:39:59.128]                   args[[name]] <- ""
[17:39:59.128]                 }
[17:39:59.128]                 NAMES <- toupper(removed)
[17:39:59.128]                 for (kk in seq_along(NAMES)) {
[17:39:59.128]                   name <- removed[[kk]]
[17:39:59.128]                   NAME <- NAMES[[kk]]
[17:39:59.128]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.128]                     next
[17:39:59.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.128]                 }
[17:39:59.128]                 if (length(args) > 0) 
[17:39:59.128]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.128]             }
[17:39:59.128]             else {
[17:39:59.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.128]             }
[17:39:59.128]             {
[17:39:59.128]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.128]                   0L) {
[17:39:59.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.128]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.128]                   base::options(opts)
[17:39:59.128]                 }
[17:39:59.128]                 {
[17:39:59.128]                   {
[17:39:59.128]                     NULL
[17:39:59.128]                     RNGkind("Mersenne-Twister")
[17:39:59.128]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:59.128]                       inherits = FALSE)
[17:39:59.128]                   }
[17:39:59.128]                   options(future.plan = NULL)
[17:39:59.128]                   if (is.na(NA_character_)) 
[17:39:59.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.128]                     .init = FALSE)
[17:39:59.128]                 }
[17:39:59.128]             }
[17:39:59.128]         }
[17:39:59.128]     })
[17:39:59.128]     if (TRUE) {
[17:39:59.128]         base::sink(type = "output", split = FALSE)
[17:39:59.128]         if (TRUE) {
[17:39:59.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.128]         }
[17:39:59.128]         else {
[17:39:59.128]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.128]         }
[17:39:59.128]         base::close(...future.stdout)
[17:39:59.128]         ...future.stdout <- NULL
[17:39:59.128]     }
[17:39:59.128]     ...future.result$conditions <- ...future.conditions
[17:39:59.128]     ...future.result$finished <- base::Sys.time()
[17:39:59.128]     ...future.result
[17:39:59.128] }
[17:39:59.130] assign_globals() ...
[17:39:59.130] List of 1
[17:39:59.130]  $ pkg: chr "foo"
[17:39:59.130]  - attr(*, "where")=List of 1
[17:39:59.130]   ..$ pkg:<environment: R_EmptyEnv> 
[17:39:59.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:59.130]  - attr(*, "resolved")= logi TRUE
[17:39:59.130]  - attr(*, "total_size")= num 112
[17:39:59.132] - copied ‘pkg’ to environment
[17:39:59.132] assign_globals() ... done
[17:39:59.132] plan(): Setting new future strategy stack:
[17:39:59.133] List of future strategies:
[17:39:59.133] 1. sequential:
[17:39:59.133]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:59.133]    - tweaked: FALSE
[17:39:59.133]    - call: NULL
[17:39:59.133] plan(): nbrOfWorkers() = 1
[17:39:59.134] plan(): Setting new future strategy stack:
[17:39:59.134] List of future strategies:
[17:39:59.134] 1. multisession:
[17:39:59.134]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:59.134]    - tweaked: FALSE
[17:39:59.134]    - call: plan(strategy)
[17:39:59.137] plan(): nbrOfWorkers() = 2
[17:39:59.138] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.138] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.139] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.140] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:59.140] Searching for globals ... DONE
[17:39:59.141] Resolving globals: TRUE
[17:39:59.141] Resolving any globals that are futures ...
[17:39:59.141] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:59.141] Resolving any globals that are futures ... DONE
[17:39:59.141] Resolving futures part of globals (recursively) ...
[17:39:59.141] resolve() on list ...
[17:39:59.142]  recursive: 99
[17:39:59.142]  length: 1
[17:39:59.142]  elements: ‘a’
[17:39:59.142]  length: 0 (resolved future 1)
[17:39:59.142] resolve() on list ... DONE
[17:39:59.142] - globals: [1] ‘a’
[17:39:59.142] Resolving futures part of globals (recursively) ... DONE
[17:39:59.142] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:59.143] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:39:59.143] - globals: [1] ‘a’
[17:39:59.143] 
[17:39:59.143] getGlobalsAndPackages() ... DONE
[17:39:59.143] run() for ‘Future’ ...
[17:39:59.143] - state: ‘created’
[17:39:59.143] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.157] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.157]   - Field: ‘node’
[17:39:59.157]   - Field: ‘label’
[17:39:59.157]   - Field: ‘local’
[17:39:59.157]   - Field: ‘owner’
[17:39:59.157]   - Field: ‘envir’
[17:39:59.157]   - Field: ‘workers’
[17:39:59.158]   - Field: ‘packages’
[17:39:59.158]   - Field: ‘gc’
[17:39:59.158]   - Field: ‘conditions’
[17:39:59.158]   - Field: ‘persistent’
[17:39:59.158]   - Field: ‘expr’
[17:39:59.158]   - Field: ‘uuid’
[17:39:59.158]   - Field: ‘seed’
[17:39:59.158]   - Field: ‘version’
[17:39:59.158]   - Field: ‘result’
[17:39:59.158]   - Field: ‘asynchronous’
[17:39:59.158]   - Field: ‘calls’
[17:39:59.158]   - Field: ‘globals’
[17:39:59.159]   - Field: ‘stdout’
[17:39:59.159]   - Field: ‘earlySignal’
[17:39:59.159]   - Field: ‘lazy’
[17:39:59.159]   - Field: ‘state’
[17:39:59.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.159] - Launch lazy future ...
[17:39:59.159] Packages needed by the future expression (n = 0): <none>
[17:39:59.159] Packages needed by future strategies (n = 0): <none>
[17:39:59.160] {
[17:39:59.160]     {
[17:39:59.160]         {
[17:39:59.160]             ...future.startTime <- base::Sys.time()
[17:39:59.160]             {
[17:39:59.160]                 {
[17:39:59.160]                   {
[17:39:59.160]                     {
[17:39:59.160]                       base::local({
[17:39:59.160]                         has_future <- base::requireNamespace("future", 
[17:39:59.160]                           quietly = TRUE)
[17:39:59.160]                         if (has_future) {
[17:39:59.160]                           ns <- base::getNamespace("future")
[17:39:59.160]                           version <- ns[[".package"]][["version"]]
[17:39:59.160]                           if (is.null(version)) 
[17:39:59.160]                             version <- utils::packageVersion("future")
[17:39:59.160]                         }
[17:39:59.160]                         else {
[17:39:59.160]                           version <- NULL
[17:39:59.160]                         }
[17:39:59.160]                         if (!has_future || version < "1.8.0") {
[17:39:59.160]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.160]                             "", base::R.version$version.string), 
[17:39:59.160]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.160]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.160]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.160]                               "release", "version")], collapse = " "), 
[17:39:59.160]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.160]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.160]                             info)
[17:39:59.160]                           info <- base::paste(info, collapse = "; ")
[17:39:59.160]                           if (!has_future) {
[17:39:59.160]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.160]                               info)
[17:39:59.160]                           }
[17:39:59.160]                           else {
[17:39:59.160]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.160]                               info, version)
[17:39:59.160]                           }
[17:39:59.160]                           base::stop(msg)
[17:39:59.160]                         }
[17:39:59.160]                       })
[17:39:59.160]                     }
[17:39:59.160]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.160]                     base::options(mc.cores = 1L)
[17:39:59.160]                   }
[17:39:59.160]                   ...future.strategy.old <- future::plan("list")
[17:39:59.160]                   options(future.plan = NULL)
[17:39:59.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.160]                 }
[17:39:59.160]                 ...future.workdir <- getwd()
[17:39:59.160]             }
[17:39:59.160]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.160]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.160]         }
[17:39:59.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.160]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.160]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.160]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.160]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.160]             base::names(...future.oldOptions))
[17:39:59.160]     }
[17:39:59.160]     if (FALSE) {
[17:39:59.160]     }
[17:39:59.160]     else {
[17:39:59.160]         if (TRUE) {
[17:39:59.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.160]                 open = "w")
[17:39:59.160]         }
[17:39:59.160]         else {
[17:39:59.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.160]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.160]         }
[17:39:59.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.160]             base::sink(type = "output", split = FALSE)
[17:39:59.160]             base::close(...future.stdout)
[17:39:59.160]         }, add = TRUE)
[17:39:59.160]     }
[17:39:59.160]     ...future.frame <- base::sys.nframe()
[17:39:59.160]     ...future.conditions <- base::list()
[17:39:59.160]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.160]     if (FALSE) {
[17:39:59.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.160]     }
[17:39:59.160]     ...future.result <- base::tryCatch({
[17:39:59.160]         base::withCallingHandlers({
[17:39:59.160]             ...future.value <- base::withVisible(base::local({
[17:39:59.160]                 ...future.makeSendCondition <- base::local({
[17:39:59.160]                   sendCondition <- NULL
[17:39:59.160]                   function(frame = 1L) {
[17:39:59.160]                     if (is.function(sendCondition)) 
[17:39:59.160]                       return(sendCondition)
[17:39:59.160]                     ns <- getNamespace("parallel")
[17:39:59.160]                     if (exists("sendData", mode = "function", 
[17:39:59.160]                       envir = ns)) {
[17:39:59.160]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.160]                         envir = ns)
[17:39:59.160]                       envir <- sys.frame(frame)
[17:39:59.160]                       master <- NULL
[17:39:59.160]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.160]                         !identical(envir, emptyenv())) {
[17:39:59.160]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.160]                           inherits = FALSE)) {
[17:39:59.160]                           master <- get("master", mode = "list", 
[17:39:59.160]                             envir = envir, inherits = FALSE)
[17:39:59.160]                           if (inherits(master, c("SOCKnode", 
[17:39:59.160]                             "SOCK0node"))) {
[17:39:59.160]                             sendCondition <<- function(cond) {
[17:39:59.160]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.160]                                 success = TRUE)
[17:39:59.160]                               parallel_sendData(master, data)
[17:39:59.160]                             }
[17:39:59.160]                             return(sendCondition)
[17:39:59.160]                           }
[17:39:59.160]                         }
[17:39:59.160]                         frame <- frame + 1L
[17:39:59.160]                         envir <- sys.frame(frame)
[17:39:59.160]                       }
[17:39:59.160]                     }
[17:39:59.160]                     sendCondition <<- function(cond) NULL
[17:39:59.160]                   }
[17:39:59.160]                 })
[17:39:59.160]                 withCallingHandlers({
[17:39:59.160]                   {
[17:39:59.160]                     b <- a
[17:39:59.160]                     a <- 2
[17:39:59.160]                     a * b
[17:39:59.160]                   }
[17:39:59.160]                 }, immediateCondition = function(cond) {
[17:39:59.160]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.160]                   sendCondition(cond)
[17:39:59.160]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.160]                   {
[17:39:59.160]                     inherits <- base::inherits
[17:39:59.160]                     invokeRestart <- base::invokeRestart
[17:39:59.160]                     is.null <- base::is.null
[17:39:59.160]                     muffled <- FALSE
[17:39:59.160]                     if (inherits(cond, "message")) {
[17:39:59.160]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.160]                       if (muffled) 
[17:39:59.160]                         invokeRestart("muffleMessage")
[17:39:59.160]                     }
[17:39:59.160]                     else if (inherits(cond, "warning")) {
[17:39:59.160]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.160]                       if (muffled) 
[17:39:59.160]                         invokeRestart("muffleWarning")
[17:39:59.160]                     }
[17:39:59.160]                     else if (inherits(cond, "condition")) {
[17:39:59.160]                       if (!is.null(pattern)) {
[17:39:59.160]                         computeRestarts <- base::computeRestarts
[17:39:59.160]                         grepl <- base::grepl
[17:39:59.160]                         restarts <- computeRestarts(cond)
[17:39:59.160]                         for (restart in restarts) {
[17:39:59.160]                           name <- restart$name
[17:39:59.160]                           if (is.null(name)) 
[17:39:59.160]                             next
[17:39:59.160]                           if (!grepl(pattern, name)) 
[17:39:59.160]                             next
[17:39:59.160]                           invokeRestart(restart)
[17:39:59.160]                           muffled <- TRUE
[17:39:59.160]                           break
[17:39:59.160]                         }
[17:39:59.160]                       }
[17:39:59.160]                     }
[17:39:59.160]                     invisible(muffled)
[17:39:59.160]                   }
[17:39:59.160]                   muffleCondition(cond)
[17:39:59.160]                 })
[17:39:59.160]             }))
[17:39:59.160]             future::FutureResult(value = ...future.value$value, 
[17:39:59.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.160]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.160]                     ...future.globalenv.names))
[17:39:59.160]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.160]         }, condition = base::local({
[17:39:59.160]             c <- base::c
[17:39:59.160]             inherits <- base::inherits
[17:39:59.160]             invokeRestart <- base::invokeRestart
[17:39:59.160]             length <- base::length
[17:39:59.160]             list <- base::list
[17:39:59.160]             seq.int <- base::seq.int
[17:39:59.160]             signalCondition <- base::signalCondition
[17:39:59.160]             sys.calls <- base::sys.calls
[17:39:59.160]             `[[` <- base::`[[`
[17:39:59.160]             `+` <- base::`+`
[17:39:59.160]             `<<-` <- base::`<<-`
[17:39:59.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.160]                   3L)]
[17:39:59.160]             }
[17:39:59.160]             function(cond) {
[17:39:59.160]                 is_error <- inherits(cond, "error")
[17:39:59.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.160]                   NULL)
[17:39:59.160]                 if (is_error) {
[17:39:59.160]                   sessionInformation <- function() {
[17:39:59.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.160]                       search = base::search(), system = base::Sys.info())
[17:39:59.160]                   }
[17:39:59.160]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.160]                     cond$call), session = sessionInformation(), 
[17:39:59.160]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.160]                   signalCondition(cond)
[17:39:59.160]                 }
[17:39:59.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.160]                 "immediateCondition"))) {
[17:39:59.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.160]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.160]                   if (TRUE && !signal) {
[17:39:59.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.160]                     {
[17:39:59.160]                       inherits <- base::inherits
[17:39:59.160]                       invokeRestart <- base::invokeRestart
[17:39:59.160]                       is.null <- base::is.null
[17:39:59.160]                       muffled <- FALSE
[17:39:59.160]                       if (inherits(cond, "message")) {
[17:39:59.160]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.160]                         if (muffled) 
[17:39:59.160]                           invokeRestart("muffleMessage")
[17:39:59.160]                       }
[17:39:59.160]                       else if (inherits(cond, "warning")) {
[17:39:59.160]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.160]                         if (muffled) 
[17:39:59.160]                           invokeRestart("muffleWarning")
[17:39:59.160]                       }
[17:39:59.160]                       else if (inherits(cond, "condition")) {
[17:39:59.160]                         if (!is.null(pattern)) {
[17:39:59.160]                           computeRestarts <- base::computeRestarts
[17:39:59.160]                           grepl <- base::grepl
[17:39:59.160]                           restarts <- computeRestarts(cond)
[17:39:59.160]                           for (restart in restarts) {
[17:39:59.160]                             name <- restart$name
[17:39:59.160]                             if (is.null(name)) 
[17:39:59.160]                               next
[17:39:59.160]                             if (!grepl(pattern, name)) 
[17:39:59.160]                               next
[17:39:59.160]                             invokeRestart(restart)
[17:39:59.160]                             muffled <- TRUE
[17:39:59.160]                             break
[17:39:59.160]                           }
[17:39:59.160]                         }
[17:39:59.160]                       }
[17:39:59.160]                       invisible(muffled)
[17:39:59.160]                     }
[17:39:59.160]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.160]                   }
[17:39:59.160]                 }
[17:39:59.160]                 else {
[17:39:59.160]                   if (TRUE) {
[17:39:59.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.160]                     {
[17:39:59.160]                       inherits <- base::inherits
[17:39:59.160]                       invokeRestart <- base::invokeRestart
[17:39:59.160]                       is.null <- base::is.null
[17:39:59.160]                       muffled <- FALSE
[17:39:59.160]                       if (inherits(cond, "message")) {
[17:39:59.160]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.160]                         if (muffled) 
[17:39:59.160]                           invokeRestart("muffleMessage")
[17:39:59.160]                       }
[17:39:59.160]                       else if (inherits(cond, "warning")) {
[17:39:59.160]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.160]                         if (muffled) 
[17:39:59.160]                           invokeRestart("muffleWarning")
[17:39:59.160]                       }
[17:39:59.160]                       else if (inherits(cond, "condition")) {
[17:39:59.160]                         if (!is.null(pattern)) {
[17:39:59.160]                           computeRestarts <- base::computeRestarts
[17:39:59.160]                           grepl <- base::grepl
[17:39:59.160]                           restarts <- computeRestarts(cond)
[17:39:59.160]                           for (restart in restarts) {
[17:39:59.160]                             name <- restart$name
[17:39:59.160]                             if (is.null(name)) 
[17:39:59.160]                               next
[17:39:59.160]                             if (!grepl(pattern, name)) 
[17:39:59.160]                               next
[17:39:59.160]                             invokeRestart(restart)
[17:39:59.160]                             muffled <- TRUE
[17:39:59.160]                             break
[17:39:59.160]                           }
[17:39:59.160]                         }
[17:39:59.160]                       }
[17:39:59.160]                       invisible(muffled)
[17:39:59.160]                     }
[17:39:59.160]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.160]                   }
[17:39:59.160]                 }
[17:39:59.160]             }
[17:39:59.160]         }))
[17:39:59.160]     }, error = function(ex) {
[17:39:59.160]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.160]                 ...future.rng), started = ...future.startTime, 
[17:39:59.160]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.160]             version = "1.8"), class = "FutureResult")
[17:39:59.160]     }, finally = {
[17:39:59.160]         if (!identical(...future.workdir, getwd())) 
[17:39:59.160]             setwd(...future.workdir)
[17:39:59.160]         {
[17:39:59.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.160]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.160]             }
[17:39:59.160]             base::options(...future.oldOptions)
[17:39:59.160]             if (.Platform$OS.type == "windows") {
[17:39:59.160]                 old_names <- names(...future.oldEnvVars)
[17:39:59.160]                 envs <- base::Sys.getenv()
[17:39:59.160]                 names <- names(envs)
[17:39:59.160]                 common <- intersect(names, old_names)
[17:39:59.160]                 added <- setdiff(names, old_names)
[17:39:59.160]                 removed <- setdiff(old_names, names)
[17:39:59.160]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.160]                   envs[common]]
[17:39:59.160]                 NAMES <- toupper(changed)
[17:39:59.160]                 args <- list()
[17:39:59.160]                 for (kk in seq_along(NAMES)) {
[17:39:59.160]                   name <- changed[[kk]]
[17:39:59.160]                   NAME <- NAMES[[kk]]
[17:39:59.160]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.160]                     next
[17:39:59.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.160]                 }
[17:39:59.160]                 NAMES <- toupper(added)
[17:39:59.160]                 for (kk in seq_along(NAMES)) {
[17:39:59.160]                   name <- added[[kk]]
[17:39:59.160]                   NAME <- NAMES[[kk]]
[17:39:59.160]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.160]                     next
[17:39:59.160]                   args[[name]] <- ""
[17:39:59.160]                 }
[17:39:59.160]                 NAMES <- toupper(removed)
[17:39:59.160]                 for (kk in seq_along(NAMES)) {
[17:39:59.160]                   name <- removed[[kk]]
[17:39:59.160]                   NAME <- NAMES[[kk]]
[17:39:59.160]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.160]                     next
[17:39:59.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.160]                 }
[17:39:59.160]                 if (length(args) > 0) 
[17:39:59.160]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.160]             }
[17:39:59.160]             else {
[17:39:59.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.160]             }
[17:39:59.160]             {
[17:39:59.160]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.160]                   0L) {
[17:39:59.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.160]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.160]                   base::options(opts)
[17:39:59.160]                 }
[17:39:59.160]                 {
[17:39:59.160]                   {
[17:39:59.160]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.160]                     NULL
[17:39:59.160]                   }
[17:39:59.160]                   options(future.plan = NULL)
[17:39:59.160]                   if (is.na(NA_character_)) 
[17:39:59.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.160]                     .init = FALSE)
[17:39:59.160]                 }
[17:39:59.160]             }
[17:39:59.160]         }
[17:39:59.160]     })
[17:39:59.160]     if (TRUE) {
[17:39:59.160]         base::sink(type = "output", split = FALSE)
[17:39:59.160]         if (TRUE) {
[17:39:59.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.160]         }
[17:39:59.160]         else {
[17:39:59.160]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.160]         }
[17:39:59.160]         base::close(...future.stdout)
[17:39:59.160]         ...future.stdout <- NULL
[17:39:59.160]     }
[17:39:59.160]     ...future.result$conditions <- ...future.conditions
[17:39:59.160]     ...future.result$finished <- base::Sys.time()
[17:39:59.160]     ...future.result
[17:39:59.160] }
[17:39:59.162] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:39:59.163] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:39:59.163] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:39:59.163] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:39:59.163] MultisessionFuture started
[17:39:59.163] - Launch lazy future ... done
[17:39:59.164] run() for ‘MultisessionFuture’ ... done
[17:39:59.164] result() for ClusterFuture ...
[17:39:59.164] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.164] - Validating connection of MultisessionFuture
[17:39:59.206] - received message: FutureResult
[17:39:59.206] - Received FutureResult
[17:39:59.206] - Erased future from FutureRegistry
[17:39:59.207] result() for ClusterFuture ...
[17:39:59.207] - result already collected: FutureResult
[17:39:59.207] result() for ClusterFuture ... done
[17:39:59.207] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.207] result() for ClusterFuture ... done
[17:39:59.207] result() for ClusterFuture ...
[17:39:59.207] - result already collected: FutureResult
[17:39:59.207] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.208] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.208] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.210] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:59.210] Searching for globals ... DONE
[17:39:59.210] Resolving globals: TRUE
[17:39:59.210] Resolving any globals that are futures ...
[17:39:59.210] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:39:59.210] Resolving any globals that are futures ... DONE
[17:39:59.210] Resolving futures part of globals (recursively) ...
[17:39:59.211] resolve() on list ...
[17:39:59.211]  recursive: 99
[17:39:59.211]  length: 1
[17:39:59.211]  elements: ‘a’
[17:39:59.211]  length: 0 (resolved future 1)
[17:39:59.211] resolve() on list ... DONE
[17:39:59.211] - globals: [1] ‘a’
[17:39:59.211] Resolving futures part of globals (recursively) ... DONE
[17:39:59.211] The total size of the 1 globals is 56 bytes (56 bytes)
[17:39:59.212] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:39:59.212] - globals: [1] ‘a’
[17:39:59.212] 
[17:39:59.212] getGlobalsAndPackages() ... DONE
[17:39:59.212] run() for ‘Future’ ...
[17:39:59.212] - state: ‘created’
[17:39:59.213] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.226]   - Field: ‘node’
[17:39:59.226]   - Field: ‘label’
[17:39:59.227]   - Field: ‘local’
[17:39:59.227]   - Field: ‘owner’
[17:39:59.227]   - Field: ‘envir’
[17:39:59.227]   - Field: ‘workers’
[17:39:59.227]   - Field: ‘packages’
[17:39:59.227]   - Field: ‘gc’
[17:39:59.227]   - Field: ‘conditions’
[17:39:59.227]   - Field: ‘persistent’
[17:39:59.227]   - Field: ‘expr’
[17:39:59.227]   - Field: ‘uuid’
[17:39:59.227]   - Field: ‘seed’
[17:39:59.228]   - Field: ‘version’
[17:39:59.228]   - Field: ‘result’
[17:39:59.228]   - Field: ‘asynchronous’
[17:39:59.228]   - Field: ‘calls’
[17:39:59.228]   - Field: ‘globals’
[17:39:59.228]   - Field: ‘stdout’
[17:39:59.228]   - Field: ‘earlySignal’
[17:39:59.228]   - Field: ‘lazy’
[17:39:59.228]   - Field: ‘state’
[17:39:59.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.228] - Launch lazy future ...
[17:39:59.229] Packages needed by the future expression (n = 0): <none>
[17:39:59.229] Packages needed by future strategies (n = 0): <none>
[17:39:59.229] {
[17:39:59.229]     {
[17:39:59.229]         {
[17:39:59.229]             ...future.startTime <- base::Sys.time()
[17:39:59.229]             {
[17:39:59.229]                 {
[17:39:59.229]                   {
[17:39:59.229]                     {
[17:39:59.229]                       base::local({
[17:39:59.229]                         has_future <- base::requireNamespace("future", 
[17:39:59.229]                           quietly = TRUE)
[17:39:59.229]                         if (has_future) {
[17:39:59.229]                           ns <- base::getNamespace("future")
[17:39:59.229]                           version <- ns[[".package"]][["version"]]
[17:39:59.229]                           if (is.null(version)) 
[17:39:59.229]                             version <- utils::packageVersion("future")
[17:39:59.229]                         }
[17:39:59.229]                         else {
[17:39:59.229]                           version <- NULL
[17:39:59.229]                         }
[17:39:59.229]                         if (!has_future || version < "1.8.0") {
[17:39:59.229]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.229]                             "", base::R.version$version.string), 
[17:39:59.229]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.229]                               "release", "version")], collapse = " "), 
[17:39:59.229]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.229]                             info)
[17:39:59.229]                           info <- base::paste(info, collapse = "; ")
[17:39:59.229]                           if (!has_future) {
[17:39:59.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.229]                               info)
[17:39:59.229]                           }
[17:39:59.229]                           else {
[17:39:59.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.229]                               info, version)
[17:39:59.229]                           }
[17:39:59.229]                           base::stop(msg)
[17:39:59.229]                         }
[17:39:59.229]                       })
[17:39:59.229]                     }
[17:39:59.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.229]                     base::options(mc.cores = 1L)
[17:39:59.229]                   }
[17:39:59.229]                   ...future.strategy.old <- future::plan("list")
[17:39:59.229]                   options(future.plan = NULL)
[17:39:59.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.229]                 }
[17:39:59.229]                 ...future.workdir <- getwd()
[17:39:59.229]             }
[17:39:59.229]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.229]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.229]         }
[17:39:59.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.229]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.229]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.229]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.229]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.229]             base::names(...future.oldOptions))
[17:39:59.229]     }
[17:39:59.229]     if (FALSE) {
[17:39:59.229]     }
[17:39:59.229]     else {
[17:39:59.229]         if (TRUE) {
[17:39:59.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.229]                 open = "w")
[17:39:59.229]         }
[17:39:59.229]         else {
[17:39:59.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.229]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.229]         }
[17:39:59.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.229]             base::sink(type = "output", split = FALSE)
[17:39:59.229]             base::close(...future.stdout)
[17:39:59.229]         }, add = TRUE)
[17:39:59.229]     }
[17:39:59.229]     ...future.frame <- base::sys.nframe()
[17:39:59.229]     ...future.conditions <- base::list()
[17:39:59.229]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.229]     if (FALSE) {
[17:39:59.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.229]     }
[17:39:59.229]     ...future.result <- base::tryCatch({
[17:39:59.229]         base::withCallingHandlers({
[17:39:59.229]             ...future.value <- base::withVisible(base::local({
[17:39:59.229]                 ...future.makeSendCondition <- base::local({
[17:39:59.229]                   sendCondition <- NULL
[17:39:59.229]                   function(frame = 1L) {
[17:39:59.229]                     if (is.function(sendCondition)) 
[17:39:59.229]                       return(sendCondition)
[17:39:59.229]                     ns <- getNamespace("parallel")
[17:39:59.229]                     if (exists("sendData", mode = "function", 
[17:39:59.229]                       envir = ns)) {
[17:39:59.229]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.229]                         envir = ns)
[17:39:59.229]                       envir <- sys.frame(frame)
[17:39:59.229]                       master <- NULL
[17:39:59.229]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.229]                         !identical(envir, emptyenv())) {
[17:39:59.229]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.229]                           inherits = FALSE)) {
[17:39:59.229]                           master <- get("master", mode = "list", 
[17:39:59.229]                             envir = envir, inherits = FALSE)
[17:39:59.229]                           if (inherits(master, c("SOCKnode", 
[17:39:59.229]                             "SOCK0node"))) {
[17:39:59.229]                             sendCondition <<- function(cond) {
[17:39:59.229]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.229]                                 success = TRUE)
[17:39:59.229]                               parallel_sendData(master, data)
[17:39:59.229]                             }
[17:39:59.229]                             return(sendCondition)
[17:39:59.229]                           }
[17:39:59.229]                         }
[17:39:59.229]                         frame <- frame + 1L
[17:39:59.229]                         envir <- sys.frame(frame)
[17:39:59.229]                       }
[17:39:59.229]                     }
[17:39:59.229]                     sendCondition <<- function(cond) NULL
[17:39:59.229]                   }
[17:39:59.229]                 })
[17:39:59.229]                 withCallingHandlers({
[17:39:59.229]                   {
[17:39:59.229]                     b <- a
[17:39:59.229]                     a <- 2
[17:39:59.229]                     a * b
[17:39:59.229]                   }
[17:39:59.229]                 }, immediateCondition = function(cond) {
[17:39:59.229]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.229]                   sendCondition(cond)
[17:39:59.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.229]                   {
[17:39:59.229]                     inherits <- base::inherits
[17:39:59.229]                     invokeRestart <- base::invokeRestart
[17:39:59.229]                     is.null <- base::is.null
[17:39:59.229]                     muffled <- FALSE
[17:39:59.229]                     if (inherits(cond, "message")) {
[17:39:59.229]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.229]                       if (muffled) 
[17:39:59.229]                         invokeRestart("muffleMessage")
[17:39:59.229]                     }
[17:39:59.229]                     else if (inherits(cond, "warning")) {
[17:39:59.229]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.229]                       if (muffled) 
[17:39:59.229]                         invokeRestart("muffleWarning")
[17:39:59.229]                     }
[17:39:59.229]                     else if (inherits(cond, "condition")) {
[17:39:59.229]                       if (!is.null(pattern)) {
[17:39:59.229]                         computeRestarts <- base::computeRestarts
[17:39:59.229]                         grepl <- base::grepl
[17:39:59.229]                         restarts <- computeRestarts(cond)
[17:39:59.229]                         for (restart in restarts) {
[17:39:59.229]                           name <- restart$name
[17:39:59.229]                           if (is.null(name)) 
[17:39:59.229]                             next
[17:39:59.229]                           if (!grepl(pattern, name)) 
[17:39:59.229]                             next
[17:39:59.229]                           invokeRestart(restart)
[17:39:59.229]                           muffled <- TRUE
[17:39:59.229]                           break
[17:39:59.229]                         }
[17:39:59.229]                       }
[17:39:59.229]                     }
[17:39:59.229]                     invisible(muffled)
[17:39:59.229]                   }
[17:39:59.229]                   muffleCondition(cond)
[17:39:59.229]                 })
[17:39:59.229]             }))
[17:39:59.229]             future::FutureResult(value = ...future.value$value, 
[17:39:59.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.229]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.229]                     ...future.globalenv.names))
[17:39:59.229]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.229]         }, condition = base::local({
[17:39:59.229]             c <- base::c
[17:39:59.229]             inherits <- base::inherits
[17:39:59.229]             invokeRestart <- base::invokeRestart
[17:39:59.229]             length <- base::length
[17:39:59.229]             list <- base::list
[17:39:59.229]             seq.int <- base::seq.int
[17:39:59.229]             signalCondition <- base::signalCondition
[17:39:59.229]             sys.calls <- base::sys.calls
[17:39:59.229]             `[[` <- base::`[[`
[17:39:59.229]             `+` <- base::`+`
[17:39:59.229]             `<<-` <- base::`<<-`
[17:39:59.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.229]                   3L)]
[17:39:59.229]             }
[17:39:59.229]             function(cond) {
[17:39:59.229]                 is_error <- inherits(cond, "error")
[17:39:59.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.229]                   NULL)
[17:39:59.229]                 if (is_error) {
[17:39:59.229]                   sessionInformation <- function() {
[17:39:59.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.229]                       search = base::search(), system = base::Sys.info())
[17:39:59.229]                   }
[17:39:59.229]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.229]                     cond$call), session = sessionInformation(), 
[17:39:59.229]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.229]                   signalCondition(cond)
[17:39:59.229]                 }
[17:39:59.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.229]                 "immediateCondition"))) {
[17:39:59.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.229]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.229]                   if (TRUE && !signal) {
[17:39:59.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.229]                     {
[17:39:59.229]                       inherits <- base::inherits
[17:39:59.229]                       invokeRestart <- base::invokeRestart
[17:39:59.229]                       is.null <- base::is.null
[17:39:59.229]                       muffled <- FALSE
[17:39:59.229]                       if (inherits(cond, "message")) {
[17:39:59.229]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.229]                         if (muffled) 
[17:39:59.229]                           invokeRestart("muffleMessage")
[17:39:59.229]                       }
[17:39:59.229]                       else if (inherits(cond, "warning")) {
[17:39:59.229]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.229]                         if (muffled) 
[17:39:59.229]                           invokeRestart("muffleWarning")
[17:39:59.229]                       }
[17:39:59.229]                       else if (inherits(cond, "condition")) {
[17:39:59.229]                         if (!is.null(pattern)) {
[17:39:59.229]                           computeRestarts <- base::computeRestarts
[17:39:59.229]                           grepl <- base::grepl
[17:39:59.229]                           restarts <- computeRestarts(cond)
[17:39:59.229]                           for (restart in restarts) {
[17:39:59.229]                             name <- restart$name
[17:39:59.229]                             if (is.null(name)) 
[17:39:59.229]                               next
[17:39:59.229]                             if (!grepl(pattern, name)) 
[17:39:59.229]                               next
[17:39:59.229]                             invokeRestart(restart)
[17:39:59.229]                             muffled <- TRUE
[17:39:59.229]                             break
[17:39:59.229]                           }
[17:39:59.229]                         }
[17:39:59.229]                       }
[17:39:59.229]                       invisible(muffled)
[17:39:59.229]                     }
[17:39:59.229]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.229]                   }
[17:39:59.229]                 }
[17:39:59.229]                 else {
[17:39:59.229]                   if (TRUE) {
[17:39:59.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.229]                     {
[17:39:59.229]                       inherits <- base::inherits
[17:39:59.229]                       invokeRestart <- base::invokeRestart
[17:39:59.229]                       is.null <- base::is.null
[17:39:59.229]                       muffled <- FALSE
[17:39:59.229]                       if (inherits(cond, "message")) {
[17:39:59.229]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.229]                         if (muffled) 
[17:39:59.229]                           invokeRestart("muffleMessage")
[17:39:59.229]                       }
[17:39:59.229]                       else if (inherits(cond, "warning")) {
[17:39:59.229]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.229]                         if (muffled) 
[17:39:59.229]                           invokeRestart("muffleWarning")
[17:39:59.229]                       }
[17:39:59.229]                       else if (inherits(cond, "condition")) {
[17:39:59.229]                         if (!is.null(pattern)) {
[17:39:59.229]                           computeRestarts <- base::computeRestarts
[17:39:59.229]                           grepl <- base::grepl
[17:39:59.229]                           restarts <- computeRestarts(cond)
[17:39:59.229]                           for (restart in restarts) {
[17:39:59.229]                             name <- restart$name
[17:39:59.229]                             if (is.null(name)) 
[17:39:59.229]                               next
[17:39:59.229]                             if (!grepl(pattern, name)) 
[17:39:59.229]                               next
[17:39:59.229]                             invokeRestart(restart)
[17:39:59.229]                             muffled <- TRUE
[17:39:59.229]                             break
[17:39:59.229]                           }
[17:39:59.229]                         }
[17:39:59.229]                       }
[17:39:59.229]                       invisible(muffled)
[17:39:59.229]                     }
[17:39:59.229]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.229]                   }
[17:39:59.229]                 }
[17:39:59.229]             }
[17:39:59.229]         }))
[17:39:59.229]     }, error = function(ex) {
[17:39:59.229]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.229]                 ...future.rng), started = ...future.startTime, 
[17:39:59.229]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.229]             version = "1.8"), class = "FutureResult")
[17:39:59.229]     }, finally = {
[17:39:59.229]         if (!identical(...future.workdir, getwd())) 
[17:39:59.229]             setwd(...future.workdir)
[17:39:59.229]         {
[17:39:59.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.229]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.229]             }
[17:39:59.229]             base::options(...future.oldOptions)
[17:39:59.229]             if (.Platform$OS.type == "windows") {
[17:39:59.229]                 old_names <- names(...future.oldEnvVars)
[17:39:59.229]                 envs <- base::Sys.getenv()
[17:39:59.229]                 names <- names(envs)
[17:39:59.229]                 common <- intersect(names, old_names)
[17:39:59.229]                 added <- setdiff(names, old_names)
[17:39:59.229]                 removed <- setdiff(old_names, names)
[17:39:59.229]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.229]                   envs[common]]
[17:39:59.229]                 NAMES <- toupper(changed)
[17:39:59.229]                 args <- list()
[17:39:59.229]                 for (kk in seq_along(NAMES)) {
[17:39:59.229]                   name <- changed[[kk]]
[17:39:59.229]                   NAME <- NAMES[[kk]]
[17:39:59.229]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.229]                     next
[17:39:59.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.229]                 }
[17:39:59.229]                 NAMES <- toupper(added)
[17:39:59.229]                 for (kk in seq_along(NAMES)) {
[17:39:59.229]                   name <- added[[kk]]
[17:39:59.229]                   NAME <- NAMES[[kk]]
[17:39:59.229]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.229]                     next
[17:39:59.229]                   args[[name]] <- ""
[17:39:59.229]                 }
[17:39:59.229]                 NAMES <- toupper(removed)
[17:39:59.229]                 for (kk in seq_along(NAMES)) {
[17:39:59.229]                   name <- removed[[kk]]
[17:39:59.229]                   NAME <- NAMES[[kk]]
[17:39:59.229]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.229]                     next
[17:39:59.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.229]                 }
[17:39:59.229]                 if (length(args) > 0) 
[17:39:59.229]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.229]             }
[17:39:59.229]             else {
[17:39:59.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.229]             }
[17:39:59.229]             {
[17:39:59.229]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.229]                   0L) {
[17:39:59.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.229]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.229]                   base::options(opts)
[17:39:59.229]                 }
[17:39:59.229]                 {
[17:39:59.229]                   {
[17:39:59.229]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.229]                     NULL
[17:39:59.229]                   }
[17:39:59.229]                   options(future.plan = NULL)
[17:39:59.229]                   if (is.na(NA_character_)) 
[17:39:59.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.229]                     .init = FALSE)
[17:39:59.229]                 }
[17:39:59.229]             }
[17:39:59.229]         }
[17:39:59.229]     })
[17:39:59.229]     if (TRUE) {
[17:39:59.229]         base::sink(type = "output", split = FALSE)
[17:39:59.229]         if (TRUE) {
[17:39:59.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.229]         }
[17:39:59.229]         else {
[17:39:59.229]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.229]         }
[17:39:59.229]         base::close(...future.stdout)
[17:39:59.229]         ...future.stdout <- NULL
[17:39:59.229]     }
[17:39:59.229]     ...future.result$conditions <- ...future.conditions
[17:39:59.229]     ...future.result$finished <- base::Sys.time()
[17:39:59.229]     ...future.result
[17:39:59.229] }
[17:39:59.232] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:39:59.232] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:39:59.232] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:39:59.232] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:39:59.233] MultisessionFuture started
[17:39:59.233] - Launch lazy future ... done
[17:39:59.233] run() for ‘MultisessionFuture’ ... done
[17:39:59.233] result() for ClusterFuture ...
[17:39:59.233] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.233] - Validating connection of MultisessionFuture
[17:39:59.278] - received message: FutureResult
[17:39:59.278] - Received FutureResult
[17:39:59.278] - Erased future from FutureRegistry
[17:39:59.278] result() for ClusterFuture ...
[17:39:59.278] - result already collected: FutureResult
[17:39:59.279] result() for ClusterFuture ... done
[17:39:59.279] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.279] result() for ClusterFuture ... done
[17:39:59.279] result() for ClusterFuture ...
[17:39:59.279] - result already collected: FutureResult
[17:39:59.279] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.280] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.280] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.282] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.282] Searching for globals ... DONE
[17:39:59.282] Resolving globals: TRUE
[17:39:59.282] Resolving any globals that are futures ...
[17:39:59.282] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.282] Resolving any globals that are futures ... DONE
[17:39:59.283] Resolving futures part of globals (recursively) ...
[17:39:59.283] resolve() on list ...
[17:39:59.283]  recursive: 99
[17:39:59.283]  length: 2
[17:39:59.283]  elements: ‘a’, ‘ii’
[17:39:59.283]  length: 1 (resolved future 1)
[17:39:59.283]  length: 0 (resolved future 2)
[17:39:59.283] resolve() on list ... DONE
[17:39:59.283] - globals: [2] ‘a’, ‘ii’
[17:39:59.283] Resolving futures part of globals (recursively) ... DONE
[17:39:59.284] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:59.284] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:59.284] - globals: [2] ‘a’, ‘ii’
[17:39:59.284] 
[17:39:59.284] getGlobalsAndPackages() ... DONE
[17:39:59.285] run() for ‘Future’ ...
[17:39:59.285] - state: ‘created’
[17:39:59.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.298] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.299]   - Field: ‘node’
[17:39:59.299]   - Field: ‘label’
[17:39:59.299]   - Field: ‘local’
[17:39:59.299]   - Field: ‘owner’
[17:39:59.299]   - Field: ‘envir’
[17:39:59.299]   - Field: ‘workers’
[17:39:59.299]   - Field: ‘packages’
[17:39:59.299]   - Field: ‘gc’
[17:39:59.299]   - Field: ‘conditions’
[17:39:59.299]   - Field: ‘persistent’
[17:39:59.299]   - Field: ‘expr’
[17:39:59.299]   - Field: ‘uuid’
[17:39:59.300]   - Field: ‘seed’
[17:39:59.300]   - Field: ‘version’
[17:39:59.300]   - Field: ‘result’
[17:39:59.300]   - Field: ‘asynchronous’
[17:39:59.300]   - Field: ‘calls’
[17:39:59.300]   - Field: ‘globals’
[17:39:59.300]   - Field: ‘stdout’
[17:39:59.302]   - Field: ‘earlySignal’
[17:39:59.302]   - Field: ‘lazy’
[17:39:59.302]   - Field: ‘state’
[17:39:59.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.303] - Launch lazy future ...
[17:39:59.303] Packages needed by the future expression (n = 0): <none>
[17:39:59.303] Packages needed by future strategies (n = 0): <none>
[17:39:59.303] {
[17:39:59.303]     {
[17:39:59.303]         {
[17:39:59.303]             ...future.startTime <- base::Sys.time()
[17:39:59.303]             {
[17:39:59.303]                 {
[17:39:59.303]                   {
[17:39:59.303]                     {
[17:39:59.303]                       base::local({
[17:39:59.303]                         has_future <- base::requireNamespace("future", 
[17:39:59.303]                           quietly = TRUE)
[17:39:59.303]                         if (has_future) {
[17:39:59.303]                           ns <- base::getNamespace("future")
[17:39:59.303]                           version <- ns[[".package"]][["version"]]
[17:39:59.303]                           if (is.null(version)) 
[17:39:59.303]                             version <- utils::packageVersion("future")
[17:39:59.303]                         }
[17:39:59.303]                         else {
[17:39:59.303]                           version <- NULL
[17:39:59.303]                         }
[17:39:59.303]                         if (!has_future || version < "1.8.0") {
[17:39:59.303]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.303]                             "", base::R.version$version.string), 
[17:39:59.303]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.303]                               "release", "version")], collapse = " "), 
[17:39:59.303]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.303]                             info)
[17:39:59.303]                           info <- base::paste(info, collapse = "; ")
[17:39:59.303]                           if (!has_future) {
[17:39:59.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.303]                               info)
[17:39:59.303]                           }
[17:39:59.303]                           else {
[17:39:59.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.303]                               info, version)
[17:39:59.303]                           }
[17:39:59.303]                           base::stop(msg)
[17:39:59.303]                         }
[17:39:59.303]                       })
[17:39:59.303]                     }
[17:39:59.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.303]                     base::options(mc.cores = 1L)
[17:39:59.303]                   }
[17:39:59.303]                   ...future.strategy.old <- future::plan("list")
[17:39:59.303]                   options(future.plan = NULL)
[17:39:59.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.303]                 }
[17:39:59.303]                 ...future.workdir <- getwd()
[17:39:59.303]             }
[17:39:59.303]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.303]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.303]         }
[17:39:59.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.303]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.303]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.303]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.303]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.303]             base::names(...future.oldOptions))
[17:39:59.303]     }
[17:39:59.303]     if (FALSE) {
[17:39:59.303]     }
[17:39:59.303]     else {
[17:39:59.303]         if (TRUE) {
[17:39:59.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.303]                 open = "w")
[17:39:59.303]         }
[17:39:59.303]         else {
[17:39:59.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.303]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.303]         }
[17:39:59.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.303]             base::sink(type = "output", split = FALSE)
[17:39:59.303]             base::close(...future.stdout)
[17:39:59.303]         }, add = TRUE)
[17:39:59.303]     }
[17:39:59.303]     ...future.frame <- base::sys.nframe()
[17:39:59.303]     ...future.conditions <- base::list()
[17:39:59.303]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.303]     if (FALSE) {
[17:39:59.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.303]     }
[17:39:59.303]     ...future.result <- base::tryCatch({
[17:39:59.303]         base::withCallingHandlers({
[17:39:59.303]             ...future.value <- base::withVisible(base::local({
[17:39:59.303]                 ...future.makeSendCondition <- base::local({
[17:39:59.303]                   sendCondition <- NULL
[17:39:59.303]                   function(frame = 1L) {
[17:39:59.303]                     if (is.function(sendCondition)) 
[17:39:59.303]                       return(sendCondition)
[17:39:59.303]                     ns <- getNamespace("parallel")
[17:39:59.303]                     if (exists("sendData", mode = "function", 
[17:39:59.303]                       envir = ns)) {
[17:39:59.303]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.303]                         envir = ns)
[17:39:59.303]                       envir <- sys.frame(frame)
[17:39:59.303]                       master <- NULL
[17:39:59.303]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.303]                         !identical(envir, emptyenv())) {
[17:39:59.303]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.303]                           inherits = FALSE)) {
[17:39:59.303]                           master <- get("master", mode = "list", 
[17:39:59.303]                             envir = envir, inherits = FALSE)
[17:39:59.303]                           if (inherits(master, c("SOCKnode", 
[17:39:59.303]                             "SOCK0node"))) {
[17:39:59.303]                             sendCondition <<- function(cond) {
[17:39:59.303]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.303]                                 success = TRUE)
[17:39:59.303]                               parallel_sendData(master, data)
[17:39:59.303]                             }
[17:39:59.303]                             return(sendCondition)
[17:39:59.303]                           }
[17:39:59.303]                         }
[17:39:59.303]                         frame <- frame + 1L
[17:39:59.303]                         envir <- sys.frame(frame)
[17:39:59.303]                       }
[17:39:59.303]                     }
[17:39:59.303]                     sendCondition <<- function(cond) NULL
[17:39:59.303]                   }
[17:39:59.303]                 })
[17:39:59.303]                 withCallingHandlers({
[17:39:59.303]                   {
[17:39:59.303]                     b <- a * ii
[17:39:59.303]                     a <- 0
[17:39:59.303]                     b
[17:39:59.303]                   }
[17:39:59.303]                 }, immediateCondition = function(cond) {
[17:39:59.303]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.303]                   sendCondition(cond)
[17:39:59.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.303]                   {
[17:39:59.303]                     inherits <- base::inherits
[17:39:59.303]                     invokeRestart <- base::invokeRestart
[17:39:59.303]                     is.null <- base::is.null
[17:39:59.303]                     muffled <- FALSE
[17:39:59.303]                     if (inherits(cond, "message")) {
[17:39:59.303]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.303]                       if (muffled) 
[17:39:59.303]                         invokeRestart("muffleMessage")
[17:39:59.303]                     }
[17:39:59.303]                     else if (inherits(cond, "warning")) {
[17:39:59.303]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.303]                       if (muffled) 
[17:39:59.303]                         invokeRestart("muffleWarning")
[17:39:59.303]                     }
[17:39:59.303]                     else if (inherits(cond, "condition")) {
[17:39:59.303]                       if (!is.null(pattern)) {
[17:39:59.303]                         computeRestarts <- base::computeRestarts
[17:39:59.303]                         grepl <- base::grepl
[17:39:59.303]                         restarts <- computeRestarts(cond)
[17:39:59.303]                         for (restart in restarts) {
[17:39:59.303]                           name <- restart$name
[17:39:59.303]                           if (is.null(name)) 
[17:39:59.303]                             next
[17:39:59.303]                           if (!grepl(pattern, name)) 
[17:39:59.303]                             next
[17:39:59.303]                           invokeRestart(restart)
[17:39:59.303]                           muffled <- TRUE
[17:39:59.303]                           break
[17:39:59.303]                         }
[17:39:59.303]                       }
[17:39:59.303]                     }
[17:39:59.303]                     invisible(muffled)
[17:39:59.303]                   }
[17:39:59.303]                   muffleCondition(cond)
[17:39:59.303]                 })
[17:39:59.303]             }))
[17:39:59.303]             future::FutureResult(value = ...future.value$value, 
[17:39:59.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.303]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.303]                     ...future.globalenv.names))
[17:39:59.303]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.303]         }, condition = base::local({
[17:39:59.303]             c <- base::c
[17:39:59.303]             inherits <- base::inherits
[17:39:59.303]             invokeRestart <- base::invokeRestart
[17:39:59.303]             length <- base::length
[17:39:59.303]             list <- base::list
[17:39:59.303]             seq.int <- base::seq.int
[17:39:59.303]             signalCondition <- base::signalCondition
[17:39:59.303]             sys.calls <- base::sys.calls
[17:39:59.303]             `[[` <- base::`[[`
[17:39:59.303]             `+` <- base::`+`
[17:39:59.303]             `<<-` <- base::`<<-`
[17:39:59.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.303]                   3L)]
[17:39:59.303]             }
[17:39:59.303]             function(cond) {
[17:39:59.303]                 is_error <- inherits(cond, "error")
[17:39:59.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.303]                   NULL)
[17:39:59.303]                 if (is_error) {
[17:39:59.303]                   sessionInformation <- function() {
[17:39:59.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.303]                       search = base::search(), system = base::Sys.info())
[17:39:59.303]                   }
[17:39:59.303]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.303]                     cond$call), session = sessionInformation(), 
[17:39:59.303]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.303]                   signalCondition(cond)
[17:39:59.303]                 }
[17:39:59.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.303]                 "immediateCondition"))) {
[17:39:59.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.303]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.303]                   if (TRUE && !signal) {
[17:39:59.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.303]                     {
[17:39:59.303]                       inherits <- base::inherits
[17:39:59.303]                       invokeRestart <- base::invokeRestart
[17:39:59.303]                       is.null <- base::is.null
[17:39:59.303]                       muffled <- FALSE
[17:39:59.303]                       if (inherits(cond, "message")) {
[17:39:59.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.303]                         if (muffled) 
[17:39:59.303]                           invokeRestart("muffleMessage")
[17:39:59.303]                       }
[17:39:59.303]                       else if (inherits(cond, "warning")) {
[17:39:59.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.303]                         if (muffled) 
[17:39:59.303]                           invokeRestart("muffleWarning")
[17:39:59.303]                       }
[17:39:59.303]                       else if (inherits(cond, "condition")) {
[17:39:59.303]                         if (!is.null(pattern)) {
[17:39:59.303]                           computeRestarts <- base::computeRestarts
[17:39:59.303]                           grepl <- base::grepl
[17:39:59.303]                           restarts <- computeRestarts(cond)
[17:39:59.303]                           for (restart in restarts) {
[17:39:59.303]                             name <- restart$name
[17:39:59.303]                             if (is.null(name)) 
[17:39:59.303]                               next
[17:39:59.303]                             if (!grepl(pattern, name)) 
[17:39:59.303]                               next
[17:39:59.303]                             invokeRestart(restart)
[17:39:59.303]                             muffled <- TRUE
[17:39:59.303]                             break
[17:39:59.303]                           }
[17:39:59.303]                         }
[17:39:59.303]                       }
[17:39:59.303]                       invisible(muffled)
[17:39:59.303]                     }
[17:39:59.303]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.303]                   }
[17:39:59.303]                 }
[17:39:59.303]                 else {
[17:39:59.303]                   if (TRUE) {
[17:39:59.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.303]                     {
[17:39:59.303]                       inherits <- base::inherits
[17:39:59.303]                       invokeRestart <- base::invokeRestart
[17:39:59.303]                       is.null <- base::is.null
[17:39:59.303]                       muffled <- FALSE
[17:39:59.303]                       if (inherits(cond, "message")) {
[17:39:59.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.303]                         if (muffled) 
[17:39:59.303]                           invokeRestart("muffleMessage")
[17:39:59.303]                       }
[17:39:59.303]                       else if (inherits(cond, "warning")) {
[17:39:59.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.303]                         if (muffled) 
[17:39:59.303]                           invokeRestart("muffleWarning")
[17:39:59.303]                       }
[17:39:59.303]                       else if (inherits(cond, "condition")) {
[17:39:59.303]                         if (!is.null(pattern)) {
[17:39:59.303]                           computeRestarts <- base::computeRestarts
[17:39:59.303]                           grepl <- base::grepl
[17:39:59.303]                           restarts <- computeRestarts(cond)
[17:39:59.303]                           for (restart in restarts) {
[17:39:59.303]                             name <- restart$name
[17:39:59.303]                             if (is.null(name)) 
[17:39:59.303]                               next
[17:39:59.303]                             if (!grepl(pattern, name)) 
[17:39:59.303]                               next
[17:39:59.303]                             invokeRestart(restart)
[17:39:59.303]                             muffled <- TRUE
[17:39:59.303]                             break
[17:39:59.303]                           }
[17:39:59.303]                         }
[17:39:59.303]                       }
[17:39:59.303]                       invisible(muffled)
[17:39:59.303]                     }
[17:39:59.303]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.303]                   }
[17:39:59.303]                 }
[17:39:59.303]             }
[17:39:59.303]         }))
[17:39:59.303]     }, error = function(ex) {
[17:39:59.303]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.303]                 ...future.rng), started = ...future.startTime, 
[17:39:59.303]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.303]             version = "1.8"), class = "FutureResult")
[17:39:59.303]     }, finally = {
[17:39:59.303]         if (!identical(...future.workdir, getwd())) 
[17:39:59.303]             setwd(...future.workdir)
[17:39:59.303]         {
[17:39:59.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.303]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.303]             }
[17:39:59.303]             base::options(...future.oldOptions)
[17:39:59.303]             if (.Platform$OS.type == "windows") {
[17:39:59.303]                 old_names <- names(...future.oldEnvVars)
[17:39:59.303]                 envs <- base::Sys.getenv()
[17:39:59.303]                 names <- names(envs)
[17:39:59.303]                 common <- intersect(names, old_names)
[17:39:59.303]                 added <- setdiff(names, old_names)
[17:39:59.303]                 removed <- setdiff(old_names, names)
[17:39:59.303]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.303]                   envs[common]]
[17:39:59.303]                 NAMES <- toupper(changed)
[17:39:59.303]                 args <- list()
[17:39:59.303]                 for (kk in seq_along(NAMES)) {
[17:39:59.303]                   name <- changed[[kk]]
[17:39:59.303]                   NAME <- NAMES[[kk]]
[17:39:59.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.303]                     next
[17:39:59.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.303]                 }
[17:39:59.303]                 NAMES <- toupper(added)
[17:39:59.303]                 for (kk in seq_along(NAMES)) {
[17:39:59.303]                   name <- added[[kk]]
[17:39:59.303]                   NAME <- NAMES[[kk]]
[17:39:59.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.303]                     next
[17:39:59.303]                   args[[name]] <- ""
[17:39:59.303]                 }
[17:39:59.303]                 NAMES <- toupper(removed)
[17:39:59.303]                 for (kk in seq_along(NAMES)) {
[17:39:59.303]                   name <- removed[[kk]]
[17:39:59.303]                   NAME <- NAMES[[kk]]
[17:39:59.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.303]                     next
[17:39:59.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.303]                 }
[17:39:59.303]                 if (length(args) > 0) 
[17:39:59.303]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.303]             }
[17:39:59.303]             else {
[17:39:59.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.303]             }
[17:39:59.303]             {
[17:39:59.303]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.303]                   0L) {
[17:39:59.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.303]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.303]                   base::options(opts)
[17:39:59.303]                 }
[17:39:59.303]                 {
[17:39:59.303]                   {
[17:39:59.303]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.303]                     NULL
[17:39:59.303]                   }
[17:39:59.303]                   options(future.plan = NULL)
[17:39:59.303]                   if (is.na(NA_character_)) 
[17:39:59.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.303]                     .init = FALSE)
[17:39:59.303]                 }
[17:39:59.303]             }
[17:39:59.303]         }
[17:39:59.303]     })
[17:39:59.303]     if (TRUE) {
[17:39:59.303]         base::sink(type = "output", split = FALSE)
[17:39:59.303]         if (TRUE) {
[17:39:59.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.303]         }
[17:39:59.303]         else {
[17:39:59.303]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.303]         }
[17:39:59.303]         base::close(...future.stdout)
[17:39:59.303]         ...future.stdout <- NULL
[17:39:59.303]     }
[17:39:59.303]     ...future.result$conditions <- ...future.conditions
[17:39:59.303]     ...future.result$finished <- base::Sys.time()
[17:39:59.303]     ...future.result
[17:39:59.303] }
[17:39:59.306] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:39:59.306] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:39:59.306] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:39:59.306] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:39:59.307] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:59.307] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:39:59.307] MultisessionFuture started
[17:39:59.307] - Launch lazy future ... done
[17:39:59.307] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.308] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.308] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.310] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.310] Searching for globals ... DONE
[17:39:59.310] Resolving globals: TRUE
[17:39:59.310] Resolving any globals that are futures ...
[17:39:59.310] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.310] Resolving any globals that are futures ... DONE
[17:39:59.311] Resolving futures part of globals (recursively) ...
[17:39:59.311] resolve() on list ...
[17:39:59.311]  recursive: 99
[17:39:59.311]  length: 2
[17:39:59.311]  elements: ‘a’, ‘ii’
[17:39:59.311]  length: 1 (resolved future 1)
[17:39:59.311]  length: 0 (resolved future 2)
[17:39:59.311] resolve() on list ... DONE
[17:39:59.311] - globals: [2] ‘a’, ‘ii’
[17:39:59.311] Resolving futures part of globals (recursively) ... DONE
[17:39:59.312] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:59.312] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:59.312] - globals: [2] ‘a’, ‘ii’
[17:39:59.312] 
[17:39:59.312] getGlobalsAndPackages() ... DONE
[17:39:59.312] run() for ‘Future’ ...
[17:39:59.313] - state: ‘created’
[17:39:59.313] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.326]   - Field: ‘node’
[17:39:59.326]   - Field: ‘label’
[17:39:59.326]   - Field: ‘local’
[17:39:59.326]   - Field: ‘owner’
[17:39:59.326]   - Field: ‘envir’
[17:39:59.327]   - Field: ‘workers’
[17:39:59.327]   - Field: ‘packages’
[17:39:59.327]   - Field: ‘gc’
[17:39:59.327]   - Field: ‘conditions’
[17:39:59.327]   - Field: ‘persistent’
[17:39:59.327]   - Field: ‘expr’
[17:39:59.327]   - Field: ‘uuid’
[17:39:59.327]   - Field: ‘seed’
[17:39:59.327]   - Field: ‘version’
[17:39:59.327]   - Field: ‘result’
[17:39:59.327]   - Field: ‘asynchronous’
[17:39:59.327]   - Field: ‘calls’
[17:39:59.328]   - Field: ‘globals’
[17:39:59.328]   - Field: ‘stdout’
[17:39:59.328]   - Field: ‘earlySignal’
[17:39:59.328]   - Field: ‘lazy’
[17:39:59.328]   - Field: ‘state’
[17:39:59.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.328] - Launch lazy future ...
[17:39:59.328] Packages needed by the future expression (n = 0): <none>
[17:39:59.328] Packages needed by future strategies (n = 0): <none>
[17:39:59.329] {
[17:39:59.329]     {
[17:39:59.329]         {
[17:39:59.329]             ...future.startTime <- base::Sys.time()
[17:39:59.329]             {
[17:39:59.329]                 {
[17:39:59.329]                   {
[17:39:59.329]                     {
[17:39:59.329]                       base::local({
[17:39:59.329]                         has_future <- base::requireNamespace("future", 
[17:39:59.329]                           quietly = TRUE)
[17:39:59.329]                         if (has_future) {
[17:39:59.329]                           ns <- base::getNamespace("future")
[17:39:59.329]                           version <- ns[[".package"]][["version"]]
[17:39:59.329]                           if (is.null(version)) 
[17:39:59.329]                             version <- utils::packageVersion("future")
[17:39:59.329]                         }
[17:39:59.329]                         else {
[17:39:59.329]                           version <- NULL
[17:39:59.329]                         }
[17:39:59.329]                         if (!has_future || version < "1.8.0") {
[17:39:59.329]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.329]                             "", base::R.version$version.string), 
[17:39:59.329]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.329]                               "release", "version")], collapse = " "), 
[17:39:59.329]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.329]                             info)
[17:39:59.329]                           info <- base::paste(info, collapse = "; ")
[17:39:59.329]                           if (!has_future) {
[17:39:59.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.329]                               info)
[17:39:59.329]                           }
[17:39:59.329]                           else {
[17:39:59.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.329]                               info, version)
[17:39:59.329]                           }
[17:39:59.329]                           base::stop(msg)
[17:39:59.329]                         }
[17:39:59.329]                       })
[17:39:59.329]                     }
[17:39:59.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.329]                     base::options(mc.cores = 1L)
[17:39:59.329]                   }
[17:39:59.329]                   ...future.strategy.old <- future::plan("list")
[17:39:59.329]                   options(future.plan = NULL)
[17:39:59.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.329]                 }
[17:39:59.329]                 ...future.workdir <- getwd()
[17:39:59.329]             }
[17:39:59.329]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.329]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.329]         }
[17:39:59.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.329]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.329]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.329]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.329]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.329]             base::names(...future.oldOptions))
[17:39:59.329]     }
[17:39:59.329]     if (FALSE) {
[17:39:59.329]     }
[17:39:59.329]     else {
[17:39:59.329]         if (TRUE) {
[17:39:59.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.329]                 open = "w")
[17:39:59.329]         }
[17:39:59.329]         else {
[17:39:59.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.329]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.329]         }
[17:39:59.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.329]             base::sink(type = "output", split = FALSE)
[17:39:59.329]             base::close(...future.stdout)
[17:39:59.329]         }, add = TRUE)
[17:39:59.329]     }
[17:39:59.329]     ...future.frame <- base::sys.nframe()
[17:39:59.329]     ...future.conditions <- base::list()
[17:39:59.329]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.329]     if (FALSE) {
[17:39:59.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.329]     }
[17:39:59.329]     ...future.result <- base::tryCatch({
[17:39:59.329]         base::withCallingHandlers({
[17:39:59.329]             ...future.value <- base::withVisible(base::local({
[17:39:59.329]                 ...future.makeSendCondition <- base::local({
[17:39:59.329]                   sendCondition <- NULL
[17:39:59.329]                   function(frame = 1L) {
[17:39:59.329]                     if (is.function(sendCondition)) 
[17:39:59.329]                       return(sendCondition)
[17:39:59.329]                     ns <- getNamespace("parallel")
[17:39:59.329]                     if (exists("sendData", mode = "function", 
[17:39:59.329]                       envir = ns)) {
[17:39:59.329]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.329]                         envir = ns)
[17:39:59.329]                       envir <- sys.frame(frame)
[17:39:59.329]                       master <- NULL
[17:39:59.329]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.329]                         !identical(envir, emptyenv())) {
[17:39:59.329]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.329]                           inherits = FALSE)) {
[17:39:59.329]                           master <- get("master", mode = "list", 
[17:39:59.329]                             envir = envir, inherits = FALSE)
[17:39:59.329]                           if (inherits(master, c("SOCKnode", 
[17:39:59.329]                             "SOCK0node"))) {
[17:39:59.329]                             sendCondition <<- function(cond) {
[17:39:59.329]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.329]                                 success = TRUE)
[17:39:59.329]                               parallel_sendData(master, data)
[17:39:59.329]                             }
[17:39:59.329]                             return(sendCondition)
[17:39:59.329]                           }
[17:39:59.329]                         }
[17:39:59.329]                         frame <- frame + 1L
[17:39:59.329]                         envir <- sys.frame(frame)
[17:39:59.329]                       }
[17:39:59.329]                     }
[17:39:59.329]                     sendCondition <<- function(cond) NULL
[17:39:59.329]                   }
[17:39:59.329]                 })
[17:39:59.329]                 withCallingHandlers({
[17:39:59.329]                   {
[17:39:59.329]                     b <- a * ii
[17:39:59.329]                     a <- 0
[17:39:59.329]                     b
[17:39:59.329]                   }
[17:39:59.329]                 }, immediateCondition = function(cond) {
[17:39:59.329]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.329]                   sendCondition(cond)
[17:39:59.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.329]                   {
[17:39:59.329]                     inherits <- base::inherits
[17:39:59.329]                     invokeRestart <- base::invokeRestart
[17:39:59.329]                     is.null <- base::is.null
[17:39:59.329]                     muffled <- FALSE
[17:39:59.329]                     if (inherits(cond, "message")) {
[17:39:59.329]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.329]                       if (muffled) 
[17:39:59.329]                         invokeRestart("muffleMessage")
[17:39:59.329]                     }
[17:39:59.329]                     else if (inherits(cond, "warning")) {
[17:39:59.329]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.329]                       if (muffled) 
[17:39:59.329]                         invokeRestart("muffleWarning")
[17:39:59.329]                     }
[17:39:59.329]                     else if (inherits(cond, "condition")) {
[17:39:59.329]                       if (!is.null(pattern)) {
[17:39:59.329]                         computeRestarts <- base::computeRestarts
[17:39:59.329]                         grepl <- base::grepl
[17:39:59.329]                         restarts <- computeRestarts(cond)
[17:39:59.329]                         for (restart in restarts) {
[17:39:59.329]                           name <- restart$name
[17:39:59.329]                           if (is.null(name)) 
[17:39:59.329]                             next
[17:39:59.329]                           if (!grepl(pattern, name)) 
[17:39:59.329]                             next
[17:39:59.329]                           invokeRestart(restart)
[17:39:59.329]                           muffled <- TRUE
[17:39:59.329]                           break
[17:39:59.329]                         }
[17:39:59.329]                       }
[17:39:59.329]                     }
[17:39:59.329]                     invisible(muffled)
[17:39:59.329]                   }
[17:39:59.329]                   muffleCondition(cond)
[17:39:59.329]                 })
[17:39:59.329]             }))
[17:39:59.329]             future::FutureResult(value = ...future.value$value, 
[17:39:59.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.329]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.329]                     ...future.globalenv.names))
[17:39:59.329]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.329]         }, condition = base::local({
[17:39:59.329]             c <- base::c
[17:39:59.329]             inherits <- base::inherits
[17:39:59.329]             invokeRestart <- base::invokeRestart
[17:39:59.329]             length <- base::length
[17:39:59.329]             list <- base::list
[17:39:59.329]             seq.int <- base::seq.int
[17:39:59.329]             signalCondition <- base::signalCondition
[17:39:59.329]             sys.calls <- base::sys.calls
[17:39:59.329]             `[[` <- base::`[[`
[17:39:59.329]             `+` <- base::`+`
[17:39:59.329]             `<<-` <- base::`<<-`
[17:39:59.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.329]                   3L)]
[17:39:59.329]             }
[17:39:59.329]             function(cond) {
[17:39:59.329]                 is_error <- inherits(cond, "error")
[17:39:59.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.329]                   NULL)
[17:39:59.329]                 if (is_error) {
[17:39:59.329]                   sessionInformation <- function() {
[17:39:59.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.329]                       search = base::search(), system = base::Sys.info())
[17:39:59.329]                   }
[17:39:59.329]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.329]                     cond$call), session = sessionInformation(), 
[17:39:59.329]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.329]                   signalCondition(cond)
[17:39:59.329]                 }
[17:39:59.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.329]                 "immediateCondition"))) {
[17:39:59.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.329]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.329]                   if (TRUE && !signal) {
[17:39:59.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.329]                     {
[17:39:59.329]                       inherits <- base::inherits
[17:39:59.329]                       invokeRestart <- base::invokeRestart
[17:39:59.329]                       is.null <- base::is.null
[17:39:59.329]                       muffled <- FALSE
[17:39:59.329]                       if (inherits(cond, "message")) {
[17:39:59.329]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.329]                         if (muffled) 
[17:39:59.329]                           invokeRestart("muffleMessage")
[17:39:59.329]                       }
[17:39:59.329]                       else if (inherits(cond, "warning")) {
[17:39:59.329]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.329]                         if (muffled) 
[17:39:59.329]                           invokeRestart("muffleWarning")
[17:39:59.329]                       }
[17:39:59.329]                       else if (inherits(cond, "condition")) {
[17:39:59.329]                         if (!is.null(pattern)) {
[17:39:59.329]                           computeRestarts <- base::computeRestarts
[17:39:59.329]                           grepl <- base::grepl
[17:39:59.329]                           restarts <- computeRestarts(cond)
[17:39:59.329]                           for (restart in restarts) {
[17:39:59.329]                             name <- restart$name
[17:39:59.329]                             if (is.null(name)) 
[17:39:59.329]                               next
[17:39:59.329]                             if (!grepl(pattern, name)) 
[17:39:59.329]                               next
[17:39:59.329]                             invokeRestart(restart)
[17:39:59.329]                             muffled <- TRUE
[17:39:59.329]                             break
[17:39:59.329]                           }
[17:39:59.329]                         }
[17:39:59.329]                       }
[17:39:59.329]                       invisible(muffled)
[17:39:59.329]                     }
[17:39:59.329]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.329]                   }
[17:39:59.329]                 }
[17:39:59.329]                 else {
[17:39:59.329]                   if (TRUE) {
[17:39:59.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.329]                     {
[17:39:59.329]                       inherits <- base::inherits
[17:39:59.329]                       invokeRestart <- base::invokeRestart
[17:39:59.329]                       is.null <- base::is.null
[17:39:59.329]                       muffled <- FALSE
[17:39:59.329]                       if (inherits(cond, "message")) {
[17:39:59.329]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.329]                         if (muffled) 
[17:39:59.329]                           invokeRestart("muffleMessage")
[17:39:59.329]                       }
[17:39:59.329]                       else if (inherits(cond, "warning")) {
[17:39:59.329]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.329]                         if (muffled) 
[17:39:59.329]                           invokeRestart("muffleWarning")
[17:39:59.329]                       }
[17:39:59.329]                       else if (inherits(cond, "condition")) {
[17:39:59.329]                         if (!is.null(pattern)) {
[17:39:59.329]                           computeRestarts <- base::computeRestarts
[17:39:59.329]                           grepl <- base::grepl
[17:39:59.329]                           restarts <- computeRestarts(cond)
[17:39:59.329]                           for (restart in restarts) {
[17:39:59.329]                             name <- restart$name
[17:39:59.329]                             if (is.null(name)) 
[17:39:59.329]                               next
[17:39:59.329]                             if (!grepl(pattern, name)) 
[17:39:59.329]                               next
[17:39:59.329]                             invokeRestart(restart)
[17:39:59.329]                             muffled <- TRUE
[17:39:59.329]                             break
[17:39:59.329]                           }
[17:39:59.329]                         }
[17:39:59.329]                       }
[17:39:59.329]                       invisible(muffled)
[17:39:59.329]                     }
[17:39:59.329]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.329]                   }
[17:39:59.329]                 }
[17:39:59.329]             }
[17:39:59.329]         }))
[17:39:59.329]     }, error = function(ex) {
[17:39:59.329]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.329]                 ...future.rng), started = ...future.startTime, 
[17:39:59.329]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.329]             version = "1.8"), class = "FutureResult")
[17:39:59.329]     }, finally = {
[17:39:59.329]         if (!identical(...future.workdir, getwd())) 
[17:39:59.329]             setwd(...future.workdir)
[17:39:59.329]         {
[17:39:59.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.329]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.329]             }
[17:39:59.329]             base::options(...future.oldOptions)
[17:39:59.329]             if (.Platform$OS.type == "windows") {
[17:39:59.329]                 old_names <- names(...future.oldEnvVars)
[17:39:59.329]                 envs <- base::Sys.getenv()
[17:39:59.329]                 names <- names(envs)
[17:39:59.329]                 common <- intersect(names, old_names)
[17:39:59.329]                 added <- setdiff(names, old_names)
[17:39:59.329]                 removed <- setdiff(old_names, names)
[17:39:59.329]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.329]                   envs[common]]
[17:39:59.329]                 NAMES <- toupper(changed)
[17:39:59.329]                 args <- list()
[17:39:59.329]                 for (kk in seq_along(NAMES)) {
[17:39:59.329]                   name <- changed[[kk]]
[17:39:59.329]                   NAME <- NAMES[[kk]]
[17:39:59.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.329]                     next
[17:39:59.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.329]                 }
[17:39:59.329]                 NAMES <- toupper(added)
[17:39:59.329]                 for (kk in seq_along(NAMES)) {
[17:39:59.329]                   name <- added[[kk]]
[17:39:59.329]                   NAME <- NAMES[[kk]]
[17:39:59.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.329]                     next
[17:39:59.329]                   args[[name]] <- ""
[17:39:59.329]                 }
[17:39:59.329]                 NAMES <- toupper(removed)
[17:39:59.329]                 for (kk in seq_along(NAMES)) {
[17:39:59.329]                   name <- removed[[kk]]
[17:39:59.329]                   NAME <- NAMES[[kk]]
[17:39:59.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.329]                     next
[17:39:59.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.329]                 }
[17:39:59.329]                 if (length(args) > 0) 
[17:39:59.329]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.329]             }
[17:39:59.329]             else {
[17:39:59.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.329]             }
[17:39:59.329]             {
[17:39:59.329]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.329]                   0L) {
[17:39:59.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.329]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.329]                   base::options(opts)
[17:39:59.329]                 }
[17:39:59.329]                 {
[17:39:59.329]                   {
[17:39:59.329]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.329]                     NULL
[17:39:59.329]                   }
[17:39:59.329]                   options(future.plan = NULL)
[17:39:59.329]                   if (is.na(NA_character_)) 
[17:39:59.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.329]                     .init = FALSE)
[17:39:59.329]                 }
[17:39:59.329]             }
[17:39:59.329]         }
[17:39:59.329]     })
[17:39:59.329]     if (TRUE) {
[17:39:59.329]         base::sink(type = "output", split = FALSE)
[17:39:59.329]         if (TRUE) {
[17:39:59.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.329]         }
[17:39:59.329]         else {
[17:39:59.329]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.329]         }
[17:39:59.329]         base::close(...future.stdout)
[17:39:59.329]         ...future.stdout <- NULL
[17:39:59.329]     }
[17:39:59.329]     ...future.result$conditions <- ...future.conditions
[17:39:59.329]     ...future.result$finished <- base::Sys.time()
[17:39:59.329]     ...future.result
[17:39:59.329] }
[17:39:59.331] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:59.341] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.342] - Validating connection of MultisessionFuture
[17:39:59.342] - received message: FutureResult
[17:39:59.342] - Received FutureResult
[17:39:59.342] - Erased future from FutureRegistry
[17:39:59.342] result() for ClusterFuture ...
[17:39:59.342] - result already collected: FutureResult
[17:39:59.342] result() for ClusterFuture ... done
[17:39:59.343] signalConditions() ...
[17:39:59.343]  - include = ‘immediateCondition’
[17:39:59.343]  - exclude = 
[17:39:59.343]  - resignal = FALSE
[17:39:59.343]  - Number of conditions: 1
[17:39:59.343] signalConditions() ... done
[17:39:59.343] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.343] result() for ClusterFuture ...
[17:39:59.343] - result already collected: FutureResult
[17:39:59.343] result() for ClusterFuture ... done
[17:39:59.343] result() for ClusterFuture ...
[17:39:59.343] - result already collected: FutureResult
[17:39:59.344] result() for ClusterFuture ... done
[17:39:59.344] signalConditions() ...
[17:39:59.344]  - include = ‘immediateCondition’
[17:39:59.344]  - exclude = 
[17:39:59.344]  - resignal = FALSE
[17:39:59.344]  - Number of conditions: 1
[17:39:59.344] signalConditions() ... done
[17:39:59.345] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:39:59.345] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:39:59.345] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.345] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:39:59.346] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.346] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:39:59.346] MultisessionFuture started
[17:39:59.347] - Launch lazy future ... done
[17:39:59.347] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.347] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.348] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.350] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.350] Searching for globals ... DONE
[17:39:59.350] Resolving globals: TRUE
[17:39:59.350] Resolving any globals that are futures ...
[17:39:59.350] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.351] Resolving any globals that are futures ... DONE
[17:39:59.351] Resolving futures part of globals (recursively) ...
[17:39:59.351] resolve() on list ...
[17:39:59.351]  recursive: 99
[17:39:59.351]  length: 2
[17:39:59.351]  elements: ‘a’, ‘ii’
[17:39:59.352]  length: 1 (resolved future 1)
[17:39:59.352]  length: 0 (resolved future 2)
[17:39:59.352] resolve() on list ... DONE
[17:39:59.352] - globals: [2] ‘a’, ‘ii’
[17:39:59.352] Resolving futures part of globals (recursively) ... DONE
[17:39:59.352] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:59.352] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:59.353] - globals: [2] ‘a’, ‘ii’
[17:39:59.353] 
[17:39:59.353] getGlobalsAndPackages() ... DONE
[17:39:59.353] run() for ‘Future’ ...
[17:39:59.353] - state: ‘created’
[17:39:59.353] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.367] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.367]   - Field: ‘node’
[17:39:59.367]   - Field: ‘label’
[17:39:59.367]   - Field: ‘local’
[17:39:59.367]   - Field: ‘owner’
[17:39:59.368]   - Field: ‘envir’
[17:39:59.368]   - Field: ‘workers’
[17:39:59.368]   - Field: ‘packages’
[17:39:59.368]   - Field: ‘gc’
[17:39:59.368]   - Field: ‘conditions’
[17:39:59.368]   - Field: ‘persistent’
[17:39:59.368]   - Field: ‘expr’
[17:39:59.368]   - Field: ‘uuid’
[17:39:59.368]   - Field: ‘seed’
[17:39:59.368]   - Field: ‘version’
[17:39:59.368]   - Field: ‘result’
[17:39:59.369]   - Field: ‘asynchronous’
[17:39:59.369]   - Field: ‘calls’
[17:39:59.369]   - Field: ‘globals’
[17:39:59.369]   - Field: ‘stdout’
[17:39:59.369]   - Field: ‘earlySignal’
[17:39:59.369]   - Field: ‘lazy’
[17:39:59.369]   - Field: ‘state’
[17:39:59.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.369] - Launch lazy future ...
[17:39:59.370] Packages needed by the future expression (n = 0): <none>
[17:39:59.370] Packages needed by future strategies (n = 0): <none>
[17:39:59.370] {
[17:39:59.370]     {
[17:39:59.370]         {
[17:39:59.370]             ...future.startTime <- base::Sys.time()
[17:39:59.370]             {
[17:39:59.370]                 {
[17:39:59.370]                   {
[17:39:59.370]                     {
[17:39:59.370]                       base::local({
[17:39:59.370]                         has_future <- base::requireNamespace("future", 
[17:39:59.370]                           quietly = TRUE)
[17:39:59.370]                         if (has_future) {
[17:39:59.370]                           ns <- base::getNamespace("future")
[17:39:59.370]                           version <- ns[[".package"]][["version"]]
[17:39:59.370]                           if (is.null(version)) 
[17:39:59.370]                             version <- utils::packageVersion("future")
[17:39:59.370]                         }
[17:39:59.370]                         else {
[17:39:59.370]                           version <- NULL
[17:39:59.370]                         }
[17:39:59.370]                         if (!has_future || version < "1.8.0") {
[17:39:59.370]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.370]                             "", base::R.version$version.string), 
[17:39:59.370]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.370]                               "release", "version")], collapse = " "), 
[17:39:59.370]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.370]                             info)
[17:39:59.370]                           info <- base::paste(info, collapse = "; ")
[17:39:59.370]                           if (!has_future) {
[17:39:59.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.370]                               info)
[17:39:59.370]                           }
[17:39:59.370]                           else {
[17:39:59.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.370]                               info, version)
[17:39:59.370]                           }
[17:39:59.370]                           base::stop(msg)
[17:39:59.370]                         }
[17:39:59.370]                       })
[17:39:59.370]                     }
[17:39:59.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.370]                     base::options(mc.cores = 1L)
[17:39:59.370]                   }
[17:39:59.370]                   ...future.strategy.old <- future::plan("list")
[17:39:59.370]                   options(future.plan = NULL)
[17:39:59.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.370]                 }
[17:39:59.370]                 ...future.workdir <- getwd()
[17:39:59.370]             }
[17:39:59.370]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.370]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.370]         }
[17:39:59.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.370]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.370]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.370]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.370]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.370]             base::names(...future.oldOptions))
[17:39:59.370]     }
[17:39:59.370]     if (FALSE) {
[17:39:59.370]     }
[17:39:59.370]     else {
[17:39:59.370]         if (TRUE) {
[17:39:59.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.370]                 open = "w")
[17:39:59.370]         }
[17:39:59.370]         else {
[17:39:59.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.370]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.370]         }
[17:39:59.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.370]             base::sink(type = "output", split = FALSE)
[17:39:59.370]             base::close(...future.stdout)
[17:39:59.370]         }, add = TRUE)
[17:39:59.370]     }
[17:39:59.370]     ...future.frame <- base::sys.nframe()
[17:39:59.370]     ...future.conditions <- base::list()
[17:39:59.370]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.370]     if (FALSE) {
[17:39:59.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.370]     }
[17:39:59.370]     ...future.result <- base::tryCatch({
[17:39:59.370]         base::withCallingHandlers({
[17:39:59.370]             ...future.value <- base::withVisible(base::local({
[17:39:59.370]                 ...future.makeSendCondition <- base::local({
[17:39:59.370]                   sendCondition <- NULL
[17:39:59.370]                   function(frame = 1L) {
[17:39:59.370]                     if (is.function(sendCondition)) 
[17:39:59.370]                       return(sendCondition)
[17:39:59.370]                     ns <- getNamespace("parallel")
[17:39:59.370]                     if (exists("sendData", mode = "function", 
[17:39:59.370]                       envir = ns)) {
[17:39:59.370]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.370]                         envir = ns)
[17:39:59.370]                       envir <- sys.frame(frame)
[17:39:59.370]                       master <- NULL
[17:39:59.370]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.370]                         !identical(envir, emptyenv())) {
[17:39:59.370]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.370]                           inherits = FALSE)) {
[17:39:59.370]                           master <- get("master", mode = "list", 
[17:39:59.370]                             envir = envir, inherits = FALSE)
[17:39:59.370]                           if (inherits(master, c("SOCKnode", 
[17:39:59.370]                             "SOCK0node"))) {
[17:39:59.370]                             sendCondition <<- function(cond) {
[17:39:59.370]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.370]                                 success = TRUE)
[17:39:59.370]                               parallel_sendData(master, data)
[17:39:59.370]                             }
[17:39:59.370]                             return(sendCondition)
[17:39:59.370]                           }
[17:39:59.370]                         }
[17:39:59.370]                         frame <- frame + 1L
[17:39:59.370]                         envir <- sys.frame(frame)
[17:39:59.370]                       }
[17:39:59.370]                     }
[17:39:59.370]                     sendCondition <<- function(cond) NULL
[17:39:59.370]                   }
[17:39:59.370]                 })
[17:39:59.370]                 withCallingHandlers({
[17:39:59.370]                   {
[17:39:59.370]                     b <- a * ii
[17:39:59.370]                     a <- 0
[17:39:59.370]                     b
[17:39:59.370]                   }
[17:39:59.370]                 }, immediateCondition = function(cond) {
[17:39:59.370]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.370]                   sendCondition(cond)
[17:39:59.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.370]                   {
[17:39:59.370]                     inherits <- base::inherits
[17:39:59.370]                     invokeRestart <- base::invokeRestart
[17:39:59.370]                     is.null <- base::is.null
[17:39:59.370]                     muffled <- FALSE
[17:39:59.370]                     if (inherits(cond, "message")) {
[17:39:59.370]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.370]                       if (muffled) 
[17:39:59.370]                         invokeRestart("muffleMessage")
[17:39:59.370]                     }
[17:39:59.370]                     else if (inherits(cond, "warning")) {
[17:39:59.370]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.370]                       if (muffled) 
[17:39:59.370]                         invokeRestart("muffleWarning")
[17:39:59.370]                     }
[17:39:59.370]                     else if (inherits(cond, "condition")) {
[17:39:59.370]                       if (!is.null(pattern)) {
[17:39:59.370]                         computeRestarts <- base::computeRestarts
[17:39:59.370]                         grepl <- base::grepl
[17:39:59.370]                         restarts <- computeRestarts(cond)
[17:39:59.370]                         for (restart in restarts) {
[17:39:59.370]                           name <- restart$name
[17:39:59.370]                           if (is.null(name)) 
[17:39:59.370]                             next
[17:39:59.370]                           if (!grepl(pattern, name)) 
[17:39:59.370]                             next
[17:39:59.370]                           invokeRestart(restart)
[17:39:59.370]                           muffled <- TRUE
[17:39:59.370]                           break
[17:39:59.370]                         }
[17:39:59.370]                       }
[17:39:59.370]                     }
[17:39:59.370]                     invisible(muffled)
[17:39:59.370]                   }
[17:39:59.370]                   muffleCondition(cond)
[17:39:59.370]                 })
[17:39:59.370]             }))
[17:39:59.370]             future::FutureResult(value = ...future.value$value, 
[17:39:59.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.370]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.370]                     ...future.globalenv.names))
[17:39:59.370]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.370]         }, condition = base::local({
[17:39:59.370]             c <- base::c
[17:39:59.370]             inherits <- base::inherits
[17:39:59.370]             invokeRestart <- base::invokeRestart
[17:39:59.370]             length <- base::length
[17:39:59.370]             list <- base::list
[17:39:59.370]             seq.int <- base::seq.int
[17:39:59.370]             signalCondition <- base::signalCondition
[17:39:59.370]             sys.calls <- base::sys.calls
[17:39:59.370]             `[[` <- base::`[[`
[17:39:59.370]             `+` <- base::`+`
[17:39:59.370]             `<<-` <- base::`<<-`
[17:39:59.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.370]                   3L)]
[17:39:59.370]             }
[17:39:59.370]             function(cond) {
[17:39:59.370]                 is_error <- inherits(cond, "error")
[17:39:59.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.370]                   NULL)
[17:39:59.370]                 if (is_error) {
[17:39:59.370]                   sessionInformation <- function() {
[17:39:59.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.370]                       search = base::search(), system = base::Sys.info())
[17:39:59.370]                   }
[17:39:59.370]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.370]                     cond$call), session = sessionInformation(), 
[17:39:59.370]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.370]                   signalCondition(cond)
[17:39:59.370]                 }
[17:39:59.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.370]                 "immediateCondition"))) {
[17:39:59.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.370]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.370]                   if (TRUE && !signal) {
[17:39:59.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.370]                     {
[17:39:59.370]                       inherits <- base::inherits
[17:39:59.370]                       invokeRestart <- base::invokeRestart
[17:39:59.370]                       is.null <- base::is.null
[17:39:59.370]                       muffled <- FALSE
[17:39:59.370]                       if (inherits(cond, "message")) {
[17:39:59.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.370]                         if (muffled) 
[17:39:59.370]                           invokeRestart("muffleMessage")
[17:39:59.370]                       }
[17:39:59.370]                       else if (inherits(cond, "warning")) {
[17:39:59.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.370]                         if (muffled) 
[17:39:59.370]                           invokeRestart("muffleWarning")
[17:39:59.370]                       }
[17:39:59.370]                       else if (inherits(cond, "condition")) {
[17:39:59.370]                         if (!is.null(pattern)) {
[17:39:59.370]                           computeRestarts <- base::computeRestarts
[17:39:59.370]                           grepl <- base::grepl
[17:39:59.370]                           restarts <- computeRestarts(cond)
[17:39:59.370]                           for (restart in restarts) {
[17:39:59.370]                             name <- restart$name
[17:39:59.370]                             if (is.null(name)) 
[17:39:59.370]                               next
[17:39:59.370]                             if (!grepl(pattern, name)) 
[17:39:59.370]                               next
[17:39:59.370]                             invokeRestart(restart)
[17:39:59.370]                             muffled <- TRUE
[17:39:59.370]                             break
[17:39:59.370]                           }
[17:39:59.370]                         }
[17:39:59.370]                       }
[17:39:59.370]                       invisible(muffled)
[17:39:59.370]                     }
[17:39:59.370]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.370]                   }
[17:39:59.370]                 }
[17:39:59.370]                 else {
[17:39:59.370]                   if (TRUE) {
[17:39:59.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.370]                     {
[17:39:59.370]                       inherits <- base::inherits
[17:39:59.370]                       invokeRestart <- base::invokeRestart
[17:39:59.370]                       is.null <- base::is.null
[17:39:59.370]                       muffled <- FALSE
[17:39:59.370]                       if (inherits(cond, "message")) {
[17:39:59.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.370]                         if (muffled) 
[17:39:59.370]                           invokeRestart("muffleMessage")
[17:39:59.370]                       }
[17:39:59.370]                       else if (inherits(cond, "warning")) {
[17:39:59.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.370]                         if (muffled) 
[17:39:59.370]                           invokeRestart("muffleWarning")
[17:39:59.370]                       }
[17:39:59.370]                       else if (inherits(cond, "condition")) {
[17:39:59.370]                         if (!is.null(pattern)) {
[17:39:59.370]                           computeRestarts <- base::computeRestarts
[17:39:59.370]                           grepl <- base::grepl
[17:39:59.370]                           restarts <- computeRestarts(cond)
[17:39:59.370]                           for (restart in restarts) {
[17:39:59.370]                             name <- restart$name
[17:39:59.370]                             if (is.null(name)) 
[17:39:59.370]                               next
[17:39:59.370]                             if (!grepl(pattern, name)) 
[17:39:59.370]                               next
[17:39:59.370]                             invokeRestart(restart)
[17:39:59.370]                             muffled <- TRUE
[17:39:59.370]                             break
[17:39:59.370]                           }
[17:39:59.370]                         }
[17:39:59.370]                       }
[17:39:59.370]                       invisible(muffled)
[17:39:59.370]                     }
[17:39:59.370]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.370]                   }
[17:39:59.370]                 }
[17:39:59.370]             }
[17:39:59.370]         }))
[17:39:59.370]     }, error = function(ex) {
[17:39:59.370]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.370]                 ...future.rng), started = ...future.startTime, 
[17:39:59.370]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.370]             version = "1.8"), class = "FutureResult")
[17:39:59.370]     }, finally = {
[17:39:59.370]         if (!identical(...future.workdir, getwd())) 
[17:39:59.370]             setwd(...future.workdir)
[17:39:59.370]         {
[17:39:59.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.370]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.370]             }
[17:39:59.370]             base::options(...future.oldOptions)
[17:39:59.370]             if (.Platform$OS.type == "windows") {
[17:39:59.370]                 old_names <- names(...future.oldEnvVars)
[17:39:59.370]                 envs <- base::Sys.getenv()
[17:39:59.370]                 names <- names(envs)
[17:39:59.370]                 common <- intersect(names, old_names)
[17:39:59.370]                 added <- setdiff(names, old_names)
[17:39:59.370]                 removed <- setdiff(old_names, names)
[17:39:59.370]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.370]                   envs[common]]
[17:39:59.370]                 NAMES <- toupper(changed)
[17:39:59.370]                 args <- list()
[17:39:59.370]                 for (kk in seq_along(NAMES)) {
[17:39:59.370]                   name <- changed[[kk]]
[17:39:59.370]                   NAME <- NAMES[[kk]]
[17:39:59.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.370]                     next
[17:39:59.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.370]                 }
[17:39:59.370]                 NAMES <- toupper(added)
[17:39:59.370]                 for (kk in seq_along(NAMES)) {
[17:39:59.370]                   name <- added[[kk]]
[17:39:59.370]                   NAME <- NAMES[[kk]]
[17:39:59.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.370]                     next
[17:39:59.370]                   args[[name]] <- ""
[17:39:59.370]                 }
[17:39:59.370]                 NAMES <- toupper(removed)
[17:39:59.370]                 for (kk in seq_along(NAMES)) {
[17:39:59.370]                   name <- removed[[kk]]
[17:39:59.370]                   NAME <- NAMES[[kk]]
[17:39:59.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.370]                     next
[17:39:59.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.370]                 }
[17:39:59.370]                 if (length(args) > 0) 
[17:39:59.370]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.370]             }
[17:39:59.370]             else {
[17:39:59.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.370]             }
[17:39:59.370]             {
[17:39:59.370]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.370]                   0L) {
[17:39:59.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.370]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.370]                   base::options(opts)
[17:39:59.370]                 }
[17:39:59.370]                 {
[17:39:59.370]                   {
[17:39:59.370]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.370]                     NULL
[17:39:59.370]                   }
[17:39:59.370]                   options(future.plan = NULL)
[17:39:59.370]                   if (is.na(NA_character_)) 
[17:39:59.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.370]                     .init = FALSE)
[17:39:59.370]                 }
[17:39:59.370]             }
[17:39:59.370]         }
[17:39:59.370]     })
[17:39:59.370]     if (TRUE) {
[17:39:59.370]         base::sink(type = "output", split = FALSE)
[17:39:59.370]         if (TRUE) {
[17:39:59.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.370]         }
[17:39:59.370]         else {
[17:39:59.370]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.370]         }
[17:39:59.370]         base::close(...future.stdout)
[17:39:59.370]         ...future.stdout <- NULL
[17:39:59.370]     }
[17:39:59.370]     ...future.result$conditions <- ...future.conditions
[17:39:59.370]     ...future.result$finished <- base::Sys.time()
[17:39:59.370]     ...future.result
[17:39:59.370] }
[17:39:59.372] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:59.383] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.383] - Validating connection of MultisessionFuture
[17:39:59.383] - received message: FutureResult
[17:39:59.383] - Received FutureResult
[17:39:59.383] - Erased future from FutureRegistry
[17:39:59.383] result() for ClusterFuture ...
[17:39:59.384] - result already collected: FutureResult
[17:39:59.384] result() for ClusterFuture ... done
[17:39:59.384] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.384] result() for ClusterFuture ...
[17:39:59.384] - result already collected: FutureResult
[17:39:59.384] result() for ClusterFuture ... done
[17:39:59.384] result() for ClusterFuture ...
[17:39:59.384] - result already collected: FutureResult
[17:39:59.384] result() for ClusterFuture ... done
[17:39:59.385] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:39:59.385] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:39:59.385] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:39:59.386] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:39:59.386] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:59.386] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:39:59.386] MultisessionFuture started
[17:39:59.387] - Launch lazy future ... done
[17:39:59.387] run() for ‘MultisessionFuture’ ... done
[17:39:59.387] result() for ClusterFuture ...
[17:39:59.387] - result already collected: FutureResult
[17:39:59.387] result() for ClusterFuture ... done
[17:39:59.387] result() for ClusterFuture ...
[17:39:59.387] - result already collected: FutureResult
[17:39:59.387] result() for ClusterFuture ... done
[17:39:59.387] result() for ClusterFuture ...
[17:39:59.388] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.388] - Validating connection of MultisessionFuture
[17:39:59.388] - received message: FutureResult
[17:39:59.388] - Received FutureResult
[17:39:59.388] - Erased future from FutureRegistry
[17:39:59.388] result() for ClusterFuture ...
[17:39:59.388] - result already collected: FutureResult
[17:39:59.388] result() for ClusterFuture ... done
[17:39:59.388] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.388] result() for ClusterFuture ... done
[17:39:59.389] result() for ClusterFuture ...
[17:39:59.389] - result already collected: FutureResult
[17:39:59.389] result() for ClusterFuture ... done
[17:39:59.389] result() for ClusterFuture ...
[17:39:59.389] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.389] - Validating connection of MultisessionFuture
[17:39:59.430] - received message: FutureResult
[17:39:59.430] - Received FutureResult
[17:39:59.430] - Erased future from FutureRegistry
[17:39:59.431] result() for ClusterFuture ...
[17:39:59.431] - result already collected: FutureResult
[17:39:59.431] result() for ClusterFuture ... done
[17:39:59.431] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.431] result() for ClusterFuture ... done
[17:39:59.431] result() for ClusterFuture ...
[17:39:59.431] - result already collected: FutureResult
[17:39:59.431] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.432] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.432] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.434] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.434] Searching for globals ... DONE
[17:39:59.434] Resolving globals: TRUE
[17:39:59.434] Resolving any globals that are futures ...
[17:39:59.434] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.434] Resolving any globals that are futures ... DONE
[17:39:59.435] Resolving futures part of globals (recursively) ...
[17:39:59.435] resolve() on list ...
[17:39:59.435]  recursive: 99
[17:39:59.435]  length: 2
[17:39:59.435]  elements: ‘a’, ‘ii’
[17:39:59.435]  length: 1 (resolved future 1)
[17:39:59.436]  length: 0 (resolved future 2)
[17:39:59.436] resolve() on list ... DONE
[17:39:59.436] - globals: [2] ‘a’, ‘ii’
[17:39:59.436] Resolving futures part of globals (recursively) ... DONE
[17:39:59.436] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:59.436] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:59.436] - globals: [2] ‘a’, ‘ii’
[17:39:59.437] 
[17:39:59.437] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.437] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.437] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.439] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.439] Searching for globals ... DONE
[17:39:59.439] Resolving globals: TRUE
[17:39:59.439] Resolving any globals that are futures ...
[17:39:59.439] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.440] Resolving any globals that are futures ... DONE
[17:39:59.440] Resolving futures part of globals (recursively) ...
[17:39:59.440] resolve() on list ...
[17:39:59.440]  recursive: 99
[17:39:59.440]  length: 2
[17:39:59.440]  elements: ‘a’, ‘ii’
[17:39:59.441]  length: 1 (resolved future 1)
[17:39:59.441]  length: 0 (resolved future 2)
[17:39:59.441] resolve() on list ... DONE
[17:39:59.441] - globals: [2] ‘a’, ‘ii’
[17:39:59.441] Resolving futures part of globals (recursively) ... DONE
[17:39:59.441] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:59.441] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:59.442] - globals: [2] ‘a’, ‘ii’
[17:39:59.442] 
[17:39:59.442] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.442] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.442] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.444] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.444] Searching for globals ... DONE
[17:39:59.444] Resolving globals: TRUE
[17:39:59.444] Resolving any globals that are futures ...
[17:39:59.445] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:39:59.445] Resolving any globals that are futures ... DONE
[17:39:59.445] Resolving futures part of globals (recursively) ...
[17:39:59.445] resolve() on list ...
[17:39:59.445]  recursive: 99
[17:39:59.445]  length: 2
[17:39:59.445]  elements: ‘a’, ‘ii’
[17:39:59.446]  length: 1 (resolved future 1)
[17:39:59.446]  length: 0 (resolved future 2)
[17:39:59.446] resolve() on list ... DONE
[17:39:59.446] - globals: [2] ‘a’, ‘ii’
[17:39:59.446] Resolving futures part of globals (recursively) ... DONE
[17:39:59.446] The total size of the 2 globals is 112 bytes (112 bytes)
[17:39:59.446] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:39:59.447] - globals: [2] ‘a’, ‘ii’
[17:39:59.447] 
[17:39:59.447] getGlobalsAndPackages() ... DONE
[17:39:59.447] run() for ‘Future’ ...
[17:39:59.447] - state: ‘created’
[17:39:59.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.461] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.461]   - Field: ‘node’
[17:39:59.461]   - Field: ‘label’
[17:39:59.462]   - Field: ‘local’
[17:39:59.462]   - Field: ‘owner’
[17:39:59.462]   - Field: ‘envir’
[17:39:59.462]   - Field: ‘workers’
[17:39:59.462]   - Field: ‘packages’
[17:39:59.462]   - Field: ‘gc’
[17:39:59.462]   - Field: ‘conditions’
[17:39:59.462]   - Field: ‘persistent’
[17:39:59.462]   - Field: ‘expr’
[17:39:59.462]   - Field: ‘uuid’
[17:39:59.462]   - Field: ‘seed’
[17:39:59.463]   - Field: ‘version’
[17:39:59.463]   - Field: ‘result’
[17:39:59.463]   - Field: ‘asynchronous’
[17:39:59.463]   - Field: ‘calls’
[17:39:59.463]   - Field: ‘globals’
[17:39:59.463]   - Field: ‘stdout’
[17:39:59.463]   - Field: ‘earlySignal’
[17:39:59.463]   - Field: ‘lazy’
[17:39:59.463]   - Field: ‘state’
[17:39:59.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.463] - Launch lazy future ...
[17:39:59.464] Packages needed by the future expression (n = 0): <none>
[17:39:59.464] Packages needed by future strategies (n = 0): <none>
[17:39:59.464] {
[17:39:59.464]     {
[17:39:59.464]         {
[17:39:59.464]             ...future.startTime <- base::Sys.time()
[17:39:59.464]             {
[17:39:59.464]                 {
[17:39:59.464]                   {
[17:39:59.464]                     {
[17:39:59.464]                       base::local({
[17:39:59.464]                         has_future <- base::requireNamespace("future", 
[17:39:59.464]                           quietly = TRUE)
[17:39:59.464]                         if (has_future) {
[17:39:59.464]                           ns <- base::getNamespace("future")
[17:39:59.464]                           version <- ns[[".package"]][["version"]]
[17:39:59.464]                           if (is.null(version)) 
[17:39:59.464]                             version <- utils::packageVersion("future")
[17:39:59.464]                         }
[17:39:59.464]                         else {
[17:39:59.464]                           version <- NULL
[17:39:59.464]                         }
[17:39:59.464]                         if (!has_future || version < "1.8.0") {
[17:39:59.464]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.464]                             "", base::R.version$version.string), 
[17:39:59.464]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.464]                               "release", "version")], collapse = " "), 
[17:39:59.464]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.464]                             info)
[17:39:59.464]                           info <- base::paste(info, collapse = "; ")
[17:39:59.464]                           if (!has_future) {
[17:39:59.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.464]                               info)
[17:39:59.464]                           }
[17:39:59.464]                           else {
[17:39:59.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.464]                               info, version)
[17:39:59.464]                           }
[17:39:59.464]                           base::stop(msg)
[17:39:59.464]                         }
[17:39:59.464]                       })
[17:39:59.464]                     }
[17:39:59.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.464]                     base::options(mc.cores = 1L)
[17:39:59.464]                   }
[17:39:59.464]                   ...future.strategy.old <- future::plan("list")
[17:39:59.464]                   options(future.plan = NULL)
[17:39:59.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.464]                 }
[17:39:59.464]                 ...future.workdir <- getwd()
[17:39:59.464]             }
[17:39:59.464]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.464]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.464]         }
[17:39:59.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.464]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.464]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.464]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.464]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.464]             base::names(...future.oldOptions))
[17:39:59.464]     }
[17:39:59.464]     if (FALSE) {
[17:39:59.464]     }
[17:39:59.464]     else {
[17:39:59.464]         if (TRUE) {
[17:39:59.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.464]                 open = "w")
[17:39:59.464]         }
[17:39:59.464]         else {
[17:39:59.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.464]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.464]         }
[17:39:59.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.464]             base::sink(type = "output", split = FALSE)
[17:39:59.464]             base::close(...future.stdout)
[17:39:59.464]         }, add = TRUE)
[17:39:59.464]     }
[17:39:59.464]     ...future.frame <- base::sys.nframe()
[17:39:59.464]     ...future.conditions <- base::list()
[17:39:59.464]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.464]     if (FALSE) {
[17:39:59.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.464]     }
[17:39:59.464]     ...future.result <- base::tryCatch({
[17:39:59.464]         base::withCallingHandlers({
[17:39:59.464]             ...future.value <- base::withVisible(base::local({
[17:39:59.464]                 ...future.makeSendCondition <- base::local({
[17:39:59.464]                   sendCondition <- NULL
[17:39:59.464]                   function(frame = 1L) {
[17:39:59.464]                     if (is.function(sendCondition)) 
[17:39:59.464]                       return(sendCondition)
[17:39:59.464]                     ns <- getNamespace("parallel")
[17:39:59.464]                     if (exists("sendData", mode = "function", 
[17:39:59.464]                       envir = ns)) {
[17:39:59.464]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.464]                         envir = ns)
[17:39:59.464]                       envir <- sys.frame(frame)
[17:39:59.464]                       master <- NULL
[17:39:59.464]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.464]                         !identical(envir, emptyenv())) {
[17:39:59.464]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.464]                           inherits = FALSE)) {
[17:39:59.464]                           master <- get("master", mode = "list", 
[17:39:59.464]                             envir = envir, inherits = FALSE)
[17:39:59.464]                           if (inherits(master, c("SOCKnode", 
[17:39:59.464]                             "SOCK0node"))) {
[17:39:59.464]                             sendCondition <<- function(cond) {
[17:39:59.464]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.464]                                 success = TRUE)
[17:39:59.464]                               parallel_sendData(master, data)
[17:39:59.464]                             }
[17:39:59.464]                             return(sendCondition)
[17:39:59.464]                           }
[17:39:59.464]                         }
[17:39:59.464]                         frame <- frame + 1L
[17:39:59.464]                         envir <- sys.frame(frame)
[17:39:59.464]                       }
[17:39:59.464]                     }
[17:39:59.464]                     sendCondition <<- function(cond) NULL
[17:39:59.464]                   }
[17:39:59.464]                 })
[17:39:59.464]                 withCallingHandlers({
[17:39:59.464]                   {
[17:39:59.464]                     b <- a * ii
[17:39:59.464]                     a <- 0
[17:39:59.464]                     b
[17:39:59.464]                   }
[17:39:59.464]                 }, immediateCondition = function(cond) {
[17:39:59.464]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.464]                   sendCondition(cond)
[17:39:59.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.464]                   {
[17:39:59.464]                     inherits <- base::inherits
[17:39:59.464]                     invokeRestart <- base::invokeRestart
[17:39:59.464]                     is.null <- base::is.null
[17:39:59.464]                     muffled <- FALSE
[17:39:59.464]                     if (inherits(cond, "message")) {
[17:39:59.464]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.464]                       if (muffled) 
[17:39:59.464]                         invokeRestart("muffleMessage")
[17:39:59.464]                     }
[17:39:59.464]                     else if (inherits(cond, "warning")) {
[17:39:59.464]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.464]                       if (muffled) 
[17:39:59.464]                         invokeRestart("muffleWarning")
[17:39:59.464]                     }
[17:39:59.464]                     else if (inherits(cond, "condition")) {
[17:39:59.464]                       if (!is.null(pattern)) {
[17:39:59.464]                         computeRestarts <- base::computeRestarts
[17:39:59.464]                         grepl <- base::grepl
[17:39:59.464]                         restarts <- computeRestarts(cond)
[17:39:59.464]                         for (restart in restarts) {
[17:39:59.464]                           name <- restart$name
[17:39:59.464]                           if (is.null(name)) 
[17:39:59.464]                             next
[17:39:59.464]                           if (!grepl(pattern, name)) 
[17:39:59.464]                             next
[17:39:59.464]                           invokeRestart(restart)
[17:39:59.464]                           muffled <- TRUE
[17:39:59.464]                           break
[17:39:59.464]                         }
[17:39:59.464]                       }
[17:39:59.464]                     }
[17:39:59.464]                     invisible(muffled)
[17:39:59.464]                   }
[17:39:59.464]                   muffleCondition(cond)
[17:39:59.464]                 })
[17:39:59.464]             }))
[17:39:59.464]             future::FutureResult(value = ...future.value$value, 
[17:39:59.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.464]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.464]                     ...future.globalenv.names))
[17:39:59.464]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.464]         }, condition = base::local({
[17:39:59.464]             c <- base::c
[17:39:59.464]             inherits <- base::inherits
[17:39:59.464]             invokeRestart <- base::invokeRestart
[17:39:59.464]             length <- base::length
[17:39:59.464]             list <- base::list
[17:39:59.464]             seq.int <- base::seq.int
[17:39:59.464]             signalCondition <- base::signalCondition
[17:39:59.464]             sys.calls <- base::sys.calls
[17:39:59.464]             `[[` <- base::`[[`
[17:39:59.464]             `+` <- base::`+`
[17:39:59.464]             `<<-` <- base::`<<-`
[17:39:59.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.464]                   3L)]
[17:39:59.464]             }
[17:39:59.464]             function(cond) {
[17:39:59.464]                 is_error <- inherits(cond, "error")
[17:39:59.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.464]                   NULL)
[17:39:59.464]                 if (is_error) {
[17:39:59.464]                   sessionInformation <- function() {
[17:39:59.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.464]                       search = base::search(), system = base::Sys.info())
[17:39:59.464]                   }
[17:39:59.464]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.464]                     cond$call), session = sessionInformation(), 
[17:39:59.464]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.464]                   signalCondition(cond)
[17:39:59.464]                 }
[17:39:59.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.464]                 "immediateCondition"))) {
[17:39:59.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.464]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.464]                   if (TRUE && !signal) {
[17:39:59.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.464]                     {
[17:39:59.464]                       inherits <- base::inherits
[17:39:59.464]                       invokeRestart <- base::invokeRestart
[17:39:59.464]                       is.null <- base::is.null
[17:39:59.464]                       muffled <- FALSE
[17:39:59.464]                       if (inherits(cond, "message")) {
[17:39:59.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.464]                         if (muffled) 
[17:39:59.464]                           invokeRestart("muffleMessage")
[17:39:59.464]                       }
[17:39:59.464]                       else if (inherits(cond, "warning")) {
[17:39:59.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.464]                         if (muffled) 
[17:39:59.464]                           invokeRestart("muffleWarning")
[17:39:59.464]                       }
[17:39:59.464]                       else if (inherits(cond, "condition")) {
[17:39:59.464]                         if (!is.null(pattern)) {
[17:39:59.464]                           computeRestarts <- base::computeRestarts
[17:39:59.464]                           grepl <- base::grepl
[17:39:59.464]                           restarts <- computeRestarts(cond)
[17:39:59.464]                           for (restart in restarts) {
[17:39:59.464]                             name <- restart$name
[17:39:59.464]                             if (is.null(name)) 
[17:39:59.464]                               next
[17:39:59.464]                             if (!grepl(pattern, name)) 
[17:39:59.464]                               next
[17:39:59.464]                             invokeRestart(restart)
[17:39:59.464]                             muffled <- TRUE
[17:39:59.464]                             break
[17:39:59.464]                           }
[17:39:59.464]                         }
[17:39:59.464]                       }
[17:39:59.464]                       invisible(muffled)
[17:39:59.464]                     }
[17:39:59.464]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.464]                   }
[17:39:59.464]                 }
[17:39:59.464]                 else {
[17:39:59.464]                   if (TRUE) {
[17:39:59.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.464]                     {
[17:39:59.464]                       inherits <- base::inherits
[17:39:59.464]                       invokeRestart <- base::invokeRestart
[17:39:59.464]                       is.null <- base::is.null
[17:39:59.464]                       muffled <- FALSE
[17:39:59.464]                       if (inherits(cond, "message")) {
[17:39:59.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.464]                         if (muffled) 
[17:39:59.464]                           invokeRestart("muffleMessage")
[17:39:59.464]                       }
[17:39:59.464]                       else if (inherits(cond, "warning")) {
[17:39:59.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.464]                         if (muffled) 
[17:39:59.464]                           invokeRestart("muffleWarning")
[17:39:59.464]                       }
[17:39:59.464]                       else if (inherits(cond, "condition")) {
[17:39:59.464]                         if (!is.null(pattern)) {
[17:39:59.464]                           computeRestarts <- base::computeRestarts
[17:39:59.464]                           grepl <- base::grepl
[17:39:59.464]                           restarts <- computeRestarts(cond)
[17:39:59.464]                           for (restart in restarts) {
[17:39:59.464]                             name <- restart$name
[17:39:59.464]                             if (is.null(name)) 
[17:39:59.464]                               next
[17:39:59.464]                             if (!grepl(pattern, name)) 
[17:39:59.464]                               next
[17:39:59.464]                             invokeRestart(restart)
[17:39:59.464]                             muffled <- TRUE
[17:39:59.464]                             break
[17:39:59.464]                           }
[17:39:59.464]                         }
[17:39:59.464]                       }
[17:39:59.464]                       invisible(muffled)
[17:39:59.464]                     }
[17:39:59.464]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.464]                   }
[17:39:59.464]                 }
[17:39:59.464]             }
[17:39:59.464]         }))
[17:39:59.464]     }, error = function(ex) {
[17:39:59.464]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.464]                 ...future.rng), started = ...future.startTime, 
[17:39:59.464]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.464]             version = "1.8"), class = "FutureResult")
[17:39:59.464]     }, finally = {
[17:39:59.464]         if (!identical(...future.workdir, getwd())) 
[17:39:59.464]             setwd(...future.workdir)
[17:39:59.464]         {
[17:39:59.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.464]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.464]             }
[17:39:59.464]             base::options(...future.oldOptions)
[17:39:59.464]             if (.Platform$OS.type == "windows") {
[17:39:59.464]                 old_names <- names(...future.oldEnvVars)
[17:39:59.464]                 envs <- base::Sys.getenv()
[17:39:59.464]                 names <- names(envs)
[17:39:59.464]                 common <- intersect(names, old_names)
[17:39:59.464]                 added <- setdiff(names, old_names)
[17:39:59.464]                 removed <- setdiff(old_names, names)
[17:39:59.464]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.464]                   envs[common]]
[17:39:59.464]                 NAMES <- toupper(changed)
[17:39:59.464]                 args <- list()
[17:39:59.464]                 for (kk in seq_along(NAMES)) {
[17:39:59.464]                   name <- changed[[kk]]
[17:39:59.464]                   NAME <- NAMES[[kk]]
[17:39:59.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.464]                     next
[17:39:59.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.464]                 }
[17:39:59.464]                 NAMES <- toupper(added)
[17:39:59.464]                 for (kk in seq_along(NAMES)) {
[17:39:59.464]                   name <- added[[kk]]
[17:39:59.464]                   NAME <- NAMES[[kk]]
[17:39:59.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.464]                     next
[17:39:59.464]                   args[[name]] <- ""
[17:39:59.464]                 }
[17:39:59.464]                 NAMES <- toupper(removed)
[17:39:59.464]                 for (kk in seq_along(NAMES)) {
[17:39:59.464]                   name <- removed[[kk]]
[17:39:59.464]                   NAME <- NAMES[[kk]]
[17:39:59.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.464]                     next
[17:39:59.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.464]                 }
[17:39:59.464]                 if (length(args) > 0) 
[17:39:59.464]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.464]             }
[17:39:59.464]             else {
[17:39:59.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.464]             }
[17:39:59.464]             {
[17:39:59.464]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.464]                   0L) {
[17:39:59.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.464]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.464]                   base::options(opts)
[17:39:59.464]                 }
[17:39:59.464]                 {
[17:39:59.464]                   {
[17:39:59.464]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.464]                     NULL
[17:39:59.464]                   }
[17:39:59.464]                   options(future.plan = NULL)
[17:39:59.464]                   if (is.na(NA_character_)) 
[17:39:59.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.464]                     .init = FALSE)
[17:39:59.464]                 }
[17:39:59.464]             }
[17:39:59.464]         }
[17:39:59.464]     })
[17:39:59.464]     if (TRUE) {
[17:39:59.464]         base::sink(type = "output", split = FALSE)
[17:39:59.464]         if (TRUE) {
[17:39:59.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.464]         }
[17:39:59.464]         else {
[17:39:59.464]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.464]         }
[17:39:59.464]         base::close(...future.stdout)
[17:39:59.464]         ...future.stdout <- NULL
[17:39:59.464]     }
[17:39:59.464]     ...future.result$conditions <- ...future.conditions
[17:39:59.464]     ...future.result$finished <- base::Sys.time()
[17:39:59.464]     ...future.result
[17:39:59.464] }
[17:39:59.467] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:39:59.467] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:39:59.467] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.467] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:39:59.468] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.468] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:39:59.468] MultisessionFuture started
[17:39:59.468] - Launch lazy future ... done
[17:39:59.468] run() for ‘MultisessionFuture’ ... done
[17:39:59.469] result() for ClusterFuture ...
[17:39:59.469] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.469] - Validating connection of MultisessionFuture
[17:39:59.470] - received message: FutureResult
[17:39:59.470] - Received FutureResult
[17:39:59.470] - Erased future from FutureRegistry
[17:39:59.470] result() for ClusterFuture ...
[17:39:59.470] - result already collected: FutureResult
[17:39:59.470] result() for ClusterFuture ... done
[17:39:59.470] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.471] result() for ClusterFuture ... done
[17:39:59.471] result() for ClusterFuture ...
[17:39:59.471] - result already collected: FutureResult
[17:39:59.471] result() for ClusterFuture ... done
[17:39:59.471] run() for ‘Future’ ...
[17:39:59.471] - state: ‘created’
[17:39:59.471] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.487] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.487]   - Field: ‘node’
[17:39:59.487]   - Field: ‘label’
[17:39:59.487]   - Field: ‘local’
[17:39:59.487]   - Field: ‘owner’
[17:39:59.487]   - Field: ‘envir’
[17:39:59.488]   - Field: ‘workers’
[17:39:59.488]   - Field: ‘packages’
[17:39:59.488]   - Field: ‘gc’
[17:39:59.488]   - Field: ‘conditions’
[17:39:59.488]   - Field: ‘persistent’
[17:39:59.488]   - Field: ‘expr’
[17:39:59.488]   - Field: ‘uuid’
[17:39:59.488]   - Field: ‘seed’
[17:39:59.488]   - Field: ‘version’
[17:39:59.488]   - Field: ‘result’
[17:39:59.488]   - Field: ‘asynchronous’
[17:39:59.489]   - Field: ‘calls’
[17:39:59.489]   - Field: ‘globals’
[17:39:59.489]   - Field: ‘stdout’
[17:39:59.489]   - Field: ‘earlySignal’
[17:39:59.489]   - Field: ‘lazy’
[17:39:59.489]   - Field: ‘state’
[17:39:59.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.489] - Launch lazy future ...
[17:39:59.489] Packages needed by the future expression (n = 0): <none>
[17:39:59.490] Packages needed by future strategies (n = 0): <none>
[17:39:59.490] {
[17:39:59.490]     {
[17:39:59.490]         {
[17:39:59.490]             ...future.startTime <- base::Sys.time()
[17:39:59.490]             {
[17:39:59.490]                 {
[17:39:59.490]                   {
[17:39:59.490]                     {
[17:39:59.490]                       base::local({
[17:39:59.490]                         has_future <- base::requireNamespace("future", 
[17:39:59.490]                           quietly = TRUE)
[17:39:59.490]                         if (has_future) {
[17:39:59.490]                           ns <- base::getNamespace("future")
[17:39:59.490]                           version <- ns[[".package"]][["version"]]
[17:39:59.490]                           if (is.null(version)) 
[17:39:59.490]                             version <- utils::packageVersion("future")
[17:39:59.490]                         }
[17:39:59.490]                         else {
[17:39:59.490]                           version <- NULL
[17:39:59.490]                         }
[17:39:59.490]                         if (!has_future || version < "1.8.0") {
[17:39:59.490]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.490]                             "", base::R.version$version.string), 
[17:39:59.490]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.490]                               "release", "version")], collapse = " "), 
[17:39:59.490]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.490]                             info)
[17:39:59.490]                           info <- base::paste(info, collapse = "; ")
[17:39:59.490]                           if (!has_future) {
[17:39:59.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.490]                               info)
[17:39:59.490]                           }
[17:39:59.490]                           else {
[17:39:59.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.490]                               info, version)
[17:39:59.490]                           }
[17:39:59.490]                           base::stop(msg)
[17:39:59.490]                         }
[17:39:59.490]                       })
[17:39:59.490]                     }
[17:39:59.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.490]                     base::options(mc.cores = 1L)
[17:39:59.490]                   }
[17:39:59.490]                   ...future.strategy.old <- future::plan("list")
[17:39:59.490]                   options(future.plan = NULL)
[17:39:59.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.490]                 }
[17:39:59.490]                 ...future.workdir <- getwd()
[17:39:59.490]             }
[17:39:59.490]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.490]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.490]         }
[17:39:59.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.490]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.490]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.490]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.490]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.490]             base::names(...future.oldOptions))
[17:39:59.490]     }
[17:39:59.490]     if (FALSE) {
[17:39:59.490]     }
[17:39:59.490]     else {
[17:39:59.490]         if (TRUE) {
[17:39:59.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.490]                 open = "w")
[17:39:59.490]         }
[17:39:59.490]         else {
[17:39:59.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.490]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.490]         }
[17:39:59.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.490]             base::sink(type = "output", split = FALSE)
[17:39:59.490]             base::close(...future.stdout)
[17:39:59.490]         }, add = TRUE)
[17:39:59.490]     }
[17:39:59.490]     ...future.frame <- base::sys.nframe()
[17:39:59.490]     ...future.conditions <- base::list()
[17:39:59.490]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.490]     if (FALSE) {
[17:39:59.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.490]     }
[17:39:59.490]     ...future.result <- base::tryCatch({
[17:39:59.490]         base::withCallingHandlers({
[17:39:59.490]             ...future.value <- base::withVisible(base::local({
[17:39:59.490]                 ...future.makeSendCondition <- base::local({
[17:39:59.490]                   sendCondition <- NULL
[17:39:59.490]                   function(frame = 1L) {
[17:39:59.490]                     if (is.function(sendCondition)) 
[17:39:59.490]                       return(sendCondition)
[17:39:59.490]                     ns <- getNamespace("parallel")
[17:39:59.490]                     if (exists("sendData", mode = "function", 
[17:39:59.490]                       envir = ns)) {
[17:39:59.490]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.490]                         envir = ns)
[17:39:59.490]                       envir <- sys.frame(frame)
[17:39:59.490]                       master <- NULL
[17:39:59.490]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.490]                         !identical(envir, emptyenv())) {
[17:39:59.490]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.490]                           inherits = FALSE)) {
[17:39:59.490]                           master <- get("master", mode = "list", 
[17:39:59.490]                             envir = envir, inherits = FALSE)
[17:39:59.490]                           if (inherits(master, c("SOCKnode", 
[17:39:59.490]                             "SOCK0node"))) {
[17:39:59.490]                             sendCondition <<- function(cond) {
[17:39:59.490]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.490]                                 success = TRUE)
[17:39:59.490]                               parallel_sendData(master, data)
[17:39:59.490]                             }
[17:39:59.490]                             return(sendCondition)
[17:39:59.490]                           }
[17:39:59.490]                         }
[17:39:59.490]                         frame <- frame + 1L
[17:39:59.490]                         envir <- sys.frame(frame)
[17:39:59.490]                       }
[17:39:59.490]                     }
[17:39:59.490]                     sendCondition <<- function(cond) NULL
[17:39:59.490]                   }
[17:39:59.490]                 })
[17:39:59.490]                 withCallingHandlers({
[17:39:59.490]                   {
[17:39:59.490]                     b <- a * ii
[17:39:59.490]                     a <- 0
[17:39:59.490]                     b
[17:39:59.490]                   }
[17:39:59.490]                 }, immediateCondition = function(cond) {
[17:39:59.490]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.490]                   sendCondition(cond)
[17:39:59.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.490]                   {
[17:39:59.490]                     inherits <- base::inherits
[17:39:59.490]                     invokeRestart <- base::invokeRestart
[17:39:59.490]                     is.null <- base::is.null
[17:39:59.490]                     muffled <- FALSE
[17:39:59.490]                     if (inherits(cond, "message")) {
[17:39:59.490]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.490]                       if (muffled) 
[17:39:59.490]                         invokeRestart("muffleMessage")
[17:39:59.490]                     }
[17:39:59.490]                     else if (inherits(cond, "warning")) {
[17:39:59.490]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.490]                       if (muffled) 
[17:39:59.490]                         invokeRestart("muffleWarning")
[17:39:59.490]                     }
[17:39:59.490]                     else if (inherits(cond, "condition")) {
[17:39:59.490]                       if (!is.null(pattern)) {
[17:39:59.490]                         computeRestarts <- base::computeRestarts
[17:39:59.490]                         grepl <- base::grepl
[17:39:59.490]                         restarts <- computeRestarts(cond)
[17:39:59.490]                         for (restart in restarts) {
[17:39:59.490]                           name <- restart$name
[17:39:59.490]                           if (is.null(name)) 
[17:39:59.490]                             next
[17:39:59.490]                           if (!grepl(pattern, name)) 
[17:39:59.490]                             next
[17:39:59.490]                           invokeRestart(restart)
[17:39:59.490]                           muffled <- TRUE
[17:39:59.490]                           break
[17:39:59.490]                         }
[17:39:59.490]                       }
[17:39:59.490]                     }
[17:39:59.490]                     invisible(muffled)
[17:39:59.490]                   }
[17:39:59.490]                   muffleCondition(cond)
[17:39:59.490]                 })
[17:39:59.490]             }))
[17:39:59.490]             future::FutureResult(value = ...future.value$value, 
[17:39:59.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.490]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.490]                     ...future.globalenv.names))
[17:39:59.490]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.490]         }, condition = base::local({
[17:39:59.490]             c <- base::c
[17:39:59.490]             inherits <- base::inherits
[17:39:59.490]             invokeRestart <- base::invokeRestart
[17:39:59.490]             length <- base::length
[17:39:59.490]             list <- base::list
[17:39:59.490]             seq.int <- base::seq.int
[17:39:59.490]             signalCondition <- base::signalCondition
[17:39:59.490]             sys.calls <- base::sys.calls
[17:39:59.490]             `[[` <- base::`[[`
[17:39:59.490]             `+` <- base::`+`
[17:39:59.490]             `<<-` <- base::`<<-`
[17:39:59.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.490]                   3L)]
[17:39:59.490]             }
[17:39:59.490]             function(cond) {
[17:39:59.490]                 is_error <- inherits(cond, "error")
[17:39:59.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.490]                   NULL)
[17:39:59.490]                 if (is_error) {
[17:39:59.490]                   sessionInformation <- function() {
[17:39:59.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.490]                       search = base::search(), system = base::Sys.info())
[17:39:59.490]                   }
[17:39:59.490]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.490]                     cond$call), session = sessionInformation(), 
[17:39:59.490]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.490]                   signalCondition(cond)
[17:39:59.490]                 }
[17:39:59.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.490]                 "immediateCondition"))) {
[17:39:59.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.490]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.490]                   if (TRUE && !signal) {
[17:39:59.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.490]                     {
[17:39:59.490]                       inherits <- base::inherits
[17:39:59.490]                       invokeRestart <- base::invokeRestart
[17:39:59.490]                       is.null <- base::is.null
[17:39:59.490]                       muffled <- FALSE
[17:39:59.490]                       if (inherits(cond, "message")) {
[17:39:59.490]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.490]                         if (muffled) 
[17:39:59.490]                           invokeRestart("muffleMessage")
[17:39:59.490]                       }
[17:39:59.490]                       else if (inherits(cond, "warning")) {
[17:39:59.490]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.490]                         if (muffled) 
[17:39:59.490]                           invokeRestart("muffleWarning")
[17:39:59.490]                       }
[17:39:59.490]                       else if (inherits(cond, "condition")) {
[17:39:59.490]                         if (!is.null(pattern)) {
[17:39:59.490]                           computeRestarts <- base::computeRestarts
[17:39:59.490]                           grepl <- base::grepl
[17:39:59.490]                           restarts <- computeRestarts(cond)
[17:39:59.490]                           for (restart in restarts) {
[17:39:59.490]                             name <- restart$name
[17:39:59.490]                             if (is.null(name)) 
[17:39:59.490]                               next
[17:39:59.490]                             if (!grepl(pattern, name)) 
[17:39:59.490]                               next
[17:39:59.490]                             invokeRestart(restart)
[17:39:59.490]                             muffled <- TRUE
[17:39:59.490]                             break
[17:39:59.490]                           }
[17:39:59.490]                         }
[17:39:59.490]                       }
[17:39:59.490]                       invisible(muffled)
[17:39:59.490]                     }
[17:39:59.490]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.490]                   }
[17:39:59.490]                 }
[17:39:59.490]                 else {
[17:39:59.490]                   if (TRUE) {
[17:39:59.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.490]                     {
[17:39:59.490]                       inherits <- base::inherits
[17:39:59.490]                       invokeRestart <- base::invokeRestart
[17:39:59.490]                       is.null <- base::is.null
[17:39:59.490]                       muffled <- FALSE
[17:39:59.490]                       if (inherits(cond, "message")) {
[17:39:59.490]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.490]                         if (muffled) 
[17:39:59.490]                           invokeRestart("muffleMessage")
[17:39:59.490]                       }
[17:39:59.490]                       else if (inherits(cond, "warning")) {
[17:39:59.490]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.490]                         if (muffled) 
[17:39:59.490]                           invokeRestart("muffleWarning")
[17:39:59.490]                       }
[17:39:59.490]                       else if (inherits(cond, "condition")) {
[17:39:59.490]                         if (!is.null(pattern)) {
[17:39:59.490]                           computeRestarts <- base::computeRestarts
[17:39:59.490]                           grepl <- base::grepl
[17:39:59.490]                           restarts <- computeRestarts(cond)
[17:39:59.490]                           for (restart in restarts) {
[17:39:59.490]                             name <- restart$name
[17:39:59.490]                             if (is.null(name)) 
[17:39:59.490]                               next
[17:39:59.490]                             if (!grepl(pattern, name)) 
[17:39:59.490]                               next
[17:39:59.490]                             invokeRestart(restart)
[17:39:59.490]                             muffled <- TRUE
[17:39:59.490]                             break
[17:39:59.490]                           }
[17:39:59.490]                         }
[17:39:59.490]                       }
[17:39:59.490]                       invisible(muffled)
[17:39:59.490]                     }
[17:39:59.490]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.490]                   }
[17:39:59.490]                 }
[17:39:59.490]             }
[17:39:59.490]         }))
[17:39:59.490]     }, error = function(ex) {
[17:39:59.490]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.490]                 ...future.rng), started = ...future.startTime, 
[17:39:59.490]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.490]             version = "1.8"), class = "FutureResult")
[17:39:59.490]     }, finally = {
[17:39:59.490]         if (!identical(...future.workdir, getwd())) 
[17:39:59.490]             setwd(...future.workdir)
[17:39:59.490]         {
[17:39:59.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.490]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.490]             }
[17:39:59.490]             base::options(...future.oldOptions)
[17:39:59.490]             if (.Platform$OS.type == "windows") {
[17:39:59.490]                 old_names <- names(...future.oldEnvVars)
[17:39:59.490]                 envs <- base::Sys.getenv()
[17:39:59.490]                 names <- names(envs)
[17:39:59.490]                 common <- intersect(names, old_names)
[17:39:59.490]                 added <- setdiff(names, old_names)
[17:39:59.490]                 removed <- setdiff(old_names, names)
[17:39:59.490]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.490]                   envs[common]]
[17:39:59.490]                 NAMES <- toupper(changed)
[17:39:59.490]                 args <- list()
[17:39:59.490]                 for (kk in seq_along(NAMES)) {
[17:39:59.490]                   name <- changed[[kk]]
[17:39:59.490]                   NAME <- NAMES[[kk]]
[17:39:59.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.490]                     next
[17:39:59.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.490]                 }
[17:39:59.490]                 NAMES <- toupper(added)
[17:39:59.490]                 for (kk in seq_along(NAMES)) {
[17:39:59.490]                   name <- added[[kk]]
[17:39:59.490]                   NAME <- NAMES[[kk]]
[17:39:59.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.490]                     next
[17:39:59.490]                   args[[name]] <- ""
[17:39:59.490]                 }
[17:39:59.490]                 NAMES <- toupper(removed)
[17:39:59.490]                 for (kk in seq_along(NAMES)) {
[17:39:59.490]                   name <- removed[[kk]]
[17:39:59.490]                   NAME <- NAMES[[kk]]
[17:39:59.490]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.490]                     next
[17:39:59.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.490]                 }
[17:39:59.490]                 if (length(args) > 0) 
[17:39:59.490]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.490]             }
[17:39:59.490]             else {
[17:39:59.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.490]             }
[17:39:59.490]             {
[17:39:59.490]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.490]                   0L) {
[17:39:59.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.490]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.490]                   base::options(opts)
[17:39:59.490]                 }
[17:39:59.490]                 {
[17:39:59.490]                   {
[17:39:59.490]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.490]                     NULL
[17:39:59.490]                   }
[17:39:59.490]                   options(future.plan = NULL)
[17:39:59.490]                   if (is.na(NA_character_)) 
[17:39:59.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.490]                     .init = FALSE)
[17:39:59.490]                 }
[17:39:59.490]             }
[17:39:59.490]         }
[17:39:59.490]     })
[17:39:59.490]     if (TRUE) {
[17:39:59.490]         base::sink(type = "output", split = FALSE)
[17:39:59.490]         if (TRUE) {
[17:39:59.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.490]         }
[17:39:59.490]         else {
[17:39:59.490]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.490]         }
[17:39:59.490]         base::close(...future.stdout)
[17:39:59.490]         ...future.stdout <- NULL
[17:39:59.490]     }
[17:39:59.490]     ...future.result$conditions <- ...future.conditions
[17:39:59.490]     ...future.result$finished <- base::Sys.time()
[17:39:59.490]     ...future.result
[17:39:59.490] }
[17:39:59.492] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:39:59.493] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:39:59.493] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.493] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:39:59.493] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.494] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:39:59.494] MultisessionFuture started
[17:39:59.494] - Launch lazy future ... done
[17:39:59.494] run() for ‘MultisessionFuture’ ... done
[17:39:59.494] result() for ClusterFuture ...
[17:39:59.495] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.495] - Validating connection of MultisessionFuture
[17:39:59.496] - received message: FutureResult
[17:39:59.496] - Received FutureResult
[17:39:59.496] - Erased future from FutureRegistry
[17:39:59.496] result() for ClusterFuture ...
[17:39:59.496] - result already collected: FutureResult
[17:39:59.496] result() for ClusterFuture ... done
[17:39:59.497] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.497] result() for ClusterFuture ... done
[17:39:59.497] result() for ClusterFuture ...
[17:39:59.497] - result already collected: FutureResult
[17:39:59.497] result() for ClusterFuture ... done
[17:39:59.497] run() for ‘Future’ ...
[17:39:59.497] - state: ‘created’
[17:39:59.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.511]   - Field: ‘node’
[17:39:59.511]   - Field: ‘label’
[17:39:59.511]   - Field: ‘local’
[17:39:59.511]   - Field: ‘owner’
[17:39:59.511]   - Field: ‘envir’
[17:39:59.511]   - Field: ‘workers’
[17:39:59.511]   - Field: ‘packages’
[17:39:59.512]   - Field: ‘gc’
[17:39:59.512]   - Field: ‘conditions’
[17:39:59.512]   - Field: ‘persistent’
[17:39:59.512]   - Field: ‘expr’
[17:39:59.512]   - Field: ‘uuid’
[17:39:59.512]   - Field: ‘seed’
[17:39:59.512]   - Field: ‘version’
[17:39:59.512]   - Field: ‘result’
[17:39:59.512]   - Field: ‘asynchronous’
[17:39:59.512]   - Field: ‘calls’
[17:39:59.512]   - Field: ‘globals’
[17:39:59.513]   - Field: ‘stdout’
[17:39:59.513]   - Field: ‘earlySignal’
[17:39:59.513]   - Field: ‘lazy’
[17:39:59.513]   - Field: ‘state’
[17:39:59.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.513] - Launch lazy future ...
[17:39:59.513] Packages needed by the future expression (n = 0): <none>
[17:39:59.513] Packages needed by future strategies (n = 0): <none>
[17:39:59.514] {
[17:39:59.514]     {
[17:39:59.514]         {
[17:39:59.514]             ...future.startTime <- base::Sys.time()
[17:39:59.514]             {
[17:39:59.514]                 {
[17:39:59.514]                   {
[17:39:59.514]                     {
[17:39:59.514]                       base::local({
[17:39:59.514]                         has_future <- base::requireNamespace("future", 
[17:39:59.514]                           quietly = TRUE)
[17:39:59.514]                         if (has_future) {
[17:39:59.514]                           ns <- base::getNamespace("future")
[17:39:59.514]                           version <- ns[[".package"]][["version"]]
[17:39:59.514]                           if (is.null(version)) 
[17:39:59.514]                             version <- utils::packageVersion("future")
[17:39:59.514]                         }
[17:39:59.514]                         else {
[17:39:59.514]                           version <- NULL
[17:39:59.514]                         }
[17:39:59.514]                         if (!has_future || version < "1.8.0") {
[17:39:59.514]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.514]                             "", base::R.version$version.string), 
[17:39:59.514]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.514]                               "release", "version")], collapse = " "), 
[17:39:59.514]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.514]                             info)
[17:39:59.514]                           info <- base::paste(info, collapse = "; ")
[17:39:59.514]                           if (!has_future) {
[17:39:59.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.514]                               info)
[17:39:59.514]                           }
[17:39:59.514]                           else {
[17:39:59.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.514]                               info, version)
[17:39:59.514]                           }
[17:39:59.514]                           base::stop(msg)
[17:39:59.514]                         }
[17:39:59.514]                       })
[17:39:59.514]                     }
[17:39:59.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.514]                     base::options(mc.cores = 1L)
[17:39:59.514]                   }
[17:39:59.514]                   ...future.strategy.old <- future::plan("list")
[17:39:59.514]                   options(future.plan = NULL)
[17:39:59.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.514]                 }
[17:39:59.514]                 ...future.workdir <- getwd()
[17:39:59.514]             }
[17:39:59.514]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.514]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.514]         }
[17:39:59.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.514]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.514]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.514]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.514]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.514]             base::names(...future.oldOptions))
[17:39:59.514]     }
[17:39:59.514]     if (FALSE) {
[17:39:59.514]     }
[17:39:59.514]     else {
[17:39:59.514]         if (TRUE) {
[17:39:59.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.514]                 open = "w")
[17:39:59.514]         }
[17:39:59.514]         else {
[17:39:59.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.514]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.514]         }
[17:39:59.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.514]             base::sink(type = "output", split = FALSE)
[17:39:59.514]             base::close(...future.stdout)
[17:39:59.514]         }, add = TRUE)
[17:39:59.514]     }
[17:39:59.514]     ...future.frame <- base::sys.nframe()
[17:39:59.514]     ...future.conditions <- base::list()
[17:39:59.514]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.514]     if (FALSE) {
[17:39:59.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.514]     }
[17:39:59.514]     ...future.result <- base::tryCatch({
[17:39:59.514]         base::withCallingHandlers({
[17:39:59.514]             ...future.value <- base::withVisible(base::local({
[17:39:59.514]                 ...future.makeSendCondition <- base::local({
[17:39:59.514]                   sendCondition <- NULL
[17:39:59.514]                   function(frame = 1L) {
[17:39:59.514]                     if (is.function(sendCondition)) 
[17:39:59.514]                       return(sendCondition)
[17:39:59.514]                     ns <- getNamespace("parallel")
[17:39:59.514]                     if (exists("sendData", mode = "function", 
[17:39:59.514]                       envir = ns)) {
[17:39:59.514]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.514]                         envir = ns)
[17:39:59.514]                       envir <- sys.frame(frame)
[17:39:59.514]                       master <- NULL
[17:39:59.514]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.514]                         !identical(envir, emptyenv())) {
[17:39:59.514]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.514]                           inherits = FALSE)) {
[17:39:59.514]                           master <- get("master", mode = "list", 
[17:39:59.514]                             envir = envir, inherits = FALSE)
[17:39:59.514]                           if (inherits(master, c("SOCKnode", 
[17:39:59.514]                             "SOCK0node"))) {
[17:39:59.514]                             sendCondition <<- function(cond) {
[17:39:59.514]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.514]                                 success = TRUE)
[17:39:59.514]                               parallel_sendData(master, data)
[17:39:59.514]                             }
[17:39:59.514]                             return(sendCondition)
[17:39:59.514]                           }
[17:39:59.514]                         }
[17:39:59.514]                         frame <- frame + 1L
[17:39:59.514]                         envir <- sys.frame(frame)
[17:39:59.514]                       }
[17:39:59.514]                     }
[17:39:59.514]                     sendCondition <<- function(cond) NULL
[17:39:59.514]                   }
[17:39:59.514]                 })
[17:39:59.514]                 withCallingHandlers({
[17:39:59.514]                   {
[17:39:59.514]                     b <- a * ii
[17:39:59.514]                     a <- 0
[17:39:59.514]                     b
[17:39:59.514]                   }
[17:39:59.514]                 }, immediateCondition = function(cond) {
[17:39:59.514]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.514]                   sendCondition(cond)
[17:39:59.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.514]                   {
[17:39:59.514]                     inherits <- base::inherits
[17:39:59.514]                     invokeRestart <- base::invokeRestart
[17:39:59.514]                     is.null <- base::is.null
[17:39:59.514]                     muffled <- FALSE
[17:39:59.514]                     if (inherits(cond, "message")) {
[17:39:59.514]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.514]                       if (muffled) 
[17:39:59.514]                         invokeRestart("muffleMessage")
[17:39:59.514]                     }
[17:39:59.514]                     else if (inherits(cond, "warning")) {
[17:39:59.514]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.514]                       if (muffled) 
[17:39:59.514]                         invokeRestart("muffleWarning")
[17:39:59.514]                     }
[17:39:59.514]                     else if (inherits(cond, "condition")) {
[17:39:59.514]                       if (!is.null(pattern)) {
[17:39:59.514]                         computeRestarts <- base::computeRestarts
[17:39:59.514]                         grepl <- base::grepl
[17:39:59.514]                         restarts <- computeRestarts(cond)
[17:39:59.514]                         for (restart in restarts) {
[17:39:59.514]                           name <- restart$name
[17:39:59.514]                           if (is.null(name)) 
[17:39:59.514]                             next
[17:39:59.514]                           if (!grepl(pattern, name)) 
[17:39:59.514]                             next
[17:39:59.514]                           invokeRestart(restart)
[17:39:59.514]                           muffled <- TRUE
[17:39:59.514]                           break
[17:39:59.514]                         }
[17:39:59.514]                       }
[17:39:59.514]                     }
[17:39:59.514]                     invisible(muffled)
[17:39:59.514]                   }
[17:39:59.514]                   muffleCondition(cond)
[17:39:59.514]                 })
[17:39:59.514]             }))
[17:39:59.514]             future::FutureResult(value = ...future.value$value, 
[17:39:59.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.514]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.514]                     ...future.globalenv.names))
[17:39:59.514]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.514]         }, condition = base::local({
[17:39:59.514]             c <- base::c
[17:39:59.514]             inherits <- base::inherits
[17:39:59.514]             invokeRestart <- base::invokeRestart
[17:39:59.514]             length <- base::length
[17:39:59.514]             list <- base::list
[17:39:59.514]             seq.int <- base::seq.int
[17:39:59.514]             signalCondition <- base::signalCondition
[17:39:59.514]             sys.calls <- base::sys.calls
[17:39:59.514]             `[[` <- base::`[[`
[17:39:59.514]             `+` <- base::`+`
[17:39:59.514]             `<<-` <- base::`<<-`
[17:39:59.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.514]                   3L)]
[17:39:59.514]             }
[17:39:59.514]             function(cond) {
[17:39:59.514]                 is_error <- inherits(cond, "error")
[17:39:59.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.514]                   NULL)
[17:39:59.514]                 if (is_error) {
[17:39:59.514]                   sessionInformation <- function() {
[17:39:59.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.514]                       search = base::search(), system = base::Sys.info())
[17:39:59.514]                   }
[17:39:59.514]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.514]                     cond$call), session = sessionInformation(), 
[17:39:59.514]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.514]                   signalCondition(cond)
[17:39:59.514]                 }
[17:39:59.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.514]                 "immediateCondition"))) {
[17:39:59.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.514]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.514]                   if (TRUE && !signal) {
[17:39:59.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.514]                     {
[17:39:59.514]                       inherits <- base::inherits
[17:39:59.514]                       invokeRestart <- base::invokeRestart
[17:39:59.514]                       is.null <- base::is.null
[17:39:59.514]                       muffled <- FALSE
[17:39:59.514]                       if (inherits(cond, "message")) {
[17:39:59.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.514]                         if (muffled) 
[17:39:59.514]                           invokeRestart("muffleMessage")
[17:39:59.514]                       }
[17:39:59.514]                       else if (inherits(cond, "warning")) {
[17:39:59.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.514]                         if (muffled) 
[17:39:59.514]                           invokeRestart("muffleWarning")
[17:39:59.514]                       }
[17:39:59.514]                       else if (inherits(cond, "condition")) {
[17:39:59.514]                         if (!is.null(pattern)) {
[17:39:59.514]                           computeRestarts <- base::computeRestarts
[17:39:59.514]                           grepl <- base::grepl
[17:39:59.514]                           restarts <- computeRestarts(cond)
[17:39:59.514]                           for (restart in restarts) {
[17:39:59.514]                             name <- restart$name
[17:39:59.514]                             if (is.null(name)) 
[17:39:59.514]                               next
[17:39:59.514]                             if (!grepl(pattern, name)) 
[17:39:59.514]                               next
[17:39:59.514]                             invokeRestart(restart)
[17:39:59.514]                             muffled <- TRUE
[17:39:59.514]                             break
[17:39:59.514]                           }
[17:39:59.514]                         }
[17:39:59.514]                       }
[17:39:59.514]                       invisible(muffled)
[17:39:59.514]                     }
[17:39:59.514]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.514]                   }
[17:39:59.514]                 }
[17:39:59.514]                 else {
[17:39:59.514]                   if (TRUE) {
[17:39:59.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.514]                     {
[17:39:59.514]                       inherits <- base::inherits
[17:39:59.514]                       invokeRestart <- base::invokeRestart
[17:39:59.514]                       is.null <- base::is.null
[17:39:59.514]                       muffled <- FALSE
[17:39:59.514]                       if (inherits(cond, "message")) {
[17:39:59.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.514]                         if (muffled) 
[17:39:59.514]                           invokeRestart("muffleMessage")
[17:39:59.514]                       }
[17:39:59.514]                       else if (inherits(cond, "warning")) {
[17:39:59.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.514]                         if (muffled) 
[17:39:59.514]                           invokeRestart("muffleWarning")
[17:39:59.514]                       }
[17:39:59.514]                       else if (inherits(cond, "condition")) {
[17:39:59.514]                         if (!is.null(pattern)) {
[17:39:59.514]                           computeRestarts <- base::computeRestarts
[17:39:59.514]                           grepl <- base::grepl
[17:39:59.514]                           restarts <- computeRestarts(cond)
[17:39:59.514]                           for (restart in restarts) {
[17:39:59.514]                             name <- restart$name
[17:39:59.514]                             if (is.null(name)) 
[17:39:59.514]                               next
[17:39:59.514]                             if (!grepl(pattern, name)) 
[17:39:59.514]                               next
[17:39:59.514]                             invokeRestart(restart)
[17:39:59.514]                             muffled <- TRUE
[17:39:59.514]                             break
[17:39:59.514]                           }
[17:39:59.514]                         }
[17:39:59.514]                       }
[17:39:59.514]                       invisible(muffled)
[17:39:59.514]                     }
[17:39:59.514]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.514]                   }
[17:39:59.514]                 }
[17:39:59.514]             }
[17:39:59.514]         }))
[17:39:59.514]     }, error = function(ex) {
[17:39:59.514]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.514]                 ...future.rng), started = ...future.startTime, 
[17:39:59.514]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.514]             version = "1.8"), class = "FutureResult")
[17:39:59.514]     }, finally = {
[17:39:59.514]         if (!identical(...future.workdir, getwd())) 
[17:39:59.514]             setwd(...future.workdir)
[17:39:59.514]         {
[17:39:59.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.514]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.514]             }
[17:39:59.514]             base::options(...future.oldOptions)
[17:39:59.514]             if (.Platform$OS.type == "windows") {
[17:39:59.514]                 old_names <- names(...future.oldEnvVars)
[17:39:59.514]                 envs <- base::Sys.getenv()
[17:39:59.514]                 names <- names(envs)
[17:39:59.514]                 common <- intersect(names, old_names)
[17:39:59.514]                 added <- setdiff(names, old_names)
[17:39:59.514]                 removed <- setdiff(old_names, names)
[17:39:59.514]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.514]                   envs[common]]
[17:39:59.514]                 NAMES <- toupper(changed)
[17:39:59.514]                 args <- list()
[17:39:59.514]                 for (kk in seq_along(NAMES)) {
[17:39:59.514]                   name <- changed[[kk]]
[17:39:59.514]                   NAME <- NAMES[[kk]]
[17:39:59.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.514]                     next
[17:39:59.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.514]                 }
[17:39:59.514]                 NAMES <- toupper(added)
[17:39:59.514]                 for (kk in seq_along(NAMES)) {
[17:39:59.514]                   name <- added[[kk]]
[17:39:59.514]                   NAME <- NAMES[[kk]]
[17:39:59.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.514]                     next
[17:39:59.514]                   args[[name]] <- ""
[17:39:59.514]                 }
[17:39:59.514]                 NAMES <- toupper(removed)
[17:39:59.514]                 for (kk in seq_along(NAMES)) {
[17:39:59.514]                   name <- removed[[kk]]
[17:39:59.514]                   NAME <- NAMES[[kk]]
[17:39:59.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.514]                     next
[17:39:59.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.514]                 }
[17:39:59.514]                 if (length(args) > 0) 
[17:39:59.514]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.514]             }
[17:39:59.514]             else {
[17:39:59.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.514]             }
[17:39:59.514]             {
[17:39:59.514]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.514]                   0L) {
[17:39:59.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.514]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.514]                   base::options(opts)
[17:39:59.514]                 }
[17:39:59.514]                 {
[17:39:59.514]                   {
[17:39:59.514]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.514]                     NULL
[17:39:59.514]                   }
[17:39:59.514]                   options(future.plan = NULL)
[17:39:59.514]                   if (is.na(NA_character_)) 
[17:39:59.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.514]                     .init = FALSE)
[17:39:59.514]                 }
[17:39:59.514]             }
[17:39:59.514]         }
[17:39:59.514]     })
[17:39:59.514]     if (TRUE) {
[17:39:59.514]         base::sink(type = "output", split = FALSE)
[17:39:59.514]         if (TRUE) {
[17:39:59.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.514]         }
[17:39:59.514]         else {
[17:39:59.514]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.514]         }
[17:39:59.514]         base::close(...future.stdout)
[17:39:59.514]         ...future.stdout <- NULL
[17:39:59.514]     }
[17:39:59.514]     ...future.result$conditions <- ...future.conditions
[17:39:59.514]     ...future.result$finished <- base::Sys.time()
[17:39:59.514]     ...future.result
[17:39:59.514] }
[17:39:59.516] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:39:59.516] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:39:59.517] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.517] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:39:59.517] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:59.517] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:39:59.518] MultisessionFuture started
[17:39:59.518] - Launch lazy future ... done
[17:39:59.518] run() for ‘MultisessionFuture’ ... done
[17:39:59.518] result() for ClusterFuture ...
[17:39:59.518] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.519] - Validating connection of MultisessionFuture
[17:39:59.520] - received message: FutureResult
[17:39:59.520] - Received FutureResult
[17:39:59.520] - Erased future from FutureRegistry
[17:39:59.520] result() for ClusterFuture ...
[17:39:59.520] - result already collected: FutureResult
[17:39:59.520] result() for ClusterFuture ... done
[17:39:59.520] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.520] result() for ClusterFuture ... done
[17:39:59.520] result() for ClusterFuture ...
[17:39:59.521] - result already collected: FutureResult
[17:39:59.521] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.521] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.521] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.522] 
[17:39:59.522] Searching for globals ... DONE
[17:39:59.522] - globals: [0] <none>
[17:39:59.522] getGlobalsAndPackages() ... DONE
[17:39:59.522] run() for ‘Future’ ...
[17:39:59.522] - state: ‘created’
[17:39:59.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.536] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.537]   - Field: ‘node’
[17:39:59.537]   - Field: ‘label’
[17:39:59.537]   - Field: ‘local’
[17:39:59.537]   - Field: ‘owner’
[17:39:59.537]   - Field: ‘envir’
[17:39:59.537]   - Field: ‘workers’
[17:39:59.537]   - Field: ‘packages’
[17:39:59.537]   - Field: ‘gc’
[17:39:59.537]   - Field: ‘conditions’
[17:39:59.537]   - Field: ‘persistent’
[17:39:59.537]   - Field: ‘expr’
[17:39:59.538]   - Field: ‘uuid’
[17:39:59.538]   - Field: ‘seed’
[17:39:59.538]   - Field: ‘version’
[17:39:59.538]   - Field: ‘result’
[17:39:59.538]   - Field: ‘asynchronous’
[17:39:59.538]   - Field: ‘calls’
[17:39:59.538]   - Field: ‘globals’
[17:39:59.538]   - Field: ‘stdout’
[17:39:59.538]   - Field: ‘earlySignal’
[17:39:59.538]   - Field: ‘lazy’
[17:39:59.538]   - Field: ‘state’
[17:39:59.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.539] - Launch lazy future ...
[17:39:59.539] Packages needed by the future expression (n = 0): <none>
[17:39:59.539] Packages needed by future strategies (n = 0): <none>
[17:39:59.539] {
[17:39:59.539]     {
[17:39:59.539]         {
[17:39:59.539]             ...future.startTime <- base::Sys.time()
[17:39:59.539]             {
[17:39:59.539]                 {
[17:39:59.539]                   {
[17:39:59.539]                     {
[17:39:59.539]                       base::local({
[17:39:59.539]                         has_future <- base::requireNamespace("future", 
[17:39:59.539]                           quietly = TRUE)
[17:39:59.539]                         if (has_future) {
[17:39:59.539]                           ns <- base::getNamespace("future")
[17:39:59.539]                           version <- ns[[".package"]][["version"]]
[17:39:59.539]                           if (is.null(version)) 
[17:39:59.539]                             version <- utils::packageVersion("future")
[17:39:59.539]                         }
[17:39:59.539]                         else {
[17:39:59.539]                           version <- NULL
[17:39:59.539]                         }
[17:39:59.539]                         if (!has_future || version < "1.8.0") {
[17:39:59.539]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.539]                             "", base::R.version$version.string), 
[17:39:59.539]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.539]                               "release", "version")], collapse = " "), 
[17:39:59.539]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.539]                             info)
[17:39:59.539]                           info <- base::paste(info, collapse = "; ")
[17:39:59.539]                           if (!has_future) {
[17:39:59.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.539]                               info)
[17:39:59.539]                           }
[17:39:59.539]                           else {
[17:39:59.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.539]                               info, version)
[17:39:59.539]                           }
[17:39:59.539]                           base::stop(msg)
[17:39:59.539]                         }
[17:39:59.539]                       })
[17:39:59.539]                     }
[17:39:59.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.539]                     base::options(mc.cores = 1L)
[17:39:59.539]                   }
[17:39:59.539]                   ...future.strategy.old <- future::plan("list")
[17:39:59.539]                   options(future.plan = NULL)
[17:39:59.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.539]                 }
[17:39:59.539]                 ...future.workdir <- getwd()
[17:39:59.539]             }
[17:39:59.539]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.539]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.539]         }
[17:39:59.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.539]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.539]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.539]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.539]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.539]             base::names(...future.oldOptions))
[17:39:59.539]     }
[17:39:59.539]     if (FALSE) {
[17:39:59.539]     }
[17:39:59.539]     else {
[17:39:59.539]         if (TRUE) {
[17:39:59.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.539]                 open = "w")
[17:39:59.539]         }
[17:39:59.539]         else {
[17:39:59.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.539]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.539]         }
[17:39:59.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.539]             base::sink(type = "output", split = FALSE)
[17:39:59.539]             base::close(...future.stdout)
[17:39:59.539]         }, add = TRUE)
[17:39:59.539]     }
[17:39:59.539]     ...future.frame <- base::sys.nframe()
[17:39:59.539]     ...future.conditions <- base::list()
[17:39:59.539]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.539]     if (FALSE) {
[17:39:59.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.539]     }
[17:39:59.539]     ...future.result <- base::tryCatch({
[17:39:59.539]         base::withCallingHandlers({
[17:39:59.539]             ...future.value <- base::withVisible(base::local({
[17:39:59.539]                 ...future.makeSendCondition <- base::local({
[17:39:59.539]                   sendCondition <- NULL
[17:39:59.539]                   function(frame = 1L) {
[17:39:59.539]                     if (is.function(sendCondition)) 
[17:39:59.539]                       return(sendCondition)
[17:39:59.539]                     ns <- getNamespace("parallel")
[17:39:59.539]                     if (exists("sendData", mode = "function", 
[17:39:59.539]                       envir = ns)) {
[17:39:59.539]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.539]                         envir = ns)
[17:39:59.539]                       envir <- sys.frame(frame)
[17:39:59.539]                       master <- NULL
[17:39:59.539]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.539]                         !identical(envir, emptyenv())) {
[17:39:59.539]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.539]                           inherits = FALSE)) {
[17:39:59.539]                           master <- get("master", mode = "list", 
[17:39:59.539]                             envir = envir, inherits = FALSE)
[17:39:59.539]                           if (inherits(master, c("SOCKnode", 
[17:39:59.539]                             "SOCK0node"))) {
[17:39:59.539]                             sendCondition <<- function(cond) {
[17:39:59.539]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.539]                                 success = TRUE)
[17:39:59.539]                               parallel_sendData(master, data)
[17:39:59.539]                             }
[17:39:59.539]                             return(sendCondition)
[17:39:59.539]                           }
[17:39:59.539]                         }
[17:39:59.539]                         frame <- frame + 1L
[17:39:59.539]                         envir <- sys.frame(frame)
[17:39:59.539]                       }
[17:39:59.539]                     }
[17:39:59.539]                     sendCondition <<- function(cond) NULL
[17:39:59.539]                   }
[17:39:59.539]                 })
[17:39:59.539]                 withCallingHandlers({
[17:39:59.539]                   1
[17:39:59.539]                 }, immediateCondition = function(cond) {
[17:39:59.539]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.539]                   sendCondition(cond)
[17:39:59.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.539]                   {
[17:39:59.539]                     inherits <- base::inherits
[17:39:59.539]                     invokeRestart <- base::invokeRestart
[17:39:59.539]                     is.null <- base::is.null
[17:39:59.539]                     muffled <- FALSE
[17:39:59.539]                     if (inherits(cond, "message")) {
[17:39:59.539]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.539]                       if (muffled) 
[17:39:59.539]                         invokeRestart("muffleMessage")
[17:39:59.539]                     }
[17:39:59.539]                     else if (inherits(cond, "warning")) {
[17:39:59.539]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.539]                       if (muffled) 
[17:39:59.539]                         invokeRestart("muffleWarning")
[17:39:59.539]                     }
[17:39:59.539]                     else if (inherits(cond, "condition")) {
[17:39:59.539]                       if (!is.null(pattern)) {
[17:39:59.539]                         computeRestarts <- base::computeRestarts
[17:39:59.539]                         grepl <- base::grepl
[17:39:59.539]                         restarts <- computeRestarts(cond)
[17:39:59.539]                         for (restart in restarts) {
[17:39:59.539]                           name <- restart$name
[17:39:59.539]                           if (is.null(name)) 
[17:39:59.539]                             next
[17:39:59.539]                           if (!grepl(pattern, name)) 
[17:39:59.539]                             next
[17:39:59.539]                           invokeRestart(restart)
[17:39:59.539]                           muffled <- TRUE
[17:39:59.539]                           break
[17:39:59.539]                         }
[17:39:59.539]                       }
[17:39:59.539]                     }
[17:39:59.539]                     invisible(muffled)
[17:39:59.539]                   }
[17:39:59.539]                   muffleCondition(cond)
[17:39:59.539]                 })
[17:39:59.539]             }))
[17:39:59.539]             future::FutureResult(value = ...future.value$value, 
[17:39:59.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.539]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.539]                     ...future.globalenv.names))
[17:39:59.539]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.539]         }, condition = base::local({
[17:39:59.539]             c <- base::c
[17:39:59.539]             inherits <- base::inherits
[17:39:59.539]             invokeRestart <- base::invokeRestart
[17:39:59.539]             length <- base::length
[17:39:59.539]             list <- base::list
[17:39:59.539]             seq.int <- base::seq.int
[17:39:59.539]             signalCondition <- base::signalCondition
[17:39:59.539]             sys.calls <- base::sys.calls
[17:39:59.539]             `[[` <- base::`[[`
[17:39:59.539]             `+` <- base::`+`
[17:39:59.539]             `<<-` <- base::`<<-`
[17:39:59.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.539]                   3L)]
[17:39:59.539]             }
[17:39:59.539]             function(cond) {
[17:39:59.539]                 is_error <- inherits(cond, "error")
[17:39:59.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.539]                   NULL)
[17:39:59.539]                 if (is_error) {
[17:39:59.539]                   sessionInformation <- function() {
[17:39:59.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.539]                       search = base::search(), system = base::Sys.info())
[17:39:59.539]                   }
[17:39:59.539]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.539]                     cond$call), session = sessionInformation(), 
[17:39:59.539]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.539]                   signalCondition(cond)
[17:39:59.539]                 }
[17:39:59.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.539]                 "immediateCondition"))) {
[17:39:59.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.539]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.539]                   if (TRUE && !signal) {
[17:39:59.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.539]                     {
[17:39:59.539]                       inherits <- base::inherits
[17:39:59.539]                       invokeRestart <- base::invokeRestart
[17:39:59.539]                       is.null <- base::is.null
[17:39:59.539]                       muffled <- FALSE
[17:39:59.539]                       if (inherits(cond, "message")) {
[17:39:59.539]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.539]                         if (muffled) 
[17:39:59.539]                           invokeRestart("muffleMessage")
[17:39:59.539]                       }
[17:39:59.539]                       else if (inherits(cond, "warning")) {
[17:39:59.539]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.539]                         if (muffled) 
[17:39:59.539]                           invokeRestart("muffleWarning")
[17:39:59.539]                       }
[17:39:59.539]                       else if (inherits(cond, "condition")) {
[17:39:59.539]                         if (!is.null(pattern)) {
[17:39:59.539]                           computeRestarts <- base::computeRestarts
[17:39:59.539]                           grepl <- base::grepl
[17:39:59.539]                           restarts <- computeRestarts(cond)
[17:39:59.539]                           for (restart in restarts) {
[17:39:59.539]                             name <- restart$name
[17:39:59.539]                             if (is.null(name)) 
[17:39:59.539]                               next
[17:39:59.539]                             if (!grepl(pattern, name)) 
[17:39:59.539]                               next
[17:39:59.539]                             invokeRestart(restart)
[17:39:59.539]                             muffled <- TRUE
[17:39:59.539]                             break
[17:39:59.539]                           }
[17:39:59.539]                         }
[17:39:59.539]                       }
[17:39:59.539]                       invisible(muffled)
[17:39:59.539]                     }
[17:39:59.539]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.539]                   }
[17:39:59.539]                 }
[17:39:59.539]                 else {
[17:39:59.539]                   if (TRUE) {
[17:39:59.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.539]                     {
[17:39:59.539]                       inherits <- base::inherits
[17:39:59.539]                       invokeRestart <- base::invokeRestart
[17:39:59.539]                       is.null <- base::is.null
[17:39:59.539]                       muffled <- FALSE
[17:39:59.539]                       if (inherits(cond, "message")) {
[17:39:59.539]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.539]                         if (muffled) 
[17:39:59.539]                           invokeRestart("muffleMessage")
[17:39:59.539]                       }
[17:39:59.539]                       else if (inherits(cond, "warning")) {
[17:39:59.539]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.539]                         if (muffled) 
[17:39:59.539]                           invokeRestart("muffleWarning")
[17:39:59.539]                       }
[17:39:59.539]                       else if (inherits(cond, "condition")) {
[17:39:59.539]                         if (!is.null(pattern)) {
[17:39:59.539]                           computeRestarts <- base::computeRestarts
[17:39:59.539]                           grepl <- base::grepl
[17:39:59.539]                           restarts <- computeRestarts(cond)
[17:39:59.539]                           for (restart in restarts) {
[17:39:59.539]                             name <- restart$name
[17:39:59.539]                             if (is.null(name)) 
[17:39:59.539]                               next
[17:39:59.539]                             if (!grepl(pattern, name)) 
[17:39:59.539]                               next
[17:39:59.539]                             invokeRestart(restart)
[17:39:59.539]                             muffled <- TRUE
[17:39:59.539]                             break
[17:39:59.539]                           }
[17:39:59.539]                         }
[17:39:59.539]                       }
[17:39:59.539]                       invisible(muffled)
[17:39:59.539]                     }
[17:39:59.539]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.539]                   }
[17:39:59.539]                 }
[17:39:59.539]             }
[17:39:59.539]         }))
[17:39:59.539]     }, error = function(ex) {
[17:39:59.539]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.539]                 ...future.rng), started = ...future.startTime, 
[17:39:59.539]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.539]             version = "1.8"), class = "FutureResult")
[17:39:59.539]     }, finally = {
[17:39:59.539]         if (!identical(...future.workdir, getwd())) 
[17:39:59.539]             setwd(...future.workdir)
[17:39:59.539]         {
[17:39:59.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.539]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.539]             }
[17:39:59.539]             base::options(...future.oldOptions)
[17:39:59.539]             if (.Platform$OS.type == "windows") {
[17:39:59.539]                 old_names <- names(...future.oldEnvVars)
[17:39:59.539]                 envs <- base::Sys.getenv()
[17:39:59.539]                 names <- names(envs)
[17:39:59.539]                 common <- intersect(names, old_names)
[17:39:59.539]                 added <- setdiff(names, old_names)
[17:39:59.539]                 removed <- setdiff(old_names, names)
[17:39:59.539]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.539]                   envs[common]]
[17:39:59.539]                 NAMES <- toupper(changed)
[17:39:59.539]                 args <- list()
[17:39:59.539]                 for (kk in seq_along(NAMES)) {
[17:39:59.539]                   name <- changed[[kk]]
[17:39:59.539]                   NAME <- NAMES[[kk]]
[17:39:59.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.539]                     next
[17:39:59.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.539]                 }
[17:39:59.539]                 NAMES <- toupper(added)
[17:39:59.539]                 for (kk in seq_along(NAMES)) {
[17:39:59.539]                   name <- added[[kk]]
[17:39:59.539]                   NAME <- NAMES[[kk]]
[17:39:59.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.539]                     next
[17:39:59.539]                   args[[name]] <- ""
[17:39:59.539]                 }
[17:39:59.539]                 NAMES <- toupper(removed)
[17:39:59.539]                 for (kk in seq_along(NAMES)) {
[17:39:59.539]                   name <- removed[[kk]]
[17:39:59.539]                   NAME <- NAMES[[kk]]
[17:39:59.539]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.539]                     next
[17:39:59.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.539]                 }
[17:39:59.539]                 if (length(args) > 0) 
[17:39:59.539]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.539]             }
[17:39:59.539]             else {
[17:39:59.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.539]             }
[17:39:59.539]             {
[17:39:59.539]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.539]                   0L) {
[17:39:59.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.539]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.539]                   base::options(opts)
[17:39:59.539]                 }
[17:39:59.539]                 {
[17:39:59.539]                   {
[17:39:59.539]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.539]                     NULL
[17:39:59.539]                   }
[17:39:59.539]                   options(future.plan = NULL)
[17:39:59.539]                   if (is.na(NA_character_)) 
[17:39:59.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.539]                     .init = FALSE)
[17:39:59.539]                 }
[17:39:59.539]             }
[17:39:59.539]         }
[17:39:59.539]     })
[17:39:59.539]     if (TRUE) {
[17:39:59.539]         base::sink(type = "output", split = FALSE)
[17:39:59.539]         if (TRUE) {
[17:39:59.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.539]         }
[17:39:59.539]         else {
[17:39:59.539]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.539]         }
[17:39:59.539]         base::close(...future.stdout)
[17:39:59.539]         ...future.stdout <- NULL
[17:39:59.539]     }
[17:39:59.539]     ...future.result$conditions <- ...future.conditions
[17:39:59.539]     ...future.result$finished <- base::Sys.time()
[17:39:59.539]     ...future.result
[17:39:59.539] }
[17:39:59.542] MultisessionFuture started
[17:39:59.542] - Launch lazy future ... done
[17:39:59.543] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.543] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.543] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.544] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:59.545] Searching for globals ... DONE
[17:39:59.545] Resolving globals: TRUE
[17:39:59.545] Resolving any globals that are futures ...
[17:39:59.545] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:59.545] Resolving any globals that are futures ... DONE
[17:39:59.545] Resolving futures part of globals (recursively) ...
[17:39:59.546] resolve() on list ...
[17:39:59.546]  recursive: 99
[17:39:59.546]  length: 1
[17:39:59.546]  elements: ‘a’
[17:39:59.546] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.546] - Validating connection of MultisessionFuture
[17:39:59.547] - received message: FutureResult
[17:39:59.547] - Received FutureResult
[17:39:59.547] - Erased future from FutureRegistry
[17:39:59.547] result() for ClusterFuture ...
[17:39:59.547] - result already collected: FutureResult
[17:39:59.547] result() for ClusterFuture ... done
[17:39:59.547] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.547] Future #1
[17:39:59.547] result() for ClusterFuture ...
[17:39:59.548] - result already collected: FutureResult
[17:39:59.548] result() for ClusterFuture ... done
[17:39:59.548] result() for ClusterFuture ...
[17:39:59.548] - result already collected: FutureResult
[17:39:59.548] result() for ClusterFuture ... done
[17:39:59.548] A MultisessionFuture was resolved
[17:39:59.548]  length: 0 (resolved future 1)
[17:39:59.548] resolve() on list ... DONE
[17:39:59.548] - globals: [1] ‘a’
[17:39:59.548] Resolving futures part of globals (recursively) ... DONE
[17:39:59.550] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[17:39:59.551] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:59.551] - globals: [1] ‘a’
[17:39:59.551] - packages: [1] ‘future’
[17:39:59.551] getGlobalsAndPackages() ... DONE
[17:39:59.551] run() for ‘Future’ ...
[17:39:59.551] - state: ‘created’
[17:39:59.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.565]   - Field: ‘node’
[17:39:59.566]   - Field: ‘label’
[17:39:59.566]   - Field: ‘local’
[17:39:59.566]   - Field: ‘owner’
[17:39:59.566]   - Field: ‘envir’
[17:39:59.566]   - Field: ‘workers’
[17:39:59.566]   - Field: ‘packages’
[17:39:59.566]   - Field: ‘gc’
[17:39:59.566]   - Field: ‘conditions’
[17:39:59.566]   - Field: ‘persistent’
[17:39:59.566]   - Field: ‘expr’
[17:39:59.566]   - Field: ‘uuid’
[17:39:59.567]   - Field: ‘seed’
[17:39:59.567]   - Field: ‘version’
[17:39:59.567]   - Field: ‘result’
[17:39:59.567]   - Field: ‘asynchronous’
[17:39:59.567]   - Field: ‘calls’
[17:39:59.567]   - Field: ‘globals’
[17:39:59.567]   - Field: ‘stdout’
[17:39:59.567]   - Field: ‘earlySignal’
[17:39:59.567]   - Field: ‘lazy’
[17:39:59.568]   - Field: ‘state’
[17:39:59.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.568] - Launch lazy future ...
[17:39:59.568] Packages needed by the future expression (n = 1): ‘future’
[17:39:59.569] Packages needed by future strategies (n = 0): <none>
[17:39:59.569] {
[17:39:59.569]     {
[17:39:59.569]         {
[17:39:59.569]             ...future.startTime <- base::Sys.time()
[17:39:59.569]             {
[17:39:59.569]                 {
[17:39:59.569]                   {
[17:39:59.569]                     {
[17:39:59.569]                       {
[17:39:59.569]                         base::local({
[17:39:59.569]                           has_future <- base::requireNamespace("future", 
[17:39:59.569]                             quietly = TRUE)
[17:39:59.569]                           if (has_future) {
[17:39:59.569]                             ns <- base::getNamespace("future")
[17:39:59.569]                             version <- ns[[".package"]][["version"]]
[17:39:59.569]                             if (is.null(version)) 
[17:39:59.569]                               version <- utils::packageVersion("future")
[17:39:59.569]                           }
[17:39:59.569]                           else {
[17:39:59.569]                             version <- NULL
[17:39:59.569]                           }
[17:39:59.569]                           if (!has_future || version < "1.8.0") {
[17:39:59.569]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.569]                               "", base::R.version$version.string), 
[17:39:59.569]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:59.569]                                 base::R.version$platform, 8 * 
[17:39:59.569]                                   base::.Machine$sizeof.pointer), 
[17:39:59.569]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.569]                                 "release", "version")], collapse = " "), 
[17:39:59.569]                               hostname = base::Sys.info()[["nodename"]])
[17:39:59.569]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.569]                               info)
[17:39:59.569]                             info <- base::paste(info, collapse = "; ")
[17:39:59.569]                             if (!has_future) {
[17:39:59.569]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.569]                                 info)
[17:39:59.569]                             }
[17:39:59.569]                             else {
[17:39:59.569]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.569]                                 info, version)
[17:39:59.569]                             }
[17:39:59.569]                             base::stop(msg)
[17:39:59.569]                           }
[17:39:59.569]                         })
[17:39:59.569]                       }
[17:39:59.569]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.569]                       base::options(mc.cores = 1L)
[17:39:59.569]                     }
[17:39:59.569]                     base::local({
[17:39:59.569]                       for (pkg in "future") {
[17:39:59.569]                         base::loadNamespace(pkg)
[17:39:59.569]                         base::library(pkg, character.only = TRUE)
[17:39:59.569]                       }
[17:39:59.569]                     })
[17:39:59.569]                   }
[17:39:59.569]                   ...future.strategy.old <- future::plan("list")
[17:39:59.569]                   options(future.plan = NULL)
[17:39:59.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.569]                 }
[17:39:59.569]                 ...future.workdir <- getwd()
[17:39:59.569]             }
[17:39:59.569]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.569]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.569]         }
[17:39:59.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.569]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.569]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.569]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.569]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.569]             base::names(...future.oldOptions))
[17:39:59.569]     }
[17:39:59.569]     if (FALSE) {
[17:39:59.569]     }
[17:39:59.569]     else {
[17:39:59.569]         if (TRUE) {
[17:39:59.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.569]                 open = "w")
[17:39:59.569]         }
[17:39:59.569]         else {
[17:39:59.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.569]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.569]         }
[17:39:59.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.569]             base::sink(type = "output", split = FALSE)
[17:39:59.569]             base::close(...future.stdout)
[17:39:59.569]         }, add = TRUE)
[17:39:59.569]     }
[17:39:59.569]     ...future.frame <- base::sys.nframe()
[17:39:59.569]     ...future.conditions <- base::list()
[17:39:59.569]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.569]     if (FALSE) {
[17:39:59.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.569]     }
[17:39:59.569]     ...future.result <- base::tryCatch({
[17:39:59.569]         base::withCallingHandlers({
[17:39:59.569]             ...future.value <- base::withVisible(base::local({
[17:39:59.569]                 ...future.makeSendCondition <- base::local({
[17:39:59.569]                   sendCondition <- NULL
[17:39:59.569]                   function(frame = 1L) {
[17:39:59.569]                     if (is.function(sendCondition)) 
[17:39:59.569]                       return(sendCondition)
[17:39:59.569]                     ns <- getNamespace("parallel")
[17:39:59.569]                     if (exists("sendData", mode = "function", 
[17:39:59.569]                       envir = ns)) {
[17:39:59.569]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.569]                         envir = ns)
[17:39:59.569]                       envir <- sys.frame(frame)
[17:39:59.569]                       master <- NULL
[17:39:59.569]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.569]                         !identical(envir, emptyenv())) {
[17:39:59.569]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.569]                           inherits = FALSE)) {
[17:39:59.569]                           master <- get("master", mode = "list", 
[17:39:59.569]                             envir = envir, inherits = FALSE)
[17:39:59.569]                           if (inherits(master, c("SOCKnode", 
[17:39:59.569]                             "SOCK0node"))) {
[17:39:59.569]                             sendCondition <<- function(cond) {
[17:39:59.569]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.569]                                 success = TRUE)
[17:39:59.569]                               parallel_sendData(master, data)
[17:39:59.569]                             }
[17:39:59.569]                             return(sendCondition)
[17:39:59.569]                           }
[17:39:59.569]                         }
[17:39:59.569]                         frame <- frame + 1L
[17:39:59.569]                         envir <- sys.frame(frame)
[17:39:59.569]                       }
[17:39:59.569]                     }
[17:39:59.569]                     sendCondition <<- function(cond) NULL
[17:39:59.569]                   }
[17:39:59.569]                 })
[17:39:59.569]                 withCallingHandlers({
[17:39:59.569]                   value(a) + 1
[17:39:59.569]                 }, immediateCondition = function(cond) {
[17:39:59.569]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.569]                   sendCondition(cond)
[17:39:59.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.569]                   {
[17:39:59.569]                     inherits <- base::inherits
[17:39:59.569]                     invokeRestart <- base::invokeRestart
[17:39:59.569]                     is.null <- base::is.null
[17:39:59.569]                     muffled <- FALSE
[17:39:59.569]                     if (inherits(cond, "message")) {
[17:39:59.569]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.569]                       if (muffled) 
[17:39:59.569]                         invokeRestart("muffleMessage")
[17:39:59.569]                     }
[17:39:59.569]                     else if (inherits(cond, "warning")) {
[17:39:59.569]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.569]                       if (muffled) 
[17:39:59.569]                         invokeRestart("muffleWarning")
[17:39:59.569]                     }
[17:39:59.569]                     else if (inherits(cond, "condition")) {
[17:39:59.569]                       if (!is.null(pattern)) {
[17:39:59.569]                         computeRestarts <- base::computeRestarts
[17:39:59.569]                         grepl <- base::grepl
[17:39:59.569]                         restarts <- computeRestarts(cond)
[17:39:59.569]                         for (restart in restarts) {
[17:39:59.569]                           name <- restart$name
[17:39:59.569]                           if (is.null(name)) 
[17:39:59.569]                             next
[17:39:59.569]                           if (!grepl(pattern, name)) 
[17:39:59.569]                             next
[17:39:59.569]                           invokeRestart(restart)
[17:39:59.569]                           muffled <- TRUE
[17:39:59.569]                           break
[17:39:59.569]                         }
[17:39:59.569]                       }
[17:39:59.569]                     }
[17:39:59.569]                     invisible(muffled)
[17:39:59.569]                   }
[17:39:59.569]                   muffleCondition(cond)
[17:39:59.569]                 })
[17:39:59.569]             }))
[17:39:59.569]             future::FutureResult(value = ...future.value$value, 
[17:39:59.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.569]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.569]                     ...future.globalenv.names))
[17:39:59.569]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.569]         }, condition = base::local({
[17:39:59.569]             c <- base::c
[17:39:59.569]             inherits <- base::inherits
[17:39:59.569]             invokeRestart <- base::invokeRestart
[17:39:59.569]             length <- base::length
[17:39:59.569]             list <- base::list
[17:39:59.569]             seq.int <- base::seq.int
[17:39:59.569]             signalCondition <- base::signalCondition
[17:39:59.569]             sys.calls <- base::sys.calls
[17:39:59.569]             `[[` <- base::`[[`
[17:39:59.569]             `+` <- base::`+`
[17:39:59.569]             `<<-` <- base::`<<-`
[17:39:59.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.569]                   3L)]
[17:39:59.569]             }
[17:39:59.569]             function(cond) {
[17:39:59.569]                 is_error <- inherits(cond, "error")
[17:39:59.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.569]                   NULL)
[17:39:59.569]                 if (is_error) {
[17:39:59.569]                   sessionInformation <- function() {
[17:39:59.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.569]                       search = base::search(), system = base::Sys.info())
[17:39:59.569]                   }
[17:39:59.569]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.569]                     cond$call), session = sessionInformation(), 
[17:39:59.569]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.569]                   signalCondition(cond)
[17:39:59.569]                 }
[17:39:59.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.569]                 "immediateCondition"))) {
[17:39:59.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.569]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.569]                   if (TRUE && !signal) {
[17:39:59.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.569]                     {
[17:39:59.569]                       inherits <- base::inherits
[17:39:59.569]                       invokeRestart <- base::invokeRestart
[17:39:59.569]                       is.null <- base::is.null
[17:39:59.569]                       muffled <- FALSE
[17:39:59.569]                       if (inherits(cond, "message")) {
[17:39:59.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.569]                         if (muffled) 
[17:39:59.569]                           invokeRestart("muffleMessage")
[17:39:59.569]                       }
[17:39:59.569]                       else if (inherits(cond, "warning")) {
[17:39:59.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.569]                         if (muffled) 
[17:39:59.569]                           invokeRestart("muffleWarning")
[17:39:59.569]                       }
[17:39:59.569]                       else if (inherits(cond, "condition")) {
[17:39:59.569]                         if (!is.null(pattern)) {
[17:39:59.569]                           computeRestarts <- base::computeRestarts
[17:39:59.569]                           grepl <- base::grepl
[17:39:59.569]                           restarts <- computeRestarts(cond)
[17:39:59.569]                           for (restart in restarts) {
[17:39:59.569]                             name <- restart$name
[17:39:59.569]                             if (is.null(name)) 
[17:39:59.569]                               next
[17:39:59.569]                             if (!grepl(pattern, name)) 
[17:39:59.569]                               next
[17:39:59.569]                             invokeRestart(restart)
[17:39:59.569]                             muffled <- TRUE
[17:39:59.569]                             break
[17:39:59.569]                           }
[17:39:59.569]                         }
[17:39:59.569]                       }
[17:39:59.569]                       invisible(muffled)
[17:39:59.569]                     }
[17:39:59.569]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.569]                   }
[17:39:59.569]                 }
[17:39:59.569]                 else {
[17:39:59.569]                   if (TRUE) {
[17:39:59.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.569]                     {
[17:39:59.569]                       inherits <- base::inherits
[17:39:59.569]                       invokeRestart <- base::invokeRestart
[17:39:59.569]                       is.null <- base::is.null
[17:39:59.569]                       muffled <- FALSE
[17:39:59.569]                       if (inherits(cond, "message")) {
[17:39:59.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.569]                         if (muffled) 
[17:39:59.569]                           invokeRestart("muffleMessage")
[17:39:59.569]                       }
[17:39:59.569]                       else if (inherits(cond, "warning")) {
[17:39:59.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.569]                         if (muffled) 
[17:39:59.569]                           invokeRestart("muffleWarning")
[17:39:59.569]                       }
[17:39:59.569]                       else if (inherits(cond, "condition")) {
[17:39:59.569]                         if (!is.null(pattern)) {
[17:39:59.569]                           computeRestarts <- base::computeRestarts
[17:39:59.569]                           grepl <- base::grepl
[17:39:59.569]                           restarts <- computeRestarts(cond)
[17:39:59.569]                           for (restart in restarts) {
[17:39:59.569]                             name <- restart$name
[17:39:59.569]                             if (is.null(name)) 
[17:39:59.569]                               next
[17:39:59.569]                             if (!grepl(pattern, name)) 
[17:39:59.569]                               next
[17:39:59.569]                             invokeRestart(restart)
[17:39:59.569]                             muffled <- TRUE
[17:39:59.569]                             break
[17:39:59.569]                           }
[17:39:59.569]                         }
[17:39:59.569]                       }
[17:39:59.569]                       invisible(muffled)
[17:39:59.569]                     }
[17:39:59.569]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.569]                   }
[17:39:59.569]                 }
[17:39:59.569]             }
[17:39:59.569]         }))
[17:39:59.569]     }, error = function(ex) {
[17:39:59.569]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.569]                 ...future.rng), started = ...future.startTime, 
[17:39:59.569]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.569]             version = "1.8"), class = "FutureResult")
[17:39:59.569]     }, finally = {
[17:39:59.569]         if (!identical(...future.workdir, getwd())) 
[17:39:59.569]             setwd(...future.workdir)
[17:39:59.569]         {
[17:39:59.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.569]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.569]             }
[17:39:59.569]             base::options(...future.oldOptions)
[17:39:59.569]             if (.Platform$OS.type == "windows") {
[17:39:59.569]                 old_names <- names(...future.oldEnvVars)
[17:39:59.569]                 envs <- base::Sys.getenv()
[17:39:59.569]                 names <- names(envs)
[17:39:59.569]                 common <- intersect(names, old_names)
[17:39:59.569]                 added <- setdiff(names, old_names)
[17:39:59.569]                 removed <- setdiff(old_names, names)
[17:39:59.569]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.569]                   envs[common]]
[17:39:59.569]                 NAMES <- toupper(changed)
[17:39:59.569]                 args <- list()
[17:39:59.569]                 for (kk in seq_along(NAMES)) {
[17:39:59.569]                   name <- changed[[kk]]
[17:39:59.569]                   NAME <- NAMES[[kk]]
[17:39:59.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.569]                     next
[17:39:59.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.569]                 }
[17:39:59.569]                 NAMES <- toupper(added)
[17:39:59.569]                 for (kk in seq_along(NAMES)) {
[17:39:59.569]                   name <- added[[kk]]
[17:39:59.569]                   NAME <- NAMES[[kk]]
[17:39:59.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.569]                     next
[17:39:59.569]                   args[[name]] <- ""
[17:39:59.569]                 }
[17:39:59.569]                 NAMES <- toupper(removed)
[17:39:59.569]                 for (kk in seq_along(NAMES)) {
[17:39:59.569]                   name <- removed[[kk]]
[17:39:59.569]                   NAME <- NAMES[[kk]]
[17:39:59.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.569]                     next
[17:39:59.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.569]                 }
[17:39:59.569]                 if (length(args) > 0) 
[17:39:59.569]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.569]             }
[17:39:59.569]             else {
[17:39:59.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.569]             }
[17:39:59.569]             {
[17:39:59.569]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.569]                   0L) {
[17:39:59.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.569]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.569]                   base::options(opts)
[17:39:59.569]                 }
[17:39:59.569]                 {
[17:39:59.569]                   {
[17:39:59.569]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.569]                     NULL
[17:39:59.569]                   }
[17:39:59.569]                   options(future.plan = NULL)
[17:39:59.569]                   if (is.na(NA_character_)) 
[17:39:59.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.569]                     .init = FALSE)
[17:39:59.569]                 }
[17:39:59.569]             }
[17:39:59.569]         }
[17:39:59.569]     })
[17:39:59.569]     if (TRUE) {
[17:39:59.569]         base::sink(type = "output", split = FALSE)
[17:39:59.569]         if (TRUE) {
[17:39:59.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.569]         }
[17:39:59.569]         else {
[17:39:59.569]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.569]         }
[17:39:59.569]         base::close(...future.stdout)
[17:39:59.569]         ...future.stdout <- NULL
[17:39:59.569]     }
[17:39:59.569]     ...future.result$conditions <- ...future.conditions
[17:39:59.569]     ...future.result$finished <- base::Sys.time()
[17:39:59.569]     ...future.result
[17:39:59.569] }
[17:39:59.574] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:39:59.577] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:39:59.629] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:39:59.629] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:39:59.630] MultisessionFuture started
[17:39:59.630] - Launch lazy future ... done
[17:39:59.630] run() for ‘MultisessionFuture’ ... done
[17:39:59.630] result() for ClusterFuture ...
[17:39:59.631] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.631] - Validating connection of MultisessionFuture
[17:39:59.679] - received message: FutureResult
[17:39:59.679] - Received FutureResult
[17:39:59.679] - Erased future from FutureRegistry
[17:39:59.679] result() for ClusterFuture ...
[17:39:59.679] - result already collected: FutureResult
[17:39:59.679] result() for ClusterFuture ... done
[17:39:59.679] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.679] result() for ClusterFuture ... done
[17:39:59.680] result() for ClusterFuture ...
[17:39:59.680] - result already collected: FutureResult
[17:39:59.680] result() for ClusterFuture ... done
value(b) = 2
[17:39:59.680] result() for ClusterFuture ...
[17:39:59.680] - result already collected: FutureResult
[17:39:59.680] result() for ClusterFuture ... done
[17:39:59.680] result() for ClusterFuture ...
[17:39:59.680] - result already collected: FutureResult
[17:39:59.680] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.681] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.681] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.681] 
[17:39:59.681] Searching for globals ... DONE
[17:39:59.681] - globals: [0] <none>
[17:39:59.682] getGlobalsAndPackages() ... DONE
[17:39:59.682] run() for ‘Future’ ...
[17:39:59.682] - state: ‘created’
[17:39:59.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.696]   - Field: ‘node’
[17:39:59.696]   - Field: ‘label’
[17:39:59.696]   - Field: ‘local’
[17:39:59.696]   - Field: ‘owner’
[17:39:59.696]   - Field: ‘envir’
[17:39:59.696]   - Field: ‘workers’
[17:39:59.697]   - Field: ‘packages’
[17:39:59.697]   - Field: ‘gc’
[17:39:59.697]   - Field: ‘conditions’
[17:39:59.697]   - Field: ‘persistent’
[17:39:59.697]   - Field: ‘expr’
[17:39:59.697]   - Field: ‘uuid’
[17:39:59.697]   - Field: ‘seed’
[17:39:59.697]   - Field: ‘version’
[17:39:59.697]   - Field: ‘result’
[17:39:59.697]   - Field: ‘asynchronous’
[17:39:59.697]   - Field: ‘calls’
[17:39:59.697]   - Field: ‘globals’
[17:39:59.698]   - Field: ‘stdout’
[17:39:59.698]   - Field: ‘earlySignal’
[17:39:59.698]   - Field: ‘lazy’
[17:39:59.698]   - Field: ‘state’
[17:39:59.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.698] - Launch lazy future ...
[17:39:59.698] Packages needed by the future expression (n = 0): <none>
[17:39:59.698] Packages needed by future strategies (n = 0): <none>
[17:39:59.699] {
[17:39:59.699]     {
[17:39:59.699]         {
[17:39:59.699]             ...future.startTime <- base::Sys.time()
[17:39:59.699]             {
[17:39:59.699]                 {
[17:39:59.699]                   {
[17:39:59.699]                     {
[17:39:59.699]                       base::local({
[17:39:59.699]                         has_future <- base::requireNamespace("future", 
[17:39:59.699]                           quietly = TRUE)
[17:39:59.699]                         if (has_future) {
[17:39:59.699]                           ns <- base::getNamespace("future")
[17:39:59.699]                           version <- ns[[".package"]][["version"]]
[17:39:59.699]                           if (is.null(version)) 
[17:39:59.699]                             version <- utils::packageVersion("future")
[17:39:59.699]                         }
[17:39:59.699]                         else {
[17:39:59.699]                           version <- NULL
[17:39:59.699]                         }
[17:39:59.699]                         if (!has_future || version < "1.8.0") {
[17:39:59.699]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.699]                             "", base::R.version$version.string), 
[17:39:59.699]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.699]                               "release", "version")], collapse = " "), 
[17:39:59.699]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.699]                             info)
[17:39:59.699]                           info <- base::paste(info, collapse = "; ")
[17:39:59.699]                           if (!has_future) {
[17:39:59.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.699]                               info)
[17:39:59.699]                           }
[17:39:59.699]                           else {
[17:39:59.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.699]                               info, version)
[17:39:59.699]                           }
[17:39:59.699]                           base::stop(msg)
[17:39:59.699]                         }
[17:39:59.699]                       })
[17:39:59.699]                     }
[17:39:59.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.699]                     base::options(mc.cores = 1L)
[17:39:59.699]                   }
[17:39:59.699]                   ...future.strategy.old <- future::plan("list")
[17:39:59.699]                   options(future.plan = NULL)
[17:39:59.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.699]                 }
[17:39:59.699]                 ...future.workdir <- getwd()
[17:39:59.699]             }
[17:39:59.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.699]         }
[17:39:59.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.699]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.699]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.699]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.699]             base::names(...future.oldOptions))
[17:39:59.699]     }
[17:39:59.699]     if (FALSE) {
[17:39:59.699]     }
[17:39:59.699]     else {
[17:39:59.699]         if (TRUE) {
[17:39:59.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.699]                 open = "w")
[17:39:59.699]         }
[17:39:59.699]         else {
[17:39:59.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.699]         }
[17:39:59.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.699]             base::sink(type = "output", split = FALSE)
[17:39:59.699]             base::close(...future.stdout)
[17:39:59.699]         }, add = TRUE)
[17:39:59.699]     }
[17:39:59.699]     ...future.frame <- base::sys.nframe()
[17:39:59.699]     ...future.conditions <- base::list()
[17:39:59.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.699]     if (FALSE) {
[17:39:59.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.699]     }
[17:39:59.699]     ...future.result <- base::tryCatch({
[17:39:59.699]         base::withCallingHandlers({
[17:39:59.699]             ...future.value <- base::withVisible(base::local({
[17:39:59.699]                 ...future.makeSendCondition <- base::local({
[17:39:59.699]                   sendCondition <- NULL
[17:39:59.699]                   function(frame = 1L) {
[17:39:59.699]                     if (is.function(sendCondition)) 
[17:39:59.699]                       return(sendCondition)
[17:39:59.699]                     ns <- getNamespace("parallel")
[17:39:59.699]                     if (exists("sendData", mode = "function", 
[17:39:59.699]                       envir = ns)) {
[17:39:59.699]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.699]                         envir = ns)
[17:39:59.699]                       envir <- sys.frame(frame)
[17:39:59.699]                       master <- NULL
[17:39:59.699]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.699]                         !identical(envir, emptyenv())) {
[17:39:59.699]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.699]                           inherits = FALSE)) {
[17:39:59.699]                           master <- get("master", mode = "list", 
[17:39:59.699]                             envir = envir, inherits = FALSE)
[17:39:59.699]                           if (inherits(master, c("SOCKnode", 
[17:39:59.699]                             "SOCK0node"))) {
[17:39:59.699]                             sendCondition <<- function(cond) {
[17:39:59.699]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.699]                                 success = TRUE)
[17:39:59.699]                               parallel_sendData(master, data)
[17:39:59.699]                             }
[17:39:59.699]                             return(sendCondition)
[17:39:59.699]                           }
[17:39:59.699]                         }
[17:39:59.699]                         frame <- frame + 1L
[17:39:59.699]                         envir <- sys.frame(frame)
[17:39:59.699]                       }
[17:39:59.699]                     }
[17:39:59.699]                     sendCondition <<- function(cond) NULL
[17:39:59.699]                   }
[17:39:59.699]                 })
[17:39:59.699]                 withCallingHandlers({
[17:39:59.699]                   1
[17:39:59.699]                 }, immediateCondition = function(cond) {
[17:39:59.699]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.699]                   sendCondition(cond)
[17:39:59.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.699]                   {
[17:39:59.699]                     inherits <- base::inherits
[17:39:59.699]                     invokeRestart <- base::invokeRestart
[17:39:59.699]                     is.null <- base::is.null
[17:39:59.699]                     muffled <- FALSE
[17:39:59.699]                     if (inherits(cond, "message")) {
[17:39:59.699]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.699]                       if (muffled) 
[17:39:59.699]                         invokeRestart("muffleMessage")
[17:39:59.699]                     }
[17:39:59.699]                     else if (inherits(cond, "warning")) {
[17:39:59.699]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.699]                       if (muffled) 
[17:39:59.699]                         invokeRestart("muffleWarning")
[17:39:59.699]                     }
[17:39:59.699]                     else if (inherits(cond, "condition")) {
[17:39:59.699]                       if (!is.null(pattern)) {
[17:39:59.699]                         computeRestarts <- base::computeRestarts
[17:39:59.699]                         grepl <- base::grepl
[17:39:59.699]                         restarts <- computeRestarts(cond)
[17:39:59.699]                         for (restart in restarts) {
[17:39:59.699]                           name <- restart$name
[17:39:59.699]                           if (is.null(name)) 
[17:39:59.699]                             next
[17:39:59.699]                           if (!grepl(pattern, name)) 
[17:39:59.699]                             next
[17:39:59.699]                           invokeRestart(restart)
[17:39:59.699]                           muffled <- TRUE
[17:39:59.699]                           break
[17:39:59.699]                         }
[17:39:59.699]                       }
[17:39:59.699]                     }
[17:39:59.699]                     invisible(muffled)
[17:39:59.699]                   }
[17:39:59.699]                   muffleCondition(cond)
[17:39:59.699]                 })
[17:39:59.699]             }))
[17:39:59.699]             future::FutureResult(value = ...future.value$value, 
[17:39:59.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.699]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.699]                     ...future.globalenv.names))
[17:39:59.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.699]         }, condition = base::local({
[17:39:59.699]             c <- base::c
[17:39:59.699]             inherits <- base::inherits
[17:39:59.699]             invokeRestart <- base::invokeRestart
[17:39:59.699]             length <- base::length
[17:39:59.699]             list <- base::list
[17:39:59.699]             seq.int <- base::seq.int
[17:39:59.699]             signalCondition <- base::signalCondition
[17:39:59.699]             sys.calls <- base::sys.calls
[17:39:59.699]             `[[` <- base::`[[`
[17:39:59.699]             `+` <- base::`+`
[17:39:59.699]             `<<-` <- base::`<<-`
[17:39:59.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.699]                   3L)]
[17:39:59.699]             }
[17:39:59.699]             function(cond) {
[17:39:59.699]                 is_error <- inherits(cond, "error")
[17:39:59.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.699]                   NULL)
[17:39:59.699]                 if (is_error) {
[17:39:59.699]                   sessionInformation <- function() {
[17:39:59.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.699]                       search = base::search(), system = base::Sys.info())
[17:39:59.699]                   }
[17:39:59.699]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.699]                     cond$call), session = sessionInformation(), 
[17:39:59.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.699]                   signalCondition(cond)
[17:39:59.699]                 }
[17:39:59.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.699]                 "immediateCondition"))) {
[17:39:59.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.699]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.699]                   if (TRUE && !signal) {
[17:39:59.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.699]                     {
[17:39:59.699]                       inherits <- base::inherits
[17:39:59.699]                       invokeRestart <- base::invokeRestart
[17:39:59.699]                       is.null <- base::is.null
[17:39:59.699]                       muffled <- FALSE
[17:39:59.699]                       if (inherits(cond, "message")) {
[17:39:59.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.699]                         if (muffled) 
[17:39:59.699]                           invokeRestart("muffleMessage")
[17:39:59.699]                       }
[17:39:59.699]                       else if (inherits(cond, "warning")) {
[17:39:59.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.699]                         if (muffled) 
[17:39:59.699]                           invokeRestart("muffleWarning")
[17:39:59.699]                       }
[17:39:59.699]                       else if (inherits(cond, "condition")) {
[17:39:59.699]                         if (!is.null(pattern)) {
[17:39:59.699]                           computeRestarts <- base::computeRestarts
[17:39:59.699]                           grepl <- base::grepl
[17:39:59.699]                           restarts <- computeRestarts(cond)
[17:39:59.699]                           for (restart in restarts) {
[17:39:59.699]                             name <- restart$name
[17:39:59.699]                             if (is.null(name)) 
[17:39:59.699]                               next
[17:39:59.699]                             if (!grepl(pattern, name)) 
[17:39:59.699]                               next
[17:39:59.699]                             invokeRestart(restart)
[17:39:59.699]                             muffled <- TRUE
[17:39:59.699]                             break
[17:39:59.699]                           }
[17:39:59.699]                         }
[17:39:59.699]                       }
[17:39:59.699]                       invisible(muffled)
[17:39:59.699]                     }
[17:39:59.699]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.699]                   }
[17:39:59.699]                 }
[17:39:59.699]                 else {
[17:39:59.699]                   if (TRUE) {
[17:39:59.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.699]                     {
[17:39:59.699]                       inherits <- base::inherits
[17:39:59.699]                       invokeRestart <- base::invokeRestart
[17:39:59.699]                       is.null <- base::is.null
[17:39:59.699]                       muffled <- FALSE
[17:39:59.699]                       if (inherits(cond, "message")) {
[17:39:59.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.699]                         if (muffled) 
[17:39:59.699]                           invokeRestart("muffleMessage")
[17:39:59.699]                       }
[17:39:59.699]                       else if (inherits(cond, "warning")) {
[17:39:59.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.699]                         if (muffled) 
[17:39:59.699]                           invokeRestart("muffleWarning")
[17:39:59.699]                       }
[17:39:59.699]                       else if (inherits(cond, "condition")) {
[17:39:59.699]                         if (!is.null(pattern)) {
[17:39:59.699]                           computeRestarts <- base::computeRestarts
[17:39:59.699]                           grepl <- base::grepl
[17:39:59.699]                           restarts <- computeRestarts(cond)
[17:39:59.699]                           for (restart in restarts) {
[17:39:59.699]                             name <- restart$name
[17:39:59.699]                             if (is.null(name)) 
[17:39:59.699]                               next
[17:39:59.699]                             if (!grepl(pattern, name)) 
[17:39:59.699]                               next
[17:39:59.699]                             invokeRestart(restart)
[17:39:59.699]                             muffled <- TRUE
[17:39:59.699]                             break
[17:39:59.699]                           }
[17:39:59.699]                         }
[17:39:59.699]                       }
[17:39:59.699]                       invisible(muffled)
[17:39:59.699]                     }
[17:39:59.699]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.699]                   }
[17:39:59.699]                 }
[17:39:59.699]             }
[17:39:59.699]         }))
[17:39:59.699]     }, error = function(ex) {
[17:39:59.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.699]                 ...future.rng), started = ...future.startTime, 
[17:39:59.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.699]             version = "1.8"), class = "FutureResult")
[17:39:59.699]     }, finally = {
[17:39:59.699]         if (!identical(...future.workdir, getwd())) 
[17:39:59.699]             setwd(...future.workdir)
[17:39:59.699]         {
[17:39:59.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.699]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.699]             }
[17:39:59.699]             base::options(...future.oldOptions)
[17:39:59.699]             if (.Platform$OS.type == "windows") {
[17:39:59.699]                 old_names <- names(...future.oldEnvVars)
[17:39:59.699]                 envs <- base::Sys.getenv()
[17:39:59.699]                 names <- names(envs)
[17:39:59.699]                 common <- intersect(names, old_names)
[17:39:59.699]                 added <- setdiff(names, old_names)
[17:39:59.699]                 removed <- setdiff(old_names, names)
[17:39:59.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.699]                   envs[common]]
[17:39:59.699]                 NAMES <- toupper(changed)
[17:39:59.699]                 args <- list()
[17:39:59.699]                 for (kk in seq_along(NAMES)) {
[17:39:59.699]                   name <- changed[[kk]]
[17:39:59.699]                   NAME <- NAMES[[kk]]
[17:39:59.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.699]                     next
[17:39:59.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.699]                 }
[17:39:59.699]                 NAMES <- toupper(added)
[17:39:59.699]                 for (kk in seq_along(NAMES)) {
[17:39:59.699]                   name <- added[[kk]]
[17:39:59.699]                   NAME <- NAMES[[kk]]
[17:39:59.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.699]                     next
[17:39:59.699]                   args[[name]] <- ""
[17:39:59.699]                 }
[17:39:59.699]                 NAMES <- toupper(removed)
[17:39:59.699]                 for (kk in seq_along(NAMES)) {
[17:39:59.699]                   name <- removed[[kk]]
[17:39:59.699]                   NAME <- NAMES[[kk]]
[17:39:59.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.699]                     next
[17:39:59.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.699]                 }
[17:39:59.699]                 if (length(args) > 0) 
[17:39:59.699]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.699]             }
[17:39:59.699]             else {
[17:39:59.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.699]             }
[17:39:59.699]             {
[17:39:59.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.699]                   0L) {
[17:39:59.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.699]                   base::options(opts)
[17:39:59.699]                 }
[17:39:59.699]                 {
[17:39:59.699]                   {
[17:39:59.699]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.699]                     NULL
[17:39:59.699]                   }
[17:39:59.699]                   options(future.plan = NULL)
[17:39:59.699]                   if (is.na(NA_character_)) 
[17:39:59.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.699]                     .init = FALSE)
[17:39:59.699]                 }
[17:39:59.699]             }
[17:39:59.699]         }
[17:39:59.699]     })
[17:39:59.699]     if (TRUE) {
[17:39:59.699]         base::sink(type = "output", split = FALSE)
[17:39:59.699]         if (TRUE) {
[17:39:59.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.699]         }
[17:39:59.699]         else {
[17:39:59.699]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.699]         }
[17:39:59.699]         base::close(...future.stdout)
[17:39:59.699]         ...future.stdout <- NULL
[17:39:59.699]     }
[17:39:59.699]     ...future.result$conditions <- ...future.conditions
[17:39:59.699]     ...future.result$finished <- base::Sys.time()
[17:39:59.699]     ...future.result
[17:39:59.699] }
[17:39:59.702] MultisessionFuture started
[17:39:59.702] - Launch lazy future ... done
[17:39:59.702] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.702] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.702] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.703] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:59.703] Searching for globals ... DONE
[17:39:59.703] Resolving globals: TRUE
[17:39:59.703] Resolving any globals that are futures ...
[17:39:59.704] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:59.704] Resolving any globals that are futures ... DONE
[17:39:59.704] Resolving futures part of globals (recursively) ...
[17:39:59.704] resolve() on list ...
[17:39:59.704]  recursive: 99
[17:39:59.704]  length: 1
[17:39:59.705]  elements: ‘a’
[17:39:59.747] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.747] - Validating connection of MultisessionFuture
[17:39:59.747] - received message: FutureResult
[17:39:59.747] - Received FutureResult
[17:39:59.748] - Erased future from FutureRegistry
[17:39:59.748] result() for ClusterFuture ...
[17:39:59.748] - result already collected: FutureResult
[17:39:59.748] result() for ClusterFuture ... done
[17:39:59.748] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.748] Future #1
[17:39:59.748] result() for ClusterFuture ...
[17:39:59.748] - result already collected: FutureResult
[17:39:59.748] result() for ClusterFuture ... done
[17:39:59.748] result() for ClusterFuture ...
[17:39:59.749] - result already collected: FutureResult
[17:39:59.749] result() for ClusterFuture ... done
[17:39:59.749] A MultisessionFuture was resolved
[17:39:59.749]  length: 0 (resolved future 1)
[17:39:59.749] resolve() on list ... DONE
[17:39:59.749] - globals: [1] ‘a’
[17:39:59.749] Resolving futures part of globals (recursively) ... DONE
[17:39:59.751] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[17:39:59.752] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:59.752] - globals: [1] ‘a’
[17:39:59.752] - packages: [1] ‘future’
[17:39:59.752] getGlobalsAndPackages() ... DONE
[17:39:59.752] run() for ‘Future’ ...
[17:39:59.753] - state: ‘created’
[17:39:59.753] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.768] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.768]   - Field: ‘node’
[17:39:59.768]   - Field: ‘label’
[17:39:59.768]   - Field: ‘local’
[17:39:59.769]   - Field: ‘owner’
[17:39:59.769]   - Field: ‘envir’
[17:39:59.769]   - Field: ‘workers’
[17:39:59.769]   - Field: ‘packages’
[17:39:59.769]   - Field: ‘gc’
[17:39:59.769]   - Field: ‘conditions’
[17:39:59.769]   - Field: ‘persistent’
[17:39:59.769]   - Field: ‘expr’
[17:39:59.769]   - Field: ‘uuid’
[17:39:59.769]   - Field: ‘seed’
[17:39:59.769]   - Field: ‘version’
[17:39:59.770]   - Field: ‘result’
[17:39:59.772]   - Field: ‘asynchronous’
[17:39:59.773]   - Field: ‘calls’
[17:39:59.773]   - Field: ‘globals’
[17:39:59.773]   - Field: ‘stdout’
[17:39:59.773]   - Field: ‘earlySignal’
[17:39:59.773]   - Field: ‘lazy’
[17:39:59.773]   - Field: ‘state’
[17:39:59.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.773] - Launch lazy future ...
[17:39:59.774] Packages needed by the future expression (n = 1): ‘future’
[17:39:59.774] Packages needed by future strategies (n = 0): <none>
[17:39:59.774] {
[17:39:59.774]     {
[17:39:59.774]         {
[17:39:59.774]             ...future.startTime <- base::Sys.time()
[17:39:59.774]             {
[17:39:59.774]                 {
[17:39:59.774]                   {
[17:39:59.774]                     {
[17:39:59.774]                       {
[17:39:59.774]                         base::local({
[17:39:59.774]                           has_future <- base::requireNamespace("future", 
[17:39:59.774]                             quietly = TRUE)
[17:39:59.774]                           if (has_future) {
[17:39:59.774]                             ns <- base::getNamespace("future")
[17:39:59.774]                             version <- ns[[".package"]][["version"]]
[17:39:59.774]                             if (is.null(version)) 
[17:39:59.774]                               version <- utils::packageVersion("future")
[17:39:59.774]                           }
[17:39:59.774]                           else {
[17:39:59.774]                             version <- NULL
[17:39:59.774]                           }
[17:39:59.774]                           if (!has_future || version < "1.8.0") {
[17:39:59.774]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.774]                               "", base::R.version$version.string), 
[17:39:59.774]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:59.774]                                 base::R.version$platform, 8 * 
[17:39:59.774]                                   base::.Machine$sizeof.pointer), 
[17:39:59.774]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.774]                                 "release", "version")], collapse = " "), 
[17:39:59.774]                               hostname = base::Sys.info()[["nodename"]])
[17:39:59.774]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.774]                               info)
[17:39:59.774]                             info <- base::paste(info, collapse = "; ")
[17:39:59.774]                             if (!has_future) {
[17:39:59.774]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.774]                                 info)
[17:39:59.774]                             }
[17:39:59.774]                             else {
[17:39:59.774]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.774]                                 info, version)
[17:39:59.774]                             }
[17:39:59.774]                             base::stop(msg)
[17:39:59.774]                           }
[17:39:59.774]                         })
[17:39:59.774]                       }
[17:39:59.774]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.774]                       base::options(mc.cores = 1L)
[17:39:59.774]                     }
[17:39:59.774]                     base::local({
[17:39:59.774]                       for (pkg in "future") {
[17:39:59.774]                         base::loadNamespace(pkg)
[17:39:59.774]                         base::library(pkg, character.only = TRUE)
[17:39:59.774]                       }
[17:39:59.774]                     })
[17:39:59.774]                   }
[17:39:59.774]                   ...future.strategy.old <- future::plan("list")
[17:39:59.774]                   options(future.plan = NULL)
[17:39:59.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.774]                 }
[17:39:59.774]                 ...future.workdir <- getwd()
[17:39:59.774]             }
[17:39:59.774]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.774]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.774]         }
[17:39:59.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.774]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.774]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.774]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.774]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.774]             base::names(...future.oldOptions))
[17:39:59.774]     }
[17:39:59.774]     if (FALSE) {
[17:39:59.774]     }
[17:39:59.774]     else {
[17:39:59.774]         if (TRUE) {
[17:39:59.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.774]                 open = "w")
[17:39:59.774]         }
[17:39:59.774]         else {
[17:39:59.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.774]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.774]         }
[17:39:59.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.774]             base::sink(type = "output", split = FALSE)
[17:39:59.774]             base::close(...future.stdout)
[17:39:59.774]         }, add = TRUE)
[17:39:59.774]     }
[17:39:59.774]     ...future.frame <- base::sys.nframe()
[17:39:59.774]     ...future.conditions <- base::list()
[17:39:59.774]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.774]     if (FALSE) {
[17:39:59.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.774]     }
[17:39:59.774]     ...future.result <- base::tryCatch({
[17:39:59.774]         base::withCallingHandlers({
[17:39:59.774]             ...future.value <- base::withVisible(base::local({
[17:39:59.774]                 ...future.makeSendCondition <- base::local({
[17:39:59.774]                   sendCondition <- NULL
[17:39:59.774]                   function(frame = 1L) {
[17:39:59.774]                     if (is.function(sendCondition)) 
[17:39:59.774]                       return(sendCondition)
[17:39:59.774]                     ns <- getNamespace("parallel")
[17:39:59.774]                     if (exists("sendData", mode = "function", 
[17:39:59.774]                       envir = ns)) {
[17:39:59.774]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.774]                         envir = ns)
[17:39:59.774]                       envir <- sys.frame(frame)
[17:39:59.774]                       master <- NULL
[17:39:59.774]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.774]                         !identical(envir, emptyenv())) {
[17:39:59.774]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.774]                           inherits = FALSE)) {
[17:39:59.774]                           master <- get("master", mode = "list", 
[17:39:59.774]                             envir = envir, inherits = FALSE)
[17:39:59.774]                           if (inherits(master, c("SOCKnode", 
[17:39:59.774]                             "SOCK0node"))) {
[17:39:59.774]                             sendCondition <<- function(cond) {
[17:39:59.774]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.774]                                 success = TRUE)
[17:39:59.774]                               parallel_sendData(master, data)
[17:39:59.774]                             }
[17:39:59.774]                             return(sendCondition)
[17:39:59.774]                           }
[17:39:59.774]                         }
[17:39:59.774]                         frame <- frame + 1L
[17:39:59.774]                         envir <- sys.frame(frame)
[17:39:59.774]                       }
[17:39:59.774]                     }
[17:39:59.774]                     sendCondition <<- function(cond) NULL
[17:39:59.774]                   }
[17:39:59.774]                 })
[17:39:59.774]                 withCallingHandlers({
[17:39:59.774]                   value(a) + 1
[17:39:59.774]                 }, immediateCondition = function(cond) {
[17:39:59.774]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.774]                   sendCondition(cond)
[17:39:59.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.774]                   {
[17:39:59.774]                     inherits <- base::inherits
[17:39:59.774]                     invokeRestart <- base::invokeRestart
[17:39:59.774]                     is.null <- base::is.null
[17:39:59.774]                     muffled <- FALSE
[17:39:59.774]                     if (inherits(cond, "message")) {
[17:39:59.774]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.774]                       if (muffled) 
[17:39:59.774]                         invokeRestart("muffleMessage")
[17:39:59.774]                     }
[17:39:59.774]                     else if (inherits(cond, "warning")) {
[17:39:59.774]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.774]                       if (muffled) 
[17:39:59.774]                         invokeRestart("muffleWarning")
[17:39:59.774]                     }
[17:39:59.774]                     else if (inherits(cond, "condition")) {
[17:39:59.774]                       if (!is.null(pattern)) {
[17:39:59.774]                         computeRestarts <- base::computeRestarts
[17:39:59.774]                         grepl <- base::grepl
[17:39:59.774]                         restarts <- computeRestarts(cond)
[17:39:59.774]                         for (restart in restarts) {
[17:39:59.774]                           name <- restart$name
[17:39:59.774]                           if (is.null(name)) 
[17:39:59.774]                             next
[17:39:59.774]                           if (!grepl(pattern, name)) 
[17:39:59.774]                             next
[17:39:59.774]                           invokeRestart(restart)
[17:39:59.774]                           muffled <- TRUE
[17:39:59.774]                           break
[17:39:59.774]                         }
[17:39:59.774]                       }
[17:39:59.774]                     }
[17:39:59.774]                     invisible(muffled)
[17:39:59.774]                   }
[17:39:59.774]                   muffleCondition(cond)
[17:39:59.774]                 })
[17:39:59.774]             }))
[17:39:59.774]             future::FutureResult(value = ...future.value$value, 
[17:39:59.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.774]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.774]                     ...future.globalenv.names))
[17:39:59.774]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.774]         }, condition = base::local({
[17:39:59.774]             c <- base::c
[17:39:59.774]             inherits <- base::inherits
[17:39:59.774]             invokeRestart <- base::invokeRestart
[17:39:59.774]             length <- base::length
[17:39:59.774]             list <- base::list
[17:39:59.774]             seq.int <- base::seq.int
[17:39:59.774]             signalCondition <- base::signalCondition
[17:39:59.774]             sys.calls <- base::sys.calls
[17:39:59.774]             `[[` <- base::`[[`
[17:39:59.774]             `+` <- base::`+`
[17:39:59.774]             `<<-` <- base::`<<-`
[17:39:59.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.774]                   3L)]
[17:39:59.774]             }
[17:39:59.774]             function(cond) {
[17:39:59.774]                 is_error <- inherits(cond, "error")
[17:39:59.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.774]                   NULL)
[17:39:59.774]                 if (is_error) {
[17:39:59.774]                   sessionInformation <- function() {
[17:39:59.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.774]                       search = base::search(), system = base::Sys.info())
[17:39:59.774]                   }
[17:39:59.774]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.774]                     cond$call), session = sessionInformation(), 
[17:39:59.774]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.774]                   signalCondition(cond)
[17:39:59.774]                 }
[17:39:59.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.774]                 "immediateCondition"))) {
[17:39:59.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.774]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.774]                   if (TRUE && !signal) {
[17:39:59.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.774]                     {
[17:39:59.774]                       inherits <- base::inherits
[17:39:59.774]                       invokeRestart <- base::invokeRestart
[17:39:59.774]                       is.null <- base::is.null
[17:39:59.774]                       muffled <- FALSE
[17:39:59.774]                       if (inherits(cond, "message")) {
[17:39:59.774]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.774]                         if (muffled) 
[17:39:59.774]                           invokeRestart("muffleMessage")
[17:39:59.774]                       }
[17:39:59.774]                       else if (inherits(cond, "warning")) {
[17:39:59.774]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.774]                         if (muffled) 
[17:39:59.774]                           invokeRestart("muffleWarning")
[17:39:59.774]                       }
[17:39:59.774]                       else if (inherits(cond, "condition")) {
[17:39:59.774]                         if (!is.null(pattern)) {
[17:39:59.774]                           computeRestarts <- base::computeRestarts
[17:39:59.774]                           grepl <- base::grepl
[17:39:59.774]                           restarts <- computeRestarts(cond)
[17:39:59.774]                           for (restart in restarts) {
[17:39:59.774]                             name <- restart$name
[17:39:59.774]                             if (is.null(name)) 
[17:39:59.774]                               next
[17:39:59.774]                             if (!grepl(pattern, name)) 
[17:39:59.774]                               next
[17:39:59.774]                             invokeRestart(restart)
[17:39:59.774]                             muffled <- TRUE
[17:39:59.774]                             break
[17:39:59.774]                           }
[17:39:59.774]                         }
[17:39:59.774]                       }
[17:39:59.774]                       invisible(muffled)
[17:39:59.774]                     }
[17:39:59.774]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.774]                   }
[17:39:59.774]                 }
[17:39:59.774]                 else {
[17:39:59.774]                   if (TRUE) {
[17:39:59.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.774]                     {
[17:39:59.774]                       inherits <- base::inherits
[17:39:59.774]                       invokeRestart <- base::invokeRestart
[17:39:59.774]                       is.null <- base::is.null
[17:39:59.774]                       muffled <- FALSE
[17:39:59.774]                       if (inherits(cond, "message")) {
[17:39:59.774]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.774]                         if (muffled) 
[17:39:59.774]                           invokeRestart("muffleMessage")
[17:39:59.774]                       }
[17:39:59.774]                       else if (inherits(cond, "warning")) {
[17:39:59.774]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.774]                         if (muffled) 
[17:39:59.774]                           invokeRestart("muffleWarning")
[17:39:59.774]                       }
[17:39:59.774]                       else if (inherits(cond, "condition")) {
[17:39:59.774]                         if (!is.null(pattern)) {
[17:39:59.774]                           computeRestarts <- base::computeRestarts
[17:39:59.774]                           grepl <- base::grepl
[17:39:59.774]                           restarts <- computeRestarts(cond)
[17:39:59.774]                           for (restart in restarts) {
[17:39:59.774]                             name <- restart$name
[17:39:59.774]                             if (is.null(name)) 
[17:39:59.774]                               next
[17:39:59.774]                             if (!grepl(pattern, name)) 
[17:39:59.774]                               next
[17:39:59.774]                             invokeRestart(restart)
[17:39:59.774]                             muffled <- TRUE
[17:39:59.774]                             break
[17:39:59.774]                           }
[17:39:59.774]                         }
[17:39:59.774]                       }
[17:39:59.774]                       invisible(muffled)
[17:39:59.774]                     }
[17:39:59.774]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.774]                   }
[17:39:59.774]                 }
[17:39:59.774]             }
[17:39:59.774]         }))
[17:39:59.774]     }, error = function(ex) {
[17:39:59.774]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.774]                 ...future.rng), started = ...future.startTime, 
[17:39:59.774]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.774]             version = "1.8"), class = "FutureResult")
[17:39:59.774]     }, finally = {
[17:39:59.774]         if (!identical(...future.workdir, getwd())) 
[17:39:59.774]             setwd(...future.workdir)
[17:39:59.774]         {
[17:39:59.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.774]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.774]             }
[17:39:59.774]             base::options(...future.oldOptions)
[17:39:59.774]             if (.Platform$OS.type == "windows") {
[17:39:59.774]                 old_names <- names(...future.oldEnvVars)
[17:39:59.774]                 envs <- base::Sys.getenv()
[17:39:59.774]                 names <- names(envs)
[17:39:59.774]                 common <- intersect(names, old_names)
[17:39:59.774]                 added <- setdiff(names, old_names)
[17:39:59.774]                 removed <- setdiff(old_names, names)
[17:39:59.774]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.774]                   envs[common]]
[17:39:59.774]                 NAMES <- toupper(changed)
[17:39:59.774]                 args <- list()
[17:39:59.774]                 for (kk in seq_along(NAMES)) {
[17:39:59.774]                   name <- changed[[kk]]
[17:39:59.774]                   NAME <- NAMES[[kk]]
[17:39:59.774]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.774]                     next
[17:39:59.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.774]                 }
[17:39:59.774]                 NAMES <- toupper(added)
[17:39:59.774]                 for (kk in seq_along(NAMES)) {
[17:39:59.774]                   name <- added[[kk]]
[17:39:59.774]                   NAME <- NAMES[[kk]]
[17:39:59.774]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.774]                     next
[17:39:59.774]                   args[[name]] <- ""
[17:39:59.774]                 }
[17:39:59.774]                 NAMES <- toupper(removed)
[17:39:59.774]                 for (kk in seq_along(NAMES)) {
[17:39:59.774]                   name <- removed[[kk]]
[17:39:59.774]                   NAME <- NAMES[[kk]]
[17:39:59.774]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.774]                     next
[17:39:59.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.774]                 }
[17:39:59.774]                 if (length(args) > 0) 
[17:39:59.774]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.774]             }
[17:39:59.774]             else {
[17:39:59.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.774]             }
[17:39:59.774]             {
[17:39:59.774]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.774]                   0L) {
[17:39:59.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.774]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.774]                   base::options(opts)
[17:39:59.774]                 }
[17:39:59.774]                 {
[17:39:59.774]                   {
[17:39:59.774]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.774]                     NULL
[17:39:59.774]                   }
[17:39:59.774]                   options(future.plan = NULL)
[17:39:59.774]                   if (is.na(NA_character_)) 
[17:39:59.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.774]                     .init = FALSE)
[17:39:59.774]                 }
[17:39:59.774]             }
[17:39:59.774]         }
[17:39:59.774]     })
[17:39:59.774]     if (TRUE) {
[17:39:59.774]         base::sink(type = "output", split = FALSE)
[17:39:59.774]         if (TRUE) {
[17:39:59.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.774]         }
[17:39:59.774]         else {
[17:39:59.774]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.774]         }
[17:39:59.774]         base::close(...future.stdout)
[17:39:59.774]         ...future.stdout <- NULL
[17:39:59.774]     }
[17:39:59.774]     ...future.result$conditions <- ...future.conditions
[17:39:59.774]     ...future.result$finished <- base::Sys.time()
[17:39:59.774]     ...future.result
[17:39:59.774] }
[17:39:59.777] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:39:59.779] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:39:59.833] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:39:59.833] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:39:59.833] MultisessionFuture started
[17:39:59.833] - Launch lazy future ... done
[17:39:59.834] run() for ‘MultisessionFuture’ ... done
[17:39:59.834] result() for ClusterFuture ...
[17:39:59.834] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.834] - Validating connection of MultisessionFuture
[17:39:59.878] - received message: FutureResult
[17:39:59.879] - Received FutureResult
[17:39:59.879] - Erased future from FutureRegistry
[17:39:59.879] result() for ClusterFuture ...
[17:39:59.879] - result already collected: FutureResult
[17:39:59.879] result() for ClusterFuture ... done
[17:39:59.879] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.879] result() for ClusterFuture ... done
[17:39:59.879] result() for ClusterFuture ...
[17:39:59.879] - result already collected: FutureResult
[17:39:59.879] result() for ClusterFuture ... done
value(b) = 2
[17:39:59.880] result() for ClusterFuture ...
[17:39:59.880] - result already collected: FutureResult
[17:39:59.880] result() for ClusterFuture ... done
[17:39:59.880] result() for ClusterFuture ...
[17:39:59.880] - result already collected: FutureResult
[17:39:59.880] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.880] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.881] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.881] 
[17:39:59.881] Searching for globals ... DONE
[17:39:59.881] - globals: [0] <none>
[17:39:59.881] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:39:59.882] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:39:59.882] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:39:59.882] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:39:59.883] Searching for globals ... DONE
[17:39:59.883] Resolving globals: TRUE
[17:39:59.883] Resolving any globals that are futures ...
[17:39:59.883] - globals: [3] ‘+’, ‘value’, ‘a’
[17:39:59.883] Resolving any globals that are futures ... DONE
[17:39:59.883] Resolving futures part of globals (recursively) ...
[17:39:59.884] resolve() on list ...
[17:39:59.884]  recursive: 99
[17:39:59.884]  length: 1
[17:39:59.884]  elements: ‘a’
[17:39:59.884] run() for ‘Future’ ...
[17:39:59.884] - state: ‘created’
[17:39:59.884] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.898] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.898]   - Field: ‘node’
[17:39:59.898]   - Field: ‘label’
[17:39:59.898]   - Field: ‘local’
[17:39:59.898]   - Field: ‘owner’
[17:39:59.899]   - Field: ‘envir’
[17:39:59.899]   - Field: ‘workers’
[17:39:59.899]   - Field: ‘packages’
[17:39:59.899]   - Field: ‘gc’
[17:39:59.899]   - Field: ‘conditions’
[17:39:59.899]   - Field: ‘persistent’
[17:39:59.899]   - Field: ‘expr’
[17:39:59.899]   - Field: ‘uuid’
[17:39:59.899]   - Field: ‘seed’
[17:39:59.899]   - Field: ‘version’
[17:39:59.899]   - Field: ‘result’
[17:39:59.899]   - Field: ‘asynchronous’
[17:39:59.900]   - Field: ‘calls’
[17:39:59.900]   - Field: ‘globals’
[17:39:59.900]   - Field: ‘stdout’
[17:39:59.900]   - Field: ‘earlySignal’
[17:39:59.900]   - Field: ‘lazy’
[17:39:59.900]   - Field: ‘state’
[17:39:59.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.900] - Launch lazy future ...
[17:39:59.900] Packages needed by the future expression (n = 0): <none>
[17:39:59.901] Packages needed by future strategies (n = 0): <none>
[17:39:59.901] {
[17:39:59.901]     {
[17:39:59.901]         {
[17:39:59.901]             ...future.startTime <- base::Sys.time()
[17:39:59.901]             {
[17:39:59.901]                 {
[17:39:59.901]                   {
[17:39:59.901]                     {
[17:39:59.901]                       base::local({
[17:39:59.901]                         has_future <- base::requireNamespace("future", 
[17:39:59.901]                           quietly = TRUE)
[17:39:59.901]                         if (has_future) {
[17:39:59.901]                           ns <- base::getNamespace("future")
[17:39:59.901]                           version <- ns[[".package"]][["version"]]
[17:39:59.901]                           if (is.null(version)) 
[17:39:59.901]                             version <- utils::packageVersion("future")
[17:39:59.901]                         }
[17:39:59.901]                         else {
[17:39:59.901]                           version <- NULL
[17:39:59.901]                         }
[17:39:59.901]                         if (!has_future || version < "1.8.0") {
[17:39:59.901]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.901]                             "", base::R.version$version.string), 
[17:39:59.901]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:59.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:59.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.901]                               "release", "version")], collapse = " "), 
[17:39:59.901]                             hostname = base::Sys.info()[["nodename"]])
[17:39:59.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.901]                             info)
[17:39:59.901]                           info <- base::paste(info, collapse = "; ")
[17:39:59.901]                           if (!has_future) {
[17:39:59.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.901]                               info)
[17:39:59.901]                           }
[17:39:59.901]                           else {
[17:39:59.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.901]                               info, version)
[17:39:59.901]                           }
[17:39:59.901]                           base::stop(msg)
[17:39:59.901]                         }
[17:39:59.901]                       })
[17:39:59.901]                     }
[17:39:59.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.901]                     base::options(mc.cores = 1L)
[17:39:59.901]                   }
[17:39:59.901]                   ...future.strategy.old <- future::plan("list")
[17:39:59.901]                   options(future.plan = NULL)
[17:39:59.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.901]                 }
[17:39:59.901]                 ...future.workdir <- getwd()
[17:39:59.901]             }
[17:39:59.901]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.901]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.901]         }
[17:39:59.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.901]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.901]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.901]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.901]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.901]             base::names(...future.oldOptions))
[17:39:59.901]     }
[17:39:59.901]     if (FALSE) {
[17:39:59.901]     }
[17:39:59.901]     else {
[17:39:59.901]         if (TRUE) {
[17:39:59.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.901]                 open = "w")
[17:39:59.901]         }
[17:39:59.901]         else {
[17:39:59.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.901]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.901]         }
[17:39:59.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.901]             base::sink(type = "output", split = FALSE)
[17:39:59.901]             base::close(...future.stdout)
[17:39:59.901]         }, add = TRUE)
[17:39:59.901]     }
[17:39:59.901]     ...future.frame <- base::sys.nframe()
[17:39:59.901]     ...future.conditions <- base::list()
[17:39:59.901]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.901]     if (FALSE) {
[17:39:59.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.901]     }
[17:39:59.901]     ...future.result <- base::tryCatch({
[17:39:59.901]         base::withCallingHandlers({
[17:39:59.901]             ...future.value <- base::withVisible(base::local({
[17:39:59.901]                 ...future.makeSendCondition <- base::local({
[17:39:59.901]                   sendCondition <- NULL
[17:39:59.901]                   function(frame = 1L) {
[17:39:59.901]                     if (is.function(sendCondition)) 
[17:39:59.901]                       return(sendCondition)
[17:39:59.901]                     ns <- getNamespace("parallel")
[17:39:59.901]                     if (exists("sendData", mode = "function", 
[17:39:59.901]                       envir = ns)) {
[17:39:59.901]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.901]                         envir = ns)
[17:39:59.901]                       envir <- sys.frame(frame)
[17:39:59.901]                       master <- NULL
[17:39:59.901]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.901]                         !identical(envir, emptyenv())) {
[17:39:59.901]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.901]                           inherits = FALSE)) {
[17:39:59.901]                           master <- get("master", mode = "list", 
[17:39:59.901]                             envir = envir, inherits = FALSE)
[17:39:59.901]                           if (inherits(master, c("SOCKnode", 
[17:39:59.901]                             "SOCK0node"))) {
[17:39:59.901]                             sendCondition <<- function(cond) {
[17:39:59.901]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.901]                                 success = TRUE)
[17:39:59.901]                               parallel_sendData(master, data)
[17:39:59.901]                             }
[17:39:59.901]                             return(sendCondition)
[17:39:59.901]                           }
[17:39:59.901]                         }
[17:39:59.901]                         frame <- frame + 1L
[17:39:59.901]                         envir <- sys.frame(frame)
[17:39:59.901]                       }
[17:39:59.901]                     }
[17:39:59.901]                     sendCondition <<- function(cond) NULL
[17:39:59.901]                   }
[17:39:59.901]                 })
[17:39:59.901]                 withCallingHandlers({
[17:39:59.901]                   1
[17:39:59.901]                 }, immediateCondition = function(cond) {
[17:39:59.901]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.901]                   sendCondition(cond)
[17:39:59.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.901]                   {
[17:39:59.901]                     inherits <- base::inherits
[17:39:59.901]                     invokeRestart <- base::invokeRestart
[17:39:59.901]                     is.null <- base::is.null
[17:39:59.901]                     muffled <- FALSE
[17:39:59.901]                     if (inherits(cond, "message")) {
[17:39:59.901]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.901]                       if (muffled) 
[17:39:59.901]                         invokeRestart("muffleMessage")
[17:39:59.901]                     }
[17:39:59.901]                     else if (inherits(cond, "warning")) {
[17:39:59.901]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.901]                       if (muffled) 
[17:39:59.901]                         invokeRestart("muffleWarning")
[17:39:59.901]                     }
[17:39:59.901]                     else if (inherits(cond, "condition")) {
[17:39:59.901]                       if (!is.null(pattern)) {
[17:39:59.901]                         computeRestarts <- base::computeRestarts
[17:39:59.901]                         grepl <- base::grepl
[17:39:59.901]                         restarts <- computeRestarts(cond)
[17:39:59.901]                         for (restart in restarts) {
[17:39:59.901]                           name <- restart$name
[17:39:59.901]                           if (is.null(name)) 
[17:39:59.901]                             next
[17:39:59.901]                           if (!grepl(pattern, name)) 
[17:39:59.901]                             next
[17:39:59.901]                           invokeRestart(restart)
[17:39:59.901]                           muffled <- TRUE
[17:39:59.901]                           break
[17:39:59.901]                         }
[17:39:59.901]                       }
[17:39:59.901]                     }
[17:39:59.901]                     invisible(muffled)
[17:39:59.901]                   }
[17:39:59.901]                   muffleCondition(cond)
[17:39:59.901]                 })
[17:39:59.901]             }))
[17:39:59.901]             future::FutureResult(value = ...future.value$value, 
[17:39:59.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.901]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.901]                     ...future.globalenv.names))
[17:39:59.901]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.901]         }, condition = base::local({
[17:39:59.901]             c <- base::c
[17:39:59.901]             inherits <- base::inherits
[17:39:59.901]             invokeRestart <- base::invokeRestart
[17:39:59.901]             length <- base::length
[17:39:59.901]             list <- base::list
[17:39:59.901]             seq.int <- base::seq.int
[17:39:59.901]             signalCondition <- base::signalCondition
[17:39:59.901]             sys.calls <- base::sys.calls
[17:39:59.901]             `[[` <- base::`[[`
[17:39:59.901]             `+` <- base::`+`
[17:39:59.901]             `<<-` <- base::`<<-`
[17:39:59.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.901]                   3L)]
[17:39:59.901]             }
[17:39:59.901]             function(cond) {
[17:39:59.901]                 is_error <- inherits(cond, "error")
[17:39:59.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.901]                   NULL)
[17:39:59.901]                 if (is_error) {
[17:39:59.901]                   sessionInformation <- function() {
[17:39:59.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.901]                       search = base::search(), system = base::Sys.info())
[17:39:59.901]                   }
[17:39:59.901]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.901]                     cond$call), session = sessionInformation(), 
[17:39:59.901]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.901]                   signalCondition(cond)
[17:39:59.901]                 }
[17:39:59.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.901]                 "immediateCondition"))) {
[17:39:59.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.901]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.901]                   if (TRUE && !signal) {
[17:39:59.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.901]                     {
[17:39:59.901]                       inherits <- base::inherits
[17:39:59.901]                       invokeRestart <- base::invokeRestart
[17:39:59.901]                       is.null <- base::is.null
[17:39:59.901]                       muffled <- FALSE
[17:39:59.901]                       if (inherits(cond, "message")) {
[17:39:59.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.901]                         if (muffled) 
[17:39:59.901]                           invokeRestart("muffleMessage")
[17:39:59.901]                       }
[17:39:59.901]                       else if (inherits(cond, "warning")) {
[17:39:59.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.901]                         if (muffled) 
[17:39:59.901]                           invokeRestart("muffleWarning")
[17:39:59.901]                       }
[17:39:59.901]                       else if (inherits(cond, "condition")) {
[17:39:59.901]                         if (!is.null(pattern)) {
[17:39:59.901]                           computeRestarts <- base::computeRestarts
[17:39:59.901]                           grepl <- base::grepl
[17:39:59.901]                           restarts <- computeRestarts(cond)
[17:39:59.901]                           for (restart in restarts) {
[17:39:59.901]                             name <- restart$name
[17:39:59.901]                             if (is.null(name)) 
[17:39:59.901]                               next
[17:39:59.901]                             if (!grepl(pattern, name)) 
[17:39:59.901]                               next
[17:39:59.901]                             invokeRestart(restart)
[17:39:59.901]                             muffled <- TRUE
[17:39:59.901]                             break
[17:39:59.901]                           }
[17:39:59.901]                         }
[17:39:59.901]                       }
[17:39:59.901]                       invisible(muffled)
[17:39:59.901]                     }
[17:39:59.901]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.901]                   }
[17:39:59.901]                 }
[17:39:59.901]                 else {
[17:39:59.901]                   if (TRUE) {
[17:39:59.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.901]                     {
[17:39:59.901]                       inherits <- base::inherits
[17:39:59.901]                       invokeRestart <- base::invokeRestart
[17:39:59.901]                       is.null <- base::is.null
[17:39:59.901]                       muffled <- FALSE
[17:39:59.901]                       if (inherits(cond, "message")) {
[17:39:59.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.901]                         if (muffled) 
[17:39:59.901]                           invokeRestart("muffleMessage")
[17:39:59.901]                       }
[17:39:59.901]                       else if (inherits(cond, "warning")) {
[17:39:59.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.901]                         if (muffled) 
[17:39:59.901]                           invokeRestart("muffleWarning")
[17:39:59.901]                       }
[17:39:59.901]                       else if (inherits(cond, "condition")) {
[17:39:59.901]                         if (!is.null(pattern)) {
[17:39:59.901]                           computeRestarts <- base::computeRestarts
[17:39:59.901]                           grepl <- base::grepl
[17:39:59.901]                           restarts <- computeRestarts(cond)
[17:39:59.901]                           for (restart in restarts) {
[17:39:59.901]                             name <- restart$name
[17:39:59.901]                             if (is.null(name)) 
[17:39:59.901]                               next
[17:39:59.901]                             if (!grepl(pattern, name)) 
[17:39:59.901]                               next
[17:39:59.901]                             invokeRestart(restart)
[17:39:59.901]                             muffled <- TRUE
[17:39:59.901]                             break
[17:39:59.901]                           }
[17:39:59.901]                         }
[17:39:59.901]                       }
[17:39:59.901]                       invisible(muffled)
[17:39:59.901]                     }
[17:39:59.901]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.901]                   }
[17:39:59.901]                 }
[17:39:59.901]             }
[17:39:59.901]         }))
[17:39:59.901]     }, error = function(ex) {
[17:39:59.901]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.901]                 ...future.rng), started = ...future.startTime, 
[17:39:59.901]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.901]             version = "1.8"), class = "FutureResult")
[17:39:59.901]     }, finally = {
[17:39:59.901]         if (!identical(...future.workdir, getwd())) 
[17:39:59.901]             setwd(...future.workdir)
[17:39:59.901]         {
[17:39:59.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.901]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.901]             }
[17:39:59.901]             base::options(...future.oldOptions)
[17:39:59.901]             if (.Platform$OS.type == "windows") {
[17:39:59.901]                 old_names <- names(...future.oldEnvVars)
[17:39:59.901]                 envs <- base::Sys.getenv()
[17:39:59.901]                 names <- names(envs)
[17:39:59.901]                 common <- intersect(names, old_names)
[17:39:59.901]                 added <- setdiff(names, old_names)
[17:39:59.901]                 removed <- setdiff(old_names, names)
[17:39:59.901]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.901]                   envs[common]]
[17:39:59.901]                 NAMES <- toupper(changed)
[17:39:59.901]                 args <- list()
[17:39:59.901]                 for (kk in seq_along(NAMES)) {
[17:39:59.901]                   name <- changed[[kk]]
[17:39:59.901]                   NAME <- NAMES[[kk]]
[17:39:59.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.901]                     next
[17:39:59.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.901]                 }
[17:39:59.901]                 NAMES <- toupper(added)
[17:39:59.901]                 for (kk in seq_along(NAMES)) {
[17:39:59.901]                   name <- added[[kk]]
[17:39:59.901]                   NAME <- NAMES[[kk]]
[17:39:59.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.901]                     next
[17:39:59.901]                   args[[name]] <- ""
[17:39:59.901]                 }
[17:39:59.901]                 NAMES <- toupper(removed)
[17:39:59.901]                 for (kk in seq_along(NAMES)) {
[17:39:59.901]                   name <- removed[[kk]]
[17:39:59.901]                   NAME <- NAMES[[kk]]
[17:39:59.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.901]                     next
[17:39:59.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.901]                 }
[17:39:59.901]                 if (length(args) > 0) 
[17:39:59.901]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.901]             }
[17:39:59.901]             else {
[17:39:59.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.901]             }
[17:39:59.901]             {
[17:39:59.901]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.901]                   0L) {
[17:39:59.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.901]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.901]                   base::options(opts)
[17:39:59.901]                 }
[17:39:59.901]                 {
[17:39:59.901]                   {
[17:39:59.901]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.901]                     NULL
[17:39:59.901]                   }
[17:39:59.901]                   options(future.plan = NULL)
[17:39:59.901]                   if (is.na(NA_character_)) 
[17:39:59.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.901]                     .init = FALSE)
[17:39:59.901]                 }
[17:39:59.901]             }
[17:39:59.901]         }
[17:39:59.901]     })
[17:39:59.901]     if (TRUE) {
[17:39:59.901]         base::sink(type = "output", split = FALSE)
[17:39:59.901]         if (TRUE) {
[17:39:59.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.901]         }
[17:39:59.901]         else {
[17:39:59.901]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.901]         }
[17:39:59.901]         base::close(...future.stdout)
[17:39:59.901]         ...future.stdout <- NULL
[17:39:59.901]     }
[17:39:59.901]     ...future.result$conditions <- ...future.conditions
[17:39:59.901]     ...future.result$finished <- base::Sys.time()
[17:39:59.901]     ...future.result
[17:39:59.901] }
[17:39:59.904] MultisessionFuture started
[17:39:59.904] - Launch lazy future ... done
[17:39:59.904] run() for ‘MultisessionFuture’ ... done
[17:39:59.946] receiveMessageFromWorker() for ClusterFuture ...
[17:39:59.946] - Validating connection of MultisessionFuture
[17:39:59.946] - received message: FutureResult
[17:39:59.946] - Received FutureResult
[17:39:59.947] - Erased future from FutureRegistry
[17:39:59.947] result() for ClusterFuture ...
[17:39:59.947] - result already collected: FutureResult
[17:39:59.947] result() for ClusterFuture ... done
[17:39:59.947] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:59.947] Future #1
[17:39:59.947] result() for ClusterFuture ...
[17:39:59.947] - result already collected: FutureResult
[17:39:59.947] result() for ClusterFuture ... done
[17:39:59.947] result() for ClusterFuture ...
[17:39:59.947] - result already collected: FutureResult
[17:39:59.948] result() for ClusterFuture ... done
[17:39:59.948] A MultisessionFuture was resolved
[17:39:59.948]  length: 0 (resolved future 1)
[17:39:59.948] resolve() on list ... DONE
[17:39:59.948] - globals: [1] ‘a’
[17:39:59.948] Resolving futures part of globals (recursively) ... DONE
[17:39:59.950] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[17:39:59.950] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:39:59.950] - globals: [1] ‘a’
[17:39:59.951] - packages: [1] ‘future’
[17:39:59.951] getGlobalsAndPackages() ... DONE
[17:39:59.951] run() for ‘Future’ ...
[17:39:59.951] - state: ‘created’
[17:39:59.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:59.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:59.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:59.965]   - Field: ‘node’
[17:39:59.965]   - Field: ‘label’
[17:39:59.965]   - Field: ‘local’
[17:39:59.965]   - Field: ‘owner’
[17:39:59.965]   - Field: ‘envir’
[17:39:59.965]   - Field: ‘workers’
[17:39:59.965]   - Field: ‘packages’
[17:39:59.965]   - Field: ‘gc’
[17:39:59.965]   - Field: ‘conditions’
[17:39:59.966]   - Field: ‘persistent’
[17:39:59.966]   - Field: ‘expr’
[17:39:59.966]   - Field: ‘uuid’
[17:39:59.966]   - Field: ‘seed’
[17:39:59.966]   - Field: ‘version’
[17:39:59.966]   - Field: ‘result’
[17:39:59.966]   - Field: ‘asynchronous’
[17:39:59.966]   - Field: ‘calls’
[17:39:59.966]   - Field: ‘globals’
[17:39:59.966]   - Field: ‘stdout’
[17:39:59.966]   - Field: ‘earlySignal’
[17:39:59.967]   - Field: ‘lazy’
[17:39:59.967]   - Field: ‘state’
[17:39:59.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:59.967] - Launch lazy future ...
[17:39:59.967] Packages needed by the future expression (n = 1): ‘future’
[17:39:59.967] Packages needed by future strategies (n = 0): <none>
[17:39:59.968] {
[17:39:59.968]     {
[17:39:59.968]         {
[17:39:59.968]             ...future.startTime <- base::Sys.time()
[17:39:59.968]             {
[17:39:59.968]                 {
[17:39:59.968]                   {
[17:39:59.968]                     {
[17:39:59.968]                       {
[17:39:59.968]                         base::local({
[17:39:59.968]                           has_future <- base::requireNamespace("future", 
[17:39:59.968]                             quietly = TRUE)
[17:39:59.968]                           if (has_future) {
[17:39:59.968]                             ns <- base::getNamespace("future")
[17:39:59.968]                             version <- ns[[".package"]][["version"]]
[17:39:59.968]                             if (is.null(version)) 
[17:39:59.968]                               version <- utils::packageVersion("future")
[17:39:59.968]                           }
[17:39:59.968]                           else {
[17:39:59.968]                             version <- NULL
[17:39:59.968]                           }
[17:39:59.968]                           if (!has_future || version < "1.8.0") {
[17:39:59.968]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:59.968]                               "", base::R.version$version.string), 
[17:39:59.968]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:59.968]                                 base::R.version$platform, 8 * 
[17:39:59.968]                                   base::.Machine$sizeof.pointer), 
[17:39:59.968]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:59.968]                                 "release", "version")], collapse = " "), 
[17:39:59.968]                               hostname = base::Sys.info()[["nodename"]])
[17:39:59.968]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:59.968]                               info)
[17:39:59.968]                             info <- base::paste(info, collapse = "; ")
[17:39:59.968]                             if (!has_future) {
[17:39:59.968]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:59.968]                                 info)
[17:39:59.968]                             }
[17:39:59.968]                             else {
[17:39:59.968]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:59.968]                                 info, version)
[17:39:59.968]                             }
[17:39:59.968]                             base::stop(msg)
[17:39:59.968]                           }
[17:39:59.968]                         })
[17:39:59.968]                       }
[17:39:59.968]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:59.968]                       base::options(mc.cores = 1L)
[17:39:59.968]                     }
[17:39:59.968]                     base::local({
[17:39:59.968]                       for (pkg in "future") {
[17:39:59.968]                         base::loadNamespace(pkg)
[17:39:59.968]                         base::library(pkg, character.only = TRUE)
[17:39:59.968]                       }
[17:39:59.968]                     })
[17:39:59.968]                   }
[17:39:59.968]                   ...future.strategy.old <- future::plan("list")
[17:39:59.968]                   options(future.plan = NULL)
[17:39:59.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:59.968]                 }
[17:39:59.968]                 ...future.workdir <- getwd()
[17:39:59.968]             }
[17:39:59.968]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:59.968]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:59.968]         }
[17:39:59.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:39:59.968]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:39:59.968]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:39:59.968]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:39:59.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:59.968]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:59.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:59.968]             base::names(...future.oldOptions))
[17:39:59.968]     }
[17:39:59.968]     if (FALSE) {
[17:39:59.968]     }
[17:39:59.968]     else {
[17:39:59.968]         if (TRUE) {
[17:39:59.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:59.968]                 open = "w")
[17:39:59.968]         }
[17:39:59.968]         else {
[17:39:59.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:59.968]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:59.968]         }
[17:39:59.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:59.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:59.968]             base::sink(type = "output", split = FALSE)
[17:39:59.968]             base::close(...future.stdout)
[17:39:59.968]         }, add = TRUE)
[17:39:59.968]     }
[17:39:59.968]     ...future.frame <- base::sys.nframe()
[17:39:59.968]     ...future.conditions <- base::list()
[17:39:59.968]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:59.968]     if (FALSE) {
[17:39:59.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:59.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:59.968]     }
[17:39:59.968]     ...future.result <- base::tryCatch({
[17:39:59.968]         base::withCallingHandlers({
[17:39:59.968]             ...future.value <- base::withVisible(base::local({
[17:39:59.968]                 ...future.makeSendCondition <- base::local({
[17:39:59.968]                   sendCondition <- NULL
[17:39:59.968]                   function(frame = 1L) {
[17:39:59.968]                     if (is.function(sendCondition)) 
[17:39:59.968]                       return(sendCondition)
[17:39:59.968]                     ns <- getNamespace("parallel")
[17:39:59.968]                     if (exists("sendData", mode = "function", 
[17:39:59.968]                       envir = ns)) {
[17:39:59.968]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:59.968]                         envir = ns)
[17:39:59.968]                       envir <- sys.frame(frame)
[17:39:59.968]                       master <- NULL
[17:39:59.968]                       while (!identical(envir, .GlobalEnv) && 
[17:39:59.968]                         !identical(envir, emptyenv())) {
[17:39:59.968]                         if (exists("master", mode = "list", envir = envir, 
[17:39:59.968]                           inherits = FALSE)) {
[17:39:59.968]                           master <- get("master", mode = "list", 
[17:39:59.968]                             envir = envir, inherits = FALSE)
[17:39:59.968]                           if (inherits(master, c("SOCKnode", 
[17:39:59.968]                             "SOCK0node"))) {
[17:39:59.968]                             sendCondition <<- function(cond) {
[17:39:59.968]                               data <- list(type = "VALUE", value = cond, 
[17:39:59.968]                                 success = TRUE)
[17:39:59.968]                               parallel_sendData(master, data)
[17:39:59.968]                             }
[17:39:59.968]                             return(sendCondition)
[17:39:59.968]                           }
[17:39:59.968]                         }
[17:39:59.968]                         frame <- frame + 1L
[17:39:59.968]                         envir <- sys.frame(frame)
[17:39:59.968]                       }
[17:39:59.968]                     }
[17:39:59.968]                     sendCondition <<- function(cond) NULL
[17:39:59.968]                   }
[17:39:59.968]                 })
[17:39:59.968]                 withCallingHandlers({
[17:39:59.968]                   value(a) + 1
[17:39:59.968]                 }, immediateCondition = function(cond) {
[17:39:59.968]                   sendCondition <- ...future.makeSendCondition()
[17:39:59.968]                   sendCondition(cond)
[17:39:59.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.968]                   {
[17:39:59.968]                     inherits <- base::inherits
[17:39:59.968]                     invokeRestart <- base::invokeRestart
[17:39:59.968]                     is.null <- base::is.null
[17:39:59.968]                     muffled <- FALSE
[17:39:59.968]                     if (inherits(cond, "message")) {
[17:39:59.968]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:59.968]                       if (muffled) 
[17:39:59.968]                         invokeRestart("muffleMessage")
[17:39:59.968]                     }
[17:39:59.968]                     else if (inherits(cond, "warning")) {
[17:39:59.968]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:59.968]                       if (muffled) 
[17:39:59.968]                         invokeRestart("muffleWarning")
[17:39:59.968]                     }
[17:39:59.968]                     else if (inherits(cond, "condition")) {
[17:39:59.968]                       if (!is.null(pattern)) {
[17:39:59.968]                         computeRestarts <- base::computeRestarts
[17:39:59.968]                         grepl <- base::grepl
[17:39:59.968]                         restarts <- computeRestarts(cond)
[17:39:59.968]                         for (restart in restarts) {
[17:39:59.968]                           name <- restart$name
[17:39:59.968]                           if (is.null(name)) 
[17:39:59.968]                             next
[17:39:59.968]                           if (!grepl(pattern, name)) 
[17:39:59.968]                             next
[17:39:59.968]                           invokeRestart(restart)
[17:39:59.968]                           muffled <- TRUE
[17:39:59.968]                           break
[17:39:59.968]                         }
[17:39:59.968]                       }
[17:39:59.968]                     }
[17:39:59.968]                     invisible(muffled)
[17:39:59.968]                   }
[17:39:59.968]                   muffleCondition(cond)
[17:39:59.968]                 })
[17:39:59.968]             }))
[17:39:59.968]             future::FutureResult(value = ...future.value$value, 
[17:39:59.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.968]                   ...future.rng), globalenv = if (FALSE) 
[17:39:59.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:59.968]                     ...future.globalenv.names))
[17:39:59.968]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:59.968]         }, condition = base::local({
[17:39:59.968]             c <- base::c
[17:39:59.968]             inherits <- base::inherits
[17:39:59.968]             invokeRestart <- base::invokeRestart
[17:39:59.968]             length <- base::length
[17:39:59.968]             list <- base::list
[17:39:59.968]             seq.int <- base::seq.int
[17:39:59.968]             signalCondition <- base::signalCondition
[17:39:59.968]             sys.calls <- base::sys.calls
[17:39:59.968]             `[[` <- base::`[[`
[17:39:59.968]             `+` <- base::`+`
[17:39:59.968]             `<<-` <- base::`<<-`
[17:39:59.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:59.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:59.968]                   3L)]
[17:39:59.968]             }
[17:39:59.968]             function(cond) {
[17:39:59.968]                 is_error <- inherits(cond, "error")
[17:39:59.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:59.968]                   NULL)
[17:39:59.968]                 if (is_error) {
[17:39:59.968]                   sessionInformation <- function() {
[17:39:59.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:59.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:59.968]                       search = base::search(), system = base::Sys.info())
[17:39:59.968]                   }
[17:39:59.968]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:59.968]                     cond$call), session = sessionInformation(), 
[17:39:59.968]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:59.968]                   signalCondition(cond)
[17:39:59.968]                 }
[17:39:59.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:59.968]                 "immediateCondition"))) {
[17:39:59.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:59.968]                   ...future.conditions[[length(...future.conditions) + 
[17:39:59.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:59.968]                   if (TRUE && !signal) {
[17:39:59.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.968]                     {
[17:39:59.968]                       inherits <- base::inherits
[17:39:59.968]                       invokeRestart <- base::invokeRestart
[17:39:59.968]                       is.null <- base::is.null
[17:39:59.968]                       muffled <- FALSE
[17:39:59.968]                       if (inherits(cond, "message")) {
[17:39:59.968]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.968]                         if (muffled) 
[17:39:59.968]                           invokeRestart("muffleMessage")
[17:39:59.968]                       }
[17:39:59.968]                       else if (inherits(cond, "warning")) {
[17:39:59.968]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.968]                         if (muffled) 
[17:39:59.968]                           invokeRestart("muffleWarning")
[17:39:59.968]                       }
[17:39:59.968]                       else if (inherits(cond, "condition")) {
[17:39:59.968]                         if (!is.null(pattern)) {
[17:39:59.968]                           computeRestarts <- base::computeRestarts
[17:39:59.968]                           grepl <- base::grepl
[17:39:59.968]                           restarts <- computeRestarts(cond)
[17:39:59.968]                           for (restart in restarts) {
[17:39:59.968]                             name <- restart$name
[17:39:59.968]                             if (is.null(name)) 
[17:39:59.968]                               next
[17:39:59.968]                             if (!grepl(pattern, name)) 
[17:39:59.968]                               next
[17:39:59.968]                             invokeRestart(restart)
[17:39:59.968]                             muffled <- TRUE
[17:39:59.968]                             break
[17:39:59.968]                           }
[17:39:59.968]                         }
[17:39:59.968]                       }
[17:39:59.968]                       invisible(muffled)
[17:39:59.968]                     }
[17:39:59.968]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.968]                   }
[17:39:59.968]                 }
[17:39:59.968]                 else {
[17:39:59.968]                   if (TRUE) {
[17:39:59.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:59.968]                     {
[17:39:59.968]                       inherits <- base::inherits
[17:39:59.968]                       invokeRestart <- base::invokeRestart
[17:39:59.968]                       is.null <- base::is.null
[17:39:59.968]                       muffled <- FALSE
[17:39:59.968]                       if (inherits(cond, "message")) {
[17:39:59.968]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:59.968]                         if (muffled) 
[17:39:59.968]                           invokeRestart("muffleMessage")
[17:39:59.968]                       }
[17:39:59.968]                       else if (inherits(cond, "warning")) {
[17:39:59.968]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:59.968]                         if (muffled) 
[17:39:59.968]                           invokeRestart("muffleWarning")
[17:39:59.968]                       }
[17:39:59.968]                       else if (inherits(cond, "condition")) {
[17:39:59.968]                         if (!is.null(pattern)) {
[17:39:59.968]                           computeRestarts <- base::computeRestarts
[17:39:59.968]                           grepl <- base::grepl
[17:39:59.968]                           restarts <- computeRestarts(cond)
[17:39:59.968]                           for (restart in restarts) {
[17:39:59.968]                             name <- restart$name
[17:39:59.968]                             if (is.null(name)) 
[17:39:59.968]                               next
[17:39:59.968]                             if (!grepl(pattern, name)) 
[17:39:59.968]                               next
[17:39:59.968]                             invokeRestart(restart)
[17:39:59.968]                             muffled <- TRUE
[17:39:59.968]                             break
[17:39:59.968]                           }
[17:39:59.968]                         }
[17:39:59.968]                       }
[17:39:59.968]                       invisible(muffled)
[17:39:59.968]                     }
[17:39:59.968]                     muffleCondition(cond, pattern = "^muffle")
[17:39:59.968]                   }
[17:39:59.968]                 }
[17:39:59.968]             }
[17:39:59.968]         }))
[17:39:59.968]     }, error = function(ex) {
[17:39:59.968]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:59.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:59.968]                 ...future.rng), started = ...future.startTime, 
[17:39:59.968]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:59.968]             version = "1.8"), class = "FutureResult")
[17:39:59.968]     }, finally = {
[17:39:59.968]         if (!identical(...future.workdir, getwd())) 
[17:39:59.968]             setwd(...future.workdir)
[17:39:59.968]         {
[17:39:59.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:59.968]                 ...future.oldOptions$nwarnings <- NULL
[17:39:59.968]             }
[17:39:59.968]             base::options(...future.oldOptions)
[17:39:59.968]             if (.Platform$OS.type == "windows") {
[17:39:59.968]                 old_names <- names(...future.oldEnvVars)
[17:39:59.968]                 envs <- base::Sys.getenv()
[17:39:59.968]                 names <- names(envs)
[17:39:59.968]                 common <- intersect(names, old_names)
[17:39:59.968]                 added <- setdiff(names, old_names)
[17:39:59.968]                 removed <- setdiff(old_names, names)
[17:39:59.968]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:59.968]                   envs[common]]
[17:39:59.968]                 NAMES <- toupper(changed)
[17:39:59.968]                 args <- list()
[17:39:59.968]                 for (kk in seq_along(NAMES)) {
[17:39:59.968]                   name <- changed[[kk]]
[17:39:59.968]                   NAME <- NAMES[[kk]]
[17:39:59.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.968]                     next
[17:39:59.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.968]                 }
[17:39:59.968]                 NAMES <- toupper(added)
[17:39:59.968]                 for (kk in seq_along(NAMES)) {
[17:39:59.968]                   name <- added[[kk]]
[17:39:59.968]                   NAME <- NAMES[[kk]]
[17:39:59.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.968]                     next
[17:39:59.968]                   args[[name]] <- ""
[17:39:59.968]                 }
[17:39:59.968]                 NAMES <- toupper(removed)
[17:39:59.968]                 for (kk in seq_along(NAMES)) {
[17:39:59.968]                   name <- removed[[kk]]
[17:39:59.968]                   NAME <- NAMES[[kk]]
[17:39:59.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:59.968]                     next
[17:39:59.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:59.968]                 }
[17:39:59.968]                 if (length(args) > 0) 
[17:39:59.968]                   base::do.call(base::Sys.setenv, args = args)
[17:39:59.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:59.968]             }
[17:39:59.968]             else {
[17:39:59.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:59.968]             }
[17:39:59.968]             {
[17:39:59.968]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:59.968]                   0L) {
[17:39:59.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:59.968]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:59.968]                   base::options(opts)
[17:39:59.968]                 }
[17:39:59.968]                 {
[17:39:59.968]                   {
[17:39:59.968]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:59.968]                     NULL
[17:39:59.968]                   }
[17:39:59.968]                   options(future.plan = NULL)
[17:39:59.968]                   if (is.na(NA_character_)) 
[17:39:59.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:59.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:59.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:59.968]                     .init = FALSE)
[17:39:59.968]                 }
[17:39:59.968]             }
[17:39:59.968]         }
[17:39:59.968]     })
[17:39:59.968]     if (TRUE) {
[17:39:59.968]         base::sink(type = "output", split = FALSE)
[17:39:59.968]         if (TRUE) {
[17:39:59.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:59.968]         }
[17:39:59.968]         else {
[17:39:59.968]             ...future.result["stdout"] <- base::list(NULL)
[17:39:59.968]         }
[17:39:59.968]         base::close(...future.stdout)
[17:39:59.968]         ...future.stdout <- NULL
[17:39:59.968]     }
[17:39:59.968]     ...future.result$conditions <- ...future.conditions
[17:39:59.968]     ...future.result$finished <- base::Sys.time()
[17:39:59.968]     ...future.result
[17:39:59.968] }
[17:39:59.970] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:39:59.972] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:40:00.025] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:40:00.025] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:40:00.026] MultisessionFuture started
[17:40:00.026] - Launch lazy future ... done
[17:40:00.026] run() for ‘MultisessionFuture’ ... done
[17:40:00.026] result() for ClusterFuture ...
[17:40:00.026] receiveMessageFromWorker() for ClusterFuture ...
[17:40:00.026] - Validating connection of MultisessionFuture
[17:40:00.071] - received message: FutureResult
[17:40:00.071] - Received FutureResult
[17:40:00.071] - Erased future from FutureRegistry
[17:40:00.071] result() for ClusterFuture ...
[17:40:00.071] - result already collected: FutureResult
[17:40:00.071] result() for ClusterFuture ... done
[17:40:00.071] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:00.071] result() for ClusterFuture ... done
[17:40:00.072] result() for ClusterFuture ...
[17:40:00.072] - result already collected: FutureResult
[17:40:00.072] result() for ClusterFuture ... done
value(b) = 2
[17:40:00.072] result() for ClusterFuture ...
[17:40:00.072] - result already collected: FutureResult
[17:40:00.072] result() for ClusterFuture ... done
[17:40:00.072] result() for ClusterFuture ...
[17:40:00.072] - result already collected: FutureResult
[17:40:00.072] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:40:00.073] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:40:00.073] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:40:00.073] 
[17:40:00.073] Searching for globals ... DONE
[17:40:00.074] - globals: [0] <none>
[17:40:00.074] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:40:00.074] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:40:00.074] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:40:00.075] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:40:00.075] Searching for globals ... DONE
[17:40:00.075] Resolving globals: TRUE
[17:40:00.075] Resolving any globals that are futures ...
[17:40:00.075] - globals: [3] ‘+’, ‘value’, ‘a’
[17:40:00.075] Resolving any globals that are futures ... DONE
[17:40:00.076] Resolving futures part of globals (recursively) ...
[17:40:00.076] resolve() on list ...
[17:40:00.076]  recursive: 99
[17:40:00.076]  length: 1
[17:40:00.076]  elements: ‘a’
[17:40:00.076] run() for ‘Future’ ...
[17:40:00.076] - state: ‘created’
[17:40:00.077] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:00.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:00.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:00.091]   - Field: ‘node’
[17:40:00.091]   - Field: ‘label’
[17:40:00.091]   - Field: ‘local’
[17:40:00.091]   - Field: ‘owner’
[17:40:00.091]   - Field: ‘envir’
[17:40:00.091]   - Field: ‘workers’
[17:40:00.091]   - Field: ‘packages’
[17:40:00.091]   - Field: ‘gc’
[17:40:00.092]   - Field: ‘conditions’
[17:40:00.092]   - Field: ‘persistent’
[17:40:00.092]   - Field: ‘expr’
[17:40:00.092]   - Field: ‘uuid’
[17:40:00.092]   - Field: ‘seed’
[17:40:00.092]   - Field: ‘version’
[17:40:00.092]   - Field: ‘result’
[17:40:00.092]   - Field: ‘asynchronous’
[17:40:00.092]   - Field: ‘calls’
[17:40:00.092]   - Field: ‘globals’
[17:40:00.092]   - Field: ‘stdout’
[17:40:00.093]   - Field: ‘earlySignal’
[17:40:00.093]   - Field: ‘lazy’
[17:40:00.093]   - Field: ‘state’
[17:40:00.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:00.093] - Launch lazy future ...
[17:40:00.093] Packages needed by the future expression (n = 0): <none>
[17:40:00.093] Packages needed by future strategies (n = 0): <none>
[17:40:00.094] {
[17:40:00.094]     {
[17:40:00.094]         {
[17:40:00.094]             ...future.startTime <- base::Sys.time()
[17:40:00.094]             {
[17:40:00.094]                 {
[17:40:00.094]                   {
[17:40:00.094]                     {
[17:40:00.094]                       base::local({
[17:40:00.094]                         has_future <- base::requireNamespace("future", 
[17:40:00.094]                           quietly = TRUE)
[17:40:00.094]                         if (has_future) {
[17:40:00.094]                           ns <- base::getNamespace("future")
[17:40:00.094]                           version <- ns[[".package"]][["version"]]
[17:40:00.094]                           if (is.null(version)) 
[17:40:00.094]                             version <- utils::packageVersion("future")
[17:40:00.094]                         }
[17:40:00.094]                         else {
[17:40:00.094]                           version <- NULL
[17:40:00.094]                         }
[17:40:00.094]                         if (!has_future || version < "1.8.0") {
[17:40:00.094]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:00.094]                             "", base::R.version$version.string), 
[17:40:00.094]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:00.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:00.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:00.094]                               "release", "version")], collapse = " "), 
[17:40:00.094]                             hostname = base::Sys.info()[["nodename"]])
[17:40:00.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:00.094]                             info)
[17:40:00.094]                           info <- base::paste(info, collapse = "; ")
[17:40:00.094]                           if (!has_future) {
[17:40:00.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:00.094]                               info)
[17:40:00.094]                           }
[17:40:00.094]                           else {
[17:40:00.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:00.094]                               info, version)
[17:40:00.094]                           }
[17:40:00.094]                           base::stop(msg)
[17:40:00.094]                         }
[17:40:00.094]                       })
[17:40:00.094]                     }
[17:40:00.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:00.094]                     base::options(mc.cores = 1L)
[17:40:00.094]                   }
[17:40:00.094]                   ...future.strategy.old <- future::plan("list")
[17:40:00.094]                   options(future.plan = NULL)
[17:40:00.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:00.094]                 }
[17:40:00.094]                 ...future.workdir <- getwd()
[17:40:00.094]             }
[17:40:00.094]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:00.094]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:00.094]         }
[17:40:00.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:40:00.094]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:40:00.094]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:40:00.094]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:40:00.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:00.094]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:00.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:00.094]             base::names(...future.oldOptions))
[17:40:00.094]     }
[17:40:00.094]     if (FALSE) {
[17:40:00.094]     }
[17:40:00.094]     else {
[17:40:00.094]         if (TRUE) {
[17:40:00.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:00.094]                 open = "w")
[17:40:00.094]         }
[17:40:00.094]         else {
[17:40:00.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:00.094]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:00.094]         }
[17:40:00.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:00.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:00.094]             base::sink(type = "output", split = FALSE)
[17:40:00.094]             base::close(...future.stdout)
[17:40:00.094]         }, add = TRUE)
[17:40:00.094]     }
[17:40:00.094]     ...future.frame <- base::sys.nframe()
[17:40:00.094]     ...future.conditions <- base::list()
[17:40:00.094]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:00.094]     if (FALSE) {
[17:40:00.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:00.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:00.094]     }
[17:40:00.094]     ...future.result <- base::tryCatch({
[17:40:00.094]         base::withCallingHandlers({
[17:40:00.094]             ...future.value <- base::withVisible(base::local({
[17:40:00.094]                 ...future.makeSendCondition <- base::local({
[17:40:00.094]                   sendCondition <- NULL
[17:40:00.094]                   function(frame = 1L) {
[17:40:00.094]                     if (is.function(sendCondition)) 
[17:40:00.094]                       return(sendCondition)
[17:40:00.094]                     ns <- getNamespace("parallel")
[17:40:00.094]                     if (exists("sendData", mode = "function", 
[17:40:00.094]                       envir = ns)) {
[17:40:00.094]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:00.094]                         envir = ns)
[17:40:00.094]                       envir <- sys.frame(frame)
[17:40:00.094]                       master <- NULL
[17:40:00.094]                       while (!identical(envir, .GlobalEnv) && 
[17:40:00.094]                         !identical(envir, emptyenv())) {
[17:40:00.094]                         if (exists("master", mode = "list", envir = envir, 
[17:40:00.094]                           inherits = FALSE)) {
[17:40:00.094]                           master <- get("master", mode = "list", 
[17:40:00.094]                             envir = envir, inherits = FALSE)
[17:40:00.094]                           if (inherits(master, c("SOCKnode", 
[17:40:00.094]                             "SOCK0node"))) {
[17:40:00.094]                             sendCondition <<- function(cond) {
[17:40:00.094]                               data <- list(type = "VALUE", value = cond, 
[17:40:00.094]                                 success = TRUE)
[17:40:00.094]                               parallel_sendData(master, data)
[17:40:00.094]                             }
[17:40:00.094]                             return(sendCondition)
[17:40:00.094]                           }
[17:40:00.094]                         }
[17:40:00.094]                         frame <- frame + 1L
[17:40:00.094]                         envir <- sys.frame(frame)
[17:40:00.094]                       }
[17:40:00.094]                     }
[17:40:00.094]                     sendCondition <<- function(cond) NULL
[17:40:00.094]                   }
[17:40:00.094]                 })
[17:40:00.094]                 withCallingHandlers({
[17:40:00.094]                   1
[17:40:00.094]                 }, immediateCondition = function(cond) {
[17:40:00.094]                   sendCondition <- ...future.makeSendCondition()
[17:40:00.094]                   sendCondition(cond)
[17:40:00.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.094]                   {
[17:40:00.094]                     inherits <- base::inherits
[17:40:00.094]                     invokeRestart <- base::invokeRestart
[17:40:00.094]                     is.null <- base::is.null
[17:40:00.094]                     muffled <- FALSE
[17:40:00.094]                     if (inherits(cond, "message")) {
[17:40:00.094]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:00.094]                       if (muffled) 
[17:40:00.094]                         invokeRestart("muffleMessage")
[17:40:00.094]                     }
[17:40:00.094]                     else if (inherits(cond, "warning")) {
[17:40:00.094]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:00.094]                       if (muffled) 
[17:40:00.094]                         invokeRestart("muffleWarning")
[17:40:00.094]                     }
[17:40:00.094]                     else if (inherits(cond, "condition")) {
[17:40:00.094]                       if (!is.null(pattern)) {
[17:40:00.094]                         computeRestarts <- base::computeRestarts
[17:40:00.094]                         grepl <- base::grepl
[17:40:00.094]                         restarts <- computeRestarts(cond)
[17:40:00.094]                         for (restart in restarts) {
[17:40:00.094]                           name <- restart$name
[17:40:00.094]                           if (is.null(name)) 
[17:40:00.094]                             next
[17:40:00.094]                           if (!grepl(pattern, name)) 
[17:40:00.094]                             next
[17:40:00.094]                           invokeRestart(restart)
[17:40:00.094]                           muffled <- TRUE
[17:40:00.094]                           break
[17:40:00.094]                         }
[17:40:00.094]                       }
[17:40:00.094]                     }
[17:40:00.094]                     invisible(muffled)
[17:40:00.094]                   }
[17:40:00.094]                   muffleCondition(cond)
[17:40:00.094]                 })
[17:40:00.094]             }))
[17:40:00.094]             future::FutureResult(value = ...future.value$value, 
[17:40:00.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.094]                   ...future.rng), globalenv = if (FALSE) 
[17:40:00.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:00.094]                     ...future.globalenv.names))
[17:40:00.094]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:00.094]         }, condition = base::local({
[17:40:00.094]             c <- base::c
[17:40:00.094]             inherits <- base::inherits
[17:40:00.094]             invokeRestart <- base::invokeRestart
[17:40:00.094]             length <- base::length
[17:40:00.094]             list <- base::list
[17:40:00.094]             seq.int <- base::seq.int
[17:40:00.094]             signalCondition <- base::signalCondition
[17:40:00.094]             sys.calls <- base::sys.calls
[17:40:00.094]             `[[` <- base::`[[`
[17:40:00.094]             `+` <- base::`+`
[17:40:00.094]             `<<-` <- base::`<<-`
[17:40:00.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:00.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:00.094]                   3L)]
[17:40:00.094]             }
[17:40:00.094]             function(cond) {
[17:40:00.094]                 is_error <- inherits(cond, "error")
[17:40:00.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:00.094]                   NULL)
[17:40:00.094]                 if (is_error) {
[17:40:00.094]                   sessionInformation <- function() {
[17:40:00.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:00.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:00.094]                       search = base::search(), system = base::Sys.info())
[17:40:00.094]                   }
[17:40:00.094]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:00.094]                     cond$call), session = sessionInformation(), 
[17:40:00.094]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:00.094]                   signalCondition(cond)
[17:40:00.094]                 }
[17:40:00.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:00.094]                 "immediateCondition"))) {
[17:40:00.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:00.094]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:00.094]                   if (TRUE && !signal) {
[17:40:00.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.094]                     {
[17:40:00.094]                       inherits <- base::inherits
[17:40:00.094]                       invokeRestart <- base::invokeRestart
[17:40:00.094]                       is.null <- base::is.null
[17:40:00.094]                       muffled <- FALSE
[17:40:00.094]                       if (inherits(cond, "message")) {
[17:40:00.094]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.094]                         if (muffled) 
[17:40:00.094]                           invokeRestart("muffleMessage")
[17:40:00.094]                       }
[17:40:00.094]                       else if (inherits(cond, "warning")) {
[17:40:00.094]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.094]                         if (muffled) 
[17:40:00.094]                           invokeRestart("muffleWarning")
[17:40:00.094]                       }
[17:40:00.094]                       else if (inherits(cond, "condition")) {
[17:40:00.094]                         if (!is.null(pattern)) {
[17:40:00.094]                           computeRestarts <- base::computeRestarts
[17:40:00.094]                           grepl <- base::grepl
[17:40:00.094]                           restarts <- computeRestarts(cond)
[17:40:00.094]                           for (restart in restarts) {
[17:40:00.094]                             name <- restart$name
[17:40:00.094]                             if (is.null(name)) 
[17:40:00.094]                               next
[17:40:00.094]                             if (!grepl(pattern, name)) 
[17:40:00.094]                               next
[17:40:00.094]                             invokeRestart(restart)
[17:40:00.094]                             muffled <- TRUE
[17:40:00.094]                             break
[17:40:00.094]                           }
[17:40:00.094]                         }
[17:40:00.094]                       }
[17:40:00.094]                       invisible(muffled)
[17:40:00.094]                     }
[17:40:00.094]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.094]                   }
[17:40:00.094]                 }
[17:40:00.094]                 else {
[17:40:00.094]                   if (TRUE) {
[17:40:00.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.094]                     {
[17:40:00.094]                       inherits <- base::inherits
[17:40:00.094]                       invokeRestart <- base::invokeRestart
[17:40:00.094]                       is.null <- base::is.null
[17:40:00.094]                       muffled <- FALSE
[17:40:00.094]                       if (inherits(cond, "message")) {
[17:40:00.094]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.094]                         if (muffled) 
[17:40:00.094]                           invokeRestart("muffleMessage")
[17:40:00.094]                       }
[17:40:00.094]                       else if (inherits(cond, "warning")) {
[17:40:00.094]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.094]                         if (muffled) 
[17:40:00.094]                           invokeRestart("muffleWarning")
[17:40:00.094]                       }
[17:40:00.094]                       else if (inherits(cond, "condition")) {
[17:40:00.094]                         if (!is.null(pattern)) {
[17:40:00.094]                           computeRestarts <- base::computeRestarts
[17:40:00.094]                           grepl <- base::grepl
[17:40:00.094]                           restarts <- computeRestarts(cond)
[17:40:00.094]                           for (restart in restarts) {
[17:40:00.094]                             name <- restart$name
[17:40:00.094]                             if (is.null(name)) 
[17:40:00.094]                               next
[17:40:00.094]                             if (!grepl(pattern, name)) 
[17:40:00.094]                               next
[17:40:00.094]                             invokeRestart(restart)
[17:40:00.094]                             muffled <- TRUE
[17:40:00.094]                             break
[17:40:00.094]                           }
[17:40:00.094]                         }
[17:40:00.094]                       }
[17:40:00.094]                       invisible(muffled)
[17:40:00.094]                     }
[17:40:00.094]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.094]                   }
[17:40:00.094]                 }
[17:40:00.094]             }
[17:40:00.094]         }))
[17:40:00.094]     }, error = function(ex) {
[17:40:00.094]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:00.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.094]                 ...future.rng), started = ...future.startTime, 
[17:40:00.094]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:00.094]             version = "1.8"), class = "FutureResult")
[17:40:00.094]     }, finally = {
[17:40:00.094]         if (!identical(...future.workdir, getwd())) 
[17:40:00.094]             setwd(...future.workdir)
[17:40:00.094]         {
[17:40:00.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:00.094]                 ...future.oldOptions$nwarnings <- NULL
[17:40:00.094]             }
[17:40:00.094]             base::options(...future.oldOptions)
[17:40:00.094]             if (.Platform$OS.type == "windows") {
[17:40:00.094]                 old_names <- names(...future.oldEnvVars)
[17:40:00.094]                 envs <- base::Sys.getenv()
[17:40:00.094]                 names <- names(envs)
[17:40:00.094]                 common <- intersect(names, old_names)
[17:40:00.094]                 added <- setdiff(names, old_names)
[17:40:00.094]                 removed <- setdiff(old_names, names)
[17:40:00.094]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:00.094]                   envs[common]]
[17:40:00.094]                 NAMES <- toupper(changed)
[17:40:00.094]                 args <- list()
[17:40:00.094]                 for (kk in seq_along(NAMES)) {
[17:40:00.094]                   name <- changed[[kk]]
[17:40:00.094]                   NAME <- NAMES[[kk]]
[17:40:00.094]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.094]                     next
[17:40:00.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.094]                 }
[17:40:00.094]                 NAMES <- toupper(added)
[17:40:00.094]                 for (kk in seq_along(NAMES)) {
[17:40:00.094]                   name <- added[[kk]]
[17:40:00.094]                   NAME <- NAMES[[kk]]
[17:40:00.094]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.094]                     next
[17:40:00.094]                   args[[name]] <- ""
[17:40:00.094]                 }
[17:40:00.094]                 NAMES <- toupper(removed)
[17:40:00.094]                 for (kk in seq_along(NAMES)) {
[17:40:00.094]                   name <- removed[[kk]]
[17:40:00.094]                   NAME <- NAMES[[kk]]
[17:40:00.094]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.094]                     next
[17:40:00.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.094]                 }
[17:40:00.094]                 if (length(args) > 0) 
[17:40:00.094]                   base::do.call(base::Sys.setenv, args = args)
[17:40:00.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:00.094]             }
[17:40:00.094]             else {
[17:40:00.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:00.094]             }
[17:40:00.094]             {
[17:40:00.094]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:00.094]                   0L) {
[17:40:00.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:00.094]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:00.094]                   base::options(opts)
[17:40:00.094]                 }
[17:40:00.094]                 {
[17:40:00.094]                   {
[17:40:00.094]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:00.094]                     NULL
[17:40:00.094]                   }
[17:40:00.094]                   options(future.plan = NULL)
[17:40:00.094]                   if (is.na(NA_character_)) 
[17:40:00.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:00.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:00.094]                     .init = FALSE)
[17:40:00.094]                 }
[17:40:00.094]             }
[17:40:00.094]         }
[17:40:00.094]     })
[17:40:00.094]     if (TRUE) {
[17:40:00.094]         base::sink(type = "output", split = FALSE)
[17:40:00.094]         if (TRUE) {
[17:40:00.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:00.094]         }
[17:40:00.094]         else {
[17:40:00.094]             ...future.result["stdout"] <- base::list(NULL)
[17:40:00.094]         }
[17:40:00.094]         base::close(...future.stdout)
[17:40:00.094]         ...future.stdout <- NULL
[17:40:00.094]     }
[17:40:00.094]     ...future.result$conditions <- ...future.conditions
[17:40:00.094]     ...future.result$finished <- base::Sys.time()
[17:40:00.094]     ...future.result
[17:40:00.094] }
[17:40:00.097] MultisessionFuture started
[17:40:00.097] - Launch lazy future ... done
[17:40:00.097] run() for ‘MultisessionFuture’ ... done
[17:40:00.138] receiveMessageFromWorker() for ClusterFuture ...
[17:40:00.138] - Validating connection of MultisessionFuture
[17:40:00.139] - received message: FutureResult
[17:40:00.139] - Received FutureResult
[17:40:00.139] - Erased future from FutureRegistry
[17:40:00.139] result() for ClusterFuture ...
[17:40:00.139] - result already collected: FutureResult
[17:40:00.139] result() for ClusterFuture ... done
[17:40:00.139] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:00.139] Future #1
[17:40:00.139] result() for ClusterFuture ...
[17:40:00.139] - result already collected: FutureResult
[17:40:00.139] result() for ClusterFuture ... done
[17:40:00.140] result() for ClusterFuture ...
[17:40:00.140] - result already collected: FutureResult
[17:40:00.140] result() for ClusterFuture ... done
[17:40:00.140] A MultisessionFuture was resolved
[17:40:00.140]  length: 0 (resolved future 1)
[17:40:00.140] resolve() on list ... DONE
[17:40:00.140] - globals: [1] ‘a’
[17:40:00.140] Resolving futures part of globals (recursively) ... DONE
[17:40:00.142] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[17:40:00.143] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[17:40:00.143] - globals: [1] ‘a’
[17:40:00.143] - packages: [1] ‘future’
[17:40:00.143] getGlobalsAndPackages() ... DONE
[17:40:00.143] run() for ‘Future’ ...
[17:40:00.143] - state: ‘created’
[17:40:00.143] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:00.157] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:00.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:00.157]   - Field: ‘node’
[17:40:00.157]   - Field: ‘label’
[17:40:00.157]   - Field: ‘local’
[17:40:00.158]   - Field: ‘owner’
[17:40:00.158]   - Field: ‘envir’
[17:40:00.158]   - Field: ‘workers’
[17:40:00.158]   - Field: ‘packages’
[17:40:00.158]   - Field: ‘gc’
[17:40:00.158]   - Field: ‘conditions’
[17:40:00.158]   - Field: ‘persistent’
[17:40:00.158]   - Field: ‘expr’
[17:40:00.158]   - Field: ‘uuid’
[17:40:00.158]   - Field: ‘seed’
[17:40:00.158]   - Field: ‘version’
[17:40:00.159]   - Field: ‘result’
[17:40:00.159]   - Field: ‘asynchronous’
[17:40:00.159]   - Field: ‘calls’
[17:40:00.159]   - Field: ‘globals’
[17:40:00.159]   - Field: ‘stdout’
[17:40:00.159]   - Field: ‘earlySignal’
[17:40:00.159]   - Field: ‘lazy’
[17:40:00.159]   - Field: ‘state’
[17:40:00.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:00.159] - Launch lazy future ...
[17:40:00.160] Packages needed by the future expression (n = 1): ‘future’
[17:40:00.160] Packages needed by future strategies (n = 0): <none>
[17:40:00.160] {
[17:40:00.160]     {
[17:40:00.160]         {
[17:40:00.160]             ...future.startTime <- base::Sys.time()
[17:40:00.160]             {
[17:40:00.160]                 {
[17:40:00.160]                   {
[17:40:00.160]                     {
[17:40:00.160]                       {
[17:40:00.160]                         base::local({
[17:40:00.160]                           has_future <- base::requireNamespace("future", 
[17:40:00.160]                             quietly = TRUE)
[17:40:00.160]                           if (has_future) {
[17:40:00.160]                             ns <- base::getNamespace("future")
[17:40:00.160]                             version <- ns[[".package"]][["version"]]
[17:40:00.160]                             if (is.null(version)) 
[17:40:00.160]                               version <- utils::packageVersion("future")
[17:40:00.160]                           }
[17:40:00.160]                           else {
[17:40:00.160]                             version <- NULL
[17:40:00.160]                           }
[17:40:00.160]                           if (!has_future || version < "1.8.0") {
[17:40:00.160]                             info <- base::c(r_version = base::gsub("R version ", 
[17:40:00.160]                               "", base::R.version$version.string), 
[17:40:00.160]                               platform = base::sprintf("%s (%s-bit)", 
[17:40:00.160]                                 base::R.version$platform, 8 * 
[17:40:00.160]                                   base::.Machine$sizeof.pointer), 
[17:40:00.160]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:00.160]                                 "release", "version")], collapse = " "), 
[17:40:00.160]                               hostname = base::Sys.info()[["nodename"]])
[17:40:00.160]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:40:00.160]                               info)
[17:40:00.160]                             info <- base::paste(info, collapse = "; ")
[17:40:00.160]                             if (!has_future) {
[17:40:00.160]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:00.160]                                 info)
[17:40:00.160]                             }
[17:40:00.160]                             else {
[17:40:00.160]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:00.160]                                 info, version)
[17:40:00.160]                             }
[17:40:00.160]                             base::stop(msg)
[17:40:00.160]                           }
[17:40:00.160]                         })
[17:40:00.160]                       }
[17:40:00.160]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:00.160]                       base::options(mc.cores = 1L)
[17:40:00.160]                     }
[17:40:00.160]                     base::local({
[17:40:00.160]                       for (pkg in "future") {
[17:40:00.160]                         base::loadNamespace(pkg)
[17:40:00.160]                         base::library(pkg, character.only = TRUE)
[17:40:00.160]                       }
[17:40:00.160]                     })
[17:40:00.160]                   }
[17:40:00.160]                   ...future.strategy.old <- future::plan("list")
[17:40:00.160]                   options(future.plan = NULL)
[17:40:00.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:00.160]                 }
[17:40:00.160]                 ...future.workdir <- getwd()
[17:40:00.160]             }
[17:40:00.160]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:00.160]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:00.160]         }
[17:40:00.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:40:00.160]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:40:00.160]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:40:00.160]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:40:00.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:00.160]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:00.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:00.160]             base::names(...future.oldOptions))
[17:40:00.160]     }
[17:40:00.160]     if (FALSE) {
[17:40:00.160]     }
[17:40:00.160]     else {
[17:40:00.160]         if (TRUE) {
[17:40:00.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:00.160]                 open = "w")
[17:40:00.160]         }
[17:40:00.160]         else {
[17:40:00.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:00.160]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:00.160]         }
[17:40:00.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:00.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:00.160]             base::sink(type = "output", split = FALSE)
[17:40:00.160]             base::close(...future.stdout)
[17:40:00.160]         }, add = TRUE)
[17:40:00.160]     }
[17:40:00.160]     ...future.frame <- base::sys.nframe()
[17:40:00.160]     ...future.conditions <- base::list()
[17:40:00.160]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:00.160]     if (FALSE) {
[17:40:00.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:00.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:00.160]     }
[17:40:00.160]     ...future.result <- base::tryCatch({
[17:40:00.160]         base::withCallingHandlers({
[17:40:00.160]             ...future.value <- base::withVisible(base::local({
[17:40:00.160]                 ...future.makeSendCondition <- base::local({
[17:40:00.160]                   sendCondition <- NULL
[17:40:00.160]                   function(frame = 1L) {
[17:40:00.160]                     if (is.function(sendCondition)) 
[17:40:00.160]                       return(sendCondition)
[17:40:00.160]                     ns <- getNamespace("parallel")
[17:40:00.160]                     if (exists("sendData", mode = "function", 
[17:40:00.160]                       envir = ns)) {
[17:40:00.160]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:00.160]                         envir = ns)
[17:40:00.160]                       envir <- sys.frame(frame)
[17:40:00.160]                       master <- NULL
[17:40:00.160]                       while (!identical(envir, .GlobalEnv) && 
[17:40:00.160]                         !identical(envir, emptyenv())) {
[17:40:00.160]                         if (exists("master", mode = "list", envir = envir, 
[17:40:00.160]                           inherits = FALSE)) {
[17:40:00.160]                           master <- get("master", mode = "list", 
[17:40:00.160]                             envir = envir, inherits = FALSE)
[17:40:00.160]                           if (inherits(master, c("SOCKnode", 
[17:40:00.160]                             "SOCK0node"))) {
[17:40:00.160]                             sendCondition <<- function(cond) {
[17:40:00.160]                               data <- list(type = "VALUE", value = cond, 
[17:40:00.160]                                 success = TRUE)
[17:40:00.160]                               parallel_sendData(master, data)
[17:40:00.160]                             }
[17:40:00.160]                             return(sendCondition)
[17:40:00.160]                           }
[17:40:00.160]                         }
[17:40:00.160]                         frame <- frame + 1L
[17:40:00.160]                         envir <- sys.frame(frame)
[17:40:00.160]                       }
[17:40:00.160]                     }
[17:40:00.160]                     sendCondition <<- function(cond) NULL
[17:40:00.160]                   }
[17:40:00.160]                 })
[17:40:00.160]                 withCallingHandlers({
[17:40:00.160]                   value(a) + 1
[17:40:00.160]                 }, immediateCondition = function(cond) {
[17:40:00.160]                   sendCondition <- ...future.makeSendCondition()
[17:40:00.160]                   sendCondition(cond)
[17:40:00.160]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.160]                   {
[17:40:00.160]                     inherits <- base::inherits
[17:40:00.160]                     invokeRestart <- base::invokeRestart
[17:40:00.160]                     is.null <- base::is.null
[17:40:00.160]                     muffled <- FALSE
[17:40:00.160]                     if (inherits(cond, "message")) {
[17:40:00.160]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:00.160]                       if (muffled) 
[17:40:00.160]                         invokeRestart("muffleMessage")
[17:40:00.160]                     }
[17:40:00.160]                     else if (inherits(cond, "warning")) {
[17:40:00.160]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:00.160]                       if (muffled) 
[17:40:00.160]                         invokeRestart("muffleWarning")
[17:40:00.160]                     }
[17:40:00.160]                     else if (inherits(cond, "condition")) {
[17:40:00.160]                       if (!is.null(pattern)) {
[17:40:00.160]                         computeRestarts <- base::computeRestarts
[17:40:00.160]                         grepl <- base::grepl
[17:40:00.160]                         restarts <- computeRestarts(cond)
[17:40:00.160]                         for (restart in restarts) {
[17:40:00.160]                           name <- restart$name
[17:40:00.160]                           if (is.null(name)) 
[17:40:00.160]                             next
[17:40:00.160]                           if (!grepl(pattern, name)) 
[17:40:00.160]                             next
[17:40:00.160]                           invokeRestart(restart)
[17:40:00.160]                           muffled <- TRUE
[17:40:00.160]                           break
[17:40:00.160]                         }
[17:40:00.160]                       }
[17:40:00.160]                     }
[17:40:00.160]                     invisible(muffled)
[17:40:00.160]                   }
[17:40:00.160]                   muffleCondition(cond)
[17:40:00.160]                 })
[17:40:00.160]             }))
[17:40:00.160]             future::FutureResult(value = ...future.value$value, 
[17:40:00.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.160]                   ...future.rng), globalenv = if (FALSE) 
[17:40:00.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:00.160]                     ...future.globalenv.names))
[17:40:00.160]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:00.160]         }, condition = base::local({
[17:40:00.160]             c <- base::c
[17:40:00.160]             inherits <- base::inherits
[17:40:00.160]             invokeRestart <- base::invokeRestart
[17:40:00.160]             length <- base::length
[17:40:00.160]             list <- base::list
[17:40:00.160]             seq.int <- base::seq.int
[17:40:00.160]             signalCondition <- base::signalCondition
[17:40:00.160]             sys.calls <- base::sys.calls
[17:40:00.160]             `[[` <- base::`[[`
[17:40:00.160]             `+` <- base::`+`
[17:40:00.160]             `<<-` <- base::`<<-`
[17:40:00.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:00.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:00.160]                   3L)]
[17:40:00.160]             }
[17:40:00.160]             function(cond) {
[17:40:00.160]                 is_error <- inherits(cond, "error")
[17:40:00.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:00.160]                   NULL)
[17:40:00.160]                 if (is_error) {
[17:40:00.160]                   sessionInformation <- function() {
[17:40:00.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:00.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:00.160]                       search = base::search(), system = base::Sys.info())
[17:40:00.160]                   }
[17:40:00.160]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:00.160]                     cond$call), session = sessionInformation(), 
[17:40:00.160]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:00.160]                   signalCondition(cond)
[17:40:00.160]                 }
[17:40:00.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:00.160]                 "immediateCondition"))) {
[17:40:00.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:00.160]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:00.160]                   if (TRUE && !signal) {
[17:40:00.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.160]                     {
[17:40:00.160]                       inherits <- base::inherits
[17:40:00.160]                       invokeRestart <- base::invokeRestart
[17:40:00.160]                       is.null <- base::is.null
[17:40:00.160]                       muffled <- FALSE
[17:40:00.160]                       if (inherits(cond, "message")) {
[17:40:00.160]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.160]                         if (muffled) 
[17:40:00.160]                           invokeRestart("muffleMessage")
[17:40:00.160]                       }
[17:40:00.160]                       else if (inherits(cond, "warning")) {
[17:40:00.160]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.160]                         if (muffled) 
[17:40:00.160]                           invokeRestart("muffleWarning")
[17:40:00.160]                       }
[17:40:00.160]                       else if (inherits(cond, "condition")) {
[17:40:00.160]                         if (!is.null(pattern)) {
[17:40:00.160]                           computeRestarts <- base::computeRestarts
[17:40:00.160]                           grepl <- base::grepl
[17:40:00.160]                           restarts <- computeRestarts(cond)
[17:40:00.160]                           for (restart in restarts) {
[17:40:00.160]                             name <- restart$name
[17:40:00.160]                             if (is.null(name)) 
[17:40:00.160]                               next
[17:40:00.160]                             if (!grepl(pattern, name)) 
[17:40:00.160]                               next
[17:40:00.160]                             invokeRestart(restart)
[17:40:00.160]                             muffled <- TRUE
[17:40:00.160]                             break
[17:40:00.160]                           }
[17:40:00.160]                         }
[17:40:00.160]                       }
[17:40:00.160]                       invisible(muffled)
[17:40:00.160]                     }
[17:40:00.160]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.160]                   }
[17:40:00.160]                 }
[17:40:00.160]                 else {
[17:40:00.160]                   if (TRUE) {
[17:40:00.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.160]                     {
[17:40:00.160]                       inherits <- base::inherits
[17:40:00.160]                       invokeRestart <- base::invokeRestart
[17:40:00.160]                       is.null <- base::is.null
[17:40:00.160]                       muffled <- FALSE
[17:40:00.160]                       if (inherits(cond, "message")) {
[17:40:00.160]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.160]                         if (muffled) 
[17:40:00.160]                           invokeRestart("muffleMessage")
[17:40:00.160]                       }
[17:40:00.160]                       else if (inherits(cond, "warning")) {
[17:40:00.160]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.160]                         if (muffled) 
[17:40:00.160]                           invokeRestart("muffleWarning")
[17:40:00.160]                       }
[17:40:00.160]                       else if (inherits(cond, "condition")) {
[17:40:00.160]                         if (!is.null(pattern)) {
[17:40:00.160]                           computeRestarts <- base::computeRestarts
[17:40:00.160]                           grepl <- base::grepl
[17:40:00.160]                           restarts <- computeRestarts(cond)
[17:40:00.160]                           for (restart in restarts) {
[17:40:00.160]                             name <- restart$name
[17:40:00.160]                             if (is.null(name)) 
[17:40:00.160]                               next
[17:40:00.160]                             if (!grepl(pattern, name)) 
[17:40:00.160]                               next
[17:40:00.160]                             invokeRestart(restart)
[17:40:00.160]                             muffled <- TRUE
[17:40:00.160]                             break
[17:40:00.160]                           }
[17:40:00.160]                         }
[17:40:00.160]                       }
[17:40:00.160]                       invisible(muffled)
[17:40:00.160]                     }
[17:40:00.160]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.160]                   }
[17:40:00.160]                 }
[17:40:00.160]             }
[17:40:00.160]         }))
[17:40:00.160]     }, error = function(ex) {
[17:40:00.160]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:00.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.160]                 ...future.rng), started = ...future.startTime, 
[17:40:00.160]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:00.160]             version = "1.8"), class = "FutureResult")
[17:40:00.160]     }, finally = {
[17:40:00.160]         if (!identical(...future.workdir, getwd())) 
[17:40:00.160]             setwd(...future.workdir)
[17:40:00.160]         {
[17:40:00.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:00.160]                 ...future.oldOptions$nwarnings <- NULL
[17:40:00.160]             }
[17:40:00.160]             base::options(...future.oldOptions)
[17:40:00.160]             if (.Platform$OS.type == "windows") {
[17:40:00.160]                 old_names <- names(...future.oldEnvVars)
[17:40:00.160]                 envs <- base::Sys.getenv()
[17:40:00.160]                 names <- names(envs)
[17:40:00.160]                 common <- intersect(names, old_names)
[17:40:00.160]                 added <- setdiff(names, old_names)
[17:40:00.160]                 removed <- setdiff(old_names, names)
[17:40:00.160]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:00.160]                   envs[common]]
[17:40:00.160]                 NAMES <- toupper(changed)
[17:40:00.160]                 args <- list()
[17:40:00.160]                 for (kk in seq_along(NAMES)) {
[17:40:00.160]                   name <- changed[[kk]]
[17:40:00.160]                   NAME <- NAMES[[kk]]
[17:40:00.160]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.160]                     next
[17:40:00.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.160]                 }
[17:40:00.160]                 NAMES <- toupper(added)
[17:40:00.160]                 for (kk in seq_along(NAMES)) {
[17:40:00.160]                   name <- added[[kk]]
[17:40:00.160]                   NAME <- NAMES[[kk]]
[17:40:00.160]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.160]                     next
[17:40:00.160]                   args[[name]] <- ""
[17:40:00.160]                 }
[17:40:00.160]                 NAMES <- toupper(removed)
[17:40:00.160]                 for (kk in seq_along(NAMES)) {
[17:40:00.160]                   name <- removed[[kk]]
[17:40:00.160]                   NAME <- NAMES[[kk]]
[17:40:00.160]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.160]                     next
[17:40:00.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.160]                 }
[17:40:00.160]                 if (length(args) > 0) 
[17:40:00.160]                   base::do.call(base::Sys.setenv, args = args)
[17:40:00.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:00.160]             }
[17:40:00.160]             else {
[17:40:00.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:00.160]             }
[17:40:00.160]             {
[17:40:00.160]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:00.160]                   0L) {
[17:40:00.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:00.160]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:00.160]                   base::options(opts)
[17:40:00.160]                 }
[17:40:00.160]                 {
[17:40:00.160]                   {
[17:40:00.160]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:00.160]                     NULL
[17:40:00.160]                   }
[17:40:00.160]                   options(future.plan = NULL)
[17:40:00.160]                   if (is.na(NA_character_)) 
[17:40:00.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:00.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:00.160]                     .init = FALSE)
[17:40:00.160]                 }
[17:40:00.160]             }
[17:40:00.160]         }
[17:40:00.160]     })
[17:40:00.160]     if (TRUE) {
[17:40:00.160]         base::sink(type = "output", split = FALSE)
[17:40:00.160]         if (TRUE) {
[17:40:00.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:00.160]         }
[17:40:00.160]         else {
[17:40:00.160]             ...future.result["stdout"] <- base::list(NULL)
[17:40:00.160]         }
[17:40:00.160]         base::close(...future.stdout)
[17:40:00.160]         ...future.stdout <- NULL
[17:40:00.160]     }
[17:40:00.160]     ...future.result$conditions <- ...future.conditions
[17:40:00.160]     ...future.result$finished <- base::Sys.time()
[17:40:00.160]     ...future.result
[17:40:00.160] }
[17:40:00.163] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[17:40:00.165] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[17:40:00.217] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[17:40:00.217] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[17:40:00.220] MultisessionFuture started
[17:40:00.220] - Launch lazy future ... done
[17:40:00.220] run() for ‘MultisessionFuture’ ... done
[17:40:00.220] result() for ClusterFuture ...
[17:40:00.220] receiveMessageFromWorker() for ClusterFuture ...
[17:40:00.220] - Validating connection of MultisessionFuture
[17:40:00.262] - received message: FutureResult
[17:40:00.263] - Received FutureResult
[17:40:00.263] - Erased future from FutureRegistry
[17:40:00.263] result() for ClusterFuture ...
[17:40:00.263] - result already collected: FutureResult
[17:40:00.263] result() for ClusterFuture ... done
[17:40:00.263] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:00.263] result() for ClusterFuture ... done
[17:40:00.263] result() for ClusterFuture ...
[17:40:00.263] - result already collected: FutureResult
[17:40:00.263] result() for ClusterFuture ... done
value(b) = 2
[17:40:00.264] result() for ClusterFuture ...
[17:40:00.264] - result already collected: FutureResult
[17:40:00.264] result() for ClusterFuture ... done
[17:40:00.264] result() for ClusterFuture ...
[17:40:00.264] - result already collected: FutureResult
[17:40:00.264] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:40:00.264] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:40:00.265] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:40:00.265] - globals found: [2] ‘{’, ‘pkg’
[17:40:00.265] Searching for globals ... DONE
[17:40:00.266] Resolving globals: TRUE
[17:40:00.266] Resolving any globals that are futures ...
[17:40:00.266] - globals: [2] ‘{’, ‘pkg’
[17:40:00.266] Resolving any globals that are futures ... DONE
[17:40:00.266] Resolving futures part of globals (recursively) ...
[17:40:00.266] resolve() on list ...
[17:40:00.266]  recursive: 99
[17:40:00.266]  length: 1
[17:40:00.267]  elements: ‘pkg’
[17:40:00.267]  length: 0 (resolved future 1)
[17:40:00.267] resolve() on list ... DONE
[17:40:00.267] - globals: [1] ‘pkg’
[17:40:00.267] Resolving futures part of globals (recursively) ... DONE
[17:40:00.267] The total size of the 1 globals is 112 bytes (112 bytes)
[17:40:00.267] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:40:00.267] - globals: [1] ‘pkg’
[17:40:00.268] 
[17:40:00.268] getGlobalsAndPackages() ... DONE
[17:40:00.268] Packages needed by the future expression (n = 0): <none>
[17:40:00.268] Packages needed by future strategies (n = 0): <none>
[17:40:00.268] {
[17:40:00.268]     {
[17:40:00.268]         {
[17:40:00.268]             ...future.startTime <- base::Sys.time()
[17:40:00.268]             {
[17:40:00.268]                 {
[17:40:00.268]                   {
[17:40:00.268]                     base::local({
[17:40:00.268]                       has_future <- base::requireNamespace("future", 
[17:40:00.268]                         quietly = TRUE)
[17:40:00.268]                       if (has_future) {
[17:40:00.268]                         ns <- base::getNamespace("future")
[17:40:00.268]                         version <- ns[[".package"]][["version"]]
[17:40:00.268]                         if (is.null(version)) 
[17:40:00.268]                           version <- utils::packageVersion("future")
[17:40:00.268]                       }
[17:40:00.268]                       else {
[17:40:00.268]                         version <- NULL
[17:40:00.268]                       }
[17:40:00.268]                       if (!has_future || version < "1.8.0") {
[17:40:00.268]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:00.268]                           "", base::R.version$version.string), 
[17:40:00.268]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:00.268]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:00.268]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:00.268]                             "release", "version")], collapse = " "), 
[17:40:00.268]                           hostname = base::Sys.info()[["nodename"]])
[17:40:00.268]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:00.268]                           info)
[17:40:00.268]                         info <- base::paste(info, collapse = "; ")
[17:40:00.268]                         if (!has_future) {
[17:40:00.268]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:00.268]                             info)
[17:40:00.268]                         }
[17:40:00.268]                         else {
[17:40:00.268]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:00.268]                             info, version)
[17:40:00.268]                         }
[17:40:00.268]                         base::stop(msg)
[17:40:00.268]                       }
[17:40:00.268]                     })
[17:40:00.268]                   }
[17:40:00.268]                   ...future.strategy.old <- future::plan("list")
[17:40:00.268]                   options(future.plan = NULL)
[17:40:00.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:00.268]                 }
[17:40:00.268]                 ...future.workdir <- getwd()
[17:40:00.268]             }
[17:40:00.268]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:00.268]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:00.268]         }
[17:40:00.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:40:00.268]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:40:00.268]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:40:00.268]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:40:00.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:00.268]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:00.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:00.268]             base::names(...future.oldOptions))
[17:40:00.268]     }
[17:40:00.268]     if (FALSE) {
[17:40:00.268]     }
[17:40:00.268]     else {
[17:40:00.268]         if (TRUE) {
[17:40:00.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:00.268]                 open = "w")
[17:40:00.268]         }
[17:40:00.268]         else {
[17:40:00.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:00.268]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:00.268]         }
[17:40:00.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:00.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:00.268]             base::sink(type = "output", split = FALSE)
[17:40:00.268]             base::close(...future.stdout)
[17:40:00.268]         }, add = TRUE)
[17:40:00.268]     }
[17:40:00.268]     ...future.frame <- base::sys.nframe()
[17:40:00.268]     ...future.conditions <- base::list()
[17:40:00.268]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:00.268]     if (FALSE) {
[17:40:00.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:00.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:00.268]     }
[17:40:00.268]     ...future.result <- base::tryCatch({
[17:40:00.268]         base::withCallingHandlers({
[17:40:00.268]             ...future.value <- base::withVisible(base::local({
[17:40:00.268]                 pkg
[17:40:00.268]             }))
[17:40:00.268]             future::FutureResult(value = ...future.value$value, 
[17:40:00.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.268]                   ...future.rng), globalenv = if (FALSE) 
[17:40:00.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:00.268]                     ...future.globalenv.names))
[17:40:00.268]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:00.268]         }, condition = base::local({
[17:40:00.268]             c <- base::c
[17:40:00.268]             inherits <- base::inherits
[17:40:00.268]             invokeRestart <- base::invokeRestart
[17:40:00.268]             length <- base::length
[17:40:00.268]             list <- base::list
[17:40:00.268]             seq.int <- base::seq.int
[17:40:00.268]             signalCondition <- base::signalCondition
[17:40:00.268]             sys.calls <- base::sys.calls
[17:40:00.268]             `[[` <- base::`[[`
[17:40:00.268]             `+` <- base::`+`
[17:40:00.268]             `<<-` <- base::`<<-`
[17:40:00.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:00.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:00.268]                   3L)]
[17:40:00.268]             }
[17:40:00.268]             function(cond) {
[17:40:00.268]                 is_error <- inherits(cond, "error")
[17:40:00.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:00.268]                   NULL)
[17:40:00.268]                 if (is_error) {
[17:40:00.268]                   sessionInformation <- function() {
[17:40:00.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:00.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:00.268]                       search = base::search(), system = base::Sys.info())
[17:40:00.268]                   }
[17:40:00.268]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:00.268]                     cond$call), session = sessionInformation(), 
[17:40:00.268]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:00.268]                   signalCondition(cond)
[17:40:00.268]                 }
[17:40:00.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:00.268]                 "immediateCondition"))) {
[17:40:00.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:00.268]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:00.268]                   if (TRUE && !signal) {
[17:40:00.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.268]                     {
[17:40:00.268]                       inherits <- base::inherits
[17:40:00.268]                       invokeRestart <- base::invokeRestart
[17:40:00.268]                       is.null <- base::is.null
[17:40:00.268]                       muffled <- FALSE
[17:40:00.268]                       if (inherits(cond, "message")) {
[17:40:00.268]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.268]                         if (muffled) 
[17:40:00.268]                           invokeRestart("muffleMessage")
[17:40:00.268]                       }
[17:40:00.268]                       else if (inherits(cond, "warning")) {
[17:40:00.268]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.268]                         if (muffled) 
[17:40:00.268]                           invokeRestart("muffleWarning")
[17:40:00.268]                       }
[17:40:00.268]                       else if (inherits(cond, "condition")) {
[17:40:00.268]                         if (!is.null(pattern)) {
[17:40:00.268]                           computeRestarts <- base::computeRestarts
[17:40:00.268]                           grepl <- base::grepl
[17:40:00.268]                           restarts <- computeRestarts(cond)
[17:40:00.268]                           for (restart in restarts) {
[17:40:00.268]                             name <- restart$name
[17:40:00.268]                             if (is.null(name)) 
[17:40:00.268]                               next
[17:40:00.268]                             if (!grepl(pattern, name)) 
[17:40:00.268]                               next
[17:40:00.268]                             invokeRestart(restart)
[17:40:00.268]                             muffled <- TRUE
[17:40:00.268]                             break
[17:40:00.268]                           }
[17:40:00.268]                         }
[17:40:00.268]                       }
[17:40:00.268]                       invisible(muffled)
[17:40:00.268]                     }
[17:40:00.268]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.268]                   }
[17:40:00.268]                 }
[17:40:00.268]                 else {
[17:40:00.268]                   if (TRUE) {
[17:40:00.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.268]                     {
[17:40:00.268]                       inherits <- base::inherits
[17:40:00.268]                       invokeRestart <- base::invokeRestart
[17:40:00.268]                       is.null <- base::is.null
[17:40:00.268]                       muffled <- FALSE
[17:40:00.268]                       if (inherits(cond, "message")) {
[17:40:00.268]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.268]                         if (muffled) 
[17:40:00.268]                           invokeRestart("muffleMessage")
[17:40:00.268]                       }
[17:40:00.268]                       else if (inherits(cond, "warning")) {
[17:40:00.268]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.268]                         if (muffled) 
[17:40:00.268]                           invokeRestart("muffleWarning")
[17:40:00.268]                       }
[17:40:00.268]                       else if (inherits(cond, "condition")) {
[17:40:00.268]                         if (!is.null(pattern)) {
[17:40:00.268]                           computeRestarts <- base::computeRestarts
[17:40:00.268]                           grepl <- base::grepl
[17:40:00.268]                           restarts <- computeRestarts(cond)
[17:40:00.268]                           for (restart in restarts) {
[17:40:00.268]                             name <- restart$name
[17:40:00.268]                             if (is.null(name)) 
[17:40:00.268]                               next
[17:40:00.268]                             if (!grepl(pattern, name)) 
[17:40:00.268]                               next
[17:40:00.268]                             invokeRestart(restart)
[17:40:00.268]                             muffled <- TRUE
[17:40:00.268]                             break
[17:40:00.268]                           }
[17:40:00.268]                         }
[17:40:00.268]                       }
[17:40:00.268]                       invisible(muffled)
[17:40:00.268]                     }
[17:40:00.268]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.268]                   }
[17:40:00.268]                 }
[17:40:00.268]             }
[17:40:00.268]         }))
[17:40:00.268]     }, error = function(ex) {
[17:40:00.268]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:00.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.268]                 ...future.rng), started = ...future.startTime, 
[17:40:00.268]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:00.268]             version = "1.8"), class = "FutureResult")
[17:40:00.268]     }, finally = {
[17:40:00.268]         if (!identical(...future.workdir, getwd())) 
[17:40:00.268]             setwd(...future.workdir)
[17:40:00.268]         {
[17:40:00.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:00.268]                 ...future.oldOptions$nwarnings <- NULL
[17:40:00.268]             }
[17:40:00.268]             base::options(...future.oldOptions)
[17:40:00.268]             if (.Platform$OS.type == "windows") {
[17:40:00.268]                 old_names <- names(...future.oldEnvVars)
[17:40:00.268]                 envs <- base::Sys.getenv()
[17:40:00.268]                 names <- names(envs)
[17:40:00.268]                 common <- intersect(names, old_names)
[17:40:00.268]                 added <- setdiff(names, old_names)
[17:40:00.268]                 removed <- setdiff(old_names, names)
[17:40:00.268]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:00.268]                   envs[common]]
[17:40:00.268]                 NAMES <- toupper(changed)
[17:40:00.268]                 args <- list()
[17:40:00.268]                 for (kk in seq_along(NAMES)) {
[17:40:00.268]                   name <- changed[[kk]]
[17:40:00.268]                   NAME <- NAMES[[kk]]
[17:40:00.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.268]                     next
[17:40:00.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.268]                 }
[17:40:00.268]                 NAMES <- toupper(added)
[17:40:00.268]                 for (kk in seq_along(NAMES)) {
[17:40:00.268]                   name <- added[[kk]]
[17:40:00.268]                   NAME <- NAMES[[kk]]
[17:40:00.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.268]                     next
[17:40:00.268]                   args[[name]] <- ""
[17:40:00.268]                 }
[17:40:00.268]                 NAMES <- toupper(removed)
[17:40:00.268]                 for (kk in seq_along(NAMES)) {
[17:40:00.268]                   name <- removed[[kk]]
[17:40:00.268]                   NAME <- NAMES[[kk]]
[17:40:00.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.268]                     next
[17:40:00.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.268]                 }
[17:40:00.268]                 if (length(args) > 0) 
[17:40:00.268]                   base::do.call(base::Sys.setenv, args = args)
[17:40:00.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:00.268]             }
[17:40:00.268]             else {
[17:40:00.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:00.268]             }
[17:40:00.268]             {
[17:40:00.268]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:00.268]                   0L) {
[17:40:00.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:00.268]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:00.268]                   base::options(opts)
[17:40:00.268]                 }
[17:40:00.268]                 {
[17:40:00.268]                   {
[17:40:00.268]                     NULL
[17:40:00.268]                     RNGkind("Mersenne-Twister")
[17:40:00.268]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:00.268]                       inherits = FALSE)
[17:40:00.268]                   }
[17:40:00.268]                   options(future.plan = NULL)
[17:40:00.268]                   if (is.na(NA_character_)) 
[17:40:00.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:00.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:00.268]                     .init = FALSE)
[17:40:00.268]                 }
[17:40:00.268]             }
[17:40:00.268]         }
[17:40:00.268]     })
[17:40:00.268]     if (TRUE) {
[17:40:00.268]         base::sink(type = "output", split = FALSE)
[17:40:00.268]         if (TRUE) {
[17:40:00.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:00.268]         }
[17:40:00.268]         else {
[17:40:00.268]             ...future.result["stdout"] <- base::list(NULL)
[17:40:00.268]         }
[17:40:00.268]         base::close(...future.stdout)
[17:40:00.268]         ...future.stdout <- NULL
[17:40:00.268]     }
[17:40:00.268]     ...future.result$conditions <- ...future.conditions
[17:40:00.268]     ...future.result$finished <- base::Sys.time()
[17:40:00.268]     ...future.result
[17:40:00.268] }
[17:40:00.270] assign_globals() ...
[17:40:00.270] List of 1
[17:40:00.270]  $ pkg: chr "foo"
[17:40:00.270]  - attr(*, "where")=List of 1
[17:40:00.270]   ..$ pkg:<environment: R_EmptyEnv> 
[17:40:00.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:00.270]  - attr(*, "resolved")= logi TRUE
[17:40:00.270]  - attr(*, "total_size")= num 112
[17:40:00.272] - copied ‘pkg’ to environment
[17:40:00.272] assign_globals() ... done
[17:40:00.273] plan(): Setting new future strategy stack:
[17:40:00.273] List of future strategies:
[17:40:00.273] 1. sequential:
[17:40:00.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:00.273]    - tweaked: FALSE
[17:40:00.273]    - call: NULL
[17:40:00.273] plan(): nbrOfWorkers() = 1
[17:40:00.274] plan(): Setting new future strategy stack:
[17:40:00.274] List of future strategies:
[17:40:00.274] 1. multisession:
[17:40:00.274]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:00.274]    - tweaked: FALSE
[17:40:00.274]    - call: plan(strategy)
[17:40:00.277] plan(): nbrOfWorkers() = 2
[17:40:00.278] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:40:00.278] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:40:00.278] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:40:00.280] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:40:00.280] Searching for globals ... DONE
[17:40:00.280] Resolving globals: TRUE
[17:40:00.280] Resolving any globals that are futures ...
[17:40:00.280] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:40:00.280] Resolving any globals that are futures ... DONE
[17:40:00.281] 
[17:40:00.281] 
[17:40:00.281] getGlobalsAndPackages() ... DONE
[17:40:00.281] run() for ‘Future’ ...
[17:40:00.281] - state: ‘created’
[17:40:00.281] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:00.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:00.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:00.295]   - Field: ‘node’
[17:40:00.296]   - Field: ‘label’
[17:40:00.296]   - Field: ‘local’
[17:40:00.296]   - Field: ‘owner’
[17:40:00.296]   - Field: ‘envir’
[17:40:00.296]   - Field: ‘workers’
[17:40:00.296]   - Field: ‘packages’
[17:40:00.296]   - Field: ‘gc’
[17:40:00.296]   - Field: ‘conditions’
[17:40:00.296]   - Field: ‘persistent’
[17:40:00.296]   - Field: ‘expr’
[17:40:00.296]   - Field: ‘uuid’
[17:40:00.297]   - Field: ‘seed’
[17:40:00.297]   - Field: ‘version’
[17:40:00.297]   - Field: ‘result’
[17:40:00.297]   - Field: ‘asynchronous’
[17:40:00.297]   - Field: ‘calls’
[17:40:00.297]   - Field: ‘globals’
[17:40:00.297]   - Field: ‘stdout’
[17:40:00.297]   - Field: ‘earlySignal’
[17:40:00.297]   - Field: ‘lazy’
[17:40:00.297]   - Field: ‘state’
[17:40:00.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:00.298] - Launch lazy future ...
[17:40:00.298] Packages needed by the future expression (n = 0): <none>
[17:40:00.298] Packages needed by future strategies (n = 0): <none>
[17:40:00.298] {
[17:40:00.298]     {
[17:40:00.298]         {
[17:40:00.298]             ...future.startTime <- base::Sys.time()
[17:40:00.298]             {
[17:40:00.298]                 {
[17:40:00.298]                   {
[17:40:00.298]                     {
[17:40:00.298]                       base::local({
[17:40:00.298]                         has_future <- base::requireNamespace("future", 
[17:40:00.298]                           quietly = TRUE)
[17:40:00.298]                         if (has_future) {
[17:40:00.298]                           ns <- base::getNamespace("future")
[17:40:00.298]                           version <- ns[[".package"]][["version"]]
[17:40:00.298]                           if (is.null(version)) 
[17:40:00.298]                             version <- utils::packageVersion("future")
[17:40:00.298]                         }
[17:40:00.298]                         else {
[17:40:00.298]                           version <- NULL
[17:40:00.298]                         }
[17:40:00.298]                         if (!has_future || version < "1.8.0") {
[17:40:00.298]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:00.298]                             "", base::R.version$version.string), 
[17:40:00.298]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:00.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:00.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:00.298]                               "release", "version")], collapse = " "), 
[17:40:00.298]                             hostname = base::Sys.info()[["nodename"]])
[17:40:00.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:00.298]                             info)
[17:40:00.298]                           info <- base::paste(info, collapse = "; ")
[17:40:00.298]                           if (!has_future) {
[17:40:00.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:00.298]                               info)
[17:40:00.298]                           }
[17:40:00.298]                           else {
[17:40:00.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:00.298]                               info, version)
[17:40:00.298]                           }
[17:40:00.298]                           base::stop(msg)
[17:40:00.298]                         }
[17:40:00.298]                       })
[17:40:00.298]                     }
[17:40:00.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:00.298]                     base::options(mc.cores = 1L)
[17:40:00.298]                   }
[17:40:00.298]                   ...future.strategy.old <- future::plan("list")
[17:40:00.298]                   options(future.plan = NULL)
[17:40:00.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:00.298]                 }
[17:40:00.298]                 ...future.workdir <- getwd()
[17:40:00.298]             }
[17:40:00.298]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:00.298]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:00.298]         }
[17:40:00.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:40:00.298]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:40:00.298]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:40:00.298]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:40:00.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:00.298]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:00.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:00.298]             base::names(...future.oldOptions))
[17:40:00.298]     }
[17:40:00.298]     if (FALSE) {
[17:40:00.298]     }
[17:40:00.298]     else {
[17:40:00.298]         if (TRUE) {
[17:40:00.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:00.298]                 open = "w")
[17:40:00.298]         }
[17:40:00.298]         else {
[17:40:00.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:00.298]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:00.298]         }
[17:40:00.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:00.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:00.298]             base::sink(type = "output", split = FALSE)
[17:40:00.298]             base::close(...future.stdout)
[17:40:00.298]         }, add = TRUE)
[17:40:00.298]     }
[17:40:00.298]     ...future.frame <- base::sys.nframe()
[17:40:00.298]     ...future.conditions <- base::list()
[17:40:00.298]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:00.298]     if (FALSE) {
[17:40:00.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:00.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:00.298]     }
[17:40:00.298]     ...future.result <- base::tryCatch({
[17:40:00.298]         base::withCallingHandlers({
[17:40:00.298]             ...future.value <- base::withVisible(base::local({
[17:40:00.298]                 ...future.makeSendCondition <- base::local({
[17:40:00.298]                   sendCondition <- NULL
[17:40:00.298]                   function(frame = 1L) {
[17:40:00.298]                     if (is.function(sendCondition)) 
[17:40:00.298]                       return(sendCondition)
[17:40:00.298]                     ns <- getNamespace("parallel")
[17:40:00.298]                     if (exists("sendData", mode = "function", 
[17:40:00.298]                       envir = ns)) {
[17:40:00.298]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:00.298]                         envir = ns)
[17:40:00.298]                       envir <- sys.frame(frame)
[17:40:00.298]                       master <- NULL
[17:40:00.298]                       while (!identical(envir, .GlobalEnv) && 
[17:40:00.298]                         !identical(envir, emptyenv())) {
[17:40:00.298]                         if (exists("master", mode = "list", envir = envir, 
[17:40:00.298]                           inherits = FALSE)) {
[17:40:00.298]                           master <- get("master", mode = "list", 
[17:40:00.298]                             envir = envir, inherits = FALSE)
[17:40:00.298]                           if (inherits(master, c("SOCKnode", 
[17:40:00.298]                             "SOCK0node"))) {
[17:40:00.298]                             sendCondition <<- function(cond) {
[17:40:00.298]                               data <- list(type = "VALUE", value = cond, 
[17:40:00.298]                                 success = TRUE)
[17:40:00.298]                               parallel_sendData(master, data)
[17:40:00.298]                             }
[17:40:00.298]                             return(sendCondition)
[17:40:00.298]                           }
[17:40:00.298]                         }
[17:40:00.298]                         frame <- frame + 1L
[17:40:00.298]                         envir <- sys.frame(frame)
[17:40:00.298]                       }
[17:40:00.298]                     }
[17:40:00.298]                     sendCondition <<- function(cond) NULL
[17:40:00.298]                   }
[17:40:00.298]                 })
[17:40:00.298]                 withCallingHandlers({
[17:40:00.298]                   {
[17:40:00.298]                     x <- 0
[17:40:00.298]                     x <- x + 1
[17:40:00.298]                     x
[17:40:00.298]                   }
[17:40:00.298]                 }, immediateCondition = function(cond) {
[17:40:00.298]                   sendCondition <- ...future.makeSendCondition()
[17:40:00.298]                   sendCondition(cond)
[17:40:00.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.298]                   {
[17:40:00.298]                     inherits <- base::inherits
[17:40:00.298]                     invokeRestart <- base::invokeRestart
[17:40:00.298]                     is.null <- base::is.null
[17:40:00.298]                     muffled <- FALSE
[17:40:00.298]                     if (inherits(cond, "message")) {
[17:40:00.298]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:00.298]                       if (muffled) 
[17:40:00.298]                         invokeRestart("muffleMessage")
[17:40:00.298]                     }
[17:40:00.298]                     else if (inherits(cond, "warning")) {
[17:40:00.298]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:00.298]                       if (muffled) 
[17:40:00.298]                         invokeRestart("muffleWarning")
[17:40:00.298]                     }
[17:40:00.298]                     else if (inherits(cond, "condition")) {
[17:40:00.298]                       if (!is.null(pattern)) {
[17:40:00.298]                         computeRestarts <- base::computeRestarts
[17:40:00.298]                         grepl <- base::grepl
[17:40:00.298]                         restarts <- computeRestarts(cond)
[17:40:00.298]                         for (restart in restarts) {
[17:40:00.298]                           name <- restart$name
[17:40:00.298]                           if (is.null(name)) 
[17:40:00.298]                             next
[17:40:00.298]                           if (!grepl(pattern, name)) 
[17:40:00.298]                             next
[17:40:00.298]                           invokeRestart(restart)
[17:40:00.298]                           muffled <- TRUE
[17:40:00.298]                           break
[17:40:00.298]                         }
[17:40:00.298]                       }
[17:40:00.298]                     }
[17:40:00.298]                     invisible(muffled)
[17:40:00.298]                   }
[17:40:00.298]                   muffleCondition(cond)
[17:40:00.298]                 })
[17:40:00.298]             }))
[17:40:00.298]             future::FutureResult(value = ...future.value$value, 
[17:40:00.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.298]                   ...future.rng), globalenv = if (FALSE) 
[17:40:00.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:00.298]                     ...future.globalenv.names))
[17:40:00.298]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:00.298]         }, condition = base::local({
[17:40:00.298]             c <- base::c
[17:40:00.298]             inherits <- base::inherits
[17:40:00.298]             invokeRestart <- base::invokeRestart
[17:40:00.298]             length <- base::length
[17:40:00.298]             list <- base::list
[17:40:00.298]             seq.int <- base::seq.int
[17:40:00.298]             signalCondition <- base::signalCondition
[17:40:00.298]             sys.calls <- base::sys.calls
[17:40:00.298]             `[[` <- base::`[[`
[17:40:00.298]             `+` <- base::`+`
[17:40:00.298]             `<<-` <- base::`<<-`
[17:40:00.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:00.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:00.298]                   3L)]
[17:40:00.298]             }
[17:40:00.298]             function(cond) {
[17:40:00.298]                 is_error <- inherits(cond, "error")
[17:40:00.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:00.298]                   NULL)
[17:40:00.298]                 if (is_error) {
[17:40:00.298]                   sessionInformation <- function() {
[17:40:00.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:00.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:00.298]                       search = base::search(), system = base::Sys.info())
[17:40:00.298]                   }
[17:40:00.298]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:00.298]                     cond$call), session = sessionInformation(), 
[17:40:00.298]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:00.298]                   signalCondition(cond)
[17:40:00.298]                 }
[17:40:00.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:00.298]                 "immediateCondition"))) {
[17:40:00.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:00.298]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:00.298]                   if (TRUE && !signal) {
[17:40:00.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.298]                     {
[17:40:00.298]                       inherits <- base::inherits
[17:40:00.298]                       invokeRestart <- base::invokeRestart
[17:40:00.298]                       is.null <- base::is.null
[17:40:00.298]                       muffled <- FALSE
[17:40:00.298]                       if (inherits(cond, "message")) {
[17:40:00.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.298]                         if (muffled) 
[17:40:00.298]                           invokeRestart("muffleMessage")
[17:40:00.298]                       }
[17:40:00.298]                       else if (inherits(cond, "warning")) {
[17:40:00.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.298]                         if (muffled) 
[17:40:00.298]                           invokeRestart("muffleWarning")
[17:40:00.298]                       }
[17:40:00.298]                       else if (inherits(cond, "condition")) {
[17:40:00.298]                         if (!is.null(pattern)) {
[17:40:00.298]                           computeRestarts <- base::computeRestarts
[17:40:00.298]                           grepl <- base::grepl
[17:40:00.298]                           restarts <- computeRestarts(cond)
[17:40:00.298]                           for (restart in restarts) {
[17:40:00.298]                             name <- restart$name
[17:40:00.298]                             if (is.null(name)) 
[17:40:00.298]                               next
[17:40:00.298]                             if (!grepl(pattern, name)) 
[17:40:00.298]                               next
[17:40:00.298]                             invokeRestart(restart)
[17:40:00.298]                             muffled <- TRUE
[17:40:00.298]                             break
[17:40:00.298]                           }
[17:40:00.298]                         }
[17:40:00.298]                       }
[17:40:00.298]                       invisible(muffled)
[17:40:00.298]                     }
[17:40:00.298]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.298]                   }
[17:40:00.298]                 }
[17:40:00.298]                 else {
[17:40:00.298]                   if (TRUE) {
[17:40:00.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.298]                     {
[17:40:00.298]                       inherits <- base::inherits
[17:40:00.298]                       invokeRestart <- base::invokeRestart
[17:40:00.298]                       is.null <- base::is.null
[17:40:00.298]                       muffled <- FALSE
[17:40:00.298]                       if (inherits(cond, "message")) {
[17:40:00.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.298]                         if (muffled) 
[17:40:00.298]                           invokeRestart("muffleMessage")
[17:40:00.298]                       }
[17:40:00.298]                       else if (inherits(cond, "warning")) {
[17:40:00.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.298]                         if (muffled) 
[17:40:00.298]                           invokeRestart("muffleWarning")
[17:40:00.298]                       }
[17:40:00.298]                       else if (inherits(cond, "condition")) {
[17:40:00.298]                         if (!is.null(pattern)) {
[17:40:00.298]                           computeRestarts <- base::computeRestarts
[17:40:00.298]                           grepl <- base::grepl
[17:40:00.298]                           restarts <- computeRestarts(cond)
[17:40:00.298]                           for (restart in restarts) {
[17:40:00.298]                             name <- restart$name
[17:40:00.298]                             if (is.null(name)) 
[17:40:00.298]                               next
[17:40:00.298]                             if (!grepl(pattern, name)) 
[17:40:00.298]                               next
[17:40:00.298]                             invokeRestart(restart)
[17:40:00.298]                             muffled <- TRUE
[17:40:00.298]                             break
[17:40:00.298]                           }
[17:40:00.298]                         }
[17:40:00.298]                       }
[17:40:00.298]                       invisible(muffled)
[17:40:00.298]                     }
[17:40:00.298]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.298]                   }
[17:40:00.298]                 }
[17:40:00.298]             }
[17:40:00.298]         }))
[17:40:00.298]     }, error = function(ex) {
[17:40:00.298]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:00.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.298]                 ...future.rng), started = ...future.startTime, 
[17:40:00.298]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:00.298]             version = "1.8"), class = "FutureResult")
[17:40:00.298]     }, finally = {
[17:40:00.298]         if (!identical(...future.workdir, getwd())) 
[17:40:00.298]             setwd(...future.workdir)
[17:40:00.298]         {
[17:40:00.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:00.298]                 ...future.oldOptions$nwarnings <- NULL
[17:40:00.298]             }
[17:40:00.298]             base::options(...future.oldOptions)
[17:40:00.298]             if (.Platform$OS.type == "windows") {
[17:40:00.298]                 old_names <- names(...future.oldEnvVars)
[17:40:00.298]                 envs <- base::Sys.getenv()
[17:40:00.298]                 names <- names(envs)
[17:40:00.298]                 common <- intersect(names, old_names)
[17:40:00.298]                 added <- setdiff(names, old_names)
[17:40:00.298]                 removed <- setdiff(old_names, names)
[17:40:00.298]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:00.298]                   envs[common]]
[17:40:00.298]                 NAMES <- toupper(changed)
[17:40:00.298]                 args <- list()
[17:40:00.298]                 for (kk in seq_along(NAMES)) {
[17:40:00.298]                   name <- changed[[kk]]
[17:40:00.298]                   NAME <- NAMES[[kk]]
[17:40:00.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.298]                     next
[17:40:00.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.298]                 }
[17:40:00.298]                 NAMES <- toupper(added)
[17:40:00.298]                 for (kk in seq_along(NAMES)) {
[17:40:00.298]                   name <- added[[kk]]
[17:40:00.298]                   NAME <- NAMES[[kk]]
[17:40:00.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.298]                     next
[17:40:00.298]                   args[[name]] <- ""
[17:40:00.298]                 }
[17:40:00.298]                 NAMES <- toupper(removed)
[17:40:00.298]                 for (kk in seq_along(NAMES)) {
[17:40:00.298]                   name <- removed[[kk]]
[17:40:00.298]                   NAME <- NAMES[[kk]]
[17:40:00.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.298]                     next
[17:40:00.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.298]                 }
[17:40:00.298]                 if (length(args) > 0) 
[17:40:00.298]                   base::do.call(base::Sys.setenv, args = args)
[17:40:00.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:00.298]             }
[17:40:00.298]             else {
[17:40:00.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:00.298]             }
[17:40:00.298]             {
[17:40:00.298]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:00.298]                   0L) {
[17:40:00.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:00.298]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:00.298]                   base::options(opts)
[17:40:00.298]                 }
[17:40:00.298]                 {
[17:40:00.298]                   {
[17:40:00.298]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:00.298]                     NULL
[17:40:00.298]                   }
[17:40:00.298]                   options(future.plan = NULL)
[17:40:00.298]                   if (is.na(NA_character_)) 
[17:40:00.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:00.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:00.298]                     .init = FALSE)
[17:40:00.298]                 }
[17:40:00.298]             }
[17:40:00.298]         }
[17:40:00.298]     })
[17:40:00.298]     if (TRUE) {
[17:40:00.298]         base::sink(type = "output", split = FALSE)
[17:40:00.298]         if (TRUE) {
[17:40:00.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:00.298]         }
[17:40:00.298]         else {
[17:40:00.298]             ...future.result["stdout"] <- base::list(NULL)
[17:40:00.298]         }
[17:40:00.298]         base::close(...future.stdout)
[17:40:00.298]         ...future.stdout <- NULL
[17:40:00.298]     }
[17:40:00.298]     ...future.result$conditions <- ...future.conditions
[17:40:00.298]     ...future.result$finished <- base::Sys.time()
[17:40:00.298]     ...future.result
[17:40:00.298] }
[17:40:00.301] MultisessionFuture started
[17:40:00.301] - Launch lazy future ... done
[17:40:00.301] run() for ‘MultisessionFuture’ ... done
[17:40:00.302] result() for ClusterFuture ...
[17:40:00.302] receiveMessageFromWorker() for ClusterFuture ...
[17:40:00.302] - Validating connection of MultisessionFuture
[17:40:00.346] - received message: FutureResult
[17:40:00.346] - Received FutureResult
[17:40:00.346] - Erased future from FutureRegistry
[17:40:00.347] result() for ClusterFuture ...
[17:40:00.347] - result already collected: FutureResult
[17:40:00.347] result() for ClusterFuture ... done
[17:40:00.347] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:00.347] result() for ClusterFuture ... done
[17:40:00.347] result() for ClusterFuture ...
[17:40:00.347] - result already collected: FutureResult
[17:40:00.347] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:40:00.348] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:40:00.348] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:40:00.349] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:40:00.349] Searching for globals ... DONE
[17:40:00.349] Resolving globals: TRUE
[17:40:00.350] Resolving any globals that are futures ...
[17:40:00.350] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:40:00.350] Resolving any globals that are futures ... DONE
[17:40:00.350] Resolving futures part of globals (recursively) ...
[17:40:00.350] resolve() on list ...
[17:40:00.350]  recursive: 99
[17:40:00.350]  length: 1
[17:40:00.351]  elements: ‘x’
[17:40:00.351]  length: 0 (resolved future 1)
[17:40:00.351] resolve() on list ... DONE
[17:40:00.351] - globals: [1] ‘x’
[17:40:00.351] Resolving futures part of globals (recursively) ... DONE
[17:40:00.351] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:00.351] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:40:00.352] - globals: [1] ‘x’
[17:40:00.352] 
[17:40:00.352] getGlobalsAndPackages() ... DONE
[17:40:00.352] run() for ‘Future’ ...
[17:40:00.352] - state: ‘created’
[17:40:00.352] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:00.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:00.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:00.366]   - Field: ‘node’
[17:40:00.366]   - Field: ‘label’
[17:40:00.366]   - Field: ‘local’
[17:40:00.367]   - Field: ‘owner’
[17:40:00.367]   - Field: ‘envir’
[17:40:00.367]   - Field: ‘workers’
[17:40:00.367]   - Field: ‘packages’
[17:40:00.367]   - Field: ‘gc’
[17:40:00.367]   - Field: ‘conditions’
[17:40:00.367]   - Field: ‘persistent’
[17:40:00.367]   - Field: ‘expr’
[17:40:00.367]   - Field: ‘uuid’
[17:40:00.367]   - Field: ‘seed’
[17:40:00.367]   - Field: ‘version’
[17:40:00.368]   - Field: ‘result’
[17:40:00.368]   - Field: ‘asynchronous’
[17:40:00.368]   - Field: ‘calls’
[17:40:00.368]   - Field: ‘globals’
[17:40:00.368]   - Field: ‘stdout’
[17:40:00.368]   - Field: ‘earlySignal’
[17:40:00.368]   - Field: ‘lazy’
[17:40:00.368]   - Field: ‘state’
[17:40:00.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:00.368] - Launch lazy future ...
[17:40:00.369] Packages needed by the future expression (n = 0): <none>
[17:40:00.369] Packages needed by future strategies (n = 0): <none>
[17:40:00.369] {
[17:40:00.369]     {
[17:40:00.369]         {
[17:40:00.369]             ...future.startTime <- base::Sys.time()
[17:40:00.369]             {
[17:40:00.369]                 {
[17:40:00.369]                   {
[17:40:00.369]                     {
[17:40:00.369]                       base::local({
[17:40:00.369]                         has_future <- base::requireNamespace("future", 
[17:40:00.369]                           quietly = TRUE)
[17:40:00.369]                         if (has_future) {
[17:40:00.369]                           ns <- base::getNamespace("future")
[17:40:00.369]                           version <- ns[[".package"]][["version"]]
[17:40:00.369]                           if (is.null(version)) 
[17:40:00.369]                             version <- utils::packageVersion("future")
[17:40:00.369]                         }
[17:40:00.369]                         else {
[17:40:00.369]                           version <- NULL
[17:40:00.369]                         }
[17:40:00.369]                         if (!has_future || version < "1.8.0") {
[17:40:00.369]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:00.369]                             "", base::R.version$version.string), 
[17:40:00.369]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:00.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:00.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:00.369]                               "release", "version")], collapse = " "), 
[17:40:00.369]                             hostname = base::Sys.info()[["nodename"]])
[17:40:00.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:00.369]                             info)
[17:40:00.369]                           info <- base::paste(info, collapse = "; ")
[17:40:00.369]                           if (!has_future) {
[17:40:00.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:00.369]                               info)
[17:40:00.369]                           }
[17:40:00.369]                           else {
[17:40:00.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:00.369]                               info, version)
[17:40:00.369]                           }
[17:40:00.369]                           base::stop(msg)
[17:40:00.369]                         }
[17:40:00.369]                       })
[17:40:00.369]                     }
[17:40:00.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:00.369]                     base::options(mc.cores = 1L)
[17:40:00.369]                   }
[17:40:00.369]                   ...future.strategy.old <- future::plan("list")
[17:40:00.369]                   options(future.plan = NULL)
[17:40:00.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:00.369]                 }
[17:40:00.369]                 ...future.workdir <- getwd()
[17:40:00.369]             }
[17:40:00.369]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:00.369]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:00.369]         }
[17:40:00.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:40:00.369]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:40:00.369]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:40:00.369]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:40:00.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:00.369]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:00.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:00.369]             base::names(...future.oldOptions))
[17:40:00.369]     }
[17:40:00.369]     if (FALSE) {
[17:40:00.369]     }
[17:40:00.369]     else {
[17:40:00.369]         if (TRUE) {
[17:40:00.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:00.369]                 open = "w")
[17:40:00.369]         }
[17:40:00.369]         else {
[17:40:00.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:00.369]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:00.369]         }
[17:40:00.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:00.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:00.369]             base::sink(type = "output", split = FALSE)
[17:40:00.369]             base::close(...future.stdout)
[17:40:00.369]         }, add = TRUE)
[17:40:00.369]     }
[17:40:00.369]     ...future.frame <- base::sys.nframe()
[17:40:00.369]     ...future.conditions <- base::list()
[17:40:00.369]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:00.369]     if (FALSE) {
[17:40:00.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:00.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:00.369]     }
[17:40:00.369]     ...future.result <- base::tryCatch({
[17:40:00.369]         base::withCallingHandlers({
[17:40:00.369]             ...future.value <- base::withVisible(base::local({
[17:40:00.369]                 ...future.makeSendCondition <- base::local({
[17:40:00.369]                   sendCondition <- NULL
[17:40:00.369]                   function(frame = 1L) {
[17:40:00.369]                     if (is.function(sendCondition)) 
[17:40:00.369]                       return(sendCondition)
[17:40:00.369]                     ns <- getNamespace("parallel")
[17:40:00.369]                     if (exists("sendData", mode = "function", 
[17:40:00.369]                       envir = ns)) {
[17:40:00.369]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:00.369]                         envir = ns)
[17:40:00.369]                       envir <- sys.frame(frame)
[17:40:00.369]                       master <- NULL
[17:40:00.369]                       while (!identical(envir, .GlobalEnv) && 
[17:40:00.369]                         !identical(envir, emptyenv())) {
[17:40:00.369]                         if (exists("master", mode = "list", envir = envir, 
[17:40:00.369]                           inherits = FALSE)) {
[17:40:00.369]                           master <- get("master", mode = "list", 
[17:40:00.369]                             envir = envir, inherits = FALSE)
[17:40:00.369]                           if (inherits(master, c("SOCKnode", 
[17:40:00.369]                             "SOCK0node"))) {
[17:40:00.369]                             sendCondition <<- function(cond) {
[17:40:00.369]                               data <- list(type = "VALUE", value = cond, 
[17:40:00.369]                                 success = TRUE)
[17:40:00.369]                               parallel_sendData(master, data)
[17:40:00.369]                             }
[17:40:00.369]                             return(sendCondition)
[17:40:00.369]                           }
[17:40:00.369]                         }
[17:40:00.369]                         frame <- frame + 1L
[17:40:00.369]                         envir <- sys.frame(frame)
[17:40:00.369]                       }
[17:40:00.369]                     }
[17:40:00.369]                     sendCondition <<- function(cond) NULL
[17:40:00.369]                   }
[17:40:00.369]                 })
[17:40:00.369]                 withCallingHandlers({
[17:40:00.369]                   {
[17:40:00.369]                     x <- x + 1
[17:40:00.369]                     x
[17:40:00.369]                   }
[17:40:00.369]                 }, immediateCondition = function(cond) {
[17:40:00.369]                   sendCondition <- ...future.makeSendCondition()
[17:40:00.369]                   sendCondition(cond)
[17:40:00.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.369]                   {
[17:40:00.369]                     inherits <- base::inherits
[17:40:00.369]                     invokeRestart <- base::invokeRestart
[17:40:00.369]                     is.null <- base::is.null
[17:40:00.369]                     muffled <- FALSE
[17:40:00.369]                     if (inherits(cond, "message")) {
[17:40:00.369]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:00.369]                       if (muffled) 
[17:40:00.369]                         invokeRestart("muffleMessage")
[17:40:00.369]                     }
[17:40:00.369]                     else if (inherits(cond, "warning")) {
[17:40:00.369]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:00.369]                       if (muffled) 
[17:40:00.369]                         invokeRestart("muffleWarning")
[17:40:00.369]                     }
[17:40:00.369]                     else if (inherits(cond, "condition")) {
[17:40:00.369]                       if (!is.null(pattern)) {
[17:40:00.369]                         computeRestarts <- base::computeRestarts
[17:40:00.369]                         grepl <- base::grepl
[17:40:00.369]                         restarts <- computeRestarts(cond)
[17:40:00.369]                         for (restart in restarts) {
[17:40:00.369]                           name <- restart$name
[17:40:00.369]                           if (is.null(name)) 
[17:40:00.369]                             next
[17:40:00.369]                           if (!grepl(pattern, name)) 
[17:40:00.369]                             next
[17:40:00.369]                           invokeRestart(restart)
[17:40:00.369]                           muffled <- TRUE
[17:40:00.369]                           break
[17:40:00.369]                         }
[17:40:00.369]                       }
[17:40:00.369]                     }
[17:40:00.369]                     invisible(muffled)
[17:40:00.369]                   }
[17:40:00.369]                   muffleCondition(cond)
[17:40:00.369]                 })
[17:40:00.369]             }))
[17:40:00.369]             future::FutureResult(value = ...future.value$value, 
[17:40:00.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.369]                   ...future.rng), globalenv = if (FALSE) 
[17:40:00.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:00.369]                     ...future.globalenv.names))
[17:40:00.369]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:00.369]         }, condition = base::local({
[17:40:00.369]             c <- base::c
[17:40:00.369]             inherits <- base::inherits
[17:40:00.369]             invokeRestart <- base::invokeRestart
[17:40:00.369]             length <- base::length
[17:40:00.369]             list <- base::list
[17:40:00.369]             seq.int <- base::seq.int
[17:40:00.369]             signalCondition <- base::signalCondition
[17:40:00.369]             sys.calls <- base::sys.calls
[17:40:00.369]             `[[` <- base::`[[`
[17:40:00.369]             `+` <- base::`+`
[17:40:00.369]             `<<-` <- base::`<<-`
[17:40:00.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:00.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:00.369]                   3L)]
[17:40:00.369]             }
[17:40:00.369]             function(cond) {
[17:40:00.369]                 is_error <- inherits(cond, "error")
[17:40:00.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:00.369]                   NULL)
[17:40:00.369]                 if (is_error) {
[17:40:00.369]                   sessionInformation <- function() {
[17:40:00.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:00.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:00.369]                       search = base::search(), system = base::Sys.info())
[17:40:00.369]                   }
[17:40:00.369]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:00.369]                     cond$call), session = sessionInformation(), 
[17:40:00.369]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:00.369]                   signalCondition(cond)
[17:40:00.369]                 }
[17:40:00.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:00.369]                 "immediateCondition"))) {
[17:40:00.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:00.369]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:00.369]                   if (TRUE && !signal) {
[17:40:00.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.369]                     {
[17:40:00.369]                       inherits <- base::inherits
[17:40:00.369]                       invokeRestart <- base::invokeRestart
[17:40:00.369]                       is.null <- base::is.null
[17:40:00.369]                       muffled <- FALSE
[17:40:00.369]                       if (inherits(cond, "message")) {
[17:40:00.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.369]                         if (muffled) 
[17:40:00.369]                           invokeRestart("muffleMessage")
[17:40:00.369]                       }
[17:40:00.369]                       else if (inherits(cond, "warning")) {
[17:40:00.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.369]                         if (muffled) 
[17:40:00.369]                           invokeRestart("muffleWarning")
[17:40:00.369]                       }
[17:40:00.369]                       else if (inherits(cond, "condition")) {
[17:40:00.369]                         if (!is.null(pattern)) {
[17:40:00.369]                           computeRestarts <- base::computeRestarts
[17:40:00.369]                           grepl <- base::grepl
[17:40:00.369]                           restarts <- computeRestarts(cond)
[17:40:00.369]                           for (restart in restarts) {
[17:40:00.369]                             name <- restart$name
[17:40:00.369]                             if (is.null(name)) 
[17:40:00.369]                               next
[17:40:00.369]                             if (!grepl(pattern, name)) 
[17:40:00.369]                               next
[17:40:00.369]                             invokeRestart(restart)
[17:40:00.369]                             muffled <- TRUE
[17:40:00.369]                             break
[17:40:00.369]                           }
[17:40:00.369]                         }
[17:40:00.369]                       }
[17:40:00.369]                       invisible(muffled)
[17:40:00.369]                     }
[17:40:00.369]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.369]                   }
[17:40:00.369]                 }
[17:40:00.369]                 else {
[17:40:00.369]                   if (TRUE) {
[17:40:00.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.369]                     {
[17:40:00.369]                       inherits <- base::inherits
[17:40:00.369]                       invokeRestart <- base::invokeRestart
[17:40:00.369]                       is.null <- base::is.null
[17:40:00.369]                       muffled <- FALSE
[17:40:00.369]                       if (inherits(cond, "message")) {
[17:40:00.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.369]                         if (muffled) 
[17:40:00.369]                           invokeRestart("muffleMessage")
[17:40:00.369]                       }
[17:40:00.369]                       else if (inherits(cond, "warning")) {
[17:40:00.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.369]                         if (muffled) 
[17:40:00.369]                           invokeRestart("muffleWarning")
[17:40:00.369]                       }
[17:40:00.369]                       else if (inherits(cond, "condition")) {
[17:40:00.369]                         if (!is.null(pattern)) {
[17:40:00.369]                           computeRestarts <- base::computeRestarts
[17:40:00.369]                           grepl <- base::grepl
[17:40:00.369]                           restarts <- computeRestarts(cond)
[17:40:00.369]                           for (restart in restarts) {
[17:40:00.369]                             name <- restart$name
[17:40:00.369]                             if (is.null(name)) 
[17:40:00.369]                               next
[17:40:00.369]                             if (!grepl(pattern, name)) 
[17:40:00.369]                               next
[17:40:00.369]                             invokeRestart(restart)
[17:40:00.369]                             muffled <- TRUE
[17:40:00.369]                             break
[17:40:00.369]                           }
[17:40:00.369]                         }
[17:40:00.369]                       }
[17:40:00.369]                       invisible(muffled)
[17:40:00.369]                     }
[17:40:00.369]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.369]                   }
[17:40:00.369]                 }
[17:40:00.369]             }
[17:40:00.369]         }))
[17:40:00.369]     }, error = function(ex) {
[17:40:00.369]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:00.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.369]                 ...future.rng), started = ...future.startTime, 
[17:40:00.369]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:00.369]             version = "1.8"), class = "FutureResult")
[17:40:00.369]     }, finally = {
[17:40:00.369]         if (!identical(...future.workdir, getwd())) 
[17:40:00.369]             setwd(...future.workdir)
[17:40:00.369]         {
[17:40:00.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:00.369]                 ...future.oldOptions$nwarnings <- NULL
[17:40:00.369]             }
[17:40:00.369]             base::options(...future.oldOptions)
[17:40:00.369]             if (.Platform$OS.type == "windows") {
[17:40:00.369]                 old_names <- names(...future.oldEnvVars)
[17:40:00.369]                 envs <- base::Sys.getenv()
[17:40:00.369]                 names <- names(envs)
[17:40:00.369]                 common <- intersect(names, old_names)
[17:40:00.369]                 added <- setdiff(names, old_names)
[17:40:00.369]                 removed <- setdiff(old_names, names)
[17:40:00.369]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:00.369]                   envs[common]]
[17:40:00.369]                 NAMES <- toupper(changed)
[17:40:00.369]                 args <- list()
[17:40:00.369]                 for (kk in seq_along(NAMES)) {
[17:40:00.369]                   name <- changed[[kk]]
[17:40:00.369]                   NAME <- NAMES[[kk]]
[17:40:00.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.369]                     next
[17:40:00.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.369]                 }
[17:40:00.369]                 NAMES <- toupper(added)
[17:40:00.369]                 for (kk in seq_along(NAMES)) {
[17:40:00.369]                   name <- added[[kk]]
[17:40:00.369]                   NAME <- NAMES[[kk]]
[17:40:00.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.369]                     next
[17:40:00.369]                   args[[name]] <- ""
[17:40:00.369]                 }
[17:40:00.369]                 NAMES <- toupper(removed)
[17:40:00.369]                 for (kk in seq_along(NAMES)) {
[17:40:00.369]                   name <- removed[[kk]]
[17:40:00.369]                   NAME <- NAMES[[kk]]
[17:40:00.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.369]                     next
[17:40:00.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.369]                 }
[17:40:00.369]                 if (length(args) > 0) 
[17:40:00.369]                   base::do.call(base::Sys.setenv, args = args)
[17:40:00.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:00.369]             }
[17:40:00.369]             else {
[17:40:00.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:00.369]             }
[17:40:00.369]             {
[17:40:00.369]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:00.369]                   0L) {
[17:40:00.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:00.369]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:00.369]                   base::options(opts)
[17:40:00.369]                 }
[17:40:00.369]                 {
[17:40:00.369]                   {
[17:40:00.369]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:00.369]                     NULL
[17:40:00.369]                   }
[17:40:00.369]                   options(future.plan = NULL)
[17:40:00.369]                   if (is.na(NA_character_)) 
[17:40:00.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:00.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:00.369]                     .init = FALSE)
[17:40:00.369]                 }
[17:40:00.369]             }
[17:40:00.369]         }
[17:40:00.369]     })
[17:40:00.369]     if (TRUE) {
[17:40:00.369]         base::sink(type = "output", split = FALSE)
[17:40:00.369]         if (TRUE) {
[17:40:00.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:00.369]         }
[17:40:00.369]         else {
[17:40:00.369]             ...future.result["stdout"] <- base::list(NULL)
[17:40:00.369]         }
[17:40:00.369]         base::close(...future.stdout)
[17:40:00.369]         ...future.stdout <- NULL
[17:40:00.369]     }
[17:40:00.369]     ...future.result$conditions <- ...future.conditions
[17:40:00.369]     ...future.result$finished <- base::Sys.time()
[17:40:00.369]     ...future.result
[17:40:00.369] }
[17:40:00.372] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:40:00.372] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:40:00.372] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:40:00.372] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:40:00.373] MultisessionFuture started
[17:40:00.373] - Launch lazy future ... done
[17:40:00.373] run() for ‘MultisessionFuture’ ... done
[17:40:00.373] result() for ClusterFuture ...
[17:40:00.373] receiveMessageFromWorker() for ClusterFuture ...
[17:40:00.373] - Validating connection of MultisessionFuture
[17:40:00.418] - received message: FutureResult
[17:40:00.418] - Received FutureResult
[17:40:00.418] - Erased future from FutureRegistry
[17:40:00.418] result() for ClusterFuture ...
[17:40:00.419] - result already collected: FutureResult
[17:40:00.419] result() for ClusterFuture ... done
[17:40:00.419] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:00.419] result() for ClusterFuture ... done
[17:40:00.419] result() for ClusterFuture ...
[17:40:00.419] - result already collected: FutureResult
[17:40:00.419] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:40:00.419] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:40:00.420] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:40:00.421] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:40:00.421] Searching for globals ... DONE
[17:40:00.421] Resolving globals: TRUE
[17:40:00.421] Resolving any globals that are futures ...
[17:40:00.422] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:40:00.422] Resolving any globals that are futures ... DONE
[17:40:00.422] Resolving futures part of globals (recursively) ...
[17:40:00.422] resolve() on list ...
[17:40:00.422]  recursive: 99
[17:40:00.422]  length: 1
[17:40:00.422]  elements: ‘x’
[17:40:00.423]  length: 0 (resolved future 1)
[17:40:00.423] resolve() on list ... DONE
[17:40:00.423] - globals: [1] ‘x’
[17:40:00.423] Resolving futures part of globals (recursively) ... DONE
[17:40:00.423] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:40:00.424] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:40:00.424] - globals: [1] ‘x’
[17:40:00.424] 
[17:40:00.425] getGlobalsAndPackages() ... DONE
[17:40:00.425] run() for ‘Future’ ...
[17:40:00.425] - state: ‘created’
[17:40:00.425] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:00.440] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:00.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:00.441]   - Field: ‘node’
[17:40:00.441]   - Field: ‘label’
[17:40:00.441]   - Field: ‘local’
[17:40:00.441]   - Field: ‘owner’
[17:40:00.441]   - Field: ‘envir’
[17:40:00.441]   - Field: ‘workers’
[17:40:00.441]   - Field: ‘packages’
[17:40:00.441]   - Field: ‘gc’
[17:40:00.441]   - Field: ‘conditions’
[17:40:00.441]   - Field: ‘persistent’
[17:40:00.442]   - Field: ‘expr’
[17:40:00.442]   - Field: ‘uuid’
[17:40:00.442]   - Field: ‘seed’
[17:40:00.442]   - Field: ‘version’
[17:40:00.442]   - Field: ‘result’
[17:40:00.442]   - Field: ‘asynchronous’
[17:40:00.442]   - Field: ‘calls’
[17:40:00.442]   - Field: ‘globals’
[17:40:00.442]   - Field: ‘stdout’
[17:40:00.442]   - Field: ‘earlySignal’
[17:40:00.442]   - Field: ‘lazy’
[17:40:00.443]   - Field: ‘state’
[17:40:00.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:00.443] - Launch lazy future ...
[17:40:00.443] Packages needed by the future expression (n = 0): <none>
[17:40:00.443] Packages needed by future strategies (n = 0): <none>
[17:40:00.443] {
[17:40:00.443]     {
[17:40:00.443]         {
[17:40:00.443]             ...future.startTime <- base::Sys.time()
[17:40:00.443]             {
[17:40:00.443]                 {
[17:40:00.443]                   {
[17:40:00.443]                     {
[17:40:00.443]                       base::local({
[17:40:00.443]                         has_future <- base::requireNamespace("future", 
[17:40:00.443]                           quietly = TRUE)
[17:40:00.443]                         if (has_future) {
[17:40:00.443]                           ns <- base::getNamespace("future")
[17:40:00.443]                           version <- ns[[".package"]][["version"]]
[17:40:00.443]                           if (is.null(version)) 
[17:40:00.443]                             version <- utils::packageVersion("future")
[17:40:00.443]                         }
[17:40:00.443]                         else {
[17:40:00.443]                           version <- NULL
[17:40:00.443]                         }
[17:40:00.443]                         if (!has_future || version < "1.8.0") {
[17:40:00.443]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:00.443]                             "", base::R.version$version.string), 
[17:40:00.443]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:00.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:00.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:00.443]                               "release", "version")], collapse = " "), 
[17:40:00.443]                             hostname = base::Sys.info()[["nodename"]])
[17:40:00.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:00.443]                             info)
[17:40:00.443]                           info <- base::paste(info, collapse = "; ")
[17:40:00.443]                           if (!has_future) {
[17:40:00.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:00.443]                               info)
[17:40:00.443]                           }
[17:40:00.443]                           else {
[17:40:00.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:00.443]                               info, version)
[17:40:00.443]                           }
[17:40:00.443]                           base::stop(msg)
[17:40:00.443]                         }
[17:40:00.443]                       })
[17:40:00.443]                     }
[17:40:00.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:00.443]                     base::options(mc.cores = 1L)
[17:40:00.443]                   }
[17:40:00.443]                   ...future.strategy.old <- future::plan("list")
[17:40:00.443]                   options(future.plan = NULL)
[17:40:00.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:00.443]                 }
[17:40:00.443]                 ...future.workdir <- getwd()
[17:40:00.443]             }
[17:40:00.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:00.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:00.443]         }
[17:40:00.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:40:00.443]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:40:00.443]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:40:00.443]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:40:00.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:00.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:00.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:00.443]             base::names(...future.oldOptions))
[17:40:00.443]     }
[17:40:00.443]     if (FALSE) {
[17:40:00.443]     }
[17:40:00.443]     else {
[17:40:00.443]         if (TRUE) {
[17:40:00.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:00.443]                 open = "w")
[17:40:00.443]         }
[17:40:00.443]         else {
[17:40:00.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:00.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:00.443]         }
[17:40:00.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:00.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:00.443]             base::sink(type = "output", split = FALSE)
[17:40:00.443]             base::close(...future.stdout)
[17:40:00.443]         }, add = TRUE)
[17:40:00.443]     }
[17:40:00.443]     ...future.frame <- base::sys.nframe()
[17:40:00.443]     ...future.conditions <- base::list()
[17:40:00.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:00.443]     if (FALSE) {
[17:40:00.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:00.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:00.443]     }
[17:40:00.443]     ...future.result <- base::tryCatch({
[17:40:00.443]         base::withCallingHandlers({
[17:40:00.443]             ...future.value <- base::withVisible(base::local({
[17:40:00.443]                 ...future.makeSendCondition <- base::local({
[17:40:00.443]                   sendCondition <- NULL
[17:40:00.443]                   function(frame = 1L) {
[17:40:00.443]                     if (is.function(sendCondition)) 
[17:40:00.443]                       return(sendCondition)
[17:40:00.443]                     ns <- getNamespace("parallel")
[17:40:00.443]                     if (exists("sendData", mode = "function", 
[17:40:00.443]                       envir = ns)) {
[17:40:00.443]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:00.443]                         envir = ns)
[17:40:00.443]                       envir <- sys.frame(frame)
[17:40:00.443]                       master <- NULL
[17:40:00.443]                       while (!identical(envir, .GlobalEnv) && 
[17:40:00.443]                         !identical(envir, emptyenv())) {
[17:40:00.443]                         if (exists("master", mode = "list", envir = envir, 
[17:40:00.443]                           inherits = FALSE)) {
[17:40:00.443]                           master <- get("master", mode = "list", 
[17:40:00.443]                             envir = envir, inherits = FALSE)
[17:40:00.443]                           if (inherits(master, c("SOCKnode", 
[17:40:00.443]                             "SOCK0node"))) {
[17:40:00.443]                             sendCondition <<- function(cond) {
[17:40:00.443]                               data <- list(type = "VALUE", value = cond, 
[17:40:00.443]                                 success = TRUE)
[17:40:00.443]                               parallel_sendData(master, data)
[17:40:00.443]                             }
[17:40:00.443]                             return(sendCondition)
[17:40:00.443]                           }
[17:40:00.443]                         }
[17:40:00.443]                         frame <- frame + 1L
[17:40:00.443]                         envir <- sys.frame(frame)
[17:40:00.443]                       }
[17:40:00.443]                     }
[17:40:00.443]                     sendCondition <<- function(cond) NULL
[17:40:00.443]                   }
[17:40:00.443]                 })
[17:40:00.443]                 withCallingHandlers({
[17:40:00.443]                   {
[17:40:00.443]                     x <- x()
[17:40:00.443]                     x
[17:40:00.443]                   }
[17:40:00.443]                 }, immediateCondition = function(cond) {
[17:40:00.443]                   sendCondition <- ...future.makeSendCondition()
[17:40:00.443]                   sendCondition(cond)
[17:40:00.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.443]                   {
[17:40:00.443]                     inherits <- base::inherits
[17:40:00.443]                     invokeRestart <- base::invokeRestart
[17:40:00.443]                     is.null <- base::is.null
[17:40:00.443]                     muffled <- FALSE
[17:40:00.443]                     if (inherits(cond, "message")) {
[17:40:00.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:00.443]                       if (muffled) 
[17:40:00.443]                         invokeRestart("muffleMessage")
[17:40:00.443]                     }
[17:40:00.443]                     else if (inherits(cond, "warning")) {
[17:40:00.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:00.443]                       if (muffled) 
[17:40:00.443]                         invokeRestart("muffleWarning")
[17:40:00.443]                     }
[17:40:00.443]                     else if (inherits(cond, "condition")) {
[17:40:00.443]                       if (!is.null(pattern)) {
[17:40:00.443]                         computeRestarts <- base::computeRestarts
[17:40:00.443]                         grepl <- base::grepl
[17:40:00.443]                         restarts <- computeRestarts(cond)
[17:40:00.443]                         for (restart in restarts) {
[17:40:00.443]                           name <- restart$name
[17:40:00.443]                           if (is.null(name)) 
[17:40:00.443]                             next
[17:40:00.443]                           if (!grepl(pattern, name)) 
[17:40:00.443]                             next
[17:40:00.443]                           invokeRestart(restart)
[17:40:00.443]                           muffled <- TRUE
[17:40:00.443]                           break
[17:40:00.443]                         }
[17:40:00.443]                       }
[17:40:00.443]                     }
[17:40:00.443]                     invisible(muffled)
[17:40:00.443]                   }
[17:40:00.443]                   muffleCondition(cond)
[17:40:00.443]                 })
[17:40:00.443]             }))
[17:40:00.443]             future::FutureResult(value = ...future.value$value, 
[17:40:00.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.443]                   ...future.rng), globalenv = if (FALSE) 
[17:40:00.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:00.443]                     ...future.globalenv.names))
[17:40:00.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:00.443]         }, condition = base::local({
[17:40:00.443]             c <- base::c
[17:40:00.443]             inherits <- base::inherits
[17:40:00.443]             invokeRestart <- base::invokeRestart
[17:40:00.443]             length <- base::length
[17:40:00.443]             list <- base::list
[17:40:00.443]             seq.int <- base::seq.int
[17:40:00.443]             signalCondition <- base::signalCondition
[17:40:00.443]             sys.calls <- base::sys.calls
[17:40:00.443]             `[[` <- base::`[[`
[17:40:00.443]             `+` <- base::`+`
[17:40:00.443]             `<<-` <- base::`<<-`
[17:40:00.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:00.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:00.443]                   3L)]
[17:40:00.443]             }
[17:40:00.443]             function(cond) {
[17:40:00.443]                 is_error <- inherits(cond, "error")
[17:40:00.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:00.443]                   NULL)
[17:40:00.443]                 if (is_error) {
[17:40:00.443]                   sessionInformation <- function() {
[17:40:00.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:00.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:00.443]                       search = base::search(), system = base::Sys.info())
[17:40:00.443]                   }
[17:40:00.443]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:00.443]                     cond$call), session = sessionInformation(), 
[17:40:00.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:00.443]                   signalCondition(cond)
[17:40:00.443]                 }
[17:40:00.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:00.443]                 "immediateCondition"))) {
[17:40:00.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:00.443]                   ...future.conditions[[length(...future.conditions) + 
[17:40:00.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:00.443]                   if (TRUE && !signal) {
[17:40:00.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.443]                     {
[17:40:00.443]                       inherits <- base::inherits
[17:40:00.443]                       invokeRestart <- base::invokeRestart
[17:40:00.443]                       is.null <- base::is.null
[17:40:00.443]                       muffled <- FALSE
[17:40:00.443]                       if (inherits(cond, "message")) {
[17:40:00.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.443]                         if (muffled) 
[17:40:00.443]                           invokeRestart("muffleMessage")
[17:40:00.443]                       }
[17:40:00.443]                       else if (inherits(cond, "warning")) {
[17:40:00.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.443]                         if (muffled) 
[17:40:00.443]                           invokeRestart("muffleWarning")
[17:40:00.443]                       }
[17:40:00.443]                       else if (inherits(cond, "condition")) {
[17:40:00.443]                         if (!is.null(pattern)) {
[17:40:00.443]                           computeRestarts <- base::computeRestarts
[17:40:00.443]                           grepl <- base::grepl
[17:40:00.443]                           restarts <- computeRestarts(cond)
[17:40:00.443]                           for (restart in restarts) {
[17:40:00.443]                             name <- restart$name
[17:40:00.443]                             if (is.null(name)) 
[17:40:00.443]                               next
[17:40:00.443]                             if (!grepl(pattern, name)) 
[17:40:00.443]                               next
[17:40:00.443]                             invokeRestart(restart)
[17:40:00.443]                             muffled <- TRUE
[17:40:00.443]                             break
[17:40:00.443]                           }
[17:40:00.443]                         }
[17:40:00.443]                       }
[17:40:00.443]                       invisible(muffled)
[17:40:00.443]                     }
[17:40:00.443]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.443]                   }
[17:40:00.443]                 }
[17:40:00.443]                 else {
[17:40:00.443]                   if (TRUE) {
[17:40:00.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:00.443]                     {
[17:40:00.443]                       inherits <- base::inherits
[17:40:00.443]                       invokeRestart <- base::invokeRestart
[17:40:00.443]                       is.null <- base::is.null
[17:40:00.443]                       muffled <- FALSE
[17:40:00.443]                       if (inherits(cond, "message")) {
[17:40:00.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:00.443]                         if (muffled) 
[17:40:00.443]                           invokeRestart("muffleMessage")
[17:40:00.443]                       }
[17:40:00.443]                       else if (inherits(cond, "warning")) {
[17:40:00.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:00.443]                         if (muffled) 
[17:40:00.443]                           invokeRestart("muffleWarning")
[17:40:00.443]                       }
[17:40:00.443]                       else if (inherits(cond, "condition")) {
[17:40:00.443]                         if (!is.null(pattern)) {
[17:40:00.443]                           computeRestarts <- base::computeRestarts
[17:40:00.443]                           grepl <- base::grepl
[17:40:00.443]                           restarts <- computeRestarts(cond)
[17:40:00.443]                           for (restart in restarts) {
[17:40:00.443]                             name <- restart$name
[17:40:00.443]                             if (is.null(name)) 
[17:40:00.443]                               next
[17:40:00.443]                             if (!grepl(pattern, name)) 
[17:40:00.443]                               next
[17:40:00.443]                             invokeRestart(restart)
[17:40:00.443]                             muffled <- TRUE
[17:40:00.443]                             break
[17:40:00.443]                           }
[17:40:00.443]                         }
[17:40:00.443]                       }
[17:40:00.443]                       invisible(muffled)
[17:40:00.443]                     }
[17:40:00.443]                     muffleCondition(cond, pattern = "^muffle")
[17:40:00.443]                   }
[17:40:00.443]                 }
[17:40:00.443]             }
[17:40:00.443]         }))
[17:40:00.443]     }, error = function(ex) {
[17:40:00.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:00.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:00.443]                 ...future.rng), started = ...future.startTime, 
[17:40:00.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:00.443]             version = "1.8"), class = "FutureResult")
[17:40:00.443]     }, finally = {
[17:40:00.443]         if (!identical(...future.workdir, getwd())) 
[17:40:00.443]             setwd(...future.workdir)
[17:40:00.443]         {
[17:40:00.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:00.443]                 ...future.oldOptions$nwarnings <- NULL
[17:40:00.443]             }
[17:40:00.443]             base::options(...future.oldOptions)
[17:40:00.443]             if (.Platform$OS.type == "windows") {
[17:40:00.443]                 old_names <- names(...future.oldEnvVars)
[17:40:00.443]                 envs <- base::Sys.getenv()
[17:40:00.443]                 names <- names(envs)
[17:40:00.443]                 common <- intersect(names, old_names)
[17:40:00.443]                 added <- setdiff(names, old_names)
[17:40:00.443]                 removed <- setdiff(old_names, names)
[17:40:00.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:00.443]                   envs[common]]
[17:40:00.443]                 NAMES <- toupper(changed)
[17:40:00.443]                 args <- list()
[17:40:00.443]                 for (kk in seq_along(NAMES)) {
[17:40:00.443]                   name <- changed[[kk]]
[17:40:00.443]                   NAME <- NAMES[[kk]]
[17:40:00.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.443]                     next
[17:40:00.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.443]                 }
[17:40:00.443]                 NAMES <- toupper(added)
[17:40:00.443]                 for (kk in seq_along(NAMES)) {
[17:40:00.443]                   name <- added[[kk]]
[17:40:00.443]                   NAME <- NAMES[[kk]]
[17:40:00.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.443]                     next
[17:40:00.443]                   args[[name]] <- ""
[17:40:00.443]                 }
[17:40:00.443]                 NAMES <- toupper(removed)
[17:40:00.443]                 for (kk in seq_along(NAMES)) {
[17:40:00.443]                   name <- removed[[kk]]
[17:40:00.443]                   NAME <- NAMES[[kk]]
[17:40:00.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:00.443]                     next
[17:40:00.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:00.443]                 }
[17:40:00.443]                 if (length(args) > 0) 
[17:40:00.443]                   base::do.call(base::Sys.setenv, args = args)
[17:40:00.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:00.443]             }
[17:40:00.443]             else {
[17:40:00.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:00.443]             }
[17:40:00.443]             {
[17:40:00.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:00.443]                   0L) {
[17:40:00.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:00.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:00.443]                   base::options(opts)
[17:40:00.443]                 }
[17:40:00.443]                 {
[17:40:00.443]                   {
[17:40:00.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:00.443]                     NULL
[17:40:00.443]                   }
[17:40:00.443]                   options(future.plan = NULL)
[17:40:00.443]                   if (is.na(NA_character_)) 
[17:40:00.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:00.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:00.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:00.443]                     .init = FALSE)
[17:40:00.443]                 }
[17:40:00.443]             }
[17:40:00.443]         }
[17:40:00.443]     })
[17:40:00.443]     if (TRUE) {
[17:40:00.443]         base::sink(type = "output", split = FALSE)
[17:40:00.443]         if (TRUE) {
[17:40:00.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:00.443]         }
[17:40:00.443]         else {
[17:40:00.443]             ...future.result["stdout"] <- base::list(NULL)
[17:40:00.443]         }
[17:40:00.443]         base::close(...future.stdout)
[17:40:00.443]         ...future.stdout <- NULL
[17:40:00.443]     }
[17:40:00.443]     ...future.result$conditions <- ...future.conditions
[17:40:00.443]     ...future.result$finished <- base::Sys.time()
[17:40:00.443]     ...future.result
[17:40:00.443] }
[17:40:00.446] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[17:40:00.446] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[17:40:00.446] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[17:40:00.447] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[17:40:00.447] MultisessionFuture started
[17:40:00.447] - Launch lazy future ... done
[17:40:00.447] run() for ‘MultisessionFuture’ ... done
[17:40:00.447] result() for ClusterFuture ...
[17:40:00.447] receiveMessageFromWorker() for ClusterFuture ...
[17:40:00.448] - Validating connection of MultisessionFuture
[17:40:00.490] - received message: FutureResult
[17:40:00.490] - Received FutureResult
[17:40:00.491] - Erased future from FutureRegistry
[17:40:00.491] result() for ClusterFuture ...
[17:40:00.491] - result already collected: FutureResult
[17:40:00.491] result() for ClusterFuture ... done
[17:40:00.491] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:00.491] result() for ClusterFuture ... done
[17:40:00.491] result() for ClusterFuture ...
[17:40:00.491] - result already collected: FutureResult
[17:40:00.491] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[17:40:00.492] plan(): Setting new future strategy stack:
[17:40:00.492] List of future strategies:
[17:40:00.492] 1. FutureStrategy:
[17:40:00.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:00.492]    - tweaked: FALSE
[17:40:00.492]    - call: future::plan(oplan)
[17:40:00.493] plan(): nbrOfWorkers() = 1
> 
